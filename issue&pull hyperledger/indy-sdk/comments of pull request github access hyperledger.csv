pull request url html,pull request url,body,commit_id,create at,id,diff_hunk,position,update at,url,html url,user
https://github.com/hyperledger/indy-sdk/pull/1546,https://github.com/hyperledger/indy-sdk/pull/1546,"Unless I am missing something, the way IndySDK is currently designed requires prover to receive credential offer, before credential request can be submitted by prover. It seems from the diagram like this restriction will stay. Why?
If I have connections with an institution, it seems natural that I should be able to request something from them. 

In my organization we've implemented credential exchange prototype between mobile app/backend on top of IndySDK without VCX. We basically ended up with equivalent of something like ""request credential offer"" message type. Did we miss something? 
Aditionally we've also implemented some API on issuer side which enabled the receiving side to ask issuer what kind of credentials can he issue. So that was typically the API the credential requester called first. Once he knew what's there to be offered, he would send ""request credential offer"" message asking for a kind of credential. The issuer decided whether the requester is ""eligible"" to get such credential based some non-indy application logic/data.
Did we not ""get"" something about IndySDK design? Is/will be flow of an agent directly requesting other agent for specific type of credential supported?
",7f5f50a075965fd676535ca5ac4055beeb1cc3a0,2019-03-25 12:09:28,268609456,"@@ -0,0 +1,656 @@
+# A2A part of IndySDK 2.0
+
+Author: Sergey Minaev, Matt Raffel, Artem Ivanov
+
+## Table of contents
+
+* [Motivation](#motivation)
+* [Goals](#goals-and-ideas)
+* [Overview](#overview)
+* [Discussion points](#discussion-points)
+* [Challenges](#challenges)
+* [IndySDK 2.0 structure](#indySDK-2-0-structure)
+* [Message Families & Messages](#message-families-&-messages)
+    * [Connection](#connection)
+    * [Credential Issuance](#credential-issuance)
+    * [Credential Presentation](#credential-presentation)
+* [API proposal](#api-proposal)
+    * [Namespaces](#namespaces)
+    * [Connection](#api-connection)
+    * [Credential Issuance](#api-credential-issuance)
+    * [Credential Presentation](#api-credential-presentation)
+* [Additional References](#additional-references)
+
+## Motivation
+[See](https://docs.google.com/document/d/1TTwGUtZ3vMvi8dXGB5lprxVvt6Da2___QuqCiyntdXs)
+
+## Goals and ideas
+
+New API of IndySDK should provide functionality for A2A communication but should not make assumptions about app business logic, transport, storage, etc.
+
+* Allow extending LibIndy to support new protocol message families and modifying the implementation.
+* Simplify process of making new message family definitions available in the common Indy ecosystem.
+* Simplify the process of support new agents.
+* Define default protocol message families. 
+* Define State Machine that developer have to follow to support new protocol message families.
+* Define the way LibIndy can consume new API functions.
+* Define the flow of communication Libindy static API, custom Libindy API helpers and an application.
+
+## Overview
+The main idea of new functionality of IndySDK is replace part of VCX library. 
+As for now VCX provide powerful mechanisms for handling Credential Issuance and Exchange flow, 
+but this library hardcode some FSM state transitions, transport flow, etc. New item should provide 
+similar functionality but give the application some flexibility.
+Internal states for particular message family should be more generic and must be aligned for the family definition. 
+The library should not perform any automatic transitions between states. Instead of that it should allows
+ application to perform validation of incoming message, check is it applicable to current state of the family flow. 
+ Actual transition between states should be performed by explicit call from application side.
+
+Current VCX will be moved out from HL/indy-sdk repo to Evernym or SF repo and most probably will have the same 
+API as for now.
+
+
+## Discussion points
+
+* How to allow (for external developer) to extend the set of supported message families:
+    * Proved some template files inside monolith library to copy paste, implement new message family and include to custom build.
+* What is the right place for new functionality: 
+    * Lbindy - suggested for start. It will simplify CI/CD flow significantly.
+        Message families may be implemented under cargo features so it will be possible to configure set of API for particular application.
+    * separate library
+    * something else
+* What is the right place for wrappers.
+* What should the API does:
+    * Should it include the ability to send reply messages?
+        * There are three possible approaches for Transport:
+            * Application calls framework specific functions.
+            * Pluggable functions defined as a part of Libindy Helpers API.
+            * Callbacks passed to `do step` state machine function and automatically called.
+    * Provide a default transport by providing a restful service handler?
+    * Should indy sdk manage A2A state? And Is state management something indy-sdk can really handle?
+        * New API should cover base states, described in appropriate standards/HIPEs
+* Naming of functions for particular message family helpers.
+* Ways the SDK can help agents with messages: creation, validation, and processing (processing where appropriate, not all cases).
+
+
+## Challenges
+
+Agent-2-Agent communications is highly unstable at this time as most of the HIPEs are still in development.
+
+
+## IndySDK 2.0 structure
+
+* Libindy
+    * Core namespace - current functionality
+    * A2A messages: state machines and helpers
+        * Connection message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * Credential Issuance message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * Credential Presentation message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * ....
+        * Template message family
+            * set of .rs files, excluded from cargo project
+            * Guideline how to implement one more msg family
+* VCX will be renamed and moved out from HL/indy-sdk
+* Wrappers
+* CLI
+
+The proposal is to have set of helpers inside libindy to assists application (or agent framework). 
+This scope will include states of flow for particular Message Family. 
+API will allow to check is it possible to move forward from the flow point of view.
+libindy will contain basic message families that will be used by the majority of agents.
+
+![Components](./components.svg)
+
+## Message Families & Messages
+
+### Connection
+
+#### Message Family
+
+The Connection Message Family consists of the following messages:
+
+* Connection Invite - https://github.com/hyperledger/indy-hipe/pull/54
+* Connection Request
+* Connection Response
+* Basic Message - https://github.com/hyperledger/indy-hipe/tree/master/text/0033-basic-message
+* State
+* State Request
+* Trust Ping - https://github.com/hyperledger/indy-hipe/tree/master/text/0032-trust-ping
+* (TBD) Ephemeral Challenge - https://github.com/hyperledger/indy-hipe/pull/95
+* (TBD) Oauth ephemeral - https://github.com/hyperledger/indy-hipe/pull/96
+
+##### Connection Invite
+TBD
+
+##### Connection Request
+TBD
+
+##### Connection Response
+TBD
+
+##### Basic Message
+TBD
+
+##### State
+TBD
+
+##### State Request
+TBD
+
+##### Trust Ping
+TBD
+
+##### Ephemeral Challenge
+
+TBD
+
+##### Oauth ephemeral
+
+TBD
+
+#### State Machine
+
+Agents need to manage state.  
+Especially between connection invites since connection invites is a multi-step process.   
+
+![State Machine definition](./connection.png)
+
+TBD
+
+#### Workflow
+
+TBD
+
+### Credential Issuance
+
+#### Message Family
+
+The Credential Issuance Message Family consists of the following messages:
+
+* Credential Offer
+* Credential Request
+* Credential Reject
+* Credential
+* Credential Ack
+
+##### Credential Offer
+This message is sent by Issuer to Prover to initiate credential issuance process. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential-offer"",
+    ""@id"": ""<uuid-offer>"",
+    ""cred_def_id"": ""KTwaKJkvyjKKf55uc6U8ZB:3:CL:59:tag1"",
+    ""comment"": ""some comment"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred-offer"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        },
+        {
+            ""nickname"": ""credential-preview"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        }
+    ]
+}
+```
+
+Description of fields:
+* `comment` - a field that provide some human readable information about this Credential Offer.
+* `cred_def_id` - id cof credential definition for offered credential
+* attachment `libindy-cred-offer` - libindy generated data about credential offer
+* attachment `credential-preview` - preview of credential.
+
+##### Credential Request
+This message is sent in response to Credential Offer by Prover to give needed details for credential issuance.
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential-request"",
+    ""@id"": ""<uuid-request>"",
+    ""cred_def_id"": ""2hoqvcwupRTUNkXn6ArYzs:3:CL:1766"",
+    ""comment"": ""some comment"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred-req"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        },
+        {
+            ""nickname"": ""credential-preview"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        }
+    ]
+}
+```
+
+Description of Fields:
+* `cred_def_id` - Credential Definition ID for requested credential
+* `comment` - a field that provide some human readable information about this Credential Offer.
+* attachment `libindy-cred-req` - libindy generated data that is needed to Issuer to issue a credential.
+* attachment `credential-preview` - optional attachment with preview of credential that Prover wants to get.
+
+##### Credential
+This message contains the credential and sent in responce to Credential Request by Issuer. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential"",
+    ""@id"": ""<uuid-credential>"",
+    ""rev_reg_def_id"": ""<rev_reg_def_id>"",
+    ""cred_def_id"": ""2hoqvcwupRTUNkXn6ArYzs:3:CL:1766"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""  
+            }
+        }
+    ]
+}
+```
+
+Description of fields:
+
+* `rev_reg_def_id` - ID of Revocation Registry Definition this credential were issued to
+* `cred_def_id` - ID of Credential Definition this credential were issued to
+* attachment `libindy-cred` - an actual credential to store, it is a json encoded in base64
+
+##### Credential Reject
+This message can be sent by any side of the conversation to finish credential issuance process without any credential created. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/reject"",
+    ""@id"": ""id""
+}
+```
+
+##### Credential Ack
+This message is sent by Prover as he confirms that he had received the credential and everything is correct. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/ack"",
+    ""@id"": ""id""
+}
+```
+
+#### State Machine
+
+The Credential Issuance State Machine consists of the following states:
+
+* Initialized
+* Issuer related states:
+    * CredentialOfferCreated
+    * CredentialRequestReceived
+    * CredentialCreated
+    * CredentialAckReceived
+* Prover related states:
+    * CredentialOfferReceived
+    * CredentialRequestCreated
+    * CredentialReceived
+    * CredentialAckCreated
+* CredentialRejectCreated
+* CredentialRejectReceived
+* Finished
+
+##### Initialized
+Common state for both parties. Indicates initiation of issuance process.
+Transitions:
+* Issuer
+    * CredentialOfferCreated - issuer acts as an initiator.
+    * CredentialRequestReceived - prover already prepared credential request and sent to issuer (prover acts as an initiator). 
+* Prover
+    * CredentialOfferReceived - prover received Credential Offer message from issuer.
+    * CredentialRequestCreated - prover already has data for request creation and acts as an initiator.
+
+##### CredentialOfferCreated
+Issuer specific state that means that Credential Offer message has been created and sent to Prover.
+Transitions:
+* CredentialRequestReceived - prover replied with Credential Request message.
+* CredentialRejectReceived - prover replied woth Credential Reject message.
+    
+##### CredentialRequestReceived
+Issuer specific state that means that Prover replied with Credential Request message on offer.
+Transitions:
+* CredentialCreated - credential created and sent to prover
+* CredentialRejectCreated - issuer interrupted credential issuance process for some reason.
+
+##### CredentialCreated
+Issuer specific state that means that Credential message has been created and sent to Prover.
+Transitions:
+* CredentialAckReceived - prover accepted credential and replied with Credential Ack message.
+* CredentialRejectReceived - prover rejected credential for some reason.
+    
+##### CredentialAckReceived
+Issuer specific state that means that Prover replied with Credential Ack message on credential.
+Transitions:
+* Finished - credential issuance process is completed.
+
+##### CredentialOfferReceived
+Prover specific state that means that Credential Offer message has been received from Issuer.
+Transitions:
+* CredentialRequestCreated - prover accepted offer and replied with Credential Request message.
+* CredentialRejectCreated - prover rejected credential offer for some reason.
+
+##### CredentialRequestCreated
+Prover specific state that means that Credential Offer message has been accepted and 
+Credential Request message created and sent to Issuer.
+Transitions:
+* CredentialReceived - credential message received from Issuer.
+* CredentialRejectReceived - issuer interrupted issuance process for some reason.
+
+##### CredentialReceived
+Prover specific state that means that Credential message has been received from Issuer.
+Transitions:
+* CredentialAckCreated - prover accepted credential and replied with Credential Ack message.
+* CredentialRejectCreated - prover rejected credential and interrupted issuance process for some reason.
+
+##### CredentialAckCreated
+Prover specific state that means that Credential Ack message created and sent to Issuer.
+Transitions:
+* Finished - credential issuance process is completed.
+
+##### CredentialRejectCreated
+Common state for both parties. Indicates interruption of issuance process.
+Transitions:
+* Finished - credential issuance process is interrupted.
+
+##### CredentialRejectReceived
+Common state for both parties. Indicates interruption of issuance process by opposite side.
+Transitions:
+* Finished - credential issuance process is interrupted.
+
+#### Choreography Diagram
+
+![Choreography Diagram](./credential-issuance.png)
+
+#### Workflow
+
+The Credential Issuance positive workflow is demonstrated on the following diagram:
+
+![Workflow](credential-issuance-positive-flow.svg)",391,2019-03-25 12:09:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/268609456,https://github.com/hyperledger/indy-sdk/pull/1546#discussion_r268609456,Patrik-Stas
https://github.com/hyperledger/indy-sdk/pull/1546,https://github.com/hyperledger/indy-sdk/pull/1546,@Patrik-Stas There is an attack that can be performed by a credential issuer if they do not present an offer. It allows them to embed data into a credential that the requester does not know about.,7f5f50a075965fd676535ca5ac4055beeb1cc3a0,2019-03-25 15:49:33,268712689,"@@ -0,0 +1,656 @@
+# A2A part of IndySDK 2.0
+
+Author: Sergey Minaev, Matt Raffel, Artem Ivanov
+
+## Table of contents
+
+* [Motivation](#motivation)
+* [Goals](#goals-and-ideas)
+* [Overview](#overview)
+* [Discussion points](#discussion-points)
+* [Challenges](#challenges)
+* [IndySDK 2.0 structure](#indySDK-2-0-structure)
+* [Message Families & Messages](#message-families-&-messages)
+    * [Connection](#connection)
+    * [Credential Issuance](#credential-issuance)
+    * [Credential Presentation](#credential-presentation)
+* [API proposal](#api-proposal)
+    * [Namespaces](#namespaces)
+    * [Connection](#api-connection)
+    * [Credential Issuance](#api-credential-issuance)
+    * [Credential Presentation](#api-credential-presentation)
+* [Additional References](#additional-references)
+
+## Motivation
+[See](https://docs.google.com/document/d/1TTwGUtZ3vMvi8dXGB5lprxVvt6Da2___QuqCiyntdXs)
+
+## Goals and ideas
+
+New API of IndySDK should provide functionality for A2A communication but should not make assumptions about app business logic, transport, storage, etc.
+
+* Allow extending LibIndy to support new protocol message families and modifying the implementation.
+* Simplify process of making new message family definitions available in the common Indy ecosystem.
+* Simplify the process of support new agents.
+* Define default protocol message families. 
+* Define State Machine that developer have to follow to support new protocol message families.
+* Define the way LibIndy can consume new API functions.
+* Define the flow of communication Libindy static API, custom Libindy API helpers and an application.
+
+## Overview
+The main idea of new functionality of IndySDK is replace part of VCX library. 
+As for now VCX provide powerful mechanisms for handling Credential Issuance and Exchange flow, 
+but this library hardcode some FSM state transitions, transport flow, etc. New item should provide 
+similar functionality but give the application some flexibility.
+Internal states for particular message family should be more generic and must be aligned for the family definition. 
+The library should not perform any automatic transitions between states. Instead of that it should allows
+ application to perform validation of incoming message, check is it applicable to current state of the family flow. 
+ Actual transition between states should be performed by explicit call from application side.
+
+Current VCX will be moved out from HL/indy-sdk repo to Evernym or SF repo and most probably will have the same 
+API as for now.
+
+
+## Discussion points
+
+* How to allow (for external developer) to extend the set of supported message families:
+    * Proved some template files inside monolith library to copy paste, implement new message family and include to custom build.
+* What is the right place for new functionality: 
+    * Lbindy - suggested for start. It will simplify CI/CD flow significantly.
+        Message families may be implemented under cargo features so it will be possible to configure set of API for particular application.
+    * separate library
+    * something else
+* What is the right place for wrappers.
+* What should the API does:
+    * Should it include the ability to send reply messages?
+        * There are three possible approaches for Transport:
+            * Application calls framework specific functions.
+            * Pluggable functions defined as a part of Libindy Helpers API.
+            * Callbacks passed to `do step` state machine function and automatically called.
+    * Provide a default transport by providing a restful service handler?
+    * Should indy sdk manage A2A state? And Is state management something indy-sdk can really handle?
+        * New API should cover base states, described in appropriate standards/HIPEs
+* Naming of functions for particular message family helpers.
+* Ways the SDK can help agents with messages: creation, validation, and processing (processing where appropriate, not all cases).
+
+
+## Challenges
+
+Agent-2-Agent communications is highly unstable at this time as most of the HIPEs are still in development.
+
+
+## IndySDK 2.0 structure
+
+* Libindy
+    * Core namespace - current functionality
+    * A2A messages: state machines and helpers
+        * Connection message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * Credential Issuance message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * Credential Presentation message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * ....
+        * Template message family
+            * set of .rs files, excluded from cargo project
+            * Guideline how to implement one more msg family
+* VCX will be renamed and moved out from HL/indy-sdk
+* Wrappers
+* CLI
+
+The proposal is to have set of helpers inside libindy to assists application (or agent framework). 
+This scope will include states of flow for particular Message Family. 
+API will allow to check is it possible to move forward from the flow point of view.
+libindy will contain basic message families that will be used by the majority of agents.
+
+![Components](./components.svg)
+
+## Message Families & Messages
+
+### Connection
+
+#### Message Family
+
+The Connection Message Family consists of the following messages:
+
+* Connection Invite - https://github.com/hyperledger/indy-hipe/pull/54
+* Connection Request
+* Connection Response
+* Basic Message - https://github.com/hyperledger/indy-hipe/tree/master/text/0033-basic-message
+* State
+* State Request
+* Trust Ping - https://github.com/hyperledger/indy-hipe/tree/master/text/0032-trust-ping
+* (TBD) Ephemeral Challenge - https://github.com/hyperledger/indy-hipe/pull/95
+* (TBD) Oauth ephemeral - https://github.com/hyperledger/indy-hipe/pull/96
+
+##### Connection Invite
+TBD
+
+##### Connection Request
+TBD
+
+##### Connection Response
+TBD
+
+##### Basic Message
+TBD
+
+##### State
+TBD
+
+##### State Request
+TBD
+
+##### Trust Ping
+TBD
+
+##### Ephemeral Challenge
+
+TBD
+
+##### Oauth ephemeral
+
+TBD
+
+#### State Machine
+
+Agents need to manage state.  
+Especially between connection invites since connection invites is a multi-step process.   
+
+![State Machine definition](./connection.png)
+
+TBD
+
+#### Workflow
+
+TBD
+
+### Credential Issuance
+
+#### Message Family
+
+The Credential Issuance Message Family consists of the following messages:
+
+* Credential Offer
+* Credential Request
+* Credential Reject
+* Credential
+* Credential Ack
+
+##### Credential Offer
+This message is sent by Issuer to Prover to initiate credential issuance process. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential-offer"",
+    ""@id"": ""<uuid-offer>"",
+    ""cred_def_id"": ""KTwaKJkvyjKKf55uc6U8ZB:3:CL:59:tag1"",
+    ""comment"": ""some comment"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred-offer"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        },
+        {
+            ""nickname"": ""credential-preview"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        }
+    ]
+}
+```
+
+Description of fields:
+* `comment` - a field that provide some human readable information about this Credential Offer.
+* `cred_def_id` - id cof credential definition for offered credential
+* attachment `libindy-cred-offer` - libindy generated data about credential offer
+* attachment `credential-preview` - preview of credential.
+
+##### Credential Request
+This message is sent in response to Credential Offer by Prover to give needed details for credential issuance.
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential-request"",
+    ""@id"": ""<uuid-request>"",
+    ""cred_def_id"": ""2hoqvcwupRTUNkXn6ArYzs:3:CL:1766"",
+    ""comment"": ""some comment"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred-req"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        },
+        {
+            ""nickname"": ""credential-preview"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        }
+    ]
+}
+```
+
+Description of Fields:
+* `cred_def_id` - Credential Definition ID for requested credential
+* `comment` - a field that provide some human readable information about this Credential Offer.
+* attachment `libindy-cred-req` - libindy generated data that is needed to Issuer to issue a credential.
+* attachment `credential-preview` - optional attachment with preview of credential that Prover wants to get.
+
+##### Credential
+This message contains the credential and sent in responce to Credential Request by Issuer. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential"",
+    ""@id"": ""<uuid-credential>"",
+    ""rev_reg_def_id"": ""<rev_reg_def_id>"",
+    ""cred_def_id"": ""2hoqvcwupRTUNkXn6ArYzs:3:CL:1766"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""  
+            }
+        }
+    ]
+}
+```
+
+Description of fields:
+
+* `rev_reg_def_id` - ID of Revocation Registry Definition this credential were issued to
+* `cred_def_id` - ID of Credential Definition this credential were issued to
+* attachment `libindy-cred` - an actual credential to store, it is a json encoded in base64
+
+##### Credential Reject
+This message can be sent by any side of the conversation to finish credential issuance process without any credential created. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/reject"",
+    ""@id"": ""id""
+}
+```
+
+##### Credential Ack
+This message is sent by Prover as he confirms that he had received the credential and everything is correct. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/ack"",
+    ""@id"": ""id""
+}
+```
+
+#### State Machine
+
+The Credential Issuance State Machine consists of the following states:
+
+* Initialized
+* Issuer related states:
+    * CredentialOfferCreated
+    * CredentialRequestReceived
+    * CredentialCreated
+    * CredentialAckReceived
+* Prover related states:
+    * CredentialOfferReceived
+    * CredentialRequestCreated
+    * CredentialReceived
+    * CredentialAckCreated
+* CredentialRejectCreated
+* CredentialRejectReceived
+* Finished
+
+##### Initialized
+Common state for both parties. Indicates initiation of issuance process.
+Transitions:
+* Issuer
+    * CredentialOfferCreated - issuer acts as an initiator.
+    * CredentialRequestReceived - prover already prepared credential request and sent to issuer (prover acts as an initiator). 
+* Prover
+    * CredentialOfferReceived - prover received Credential Offer message from issuer.
+    * CredentialRequestCreated - prover already has data for request creation and acts as an initiator.
+
+##### CredentialOfferCreated
+Issuer specific state that means that Credential Offer message has been created and sent to Prover.
+Transitions:
+* CredentialRequestReceived - prover replied with Credential Request message.
+* CredentialRejectReceived - prover replied woth Credential Reject message.
+    
+##### CredentialRequestReceived
+Issuer specific state that means that Prover replied with Credential Request message on offer.
+Transitions:
+* CredentialCreated - credential created and sent to prover
+* CredentialRejectCreated - issuer interrupted credential issuance process for some reason.
+
+##### CredentialCreated
+Issuer specific state that means that Credential message has been created and sent to Prover.
+Transitions:
+* CredentialAckReceived - prover accepted credential and replied with Credential Ack message.
+* CredentialRejectReceived - prover rejected credential for some reason.
+    
+##### CredentialAckReceived
+Issuer specific state that means that Prover replied with Credential Ack message on credential.
+Transitions:
+* Finished - credential issuance process is completed.
+
+##### CredentialOfferReceived
+Prover specific state that means that Credential Offer message has been received from Issuer.
+Transitions:
+* CredentialRequestCreated - prover accepted offer and replied with Credential Request message.
+* CredentialRejectCreated - prover rejected credential offer for some reason.
+
+##### CredentialRequestCreated
+Prover specific state that means that Credential Offer message has been accepted and 
+Credential Request message created and sent to Issuer.
+Transitions:
+* CredentialReceived - credential message received from Issuer.
+* CredentialRejectReceived - issuer interrupted issuance process for some reason.
+
+##### CredentialReceived
+Prover specific state that means that Credential message has been received from Issuer.
+Transitions:
+* CredentialAckCreated - prover accepted credential and replied with Credential Ack message.
+* CredentialRejectCreated - prover rejected credential and interrupted issuance process for some reason.
+
+##### CredentialAckCreated
+Prover specific state that means that Credential Ack message created and sent to Issuer.
+Transitions:
+* Finished - credential issuance process is completed.
+
+##### CredentialRejectCreated
+Common state for both parties. Indicates interruption of issuance process.
+Transitions:
+* Finished - credential issuance process is interrupted.
+
+##### CredentialRejectReceived
+Common state for both parties. Indicates interruption of issuance process by opposite side.
+Transitions:
+* Finished - credential issuance process is interrupted.
+
+#### Choreography Diagram
+
+![Choreography Diagram](./credential-issuance.png)
+
+#### Workflow
+
+The Credential Issuance positive workflow is demonstrated on the following diagram:
+
+![Workflow](credential-issuance-positive-flow.svg)",391,2019-03-25 15:49:34,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/268712689,https://github.com/hyperledger/indy-sdk/pull/1546#discussion_r268712689,dhh1128
https://github.com/hyperledger/indy-sdk/pull/1546,https://github.com/hyperledger/indy-sdk/pull/1546,@brentzundel or @mikelodder7 or @lovesh may be able to clarify.,7f5f50a075965fd676535ca5ac4055beeb1cc3a0,2019-03-25 15:50:27,268713184,"@@ -0,0 +1,656 @@
+# A2A part of IndySDK 2.0
+
+Author: Sergey Minaev, Matt Raffel, Artem Ivanov
+
+## Table of contents
+
+* [Motivation](#motivation)
+* [Goals](#goals-and-ideas)
+* [Overview](#overview)
+* [Discussion points](#discussion-points)
+* [Challenges](#challenges)
+* [IndySDK 2.0 structure](#indySDK-2-0-structure)
+* [Message Families & Messages](#message-families-&-messages)
+    * [Connection](#connection)
+    * [Credential Issuance](#credential-issuance)
+    * [Credential Presentation](#credential-presentation)
+* [API proposal](#api-proposal)
+    * [Namespaces](#namespaces)
+    * [Connection](#api-connection)
+    * [Credential Issuance](#api-credential-issuance)
+    * [Credential Presentation](#api-credential-presentation)
+* [Additional References](#additional-references)
+
+## Motivation
+[See](https://docs.google.com/document/d/1TTwGUtZ3vMvi8dXGB5lprxVvt6Da2___QuqCiyntdXs)
+
+## Goals and ideas
+
+New API of IndySDK should provide functionality for A2A communication but should not make assumptions about app business logic, transport, storage, etc.
+
+* Allow extending LibIndy to support new protocol message families and modifying the implementation.
+* Simplify process of making new message family definitions available in the common Indy ecosystem.
+* Simplify the process of support new agents.
+* Define default protocol message families. 
+* Define State Machine that developer have to follow to support new protocol message families.
+* Define the way LibIndy can consume new API functions.
+* Define the flow of communication Libindy static API, custom Libindy API helpers and an application.
+
+## Overview
+The main idea of new functionality of IndySDK is replace part of VCX library. 
+As for now VCX provide powerful mechanisms for handling Credential Issuance and Exchange flow, 
+but this library hardcode some FSM state transitions, transport flow, etc. New item should provide 
+similar functionality but give the application some flexibility.
+Internal states for particular message family should be more generic and must be aligned for the family definition. 
+The library should not perform any automatic transitions between states. Instead of that it should allows
+ application to perform validation of incoming message, check is it applicable to current state of the family flow. 
+ Actual transition between states should be performed by explicit call from application side.
+
+Current VCX will be moved out from HL/indy-sdk repo to Evernym or SF repo and most probably will have the same 
+API as for now.
+
+
+## Discussion points
+
+* How to allow (for external developer) to extend the set of supported message families:
+    * Proved some template files inside monolith library to copy paste, implement new message family and include to custom build.
+* What is the right place for new functionality: 
+    * Lbindy - suggested for start. It will simplify CI/CD flow significantly.
+        Message families may be implemented under cargo features so it will be possible to configure set of API for particular application.
+    * separate library
+    * something else
+* What is the right place for wrappers.
+* What should the API does:
+    * Should it include the ability to send reply messages?
+        * There are three possible approaches for Transport:
+            * Application calls framework specific functions.
+            * Pluggable functions defined as a part of Libindy Helpers API.
+            * Callbacks passed to `do step` state machine function and automatically called.
+    * Provide a default transport by providing a restful service handler?
+    * Should indy sdk manage A2A state? And Is state management something indy-sdk can really handle?
+        * New API should cover base states, described in appropriate standards/HIPEs
+* Naming of functions for particular message family helpers.
+* Ways the SDK can help agents with messages: creation, validation, and processing (processing where appropriate, not all cases).
+
+
+## Challenges
+
+Agent-2-Agent communications is highly unstable at this time as most of the HIPEs are still in development.
+
+
+## IndySDK 2.0 structure
+
+* Libindy
+    * Core namespace - current functionality
+    * A2A messages: state machines and helpers
+        * Connection message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * Credential Issuance message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * Credential Presentation message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * ....
+        * Template message family
+            * set of .rs files, excluded from cargo project
+            * Guideline how to implement one more msg family
+* VCX will be renamed and moved out from HL/indy-sdk
+* Wrappers
+* CLI
+
+The proposal is to have set of helpers inside libindy to assists application (or agent framework). 
+This scope will include states of flow for particular Message Family. 
+API will allow to check is it possible to move forward from the flow point of view.
+libindy will contain basic message families that will be used by the majority of agents.
+
+![Components](./components.svg)
+
+## Message Families & Messages
+
+### Connection
+
+#### Message Family
+
+The Connection Message Family consists of the following messages:
+
+* Connection Invite - https://github.com/hyperledger/indy-hipe/pull/54
+* Connection Request
+* Connection Response
+* Basic Message - https://github.com/hyperledger/indy-hipe/tree/master/text/0033-basic-message
+* State
+* State Request
+* Trust Ping - https://github.com/hyperledger/indy-hipe/tree/master/text/0032-trust-ping
+* (TBD) Ephemeral Challenge - https://github.com/hyperledger/indy-hipe/pull/95
+* (TBD) Oauth ephemeral - https://github.com/hyperledger/indy-hipe/pull/96
+
+##### Connection Invite
+TBD
+
+##### Connection Request
+TBD
+
+##### Connection Response
+TBD
+
+##### Basic Message
+TBD
+
+##### State
+TBD
+
+##### State Request
+TBD
+
+##### Trust Ping
+TBD
+
+##### Ephemeral Challenge
+
+TBD
+
+##### Oauth ephemeral
+
+TBD
+
+#### State Machine
+
+Agents need to manage state.  
+Especially between connection invites since connection invites is a multi-step process.   
+
+![State Machine definition](./connection.png)
+
+TBD
+
+#### Workflow
+
+TBD
+
+### Credential Issuance
+
+#### Message Family
+
+The Credential Issuance Message Family consists of the following messages:
+
+* Credential Offer
+* Credential Request
+* Credential Reject
+* Credential
+* Credential Ack
+
+##### Credential Offer
+This message is sent by Issuer to Prover to initiate credential issuance process. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential-offer"",
+    ""@id"": ""<uuid-offer>"",
+    ""cred_def_id"": ""KTwaKJkvyjKKf55uc6U8ZB:3:CL:59:tag1"",
+    ""comment"": ""some comment"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred-offer"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        },
+        {
+            ""nickname"": ""credential-preview"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        }
+    ]
+}
+```
+
+Description of fields:
+* `comment` - a field that provide some human readable information about this Credential Offer.
+* `cred_def_id` - id cof credential definition for offered credential
+* attachment `libindy-cred-offer` - libindy generated data about credential offer
+* attachment `credential-preview` - preview of credential.
+
+##### Credential Request
+This message is sent in response to Credential Offer by Prover to give needed details for credential issuance.
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential-request"",
+    ""@id"": ""<uuid-request>"",
+    ""cred_def_id"": ""2hoqvcwupRTUNkXn6ArYzs:3:CL:1766"",
+    ""comment"": ""some comment"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred-req"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        },
+        {
+            ""nickname"": ""credential-preview"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        }
+    ]
+}
+```
+
+Description of Fields:
+* `cred_def_id` - Credential Definition ID for requested credential
+* `comment` - a field that provide some human readable information about this Credential Offer.
+* attachment `libindy-cred-req` - libindy generated data that is needed to Issuer to issue a credential.
+* attachment `credential-preview` - optional attachment with preview of credential that Prover wants to get.
+
+##### Credential
+This message contains the credential and sent in responce to Credential Request by Issuer. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential"",
+    ""@id"": ""<uuid-credential>"",
+    ""rev_reg_def_id"": ""<rev_reg_def_id>"",
+    ""cred_def_id"": ""2hoqvcwupRTUNkXn6ArYzs:3:CL:1766"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""  
+            }
+        }
+    ]
+}
+```
+
+Description of fields:
+
+* `rev_reg_def_id` - ID of Revocation Registry Definition this credential were issued to
+* `cred_def_id` - ID of Credential Definition this credential were issued to
+* attachment `libindy-cred` - an actual credential to store, it is a json encoded in base64
+
+##### Credential Reject
+This message can be sent by any side of the conversation to finish credential issuance process without any credential created. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/reject"",
+    ""@id"": ""id""
+}
+```
+
+##### Credential Ack
+This message is sent by Prover as he confirms that he had received the credential and everything is correct. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/ack"",
+    ""@id"": ""id""
+}
+```
+
+#### State Machine
+
+The Credential Issuance State Machine consists of the following states:
+
+* Initialized
+* Issuer related states:
+    * CredentialOfferCreated
+    * CredentialRequestReceived
+    * CredentialCreated
+    * CredentialAckReceived
+* Prover related states:
+    * CredentialOfferReceived
+    * CredentialRequestCreated
+    * CredentialReceived
+    * CredentialAckCreated
+* CredentialRejectCreated
+* CredentialRejectReceived
+* Finished
+
+##### Initialized
+Common state for both parties. Indicates initiation of issuance process.
+Transitions:
+* Issuer
+    * CredentialOfferCreated - issuer acts as an initiator.
+    * CredentialRequestReceived - prover already prepared credential request and sent to issuer (prover acts as an initiator). 
+* Prover
+    * CredentialOfferReceived - prover received Credential Offer message from issuer.
+    * CredentialRequestCreated - prover already has data for request creation and acts as an initiator.
+
+##### CredentialOfferCreated
+Issuer specific state that means that Credential Offer message has been created and sent to Prover.
+Transitions:
+* CredentialRequestReceived - prover replied with Credential Request message.
+* CredentialRejectReceived - prover replied woth Credential Reject message.
+    
+##### CredentialRequestReceived
+Issuer specific state that means that Prover replied with Credential Request message on offer.
+Transitions:
+* CredentialCreated - credential created and sent to prover
+* CredentialRejectCreated - issuer interrupted credential issuance process for some reason.
+
+##### CredentialCreated
+Issuer specific state that means that Credential message has been created and sent to Prover.
+Transitions:
+* CredentialAckReceived - prover accepted credential and replied with Credential Ack message.
+* CredentialRejectReceived - prover rejected credential for some reason.
+    
+##### CredentialAckReceived
+Issuer specific state that means that Prover replied with Credential Ack message on credential.
+Transitions:
+* Finished - credential issuance process is completed.
+
+##### CredentialOfferReceived
+Prover specific state that means that Credential Offer message has been received from Issuer.
+Transitions:
+* CredentialRequestCreated - prover accepted offer and replied with Credential Request message.
+* CredentialRejectCreated - prover rejected credential offer for some reason.
+
+##### CredentialRequestCreated
+Prover specific state that means that Credential Offer message has been accepted and 
+Credential Request message created and sent to Issuer.
+Transitions:
+* CredentialReceived - credential message received from Issuer.
+* CredentialRejectReceived - issuer interrupted issuance process for some reason.
+
+##### CredentialReceived
+Prover specific state that means that Credential message has been received from Issuer.
+Transitions:
+* CredentialAckCreated - prover accepted credential and replied with Credential Ack message.
+* CredentialRejectCreated - prover rejected credential and interrupted issuance process for some reason.
+
+##### CredentialAckCreated
+Prover specific state that means that Credential Ack message created and sent to Issuer.
+Transitions:
+* Finished - credential issuance process is completed.
+
+##### CredentialRejectCreated
+Common state for both parties. Indicates interruption of issuance process.
+Transitions:
+* Finished - credential issuance process is interrupted.
+
+##### CredentialRejectReceived
+Common state for both parties. Indicates interruption of issuance process by opposite side.
+Transitions:
+* Finished - credential issuance process is interrupted.
+
+#### Choreography Diagram
+
+![Choreography Diagram](./credential-issuance.png)
+
+#### Workflow
+
+The Credential Issuance positive workflow is demonstrated on the following diagram:
+
+![Workflow](credential-issuance-positive-flow.svg)",391,2019-03-25 15:50:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/268713184,https://github.com/hyperledger/indy-sdk/pull/1546#discussion_r268713184,dhh1128
https://github.com/hyperledger/indy-sdk/pull/1546,https://github.com/hyperledger/indy-sdk/pull/1546,"@dhh1128 I see, fair enough if this kind of 3 step credential exchange protocol is security requirement. However, what about the functional requirement? Having the ability to ask someone to give you a credential of certain type?
Wouldn't it make sense to have something like ""credential offer request"" as a standard message type? (sounds awkward, a better name could be given).",7f5f50a075965fd676535ca5ac4055beeb1cc3a0,2019-03-25 19:39:01,268818172,"@@ -0,0 +1,656 @@
+# A2A part of IndySDK 2.0
+
+Author: Sergey Minaev, Matt Raffel, Artem Ivanov
+
+## Table of contents
+
+* [Motivation](#motivation)
+* [Goals](#goals-and-ideas)
+* [Overview](#overview)
+* [Discussion points](#discussion-points)
+* [Challenges](#challenges)
+* [IndySDK 2.0 structure](#indySDK-2-0-structure)
+* [Message Families & Messages](#message-families-&-messages)
+    * [Connection](#connection)
+    * [Credential Issuance](#credential-issuance)
+    * [Credential Presentation](#credential-presentation)
+* [API proposal](#api-proposal)
+    * [Namespaces](#namespaces)
+    * [Connection](#api-connection)
+    * [Credential Issuance](#api-credential-issuance)
+    * [Credential Presentation](#api-credential-presentation)
+* [Additional References](#additional-references)
+
+## Motivation
+[See](https://docs.google.com/document/d/1TTwGUtZ3vMvi8dXGB5lprxVvt6Da2___QuqCiyntdXs)
+
+## Goals and ideas
+
+New API of IndySDK should provide functionality for A2A communication but should not make assumptions about app business logic, transport, storage, etc.
+
+* Allow extending LibIndy to support new protocol message families and modifying the implementation.
+* Simplify process of making new message family definitions available in the common Indy ecosystem.
+* Simplify the process of support new agents.
+* Define default protocol message families. 
+* Define State Machine that developer have to follow to support new protocol message families.
+* Define the way LibIndy can consume new API functions.
+* Define the flow of communication Libindy static API, custom Libindy API helpers and an application.
+
+## Overview
+The main idea of new functionality of IndySDK is replace part of VCX library. 
+As for now VCX provide powerful mechanisms for handling Credential Issuance and Exchange flow, 
+but this library hardcode some FSM state transitions, transport flow, etc. New item should provide 
+similar functionality but give the application some flexibility.
+Internal states for particular message family should be more generic and must be aligned for the family definition. 
+The library should not perform any automatic transitions between states. Instead of that it should allows
+ application to perform validation of incoming message, check is it applicable to current state of the family flow. 
+ Actual transition between states should be performed by explicit call from application side.
+
+Current VCX will be moved out from HL/indy-sdk repo to Evernym or SF repo and most probably will have the same 
+API as for now.
+
+
+## Discussion points
+
+* How to allow (for external developer) to extend the set of supported message families:
+    * Proved some template files inside monolith library to copy paste, implement new message family and include to custom build.
+* What is the right place for new functionality: 
+    * Lbindy - suggested for start. It will simplify CI/CD flow significantly.
+        Message families may be implemented under cargo features so it will be possible to configure set of API for particular application.
+    * separate library
+    * something else
+* What is the right place for wrappers.
+* What should the API does:
+    * Should it include the ability to send reply messages?
+        * There are three possible approaches for Transport:
+            * Application calls framework specific functions.
+            * Pluggable functions defined as a part of Libindy Helpers API.
+            * Callbacks passed to `do step` state machine function and automatically called.
+    * Provide a default transport by providing a restful service handler?
+    * Should indy sdk manage A2A state? And Is state management something indy-sdk can really handle?
+        * New API should cover base states, described in appropriate standards/HIPEs
+* Naming of functions for particular message family helpers.
+* Ways the SDK can help agents with messages: creation, validation, and processing (processing where appropriate, not all cases).
+
+
+## Challenges
+
+Agent-2-Agent communications is highly unstable at this time as most of the HIPEs are still in development.
+
+
+## IndySDK 2.0 structure
+
+* Libindy
+    * Core namespace - current functionality
+    * A2A messages: state machines and helpers
+        * Connection message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * Credential Issuance message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * Credential Presentation message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * ....
+        * Template message family
+            * set of .rs files, excluded from cargo project
+            * Guideline how to implement one more msg family
+* VCX will be renamed and moved out from HL/indy-sdk
+* Wrappers
+* CLI
+
+The proposal is to have set of helpers inside libindy to assists application (or agent framework). 
+This scope will include states of flow for particular Message Family. 
+API will allow to check is it possible to move forward from the flow point of view.
+libindy will contain basic message families that will be used by the majority of agents.
+
+![Components](./components.svg)
+
+## Message Families & Messages
+
+### Connection
+
+#### Message Family
+
+The Connection Message Family consists of the following messages:
+
+* Connection Invite - https://github.com/hyperledger/indy-hipe/pull/54
+* Connection Request
+* Connection Response
+* Basic Message - https://github.com/hyperledger/indy-hipe/tree/master/text/0033-basic-message
+* State
+* State Request
+* Trust Ping - https://github.com/hyperledger/indy-hipe/tree/master/text/0032-trust-ping
+* (TBD) Ephemeral Challenge - https://github.com/hyperledger/indy-hipe/pull/95
+* (TBD) Oauth ephemeral - https://github.com/hyperledger/indy-hipe/pull/96
+
+##### Connection Invite
+TBD
+
+##### Connection Request
+TBD
+
+##### Connection Response
+TBD
+
+##### Basic Message
+TBD
+
+##### State
+TBD
+
+##### State Request
+TBD
+
+##### Trust Ping
+TBD
+
+##### Ephemeral Challenge
+
+TBD
+
+##### Oauth ephemeral
+
+TBD
+
+#### State Machine
+
+Agents need to manage state.  
+Especially between connection invites since connection invites is a multi-step process.   
+
+![State Machine definition](./connection.png)
+
+TBD
+
+#### Workflow
+
+TBD
+
+### Credential Issuance
+
+#### Message Family
+
+The Credential Issuance Message Family consists of the following messages:
+
+* Credential Offer
+* Credential Request
+* Credential Reject
+* Credential
+* Credential Ack
+
+##### Credential Offer
+This message is sent by Issuer to Prover to initiate credential issuance process. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential-offer"",
+    ""@id"": ""<uuid-offer>"",
+    ""cred_def_id"": ""KTwaKJkvyjKKf55uc6U8ZB:3:CL:59:tag1"",
+    ""comment"": ""some comment"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred-offer"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        },
+        {
+            ""nickname"": ""credential-preview"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        }
+    ]
+}
+```
+
+Description of fields:
+* `comment` - a field that provide some human readable information about this Credential Offer.
+* `cred_def_id` - id cof credential definition for offered credential
+* attachment `libindy-cred-offer` - libindy generated data about credential offer
+* attachment `credential-preview` - preview of credential.
+
+##### Credential Request
+This message is sent in response to Credential Offer by Prover to give needed details for credential issuance.
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential-request"",
+    ""@id"": ""<uuid-request>"",
+    ""cred_def_id"": ""2hoqvcwupRTUNkXn6ArYzs:3:CL:1766"",
+    ""comment"": ""some comment"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred-req"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        },
+        {
+            ""nickname"": ""credential-preview"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        }
+    ]
+}
+```
+
+Description of Fields:
+* `cred_def_id` - Credential Definition ID for requested credential
+* `comment` - a field that provide some human readable information about this Credential Offer.
+* attachment `libindy-cred-req` - libindy generated data that is needed to Issuer to issue a credential.
+* attachment `credential-preview` - optional attachment with preview of credential that Prover wants to get.
+
+##### Credential
+This message contains the credential and sent in responce to Credential Request by Issuer. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential"",
+    ""@id"": ""<uuid-credential>"",
+    ""rev_reg_def_id"": ""<rev_reg_def_id>"",
+    ""cred_def_id"": ""2hoqvcwupRTUNkXn6ArYzs:3:CL:1766"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""  
+            }
+        }
+    ]
+}
+```
+
+Description of fields:
+
+* `rev_reg_def_id` - ID of Revocation Registry Definition this credential were issued to
+* `cred_def_id` - ID of Credential Definition this credential were issued to
+* attachment `libindy-cred` - an actual credential to store, it is a json encoded in base64
+
+##### Credential Reject
+This message can be sent by any side of the conversation to finish credential issuance process without any credential created. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/reject"",
+    ""@id"": ""id""
+}
+```
+
+##### Credential Ack
+This message is sent by Prover as he confirms that he had received the credential and everything is correct. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/ack"",
+    ""@id"": ""id""
+}
+```
+
+#### State Machine
+
+The Credential Issuance State Machine consists of the following states:
+
+* Initialized
+* Issuer related states:
+    * CredentialOfferCreated
+    * CredentialRequestReceived
+    * CredentialCreated
+    * CredentialAckReceived
+* Prover related states:
+    * CredentialOfferReceived
+    * CredentialRequestCreated
+    * CredentialReceived
+    * CredentialAckCreated
+* CredentialRejectCreated
+* CredentialRejectReceived
+* Finished
+
+##### Initialized
+Common state for both parties. Indicates initiation of issuance process.
+Transitions:
+* Issuer
+    * CredentialOfferCreated - issuer acts as an initiator.
+    * CredentialRequestReceived - prover already prepared credential request and sent to issuer (prover acts as an initiator). 
+* Prover
+    * CredentialOfferReceived - prover received Credential Offer message from issuer.
+    * CredentialRequestCreated - prover already has data for request creation and acts as an initiator.
+
+##### CredentialOfferCreated
+Issuer specific state that means that Credential Offer message has been created and sent to Prover.
+Transitions:
+* CredentialRequestReceived - prover replied with Credential Request message.
+* CredentialRejectReceived - prover replied woth Credential Reject message.
+    
+##### CredentialRequestReceived
+Issuer specific state that means that Prover replied with Credential Request message on offer.
+Transitions:
+* CredentialCreated - credential created and sent to prover
+* CredentialRejectCreated - issuer interrupted credential issuance process for some reason.
+
+##### CredentialCreated
+Issuer specific state that means that Credential message has been created and sent to Prover.
+Transitions:
+* CredentialAckReceived - prover accepted credential and replied with Credential Ack message.
+* CredentialRejectReceived - prover rejected credential for some reason.
+    
+##### CredentialAckReceived
+Issuer specific state that means that Prover replied with Credential Ack message on credential.
+Transitions:
+* Finished - credential issuance process is completed.
+
+##### CredentialOfferReceived
+Prover specific state that means that Credential Offer message has been received from Issuer.
+Transitions:
+* CredentialRequestCreated - prover accepted offer and replied with Credential Request message.
+* CredentialRejectCreated - prover rejected credential offer for some reason.
+
+##### CredentialRequestCreated
+Prover specific state that means that Credential Offer message has been accepted and 
+Credential Request message created and sent to Issuer.
+Transitions:
+* CredentialReceived - credential message received from Issuer.
+* CredentialRejectReceived - issuer interrupted issuance process for some reason.
+
+##### CredentialReceived
+Prover specific state that means that Credential message has been received from Issuer.
+Transitions:
+* CredentialAckCreated - prover accepted credential and replied with Credential Ack message.
+* CredentialRejectCreated - prover rejected credential and interrupted issuance process for some reason.
+
+##### CredentialAckCreated
+Prover specific state that means that Credential Ack message created and sent to Issuer.
+Transitions:
+* Finished - credential issuance process is completed.
+
+##### CredentialRejectCreated
+Common state for both parties. Indicates interruption of issuance process.
+Transitions:
+* Finished - credential issuance process is interrupted.
+
+##### CredentialRejectReceived
+Common state for both parties. Indicates interruption of issuance process by opposite side.
+Transitions:
+* Finished - credential issuance process is interrupted.
+
+#### Choreography Diagram
+
+![Choreography Diagram](./credential-issuance.png)
+
+#### Workflow
+
+The Credential Issuance positive workflow is demonstrated on the following diagram:
+
+![Workflow](credential-issuance-positive-flow.svg)",391,2019-03-25 19:39:01,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/268818172,https://github.com/hyperledger/indy-sdk/pull/1546#discussion_r268818172,Patrik-Stas
https://github.com/hyperledger/indy-sdk/pull/1546,https://github.com/hyperledger/indy-sdk/pull/1546,"@Patrik-Stas The need for sending credential offer is for the issuer to send a nonce to ensure that the holder does know the value of the committed attributes. One such attribute is link secret. The holder never reveals the link secret, he only sends a commitment to the issuer. The holder uses the nonce sent as part of credential offer to send a proof (prior to issuance) to the issuer that he does know the link secret he is committing to. The nonce does not have to sent by the issuer always, the prover can select a nonce from another source like the current (eg. upto `n` minutes in past ) merkle root of the ledger or a randomness beacon. 

> what about the functional requirement? Having the ability to ask someone to give you a credential of certain type?

Yes, we can introduce a message by holder indicating the ""type"" of credential it needs.",7f5f50a075965fd676535ca5ac4055beeb1cc3a0,2019-03-26 07:06:20,268963922,"@@ -0,0 +1,656 @@
+# A2A part of IndySDK 2.0
+
+Author: Sergey Minaev, Matt Raffel, Artem Ivanov
+
+## Table of contents
+
+* [Motivation](#motivation)
+* [Goals](#goals-and-ideas)
+* [Overview](#overview)
+* [Discussion points](#discussion-points)
+* [Challenges](#challenges)
+* [IndySDK 2.0 structure](#indySDK-2-0-structure)
+* [Message Families & Messages](#message-families-&-messages)
+    * [Connection](#connection)
+    * [Credential Issuance](#credential-issuance)
+    * [Credential Presentation](#credential-presentation)
+* [API proposal](#api-proposal)
+    * [Namespaces](#namespaces)
+    * [Connection](#api-connection)
+    * [Credential Issuance](#api-credential-issuance)
+    * [Credential Presentation](#api-credential-presentation)
+* [Additional References](#additional-references)
+
+## Motivation
+[See](https://docs.google.com/document/d/1TTwGUtZ3vMvi8dXGB5lprxVvt6Da2___QuqCiyntdXs)
+
+## Goals and ideas
+
+New API of IndySDK should provide functionality for A2A communication but should not make assumptions about app business logic, transport, storage, etc.
+
+* Allow extending LibIndy to support new protocol message families and modifying the implementation.
+* Simplify process of making new message family definitions available in the common Indy ecosystem.
+* Simplify the process of support new agents.
+* Define default protocol message families. 
+* Define State Machine that developer have to follow to support new protocol message families.
+* Define the way LibIndy can consume new API functions.
+* Define the flow of communication Libindy static API, custom Libindy API helpers and an application.
+
+## Overview
+The main idea of new functionality of IndySDK is replace part of VCX library. 
+As for now VCX provide powerful mechanisms for handling Credential Issuance and Exchange flow, 
+but this library hardcode some FSM state transitions, transport flow, etc. New item should provide 
+similar functionality but give the application some flexibility.
+Internal states for particular message family should be more generic and must be aligned for the family definition. 
+The library should not perform any automatic transitions between states. Instead of that it should allows
+ application to perform validation of incoming message, check is it applicable to current state of the family flow. 
+ Actual transition between states should be performed by explicit call from application side.
+
+Current VCX will be moved out from HL/indy-sdk repo to Evernym or SF repo and most probably will have the same 
+API as for now.
+
+
+## Discussion points
+
+* How to allow (for external developer) to extend the set of supported message families:
+    * Proved some template files inside monolith library to copy paste, implement new message family and include to custom build.
+* What is the right place for new functionality: 
+    * Lbindy - suggested for start. It will simplify CI/CD flow significantly.
+        Message families may be implemented under cargo features so it will be possible to configure set of API for particular application.
+    * separate library
+    * something else
+* What is the right place for wrappers.
+* What should the API does:
+    * Should it include the ability to send reply messages?
+        * There are three possible approaches for Transport:
+            * Application calls framework specific functions.
+            * Pluggable functions defined as a part of Libindy Helpers API.
+            * Callbacks passed to `do step` state machine function and automatically called.
+    * Provide a default transport by providing a restful service handler?
+    * Should indy sdk manage A2A state? And Is state management something indy-sdk can really handle?
+        * New API should cover base states, described in appropriate standards/HIPEs
+* Naming of functions for particular message family helpers.
+* Ways the SDK can help agents with messages: creation, validation, and processing (processing where appropriate, not all cases).
+
+
+## Challenges
+
+Agent-2-Agent communications is highly unstable at this time as most of the HIPEs are still in development.
+
+
+## IndySDK 2.0 structure
+
+* Libindy
+    * Core namespace - current functionality
+    * A2A messages: state machines and helpers
+        * Connection message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * Credential Issuance message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * Credential Presentation message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * ....
+        * Template message family
+            * set of .rs files, excluded from cargo project
+            * Guideline how to implement one more msg family
+* VCX will be renamed and moved out from HL/indy-sdk
+* Wrappers
+* CLI
+
+The proposal is to have set of helpers inside libindy to assists application (or agent framework). 
+This scope will include states of flow for particular Message Family. 
+API will allow to check is it possible to move forward from the flow point of view.
+libindy will contain basic message families that will be used by the majority of agents.
+
+![Components](./components.svg)
+
+## Message Families & Messages
+
+### Connection
+
+#### Message Family
+
+The Connection Message Family consists of the following messages:
+
+* Connection Invite - https://github.com/hyperledger/indy-hipe/pull/54
+* Connection Request
+* Connection Response
+* Basic Message - https://github.com/hyperledger/indy-hipe/tree/master/text/0033-basic-message
+* State
+* State Request
+* Trust Ping - https://github.com/hyperledger/indy-hipe/tree/master/text/0032-trust-ping
+* (TBD) Ephemeral Challenge - https://github.com/hyperledger/indy-hipe/pull/95
+* (TBD) Oauth ephemeral - https://github.com/hyperledger/indy-hipe/pull/96
+
+##### Connection Invite
+TBD
+
+##### Connection Request
+TBD
+
+##### Connection Response
+TBD
+
+##### Basic Message
+TBD
+
+##### State
+TBD
+
+##### State Request
+TBD
+
+##### Trust Ping
+TBD
+
+##### Ephemeral Challenge
+
+TBD
+
+##### Oauth ephemeral
+
+TBD
+
+#### State Machine
+
+Agents need to manage state.  
+Especially between connection invites since connection invites is a multi-step process.   
+
+![State Machine definition](./connection.png)
+
+TBD
+
+#### Workflow
+
+TBD
+
+### Credential Issuance
+
+#### Message Family
+
+The Credential Issuance Message Family consists of the following messages:
+
+* Credential Offer
+* Credential Request
+* Credential Reject
+* Credential
+* Credential Ack
+
+##### Credential Offer
+This message is sent by Issuer to Prover to initiate credential issuance process. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential-offer"",
+    ""@id"": ""<uuid-offer>"",
+    ""cred_def_id"": ""KTwaKJkvyjKKf55uc6U8ZB:3:CL:59:tag1"",
+    ""comment"": ""some comment"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred-offer"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        },
+        {
+            ""nickname"": ""credential-preview"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        }
+    ]
+}
+```
+
+Description of fields:
+* `comment` - a field that provide some human readable information about this Credential Offer.
+* `cred_def_id` - id cof credential definition for offered credential
+* attachment `libindy-cred-offer` - libindy generated data about credential offer
+* attachment `credential-preview` - preview of credential.
+
+##### Credential Request
+This message is sent in response to Credential Offer by Prover to give needed details for credential issuance.
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential-request"",
+    ""@id"": ""<uuid-request>"",
+    ""cred_def_id"": ""2hoqvcwupRTUNkXn6ArYzs:3:CL:1766"",
+    ""comment"": ""some comment"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred-req"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        },
+        {
+            ""nickname"": ""credential-preview"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        }
+    ]
+}
+```
+
+Description of Fields:
+* `cred_def_id` - Credential Definition ID for requested credential
+* `comment` - a field that provide some human readable information about this Credential Offer.
+* attachment `libindy-cred-req` - libindy generated data that is needed to Issuer to issue a credential.
+* attachment `credential-preview` - optional attachment with preview of credential that Prover wants to get.
+
+##### Credential
+This message contains the credential and sent in responce to Credential Request by Issuer. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential"",
+    ""@id"": ""<uuid-credential>"",
+    ""rev_reg_def_id"": ""<rev_reg_def_id>"",
+    ""cred_def_id"": ""2hoqvcwupRTUNkXn6ArYzs:3:CL:1766"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""  
+            }
+        }
+    ]
+}
+```
+
+Description of fields:
+
+* `rev_reg_def_id` - ID of Revocation Registry Definition this credential were issued to
+* `cred_def_id` - ID of Credential Definition this credential were issued to
+* attachment `libindy-cred` - an actual credential to store, it is a json encoded in base64
+
+##### Credential Reject
+This message can be sent by any side of the conversation to finish credential issuance process without any credential created. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/reject"",
+    ""@id"": ""id""
+}
+```
+
+##### Credential Ack
+This message is sent by Prover as he confirms that he had received the credential and everything is correct. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/ack"",
+    ""@id"": ""id""
+}
+```
+
+#### State Machine
+
+The Credential Issuance State Machine consists of the following states:
+
+* Initialized
+* Issuer related states:
+    * CredentialOfferCreated
+    * CredentialRequestReceived
+    * CredentialCreated
+    * CredentialAckReceived
+* Prover related states:
+    * CredentialOfferReceived
+    * CredentialRequestCreated
+    * CredentialReceived
+    * CredentialAckCreated
+* CredentialRejectCreated
+* CredentialRejectReceived
+* Finished
+
+##### Initialized
+Common state for both parties. Indicates initiation of issuance process.
+Transitions:
+* Issuer
+    * CredentialOfferCreated - issuer acts as an initiator.
+    * CredentialRequestReceived - prover already prepared credential request and sent to issuer (prover acts as an initiator). 
+* Prover
+    * CredentialOfferReceived - prover received Credential Offer message from issuer.
+    * CredentialRequestCreated - prover already has data for request creation and acts as an initiator.
+
+##### CredentialOfferCreated
+Issuer specific state that means that Credential Offer message has been created and sent to Prover.
+Transitions:
+* CredentialRequestReceived - prover replied with Credential Request message.
+* CredentialRejectReceived - prover replied woth Credential Reject message.
+    
+##### CredentialRequestReceived
+Issuer specific state that means that Prover replied with Credential Request message on offer.
+Transitions:
+* CredentialCreated - credential created and sent to prover
+* CredentialRejectCreated - issuer interrupted credential issuance process for some reason.
+
+##### CredentialCreated
+Issuer specific state that means that Credential message has been created and sent to Prover.
+Transitions:
+* CredentialAckReceived - prover accepted credential and replied with Credential Ack message.
+* CredentialRejectReceived - prover rejected credential for some reason.
+    
+##### CredentialAckReceived
+Issuer specific state that means that Prover replied with Credential Ack message on credential.
+Transitions:
+* Finished - credential issuance process is completed.
+
+##### CredentialOfferReceived
+Prover specific state that means that Credential Offer message has been received from Issuer.
+Transitions:
+* CredentialRequestCreated - prover accepted offer and replied with Credential Request message.
+* CredentialRejectCreated - prover rejected credential offer for some reason.
+
+##### CredentialRequestCreated
+Prover specific state that means that Credential Offer message has been accepted and 
+Credential Request message created and sent to Issuer.
+Transitions:
+* CredentialReceived - credential message received from Issuer.
+* CredentialRejectReceived - issuer interrupted issuance process for some reason.
+
+##### CredentialReceived
+Prover specific state that means that Credential message has been received from Issuer.
+Transitions:
+* CredentialAckCreated - prover accepted credential and replied with Credential Ack message.
+* CredentialRejectCreated - prover rejected credential and interrupted issuance process for some reason.
+
+##### CredentialAckCreated
+Prover specific state that means that Credential Ack message created and sent to Issuer.
+Transitions:
+* Finished - credential issuance process is completed.
+
+##### CredentialRejectCreated
+Common state for both parties. Indicates interruption of issuance process.
+Transitions:
+* Finished - credential issuance process is interrupted.
+
+##### CredentialRejectReceived
+Common state for both parties. Indicates interruption of issuance process by opposite side.
+Transitions:
+* Finished - credential issuance process is interrupted.
+
+#### Choreography Diagram
+
+![Choreography Diagram](./credential-issuance.png)
+
+#### Workflow
+
+The Credential Issuance positive workflow is demonstrated on the following diagram:
+
+![Workflow](credential-issuance-positive-flow.svg)",391,2019-03-26 07:08:55,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/268963922,https://github.com/hyperledger/indy-sdk/pull/1546#discussion_r268963922,lovesh
https://github.com/hyperledger/indy-sdk/pull/1546,https://github.com/hyperledger/indy-sdk/pull/1546,"The important part is the holder shouldn't be allowed to generate the nonce otherwise cheating is possible. Selecting a nonce like the merkle root that the issuer can verify is acceptable. Otherwise, like @lovesh says you need to have the nonce come from the issuer.",7f5f50a075965fd676535ca5ac4055beeb1cc3a0,2019-03-26 14:34:32,269134768,"@@ -0,0 +1,656 @@
+# A2A part of IndySDK 2.0
+
+Author: Sergey Minaev, Matt Raffel, Artem Ivanov
+
+## Table of contents
+
+* [Motivation](#motivation)
+* [Goals](#goals-and-ideas)
+* [Overview](#overview)
+* [Discussion points](#discussion-points)
+* [Challenges](#challenges)
+* [IndySDK 2.0 structure](#indySDK-2-0-structure)
+* [Message Families & Messages](#message-families-&-messages)
+    * [Connection](#connection)
+    * [Credential Issuance](#credential-issuance)
+    * [Credential Presentation](#credential-presentation)
+* [API proposal](#api-proposal)
+    * [Namespaces](#namespaces)
+    * [Connection](#api-connection)
+    * [Credential Issuance](#api-credential-issuance)
+    * [Credential Presentation](#api-credential-presentation)
+* [Additional References](#additional-references)
+
+## Motivation
+[See](https://docs.google.com/document/d/1TTwGUtZ3vMvi8dXGB5lprxVvt6Da2___QuqCiyntdXs)
+
+## Goals and ideas
+
+New API of IndySDK should provide functionality for A2A communication but should not make assumptions about app business logic, transport, storage, etc.
+
+* Allow extending LibIndy to support new protocol message families and modifying the implementation.
+* Simplify process of making new message family definitions available in the common Indy ecosystem.
+* Simplify the process of support new agents.
+* Define default protocol message families. 
+* Define State Machine that developer have to follow to support new protocol message families.
+* Define the way LibIndy can consume new API functions.
+* Define the flow of communication Libindy static API, custom Libindy API helpers and an application.
+
+## Overview
+The main idea of new functionality of IndySDK is replace part of VCX library. 
+As for now VCX provide powerful mechanisms for handling Credential Issuance and Exchange flow, 
+but this library hardcode some FSM state transitions, transport flow, etc. New item should provide 
+similar functionality but give the application some flexibility.
+Internal states for particular message family should be more generic and must be aligned for the family definition. 
+The library should not perform any automatic transitions between states. Instead of that it should allows
+ application to perform validation of incoming message, check is it applicable to current state of the family flow. 
+ Actual transition between states should be performed by explicit call from application side.
+
+Current VCX will be moved out from HL/indy-sdk repo to Evernym or SF repo and most probably will have the same 
+API as for now.
+
+
+## Discussion points
+
+* How to allow (for external developer) to extend the set of supported message families:
+    * Proved some template files inside monolith library to copy paste, implement new message family and include to custom build.
+* What is the right place for new functionality: 
+    * Lbindy - suggested for start. It will simplify CI/CD flow significantly.
+        Message families may be implemented under cargo features so it will be possible to configure set of API for particular application.
+    * separate library
+    * something else
+* What is the right place for wrappers.
+* What should the API does:
+    * Should it include the ability to send reply messages?
+        * There are three possible approaches for Transport:
+            * Application calls framework specific functions.
+            * Pluggable functions defined as a part of Libindy Helpers API.
+            * Callbacks passed to `do step` state machine function and automatically called.
+    * Provide a default transport by providing a restful service handler?
+    * Should indy sdk manage A2A state? And Is state management something indy-sdk can really handle?
+        * New API should cover base states, described in appropriate standards/HIPEs
+* Naming of functions for particular message family helpers.
+* Ways the SDK can help agents with messages: creation, validation, and processing (processing where appropriate, not all cases).
+
+
+## Challenges
+
+Agent-2-Agent communications is highly unstable at this time as most of the HIPEs are still in development.
+
+
+## IndySDK 2.0 structure
+
+* Libindy
+    * Core namespace - current functionality
+    * A2A messages: state machines and helpers
+        * Connection message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * Credential Issuance message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * Credential Presentation message family
+            * State machine validator
+            * Message helpers (builders,parsers)
+        * ....
+        * Template message family
+            * set of .rs files, excluded from cargo project
+            * Guideline how to implement one more msg family
+* VCX will be renamed and moved out from HL/indy-sdk
+* Wrappers
+* CLI
+
+The proposal is to have set of helpers inside libindy to assists application (or agent framework). 
+This scope will include states of flow for particular Message Family. 
+API will allow to check is it possible to move forward from the flow point of view.
+libindy will contain basic message families that will be used by the majority of agents.
+
+![Components](./components.svg)
+
+## Message Families & Messages
+
+### Connection
+
+#### Message Family
+
+The Connection Message Family consists of the following messages:
+
+* Connection Invite - https://github.com/hyperledger/indy-hipe/pull/54
+* Connection Request
+* Connection Response
+* Basic Message - https://github.com/hyperledger/indy-hipe/tree/master/text/0033-basic-message
+* State
+* State Request
+* Trust Ping - https://github.com/hyperledger/indy-hipe/tree/master/text/0032-trust-ping
+* (TBD) Ephemeral Challenge - https://github.com/hyperledger/indy-hipe/pull/95
+* (TBD) Oauth ephemeral - https://github.com/hyperledger/indy-hipe/pull/96
+
+##### Connection Invite
+TBD
+
+##### Connection Request
+TBD
+
+##### Connection Response
+TBD
+
+##### Basic Message
+TBD
+
+##### State
+TBD
+
+##### State Request
+TBD
+
+##### Trust Ping
+TBD
+
+##### Ephemeral Challenge
+
+TBD
+
+##### Oauth ephemeral
+
+TBD
+
+#### State Machine
+
+Agents need to manage state.  
+Especially between connection invites since connection invites is a multi-step process.   
+
+![State Machine definition](./connection.png)
+
+TBD
+
+#### Workflow
+
+TBD
+
+### Credential Issuance
+
+#### Message Family
+
+The Credential Issuance Message Family consists of the following messages:
+
+* Credential Offer
+* Credential Request
+* Credential Reject
+* Credential
+* Credential Ack
+
+##### Credential Offer
+This message is sent by Issuer to Prover to initiate credential issuance process. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential-offer"",
+    ""@id"": ""<uuid-offer>"",
+    ""cred_def_id"": ""KTwaKJkvyjKKf55uc6U8ZB:3:CL:59:tag1"",
+    ""comment"": ""some comment"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred-offer"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        },
+        {
+            ""nickname"": ""credential-preview"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        }
+    ]
+}
+```
+
+Description of fields:
+* `comment` - a field that provide some human readable information about this Credential Offer.
+* `cred_def_id` - id cof credential definition for offered credential
+* attachment `libindy-cred-offer` - libindy generated data about credential offer
+* attachment `credential-preview` - preview of credential.
+
+##### Credential Request
+This message is sent in response to Credential Offer by Prover to give needed details for credential issuance.
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential-request"",
+    ""@id"": ""<uuid-request>"",
+    ""cred_def_id"": ""2hoqvcwupRTUNkXn6ArYzs:3:CL:1766"",
+    ""comment"": ""some comment"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred-req"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        },
+        {
+            ""nickname"": ""credential-preview"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""
+            }
+        }
+    ]
+}
+```
+
+Description of Fields:
+* `cred_def_id` - Credential Definition ID for requested credential
+* `comment` - a field that provide some human readable information about this Credential Offer.
+* attachment `libindy-cred-req` - libindy generated data that is needed to Issuer to issue a credential.
+* attachment `credential-preview` - optional attachment with preview of credential that Prover wants to get.
+
+##### Credential
+This message contains the credential and sent in responce to Credential Request by Issuer. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/credential"",
+    ""@id"": ""<uuid-credential>"",
+    ""rev_reg_def_id"": ""<rev_reg_def_id>"",
+    ""cred_def_id"": ""2hoqvcwupRTUNkXn6ArYzs:3:CL:1766"",
+    ""~attach"": [
+        {
+            ""nickname"": ""libindy-cred"",
+            ""mime-type"": ""application/json"",
+            ""content"": {
+                ""base64"": ""<bytes for base64>""  
+            }
+        }
+    ]
+}
+```
+
+Description of fields:
+
+* `rev_reg_def_id` - ID of Revocation Registry Definition this credential were issued to
+* `cred_def_id` - ID of Credential Definition this credential were issued to
+* attachment `libindy-cred` - an actual credential to store, it is a json encoded in base64
+
+##### Credential Reject
+This message can be sent by any side of the conversation to finish credential issuance process without any credential created. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/reject"",
+    ""@id"": ""id""
+}
+```
+
+##### Credential Ack
+This message is sent by Prover as he confirms that he had received the credential and everything is correct. 
+Schema:
+```json
+{
+    ""@type"": ""did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/credential-issuance/1.0/ack"",
+    ""@id"": ""id""
+}
+```
+
+#### State Machine
+
+The Credential Issuance State Machine consists of the following states:
+
+* Initialized
+* Issuer related states:
+    * CredentialOfferCreated
+    * CredentialRequestReceived
+    * CredentialCreated
+    * CredentialAckReceived
+* Prover related states:
+    * CredentialOfferReceived
+    * CredentialRequestCreated
+    * CredentialReceived
+    * CredentialAckCreated
+* CredentialRejectCreated
+* CredentialRejectReceived
+* Finished
+
+##### Initialized
+Common state for both parties. Indicates initiation of issuance process.
+Transitions:
+* Issuer
+    * CredentialOfferCreated - issuer acts as an initiator.
+    * CredentialRequestReceived - prover already prepared credential request and sent to issuer (prover acts as an initiator). 
+* Prover
+    * CredentialOfferReceived - prover received Credential Offer message from issuer.
+    * CredentialRequestCreated - prover already has data for request creation and acts as an initiator.
+
+##### CredentialOfferCreated
+Issuer specific state that means that Credential Offer message has been created and sent to Prover.
+Transitions:
+* CredentialRequestReceived - prover replied with Credential Request message.
+* CredentialRejectReceived - prover replied woth Credential Reject message.
+    
+##### CredentialRequestReceived
+Issuer specific state that means that Prover replied with Credential Request message on offer.
+Transitions:
+* CredentialCreated - credential created and sent to prover
+* CredentialRejectCreated - issuer interrupted credential issuance process for some reason.
+
+##### CredentialCreated
+Issuer specific state that means that Credential message has been created and sent to Prover.
+Transitions:
+* CredentialAckReceived - prover accepted credential and replied with Credential Ack message.
+* CredentialRejectReceived - prover rejected credential for some reason.
+    
+##### CredentialAckReceived
+Issuer specific state that means that Prover replied with Credential Ack message on credential.
+Transitions:
+* Finished - credential issuance process is completed.
+
+##### CredentialOfferReceived
+Prover specific state that means that Credential Offer message has been received from Issuer.
+Transitions:
+* CredentialRequestCreated - prover accepted offer and replied with Credential Request message.
+* CredentialRejectCreated - prover rejected credential offer for some reason.
+
+##### CredentialRequestCreated
+Prover specific state that means that Credential Offer message has been accepted and 
+Credential Request message created and sent to Issuer.
+Transitions:
+* CredentialReceived - credential message received from Issuer.
+* CredentialRejectReceived - issuer interrupted issuance process for some reason.
+
+##### CredentialReceived
+Prover specific state that means that Credential message has been received from Issuer.
+Transitions:
+* CredentialAckCreated - prover accepted credential and replied with Credential Ack message.
+* CredentialRejectCreated - prover rejected credential and interrupted issuance process for some reason.
+
+##### CredentialAckCreated
+Prover specific state that means that Credential Ack message created and sent to Issuer.
+Transitions:
+* Finished - credential issuance process is completed.
+
+##### CredentialRejectCreated
+Common state for both parties. Indicates interruption of issuance process.
+Transitions:
+* Finished - credential issuance process is interrupted.
+
+##### CredentialRejectReceived
+Common state for both parties. Indicates interruption of issuance process by opposite side.
+Transitions:
+* Finished - credential issuance process is interrupted.
+
+#### Choreography Diagram
+
+![Choreography Diagram](./credential-issuance.png)
+
+#### Workflow
+
+The Credential Issuance positive workflow is demonstrated on the following diagram:
+
+![Workflow](credential-issuance-positive-flow.svg)",391,2019-03-26 14:34:33,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/269134768,https://github.com/hyperledger/indy-sdk/pull/1546#discussion_r269134768,mikelodder7
https://github.com/hyperledger/indy-sdk/pull/1542,https://github.com/hyperledger/indy-sdk/pull/1542,pls fix a typo,254ed631e511af46419bb88208ae1955b66ce7df,2019-03-20 12:12:32,267307082,"@@ -430,4 +430,48 @@ libvcx sets the same log function for libindy as well.
 
 ## Libvcx 0.2.0 to 0.2.1 migration Guide
 
-The Libvcx 0.2.1 release contains fixes that don't affect API functions. 
\ No newline at end of file
+The Libvcx 0.2.1 release contains fixes that don't affect API functions. 
+
+## Libvcx 0.2.1 to 0.2.2 migration Guide
+
+The Libvcx 0.2.2 release contains fixes that don't affect API functions. 
+
+## Libvcx 0.2.2 to 0.2.23 migration Guide",,2019-03-25 19:04:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/267307082,https://github.com/hyperledger/indy-sdk/pull/1542#discussion_r267307082,jovfer
https://github.com/hyperledger/indy-sdk/pull/1539,https://github.com/hyperledger/indy-sdk/pull/1539,"Is it really CommandHandle in the result? AFAIR it should be blob reader handle, but I may be wrong",49f1743f66d681af34a7cf969dcce46cb0cde6d5,2019-03-18 15:11:20,266489021,"@@ -1,38 +1,39 @@
 use futures::Future;
 
-use {ErrorCode, IndyHandle, IndyError};
+use {ErrorCode, IndyError};
 
 use std::ffi::CString;
 
 use ffi::blob_storage;
 use ffi::ResponseI32CB;
 
 use utils::callbacks::{ClosureHandler, ResultHandler};
+use ffi::CommandHandle;
 
-pub fn open_reader(xtype: &str, config_json: &str) -> Box<Future<Item=IndyHandle, Error=IndyError>> {
+pub fn open_reader(xtype: &str, config_json: &str) -> Box<Future<Item=CommandHandle, Error=IndyError>> {",15,2019-04-01 08:57:55,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/266489021,https://github.com/hyperledger/indy-sdk/pull/1539#discussion_r266489021,jovfer
https://github.com/hyperledger/indy-sdk/pull/1539,https://github.com/hyperledger/indy-sdk/pull/1539,"actually that seems to be something I don't have yet. It is a ConfigHandle.
https://github.com/hyperledger/indy-sdk/blob/master/libindy/src/services/blob_storage/mod.rs#L128",49f1743f66d681af34a7cf969dcce46cb0cde6d5,2019-03-18 20:23:44,266625915,"@@ -1,38 +1,39 @@
 use futures::Future;
 
-use {ErrorCode, IndyHandle, IndyError};
+use {ErrorCode, IndyError};
 
 use std::ffi::CString;
 
 use ffi::blob_storage;
 use ffi::ResponseI32CB;
 
 use utils::callbacks::{ClosureHandler, ResultHandler};
+use ffi::CommandHandle;
 
-pub fn open_reader(xtype: &str, config_json: &str) -> Box<Future<Item=IndyHandle, Error=IndyError>> {
+pub fn open_reader(xtype: &str, config_json: &str) -> Box<Future<Item=CommandHandle, Error=IndyError>> {",15,2019-04-01 08:57:55,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/266625915,https://github.com/hyperledger/indy-sdk/pull/1539#discussion_r266625915,AxelNennker
https://github.com/hyperledger/indy-sdk/pull/1539,https://github.com/hyperledger/indy-sdk/pull/1539,"It seems I would have to add something like ResponseI32CB for each new type that replaces i32 e.g. ResponseBlobStorageConfigHandleCB. Which is a lot of work. Probably this should be done type by type.
Some more macros might help. Maybe reintroduce IndyHandle for now?

The amount of boilerplate in indy-sdk is quite overwhelming. ",49f1743f66d681af34a7cf969dcce46cb0cde6d5,2019-03-19 10:55:04,266829229,"@@ -1,38 +1,39 @@
 use futures::Future;
 
-use {ErrorCode, IndyHandle, IndyError};
+use {ErrorCode, IndyError};
 
 use std::ffi::CString;
 
 use ffi::blob_storage;
 use ffi::ResponseI32CB;
 
 use utils::callbacks::{ClosureHandler, ResultHandler};
+use ffi::CommandHandle;
 
-pub fn open_reader(xtype: &str, config_json: &str) -> Box<Future<Item=IndyHandle, Error=IndyError>> {
+pub fn open_reader(xtype: &str, config_json: &str) -> Box<Future<Item=CommandHandle, Error=IndyError>> {",15,2019-04-01 08:57:55,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/266829229,https://github.com/hyperledger/indy-sdk/pull/1539#discussion_r266829229,AxelNennker
https://github.com/hyperledger/indy-sdk/pull/1537,https://github.com/hyperledger/indy-sdk/pull/1537,@lovesh please restore initial location of this function against others in the file. I would like to have clear diff for discussion in progress. And when we will be ready to merge - we can change the order,afeeb267210db30ebcae806001ef9123d6a25a85,2019-03-18 10:20:52,266372924,"@@ -397,15 +397,73 @@ impl CryptoCommandExecutor {
         // Use AEAD to encrypt `message` with ""protected"" data as ""associated data""
         let (ciphertext, iv, tag) =
             self.crypto_service
-                .encrypt_plaintext(message, &base64_protected, &cek);
+                .encrypt_plaintext(message, &json_str, &cek);
 
         self._format_pack_message(&base64_protected, &ciphertext, &iv, &tag)
     }
 
+    pub fn unpack_msg(&self, jwe_json: Vec<u8>, wallet_handle: WalletHandle) -> IndyResult<Vec<u8>> {",,2019-03-19 19:31:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/266372924,https://github.com/hyperledger/indy-sdk/pull/1537#discussion_r266372924,jovfer
https://github.com/hyperledger/indy-sdk/pull/1528,https://github.com/hyperledger/indy-sdk/pull/1528,"@mattraffel the github report that it should be 4.0.0+ https://github.com/hyperledger/indy-sdk/network/alert/vcx/wrappers/node/package-lock.json/just-extend/open
but here I can see old version. Could you double check it?",1bbe06bdb41c88cb5b180884c56ece902a233d88,2019-03-14 15:19:46,265622295,"@@ -1,4535 +1,6734 @@
 {
-  ""name"": ""node-vcx-wrapper"",
-  ""version"": ""0.2.2"",
-  ""lockfileVersion"": 1,
-  ""requires"": true,
-  ""dependencies"": {
-    ""@types/chai"": {
-      ""version"": ""4.1.4"",
-      ""resolved"": ""https://registry.npmjs.org/@types/chai/-/chai-4.1.4.tgz"",
-      ""integrity"": ""sha512-h6+VEw2Vr3ORiFCyyJmcho2zALnUq9cvdB/IO8Xs9itrJVCenC7o26A6+m7D0ihTTr65eS259H5/Ghl/VjYs6g=="",
-      ""dev"": true
-    },
-    ""@types/events"": {
-      ""version"": ""1.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/@types/events/-/events-1.2.0.tgz"",
-      ""integrity"": ""sha512-KEIlhXnIutzKwRbQkGWb/I4HFqBuUykAdHgDED6xqwXJfONCjF5VoE0cXEiurh3XauygxzeDzgtXUqvLkxFzzA=="",
-      ""dev"": true
-    },
-    ""@types/ffi"": {
-      ""version"": ""0.0.19"",
-      ""resolved"": ""https://registry.npmjs.org/@types/ffi/-/ffi-0.0.19.tgz"",
-      ""integrity"": ""sha1-vaEt6ZnhpuRTK4RElzGNuuuYT4I="",
-      ""requires"": {
-        ""@types/node"": ""8.0.47"",
-        ""@types/ref"": ""0.0.28"",
-        ""@types/ref-struct"": ""0.0.28""
-      }
-    },
-    ""@types/fs-extra"": {
-      ""version"": ""5.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/@types/fs-extra/-/fs-extra-5.0.1.tgz"",
-      ""integrity"": ""sha512-h3wnflb+jMTipvbbZnClgA2BexrT4w0GcfoCz5qyxd0IRsbqhLSyesM6mqZTAnhbVmhyTm5tuxfRu9R+8l+lGw=="",
-      ""dev"": true,
-      ""requires"": {
-        ""@types/node"": ""8.0.47""
-      }
-    },
-    ""@types/glob"": {
-      ""version"": ""7.1.0"",
-      ""resolved"": ""https://registry.npmjs.org/@types/glob/-/glob-7.1.0.tgz"",
-      ""integrity"": ""sha512-k1M3Y8Ge0bOkG7U5IZObIhkrzZHMpuFpd5RJK9Gh8ekq0EhiezLLqv2ow14ylTKqXTHSqM6AMySbWEHRo+7qdQ=="",
-      ""dev"": true,
-      ""requires"": {
-        ""@types/events"": ""1.2.0"",
-        ""@types/minimatch"": ""3.0.3"",
-        ""@types/node"": ""8.0.47""
-      }
-    },
-    ""@types/handlebars"": {
-      ""version"": ""4.0.36"",
-      ""resolved"": ""https://registry.npmjs.org/@types/handlebars/-/handlebars-4.0.36.tgz"",
-      ""integrity"": ""sha512-LjNiTX7TY7wtuC6y3QwC93hKMuqYhgV9A1uXBKNvZtVC8ZvyWAjZkJ5BvT0K7RKqORRYRLMrqCxpw5RgS+MdrQ=="",
-      ""dev"": true
-    },
-    ""@types/highlight.js"": {
-      ""version"": ""9.12.2"",
-      ""resolved"": ""https://registry.npmjs.org/@types/highlight.js/-/highlight.js-9.12.2.tgz"",
-      ""integrity"": ""sha512-y5x0XD/WXDaGSyiTaTcKS4FurULJtSiYbGTeQd0m2LYZGBcZZ/7fM6t5H/DzeUF+kv8y6UfmF6yJABQsHcp9VQ=="",
-      ""dev"": true
-    },
-    ""@types/lodash"": {
-      ""version"": ""4.14.109"",
-      ""resolved"": ""https://registry.npmjs.org/@types/lodash/-/lodash-4.14.109.tgz"",
-      ""integrity"": ""sha512-hop8SdPUEzbcJm6aTsmuwjIYQo1tqLseKCM+s2bBqTU2gErwI4fE+aqUVOlscPSQbKHKgtMMPoC+h4AIGOJYvw=="",
-      ""dev"": true
-    },
-    ""@types/marked"": {
-      ""version"": ""0.3.0"",
-      ""resolved"": ""https://registry.npmjs.org/@types/marked/-/marked-0.3.0.tgz"",
-      ""integrity"": ""sha512-CSf9YWJdX1DkTNu9zcNtdCcn6hkRtB5ILjbhRId4ZOQqx30fXmdecuaXhugQL6eyrhuXtaHJ7PHI+Vm7k9ZJjg=="",
-      ""dev"": true
-    },
-    ""@types/minimatch"": {
-      ""version"": ""3.0.3"",
-      ""resolved"": ""https://registry.npmjs.org/@types/minimatch/-/minimatch-3.0.3.tgz"",
-      ""integrity"": ""sha512-tHq6qdbT9U1IRSGf14CL0pUlULksvY9OZ+5eEgl1N7t+OA3tGvNpxJCzuKQlsNgCVwbAs670L1vcVQi8j9HjnA=="",
-      ""dev"": true
-    },
-    ""@types/mocha"": {
-      ""version"": ""5.2.3"",
-      ""resolved"": ""https://registry.npmjs.org/@types/mocha/-/mocha-5.2.3.tgz"",
-      ""integrity"": ""sha512-C1wVVr7xhKu6c3Mb27dFzNYR05qvHwgtpN+JOYTGc1pKA7dCEDDYpscn7kul+bCUwa3NoGDbzI1pdznSOa397w=="",
-      ""dev"": true
-    },
-    ""@types/node"": {
-      ""version"": ""8.0.47"",
-      ""resolved"": ""https://registry.npmjs.org/@types/node/-/node-8.0.47.tgz"",
-      ""integrity"": ""sha512-kOwL746WVvt/9Phf6/JgX/bsGQvbrK5iUgzyfwZNcKVFcjAUVSpF9HxevLTld2SG9aywYHOILj38arDdY1r/iQ==""
-    },
-    ""@types/ref"": {
-      ""version"": ""0.0.28"",
-      ""resolved"": ""https://registry.npmjs.org/@types/ref/-/ref-0.0.28.tgz"",
-      ""integrity"": ""sha1-FaYSU+0SWQOLR0md4cmwy8pX9Vw="",
-      ""requires"": {
-        ""@types/node"": ""8.0.47""
-      }
-    },
-    ""@types/ref-struct"": {
-      ""version"": ""0.0.28"",
-      ""resolved"": ""https://registry.npmjs.org/@types/ref-struct/-/ref-struct-0.0.28.tgz"",
-      ""integrity"": ""sha1-uECorElUEVFdyuIJAQ1axmFVDoQ="",
-      ""requires"": {
-        ""@types/ref"": ""0.0.28""
-      }
-    },
-    ""@types/shelljs"": {
-      ""version"": ""0.7.8"",
-      ""resolved"": ""https://registry.npmjs.org/@types/shelljs/-/shelljs-0.7.8.tgz"",
-      ""integrity"": ""sha512-M2giRw93PxKS7YjU6GZjtdV9HASdB7TWqizBXe4Ju7AqbKlWvTr0gNO92XH56D/gMxqD/jNHLNfC5hA34yGqrQ=="",
-      ""dev"": true,
-      ""requires"": {
-        ""@types/glob"": ""7.1.0"",
-        ""@types/node"": ""8.0.47""
-      }
-    },
-    ""@types/sinon"": {
-      ""version"": ""5.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/@types/sinon/-/sinon-5.0.1.tgz"",
-      ""integrity"": ""sha512-yxzBCIjE3lp9lYjfBbIK/LRCoXgCLLbIIBIje7eNCcUIIR2CZZtyX5uto2hVoMSMqLrsRrT6mwwUEd0yFgOwpA=="",
-      ""dev"": true
-    },
-    ""@types/weak"": {
-      ""version"": ""1.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/@types/weak/-/weak-1.0.0.tgz"",
-      ""integrity"": ""sha512-6WXZpeAac3vj5+OfQvlqYEtc88oOgvkcxbrnmBw53Da6gA+MGztL+Hns3BpnyUevgz+4DxsJblgAew1A/tkcng=="",
-      ""dev"": true,
-      ""requires"": {
-        ""@types/node"": ""8.0.47""
-      }
-    },
-    ""ansi-regex"": {
-      ""version"": ""2.1.1"",
-      ""resolved"": ""https://registry.npmjs.org/ansi-regex/-/ansi-regex-2.1.1.tgz"",
-      ""integrity"": ""sha1-w7M6te42DYbg5ijwRorn7yfWVN8="",
-      ""dev"": true
-    },
-    ""ansi-styles"": {
-      ""version"": ""2.2.1"",
-      ""resolved"": ""https://registry.npmjs.org/ansi-styles/-/ansi-styles-2.2.1.tgz"",
-      ""integrity"": ""sha1-tDLdM1i2NM914eRmQ2gkBTPB3b4="",
-      ""dev"": true
-    },
-    ""anymatch"": {
-      ""version"": ""1.3.2"",
-      ""resolved"": ""https://registry.npmjs.org/anymatch/-/anymatch-1.3.2.tgz"",
-      ""integrity"": ""sha512-0XNayC8lTHQ2OI8aljNCN3sSx6hsr/1+rlcDAotXJR7C1oZZHCNsfpbKwMjRA3Uqb5tF1Rae2oloTr4xpq+WjA=="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""micromatch"": ""2.3.11"",
-        ""normalize-path"": ""2.1.1""
-      }
-    },
-    ""app-module-path"": {
-      ""version"": ""2.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/app-module-path/-/app-module-path-2.2.0.tgz"",
-      ""integrity"": ""sha1-ZBqlXft9am8KgUHEucCqULbCTdU="",
-      ""dev"": true
-    },
-    ""arr-diff"": {
-      ""version"": ""2.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/arr-diff/-/arr-diff-2.0.0.tgz"",
-      ""integrity"": ""sha1-jzuCf5Vai9ZpaX5KQlasPOrjVs8="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""arr-flatten"": ""1.1.0""
-      }
-    },
-    ""arr-flatten"": {
-      ""version"": ""1.1.0"",
-      ""resolved"": ""https://registry.npmjs.org/arr-flatten/-/arr-flatten-1.1.0.tgz"",
-      ""integrity"": ""sha512-L3hKV5R/p5o81R7O02IGnwpDmkp6E982XhtbuwSe3O4qOtMMMtodicASA1Cny2U+aCXcNpml+m4dPsvsJ3jatg=="",
-      ""dev"": true
-    },
-    ""arr-union"": {
-      ""version"": ""3.1.0"",
-      ""resolved"": ""https://registry.npmjs.org/arr-union/-/arr-union-3.1.0.tgz"",
-      ""integrity"": ""sha1-45sJrqne+Gao8gbiiK9jkZuuOcQ="",
-      ""dev"": true
-    },
-    ""array-unique"": {
-      ""version"": ""0.2.1"",
-      ""resolved"": ""https://registry.npmjs.org/array-unique/-/array-unique-0.2.1.tgz"",
-      ""integrity"": ""sha1-odl8yvy8JiXMcPrc6zalDFiwGlM="",
-      ""dev"": true,
-      ""optional"": true
-    },
-    ""arrify"": {
-      ""version"": ""1.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/arrify/-/arrify-1.0.1.tgz"",
-      ""integrity"": ""sha1-iYUI2iIm84DfkEcoRWhJwVAaSw0="",
-      ""dev"": true
-    },
-    ""assertion-error"": {
-      ""version"": ""1.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/assertion-error/-/assertion-error-1.0.2.tgz"",
-      ""integrity"": ""sha1-E8pRXYYgbaC6xm6DTdOX2HWBCUw="",
-      ""dev"": true
-    },
-    ""assign-symbols"": {
-      ""version"": ""1.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/assign-symbols/-/assign-symbols-1.0.0.tgz"",
-      ""integrity"": ""sha1-WWZ/QfrdTyDMvCu5a41Pf3jsA2c="",
-      ""dev"": true
-    },
-    ""async"": {
-      ""version"": ""2.6.1"",
-      ""resolved"": ""https://registry.npmjs.org/async/-/async-2.6.1.tgz"",
-      ""integrity"": ""sha512-fNEiL2+AZt6AlAw/29Cr0UDe4sRAHCpEHh54WMz+Bb7QfNcFw4h3loofyJpLeQs4Yx7yuqu/2dLgM5hKOs6HlQ=="",
-      ""dev"": true,
-      ""requires"": {
-        ""lodash"": ""4.17.11""
-      },
-      ""dependencies"": {
-        ""lodash"": {
-          ""version"": ""4.17.11"",
-          ""resolved"": ""https://registry.npmjs.org/lodash/-/lodash-4.17.11.tgz"",
-          ""integrity"": ""sha512-cQKh8igo5QUhZ7lg38DYWAxMvjSAKG0A8wGSVimP07SIUEK2UO+arSRKbRZWtelMtN5V0Hkwh5ryOto/SshYIg=="",
-          ""dev"": true
-        }
-      }
-    },
-    ""async-each"": {
-      ""version"": ""1.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/async-each/-/async-each-1.0.1.tgz"",
-      ""integrity"": ""sha1-GdOGodntxufByF04iu28xW0zYC0="",
-      ""dev"": true,
-      ""optional"": true
-    },
-    ""atob"": {
-      ""version"": ""2.1.2"",
-      ""resolved"": ""https://registry.npmjs.org/atob/-/atob-2.1.2.tgz"",
-      ""integrity"": ""sha512-Wm6ukoaOGJi/73p/cl2GvLjTI5JM1k/O14isD73YML8StrH/7/lRFgmg8nICZgD3bZZvjwCGxtMOD3wWNAu8cg=="",
-      ""dev"": true
-    },
-    ""babel-cli"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-cli/-/babel-cli-6.26.0.tgz"",
-      ""integrity"": ""sha1-UCq1SHTX24itALiHoGODzgPQAvE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-core"": ""6.26.3"",
-        ""babel-polyfill"": ""6.26.0"",
-        ""babel-register"": ""6.26.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""chokidar"": ""1.7.0"",
-        ""commander"": ""2.11.0"",
-        ""convert-source-map"": ""1.6.0"",
-        ""fs-readdir-recursive"": ""1.1.0"",
-        ""glob"": ""7.1.3"",
-        ""lodash"": ""4.17.11"",
-        ""output-file-sync"": ""1.1.2"",
-        ""path-is-absolute"": ""1.0.1"",
-        ""slash"": ""1.0.0"",
-        ""source-map"": ""0.5.7"",
-        ""v8flags"": ""2.1.1""
-      },
-      ""dependencies"": {
-        ""source-map"": {
-          ""version"": ""0.5.7"",
-          ""resolved"": ""https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz"",
-          ""integrity"": ""sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-code-frame"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-code-frame/-/babel-code-frame-6.26.0.tgz"",
-      ""integrity"": ""sha1-Y/1D99weO7fONZR9uP42mj9Yx0s="",
-      ""dev"": true,
-      ""requires"": {
-        ""chalk"": ""1.1.3"",
-        ""esutils"": ""2.0.2"",
-        ""js-tokens"": ""3.0.2""
-      },
-      ""dependencies"": {
-        ""esutils"": {
-          ""version"": ""2.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/esutils/-/esutils-2.0.2.tgz"",
-          ""integrity"": ""sha1-Cr9PHKpbyx96nYrMbepPqqBLrJs="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-core"": {
-      ""version"": ""6.26.3"",
-      ""resolved"": ""https://registry.npmjs.org/babel-core/-/babel-core-6.26.3.tgz"",
-      ""integrity"": ""sha512-6jyFLuDmeidKmUEb3NM+/yawG0M2bDZ9Z1qbZP59cyHLz8kYGKYwpJP0UwUKKUiTRNvxfLesJnTedqczP7cTDA=="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-code-frame"": ""6.26.0"",
-        ""babel-generator"": ""6.26.1"",
-        ""babel-helpers"": ""6.24.1"",
-        ""babel-messages"": ""6.23.0"",
-        ""babel-register"": ""6.26.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""babylon"": ""6.18.0"",
-        ""convert-source-map"": ""1.6.0"",
-        ""debug"": ""2.6.9"",
-        ""json5"": ""0.5.1"",
-        ""lodash"": ""4.17.11"",
-        ""minimatch"": ""3.0.4"",
-        ""path-is-absolute"": ""1.0.1"",
-        ""private"": ""0.1.8"",
-        ""slash"": ""1.0.0"",
-        ""source-map"": ""0.5.7""
-      },
-      ""dependencies"": {
-        ""babylon"": {
-          ""version"": ""6.18.0"",
-          ""resolved"": ""https://registry.npmjs.org/babylon/-/babylon-6.18.0.tgz"",
-          ""integrity"": ""sha512-q/UEjfGJ2Cm3oKV71DJz9d25TPnq5rhBVL2Q4fA5wcC3jcrdn7+SssEybFIxwAvvP+YCsCYNKughoF33GxgycQ=="",
-          ""dev"": true
+    ""name"": ""node-vcx-wrapper"",
+    ""version"": ""0.2.2"",
+    ""lockfileVersion"": 1,
+    ""requires"": true,
+    ""dependencies"": {
+        ""@types/chai"": {
+            ""version"": ""4.1.4"",
+            ""resolved"": ""https://registry.npmjs.org/@types/chai/-/chai-4.1.4.tgz"",
+            ""integrity"": ""sha512-h6+VEw2Vr3ORiFCyyJmcho2zALnUq9cvdB/IO8Xs9itrJVCenC7o26A6+m7D0ihTTr65eS259H5/Ghl/VjYs6g=="",
+            ""dev"": true
+        },
+        ""@types/events"": {
+            ""version"": ""1.2.0"",
+            ""resolved"": ""https://registry.npmjs.org/@types/events/-/events-1.2.0.tgz"",
+            ""integrity"": ""sha512-KEIlhXnIutzKwRbQkGWb/I4HFqBuUykAdHgDED6xqwXJfONCjF5VoE0cXEiurh3XauygxzeDzgtXUqvLkxFzzA=="",
+            ""dev"": true
+        },
+        ""@types/ffi"": {
+            ""version"": ""0.0.19"",
+            ""resolved"": ""https://registry.npmjs.org/@types/ffi/-/ffi-0.0.19.tgz"",
+            ""integrity"": ""sha1-vaEt6ZnhpuRTK4RElzGNuuuYT4I="",
+            ""requires"": {
+                ""@types/node"": ""*"",
+                ""@types/ref"": ""*"",
+                ""@types/ref-struct"": ""*""
+            }
         },
-        ""source-map"": {
-          ""version"": ""0.5.7"",
-          ""resolved"": ""https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz"",
-          ""integrity"": ""sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-generator"": {
-      ""version"": ""6.26.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-generator/-/babel-generator-6.26.1.tgz"",
-      ""integrity"": ""sha512-HyfwY6ApZj7BYTcJURpM5tznulaBvyio7/0d4zFOeMPUmfxkCjHocCuoLa2SAGzBI8AREcH3eP3758F672DppA=="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-messages"": ""6.23.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""detect-indent"": ""4.0.0"",
-        ""jsesc"": ""1.3.0"",
-        ""lodash"": ""4.17.11"",
-        ""source-map"": ""0.5.7"",
-        ""trim-right"": ""1.0.1""
-      },
-      ""dependencies"": {
-        ""source-map"": {
-          ""version"": ""0.5.7"",
-          ""resolved"": ""https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz"",
-          ""integrity"": ""sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-helper-call-delegate"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-call-delegate/-/babel-helper-call-delegate-6.24.1.tgz"",
-      ""integrity"": ""sha1-7Oaqzdx25Bw0YfiL/Fdb0Nqi340="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-hoist-variables"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helper-define-map"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-define-map/-/babel-helper-define-map-6.26.0.tgz"",
-      ""integrity"": ""sha1-pfVtq0GiX5fstJjH66ypgZ+Vvl8="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-function-name"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""lodash"": ""4.17.11""
-      }
-    },
-    ""babel-helper-function-name"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-function-name/-/babel-helper-function-name-6.24.1.tgz"",
-      ""integrity"": ""sha1-00dbjAPtmCQqJbSDUasYOZ01gKk="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-get-function-arity"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helper-get-function-arity"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-get-function-arity/-/babel-helper-get-function-arity-6.24.1.tgz"",
-      ""integrity"": ""sha1-j3eCqpNAfEHTqlCQj4mwMbG2hT0="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helper-hoist-variables"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-hoist-variables/-/babel-helper-hoist-variables-6.24.1.tgz"",
-      ""integrity"": ""sha1-HssnaJydJVE+rbyZFKc/VAi+enY="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helper-optimise-call-expression"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-optimise-call-expression/-/babel-helper-optimise-call-expression-6.24.1.tgz"",
-      ""integrity"": ""sha1-96E0J7qfc/j0+pk8VKl4gtEkQlc="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helper-regex"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-regex/-/babel-helper-regex-6.26.0.tgz"",
-      ""integrity"": ""sha1-MlxZ+QL4LyS3T6zu0DY5VPZJXnI="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""lodash"": ""4.17.11""
-      }
-    },
-    ""babel-helper-replace-supers"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-replace-supers/-/babel-helper-replace-supers-6.24.1.tgz"",
-      ""integrity"": ""sha1-v22/5Dk40XNpohPKiov3S2qQqxo="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-optimise-call-expression"": ""6.24.1"",
-        ""babel-messages"": ""6.23.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helpers"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helpers/-/babel-helpers-6.24.1.tgz"",
-      ""integrity"": ""sha1-NHHenK7DiOXIUOWX5Yom3fN2ArI="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0""
-      }
-    },
-    ""babel-loader"": {
-      ""version"": ""6.2.4"",
-      ""resolved"": ""https://registry.npmjs.org/babel-loader/-/babel-loader-6.2.4.tgz"",
-      ""integrity"": ""sha1-qnCv+N3CI6WVLoOaQ6bDpMi/oek="",
-      ""dev"": true,
-      ""requires"": {
-        ""loader-utils"": ""0.2.17"",
-        ""mkdirp"": ""0.5.1"",
-        ""object-assign"": ""4.1.1""
-      }
-    },
-    ""babel-messages"": {
-      ""version"": ""6.23.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-messages/-/babel-messages-6.23.0.tgz"",
-      ""integrity"": ""sha1-8830cDhYA1sqKVHG7F7fbGLyYw4="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-check-es2015-constants"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-check-es2015-constants/-/babel-plugin-check-es2015-constants-6.22.0.tgz"",
-      ""integrity"": ""sha1-NRV7EBQm/S/9PaP3XH0ekYNbv4o="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-arrow-functions"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-arrow-functions/-/babel-plugin-transform-es2015-arrow-functions-6.22.0.tgz"",
-      ""integrity"": ""sha1-RSaSy3EdX3ncf4XkQM5BufJE0iE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-block-scoped-functions"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-block-scoped-functions/-/babel-plugin-transform-es2015-block-scoped-functions-6.22.0.tgz"",
-      ""integrity"": ""sha1-u8UbSflk1wy42OC5ToICRs46YUE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-block-scoping"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-block-scoping/-/babel-plugin-transform-es2015-block-scoping-6.26.0.tgz"",
-      ""integrity"": ""sha1-1w9SmcEwjQXBL0Y4E7CgnnOxiV8="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""lodash"": ""4.17.11""
-      }
-    },
-    ""babel-plugin-transform-es2015-classes"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-classes/-/babel-plugin-transform-es2015-classes-6.24.1.tgz"",
-      ""integrity"": ""sha1-WkxYpQyclGHlZLSyo7+ryXolhNs="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-define-map"": ""6.26.0"",
-        ""babel-helper-function-name"": ""6.24.1"",
-        ""babel-helper-optimise-call-expression"": ""6.24.1"",
-        ""babel-helper-replace-supers"": ""6.24.1"",
-        ""babel-messages"": ""6.23.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-computed-properties"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-computed-properties/-/babel-plugin-transform-es2015-computed-properties-6.24.1.tgz"",
-      ""integrity"": ""sha1-b+Ko0WiV1WNPTNmZttNICjCBWbM="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-destructuring"": {
-      ""version"": ""6.23.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-destructuring/-/babel-plugin-transform-es2015-destructuring-6.23.0.tgz"",
-      ""integrity"": ""sha1-mXux8auWf2gtKwh2/jWNYOdlxW0="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-duplicate-keys"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-duplicate-keys/-/babel-plugin-transform-es2015-duplicate-keys-6.24.1.tgz"",
-      ""integrity"": ""sha1-c+s9MQypaePvnskcU3QabxV2Qj4="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-for-of"": {
-      ""version"": ""6.23.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-for-of/-/babel-plugin-transform-es2015-for-of-6.23.0.tgz"",
-      ""integrity"": ""sha1-9HyVsrYT3x0+zC/bdXNiPHUkhpE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-function-name"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-function-name/-/babel-plugin-transform-es2015-function-name-6.24.1.tgz"",
-      ""integrity"": ""sha1-g0yJhTvDaxrw86TF26qU/Y6sqos="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-function-name"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-literals"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-literals/-/babel-plugin-transform-es2015-literals-6.22.0.tgz"",
-      ""integrity"": ""sha1-T1SgLWzWbPkVKAAZox0xklN3yi4="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-modules-amd"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-modules-amd/-/babel-plugin-transform-es2015-modules-amd-6.24.1.tgz"",
-      ""integrity"": ""sha1-Oz5UAXI5hC1tGcMBHEvS8AoA0VQ="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-plugin-transform-es2015-modules-commonjs"": ""6.26.2"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-modules-commonjs"": {
-      ""version"": ""6.26.2"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-modules-commonjs/-/babel-plugin-transform-es2015-modules-commonjs-6.26.2.tgz"",
-      ""integrity"": ""sha512-CV9ROOHEdrjcwhIaJNBGMBCodN+1cfkwtM1SbUHmvyy35KGT7fohbpOxkE2uLz1o6odKK2Ck/tz47z+VqQfi9Q=="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-plugin-transform-strict-mode"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-modules-systemjs"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-modules-systemjs/-/babel-plugin-transform-es2015-modules-systemjs-6.24.1.tgz"",
-      ""integrity"": ""sha1-/4mhQrkRmpBhlfXxBuzzBdlAfSM="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-hoist-variables"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-modules-umd"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-modules-umd/-/babel-plugin-transform-es2015-modules-umd-6.24.1.tgz"",
-      ""integrity"": ""sha1-rJl+YoXNGO1hdq22B9YCNErThGg="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-plugin-transform-es2015-modules-amd"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-object-super"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-object-super/-/babel-plugin-transform-es2015-object-super-6.24.1.tgz"",
-      ""integrity"": ""sha1-JM72muIcuDp/hgPa0CH1cusnj40="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-replace-supers"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-parameters"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-parameters/-/babel-plugin-transform-es2015-parameters-6.24.1.tgz"",
-      ""integrity"": ""sha1-V6w1GrScrxSpfNE7CfZv3wpiXys="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-call-delegate"": ""6.24.1"",
-        ""babel-helper-get-function-arity"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-shorthand-properties"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-shorthand-properties/-/babel-plugin-transform-es2015-shorthand-properties-6.24.1.tgz"",
-      ""integrity"": ""sha1-JPh11nIch2YbvZmkYi5R8U3jiqA="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-spread"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-spread/-/babel-plugin-transform-es2015-spread-6.22.0.tgz"",
-      ""integrity"": ""sha1-1taKmfia7cRTbIGlQujdnxdG+NE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-sticky-regex"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-sticky-regex/-/babel-plugin-transform-es2015-sticky-regex-6.24.1.tgz"",
-      ""integrity"": ""sha1-AMHNsaynERLN8M9hJsLta0V8zbw="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-regex"": ""6.26.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-template-literals"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-template-literals/-/babel-plugin-transform-es2015-template-literals-6.22.0.tgz"",
-      ""integrity"": ""sha1-qEs0UPfp+PH2g51taH2oS7EjbY0="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-typeof-symbol"": {
-      ""version"": ""6.23.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-typeof-symbol/-/babel-plugin-transform-es2015-typeof-symbol-6.23.0.tgz"",
-      ""integrity"": ""sha1-3sCfHN3/lLUqxz1QXITfWdzOs3I="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-unicode-regex"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-unicode-regex/-/babel-plugin-transform-es2015-unicode-regex-6.24.1.tgz"",
-      ""integrity"": ""sha1-04sS9C6nMj9yk4fxinxa4frrNek="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-regex"": ""6.26.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""regexpu-core"": ""2.0.0""
-      }
-    },
-    ""babel-plugin-transform-regenerator"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-regenerator/-/babel-plugin-transform-regenerator-6.26.0.tgz"",
-      ""integrity"": ""sha1-4HA2lvveJ/Cj78rPi03KL3s6jy8="",
-      ""dev"": true,
-      ""requires"": {
-        ""regenerator-transform"": ""0.10.1""
-      }
-    },
-    ""babel-plugin-transform-strict-mode"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-strict-mode/-/babel-plugin-transform-strict-mode-6.24.1.tgz"",
-      ""integrity"": ""sha1-1fr3qleKZbvlkc9e2uBKDGcCB1g="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-polyfill"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-polyfill/-/babel-polyfill-6.26.0.tgz"",
-      ""integrity"": ""sha1-N5k3q8Z9eJWXCtxiHyhM2WbPIVM="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""core-js"": ""2.6.5"",
-        ""regenerator-runtime"": ""0.10.5""
-      },
-      ""dependencies"": {
-        ""regenerator-runtime"": {
-          ""version"": ""0.10.5"",
-          ""resolved"": ""https://registry.npmjs.org/regenerator-runtime/-/regenerator-runtime-0.10.5.tgz"",
-          ""integrity"": ""sha1-M2w+/BIgrc7dosn6tntaeVWjNlg="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-preset-es2015"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-preset-es2015/-/babel-preset-es2015-6.24.1.tgz"",
-      ""integrity"": ""sha1-1EBQ1rwsn+6nAqrzjXJ6AhBTiTk="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-plugin-check-es2015-constants"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-arrow-functions"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-block-scoped-functions"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-block-scoping"": ""6.26.0"",
-        ""babel-plugin-transform-es2015-classes"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-computed-properties"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-destructuring"": ""6.23.0"",
-        ""babel-plugin-transform-es2015-duplicate-keys"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-for-of"": ""6.23.0"",
-        ""babel-plugin-transform-es2015-function-name"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-literals"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-modules-amd"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-modules-commonjs"": ""6.26.2"",
-        ""babel-plugin-transform-es2015-modules-systemjs"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-modules-umd"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-object-super"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-parameters"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-shorthand-properties"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-spread"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-sticky-regex"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-template-literals"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-typeof-symbol"": ""6.23.0"",
-        ""babel-plugin-transform-es2015-unicode-regex"": ""6.24.1"",
-        ""babel-plugin-transform-regenerator"": ""6.26.0""
-      }
-    },
-    ""babel-register"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-register/-/babel-register-6.26.0.tgz"",
-      ""integrity"": ""sha1-btAhFz4vy0htestFxgCahW9kcHE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-core"": ""6.26.3"",
-        ""babel-runtime"": ""6.26.0"",
-        ""core-js"": ""2.6.5"",
-        ""home-or-tmp"": ""2.0.0"",
-        ""lodash"": ""4.17.11"",
-        ""mkdirp"": ""0.5.1"",
-        ""source-map-support"": ""0.4.18""
-      },
-      ""dependencies"": {
-        ""source-map"": {
-          ""version"": ""0.5.7"",
-          ""resolved"": ""https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz"",
-          ""integrity"": ""sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w="",
-          ""dev"": true
+        ""@types/fs-extra"": {
+            ""version"": ""5.0.1"",
+            ""resolved"": ""https://registry.npmjs.org/@types/fs-extra/-/fs-extra-5.0.1.tgz"",
+            ""integrity"": ""sha512-h3wnflb+jMTipvbbZnClgA2BexrT4w0GcfoCz5qyxd0IRsbqhLSyesM6mqZTAnhbVmhyTm5tuxfRu9R+8l+lGw=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@types/node"": ""*""
+            }
         },
-        ""source-map-support"": {
-          ""version"": ""0.4.18"",
-          ""resolved"": ""https://registry.npmjs.org/source-map-support/-/source-map-support-0.4.18.tgz"",
-          ""integrity"": ""sha512-try0/JqxPLF9nOjvSta7tVondkP5dwgyLDjVoyMDlmjugT2lRZ1OfsrYTkCd2hkDnJTKRbO/Rl3orm8vlsUzbA=="",
-          ""dev"": true,
-          ""requires"": {
-            ""source-map"": ""0.5.7""
-          }
-        }
-      }
-    },
-    ""babel-runtime"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-runtime/-/babel-runtime-6.26.0.tgz"",
-      ""integrity"": ""sha1-llxwWGaOgrVde/4E/yM3vItWR/4="",
-      ""dev"": true,
-      ""requires"": {
-        ""core-js"": ""2.6.5"",
-        ""regenerator-runtime"": ""0.11.1""
-      }
-    },
-    ""babel-template"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-template/-/babel-template-6.26.0.tgz"",
-      ""integrity"": ""sha1-3gPi0WOWsGn0bdn/+FIfsaDjXgI="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""babylon"": ""6.18.0"",
-        ""lodash"": ""4.17.11""
-      },
-      ""dependencies"": {
-        ""babylon"": {
-          ""version"": ""6.18.0"",
-          ""resolved"": ""https://registry.npmjs.org/babylon/-/babylon-6.18.0.tgz"",
-          ""integrity"": ""sha512-q/UEjfGJ2Cm3oKV71DJz9d25TPnq5rhBVL2Q4fA5wcC3jcrdn7+SssEybFIxwAvvP+YCsCYNKughoF33GxgycQ=="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-traverse"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-traverse/-/babel-traverse-6.26.0.tgz"",
-      ""integrity"": ""sha1-RqnL1+3MYsjlwGTi0tjQ9ANXZu4="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-code-frame"": ""6.26.0"",
-        ""babel-messages"": ""6.23.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""babylon"": ""6.18.0"",
-        ""debug"": ""2.6.9"",
-        ""globals"": ""9.18.0"",
-        ""invariant"": ""2.2.4"",
-        ""lodash"": ""4.17.11""
-      },
-      ""dependencies"": {
-        ""babylon"": {
-          ""version"": ""6.18.0"",
-          ""resolved"": ""https://registry.npmjs.org/babylon/-/babylon-6.18.0.tgz"",
-          ""integrity"": ""sha512-q/UEjfGJ2Cm3oKV71DJz9d25TPnq5rhBVL2Q4fA5wcC3jcrdn7+SssEybFIxwAvvP+YCsCYNKughoF33GxgycQ=="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-types"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-types/-/babel-types-6.26.0.tgz"",
-      ""integrity"": ""sha1-o7Bz+Uq0nrb6Vc1lInozQ4BjJJc="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""esutils"": ""2.0.2"",
-        ""lodash"": ""4.17.11"",
-        ""to-fast-properties"": ""1.0.3""
-      },
-      ""dependencies"": {
-        ""esutils"": {
-          ""version"": ""2.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/esutils/-/esutils-2.0.2.tgz"",
-          ""integrity"": ""sha1-Cr9PHKpbyx96nYrMbepPqqBLrJs="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babylon"": {
-      ""version"": ""7.0.0-beta.19"",
-      ""resolved"": ""https://registry.npmjs.org/babylon/-/babylon-7.0.0-beta.19.tgz"",
-      ""integrity"": ""sha512-Vg0C9s/REX6/WIXN37UKpv5ZhRi6A4pjHlpkE34+8/a6c2W1Q692n3hmc+SZG5lKRnaExLUbxtJ1SVT+KaCQ/A=="",
-      ""dev"": true
-    },
-    ""balanced-match"": {
-      ""version"": ""1.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.0.tgz"",
-      ""integrity"": ""sha1-ibTRmasr7kneFk6gK4nORi1xt2c="",
-      ""dev"": true
-    },
-    ""base"": {
-      ""version"": ""0.11.2"",
-      ""resolved"": ""https://registry.npmjs.org/base/-/base-0.11.2.tgz"",
-      ""integrity"": ""sha512-5T6P4xPgpp0YDFvSWwEZ4NoE3aM4QBQXDzmVbraCkFj8zHM+mba8SyqB5DbZWyR7mYHo6Y7BdQo3MoA4m0TeQg=="",
-      ""dev"": true,
-      ""requires"": {
-        ""cache-base"": ""1.0.1"",
-        ""class-utils"": ""0.3.6"",
-        ""component-emitter"": ""1.2.1"",
-        ""define-property"": ""1.0.0"",
-        ""isobject"": ""3.0.1"",
-        ""mixin-deep"": ""1.3.1"",
-        ""pascalcase"": ""0.1.1""
-      },
-      ""dependencies"": {
-        ""define-property"": {
-          ""version"": ""1.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/define-property/-/define-property-1.0.0.tgz"",
-          ""integrity"": ""sha1-dp66rz9KY6rTr56NMEybvnm/sOY="",
-          ""dev"": true,
-          ""requires"": {
-            ""is-descriptor"": ""1.0.2""
-          }
+        ""@types/glob"": {
+            ""version"": ""7.1.0"",
+            ""resolved"": ""https://registry.npmjs.org/@types/glob/-/glob-7.1.0.tgz"",
+            ""integrity"": ""sha512-k1M3Y8Ge0bOkG7U5IZObIhkrzZHMpuFpd5RJK9Gh8ekq0EhiezLLqv2ow14ylTKqXTHSqM6AMySbWEHRo+7qdQ=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@types/events"": ""*"",
+                ""@types/minimatch"": ""*"",
+                ""@types/node"": ""*""
+            }
         },
-        ""is-accessor-descriptor"": {
-          ""version"": ""1.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/is-accessor-descriptor/-/is-accessor-descriptor-1.0.0.tgz"",
-          ""integrity"": ""sha512-m5hnHTkcVsPfqx3AKlyttIPb7J+XykHvJP2B9bZDjlhLIoEq4XoK64Vg7boZlVWYK6LUY94dYPEE7Lh0ZkZKcQ=="",
-          ""dev"": true,
-          ""requires"": {
-            ""kind-of"": ""6.0.2""
-          }
+        ""@types/handlebars"": {
+            ""version"": ""4.0.36"",
+            ""resolved"": ""https://registry.npmjs.org/@types/handlebars/-/handlebars-4.0.36.tgz"",
+            ""integrity"": ""sha512-LjNiTX7TY7wtuC6y3QwC93hKMuqYhgV9A1uXBKNvZtVC8ZvyWAjZkJ5BvT0K7RKqORRYRLMrqCxpw5RgS+MdrQ=="",
+            ""dev"": true
         },
-        ""is-data-descriptor"": {
-          ""version"": ""1.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/is-data-descriptor/-/is-data-descriptor-1.0.0.tgz"",
-          ""integrity"": ""sha512-jbRXy1FmtAoCjQkVmIVYwuuqDFUbaOeDjmed1tOGPrsMhtJA4rD9tkgA0F1qJ3gRFRXcHYVkdeaP50Q5rE/jLQ=="",
-          ""dev"": true,
-          ""requires"": {
-            ""kind-of"": ""6.0.2""
-          }
+        ""@types/highlight.js"": {
+            ""version"": ""9.12.2"",
+            ""resolved"": ""https://registry.npmjs.org/@types/highlight.js/-/highlight.js-9.12.2.tgz"",
+            ""integrity"": ""sha512-y5x0XD/WXDaGSyiTaTcKS4FurULJtSiYbGTeQd0m2LYZGBcZZ/7fM6t5H/DzeUF+kv8y6UfmF6yJABQsHcp9VQ=="",
+            ""dev"": true
         },
-        ""is-descriptor"": {
-          ""version"": ""1.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/is-descriptor/-/is-descriptor-1.0.2.tgz"",
-          ""integrity"": ""sha512-2eis5WqQGV7peooDyLmNEPUrps9+SXX5c9pL3xEB+4e9HnGuDa7mB7kHxHw4CbqS9k1T2hOH3miL8n8WtiYVtg=="",
-          ""dev"": true,
-          ""requires"": {
-            ""is-accessor-descriptor"": ""1.0.0"",
-            ""is-data-descriptor"": ""1.0.0"",
-            ""kind-of"": ""6.0.2""
-          }
+        ""@types/lodash"": {
+            ""version"": ""4.14.109"",
+            ""resolved"": ""https://registry.npmjs.org/@types/lodash/-/lodash-4.14.109.tgz"",
+            ""integrity"": ""sha512-hop8SdPUEzbcJm6aTsmuwjIYQo1tqLseKCM+s2bBqTU2gErwI4fE+aqUVOlscPSQbKHKgtMMPoC+h4AIGOJYvw=="",
+            ""dev"": true
+        },
+        ""@types/marked"": {
+            ""version"": ""0.3.0"",
+            ""resolved"": ""https://registry.npmjs.org/@types/marked/-/marked-0.3.0.tgz"",
+            ""integrity"": ""sha512-CSf9YWJdX1DkTNu9zcNtdCcn6hkRtB5ILjbhRId4ZOQqx30fXmdecuaXhugQL6eyrhuXtaHJ7PHI+Vm7k9ZJjg=="",
+            ""dev"": true
+        },
+        ""@types/minimatch"": {
+            ""version"": ""3.0.3"",
+            ""resolved"": ""https://registry.npmjs.org/@types/minimatch/-/minimatch-3.0.3.tgz"",
+            ""integrity"": ""sha512-tHq6qdbT9U1IRSGf14CL0pUlULksvY9OZ+5eEgl1N7t+OA3tGvNpxJCzuKQlsNgCVwbAs670L1vcVQi8j9HjnA=="",
+            ""dev"": true
+        },
+        ""@types/mocha"": {
+            ""version"": ""5.2.3"",
+            ""resolved"": ""https://registry.npmjs.org/@types/mocha/-/mocha-5.2.3.tgz"",
+            ""integrity"": ""sha512-C1wVVr7xhKu6c3Mb27dFzNYR05qvHwgtpN+JOYTGc1pKA7dCEDDYpscn7kul+bCUwa3NoGDbzI1pdznSOa397w=="",
+            ""dev"": true
+        },
+        ""@types/node"": {
+            ""version"": ""8.0.47"",
+            ""resolved"": ""https://registry.npmjs.org/@types/node/-/node-8.0.47.tgz"",
+            ""integrity"": ""sha512-kOwL746WVvt/9Phf6/JgX/bsGQvbrK5iUgzyfwZNcKVFcjAUVSpF9HxevLTld2SG9aywYHOILj38arDdY1r/iQ==""
+        },
+        ""@types/ref"": {
+            ""version"": ""0.0.28"",
+            ""resolved"": ""https://registry.npmjs.org/@types/ref/-/ref-0.0.28.tgz"",
+            ""integrity"": ""sha1-FaYSU+0SWQOLR0md4cmwy8pX9Vw="",
+            ""requires"": {
+                ""@types/node"": ""*""
+            }
         },
-        ""isobject"": {
-          ""version"": ""3.0.1"",
-          ""resolved"": ""https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz"",
-          ""integrity"": ""sha1-TkMekrEalzFjaqH5yNHMvP2reN8="",
-          ""dev"": true
+        ""@types/ref-struct"": {
+            ""version"": ""0.0.28"",
+            ""resolved"": ""https://registry.npmjs.org/@types/ref-struct/-/ref-struct-0.0.28.tgz"",
+            ""integrity"": ""sha1-uECorElUEVFdyuIJAQ1axmFVDoQ="",
+            ""requires"": {
+                ""@types/ref"": ""*""
+            }
         },
-        ""kind-of"": {
-          ""version"": ""6.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/kind-of/-/kind-of-6.0.2.tgz"",
-          ""integrity"": ""sha512-s5kLOcnH0XqDO+FvuaLX8DDjZ18CGFk7VygH40QoKPUQhW4e2rvM0rwUq0t8IQDOwYSeLK01U90OjzBTme2QqA=="",
-          ""dev"": true
-        }
-      }
-    },
-    ""big.js"": {
-      ""version"": ""3.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/big.js/-/big.js-3.2.0.tgz"",
-      ""integrity"": ""sha512-+hN/Zh2D08Mx65pZ/4g5bsmNiZUuChDiQfTUQ7qJr4/kuopCr88xZsAXv6mBoZEsUI4OuGHlX59qE94K2mMW8Q=="",
-      ""dev"": true
-    },
-    ""binary-extensions"": {
-      ""version"": ""1.13.0"",
-      ""resolved"": ""https://registry.npmjs.org/binary-extensions/-/binary-extensions-1.13.0.tgz"",
-      ""integrity"": ""sha512-EgmjVLMn22z7eGGv3kcnHwSnJXmFHjISTY9E/S5lIcTD3Oxw05QTcBLNkJFzcb3cNueUdF/IN4U+d78V0zO8Hw=="",
-      ""dev"": true,
-      ""optional"": true
-    },
-    ""bluebird"": {
-      ""version"": ""3.5.1"",
-      ""resolved"": ""https://registry.npmjs.org/bluebird/-/bluebird-3.5.1.tgz"",
-      ""integrity"": ""sha512-MKiLiV+I1AA596t9w1sQJ8jkiSr5+ZKi0WKrYGUn6d1Fx+Ij4tIj+m2WMQSGczs5jZVxV339chE8iwk6F64wjA=="",
-      ""dev"": true
-    },
-    ""brace-expansion"": {
-      ""version"": ""1.1.11"",
-      ""resolved"": ""https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz"",
-      ""integrity"": ""sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA=="",
-      ""dev"": true,
-      ""requires"": {
-        ""balanced-match"": ""1.0.0"",
-        ""concat-map"": ""0.0.1""
-      }
-    },
-    ""braces"": {
-      ""version"": ""1.8.5"",
-      ""resolved"": ""https://registry.npmjs.org/braces/-/braces-1.8.5.tgz"",
-      ""integrity"": ""sha1-uneWLhLf+WnWt2cR6RS3N4V79qc="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""expand-range"": ""1.8.2"",
-        ""preserve"": ""0.2.0"",
-        ""repeat-element"": ""1.1.3""
-      }
-    },
-    ""browser-stdout"": {
-      ""version"": ""1.3.1"",
-      ""resolved"": ""https://registry.npmjs.org/browser-stdout/-/browser-stdout-1.3.1.tgz"",
-      ""integrity"": ""sha512-qhAVI1+Av2X7qelOfAIYwXONood6XlZE/fXaBSmW/T5SzLAmCgzi+eiWE7fUvbHaeNBQH13UftjpXxsfLkMpgw=="",
-      ""dev"": true
-    },
-    ""buffer-from"": {
-      ""version"": ""1.1.0"",
-      ""resolved"": ""https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.0.tgz"",
-      ""integrity"": ""sha512-c5mRlguI/Pe2dSZmpER62rSCu0ryKmWddzRYsuXc50U2/g8jMOulc31VZMa4mYx31U5xsmSOpDCgH88Vl9cDGQ=="",
-      ""dev"": true
-    },
-    ""builtin-modules"": {
-      ""version"": ""1.1.1"",
-      ""resolved"": ""https://registry.npmjs.org/builtin-modules/-/builtin-modules-1.1.1.tgz"",
-      ""integrity"": ""sha1-Jw8HbFpywC9bZaR9+Uxf46J4iS8="",
-      ""dev"": true
-    },
-    ""cache-base"": {
-      ""version"": ""1.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/cache-base/-/cache-base-1.0.1.tgz"",
-      ""integrity"": ""sha512-AKcdTnFSWATd5/GCPRxr2ChwIJ85CeyrEyjRHlKxQ56d4XJMGym0uAiKn0xbLOGOl3+yRpOTi484dVCEc5AUzQ=="",
-      ""dev"": true,
-      ""requires"": {
-        ""collection-visit"": ""1.0.0"",
-        ""component-emitter"": ""1.2.1"",
-        ""get-value"": ""2.0.6"",
-        ""has-value"": ""1.0.0"",
-        ""isobject"": ""3.0.1"",
-        ""set-value"": ""2.0.0"",
-        ""to-object-path"": ""0.3.0"",
-        ""union-value"": ""1.0.0"",
-        ""unset-value"": ""1.0.0""
-      },
-      ""dependencies"": {
-        ""isobject"": {
-          ""version"": ""3.0.1"",
-          ""resolved"": ""https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz"",
-          ""integrity"": ""sha1-TkMekrEalzFjaqH5yNHMvP2reN8="",
-          ""dev"": true
-        }
-      }
-    },
-    ""catharsis"": {
-      ""version"": ""0.8.9"",
-      ""resolved"": ""https://registry.npmjs.org/catharsis/-/catharsis-0.8.9.tgz"",
-      ""integrity"": ""sha1-mMyJDKZS3S7w5ws3klMQ/56Q/Is="",
-      ""dev"": true,
-      ""requires"": {
-        ""underscore-contrib"": ""0.3.0""
-      }
-    },
-    ""chai"": {
-      ""version"": ""4.1.2"",
-      ""resolved"": ""https://registry.npmjs.org/chai/-/chai-4.1.2.tgz"",
-      ""integrity"": ""sha1-D2RYS6ZC8PKs4oBiefTwbKI61zw="",
-      ""dev"": true,
-      ""requires"": {
-        ""assertion-error"": ""1.0.2"",
-        ""check-error"": ""1.0.2"",
-        ""deep-eql"": ""3.0.1"",
-        ""get-func-name"": ""2.0.0"",
-        ""pathval"": ""1.1.0"",
-        ""type-detect"": ""4.0.3""
-      }
-    },
-    ""chalk"": {
-      ""version"": ""1.1.3"",
-      ""resolved"": ""https://registry.npmjs.org/chalk/-/chalk-1.1.3.tgz"",
-      ""integrity"": ""sha1-qBFcVeSnAv5NFQq9OHKCKn4J/Jg="",
-      ""dev"": true,
-      ""requires"": {
-        ""ansi-styles"": ""2.2.1"",
-        ""escape-string-regexp"": ""1.0.5"",
-        ""has-ansi"": ""2.0.0"",
-        ""strip-ansi"": ""3.0.1"",
-        ""supports-color"": ""2.0.0""
-      },
-      ""dependencies"": {
-        ""supports-color"": {
-          ""version"": ""2.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/supports-color/-/supports-color-2.0.0.tgz"",
-          ""integrity"": ""sha1-U10EXOa2Nj+kARcIRimZXp3zJMc="",
-          ""dev"": true
-        }
-      }
-    },
-    ""check-error"": {
-      ""version"": ""1.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/check-error/-/check-error-1.0.2.tgz"",
-      ""integrity"": ""sha1-V00xLt2Iu13YkS6Sht1sCu1KrII="",
-      ""dev"": true
-    },
-    ""chokidar"": {
-      ""version"": ""1.7.0"",
-      ""resolved"": ""https://registry.npmjs.org/chokidar/-/chokidar-1.7.0.tgz"",
-      ""integrity"": ""sha1-eY5ol3gVHIB2tLNg5e3SjNortGg="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""anymatch"": ""1.3.2"",
-        ""async-each"": ""1.0.1"",
-        ""fsevents"": ""1.2.7"",
-        ""glob-parent"": ""2.0.0"",
-        ""inherits"": ""2.0.3"",
-        ""is-binary-path"": ""1.0.1"",
-        ""is-glob"": ""2.0.1"",
-        ""path-is-absolute"": ""1.0.1"",
-        ""readdirp"": ""2.2.1""
-      }
-    },
-    ""class-utils"": {
-      ""version"": ""0.3.6"",
-      ""resolved"": ""https://registry.npmjs.org/class-utils/-/class-utils-0.3.6.tgz"",
-      ""integrity"": ""sha512-qOhPa/Fj7s6TY8H8esGu5QNpMMQxz79h+urzrNYN6mn+9BnxlDGf5QZ+XeCDsxSjPqsSR56XOZOJmpeurnLMeg=="",
-      ""dev"": true,
-      ""requires"": {
-        ""arr-union"": ""3.1.0"",
-        ""define-property"": ""0.2.5"",
-        ""isobject"": ""3.0.1"",
-        ""static-extend"": ""0.1.2""
-      },
-      ""dependencies"": {
-        ""define-property"": {
-          ""version"": ""0.2.5"",
-          ""resolved"": ""https://registry.npmjs.org/define-property/-/define-property-0.2.5.tgz"",
-          ""integrity"": ""sha1-w1se+RjsPJkPmlvFe+BKrOxcgRY="",
-          ""dev"": true,
-          ""requires"": {
-            ""is-descriptor"": ""0.1.6""
-          }
+        ""@types/shelljs"": {
+            ""version"": ""0.7.8"",
+            ""resolved"": ""https://registry.npmjs.org/@types/shelljs/-/shelljs-0.7.8.tgz"",
+            ""integrity"": ""sha512-M2giRw93PxKS7YjU6GZjtdV9HASdB7TWqizBXe4Ju7AqbKlWvTr0gNO92XH56D/gMxqD/jNHLNfC5hA34yGqrQ=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@types/glob"": ""*"",
+                ""@types/node"": ""*""
+            }
         },
-        ""isobject"": {
-          ""version"": ""3.0.1"",
-          ""resolved"": ""https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz"",
-          ""integrity"": ""sha1-TkMekrEalzFjaqH5yNHMvP2reN8="",
-          ""dev"": true
-        }
-      }
-    },
-    ""collection-visit"": {
-      ""version"": ""1.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/collection-visit/-/collection-visit-1.0.0.tgz"",
-      ""integrity"": ""sha1-S8A3PBZLwykbTTaMgpzxqApZ3KA="",
-      ""dev"": true,
-      ""requires"": {
-        ""map-visit"": ""1.0.0"",
-        ""object-visit"": ""1.0.1""
-      }
-    },
-    ""color-convert"": {
-      ""version"": ""1.9.0"",
-      ""resolved"": ""https://registry.npmjs.org/color-convert/-/color-convert-1.9.0.tgz"",
-      ""integrity"": ""sha1-Gsz5fdc5uYO/mU1W/sj5WFNkG3o="",
-      ""dev"": true,
-      ""requires"": {
-        ""color-name"": ""1.1.3""
-      }
-    },
-    ""color-name"": {
-      ""version"": ""1.1.3"",
-      ""resolved"": ""https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz"",
-      ""integrity"": ""sha1-p9BVi9icQveV3UIyj3QIMcpTvCU="",
-      ""dev"": true
-    },
-    ""commander"": {
-      ""version"": ""2.11.0"",
-      ""resolved"": ""https://registry.npmjs.org/commander/-/commander-2.11.0.tgz"",
-      ""integrity"": ""sha512-b0553uYA5YAEGgyYIGYROzKQ7X5RAqedkfjiZxwi0kL1g3bOaBNNZfYkzt/CL0umgD5wc9Jec2FbB98CjkMRvQ=="",
-      ""dev"": true
-    },
-    ""component-emitter"": {
-      ""version"": ""1.2.1"",
-      ""resolved"": ""https://registry.npmjs.org/component-emitter/-/component-emitter-1.2.1.tgz"",
-      ""integrity"": ""sha1-E3kY1teCg/ffemt8WmPhQOaUJeY="",
-      ""dev"": true
-    },
-    ""concat-map"": {
-      ""version"": ""0.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz"",
-      ""integrity"": ""sha1-2Klr13/Wjfd5OnMDajug1UBdR3s="",
-      ""dev"": true
-    },
-    ""convert-source-map"": {
-      ""version"": ""1.6.0"",
-      ""resolved"": ""https://registry.npmjs.org/convert-source-map/-/convert-source-map-1.6.0.tgz"",
-      ""integrity"": ""sha512-eFu7XigvxdZ1ETfbgPBohgyQ/Z++C0eEhTor0qRwBw9unw+L0/6V8wkSuGgzdThkiS5lSpdptOQPD8Ak40a+7A=="",
-      ""dev"": true,
-      ""requires"": {
-        ""safe-buffer"": ""5.1.2""
-      }
-    },
-    ""copy-descriptor"": {
-      ""version"": ""0.1.1"",
-      ""resolved"": ""https://registry.npmjs.org/copy-descriptor/-/copy-descriptor-0.1.1.tgz"",
-      ""integrity"": ""sha1-Z29us8OZl8LuGsOpJP1hJHSPV40="",
-      ""dev"": true
-    },
-    ""core-js"": {
-      ""version"": ""2.6.5"",
-      ""resolved"": ""https://registry.npmjs.org/core-js/-/core-js-2.6.5.tgz"",
-      ""integrity"": ""sha512-klh/kDpwX8hryYL14M9w/xei6vrv6sE8gTHDG7/T/+SEovB/G4ejwcfE/CBzO6Edsu+OETZMZ3wcX/EjUkrl5A=="",
-      ""dev"": true
-    },
-    ""core-util-is"": {
-      ""version"": ""1.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.2.tgz"",
-      ""integrity"": ""sha1-tf1UIgqivFq1eqtxQMlAdUUDwac="",
-      ""dev"": true,
-      ""optional"": true
-    },
-    ""debug"": {
-      ""version"": ""2.6.9"",
-      ""resolved"": ""https://registry.npmjs.org/debug/-/debug-2.6.9.tgz"",
-      ""integrity"": ""sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA=="",
-      ""requires"": {
-        ""ms"": ""2.0.0""
-      }
-    },
-    ""decode-uri-component"": {
-      ""version"": ""0.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/decode-uri-component/-/decode-uri-component-0.2.0.tgz"",
-      ""integrity"": ""sha1-6zkTMzRYd1y4TNGh+uBiEGu4dUU="",
-      ""dev"": true
-    },
-    ""deep-eql"": {
-      ""version"": ""3.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/deep-eql/-/deep-eql-3.0.1.tgz"",
-      ""integrity"": ""sha512-+QeIQyN5ZuO+3Uk5DYh6/1eKO0m0YmJFGNmFHGACpf1ClL1nmlV/p4gNgbl2pJGxgXb4faqo6UE+M5ACEMyVcw=="",
-      ""dev"": true,
-      ""requires"": {
-        ""type-detect"": ""4.0.3""
-      }
-    },
-    ""define-property"": {
-      ""version"": ""2.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/define-property/-/define-property-2.0.2.tgz"",
-      ""integrity"": ""sha512-jwK2UV4cnPpbcG7+VRARKTZPUWowwXA8bzH5NP6ud0oeAxyYPuGZUAC7hMugpCdz4BeSZl2Dl9k66CHJ/46ZYQ=="",
-      ""dev"": true,
-      ""requires"": {
-        ""is-descriptor"": ""1.0.2"",
-        ""isobject"": ""3.0.1""
-      },
-      ""dependencies"": {
-        ""is-accessor-descriptor"": {
-          ""version"": ""1.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/is-accessor-descriptor/-/is-accessor-descriptor-1.0.0.tgz"",
-          ""integrity"": ""sha512-m5hnHTkcVsPfqx3AKlyttIPb7J+XykHvJP2B9bZDjlhLIoEq4XoK64Vg7boZlVWYK6LUY94dYPEE7Lh0ZkZKcQ=="",
-          ""dev"": true,
-          ""requires"": {
-            ""kind-of"": ""6.0.2""
-          }
+        ""@types/sinon"": {
+            ""version"": ""5.0.1"",
+            ""resolved"": ""https://registry.npmjs.org/@types/sinon/-/sinon-5.0.1.tgz"",
+            ""integrity"": ""sha512-yxzBCIjE3lp9lYjfBbIK/LRCoXgCLLbIIBIje7eNCcUIIR2CZZtyX5uto2hVoMSMqLrsRrT6mwwUEd0yFgOwpA=="",
+            ""dev"": true
+        },
+        ""@types/weak"": {
+            ""version"": ""1.0.0"",
+            ""resolved"": ""https://registry.npmjs.org/@types/weak/-/weak-1.0.0.tgz"",
+            ""integrity"": ""sha512-6WXZpeAac3vj5+OfQvlqYEtc88oOgvkcxbrnmBw53Da6gA+MGztL+Hns3BpnyUevgz+4DxsJblgAew1A/tkcng=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@types/node"": ""*""
+            }
         },
-        ""is-data-descriptor"": {
-          ""version"": ""1.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/is-data-descriptor/-/is-data-descriptor-1.0.0.tgz"",
-          ""integrity"": ""sha512-jbRXy1FmtAoCjQkVmIVYwuuqDFUbaOeDjmed1tOGPrsMhtJA4rD9tkgA0F1qJ3gRFRXcHYVkdeaP50Q5rE/jLQ=="",
-          ""dev"": true,
-          ""requires"": {
-            ""kind-of"": ""6.0.2""
-          }
+        ""@webassemblyjs/ast"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/ast/-/ast-1.8.5.tgz"",
+            ""integrity"": ""sha512-aJMfngIZ65+t71C3y2nBBg5FFG0Okt9m0XEgWZ7Ywgn1oMAT8cNwx00Uv1cQyHtidq0Xn94R4TAywO+LCQ+ZAQ=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@webassemblyjs/helper-module-context"": ""1.8.5"",
+                ""@webassemblyjs/helper-wasm-bytecode"": ""1.8.5"",
+                ""@webassemblyjs/wast-parser"": ""1.8.5""
+            }
         },
-        ""is-descriptor"": {
-          ""version"": ""1.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/is-descriptor/-/is-descriptor-1.0.2.tgz"",
-          ""integrity"": ""sha512-2eis5WqQGV7peooDyLmNEPUrps9+SXX5c9pL3xEB+4e9HnGuDa7mB7kHxHw4CbqS9k1T2hOH3miL8n8WtiYVtg=="",
-          ""dev"": true,
-          ""requires"": {
-            ""is-accessor-descriptor"": ""1.0.0"",
-            ""is-data-descriptor"": ""1.0.0"",
-            ""kind-of"": ""6.0.2""
-          }
+        ""@webassemblyjs/floating-point-hex-parser"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/floating-point-hex-parser/-/floating-point-hex-parser-1.8.5.tgz"",
+            ""integrity"": ""sha512-9p+79WHru1oqBh9ewP9zW95E3XAo+90oth7S5Re3eQnECGq59ly1Ri5tsIipKGpiStHsUYmY3zMLqtk3gTcOtQ=="",
+            ""dev"": true
+        },
+        ""@webassemblyjs/helper-api-error"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/helper-api-error/-/helper-api-error-1.8.5.tgz"",
+            ""integrity"": ""sha512-Za/tnzsvnqdaSPOUXHyKJ2XI7PDX64kWtURyGiJJZKVEdFOsdKUCPTNEVFZq3zJ2R0G5wc2PZ5gvdTRFgm81zA=="",
+            ""dev"": true
+        },
+        ""@webassemblyjs/helper-buffer"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/helper-buffer/-/helper-buffer-1.8.5.tgz"",
+            ""integrity"": ""sha512-Ri2R8nOS0U6G49Q86goFIPNgjyl6+oE1abW1pS84BuhP1Qcr5JqMwRFT3Ah3ADDDYGEgGs1iyb1DGX+kAi/c/Q=="",
+            ""dev"": true
+        },
+        ""@webassemblyjs/helper-code-frame"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/helper-code-frame/-/helper-code-frame-1.8.5.tgz"",
+            ""integrity"": ""sha512-VQAadSubZIhNpH46IR3yWO4kZZjMxN1opDrzePLdVKAZ+DFjkGD/rf4v1jap744uPVU6yjL/smZbRIIJTOUnKQ=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@webassemblyjs/wast-printer"": ""1.8.5""
+            }
         },
-        ""isobject"": {
-          ""version"": ""3.0.1"",
-          ""resolved"": ""https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz"",
-          ""integrity"": ""sha1-TkMekrEalzFjaqH5yNHMvP2reN8="",
-          ""dev"": true
+        ""@webassemblyjs/helper-fsm"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/helper-fsm/-/helper-fsm-1.8.5.tgz"",
+            ""integrity"": ""sha512-kRuX/saORcg8se/ft6Q2UbRpZwP4y7YrWsLXPbbmtepKr22i8Z4O3V5QE9DbZK908dh5Xya4Un57SDIKwB9eow=="",
+            ""dev"": true
+        },
+        ""@webassemblyjs/helper-module-context"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/helper-module-context/-/helper-module-context-1.8.5.tgz"",
+            ""integrity"": ""sha512-/O1B236mN7UNEU4t9X7Pj38i4VoU8CcMHyy3l2cV/kIF4U5KoHXDVqcDuOs1ltkac90IM4vZdHc52t1x8Yfs3g=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@webassemblyjs/ast"": ""1.8.5"",
+                ""mamacro"": ""^0.0.3""
+            }
         },
-        ""kind-of"": {
-          ""version"": ""6.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/kind-of/-/kind-of-6.0.2.tgz"",
-          ""integrity"": ""sha512-s5kLOcnH0XqDO+FvuaLX8DDjZ18CGFk7VygH40QoKPUQhW4e2rvM0rwUq0t8IQDOwYSeLK01U90OjzBTme2QqA=="",
-          ""dev"": true
-        }
-      }
-    },
-    ""detect-indent"": {
-      ""version"": ""4.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/detect-indent/-/detect-indent-4.0.0.tgz"",
-      ""integrity"": ""sha1-920GQ1LN9Docts5hnE7jqUdd4gg="",
-      ""dev"": true,
-      ""requires"": {
-        ""repeating"": ""2.0.1""
-      }
-    },
-    ""diff"": {
-      ""version"": ""3.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/diff/-/diff-3.2.0.tgz"",
-      ""integrity"": ""sha1-yc45Okt8vQsFinJck98pkCeGj/k="",
-      ""dev"": true
-    },
-    ""doctrine"": {
-      ""version"": ""0.7.2"",
-      ""resolved"": ""https://registry.npmjs.org/doctrine/-/doctrine-0.7.2.tgz"",
-      ""integrity"": ""sha1-fLhgNZujvpDgQLJrcpzkv6ZUxSM="",
-      ""dev"": true,
-      ""requires"": {
-        ""esutils"": ""1.1.6"",
-        ""isarray"": ""0.0.1""
-      }
-    },
-    ""emojis-list"": {
-      ""version"": ""2.1.0"",
-      ""resolved"": ""https://registry.npmjs.org/emojis-list/-/emojis-list-2.1.0.tgz"",
-      ""integrity"": ""sha1-TapNnbAPmBmIDHn6RXrlsJof04k="",
-      ""dev"": true
-    },
-    ""escape-string-regexp"": {
-      ""version"": ""1.0.5"",
-      ""resolved"": ""https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz"",
-      ""integrity"": ""sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ="",
-      ""dev"": true
-    },
-    ""esutils"": {
-      ""version"": ""1.1.6"",
-      ""resolved"": ""https://registry.npmjs.org/esutils/-/esutils-1.1.6.tgz"",
-      ""integrity"": ""sha1-wBzKqa5LiXxtDD4hCuUvPHqEQ3U="",
-      ""dev"": true
-    },
-    ""expand-brackets"": {
-      ""version"": ""0.1.5"",
-      ""resolved"": ""https://registry.npmjs.org/expand-brackets/-/expand-brackets-0.1.5.tgz"",
-      ""integrity"": ""sha1-3wcoTjQqgHzXM6xa9yQR5YHRF3s="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""is-posix-bracket"": ""0.1.1""
-      }
-    },
-    ""expand-range"": {
-      ""version"": ""1.8.2"",
-      ""resolved"": ""https://registry.npmjs.org/expand-range/-/expand-range-1.8.2.tgz"",
-      ""integrity"": ""sha1-opnv/TNf4nIeuujiV+x5ZE/IUzc="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""fill-range"": ""2.2.4""
-      }
-    },
-    ""extend-shallow"": {
-      ""version"": ""3.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/extend-shallow/-/extend-shallow-3.0.2.tgz"",
-      ""integrity"": ""sha1-Jqcarwc7OfshJxcnRhMcJwQCjbg="",
-      ""dev"": true,
-      ""requires"": {
-        ""assign-symbols"": ""1.0.0"",
-        ""is-extendable"": ""1.0.1""
-      },
-      ""dependencies"": {
-        ""is-extendable"": {
-          ""version"": ""1.0.1"",
-          ""resolved"": ""https://registry.npmjs.org/is-extendable/-/is-extendable-1.0.1.tgz"",
-          ""integrity"": ""sha512-arnXMxT1hhoKo9k1LZdmlNyJdDDfy2v0fXjFlmok4+i8ul/6WlbVge9bhM74OpNPQPMGUToDtz+KXa1PneJxOA=="",
-          ""dev"": true,
-          ""requires"": {
-            ""is-plain-object"": ""2.0.4""
-          }
-        }
-      }
-    },
-    ""extglob"": {
-      ""version"": ""0.3.2"",
-      ""resolved"": ""https://registry.npmjs.org/extglob/-/extglob-0.3.2.tgz"",
-      ""integrity"": ""sha1-Lhj/PS9JqydlzskCPwEdqo2DSaE="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""is-extglob"": ""1.0.0""
-      }
-    },
-    ""ffi"": {
-      ""version"": ""2.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/ffi/-/ffi-2.2.0.tgz"",
-      ""integrity"": ""sha1-vxiwRmain3EiftVoldVDCvRwQvo="",
-      ""requires"": {
-        ""bindings"": ""1.2.1"",
-        ""debug"": ""2.6.9"",
-        ""nan"": ""2.7.0"",
-        ""ref"": ""1.3.5"",
-        ""ref-struct"": ""1.1.0""
-      },
-      ""dependencies"": {
-        ""bindings"": {
-          ""version"": ""1.2.1"",
-          ""resolved"": ""https://registry.npmjs.org/bindings/-/bindings-1.2.1.tgz"",
-          ""integrity"": ""sha1-FK1hE4EtLTfXLme0ystLtyZQXxE=""
+        ""@webassemblyjs/helper-wasm-bytecode"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/helper-wasm-bytecode/-/helper-wasm-bytecode-1.8.5.tgz"",
+            ""integrity"": ""sha512-Cu4YMYG3Ddl72CbmpjU/wbP6SACcOPVbHN1dI4VJNJVgFwaKf1ppeFJrwydOG3NDHxVGuCfPlLZNyEdIYlQ6QQ=="",
+            ""dev"": true
+        },
+        ""@webassemblyjs/helper-wasm-section"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/helper-wasm-section/-/helper-wasm-section-1.8.5.tgz"",
+            ""integrity"": ""sha512-VV083zwR+VTrIWWtgIUpqfvVdK4ff38loRmrdDBgBT8ADXYsEZ5mPQ4Nde90N3UYatHdYoDIFb7oHzMncI02tA=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@webassemblyjs/ast"": ""1.8.5"",
+                ""@webassemblyjs/helper-buffer"": ""1.8.5"",
+                ""@webassemblyjs/helper-wasm-bytecode"": ""1.8.5"",
+                ""@webassemblyjs/wasm-gen"": ""1.8.5""
+            }
         },
-        ""nan"": {
-          ""version"": ""2.7.0"",
-          ""resolved"": ""https://registry.npmjs.org/nan/-/nan-2.7.0.tgz"",
-          ""integrity"": ""sha1-2Vv3IeyHfgjbJ27T/G63j5CDrUY=""
-        }
-      }
-    },
-    ""filename-regex"": {
-      ""version"": ""2.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/filename-regex/-/filename-regex-2.0.1.tgz"",
-      ""integrity"": ""sha1-wcS5vuPglyXdsQa3XB4wH+LxiyY="",
-      ""dev"": true,
-      ""optional"": true
-    },
-    ""fill-range"": {
-      ""version"": ""2.2.4"",
-      ""resolved"": ""https://registry.npmjs.org/fill-range/-/fill-range-2.2.4.tgz"",
-      ""integrity"": ""sha512-cnrcCbj01+j2gTG921VZPnHbjmdAf8oQV/iGeV2kZxGSyfYjjTyY79ErsK1WJWMpw6DaApEX72binqJE+/d+5Q=="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""is-number"": ""2.1.0"",
-        ""isobject"": ""2.1.0"",
-        ""randomatic"": ""3.1.1"",
-        ""repeat-element"": ""1.1.3"",
-        ""repeat-string"": ""1.6.1""
-      }
-    },
-    ""for-in"": {
-      ""version"": ""1.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/for-in/-/for-in-1.0.2.tgz"",
-      ""integrity"": ""sha1-gQaNKVqBQuwKxybG4iAMMPttXoA="",
-      ""dev"": true
-    },
-    ""for-own"": {
-      ""version"": ""0.1.5"",
-      ""resolved"": ""https://registry.npmjs.org/for-own/-/for-own-0.1.5.tgz"",
-      ""integrity"": ""sha1-UmXGgaTylNq78XyVCbZ2OqhFEM4="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""for-in"": ""1.0.2""
-      }
-    },
-    ""formatio"": {
-      ""version"": ""1.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/formatio/-/formatio-1.2.0.tgz"",
-      ""integrity"": ""sha1-87IWfZBoxGmKjVH092CjmlTYGOs="",
-      ""dev"": true,
-      ""requires"": {
-        ""samsam"": ""1.3.0""
-      }
-    }",,2019-03-15 16:43:03,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/265622295,https://github.com/hyperledger/indy-sdk/pull/1528#discussion_r265622295,jovfer
https://github.com/hyperledger/indy-sdk/pull/1528,https://github.com/hyperledger/indy-sdk/pull/1528,"Cannot control the package-lock.json file.  its generated.  why npm chose that version, no idea.  We either accept it or don't.  That's the only choices.",1bbe06bdb41c88cb5b180884c56ece902a233d88,2019-03-14 17:16:01,265677626,"@@ -1,4535 +1,6734 @@
 {
-  ""name"": ""node-vcx-wrapper"",
-  ""version"": ""0.2.2"",
-  ""lockfileVersion"": 1,
-  ""requires"": true,
-  ""dependencies"": {
-    ""@types/chai"": {
-      ""version"": ""4.1.4"",
-      ""resolved"": ""https://registry.npmjs.org/@types/chai/-/chai-4.1.4.tgz"",
-      ""integrity"": ""sha512-h6+VEw2Vr3ORiFCyyJmcho2zALnUq9cvdB/IO8Xs9itrJVCenC7o26A6+m7D0ihTTr65eS259H5/Ghl/VjYs6g=="",
-      ""dev"": true
-    },
-    ""@types/events"": {
-      ""version"": ""1.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/@types/events/-/events-1.2.0.tgz"",
-      ""integrity"": ""sha512-KEIlhXnIutzKwRbQkGWb/I4HFqBuUykAdHgDED6xqwXJfONCjF5VoE0cXEiurh3XauygxzeDzgtXUqvLkxFzzA=="",
-      ""dev"": true
-    },
-    ""@types/ffi"": {
-      ""version"": ""0.0.19"",
-      ""resolved"": ""https://registry.npmjs.org/@types/ffi/-/ffi-0.0.19.tgz"",
-      ""integrity"": ""sha1-vaEt6ZnhpuRTK4RElzGNuuuYT4I="",
-      ""requires"": {
-        ""@types/node"": ""8.0.47"",
-        ""@types/ref"": ""0.0.28"",
-        ""@types/ref-struct"": ""0.0.28""
-      }
-    },
-    ""@types/fs-extra"": {
-      ""version"": ""5.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/@types/fs-extra/-/fs-extra-5.0.1.tgz"",
-      ""integrity"": ""sha512-h3wnflb+jMTipvbbZnClgA2BexrT4w0GcfoCz5qyxd0IRsbqhLSyesM6mqZTAnhbVmhyTm5tuxfRu9R+8l+lGw=="",
-      ""dev"": true,
-      ""requires"": {
-        ""@types/node"": ""8.0.47""
-      }
-    },
-    ""@types/glob"": {
-      ""version"": ""7.1.0"",
-      ""resolved"": ""https://registry.npmjs.org/@types/glob/-/glob-7.1.0.tgz"",
-      ""integrity"": ""sha512-k1M3Y8Ge0bOkG7U5IZObIhkrzZHMpuFpd5RJK9Gh8ekq0EhiezLLqv2ow14ylTKqXTHSqM6AMySbWEHRo+7qdQ=="",
-      ""dev"": true,
-      ""requires"": {
-        ""@types/events"": ""1.2.0"",
-        ""@types/minimatch"": ""3.0.3"",
-        ""@types/node"": ""8.0.47""
-      }
-    },
-    ""@types/handlebars"": {
-      ""version"": ""4.0.36"",
-      ""resolved"": ""https://registry.npmjs.org/@types/handlebars/-/handlebars-4.0.36.tgz"",
-      ""integrity"": ""sha512-LjNiTX7TY7wtuC6y3QwC93hKMuqYhgV9A1uXBKNvZtVC8ZvyWAjZkJ5BvT0K7RKqORRYRLMrqCxpw5RgS+MdrQ=="",
-      ""dev"": true
-    },
-    ""@types/highlight.js"": {
-      ""version"": ""9.12.2"",
-      ""resolved"": ""https://registry.npmjs.org/@types/highlight.js/-/highlight.js-9.12.2.tgz"",
-      ""integrity"": ""sha512-y5x0XD/WXDaGSyiTaTcKS4FurULJtSiYbGTeQd0m2LYZGBcZZ/7fM6t5H/DzeUF+kv8y6UfmF6yJABQsHcp9VQ=="",
-      ""dev"": true
-    },
-    ""@types/lodash"": {
-      ""version"": ""4.14.109"",
-      ""resolved"": ""https://registry.npmjs.org/@types/lodash/-/lodash-4.14.109.tgz"",
-      ""integrity"": ""sha512-hop8SdPUEzbcJm6aTsmuwjIYQo1tqLseKCM+s2bBqTU2gErwI4fE+aqUVOlscPSQbKHKgtMMPoC+h4AIGOJYvw=="",
-      ""dev"": true
-    },
-    ""@types/marked"": {
-      ""version"": ""0.3.0"",
-      ""resolved"": ""https://registry.npmjs.org/@types/marked/-/marked-0.3.0.tgz"",
-      ""integrity"": ""sha512-CSf9YWJdX1DkTNu9zcNtdCcn6hkRtB5ILjbhRId4ZOQqx30fXmdecuaXhugQL6eyrhuXtaHJ7PHI+Vm7k9ZJjg=="",
-      ""dev"": true
-    },
-    ""@types/minimatch"": {
-      ""version"": ""3.0.3"",
-      ""resolved"": ""https://registry.npmjs.org/@types/minimatch/-/minimatch-3.0.3.tgz"",
-      ""integrity"": ""sha512-tHq6qdbT9U1IRSGf14CL0pUlULksvY9OZ+5eEgl1N7t+OA3tGvNpxJCzuKQlsNgCVwbAs670L1vcVQi8j9HjnA=="",
-      ""dev"": true
-    },
-    ""@types/mocha"": {
-      ""version"": ""5.2.3"",
-      ""resolved"": ""https://registry.npmjs.org/@types/mocha/-/mocha-5.2.3.tgz"",
-      ""integrity"": ""sha512-C1wVVr7xhKu6c3Mb27dFzNYR05qvHwgtpN+JOYTGc1pKA7dCEDDYpscn7kul+bCUwa3NoGDbzI1pdznSOa397w=="",
-      ""dev"": true
-    },
-    ""@types/node"": {
-      ""version"": ""8.0.47"",
-      ""resolved"": ""https://registry.npmjs.org/@types/node/-/node-8.0.47.tgz"",
-      ""integrity"": ""sha512-kOwL746WVvt/9Phf6/JgX/bsGQvbrK5iUgzyfwZNcKVFcjAUVSpF9HxevLTld2SG9aywYHOILj38arDdY1r/iQ==""
-    },
-    ""@types/ref"": {
-      ""version"": ""0.0.28"",
-      ""resolved"": ""https://registry.npmjs.org/@types/ref/-/ref-0.0.28.tgz"",
-      ""integrity"": ""sha1-FaYSU+0SWQOLR0md4cmwy8pX9Vw="",
-      ""requires"": {
-        ""@types/node"": ""8.0.47""
-      }
-    },
-    ""@types/ref-struct"": {
-      ""version"": ""0.0.28"",
-      ""resolved"": ""https://registry.npmjs.org/@types/ref-struct/-/ref-struct-0.0.28.tgz"",
-      ""integrity"": ""sha1-uECorElUEVFdyuIJAQ1axmFVDoQ="",
-      ""requires"": {
-        ""@types/ref"": ""0.0.28""
-      }
-    },
-    ""@types/shelljs"": {
-      ""version"": ""0.7.8"",
-      ""resolved"": ""https://registry.npmjs.org/@types/shelljs/-/shelljs-0.7.8.tgz"",
-      ""integrity"": ""sha512-M2giRw93PxKS7YjU6GZjtdV9HASdB7TWqizBXe4Ju7AqbKlWvTr0gNO92XH56D/gMxqD/jNHLNfC5hA34yGqrQ=="",
-      ""dev"": true,
-      ""requires"": {
-        ""@types/glob"": ""7.1.0"",
-        ""@types/node"": ""8.0.47""
-      }
-    },
-    ""@types/sinon"": {
-      ""version"": ""5.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/@types/sinon/-/sinon-5.0.1.tgz"",
-      ""integrity"": ""sha512-yxzBCIjE3lp9lYjfBbIK/LRCoXgCLLbIIBIje7eNCcUIIR2CZZtyX5uto2hVoMSMqLrsRrT6mwwUEd0yFgOwpA=="",
-      ""dev"": true
-    },
-    ""@types/weak"": {
-      ""version"": ""1.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/@types/weak/-/weak-1.0.0.tgz"",
-      ""integrity"": ""sha512-6WXZpeAac3vj5+OfQvlqYEtc88oOgvkcxbrnmBw53Da6gA+MGztL+Hns3BpnyUevgz+4DxsJblgAew1A/tkcng=="",
-      ""dev"": true,
-      ""requires"": {
-        ""@types/node"": ""8.0.47""
-      }
-    },
-    ""ansi-regex"": {
-      ""version"": ""2.1.1"",
-      ""resolved"": ""https://registry.npmjs.org/ansi-regex/-/ansi-regex-2.1.1.tgz"",
-      ""integrity"": ""sha1-w7M6te42DYbg5ijwRorn7yfWVN8="",
-      ""dev"": true
-    },
-    ""ansi-styles"": {
-      ""version"": ""2.2.1"",
-      ""resolved"": ""https://registry.npmjs.org/ansi-styles/-/ansi-styles-2.2.1.tgz"",
-      ""integrity"": ""sha1-tDLdM1i2NM914eRmQ2gkBTPB3b4="",
-      ""dev"": true
-    },
-    ""anymatch"": {
-      ""version"": ""1.3.2"",
-      ""resolved"": ""https://registry.npmjs.org/anymatch/-/anymatch-1.3.2.tgz"",
-      ""integrity"": ""sha512-0XNayC8lTHQ2OI8aljNCN3sSx6hsr/1+rlcDAotXJR7C1oZZHCNsfpbKwMjRA3Uqb5tF1Rae2oloTr4xpq+WjA=="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""micromatch"": ""2.3.11"",
-        ""normalize-path"": ""2.1.1""
-      }
-    },
-    ""app-module-path"": {
-      ""version"": ""2.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/app-module-path/-/app-module-path-2.2.0.tgz"",
-      ""integrity"": ""sha1-ZBqlXft9am8KgUHEucCqULbCTdU="",
-      ""dev"": true
-    },
-    ""arr-diff"": {
-      ""version"": ""2.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/arr-diff/-/arr-diff-2.0.0.tgz"",
-      ""integrity"": ""sha1-jzuCf5Vai9ZpaX5KQlasPOrjVs8="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""arr-flatten"": ""1.1.0""
-      }
-    },
-    ""arr-flatten"": {
-      ""version"": ""1.1.0"",
-      ""resolved"": ""https://registry.npmjs.org/arr-flatten/-/arr-flatten-1.1.0.tgz"",
-      ""integrity"": ""sha512-L3hKV5R/p5o81R7O02IGnwpDmkp6E982XhtbuwSe3O4qOtMMMtodicASA1Cny2U+aCXcNpml+m4dPsvsJ3jatg=="",
-      ""dev"": true
-    },
-    ""arr-union"": {
-      ""version"": ""3.1.0"",
-      ""resolved"": ""https://registry.npmjs.org/arr-union/-/arr-union-3.1.0.tgz"",
-      ""integrity"": ""sha1-45sJrqne+Gao8gbiiK9jkZuuOcQ="",
-      ""dev"": true
-    },
-    ""array-unique"": {
-      ""version"": ""0.2.1"",
-      ""resolved"": ""https://registry.npmjs.org/array-unique/-/array-unique-0.2.1.tgz"",
-      ""integrity"": ""sha1-odl8yvy8JiXMcPrc6zalDFiwGlM="",
-      ""dev"": true,
-      ""optional"": true
-    },
-    ""arrify"": {
-      ""version"": ""1.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/arrify/-/arrify-1.0.1.tgz"",
-      ""integrity"": ""sha1-iYUI2iIm84DfkEcoRWhJwVAaSw0="",
-      ""dev"": true
-    },
-    ""assertion-error"": {
-      ""version"": ""1.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/assertion-error/-/assertion-error-1.0.2.tgz"",
-      ""integrity"": ""sha1-E8pRXYYgbaC6xm6DTdOX2HWBCUw="",
-      ""dev"": true
-    },
-    ""assign-symbols"": {
-      ""version"": ""1.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/assign-symbols/-/assign-symbols-1.0.0.tgz"",
-      ""integrity"": ""sha1-WWZ/QfrdTyDMvCu5a41Pf3jsA2c="",
-      ""dev"": true
-    },
-    ""async"": {
-      ""version"": ""2.6.1"",
-      ""resolved"": ""https://registry.npmjs.org/async/-/async-2.6.1.tgz"",
-      ""integrity"": ""sha512-fNEiL2+AZt6AlAw/29Cr0UDe4sRAHCpEHh54WMz+Bb7QfNcFw4h3loofyJpLeQs4Yx7yuqu/2dLgM5hKOs6HlQ=="",
-      ""dev"": true,
-      ""requires"": {
-        ""lodash"": ""4.17.11""
-      },
-      ""dependencies"": {
-        ""lodash"": {
-          ""version"": ""4.17.11"",
-          ""resolved"": ""https://registry.npmjs.org/lodash/-/lodash-4.17.11.tgz"",
-          ""integrity"": ""sha512-cQKh8igo5QUhZ7lg38DYWAxMvjSAKG0A8wGSVimP07SIUEK2UO+arSRKbRZWtelMtN5V0Hkwh5ryOto/SshYIg=="",
-          ""dev"": true
-        }
-      }
-    },
-    ""async-each"": {
-      ""version"": ""1.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/async-each/-/async-each-1.0.1.tgz"",
-      ""integrity"": ""sha1-GdOGodntxufByF04iu28xW0zYC0="",
-      ""dev"": true,
-      ""optional"": true
-    },
-    ""atob"": {
-      ""version"": ""2.1.2"",
-      ""resolved"": ""https://registry.npmjs.org/atob/-/atob-2.1.2.tgz"",
-      ""integrity"": ""sha512-Wm6ukoaOGJi/73p/cl2GvLjTI5JM1k/O14isD73YML8StrH/7/lRFgmg8nICZgD3bZZvjwCGxtMOD3wWNAu8cg=="",
-      ""dev"": true
-    },
-    ""babel-cli"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-cli/-/babel-cli-6.26.0.tgz"",
-      ""integrity"": ""sha1-UCq1SHTX24itALiHoGODzgPQAvE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-core"": ""6.26.3"",
-        ""babel-polyfill"": ""6.26.0"",
-        ""babel-register"": ""6.26.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""chokidar"": ""1.7.0"",
-        ""commander"": ""2.11.0"",
-        ""convert-source-map"": ""1.6.0"",
-        ""fs-readdir-recursive"": ""1.1.0"",
-        ""glob"": ""7.1.3"",
-        ""lodash"": ""4.17.11"",
-        ""output-file-sync"": ""1.1.2"",
-        ""path-is-absolute"": ""1.0.1"",
-        ""slash"": ""1.0.0"",
-        ""source-map"": ""0.5.7"",
-        ""v8flags"": ""2.1.1""
-      },
-      ""dependencies"": {
-        ""source-map"": {
-          ""version"": ""0.5.7"",
-          ""resolved"": ""https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz"",
-          ""integrity"": ""sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-code-frame"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-code-frame/-/babel-code-frame-6.26.0.tgz"",
-      ""integrity"": ""sha1-Y/1D99weO7fONZR9uP42mj9Yx0s="",
-      ""dev"": true,
-      ""requires"": {
-        ""chalk"": ""1.1.3"",
-        ""esutils"": ""2.0.2"",
-        ""js-tokens"": ""3.0.2""
-      },
-      ""dependencies"": {
-        ""esutils"": {
-          ""version"": ""2.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/esutils/-/esutils-2.0.2.tgz"",
-          ""integrity"": ""sha1-Cr9PHKpbyx96nYrMbepPqqBLrJs="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-core"": {
-      ""version"": ""6.26.3"",
-      ""resolved"": ""https://registry.npmjs.org/babel-core/-/babel-core-6.26.3.tgz"",
-      ""integrity"": ""sha512-6jyFLuDmeidKmUEb3NM+/yawG0M2bDZ9Z1qbZP59cyHLz8kYGKYwpJP0UwUKKUiTRNvxfLesJnTedqczP7cTDA=="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-code-frame"": ""6.26.0"",
-        ""babel-generator"": ""6.26.1"",
-        ""babel-helpers"": ""6.24.1"",
-        ""babel-messages"": ""6.23.0"",
-        ""babel-register"": ""6.26.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""babylon"": ""6.18.0"",
-        ""convert-source-map"": ""1.6.0"",
-        ""debug"": ""2.6.9"",
-        ""json5"": ""0.5.1"",
-        ""lodash"": ""4.17.11"",
-        ""minimatch"": ""3.0.4"",
-        ""path-is-absolute"": ""1.0.1"",
-        ""private"": ""0.1.8"",
-        ""slash"": ""1.0.0"",
-        ""source-map"": ""0.5.7""
-      },
-      ""dependencies"": {
-        ""babylon"": {
-          ""version"": ""6.18.0"",
-          ""resolved"": ""https://registry.npmjs.org/babylon/-/babylon-6.18.0.tgz"",
-          ""integrity"": ""sha512-q/UEjfGJ2Cm3oKV71DJz9d25TPnq5rhBVL2Q4fA5wcC3jcrdn7+SssEybFIxwAvvP+YCsCYNKughoF33GxgycQ=="",
-          ""dev"": true
+    ""name"": ""node-vcx-wrapper"",
+    ""version"": ""0.2.2"",
+    ""lockfileVersion"": 1,
+    ""requires"": true,
+    ""dependencies"": {
+        ""@types/chai"": {
+            ""version"": ""4.1.4"",
+            ""resolved"": ""https://registry.npmjs.org/@types/chai/-/chai-4.1.4.tgz"",
+            ""integrity"": ""sha512-h6+VEw2Vr3ORiFCyyJmcho2zALnUq9cvdB/IO8Xs9itrJVCenC7o26A6+m7D0ihTTr65eS259H5/Ghl/VjYs6g=="",
+            ""dev"": true
+        },
+        ""@types/events"": {
+            ""version"": ""1.2.0"",
+            ""resolved"": ""https://registry.npmjs.org/@types/events/-/events-1.2.0.tgz"",
+            ""integrity"": ""sha512-KEIlhXnIutzKwRbQkGWb/I4HFqBuUykAdHgDED6xqwXJfONCjF5VoE0cXEiurh3XauygxzeDzgtXUqvLkxFzzA=="",
+            ""dev"": true
+        },
+        ""@types/ffi"": {
+            ""version"": ""0.0.19"",
+            ""resolved"": ""https://registry.npmjs.org/@types/ffi/-/ffi-0.0.19.tgz"",
+            ""integrity"": ""sha1-vaEt6ZnhpuRTK4RElzGNuuuYT4I="",
+            ""requires"": {
+                ""@types/node"": ""*"",
+                ""@types/ref"": ""*"",
+                ""@types/ref-struct"": ""*""
+            }
         },
-        ""source-map"": {
-          ""version"": ""0.5.7"",
-          ""resolved"": ""https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz"",
-          ""integrity"": ""sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-generator"": {
-      ""version"": ""6.26.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-generator/-/babel-generator-6.26.1.tgz"",
-      ""integrity"": ""sha512-HyfwY6ApZj7BYTcJURpM5tznulaBvyio7/0d4zFOeMPUmfxkCjHocCuoLa2SAGzBI8AREcH3eP3758F672DppA=="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-messages"": ""6.23.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""detect-indent"": ""4.0.0"",
-        ""jsesc"": ""1.3.0"",
-        ""lodash"": ""4.17.11"",
-        ""source-map"": ""0.5.7"",
-        ""trim-right"": ""1.0.1""
-      },
-      ""dependencies"": {
-        ""source-map"": {
-          ""version"": ""0.5.7"",
-          ""resolved"": ""https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz"",
-          ""integrity"": ""sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-helper-call-delegate"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-call-delegate/-/babel-helper-call-delegate-6.24.1.tgz"",
-      ""integrity"": ""sha1-7Oaqzdx25Bw0YfiL/Fdb0Nqi340="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-hoist-variables"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helper-define-map"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-define-map/-/babel-helper-define-map-6.26.0.tgz"",
-      ""integrity"": ""sha1-pfVtq0GiX5fstJjH66ypgZ+Vvl8="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-function-name"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""lodash"": ""4.17.11""
-      }
-    },
-    ""babel-helper-function-name"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-function-name/-/babel-helper-function-name-6.24.1.tgz"",
-      ""integrity"": ""sha1-00dbjAPtmCQqJbSDUasYOZ01gKk="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-get-function-arity"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helper-get-function-arity"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-get-function-arity/-/babel-helper-get-function-arity-6.24.1.tgz"",
-      ""integrity"": ""sha1-j3eCqpNAfEHTqlCQj4mwMbG2hT0="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helper-hoist-variables"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-hoist-variables/-/babel-helper-hoist-variables-6.24.1.tgz"",
-      ""integrity"": ""sha1-HssnaJydJVE+rbyZFKc/VAi+enY="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helper-optimise-call-expression"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-optimise-call-expression/-/babel-helper-optimise-call-expression-6.24.1.tgz"",
-      ""integrity"": ""sha1-96E0J7qfc/j0+pk8VKl4gtEkQlc="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helper-regex"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-regex/-/babel-helper-regex-6.26.0.tgz"",
-      ""integrity"": ""sha1-MlxZ+QL4LyS3T6zu0DY5VPZJXnI="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""lodash"": ""4.17.11""
-      }
-    },
-    ""babel-helper-replace-supers"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-replace-supers/-/babel-helper-replace-supers-6.24.1.tgz"",
-      ""integrity"": ""sha1-v22/5Dk40XNpohPKiov3S2qQqxo="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-optimise-call-expression"": ""6.24.1"",
-        ""babel-messages"": ""6.23.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helpers"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helpers/-/babel-helpers-6.24.1.tgz"",
-      ""integrity"": ""sha1-NHHenK7DiOXIUOWX5Yom3fN2ArI="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0""
-      }
-    },
-    ""babel-loader"": {
-      ""version"": ""6.2.4"",
-      ""resolved"": ""https://registry.npmjs.org/babel-loader/-/babel-loader-6.2.4.tgz"",
-      ""integrity"": ""sha1-qnCv+N3CI6WVLoOaQ6bDpMi/oek="",
-      ""dev"": true,
-      ""requires"": {
-        ""loader-utils"": ""0.2.17"",
-        ""mkdirp"": ""0.5.1"",
-        ""object-assign"": ""4.1.1""
-      }
-    },
-    ""babel-messages"": {
-      ""version"": ""6.23.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-messages/-/babel-messages-6.23.0.tgz"",
-      ""integrity"": ""sha1-8830cDhYA1sqKVHG7F7fbGLyYw4="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-check-es2015-constants"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-check-es2015-constants/-/babel-plugin-check-es2015-constants-6.22.0.tgz"",
-      ""integrity"": ""sha1-NRV7EBQm/S/9PaP3XH0ekYNbv4o="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-arrow-functions"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-arrow-functions/-/babel-plugin-transform-es2015-arrow-functions-6.22.0.tgz"",
-      ""integrity"": ""sha1-RSaSy3EdX3ncf4XkQM5BufJE0iE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-block-scoped-functions"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-block-scoped-functions/-/babel-plugin-transform-es2015-block-scoped-functions-6.22.0.tgz"",
-      ""integrity"": ""sha1-u8UbSflk1wy42OC5ToICRs46YUE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-block-scoping"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-block-scoping/-/babel-plugin-transform-es2015-block-scoping-6.26.0.tgz"",
-      ""integrity"": ""sha1-1w9SmcEwjQXBL0Y4E7CgnnOxiV8="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""lodash"": ""4.17.11""
-      }
-    },
-    ""babel-plugin-transform-es2015-classes"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-classes/-/babel-plugin-transform-es2015-classes-6.24.1.tgz"",
-      ""integrity"": ""sha1-WkxYpQyclGHlZLSyo7+ryXolhNs="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-define-map"": ""6.26.0"",
-        ""babel-helper-function-name"": ""6.24.1"",
-        ""babel-helper-optimise-call-expression"": ""6.24.1"",
-        ""babel-helper-replace-supers"": ""6.24.1"",
-        ""babel-messages"": ""6.23.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-computed-properties"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-computed-properties/-/babel-plugin-transform-es2015-computed-properties-6.24.1.tgz"",
-      ""integrity"": ""sha1-b+Ko0WiV1WNPTNmZttNICjCBWbM="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-destructuring"": {
-      ""version"": ""6.23.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-destructuring/-/babel-plugin-transform-es2015-destructuring-6.23.0.tgz"",
-      ""integrity"": ""sha1-mXux8auWf2gtKwh2/jWNYOdlxW0="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-duplicate-keys"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-duplicate-keys/-/babel-plugin-transform-es2015-duplicate-keys-6.24.1.tgz"",
-      ""integrity"": ""sha1-c+s9MQypaePvnskcU3QabxV2Qj4="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-for-of"": {
-      ""version"": ""6.23.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-for-of/-/babel-plugin-transform-es2015-for-of-6.23.0.tgz"",
-      ""integrity"": ""sha1-9HyVsrYT3x0+zC/bdXNiPHUkhpE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-function-name"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-function-name/-/babel-plugin-transform-es2015-function-name-6.24.1.tgz"",
-      ""integrity"": ""sha1-g0yJhTvDaxrw86TF26qU/Y6sqos="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-function-name"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-literals"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-literals/-/babel-plugin-transform-es2015-literals-6.22.0.tgz"",
-      ""integrity"": ""sha1-T1SgLWzWbPkVKAAZox0xklN3yi4="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-modules-amd"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-modules-amd/-/babel-plugin-transform-es2015-modules-amd-6.24.1.tgz"",
-      ""integrity"": ""sha1-Oz5UAXI5hC1tGcMBHEvS8AoA0VQ="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-plugin-transform-es2015-modules-commonjs"": ""6.26.2"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-modules-commonjs"": {
-      ""version"": ""6.26.2"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-modules-commonjs/-/babel-plugin-transform-es2015-modules-commonjs-6.26.2.tgz"",
-      ""integrity"": ""sha512-CV9ROOHEdrjcwhIaJNBGMBCodN+1cfkwtM1SbUHmvyy35KGT7fohbpOxkE2uLz1o6odKK2Ck/tz47z+VqQfi9Q=="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-plugin-transform-strict-mode"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-modules-systemjs"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-modules-systemjs/-/babel-plugin-transform-es2015-modules-systemjs-6.24.1.tgz"",
-      ""integrity"": ""sha1-/4mhQrkRmpBhlfXxBuzzBdlAfSM="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-hoist-variables"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-modules-umd"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-modules-umd/-/babel-plugin-transform-es2015-modules-umd-6.24.1.tgz"",
-      ""integrity"": ""sha1-rJl+YoXNGO1hdq22B9YCNErThGg="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-plugin-transform-es2015-modules-amd"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-object-super"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-object-super/-/babel-plugin-transform-es2015-object-super-6.24.1.tgz"",
-      ""integrity"": ""sha1-JM72muIcuDp/hgPa0CH1cusnj40="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-replace-supers"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-parameters"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-parameters/-/babel-plugin-transform-es2015-parameters-6.24.1.tgz"",
-      ""integrity"": ""sha1-V6w1GrScrxSpfNE7CfZv3wpiXys="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-call-delegate"": ""6.24.1"",
-        ""babel-helper-get-function-arity"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-shorthand-properties"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-shorthand-properties/-/babel-plugin-transform-es2015-shorthand-properties-6.24.1.tgz"",
-      ""integrity"": ""sha1-JPh11nIch2YbvZmkYi5R8U3jiqA="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-spread"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-spread/-/babel-plugin-transform-es2015-spread-6.22.0.tgz"",
-      ""integrity"": ""sha1-1taKmfia7cRTbIGlQujdnxdG+NE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-sticky-regex"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-sticky-regex/-/babel-plugin-transform-es2015-sticky-regex-6.24.1.tgz"",
-      ""integrity"": ""sha1-AMHNsaynERLN8M9hJsLta0V8zbw="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-regex"": ""6.26.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-template-literals"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-template-literals/-/babel-plugin-transform-es2015-template-literals-6.22.0.tgz"",
-      ""integrity"": ""sha1-qEs0UPfp+PH2g51taH2oS7EjbY0="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-typeof-symbol"": {
-      ""version"": ""6.23.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-typeof-symbol/-/babel-plugin-transform-es2015-typeof-symbol-6.23.0.tgz"",
-      ""integrity"": ""sha1-3sCfHN3/lLUqxz1QXITfWdzOs3I="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-unicode-regex"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-unicode-regex/-/babel-plugin-transform-es2015-unicode-regex-6.24.1.tgz"",
-      ""integrity"": ""sha1-04sS9C6nMj9yk4fxinxa4frrNek="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-regex"": ""6.26.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""regexpu-core"": ""2.0.0""
-      }
-    },
-    ""babel-plugin-transform-regenerator"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-regenerator/-/babel-plugin-transform-regenerator-6.26.0.tgz"",
-      ""integrity"": ""sha1-4HA2lvveJ/Cj78rPi03KL3s6jy8="",
-      ""dev"": true,
-      ""requires"": {
-        ""regenerator-transform"": ""0.10.1""
-      }
-    },
-    ""babel-plugin-transform-strict-mode"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-strict-mode/-/babel-plugin-transform-strict-mode-6.24.1.tgz"",
-      ""integrity"": ""sha1-1fr3qleKZbvlkc9e2uBKDGcCB1g="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-polyfill"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-polyfill/-/babel-polyfill-6.26.0.tgz"",
-      ""integrity"": ""sha1-N5k3q8Z9eJWXCtxiHyhM2WbPIVM="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""core-js"": ""2.6.5"",
-        ""regenerator-runtime"": ""0.10.5""
-      },
-      ""dependencies"": {
-        ""regenerator-runtime"": {
-          ""version"": ""0.10.5"",
-          ""resolved"": ""https://registry.npmjs.org/regenerator-runtime/-/regenerator-runtime-0.10.5.tgz"",
-          ""integrity"": ""sha1-M2w+/BIgrc7dosn6tntaeVWjNlg="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-preset-es2015"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-preset-es2015/-/babel-preset-es2015-6.24.1.tgz"",
-      ""integrity"": ""sha1-1EBQ1rwsn+6nAqrzjXJ6AhBTiTk="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-plugin-check-es2015-constants"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-arrow-functions"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-block-scoped-functions"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-block-scoping"": ""6.26.0"",
-        ""babel-plugin-transform-es2015-classes"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-computed-properties"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-destructuring"": ""6.23.0"",
-        ""babel-plugin-transform-es2015-duplicate-keys"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-for-of"": ""6.23.0"",
-        ""babel-plugin-transform-es2015-function-name"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-literals"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-modules-amd"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-modules-commonjs"": ""6.26.2"",
-        ""babel-plugin-transform-es2015-modules-systemjs"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-modules-umd"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-object-super"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-parameters"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-shorthand-properties"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-spread"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-sticky-regex"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-template-literals"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-typeof-symbol"": ""6.23.0"",
-        ""babel-plugin-transform-es2015-unicode-regex"": ""6.24.1"",
-        ""babel-plugin-transform-regenerator"": ""6.26.0""
-      }
-    },
-    ""babel-register"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-register/-/babel-register-6.26.0.tgz"",
-      ""integrity"": ""sha1-btAhFz4vy0htestFxgCahW9kcHE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-core"": ""6.26.3"",
-        ""babel-runtime"": ""6.26.0"",
-        ""core-js"": ""2.6.5"",
-        ""home-or-tmp"": ""2.0.0"",
-        ""lodash"": ""4.17.11"",
-        ""mkdirp"": ""0.5.1"",
-        ""source-map-support"": ""0.4.18""
-      },
-      ""dependencies"": {
-        ""source-map"": {
-          ""version"": ""0.5.7"",
-          ""resolved"": ""https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz"",
-          ""integrity"": ""sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w="",
-          ""dev"": true
+        ""@types/fs-extra"": {
+            ""version"": ""5.0.1"",
+            ""resolved"": ""https://registry.npmjs.org/@types/fs-extra/-/fs-extra-5.0.1.tgz"",
+            ""integrity"": ""sha512-h3wnflb+jMTipvbbZnClgA2BexrT4w0GcfoCz5qyxd0IRsbqhLSyesM6mqZTAnhbVmhyTm5tuxfRu9R+8l+lGw=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@types/node"": ""*""
+            }
         },
-        ""source-map-support"": {
-          ""version"": ""0.4.18"",
-          ""resolved"": ""https://registry.npmjs.org/source-map-support/-/source-map-support-0.4.18.tgz"",
-          ""integrity"": ""sha512-try0/JqxPLF9nOjvSta7tVondkP5dwgyLDjVoyMDlmjugT2lRZ1OfsrYTkCd2hkDnJTKRbO/Rl3orm8vlsUzbA=="",
-          ""dev"": true,
-          ""requires"": {
-            ""source-map"": ""0.5.7""
-          }
-        }
-      }
-    },
-    ""babel-runtime"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-runtime/-/babel-runtime-6.26.0.tgz"",
-      ""integrity"": ""sha1-llxwWGaOgrVde/4E/yM3vItWR/4="",
-      ""dev"": true,
-      ""requires"": {
-        ""core-js"": ""2.6.5"",
-        ""regenerator-runtime"": ""0.11.1""
-      }
-    },
-    ""babel-template"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-template/-/babel-template-6.26.0.tgz"",
-      ""integrity"": ""sha1-3gPi0WOWsGn0bdn/+FIfsaDjXgI="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""babylon"": ""6.18.0"",
-        ""lodash"": ""4.17.11""
-      },
-      ""dependencies"": {
-        ""babylon"": {
-          ""version"": ""6.18.0"",
-          ""resolved"": ""https://registry.npmjs.org/babylon/-/babylon-6.18.0.tgz"",
-          ""integrity"": ""sha512-q/UEjfGJ2Cm3oKV71DJz9d25TPnq5rhBVL2Q4fA5wcC3jcrdn7+SssEybFIxwAvvP+YCsCYNKughoF33GxgycQ=="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-traverse"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-traverse/-/babel-traverse-6.26.0.tgz"",
-      ""integrity"": ""sha1-RqnL1+3MYsjlwGTi0tjQ9ANXZu4="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-code-frame"": ""6.26.0"",
-        ""babel-messages"": ""6.23.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""babylon"": ""6.18.0"",
-        ""debug"": ""2.6.9"",
-        ""globals"": ""9.18.0"",
-        ""invariant"": ""2.2.4"",
-        ""lodash"": ""4.17.11""
-      },
-      ""dependencies"": {
-        ""babylon"": {
-          ""version"": ""6.18.0"",
-          ""resolved"": ""https://registry.npmjs.org/babylon/-/babylon-6.18.0.tgz"",
-          ""integrity"": ""sha512-q/UEjfGJ2Cm3oKV71DJz9d25TPnq5rhBVL2Q4fA5wcC3jcrdn7+SssEybFIxwAvvP+YCsCYNKughoF33GxgycQ=="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-types"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-types/-/babel-types-6.26.0.tgz"",
-      ""integrity"": ""sha1-o7Bz+Uq0nrb6Vc1lInozQ4BjJJc="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""esutils"": ""2.0.2"",
-        ""lodash"": ""4.17.11"",
-        ""to-fast-properties"": ""1.0.3""
-      },
-      ""dependencies"": {
-        ""esutils"": {
-          ""version"": ""2.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/esutils/-/esutils-2.0.2.tgz"",
-          ""integrity"": ""sha1-Cr9PHKpbyx96nYrMbepPqqBLrJs="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babylon"": {
-      ""version"": ""7.0.0-beta.19"",
-      ""resolved"": ""https://registry.npmjs.org/babylon/-/babylon-7.0.0-beta.19.tgz"",
-      ""integrity"": ""sha512-Vg0C9s/REX6/WIXN37UKpv5ZhRi6A4pjHlpkE34+8/a6c2W1Q692n3hmc+SZG5lKRnaExLUbxtJ1SVT+KaCQ/A=="",
-      ""dev"": true
-    },
-    ""balanced-match"": {
-      ""version"": ""1.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.0.tgz"",
-      ""integrity"": ""sha1-ibTRmasr7kneFk6gK4nORi1xt2c="",
-      ""dev"": true
-    },
-    ""base"": {
-      ""version"": ""0.11.2"",
-      ""resolved"": ""https://registry.npmjs.org/base/-/base-0.11.2.tgz"",
-      ""integrity"": ""sha512-5T6P4xPgpp0YDFvSWwEZ4NoE3aM4QBQXDzmVbraCkFj8zHM+mba8SyqB5DbZWyR7mYHo6Y7BdQo3MoA4m0TeQg=="",
-      ""dev"": true,
-      ""requires"": {
-        ""cache-base"": ""1.0.1"",
-        ""class-utils"": ""0.3.6"",
-        ""component-emitter"": ""1.2.1"",
-        ""define-property"": ""1.0.0"",
-        ""isobject"": ""3.0.1"",
-        ""mixin-deep"": ""1.3.1"",
-        ""pascalcase"": ""0.1.1""
-      },
-      ""dependencies"": {
-        ""define-property"": {
-          ""version"": ""1.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/define-property/-/define-property-1.0.0.tgz"",
-          ""integrity"": ""sha1-dp66rz9KY6rTr56NMEybvnm/sOY="",
-          ""dev"": true,
-          ""requires"": {
-            ""is-descriptor"": ""1.0.2""
-          }
+        ""@types/glob"": {
+            ""version"": ""7.1.0"",
+            ""resolved"": ""https://registry.npmjs.org/@types/glob/-/glob-7.1.0.tgz"",
+            ""integrity"": ""sha512-k1M3Y8Ge0bOkG7U5IZObIhkrzZHMpuFpd5RJK9Gh8ekq0EhiezLLqv2ow14ylTKqXTHSqM6AMySbWEHRo+7qdQ=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@types/events"": ""*"",
+                ""@types/minimatch"": ""*"",
+                ""@types/node"": ""*""
+            }
         },
-        ""is-accessor-descriptor"": {
-          ""version"": ""1.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/is-accessor-descriptor/-/is-accessor-descriptor-1.0.0.tgz"",
-          ""integrity"": ""sha512-m5hnHTkcVsPfqx3AKlyttIPb7J+XykHvJP2B9bZDjlhLIoEq4XoK64Vg7boZlVWYK6LUY94dYPEE7Lh0ZkZKcQ=="",
-          ""dev"": true,
-          ""requires"": {
-            ""kind-of"": ""6.0.2""
-          }
+        ""@types/handlebars"": {
+            ""version"": ""4.0.36"",
+            ""resolved"": ""https://registry.npmjs.org/@types/handlebars/-/handlebars-4.0.36.tgz"",
+            ""integrity"": ""sha512-LjNiTX7TY7wtuC6y3QwC93hKMuqYhgV9A1uXBKNvZtVC8ZvyWAjZkJ5BvT0K7RKqORRYRLMrqCxpw5RgS+MdrQ=="",
+            ""dev"": true
         },
-        ""is-data-descriptor"": {
-          ""version"": ""1.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/is-data-descriptor/-/is-data-descriptor-1.0.0.tgz"",
-          ""integrity"": ""sha512-jbRXy1FmtAoCjQkVmIVYwuuqDFUbaOeDjmed1tOGPrsMhtJA4rD9tkgA0F1qJ3gRFRXcHYVkdeaP50Q5rE/jLQ=="",
-          ""dev"": true,
-          ""requires"": {
-            ""kind-of"": ""6.0.2""
-          }
+        ""@types/highlight.js"": {
+            ""version"": ""9.12.2"",
+            ""resolved"": ""https://registry.npmjs.org/@types/highlight.js/-/highlight.js-9.12.2.tgz"",
+            ""integrity"": ""sha512-y5x0XD/WXDaGSyiTaTcKS4FurULJtSiYbGTeQd0m2LYZGBcZZ/7fM6t5H/DzeUF+kv8y6UfmF6yJABQsHcp9VQ=="",
+            ""dev"": true
         },
-        ""is-descriptor"": {
-          ""version"": ""1.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/is-descriptor/-/is-descriptor-1.0.2.tgz"",
-          ""integrity"": ""sha512-2eis5WqQGV7peooDyLmNEPUrps9+SXX5c9pL3xEB+4e9HnGuDa7mB7kHxHw4CbqS9k1T2hOH3miL8n8WtiYVtg=="",
-          ""dev"": true,
-          ""requires"": {
-            ""is-accessor-descriptor"": ""1.0.0"",
-            ""is-data-descriptor"": ""1.0.0"",
-            ""kind-of"": ""6.0.2""
-          }
+        ""@types/lodash"": {
+            ""version"": ""4.14.109"",
+            ""resolved"": ""https://registry.npmjs.org/@types/lodash/-/lodash-4.14.109.tgz"",
+            ""integrity"": ""sha512-hop8SdPUEzbcJm6aTsmuwjIYQo1tqLseKCM+s2bBqTU2gErwI4fE+aqUVOlscPSQbKHKgtMMPoC+h4AIGOJYvw=="",
+            ""dev"": true
+        },
+        ""@types/marked"": {
+            ""version"": ""0.3.0"",
+            ""resolved"": ""https://registry.npmjs.org/@types/marked/-/marked-0.3.0.tgz"",
+            ""integrity"": ""sha512-CSf9YWJdX1DkTNu9zcNtdCcn6hkRtB5ILjbhRId4ZOQqx30fXmdecuaXhugQL6eyrhuXtaHJ7PHI+Vm7k9ZJjg=="",
+            ""dev"": true
+        },
+        ""@types/minimatch"": {
+            ""version"": ""3.0.3"",
+            ""resolved"": ""https://registry.npmjs.org/@types/minimatch/-/minimatch-3.0.3.tgz"",
+            ""integrity"": ""sha512-tHq6qdbT9U1IRSGf14CL0pUlULksvY9OZ+5eEgl1N7t+OA3tGvNpxJCzuKQlsNgCVwbAs670L1vcVQi8j9HjnA=="",
+            ""dev"": true
+        },
+        ""@types/mocha"": {
+            ""version"": ""5.2.3"",
+            ""resolved"": ""https://registry.npmjs.org/@types/mocha/-/mocha-5.2.3.tgz"",
+            ""integrity"": ""sha512-C1wVVr7xhKu6c3Mb27dFzNYR05qvHwgtpN+JOYTGc1pKA7dCEDDYpscn7kul+bCUwa3NoGDbzI1pdznSOa397w=="",
+            ""dev"": true
+        },
+        ""@types/node"": {
+            ""version"": ""8.0.47"",
+            ""resolved"": ""https://registry.npmjs.org/@types/node/-/node-8.0.47.tgz"",
+            ""integrity"": ""sha512-kOwL746WVvt/9Phf6/JgX/bsGQvbrK5iUgzyfwZNcKVFcjAUVSpF9HxevLTld2SG9aywYHOILj38arDdY1r/iQ==""
+        },
+        ""@types/ref"": {
+            ""version"": ""0.0.28"",
+            ""resolved"": ""https://registry.npmjs.org/@types/ref/-/ref-0.0.28.tgz"",
+            ""integrity"": ""sha1-FaYSU+0SWQOLR0md4cmwy8pX9Vw="",
+            ""requires"": {
+                ""@types/node"": ""*""
+            }
         },
-        ""isobject"": {
-          ""version"": ""3.0.1"",
-          ""resolved"": ""https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz"",
-          ""integrity"": ""sha1-TkMekrEalzFjaqH5yNHMvP2reN8="",
-          ""dev"": true
+        ""@types/ref-struct"": {
+            ""version"": ""0.0.28"",
+            ""resolved"": ""https://registry.npmjs.org/@types/ref-struct/-/ref-struct-0.0.28.tgz"",
+            ""integrity"": ""sha1-uECorElUEVFdyuIJAQ1axmFVDoQ="",
+            ""requires"": {
+                ""@types/ref"": ""*""
+            }
         },
-        ""kind-of"": {
-          ""version"": ""6.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/kind-of/-/kind-of-6.0.2.tgz"",
-          ""integrity"": ""sha512-s5kLOcnH0XqDO+FvuaLX8DDjZ18CGFk7VygH40QoKPUQhW4e2rvM0rwUq0t8IQDOwYSeLK01U90OjzBTme2QqA=="",
-          ""dev"": true
-        }
-      }
-    },
-    ""big.js"": {
-      ""version"": ""3.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/big.js/-/big.js-3.2.0.tgz"",
-      ""integrity"": ""sha512-+hN/Zh2D08Mx65pZ/4g5bsmNiZUuChDiQfTUQ7qJr4/kuopCr88xZsAXv6mBoZEsUI4OuGHlX59qE94K2mMW8Q=="",
-      ""dev"": true
-    },
-    ""binary-extensions"": {
-      ""version"": ""1.13.0"",
-      ""resolved"": ""https://registry.npmjs.org/binary-extensions/-/binary-extensions-1.13.0.tgz"",
-      ""integrity"": ""sha512-EgmjVLMn22z7eGGv3kcnHwSnJXmFHjISTY9E/S5lIcTD3Oxw05QTcBLNkJFzcb3cNueUdF/IN4U+d78V0zO8Hw=="",
-      ""dev"": true,
-      ""optional"": true
-    },
-    ""bluebird"": {
-      ""version"": ""3.5.1"",
-      ""resolved"": ""https://registry.npmjs.org/bluebird/-/bluebird-3.5.1.tgz"",
-      ""integrity"": ""sha512-MKiLiV+I1AA596t9w1sQJ8jkiSr5+ZKi0WKrYGUn6d1Fx+Ij4tIj+m2WMQSGczs5jZVxV339chE8iwk6F64wjA=="",
-      ""dev"": true
-    },
-    ""brace-expansion"": {
-      ""version"": ""1.1.11"",
-      ""resolved"": ""https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz"",
-      ""integrity"": ""sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA=="",
-      ""dev"": true,
-      ""requires"": {
-        ""balanced-match"": ""1.0.0"",
-        ""concat-map"": ""0.0.1""
-      }
-    },
-    ""braces"": {
-      ""version"": ""1.8.5"",
-      ""resolved"": ""https://registry.npmjs.org/braces/-/braces-1.8.5.tgz"",
-      ""integrity"": ""sha1-uneWLhLf+WnWt2cR6RS3N4V79qc="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""expand-range"": ""1.8.2"",
-        ""preserve"": ""0.2.0"",
-        ""repeat-element"": ""1.1.3""
-      }
-    },
-    ""browser-stdout"": {
-      ""version"": ""1.3.1"",
-      ""resolved"": ""https://registry.npmjs.org/browser-stdout/-/browser-stdout-1.3.1.tgz"",
-      ""integrity"": ""sha512-qhAVI1+Av2X7qelOfAIYwXONood6XlZE/fXaBSmW/T5SzLAmCgzi+eiWE7fUvbHaeNBQH13UftjpXxsfLkMpgw=="",
-      ""dev"": true
-    },
-    ""buffer-from"": {
-      ""version"": ""1.1.0"",
-      ""resolved"": ""https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.0.tgz"",
-      ""integrity"": ""sha512-c5mRlguI/Pe2dSZmpER62rSCu0ryKmWddzRYsuXc50U2/g8jMOulc31VZMa4mYx31U5xsmSOpDCgH88Vl9cDGQ=="",
-      ""dev"": true
-    },
-    ""builtin-modules"": {
-      ""version"": ""1.1.1"",
-      ""resolved"": ""https://registry.npmjs.org/builtin-modules/-/builtin-modules-1.1.1.tgz"",
-      ""integrity"": ""sha1-Jw8HbFpywC9bZaR9+Uxf46J4iS8="",
-      ""dev"": true
-    },
-    ""cache-base"": {
-      ""version"": ""1.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/cache-base/-/cache-base-1.0.1.tgz"",
-      ""integrity"": ""sha512-AKcdTnFSWATd5/GCPRxr2ChwIJ85CeyrEyjRHlKxQ56d4XJMGym0uAiKn0xbLOGOl3+yRpOTi484dVCEc5AUzQ=="",
-      ""dev"": true,
-      ""requires"": {
-        ""collection-visit"": ""1.0.0"",
-        ""component-emitter"": ""1.2.1"",
-        ""get-value"": ""2.0.6"",
-        ""has-value"": ""1.0.0"",
-        ""isobject"": ""3.0.1"",
-        ""set-value"": ""2.0.0"",
-        ""to-object-path"": ""0.3.0"",
-        ""union-value"": ""1.0.0"",
-        ""unset-value"": ""1.0.0""
-      },
-      ""dependencies"": {
-        ""isobject"": {
-          ""version"": ""3.0.1"",
-          ""resolved"": ""https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz"",
-          ""integrity"": ""sha1-TkMekrEalzFjaqH5yNHMvP2reN8="",
-          ""dev"": true
-        }
-      }
-    },
-    ""catharsis"": {
-      ""version"": ""0.8.9"",
-      ""resolved"": ""https://registry.npmjs.org/catharsis/-/catharsis-0.8.9.tgz"",
-      ""integrity"": ""sha1-mMyJDKZS3S7w5ws3klMQ/56Q/Is="",
-      ""dev"": true,
-      ""requires"": {
-        ""underscore-contrib"": ""0.3.0""
-      }
-    },
-    ""chai"": {
-      ""version"": ""4.1.2"",
-      ""resolved"": ""https://registry.npmjs.org/chai/-/chai-4.1.2.tgz"",
-      ""integrity"": ""sha1-D2RYS6ZC8PKs4oBiefTwbKI61zw="",
-      ""dev"": true,
-      ""requires"": {
-        ""assertion-error"": ""1.0.2"",
-        ""check-error"": ""1.0.2"",
-        ""deep-eql"": ""3.0.1"",
-        ""get-func-name"": ""2.0.0"",
-        ""pathval"": ""1.1.0"",
-        ""type-detect"": ""4.0.3""
-      }
-    },
-    ""chalk"": {
-      ""version"": ""1.1.3"",
-      ""resolved"": ""https://registry.npmjs.org/chalk/-/chalk-1.1.3.tgz"",
-      ""integrity"": ""sha1-qBFcVeSnAv5NFQq9OHKCKn4J/Jg="",
-      ""dev"": true,
-      ""requires"": {
-        ""ansi-styles"": ""2.2.1"",
-        ""escape-string-regexp"": ""1.0.5"",
-        ""has-ansi"": ""2.0.0"",
-        ""strip-ansi"": ""3.0.1"",
-        ""supports-color"": ""2.0.0""
-      },
-      ""dependencies"": {
-        ""supports-color"": {
-          ""version"": ""2.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/supports-color/-/supports-color-2.0.0.tgz"",
-          ""integrity"": ""sha1-U10EXOa2Nj+kARcIRimZXp3zJMc="",
-          ""dev"": true
-        }
-      }
-    },
-    ""check-error"": {
-      ""version"": ""1.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/check-error/-/check-error-1.0.2.tgz"",
-      ""integrity"": ""sha1-V00xLt2Iu13YkS6Sht1sCu1KrII="",
-      ""dev"": true
-    },
-    ""chokidar"": {
-      ""version"": ""1.7.0"",
-      ""resolved"": ""https://registry.npmjs.org/chokidar/-/chokidar-1.7.0.tgz"",
-      ""integrity"": ""sha1-eY5ol3gVHIB2tLNg5e3SjNortGg="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""anymatch"": ""1.3.2"",
-        ""async-each"": ""1.0.1"",
-        ""fsevents"": ""1.2.7"",
-        ""glob-parent"": ""2.0.0"",
-        ""inherits"": ""2.0.3"",
-        ""is-binary-path"": ""1.0.1"",
-        ""is-glob"": ""2.0.1"",
-        ""path-is-absolute"": ""1.0.1"",
-        ""readdirp"": ""2.2.1""
-      }
-    },
-    ""class-utils"": {
-      ""version"": ""0.3.6"",
-      ""resolved"": ""https://registry.npmjs.org/class-utils/-/class-utils-0.3.6.tgz"",
-      ""integrity"": ""sha512-qOhPa/Fj7s6TY8H8esGu5QNpMMQxz79h+urzrNYN6mn+9BnxlDGf5QZ+XeCDsxSjPqsSR56XOZOJmpeurnLMeg=="",
-      ""dev"": true,
-      ""requires"": {
-        ""arr-union"": ""3.1.0"",
-        ""define-property"": ""0.2.5"",
-        ""isobject"": ""3.0.1"",
-        ""static-extend"": ""0.1.2""
-      },
-      ""dependencies"": {
-        ""define-property"": {
-          ""version"": ""0.2.5"",
-          ""resolved"": ""https://registry.npmjs.org/define-property/-/define-property-0.2.5.tgz"",
-          ""integrity"": ""sha1-w1se+RjsPJkPmlvFe+BKrOxcgRY="",
-          ""dev"": true,
-          ""requires"": {
-            ""is-descriptor"": ""0.1.6""
-          }
+        ""@types/shelljs"": {
+            ""version"": ""0.7.8"",
+            ""resolved"": ""https://registry.npmjs.org/@types/shelljs/-/shelljs-0.7.8.tgz"",
+            ""integrity"": ""sha512-M2giRw93PxKS7YjU6GZjtdV9HASdB7TWqizBXe4Ju7AqbKlWvTr0gNO92XH56D/gMxqD/jNHLNfC5hA34yGqrQ=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@types/glob"": ""*"",
+                ""@types/node"": ""*""
+            }
         },
-        ""isobject"": {
-          ""version"": ""3.0.1"",
-          ""resolved"": ""https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz"",
-          ""integrity"": ""sha1-TkMekrEalzFjaqH5yNHMvP2reN8="",
-          ""dev"": true
-        }
-      }
-    },
-    ""collection-visit"": {
-      ""version"": ""1.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/collection-visit/-/collection-visit-1.0.0.tgz"",
-      ""integrity"": ""sha1-S8A3PBZLwykbTTaMgpzxqApZ3KA="",
-      ""dev"": true,
-      ""requires"": {
-        ""map-visit"": ""1.0.0"",
-        ""object-visit"": ""1.0.1""
-      }
-    },
-    ""color-convert"": {
-      ""version"": ""1.9.0"",
-      ""resolved"": ""https://registry.npmjs.org/color-convert/-/color-convert-1.9.0.tgz"",
-      ""integrity"": ""sha1-Gsz5fdc5uYO/mU1W/sj5WFNkG3o="",
-      ""dev"": true,
-      ""requires"": {
-        ""color-name"": ""1.1.3""
-      }
-    },
-    ""color-name"": {
-      ""version"": ""1.1.3"",
-      ""resolved"": ""https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz"",
-      ""integrity"": ""sha1-p9BVi9icQveV3UIyj3QIMcpTvCU="",
-      ""dev"": true
-    },
-    ""commander"": {
-      ""version"": ""2.11.0"",
-      ""resolved"": ""https://registry.npmjs.org/commander/-/commander-2.11.0.tgz"",
-      ""integrity"": ""sha512-b0553uYA5YAEGgyYIGYROzKQ7X5RAqedkfjiZxwi0kL1g3bOaBNNZfYkzt/CL0umgD5wc9Jec2FbB98CjkMRvQ=="",
-      ""dev"": true
-    },
-    ""component-emitter"": {
-      ""version"": ""1.2.1"",
-      ""resolved"": ""https://registry.npmjs.org/component-emitter/-/component-emitter-1.2.1.tgz"",
-      ""integrity"": ""sha1-E3kY1teCg/ffemt8WmPhQOaUJeY="",
-      ""dev"": true
-    },
-    ""concat-map"": {
-      ""version"": ""0.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz"",
-      ""integrity"": ""sha1-2Klr13/Wjfd5OnMDajug1UBdR3s="",
-      ""dev"": true
-    },
-    ""convert-source-map"": {
-      ""version"": ""1.6.0"",
-      ""resolved"": ""https://registry.npmjs.org/convert-source-map/-/convert-source-map-1.6.0.tgz"",
-      ""integrity"": ""sha512-eFu7XigvxdZ1ETfbgPBohgyQ/Z++C0eEhTor0qRwBw9unw+L0/6V8wkSuGgzdThkiS5lSpdptOQPD8Ak40a+7A=="",
-      ""dev"": true,
-      ""requires"": {
-        ""safe-buffer"": ""5.1.2""
-      }
-    },
-    ""copy-descriptor"": {
-      ""version"": ""0.1.1"",
-      ""resolved"": ""https://registry.npmjs.org/copy-descriptor/-/copy-descriptor-0.1.1.tgz"",
-      ""integrity"": ""sha1-Z29us8OZl8LuGsOpJP1hJHSPV40="",
-      ""dev"": true
-    },
-    ""core-js"": {
-      ""version"": ""2.6.5"",
-      ""resolved"": ""https://registry.npmjs.org/core-js/-/core-js-2.6.5.tgz"",
-      ""integrity"": ""sha512-klh/kDpwX8hryYL14M9w/xei6vrv6sE8gTHDG7/T/+SEovB/G4ejwcfE/CBzO6Edsu+OETZMZ3wcX/EjUkrl5A=="",
-      ""dev"": true
-    },
-    ""core-util-is"": {
-      ""version"": ""1.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.2.tgz"",
-      ""integrity"": ""sha1-tf1UIgqivFq1eqtxQMlAdUUDwac="",
-      ""dev"": true,
-      ""optional"": true
-    },
-    ""debug"": {
-      ""version"": ""2.6.9"",
-      ""resolved"": ""https://registry.npmjs.org/debug/-/debug-2.6.9.tgz"",
-      ""integrity"": ""sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA=="",
-      ""requires"": {
-        ""ms"": ""2.0.0""
-      }
-    },
-    ""decode-uri-component"": {
-      ""version"": ""0.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/decode-uri-component/-/decode-uri-component-0.2.0.tgz"",
-      ""integrity"": ""sha1-6zkTMzRYd1y4TNGh+uBiEGu4dUU="",
-      ""dev"": true
-    },
-    ""deep-eql"": {
-      ""version"": ""3.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/deep-eql/-/deep-eql-3.0.1.tgz"",
-      ""integrity"": ""sha512-+QeIQyN5ZuO+3Uk5DYh6/1eKO0m0YmJFGNmFHGACpf1ClL1nmlV/p4gNgbl2pJGxgXb4faqo6UE+M5ACEMyVcw=="",
-      ""dev"": true,
-      ""requires"": {
-        ""type-detect"": ""4.0.3""
-      }
-    },
-    ""define-property"": {
-      ""version"": ""2.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/define-property/-/define-property-2.0.2.tgz"",
-      ""integrity"": ""sha512-jwK2UV4cnPpbcG7+VRARKTZPUWowwXA8bzH5NP6ud0oeAxyYPuGZUAC7hMugpCdz4BeSZl2Dl9k66CHJ/46ZYQ=="",
-      ""dev"": true,
-      ""requires"": {
-        ""is-descriptor"": ""1.0.2"",
-        ""isobject"": ""3.0.1""
-      },
-      ""dependencies"": {
-        ""is-accessor-descriptor"": {
-          ""version"": ""1.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/is-accessor-descriptor/-/is-accessor-descriptor-1.0.0.tgz"",
-          ""integrity"": ""sha512-m5hnHTkcVsPfqx3AKlyttIPb7J+XykHvJP2B9bZDjlhLIoEq4XoK64Vg7boZlVWYK6LUY94dYPEE7Lh0ZkZKcQ=="",
-          ""dev"": true,
-          ""requires"": {
-            ""kind-of"": ""6.0.2""
-          }
+        ""@types/sinon"": {
+            ""version"": ""5.0.1"",
+            ""resolved"": ""https://registry.npmjs.org/@types/sinon/-/sinon-5.0.1.tgz"",
+            ""integrity"": ""sha512-yxzBCIjE3lp9lYjfBbIK/LRCoXgCLLbIIBIje7eNCcUIIR2CZZtyX5uto2hVoMSMqLrsRrT6mwwUEd0yFgOwpA=="",
+            ""dev"": true
+        },
+        ""@types/weak"": {
+            ""version"": ""1.0.0"",
+            ""resolved"": ""https://registry.npmjs.org/@types/weak/-/weak-1.0.0.tgz"",
+            ""integrity"": ""sha512-6WXZpeAac3vj5+OfQvlqYEtc88oOgvkcxbrnmBw53Da6gA+MGztL+Hns3BpnyUevgz+4DxsJblgAew1A/tkcng=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@types/node"": ""*""
+            }
         },
-        ""is-data-descriptor"": {
-          ""version"": ""1.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/is-data-descriptor/-/is-data-descriptor-1.0.0.tgz"",
-          ""integrity"": ""sha512-jbRXy1FmtAoCjQkVmIVYwuuqDFUbaOeDjmed1tOGPrsMhtJA4rD9tkgA0F1qJ3gRFRXcHYVkdeaP50Q5rE/jLQ=="",
-          ""dev"": true,
-          ""requires"": {
-            ""kind-of"": ""6.0.2""
-          }
+        ""@webassemblyjs/ast"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/ast/-/ast-1.8.5.tgz"",
+            ""integrity"": ""sha512-aJMfngIZ65+t71C3y2nBBg5FFG0Okt9m0XEgWZ7Ywgn1oMAT8cNwx00Uv1cQyHtidq0Xn94R4TAywO+LCQ+ZAQ=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@webassemblyjs/helper-module-context"": ""1.8.5"",
+                ""@webassemblyjs/helper-wasm-bytecode"": ""1.8.5"",
+                ""@webassemblyjs/wast-parser"": ""1.8.5""
+            }
         },
-        ""is-descriptor"": {
-          ""version"": ""1.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/is-descriptor/-/is-descriptor-1.0.2.tgz"",
-          ""integrity"": ""sha512-2eis5WqQGV7peooDyLmNEPUrps9+SXX5c9pL3xEB+4e9HnGuDa7mB7kHxHw4CbqS9k1T2hOH3miL8n8WtiYVtg=="",
-          ""dev"": true,
-          ""requires"": {
-            ""is-accessor-descriptor"": ""1.0.0"",
-            ""is-data-descriptor"": ""1.0.0"",
-            ""kind-of"": ""6.0.2""
-          }
+        ""@webassemblyjs/floating-point-hex-parser"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/floating-point-hex-parser/-/floating-point-hex-parser-1.8.5.tgz"",
+            ""integrity"": ""sha512-9p+79WHru1oqBh9ewP9zW95E3XAo+90oth7S5Re3eQnECGq59ly1Ri5tsIipKGpiStHsUYmY3zMLqtk3gTcOtQ=="",
+            ""dev"": true
+        },
+        ""@webassemblyjs/helper-api-error"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/helper-api-error/-/helper-api-error-1.8.5.tgz"",
+            ""integrity"": ""sha512-Za/tnzsvnqdaSPOUXHyKJ2XI7PDX64kWtURyGiJJZKVEdFOsdKUCPTNEVFZq3zJ2R0G5wc2PZ5gvdTRFgm81zA=="",
+            ""dev"": true
+        },
+        ""@webassemblyjs/helper-buffer"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/helper-buffer/-/helper-buffer-1.8.5.tgz"",
+            ""integrity"": ""sha512-Ri2R8nOS0U6G49Q86goFIPNgjyl6+oE1abW1pS84BuhP1Qcr5JqMwRFT3Ah3ADDDYGEgGs1iyb1DGX+kAi/c/Q=="",
+            ""dev"": true
+        },
+        ""@webassemblyjs/helper-code-frame"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/helper-code-frame/-/helper-code-frame-1.8.5.tgz"",
+            ""integrity"": ""sha512-VQAadSubZIhNpH46IR3yWO4kZZjMxN1opDrzePLdVKAZ+DFjkGD/rf4v1jap744uPVU6yjL/smZbRIIJTOUnKQ=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@webassemblyjs/wast-printer"": ""1.8.5""
+            }
         },
-        ""isobject"": {
-          ""version"": ""3.0.1"",
-          ""resolved"": ""https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz"",
-          ""integrity"": ""sha1-TkMekrEalzFjaqH5yNHMvP2reN8="",
-          ""dev"": true
+        ""@webassemblyjs/helper-fsm"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/helper-fsm/-/helper-fsm-1.8.5.tgz"",
+            ""integrity"": ""sha512-kRuX/saORcg8se/ft6Q2UbRpZwP4y7YrWsLXPbbmtepKr22i8Z4O3V5QE9DbZK908dh5Xya4Un57SDIKwB9eow=="",
+            ""dev"": true
+        },
+        ""@webassemblyjs/helper-module-context"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/helper-module-context/-/helper-module-context-1.8.5.tgz"",
+            ""integrity"": ""sha512-/O1B236mN7UNEU4t9X7Pj38i4VoU8CcMHyy3l2cV/kIF4U5KoHXDVqcDuOs1ltkac90IM4vZdHc52t1x8Yfs3g=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@webassemblyjs/ast"": ""1.8.5"",
+                ""mamacro"": ""^0.0.3""
+            }
         },
-        ""kind-of"": {
-          ""version"": ""6.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/kind-of/-/kind-of-6.0.2.tgz"",
-          ""integrity"": ""sha512-s5kLOcnH0XqDO+FvuaLX8DDjZ18CGFk7VygH40QoKPUQhW4e2rvM0rwUq0t8IQDOwYSeLK01U90OjzBTme2QqA=="",
-          ""dev"": true
-        }
-      }
-    },
-    ""detect-indent"": {
-      ""version"": ""4.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/detect-indent/-/detect-indent-4.0.0.tgz"",
-      ""integrity"": ""sha1-920GQ1LN9Docts5hnE7jqUdd4gg="",
-      ""dev"": true,
-      ""requires"": {
-        ""repeating"": ""2.0.1""
-      }
-    },
-    ""diff"": {
-      ""version"": ""3.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/diff/-/diff-3.2.0.tgz"",
-      ""integrity"": ""sha1-yc45Okt8vQsFinJck98pkCeGj/k="",
-      ""dev"": true
-    },
-    ""doctrine"": {
-      ""version"": ""0.7.2"",
-      ""resolved"": ""https://registry.npmjs.org/doctrine/-/doctrine-0.7.2.tgz"",
-      ""integrity"": ""sha1-fLhgNZujvpDgQLJrcpzkv6ZUxSM="",
-      ""dev"": true,
-      ""requires"": {
-        ""esutils"": ""1.1.6"",
-        ""isarray"": ""0.0.1""
-      }
-    },
-    ""emojis-list"": {
-      ""version"": ""2.1.0"",
-      ""resolved"": ""https://registry.npmjs.org/emojis-list/-/emojis-list-2.1.0.tgz"",
-      ""integrity"": ""sha1-TapNnbAPmBmIDHn6RXrlsJof04k="",
-      ""dev"": true
-    },
-    ""escape-string-regexp"": {
-      ""version"": ""1.0.5"",
-      ""resolved"": ""https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz"",
-      ""integrity"": ""sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ="",
-      ""dev"": true
-    },
-    ""esutils"": {
-      ""version"": ""1.1.6"",
-      ""resolved"": ""https://registry.npmjs.org/esutils/-/esutils-1.1.6.tgz"",
-      ""integrity"": ""sha1-wBzKqa5LiXxtDD4hCuUvPHqEQ3U="",
-      ""dev"": true
-    },
-    ""expand-brackets"": {
-      ""version"": ""0.1.5"",
-      ""resolved"": ""https://registry.npmjs.org/expand-brackets/-/expand-brackets-0.1.5.tgz"",
-      ""integrity"": ""sha1-3wcoTjQqgHzXM6xa9yQR5YHRF3s="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""is-posix-bracket"": ""0.1.1""
-      }
-    },
-    ""expand-range"": {
-      ""version"": ""1.8.2"",
-      ""resolved"": ""https://registry.npmjs.org/expand-range/-/expand-range-1.8.2.tgz"",
-      ""integrity"": ""sha1-opnv/TNf4nIeuujiV+x5ZE/IUzc="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""fill-range"": ""2.2.4""
-      }
-    },
-    ""extend-shallow"": {
-      ""version"": ""3.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/extend-shallow/-/extend-shallow-3.0.2.tgz"",
-      ""integrity"": ""sha1-Jqcarwc7OfshJxcnRhMcJwQCjbg="",
-      ""dev"": true,
-      ""requires"": {
-        ""assign-symbols"": ""1.0.0"",
-        ""is-extendable"": ""1.0.1""
-      },
-      ""dependencies"": {
-        ""is-extendable"": {
-          ""version"": ""1.0.1"",
-          ""resolved"": ""https://registry.npmjs.org/is-extendable/-/is-extendable-1.0.1.tgz"",
-          ""integrity"": ""sha512-arnXMxT1hhoKo9k1LZdmlNyJdDDfy2v0fXjFlmok4+i8ul/6WlbVge9bhM74OpNPQPMGUToDtz+KXa1PneJxOA=="",
-          ""dev"": true,
-          ""requires"": {
-            ""is-plain-object"": ""2.0.4""
-          }
-        }
-      }
-    },
-    ""extglob"": {
-      ""version"": ""0.3.2"",
-      ""resolved"": ""https://registry.npmjs.org/extglob/-/extglob-0.3.2.tgz"",
-      ""integrity"": ""sha1-Lhj/PS9JqydlzskCPwEdqo2DSaE="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""is-extglob"": ""1.0.0""
-      }
-    },
-    ""ffi"": {
-      ""version"": ""2.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/ffi/-/ffi-2.2.0.tgz"",
-      ""integrity"": ""sha1-vxiwRmain3EiftVoldVDCvRwQvo="",
-      ""requires"": {
-        ""bindings"": ""1.2.1"",
-        ""debug"": ""2.6.9"",
-        ""nan"": ""2.7.0"",
-        ""ref"": ""1.3.5"",
-        ""ref-struct"": ""1.1.0""
-      },
-      ""dependencies"": {
-        ""bindings"": {
-          ""version"": ""1.2.1"",
-          ""resolved"": ""https://registry.npmjs.org/bindings/-/bindings-1.2.1.tgz"",
-          ""integrity"": ""sha1-FK1hE4EtLTfXLme0ystLtyZQXxE=""
+        ""@webassemblyjs/helper-wasm-bytecode"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/helper-wasm-bytecode/-/helper-wasm-bytecode-1.8.5.tgz"",
+            ""integrity"": ""sha512-Cu4YMYG3Ddl72CbmpjU/wbP6SACcOPVbHN1dI4VJNJVgFwaKf1ppeFJrwydOG3NDHxVGuCfPlLZNyEdIYlQ6QQ=="",
+            ""dev"": true
+        },
+        ""@webassemblyjs/helper-wasm-section"": {
+            ""version"": ""1.8.5"",
+            ""resolved"": ""https://registry.npmjs.org/@webassemblyjs/helper-wasm-section/-/helper-wasm-section-1.8.5.tgz"",
+            ""integrity"": ""sha512-VV083zwR+VTrIWWtgIUpqfvVdK4ff38loRmrdDBgBT8ADXYsEZ5mPQ4Nde90N3UYatHdYoDIFb7oHzMncI02tA=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@webassemblyjs/ast"": ""1.8.5"",
+                ""@webassemblyjs/helper-buffer"": ""1.8.5"",
+                ""@webassemblyjs/helper-wasm-bytecode"": ""1.8.5"",
+                ""@webassemblyjs/wasm-gen"": ""1.8.5""
+            }
         },
-        ""nan"": {
-          ""version"": ""2.7.0"",
-          ""resolved"": ""https://registry.npmjs.org/nan/-/nan-2.7.0.tgz"",
-          ""integrity"": ""sha1-2Vv3IeyHfgjbJ27T/G63j5CDrUY=""
-        }
-      }
-    },
-    ""filename-regex"": {
-      ""version"": ""2.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/filename-regex/-/filename-regex-2.0.1.tgz"",
-      ""integrity"": ""sha1-wcS5vuPglyXdsQa3XB4wH+LxiyY="",
-      ""dev"": true,
-      ""optional"": true
-    },
-    ""fill-range"": {
-      ""version"": ""2.2.4"",
-      ""resolved"": ""https://registry.npmjs.org/fill-range/-/fill-range-2.2.4.tgz"",
-      ""integrity"": ""sha512-cnrcCbj01+j2gTG921VZPnHbjmdAf8oQV/iGeV2kZxGSyfYjjTyY79ErsK1WJWMpw6DaApEX72binqJE+/d+5Q=="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""is-number"": ""2.1.0"",
-        ""isobject"": ""2.1.0"",
-        ""randomatic"": ""3.1.1"",
-        ""repeat-element"": ""1.1.3"",
-        ""repeat-string"": ""1.6.1""
-      }
-    },
-    ""for-in"": {
-      ""version"": ""1.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/for-in/-/for-in-1.0.2.tgz"",
-      ""integrity"": ""sha1-gQaNKVqBQuwKxybG4iAMMPttXoA="",
-      ""dev"": true
-    },
-    ""for-own"": {
-      ""version"": ""0.1.5"",
-      ""resolved"": ""https://registry.npmjs.org/for-own/-/for-own-0.1.5.tgz"",
-      ""integrity"": ""sha1-UmXGgaTylNq78XyVCbZ2OqhFEM4="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""for-in"": ""1.0.2""
-      }
-    },
-    ""formatio"": {
-      ""version"": ""1.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/formatio/-/formatio-1.2.0.tgz"",
-      ""integrity"": ""sha1-87IWfZBoxGmKjVH092CjmlTYGOs="",
-      ""dev"": true,
-      ""requires"": {
-        ""samsam"": ""1.3.0""
-      }
-    }",,2019-03-15 16:43:03,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/265677626,https://github.com/hyperledger/indy-sdk/pull/1528#discussion_r265677626,mattraffel
https://github.com/hyperledger/indy-sdk/pull/1528,https://github.com/hyperledger/indy-sdk/pull/1528,"npm audit in my env has incremented this version, so I hope it will resolve GH warnings",1bbe06bdb41c88cb5b180884c56ece902a233d88,2019-03-15 16:51:13,266064828,"@@ -1,4735 +1,4770 @@
 {
-  ""name"": ""node-vcx-wrapper"",
-  ""version"": ""0.2.2"",
-  ""lockfileVersion"": 1,
-  ""requires"": true,
-  ""dependencies"": {
-    ""@types/chai"": {
-      ""version"": ""4.1.4"",
-      ""resolved"": ""https://registry.npmjs.org/@types/chai/-/chai-4.1.4.tgz"",
-      ""integrity"": ""sha512-h6+VEw2Vr3ORiFCyyJmcho2zALnUq9cvdB/IO8Xs9itrJVCenC7o26A6+m7D0ihTTr65eS259H5/Ghl/VjYs6g=="",
-      ""dev"": true
-    },
-    ""@types/events"": {
-      ""version"": ""1.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/@types/events/-/events-1.2.0.tgz"",
-      ""integrity"": ""sha512-KEIlhXnIutzKwRbQkGWb/I4HFqBuUykAdHgDED6xqwXJfONCjF5VoE0cXEiurh3XauygxzeDzgtXUqvLkxFzzA=="",
-      ""dev"": true
-    },
-    ""@types/ffi"": {
-      ""version"": ""0.0.19"",
-      ""resolved"": ""https://registry.npmjs.org/@types/ffi/-/ffi-0.0.19.tgz"",
-      ""integrity"": ""sha1-vaEt6ZnhpuRTK4RElzGNuuuYT4I="",
-      ""requires"": {
-        ""@types/node"": ""8.0.47"",
-        ""@types/ref"": ""0.0.28"",
-        ""@types/ref-struct"": ""0.0.28""
-      }
-    },
-    ""@types/fs-extra"": {
-      ""version"": ""5.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/@types/fs-extra/-/fs-extra-5.0.1.tgz"",
-      ""integrity"": ""sha512-h3wnflb+jMTipvbbZnClgA2BexrT4w0GcfoCz5qyxd0IRsbqhLSyesM6mqZTAnhbVmhyTm5tuxfRu9R+8l+lGw=="",
-      ""dev"": true,
-      ""requires"": {
-        ""@types/node"": ""8.0.47""
-      }
-    },
-    ""@types/glob"": {
-      ""version"": ""7.1.0"",
-      ""resolved"": ""https://registry.npmjs.org/@types/glob/-/glob-7.1.0.tgz"",
-      ""integrity"": ""sha512-k1M3Y8Ge0bOkG7U5IZObIhkrzZHMpuFpd5RJK9Gh8ekq0EhiezLLqv2ow14ylTKqXTHSqM6AMySbWEHRo+7qdQ=="",
-      ""dev"": true,
-      ""requires"": {
-        ""@types/events"": ""1.2.0"",
-        ""@types/minimatch"": ""3.0.3"",
-        ""@types/node"": ""8.0.47""
-      }
-    },
-    ""@types/handlebars"": {
-      ""version"": ""4.0.36"",
-      ""resolved"": ""https://registry.npmjs.org/@types/handlebars/-/handlebars-4.0.36.tgz"",
-      ""integrity"": ""sha512-LjNiTX7TY7wtuC6y3QwC93hKMuqYhgV9A1uXBKNvZtVC8ZvyWAjZkJ5BvT0K7RKqORRYRLMrqCxpw5RgS+MdrQ=="",
-      ""dev"": true
-    },
-    ""@types/highlight.js"": {
-      ""version"": ""9.12.2"",
-      ""resolved"": ""https://registry.npmjs.org/@types/highlight.js/-/highlight.js-9.12.2.tgz"",
-      ""integrity"": ""sha512-y5x0XD/WXDaGSyiTaTcKS4FurULJtSiYbGTeQd0m2LYZGBcZZ/7fM6t5H/DzeUF+kv8y6UfmF6yJABQsHcp9VQ=="",
-      ""dev"": true
-    },
-    ""@types/lodash"": {
-      ""version"": ""4.14.109"",
-      ""resolved"": ""https://registry.npmjs.org/@types/lodash/-/lodash-4.14.109.tgz"",
-      ""integrity"": ""sha512-hop8SdPUEzbcJm6aTsmuwjIYQo1tqLseKCM+s2bBqTU2gErwI4fE+aqUVOlscPSQbKHKgtMMPoC+h4AIGOJYvw=="",
-      ""dev"": true
-    },
-    ""@types/marked"": {
-      ""version"": ""0.3.0"",
-      ""resolved"": ""https://registry.npmjs.org/@types/marked/-/marked-0.3.0.tgz"",
-      ""integrity"": ""sha512-CSf9YWJdX1DkTNu9zcNtdCcn6hkRtB5ILjbhRId4ZOQqx30fXmdecuaXhugQL6eyrhuXtaHJ7PHI+Vm7k9ZJjg=="",
-      ""dev"": true
-    },
-    ""@types/minimatch"": {
-      ""version"": ""3.0.3"",
-      ""resolved"": ""https://registry.npmjs.org/@types/minimatch/-/minimatch-3.0.3.tgz"",
-      ""integrity"": ""sha512-tHq6qdbT9U1IRSGf14CL0pUlULksvY9OZ+5eEgl1N7t+OA3tGvNpxJCzuKQlsNgCVwbAs670L1vcVQi8j9HjnA=="",
-      ""dev"": true
-    },
-    ""@types/mocha"": {
-      ""version"": ""5.2.3"",
-      ""resolved"": ""https://registry.npmjs.org/@types/mocha/-/mocha-5.2.3.tgz"",
-      ""integrity"": ""sha512-C1wVVr7xhKu6c3Mb27dFzNYR05qvHwgtpN+JOYTGc1pKA7dCEDDYpscn7kul+bCUwa3NoGDbzI1pdznSOa397w=="",
-      ""dev"": true
-    },
-    ""@types/node"": {
-      ""version"": ""8.0.47"",
-      ""resolved"": ""https://registry.npmjs.org/@types/node/-/node-8.0.47.tgz"",
-      ""integrity"": ""sha512-kOwL746WVvt/9Phf6/JgX/bsGQvbrK5iUgzyfwZNcKVFcjAUVSpF9HxevLTld2SG9aywYHOILj38arDdY1r/iQ==""
-    },
-    ""@types/ref"": {
-      ""version"": ""0.0.28"",
-      ""resolved"": ""https://registry.npmjs.org/@types/ref/-/ref-0.0.28.tgz"",
-      ""integrity"": ""sha1-FaYSU+0SWQOLR0md4cmwy8pX9Vw="",
-      ""requires"": {
-        ""@types/node"": ""8.0.47""
-      }
-    },
-    ""@types/ref-struct"": {
-      ""version"": ""0.0.28"",
-      ""resolved"": ""https://registry.npmjs.org/@types/ref-struct/-/ref-struct-0.0.28.tgz"",
-      ""integrity"": ""sha1-uECorElUEVFdyuIJAQ1axmFVDoQ="",
-      ""requires"": {
-        ""@types/ref"": ""0.0.28""
-      }
-    },
-    ""@types/shelljs"": {
-      ""version"": ""0.7.8"",
-      ""resolved"": ""https://registry.npmjs.org/@types/shelljs/-/shelljs-0.7.8.tgz"",
-      ""integrity"": ""sha512-M2giRw93PxKS7YjU6GZjtdV9HASdB7TWqizBXe4Ju7AqbKlWvTr0gNO92XH56D/gMxqD/jNHLNfC5hA34yGqrQ=="",
-      ""dev"": true,
-      ""requires"": {
-        ""@types/glob"": ""7.1.0"",
-        ""@types/node"": ""8.0.47""
-      }
-    },
-    ""@types/sinon"": {
-      ""version"": ""5.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/@types/sinon/-/sinon-5.0.1.tgz"",
-      ""integrity"": ""sha512-yxzBCIjE3lp9lYjfBbIK/LRCoXgCLLbIIBIje7eNCcUIIR2CZZtyX5uto2hVoMSMqLrsRrT6mwwUEd0yFgOwpA=="",
-      ""dev"": true
-    },
-    ""@types/weak"": {
-      ""version"": ""1.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/@types/weak/-/weak-1.0.0.tgz"",
-      ""integrity"": ""sha512-6WXZpeAac3vj5+OfQvlqYEtc88oOgvkcxbrnmBw53Da6gA+MGztL+Hns3BpnyUevgz+4DxsJblgAew1A/tkcng=="",
-      ""dev"": true,
-      ""requires"": {
-        ""@types/node"": ""8.0.47""
-      }
-    },
-    ""ansi-regex"": {
-      ""version"": ""2.1.1"",
-      ""resolved"": ""https://registry.npmjs.org/ansi-regex/-/ansi-regex-2.1.1.tgz"",
-      ""integrity"": ""sha1-w7M6te42DYbg5ijwRorn7yfWVN8="",
-      ""dev"": true
-    },
-    ""ansi-styles"": {
-      ""version"": ""2.2.1"",
-      ""resolved"": ""https://registry.npmjs.org/ansi-styles/-/ansi-styles-2.2.1.tgz"",
-      ""integrity"": ""sha1-tDLdM1i2NM914eRmQ2gkBTPB3b4="",
-      ""dev"": true
-    },
-    ""anymatch"": {
-      ""version"": ""1.3.2"",
-      ""resolved"": ""https://registry.npmjs.org/anymatch/-/anymatch-1.3.2.tgz"",
-      ""integrity"": ""sha512-0XNayC8lTHQ2OI8aljNCN3sSx6hsr/1+rlcDAotXJR7C1oZZHCNsfpbKwMjRA3Uqb5tF1Rae2oloTr4xpq+WjA=="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""micromatch"": ""2.3.11"",
-        ""normalize-path"": ""2.1.1""
-      }
-    },
-    ""app-module-path"": {
-      ""version"": ""2.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/app-module-path/-/app-module-path-2.2.0.tgz"",
-      ""integrity"": ""sha1-ZBqlXft9am8KgUHEucCqULbCTdU="",
-      ""dev"": true
-    },
-    ""arr-diff"": {
-      ""version"": ""2.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/arr-diff/-/arr-diff-2.0.0.tgz"",
-      ""integrity"": ""sha1-jzuCf5Vai9ZpaX5KQlasPOrjVs8="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""arr-flatten"": ""1.1.0""
-      }
-    },
-    ""arr-flatten"": {
-      ""version"": ""1.1.0"",
-      ""resolved"": ""https://registry.npmjs.org/arr-flatten/-/arr-flatten-1.1.0.tgz"",
-      ""integrity"": ""sha512-L3hKV5R/p5o81R7O02IGnwpDmkp6E982XhtbuwSe3O4qOtMMMtodicASA1Cny2U+aCXcNpml+m4dPsvsJ3jatg=="",
-      ""dev"": true
-    },
-    ""arr-union"": {
-      ""version"": ""3.1.0"",
-      ""resolved"": ""https://registry.npmjs.org/arr-union/-/arr-union-3.1.0.tgz"",
-      ""integrity"": ""sha1-45sJrqne+Gao8gbiiK9jkZuuOcQ="",
-      ""dev"": true
-    },
-    ""array-unique"": {
-      ""version"": ""0.2.1"",
-      ""resolved"": ""https://registry.npmjs.org/array-unique/-/array-unique-0.2.1.tgz"",
-      ""integrity"": ""sha1-odl8yvy8JiXMcPrc6zalDFiwGlM="",
-      ""dev"": true,
-      ""optional"": true
-    },
-    ""arrify"": {
-      ""version"": ""1.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/arrify/-/arrify-1.0.1.tgz"",
-      ""integrity"": ""sha1-iYUI2iIm84DfkEcoRWhJwVAaSw0="",
-      ""dev"": true
-    },
-    ""assertion-error"": {
-      ""version"": ""1.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/assertion-error/-/assertion-error-1.0.2.tgz"",
-      ""integrity"": ""sha1-E8pRXYYgbaC6xm6DTdOX2HWBCUw="",
-      ""dev"": true
-    },
-    ""assign-symbols"": {
-      ""version"": ""1.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/assign-symbols/-/assign-symbols-1.0.0.tgz"",
-      ""integrity"": ""sha1-WWZ/QfrdTyDMvCu5a41Pf3jsA2c="",
-      ""dev"": true
-    },
-    ""async"": {
-      ""version"": ""2.6.1"",
-      ""resolved"": ""https://registry.npmjs.org/async/-/async-2.6.1.tgz"",
-      ""integrity"": ""sha512-fNEiL2+AZt6AlAw/29Cr0UDe4sRAHCpEHh54WMz+Bb7QfNcFw4h3loofyJpLeQs4Yx7yuqu/2dLgM5hKOs6HlQ=="",
-      ""dev"": true,
-      ""requires"": {
-        ""lodash"": ""4.17.11""
-      },
-      ""dependencies"": {
-        ""lodash"": {
-          ""version"": ""4.17.11"",
-          ""resolved"": ""https://registry.npmjs.org/lodash/-/lodash-4.17.11.tgz"",
-          ""integrity"": ""sha512-cQKh8igo5QUhZ7lg38DYWAxMvjSAKG0A8wGSVimP07SIUEK2UO+arSRKbRZWtelMtN5V0Hkwh5ryOto/SshYIg=="",
-          ""dev"": true
-        }
-      }
-    },
-    ""async-each"": {
-      ""version"": ""1.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/async-each/-/async-each-1.0.1.tgz"",
-      ""integrity"": ""sha1-GdOGodntxufByF04iu28xW0zYC0="",
-      ""dev"": true,
-      ""optional"": true
-    },
-    ""atob"": {
-      ""version"": ""2.1.2"",
-      ""resolved"": ""https://registry.npmjs.org/atob/-/atob-2.1.2.tgz"",
-      ""integrity"": ""sha512-Wm6ukoaOGJi/73p/cl2GvLjTI5JM1k/O14isD73YML8StrH/7/lRFgmg8nICZgD3bZZvjwCGxtMOD3wWNAu8cg=="",
-      ""dev"": true
-    },
-    ""babel-cli"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-cli/-/babel-cli-6.26.0.tgz"",
-      ""integrity"": ""sha1-UCq1SHTX24itALiHoGODzgPQAvE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-core"": ""6.26.3"",
-        ""babel-polyfill"": ""6.26.0"",
-        ""babel-register"": ""6.26.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""chokidar"": ""1.7.0"",
-        ""commander"": ""2.11.0"",
-        ""convert-source-map"": ""1.6.0"",
-        ""fs-readdir-recursive"": ""1.1.0"",
-        ""glob"": ""7.1.3"",
-        ""lodash"": ""4.17.11"",
-        ""output-file-sync"": ""1.1.2"",
-        ""path-is-absolute"": ""1.0.1"",
-        ""slash"": ""1.0.0"",
-        ""source-map"": ""0.5.7"",
-        ""v8flags"": ""2.1.1""
-      },
-      ""dependencies"": {
-        ""source-map"": {
-          ""version"": ""0.5.7"",
-          ""resolved"": ""https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz"",
-          ""integrity"": ""sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-code-frame"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-code-frame/-/babel-code-frame-6.26.0.tgz"",
-      ""integrity"": ""sha1-Y/1D99weO7fONZR9uP42mj9Yx0s="",
-      ""dev"": true,
-      ""requires"": {
-        ""chalk"": ""1.1.3"",
-        ""esutils"": ""2.0.2"",
-        ""js-tokens"": ""3.0.2""
-      },
-      ""dependencies"": {
-        ""esutils"": {
-          ""version"": ""2.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/esutils/-/esutils-2.0.2.tgz"",
-          ""integrity"": ""sha1-Cr9PHKpbyx96nYrMbepPqqBLrJs="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-core"": {
-      ""version"": ""6.26.3"",
-      ""resolved"": ""https://registry.npmjs.org/babel-core/-/babel-core-6.26.3.tgz"",
-      ""integrity"": ""sha512-6jyFLuDmeidKmUEb3NM+/yawG0M2bDZ9Z1qbZP59cyHLz8kYGKYwpJP0UwUKKUiTRNvxfLesJnTedqczP7cTDA=="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-code-frame"": ""6.26.0"",
-        ""babel-generator"": ""6.26.1"",
-        ""babel-helpers"": ""6.24.1"",
-        ""babel-messages"": ""6.23.0"",
-        ""babel-register"": ""6.26.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""babylon"": ""6.18.0"",
-        ""convert-source-map"": ""1.6.0"",
-        ""debug"": ""2.6.9"",
-        ""json5"": ""0.5.1"",
-        ""lodash"": ""4.17.11"",
-        ""minimatch"": ""3.0.4"",
-        ""path-is-absolute"": ""1.0.1"",
-        ""private"": ""0.1.8"",
-        ""slash"": ""1.0.0"",
-        ""source-map"": ""0.5.7""
-      },
-      ""dependencies"": {
-        ""babylon"": {
-          ""version"": ""6.18.0"",
-          ""resolved"": ""https://registry.npmjs.org/babylon/-/babylon-6.18.0.tgz"",
-          ""integrity"": ""sha512-q/UEjfGJ2Cm3oKV71DJz9d25TPnq5rhBVL2Q4fA5wcC3jcrdn7+SssEybFIxwAvvP+YCsCYNKughoF33GxgycQ=="",
-          ""dev"": true
+    ""name"": ""node-vcx-wrapper"",
+    ""version"": ""0.2.2"",
+    ""lockfileVersion"": 1,
+    ""requires"": true,
+    ""dependencies"": {
+        ""@sinonjs/commons"": {
+            ""version"": ""1.4.0"",
+            ""resolved"": ""https://registry.npmjs.org/@sinonjs/commons/-/commons-1.4.0.tgz"",
+            ""integrity"": ""sha512-9jHK3YF/8HtJ9wCAbG+j8cD0i0+ATS9A7gXFqS36TblLPNy6rEEc+SB0imo91eCboGaBYGV/MT1/br/J+EE7Tw=="",
+            ""dev"": true,
+            ""requires"": {
+                ""type-detect"": ""4.0.8""
+            },
+            ""dependencies"": {
+                ""type-detect"": {
+                    ""version"": ""4.0.8"",
+                    ""resolved"": ""https://registry.npmjs.org/type-detect/-/type-detect-4.0.8.tgz"",
+                    ""integrity"": ""sha512-0fr/mIH1dlO+x7TlcMy+bIDqKPsw/70tVyeHW787goQjhmqaZe10uwLujubK9q9Lg6Fiho1KUKDYz0Z7k7g5/g=="",
+                    ""dev"": true
+                }
+            }
         },
-        ""source-map"": {
-          ""version"": ""0.5.7"",
-          ""resolved"": ""https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz"",
-          ""integrity"": ""sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-generator"": {
-      ""version"": ""6.26.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-generator/-/babel-generator-6.26.1.tgz"",
-      ""integrity"": ""sha512-HyfwY6ApZj7BYTcJURpM5tznulaBvyio7/0d4zFOeMPUmfxkCjHocCuoLa2SAGzBI8AREcH3eP3758F672DppA=="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-messages"": ""6.23.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""detect-indent"": ""4.0.0"",
-        ""jsesc"": ""1.3.0"",
-        ""lodash"": ""4.17.11"",
-        ""source-map"": ""0.5.7"",
-        ""trim-right"": ""1.0.1""
-      },
-      ""dependencies"": {
-        ""source-map"": {
-          ""version"": ""0.5.7"",
-          ""resolved"": ""https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz"",
-          ""integrity"": ""sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-helper-call-delegate"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-call-delegate/-/babel-helper-call-delegate-6.24.1.tgz"",
-      ""integrity"": ""sha1-7Oaqzdx25Bw0YfiL/Fdb0Nqi340="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-hoist-variables"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helper-define-map"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-define-map/-/babel-helper-define-map-6.26.0.tgz"",
-      ""integrity"": ""sha1-pfVtq0GiX5fstJjH66ypgZ+Vvl8="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-function-name"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""lodash"": ""4.17.11""
-      }
-    },
-    ""babel-helper-function-name"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-function-name/-/babel-helper-function-name-6.24.1.tgz"",
-      ""integrity"": ""sha1-00dbjAPtmCQqJbSDUasYOZ01gKk="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-get-function-arity"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helper-get-function-arity"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-get-function-arity/-/babel-helper-get-function-arity-6.24.1.tgz"",
-      ""integrity"": ""sha1-j3eCqpNAfEHTqlCQj4mwMbG2hT0="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helper-hoist-variables"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-hoist-variables/-/babel-helper-hoist-variables-6.24.1.tgz"",
-      ""integrity"": ""sha1-HssnaJydJVE+rbyZFKc/VAi+enY="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helper-optimise-call-expression"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-optimise-call-expression/-/babel-helper-optimise-call-expression-6.24.1.tgz"",
-      ""integrity"": ""sha1-96E0J7qfc/j0+pk8VKl4gtEkQlc="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helper-regex"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-regex/-/babel-helper-regex-6.26.0.tgz"",
-      ""integrity"": ""sha1-MlxZ+QL4LyS3T6zu0DY5VPZJXnI="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""lodash"": ""4.17.11""
-      }
-    },
-    ""babel-helper-replace-supers"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helper-replace-supers/-/babel-helper-replace-supers-6.24.1.tgz"",
-      ""integrity"": ""sha1-v22/5Dk40XNpohPKiov3S2qQqxo="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-optimise-call-expression"": ""6.24.1"",
-        ""babel-messages"": ""6.23.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-helpers"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-helpers/-/babel-helpers-6.24.1.tgz"",
-      ""integrity"": ""sha1-NHHenK7DiOXIUOWX5Yom3fN2ArI="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0""
-      }
-    },
-    ""babel-loader"": {
-      ""version"": ""6.2.4"",
-      ""resolved"": ""https://registry.npmjs.org/babel-loader/-/babel-loader-6.2.4.tgz"",
-      ""integrity"": ""sha1-qnCv+N3CI6WVLoOaQ6bDpMi/oek="",
-      ""dev"": true,
-      ""requires"": {
-        ""loader-utils"": ""0.2.17"",
-        ""mkdirp"": ""0.5.1"",
-        ""object-assign"": ""4.1.1""
-      }
-    },
-    ""babel-messages"": {
-      ""version"": ""6.23.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-messages/-/babel-messages-6.23.0.tgz"",
-      ""integrity"": ""sha1-8830cDhYA1sqKVHG7F7fbGLyYw4="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-check-es2015-constants"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-check-es2015-constants/-/babel-plugin-check-es2015-constants-6.22.0.tgz"",
-      ""integrity"": ""sha1-NRV7EBQm/S/9PaP3XH0ekYNbv4o="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-arrow-functions"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-arrow-functions/-/babel-plugin-transform-es2015-arrow-functions-6.22.0.tgz"",
-      ""integrity"": ""sha1-RSaSy3EdX3ncf4XkQM5BufJE0iE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-block-scoped-functions"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-block-scoped-functions/-/babel-plugin-transform-es2015-block-scoped-functions-6.22.0.tgz"",
-      ""integrity"": ""sha1-u8UbSflk1wy42OC5ToICRs46YUE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-block-scoping"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-block-scoping/-/babel-plugin-transform-es2015-block-scoping-6.26.0.tgz"",
-      ""integrity"": ""sha1-1w9SmcEwjQXBL0Y4E7CgnnOxiV8="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""lodash"": ""4.17.11""
-      }
-    },
-    ""babel-plugin-transform-es2015-classes"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-classes/-/babel-plugin-transform-es2015-classes-6.24.1.tgz"",
-      ""integrity"": ""sha1-WkxYpQyclGHlZLSyo7+ryXolhNs="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-define-map"": ""6.26.0"",
-        ""babel-helper-function-name"": ""6.24.1"",
-        ""babel-helper-optimise-call-expression"": ""6.24.1"",
-        ""babel-helper-replace-supers"": ""6.24.1"",
-        ""babel-messages"": ""6.23.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-computed-properties"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-computed-properties/-/babel-plugin-transform-es2015-computed-properties-6.24.1.tgz"",
-      ""integrity"": ""sha1-b+Ko0WiV1WNPTNmZttNICjCBWbM="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-destructuring"": {
-      ""version"": ""6.23.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-destructuring/-/babel-plugin-transform-es2015-destructuring-6.23.0.tgz"",
-      ""integrity"": ""sha1-mXux8auWf2gtKwh2/jWNYOdlxW0="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-duplicate-keys"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-duplicate-keys/-/babel-plugin-transform-es2015-duplicate-keys-6.24.1.tgz"",
-      ""integrity"": ""sha1-c+s9MQypaePvnskcU3QabxV2Qj4="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-for-of"": {
-      ""version"": ""6.23.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-for-of/-/babel-plugin-transform-es2015-for-of-6.23.0.tgz"",
-      ""integrity"": ""sha1-9HyVsrYT3x0+zC/bdXNiPHUkhpE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-function-name"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-function-name/-/babel-plugin-transform-es2015-function-name-6.24.1.tgz"",
-      ""integrity"": ""sha1-g0yJhTvDaxrw86TF26qU/Y6sqos="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-function-name"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-literals"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-literals/-/babel-plugin-transform-es2015-literals-6.22.0.tgz"",
-      ""integrity"": ""sha1-T1SgLWzWbPkVKAAZox0xklN3yi4="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-modules-amd"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-modules-amd/-/babel-plugin-transform-es2015-modules-amd-6.24.1.tgz"",
-      ""integrity"": ""sha1-Oz5UAXI5hC1tGcMBHEvS8AoA0VQ="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-plugin-transform-es2015-modules-commonjs"": ""6.26.2"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-modules-commonjs"": {
-      ""version"": ""6.26.2"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-modules-commonjs/-/babel-plugin-transform-es2015-modules-commonjs-6.26.2.tgz"",
-      ""integrity"": ""sha512-CV9ROOHEdrjcwhIaJNBGMBCodN+1cfkwtM1SbUHmvyy35KGT7fohbpOxkE2uLz1o6odKK2Ck/tz47z+VqQfi9Q=="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-plugin-transform-strict-mode"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-modules-systemjs"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-modules-systemjs/-/babel-plugin-transform-es2015-modules-systemjs-6.24.1.tgz"",
-      ""integrity"": ""sha1-/4mhQrkRmpBhlfXxBuzzBdlAfSM="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-hoist-variables"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-modules-umd"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-modules-umd/-/babel-plugin-transform-es2015-modules-umd-6.24.1.tgz"",
-      ""integrity"": ""sha1-rJl+YoXNGO1hdq22B9YCNErThGg="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-plugin-transform-es2015-modules-amd"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-object-super"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-object-super/-/babel-plugin-transform-es2015-object-super-6.24.1.tgz"",
-      ""integrity"": ""sha1-JM72muIcuDp/hgPa0CH1cusnj40="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-replace-supers"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-parameters"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-parameters/-/babel-plugin-transform-es2015-parameters-6.24.1.tgz"",
-      ""integrity"": ""sha1-V6w1GrScrxSpfNE7CfZv3wpiXys="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-call-delegate"": ""6.24.1"",
-        ""babel-helper-get-function-arity"": ""6.24.1"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-template"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-shorthand-properties"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-shorthand-properties/-/babel-plugin-transform-es2015-shorthand-properties-6.24.1.tgz"",
-      ""integrity"": ""sha1-JPh11nIch2YbvZmkYi5R8U3jiqA="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-spread"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-spread/-/babel-plugin-transform-es2015-spread-6.22.0.tgz"",
-      ""integrity"": ""sha1-1taKmfia7cRTbIGlQujdnxdG+NE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-sticky-regex"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-sticky-regex/-/babel-plugin-transform-es2015-sticky-regex-6.24.1.tgz"",
-      ""integrity"": ""sha1-AMHNsaynERLN8M9hJsLta0V8zbw="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-regex"": ""6.26.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-template-literals"": {
-      ""version"": ""6.22.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-template-literals/-/babel-plugin-transform-es2015-template-literals-6.22.0.tgz"",
-      ""integrity"": ""sha1-qEs0UPfp+PH2g51taH2oS7EjbY0="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-typeof-symbol"": {
-      ""version"": ""6.23.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-typeof-symbol/-/babel-plugin-transform-es2015-typeof-symbol-6.23.0.tgz"",
-      ""integrity"": ""sha1-3sCfHN3/lLUqxz1QXITfWdzOs3I="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0""
-      }
-    },
-    ""babel-plugin-transform-es2015-unicode-regex"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-es2015-unicode-regex/-/babel-plugin-transform-es2015-unicode-regex-6.24.1.tgz"",
-      ""integrity"": ""sha1-04sS9C6nMj9yk4fxinxa4frrNek="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-helper-regex"": ""6.26.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""regexpu-core"": ""2.0.0""
-      }
-    },
-    ""babel-plugin-transform-regenerator"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-regenerator/-/babel-plugin-transform-regenerator-6.26.0.tgz"",
-      ""integrity"": ""sha1-4HA2lvveJ/Cj78rPi03KL3s6jy8="",
-      ""dev"": true,
-      ""requires"": {
-        ""regenerator-transform"": ""0.10.1""
-      }
-    },
-    ""babel-plugin-transform-strict-mode"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-plugin-transform-strict-mode/-/babel-plugin-transform-strict-mode-6.24.1.tgz"",
-      ""integrity"": ""sha1-1fr3qleKZbvlkc9e2uBKDGcCB1g="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0""
-      }
-    },
-    ""babel-polyfill"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-polyfill/-/babel-polyfill-6.26.0.tgz"",
-      ""integrity"": ""sha1-N5k3q8Z9eJWXCtxiHyhM2WbPIVM="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""core-js"": ""2.6.5"",
-        ""regenerator-runtime"": ""0.10.5""
-      },
-      ""dependencies"": {
-        ""regenerator-runtime"": {
-          ""version"": ""0.10.5"",
-          ""resolved"": ""https://registry.npmjs.org/regenerator-runtime/-/regenerator-runtime-0.10.5.tgz"",
-          ""integrity"": ""sha1-M2w+/BIgrc7dosn6tntaeVWjNlg="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-preset-es2015"": {
-      ""version"": ""6.24.1"",
-      ""resolved"": ""https://registry.npmjs.org/babel-preset-es2015/-/babel-preset-es2015-6.24.1.tgz"",
-      ""integrity"": ""sha1-1EBQ1rwsn+6nAqrzjXJ6AhBTiTk="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-plugin-check-es2015-constants"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-arrow-functions"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-block-scoped-functions"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-block-scoping"": ""6.26.0"",
-        ""babel-plugin-transform-es2015-classes"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-computed-properties"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-destructuring"": ""6.23.0"",
-        ""babel-plugin-transform-es2015-duplicate-keys"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-for-of"": ""6.23.0"",
-        ""babel-plugin-transform-es2015-function-name"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-literals"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-modules-amd"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-modules-commonjs"": ""6.26.2"",
-        ""babel-plugin-transform-es2015-modules-systemjs"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-modules-umd"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-object-super"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-parameters"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-shorthand-properties"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-spread"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-sticky-regex"": ""6.24.1"",
-        ""babel-plugin-transform-es2015-template-literals"": ""6.22.0"",
-        ""babel-plugin-transform-es2015-typeof-symbol"": ""6.23.0"",
-        ""babel-plugin-transform-es2015-unicode-regex"": ""6.24.1"",
-        ""babel-plugin-transform-regenerator"": ""6.26.0""
-      }
-    },
-    ""babel-register"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-register/-/babel-register-6.26.0.tgz"",
-      ""integrity"": ""sha1-btAhFz4vy0htestFxgCahW9kcHE="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-core"": ""6.26.3"",
-        ""babel-runtime"": ""6.26.0"",
-        ""core-js"": ""2.6.5"",
-        ""home-or-tmp"": ""2.0.0"",
-        ""lodash"": ""4.17.11"",
-        ""mkdirp"": ""0.5.1"",
-        ""source-map-support"": ""0.4.18""
-      },
-      ""dependencies"": {
-        ""source-map"": {
-          ""version"": ""0.5.7"",
-          ""resolved"": ""https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz"",
-          ""integrity"": ""sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w="",
-          ""dev"": true
+        ""@sinonjs/formatio"": {
+            ""version"": ""3.2.1"",
+            ""resolved"": ""https://registry.npmjs.org/@sinonjs/formatio/-/formatio-3.2.1.tgz"",
+            ""integrity"": ""sha512-tsHvOB24rvyvV2+zKMmPkZ7dXX6LSLKZ7aOtXY6Edklp0uRcgGpOsQTTGTcWViFyx4uhWc6GV8QdnALbIbIdeQ=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@sinonjs/commons"": ""^1"",
+                ""@sinonjs/samsam"": ""^3.1.0""
+            }
         },
-        ""source-map-support"": {
-          ""version"": ""0.4.18"",
-          ""resolved"": ""https://registry.npmjs.org/source-map-support/-/source-map-support-0.4.18.tgz"",
-          ""integrity"": ""sha512-try0/JqxPLF9nOjvSta7tVondkP5dwgyLDjVoyMDlmjugT2lRZ1OfsrYTkCd2hkDnJTKRbO/Rl3orm8vlsUzbA=="",
-          ""dev"": true,
-          ""requires"": {
-            ""source-map"": ""0.5.7""
-          }
-        }
-      }
-    },
-    ""babel-runtime"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-runtime/-/babel-runtime-6.26.0.tgz"",
-      ""integrity"": ""sha1-llxwWGaOgrVde/4E/yM3vItWR/4="",
-      ""dev"": true,
-      ""requires"": {
-        ""core-js"": ""2.6.5"",
-        ""regenerator-runtime"": ""0.11.1""
-      }
-    },
-    ""babel-template"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-template/-/babel-template-6.26.0.tgz"",
-      ""integrity"": ""sha1-3gPi0WOWsGn0bdn/+FIfsaDjXgI="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-traverse"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""babylon"": ""6.18.0"",
-        ""lodash"": ""4.17.11""
-      },
-      ""dependencies"": {
-        ""babylon"": {
-          ""version"": ""6.18.0"",
-          ""resolved"": ""https://registry.npmjs.org/babylon/-/babylon-6.18.0.tgz"",
-          ""integrity"": ""sha512-q/UEjfGJ2Cm3oKV71DJz9d25TPnq5rhBVL2Q4fA5wcC3jcrdn7+SssEybFIxwAvvP+YCsCYNKughoF33GxgycQ=="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-traverse"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-traverse/-/babel-traverse-6.26.0.tgz"",
-      ""integrity"": ""sha1-RqnL1+3MYsjlwGTi0tjQ9ANXZu4="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-code-frame"": ""6.26.0"",
-        ""babel-messages"": ""6.23.0"",
-        ""babel-runtime"": ""6.26.0"",
-        ""babel-types"": ""6.26.0"",
-        ""babylon"": ""6.18.0"",
-        ""debug"": ""2.6.9"",
-        ""globals"": ""9.18.0"",
-        ""invariant"": ""2.2.4"",
-        ""lodash"": ""4.17.11""
-      },
-      ""dependencies"": {
-        ""babylon"": {
-          ""version"": ""6.18.0"",
-          ""resolved"": ""https://registry.npmjs.org/babylon/-/babylon-6.18.0.tgz"",
-          ""integrity"": ""sha512-q/UEjfGJ2Cm3oKV71DJz9d25TPnq5rhBVL2Q4fA5wcC3jcrdn7+SssEybFIxwAvvP+YCsCYNKughoF33GxgycQ=="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babel-types"": {
-      ""version"": ""6.26.0"",
-      ""resolved"": ""https://registry.npmjs.org/babel-types/-/babel-types-6.26.0.tgz"",
-      ""integrity"": ""sha1-o7Bz+Uq0nrb6Vc1lInozQ4BjJJc="",
-      ""dev"": true,
-      ""requires"": {
-        ""babel-runtime"": ""6.26.0"",
-        ""esutils"": ""2.0.2"",
-        ""lodash"": ""4.17.11"",
-        ""to-fast-properties"": ""1.0.3""
-      },
-      ""dependencies"": {
-        ""esutils"": {
-          ""version"": ""2.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/esutils/-/esutils-2.0.2.tgz"",
-          ""integrity"": ""sha1-Cr9PHKpbyx96nYrMbepPqqBLrJs="",
-          ""dev"": true
-        }
-      }
-    },
-    ""babylon"": {
-      ""version"": ""7.0.0-beta.19"",
-      ""resolved"": ""https://registry.npmjs.org/babylon/-/babylon-7.0.0-beta.19.tgz"",
-      ""integrity"": ""sha512-Vg0C9s/REX6/WIXN37UKpv5ZhRi6A4pjHlpkE34+8/a6c2W1Q692n3hmc+SZG5lKRnaExLUbxtJ1SVT+KaCQ/A=="",
-      ""dev"": true
-    },
-    ""balanced-match"": {
-      ""version"": ""1.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.0.tgz"",
-      ""integrity"": ""sha1-ibTRmasr7kneFk6gK4nORi1xt2c="",
-      ""dev"": true
-    },
-    ""base"": {
-      ""version"": ""0.11.2"",
-      ""resolved"": ""https://registry.npmjs.org/base/-/base-0.11.2.tgz"",
-      ""integrity"": ""sha512-5T6P4xPgpp0YDFvSWwEZ4NoE3aM4QBQXDzmVbraCkFj8zHM+mba8SyqB5DbZWyR7mYHo6Y7BdQo3MoA4m0TeQg=="",
-      ""dev"": true,
-      ""requires"": {
-        ""cache-base"": ""1.0.1"",
-        ""class-utils"": ""0.3.6"",
-        ""component-emitter"": ""1.2.1"",
-        ""define-property"": ""1.0.0"",
-        ""isobject"": ""3.0.1"",
-        ""mixin-deep"": ""1.3.1"",
-        ""pascalcase"": ""0.1.1""
-      },
-      ""dependencies"": {
-        ""define-property"": {
-          ""version"": ""1.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/define-property/-/define-property-1.0.0.tgz"",
-          ""integrity"": ""sha1-dp66rz9KY6rTr56NMEybvnm/sOY="",
-          ""dev"": true,
-          ""requires"": {
-            ""is-descriptor"": ""1.0.2""
-          }
+        ""@sinonjs/samsam"": {
+            ""version"": ""3.3.0"",
+            ""resolved"": ""https://registry.npmjs.org/@sinonjs/samsam/-/samsam-3.3.0.tgz"",
+            ""integrity"": ""sha512-beHeJM/RRAaLLsMJhsCvHK31rIqZuobfPLa/80yGH5hnD8PV1hyh9xJBJNFfNmO7yWqm+zomijHsXpI6iTQJfQ=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@sinonjs/commons"": ""^1.0.2"",
+                ""array-from"": ""^2.1.1"",
+                ""lodash"": ""^4.17.11""
+            }
         },
-        ""is-accessor-descriptor"": {
-          ""version"": ""1.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/is-accessor-descriptor/-/is-accessor-descriptor-1.0.0.tgz"",
-          ""integrity"": ""sha512-m5hnHTkcVsPfqx3AKlyttIPb7J+XykHvJP2B9bZDjlhLIoEq4XoK64Vg7boZlVWYK6LUY94dYPEE7Lh0ZkZKcQ=="",
-          ""dev"": true,
-          ""requires"": {
-            ""kind-of"": ""6.0.2""
-          }
+        ""@sinonjs/text-encoding"": {
+            ""version"": ""0.7.1"",
+            ""resolved"": ""https://registry.npmjs.org/@sinonjs/text-encoding/-/text-encoding-0.7.1.tgz"",
+            ""integrity"": ""sha512-+iTbntw2IZPb/anVDbypzfQa+ay64MW0Zo8aJ8gZPWMMK6/OubMVb6lUPMagqjOPnmtauXnFCACVl3O7ogjeqQ=="",
+            ""dev"": true
+        },
+        ""@types/chai"": {
+            ""version"": ""4.1.4"",
+            ""resolved"": ""https://registry.npmjs.org/@types/chai/-/chai-4.1.4.tgz"",
+            ""integrity"": ""sha512-h6+VEw2Vr3ORiFCyyJmcho2zALnUq9cvdB/IO8Xs9itrJVCenC7o26A6+m7D0ihTTr65eS259H5/Ghl/VjYs6g=="",
+            ""dev"": true
+        },
+        ""@types/events"": {
+            ""version"": ""1.2.0"",
+            ""resolved"": ""https://registry.npmjs.org/@types/events/-/events-1.2.0.tgz"",
+            ""integrity"": ""sha512-KEIlhXnIutzKwRbQkGWb/I4HFqBuUykAdHgDED6xqwXJfONCjF5VoE0cXEiurh3XauygxzeDzgtXUqvLkxFzzA=="",
+            ""dev"": true
+        },
+        ""@types/ffi"": {
+            ""version"": ""0.0.19"",
+            ""resolved"": ""https://registry.npmjs.org/@types/ffi/-/ffi-0.0.19.tgz"",
+            ""integrity"": ""sha1-vaEt6ZnhpuRTK4RElzGNuuuYT4I="",
+            ""requires"": {
+                ""@types/node"": ""*"",
+                ""@types/ref"": ""*"",
+                ""@types/ref-struct"": ""*""
+            }
         },
-        ""is-data-descriptor"": {
-          ""version"": ""1.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/is-data-descriptor/-/is-data-descriptor-1.0.0.tgz"",
-          ""integrity"": ""sha512-jbRXy1FmtAoCjQkVmIVYwuuqDFUbaOeDjmed1tOGPrsMhtJA4rD9tkgA0F1qJ3gRFRXcHYVkdeaP50Q5rE/jLQ=="",
-          ""dev"": true,
-          ""requires"": {
-            ""kind-of"": ""6.0.2""
-          }
+        ""@types/fs-extra"": {
+            ""version"": ""5.0.1"",
+            ""resolved"": ""https://registry.npmjs.org/@types/fs-extra/-/fs-extra-5.0.1.tgz"",
+            ""integrity"": ""sha512-h3wnflb+jMTipvbbZnClgA2BexrT4w0GcfoCz5qyxd0IRsbqhLSyesM6mqZTAnhbVmhyTm5tuxfRu9R+8l+lGw=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@types/node"": ""*""
+            }
         },
-        ""is-descriptor"": {
-          ""version"": ""1.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/is-descriptor/-/is-descriptor-1.0.2.tgz"",
-          ""integrity"": ""sha512-2eis5WqQGV7peooDyLmNEPUrps9+SXX5c9pL3xEB+4e9HnGuDa7mB7kHxHw4CbqS9k1T2hOH3miL8n8WtiYVtg=="",
-          ""dev"": true,
-          ""requires"": {
-            ""is-accessor-descriptor"": ""1.0.0"",
-            ""is-data-descriptor"": ""1.0.0"",
-            ""kind-of"": ""6.0.2""
-          }
+        ""@types/glob"": {
+            ""version"": ""7.1.0"",
+            ""resolved"": ""https://registry.npmjs.org/@types/glob/-/glob-7.1.0.tgz"",
+            ""integrity"": ""sha512-k1M3Y8Ge0bOkG7U5IZObIhkrzZHMpuFpd5RJK9Gh8ekq0EhiezLLqv2ow14ylTKqXTHSqM6AMySbWEHRo+7qdQ=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@types/events"": ""*"",
+                ""@types/minimatch"": ""*"",
+                ""@types/node"": ""*""
+            }
         },
-        ""isobject"": {
-          ""version"": ""3.0.1"",
-          ""resolved"": ""https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz"",
-          ""integrity"": ""sha1-TkMekrEalzFjaqH5yNHMvP2reN8="",
-          ""dev"": true
+        ""@types/handlebars"": {
+            ""version"": ""4.0.36"",
+            ""resolved"": ""https://registry.npmjs.org/@types/handlebars/-/handlebars-4.0.36.tgz"",
+            ""integrity"": ""sha512-LjNiTX7TY7wtuC6y3QwC93hKMuqYhgV9A1uXBKNvZtVC8ZvyWAjZkJ5BvT0K7RKqORRYRLMrqCxpw5RgS+MdrQ=="",
+            ""dev"": true
         },
-        ""kind-of"": {
-          ""version"": ""6.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/kind-of/-/kind-of-6.0.2.tgz"",
-          ""integrity"": ""sha512-s5kLOcnH0XqDO+FvuaLX8DDjZ18CGFk7VygH40QoKPUQhW4e2rvM0rwUq0t8IQDOwYSeLK01U90OjzBTme2QqA=="",
-          ""dev"": true
-        }
-      }
-    },
-    ""big.js"": {
-      ""version"": ""3.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/big.js/-/big.js-3.2.0.tgz"",
-      ""integrity"": ""sha512-+hN/Zh2D08Mx65pZ/4g5bsmNiZUuChDiQfTUQ7qJr4/kuopCr88xZsAXv6mBoZEsUI4OuGHlX59qE94K2mMW8Q=="",
-      ""dev"": true
-    },
-    ""binary-extensions"": {
-      ""version"": ""1.13.0"",
-      ""resolved"": ""https://registry.npmjs.org/binary-extensions/-/binary-extensions-1.13.0.tgz"",
-      ""integrity"": ""sha512-EgmjVLMn22z7eGGv3kcnHwSnJXmFHjISTY9E/S5lIcTD3Oxw05QTcBLNkJFzcb3cNueUdF/IN4U+d78V0zO8Hw=="",
-      ""dev"": true,
-      ""optional"": true
-    },
-    ""bluebird"": {
-      ""version"": ""3.5.1"",
-      ""resolved"": ""https://registry.npmjs.org/bluebird/-/bluebird-3.5.1.tgz"",
-      ""integrity"": ""sha512-MKiLiV+I1AA596t9w1sQJ8jkiSr5+ZKi0WKrYGUn6d1Fx+Ij4tIj+m2WMQSGczs5jZVxV339chE8iwk6F64wjA=="",
-      ""dev"": true
-    },
-    ""brace-expansion"": {
-      ""version"": ""1.1.11"",
-      ""resolved"": ""https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz"",
-      ""integrity"": ""sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA=="",
-      ""dev"": true,
-      ""requires"": {
-        ""balanced-match"": ""1.0.0"",
-        ""concat-map"": ""0.0.1""
-      }
-    },
-    ""braces"": {
-      ""version"": ""1.8.5"",
-      ""resolved"": ""https://registry.npmjs.org/braces/-/braces-1.8.5.tgz"",
-      ""integrity"": ""sha1-uneWLhLf+WnWt2cR6RS3N4V79qc="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""expand-range"": ""1.8.2"",
-        ""preserve"": ""0.2.0"",
-        ""repeat-element"": ""1.1.3""
-      }
-    },
-    ""browser-stdout"": {
-      ""version"": ""1.3.1"",
-      ""resolved"": ""https://registry.npmjs.org/browser-stdout/-/browser-stdout-1.3.1.tgz"",
-      ""integrity"": ""sha512-qhAVI1+Av2X7qelOfAIYwXONood6XlZE/fXaBSmW/T5SzLAmCgzi+eiWE7fUvbHaeNBQH13UftjpXxsfLkMpgw=="",
-      ""dev"": true
-    },
-    ""buffer-from"": {
-      ""version"": ""1.1.0"",
-      ""resolved"": ""https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.0.tgz"",
-      ""integrity"": ""sha512-c5mRlguI/Pe2dSZmpER62rSCu0ryKmWddzRYsuXc50U2/g8jMOulc31VZMa4mYx31U5xsmSOpDCgH88Vl9cDGQ=="",
-      ""dev"": true
-    },
-    ""builtin-modules"": {
-      ""version"": ""1.1.1"",
-      ""resolved"": ""https://registry.npmjs.org/builtin-modules/-/builtin-modules-1.1.1.tgz"",
-      ""integrity"": ""sha1-Jw8HbFpywC9bZaR9+Uxf46J4iS8="",
-      ""dev"": true
-    },
-    ""cache-base"": {
-      ""version"": ""1.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/cache-base/-/cache-base-1.0.1.tgz"",
-      ""integrity"": ""sha512-AKcdTnFSWATd5/GCPRxr2ChwIJ85CeyrEyjRHlKxQ56d4XJMGym0uAiKn0xbLOGOl3+yRpOTi484dVCEc5AUzQ=="",
-      ""dev"": true,
-      ""requires"": {
-        ""collection-visit"": ""1.0.0"",
-        ""component-emitter"": ""1.2.1"",
-        ""get-value"": ""2.0.6"",
-        ""has-value"": ""1.0.0"",
-        ""isobject"": ""3.0.1"",
-        ""set-value"": ""2.0.0"",
-        ""to-object-path"": ""0.3.0"",
-        ""union-value"": ""1.0.0"",
-        ""unset-value"": ""1.0.0""
-      },
-      ""dependencies"": {
-        ""isobject"": {
-          ""version"": ""3.0.1"",
-          ""resolved"": ""https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz"",
-          ""integrity"": ""sha1-TkMekrEalzFjaqH5yNHMvP2reN8="",
-          ""dev"": true
-        }
-      }
-    },
-    ""catharsis"": {
-      ""version"": ""0.8.9"",
-      ""resolved"": ""https://registry.npmjs.org/catharsis/-/catharsis-0.8.9.tgz"",
-      ""integrity"": ""sha1-mMyJDKZS3S7w5ws3klMQ/56Q/Is="",
-      ""dev"": true,
-      ""requires"": {
-        ""underscore-contrib"": ""0.3.0""
-      }
-    },
-    ""chai"": {
-      ""version"": ""4.1.2"",
-      ""resolved"": ""https://registry.npmjs.org/chai/-/chai-4.1.2.tgz"",
-      ""integrity"": ""sha1-D2RYS6ZC8PKs4oBiefTwbKI61zw="",
-      ""dev"": true,
-      ""requires"": {
-        ""assertion-error"": ""1.0.2"",
-        ""check-error"": ""1.0.2"",
-        ""deep-eql"": ""3.0.1"",
-        ""get-func-name"": ""2.0.0"",
-        ""pathval"": ""1.1.0"",
-        ""type-detect"": ""4.0.3""
-      }
-    },
-    ""chalk"": {
-      ""version"": ""1.1.3"",
-      ""resolved"": ""https://registry.npmjs.org/chalk/-/chalk-1.1.3.tgz"",
-      ""integrity"": ""sha1-qBFcVeSnAv5NFQq9OHKCKn4J/Jg="",
-      ""dev"": true,
-      ""requires"": {
-        ""ansi-styles"": ""2.2.1"",
-        ""escape-string-regexp"": ""1.0.5"",
-        ""has-ansi"": ""2.0.0"",
-        ""strip-ansi"": ""3.0.1"",
-        ""supports-color"": ""2.0.0""
-      },
-      ""dependencies"": {
-        ""supports-color"": {
-          ""version"": ""2.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/supports-color/-/supports-color-2.0.0.tgz"",
-          ""integrity"": ""sha1-U10EXOa2Nj+kARcIRimZXp3zJMc="",
-          ""dev"": true
-        }
-      }
-    },
-    ""check-error"": {
-      ""version"": ""1.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/check-error/-/check-error-1.0.2.tgz"",
-      ""integrity"": ""sha1-V00xLt2Iu13YkS6Sht1sCu1KrII="",
-      ""dev"": true
-    },
-    ""chokidar"": {
-      ""version"": ""1.7.0"",
-      ""resolved"": ""https://registry.npmjs.org/chokidar/-/chokidar-1.7.0.tgz"",
-      ""integrity"": ""sha1-eY5ol3gVHIB2tLNg5e3SjNortGg="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""anymatch"": ""1.3.2"",
-        ""async-each"": ""1.0.1"",
-        ""fsevents"": ""1.2.7"",
-        ""glob-parent"": ""2.0.0"",
-        ""inherits"": ""2.0.3"",
-        ""is-binary-path"": ""1.0.1"",
-        ""is-glob"": ""2.0.1"",
-        ""path-is-absolute"": ""1.0.1"",
-        ""readdirp"": ""2.2.1""
-      }
-    },
-    ""class-utils"": {
-      ""version"": ""0.3.6"",
-      ""resolved"": ""https://registry.npmjs.org/class-utils/-/class-utils-0.3.6.tgz"",
-      ""integrity"": ""sha512-qOhPa/Fj7s6TY8H8esGu5QNpMMQxz79h+urzrNYN6mn+9BnxlDGf5QZ+XeCDsxSjPqsSR56XOZOJmpeurnLMeg=="",
-      ""dev"": true,
-      ""requires"": {
-        ""arr-union"": ""3.1.0"",
-        ""define-property"": ""0.2.5"",
-        ""isobject"": ""3.0.1"",
-        ""static-extend"": ""0.1.2""
-      },
-      ""dependencies"": {
-        ""define-property"": {
-          ""version"": ""0.2.5"",
-          ""resolved"": ""https://registry.npmjs.org/define-property/-/define-property-0.2.5.tgz"",
-          ""integrity"": ""sha1-w1se+RjsPJkPmlvFe+BKrOxcgRY="",
-          ""dev"": true,
-          ""requires"": {
-            ""is-descriptor"": ""0.1.6""
-          }
+        ""@types/highlight.js"": {
+            ""version"": ""9.12.2"",
+            ""resolved"": ""https://registry.npmjs.org/@types/highlight.js/-/highlight.js-9.12.2.tgz"",
+            ""integrity"": ""sha512-y5x0XD/WXDaGSyiTaTcKS4FurULJtSiYbGTeQd0m2LYZGBcZZ/7fM6t5H/DzeUF+kv8y6UfmF6yJABQsHcp9VQ=="",
+            ""dev"": true
         },
-        ""isobject"": {
-          ""version"": ""3.0.1"",
-          ""resolved"": ""https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz"",
-          ""integrity"": ""sha1-TkMekrEalzFjaqH5yNHMvP2reN8="",
-          ""dev"": true
-        }
-      }
-    },
-    ""collection-visit"": {
-      ""version"": ""1.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/collection-visit/-/collection-visit-1.0.0.tgz"",
-      ""integrity"": ""sha1-S8A3PBZLwykbTTaMgpzxqApZ3KA="",
-      ""dev"": true,
-      ""requires"": {
-        ""map-visit"": ""1.0.0"",
-        ""object-visit"": ""1.0.1""
-      }
-    },
-    ""color"": {
-      ""version"": ""3.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/color/-/color-3.0.0.tgz"",
-      ""integrity"": ""sha512-jCpd5+s0s0t7p3pHQKpnJ0TpQKKdleP71LWcA0aqiljpiuAkOSUFN/dyH8ZwF0hRmFlrIuRhufds1QyEP9EB+w=="",
-      ""dev"": true,
-      ""requires"": {
-        ""color-convert"": ""1.9.3"",
-        ""color-string"": ""1.5.3""
-      },
-      ""dependencies"": {
-        ""color-convert"": {
-          ""version"": ""1.9.3"",
-          ""resolved"": ""https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz"",
-          ""integrity"": ""sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg=="",
-          ""dev"": true,
-          ""requires"": {
-            ""color-name"": ""1.1.3""
-          }
-        }
-      }
-    },
-    ""color-convert"": {
-      ""version"": ""1.9.0"",
-      ""resolved"": ""https://registry.npmjs.org/color-convert/-/color-convert-1.9.0.tgz"",
-      ""integrity"": ""sha1-Gsz5fdc5uYO/mU1W/sj5WFNkG3o="",
-      ""dev"": true,
-      ""requires"": {
-        ""color-name"": ""1.1.3""
-      }
-    },
-    ""color-name"": {
-      ""version"": ""1.1.3"",
-      ""resolved"": ""https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz"",
-      ""integrity"": ""sha1-p9BVi9icQveV3UIyj3QIMcpTvCU="",
-      ""dev"": true
-    },
-    ""color-string"": {
-      ""version"": ""1.5.3"",
-      ""resolved"": ""https://registry.npmjs.org/color-string/-/color-string-1.5.3.tgz"",
-      ""integrity"": ""sha512-dC2C5qeWoYkxki5UAXapdjqO672AM4vZuPGRQfO8b5HKuKGBbKWpITyDYN7TOFKvRW7kOgAn3746clDBMDJyQw=="",
-      ""dev"": true,
-      ""requires"": {
-        ""color-name"": ""1.1.3"",
-        ""simple-swizzle"": ""0.2.2""
-      }
-    },
-    ""colornames"": {
-      ""version"": ""1.1.1"",
-      ""resolved"": ""https://registry.npmjs.org/colornames/-/colornames-1.1.1.tgz"",
-      ""integrity"": ""sha1-+IiQMGhcfE/54qVZ9Qd+t2qBb5Y="",
-      ""dev"": true
-    },
-    ""colors"": {
-      ""version"": ""1.3.3"",
-      ""resolved"": ""https://registry.npmjs.org/colors/-/colors-1.3.3.tgz"",
-      ""integrity"": ""sha512-mmGt/1pZqYRjMxB1axhTo16/snVZ5krrKkcmMeVKxzECMMXoCgnvTPp10QgHfcbQZw8Dq2jMNG6je4JlWU0gWg=="",
-      ""dev"": true
-    },
-    ""colorspace"": {
-      ""version"": ""1.1.1"",
-      ""resolved"": ""https://registry.npmjs.org/colorspace/-/colorspace-1.1.1.tgz"",
-      ""integrity"": ""sha512-pI3btWyiuz7Ken0BWh9Elzsmv2bM9AhA7psXib4anUXy/orfZ/E0MbQwhSOG/9L8hLlalqrU0UhOuqxW1YjmVw=="",
-      ""dev"": true,
-      ""requires"": {
-        ""color"": ""3.0.0"",
-        ""text-hex"": ""1.0.0""
-      }
-    },
-    ""commander"": {
-      ""version"": ""2.11.0"",
-      ""resolved"": ""https://registry.npmjs.org/commander/-/commander-2.11.0.tgz"",
-      ""integrity"": ""sha512-b0553uYA5YAEGgyYIGYROzKQ7X5RAqedkfjiZxwi0kL1g3bOaBNNZfYkzt/CL0umgD5wc9Jec2FbB98CjkMRvQ=="",
-      ""dev"": true
-    },
-    ""component-emitter"": {
-      ""version"": ""1.2.1"",
-      ""resolved"": ""https://registry.npmjs.org/component-emitter/-/component-emitter-1.2.1.tgz"",
-      ""integrity"": ""sha1-E3kY1teCg/ffemt8WmPhQOaUJeY="",
-      ""dev"": true
-    },
-    ""concat-map"": {
-      ""version"": ""0.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz"",
-      ""integrity"": ""sha1-2Klr13/Wjfd5OnMDajug1UBdR3s="",
-      ""dev"": true
-    },
-    ""convert-source-map"": {
-      ""version"": ""1.6.0"",
-      ""resolved"": ""https://registry.npmjs.org/convert-source-map/-/convert-source-map-1.6.0.tgz"",
-      ""integrity"": ""sha512-eFu7XigvxdZ1ETfbgPBohgyQ/Z++C0eEhTor0qRwBw9unw+L0/6V8wkSuGgzdThkiS5lSpdptOQPD8Ak40a+7A=="",
-      ""dev"": true,
-      ""requires"": {
-        ""safe-buffer"": ""5.1.2""
-      }
-    },
-    ""copy-descriptor"": {
-      ""version"": ""0.1.1"",
-      ""resolved"": ""https://registry.npmjs.org/copy-descriptor/-/copy-descriptor-0.1.1.tgz"",
-      ""integrity"": ""sha1-Z29us8OZl8LuGsOpJP1hJHSPV40="",
-      ""dev"": true
-    },
-    ""core-js"": {
-      ""version"": ""2.6.5"",
-      ""resolved"": ""https://registry.npmjs.org/core-js/-/core-js-2.6.5.tgz"",
-      ""integrity"": ""sha512-klh/kDpwX8hryYL14M9w/xei6vrv6sE8gTHDG7/T/+SEovB/G4ejwcfE/CBzO6Edsu+OETZMZ3wcX/EjUkrl5A=="",
-      ""dev"": true
-    },
-    ""core-util-is"": {
-      ""version"": ""1.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.2.tgz"",
-      ""integrity"": ""sha1-tf1UIgqivFq1eqtxQMlAdUUDwac="",
-      ""dev"": true
-    },
-    ""debug"": {
-      ""version"": ""2.6.9"",
-      ""resolved"": ""https://registry.npmjs.org/debug/-/debug-2.6.9.tgz"",
-      ""integrity"": ""sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA=="",
-      ""requires"": {
-        ""ms"": ""2.0.0""
-      }
-    },
-    ""decode-uri-component"": {
-      ""version"": ""0.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/decode-uri-component/-/decode-uri-component-0.2.0.tgz"",
-      ""integrity"": ""sha1-6zkTMzRYd1y4TNGh+uBiEGu4dUU="",
-      ""dev"": true
-    },
-    ""deep-eql"": {
-      ""version"": ""3.0.1"",
-      ""resolved"": ""https://registry.npmjs.org/deep-eql/-/deep-eql-3.0.1.tgz"",
-      ""integrity"": ""sha512-+QeIQyN5ZuO+3Uk5DYh6/1eKO0m0YmJFGNmFHGACpf1ClL1nmlV/p4gNgbl2pJGxgXb4faqo6UE+M5ACEMyVcw=="",
-      ""dev"": true,
-      ""requires"": {
-        ""type-detect"": ""4.0.3""
-      }
-    },
-    ""define-property"": {
-      ""version"": ""2.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/define-property/-/define-property-2.0.2.tgz"",
-      ""integrity"": ""sha512-jwK2UV4cnPpbcG7+VRARKTZPUWowwXA8bzH5NP6ud0oeAxyYPuGZUAC7hMugpCdz4BeSZl2Dl9k66CHJ/46ZYQ=="",
-      ""dev"": true,
-      ""requires"": {
-        ""is-descriptor"": ""1.0.2"",
-        ""isobject"": ""3.0.1""
-      },
-      ""dependencies"": {
-        ""is-accessor-descriptor"": {
-          ""version"": ""1.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/is-accessor-descriptor/-/is-accessor-descriptor-1.0.0.tgz"",
-          ""integrity"": ""sha512-m5hnHTkcVsPfqx3AKlyttIPb7J+XykHvJP2B9bZDjlhLIoEq4XoK64Vg7boZlVWYK6LUY94dYPEE7Lh0ZkZKcQ=="",
-          ""dev"": true,
-          ""requires"": {
-            ""kind-of"": ""6.0.2""
-          }
+        ""@types/lodash"": {
+            ""version"": ""4.14.109"",
+            ""resolved"": ""https://registry.npmjs.org/@types/lodash/-/lodash-4.14.109.tgz"",
+            ""integrity"": ""sha512-hop8SdPUEzbcJm6aTsmuwjIYQo1tqLseKCM+s2bBqTU2gErwI4fE+aqUVOlscPSQbKHKgtMMPoC+h4AIGOJYvw=="",
+            ""dev"": true
+        },
+        ""@types/marked"": {
+            ""version"": ""0.3.0"",
+            ""resolved"": ""https://registry.npmjs.org/@types/marked/-/marked-0.3.0.tgz"",
+            ""integrity"": ""sha512-CSf9YWJdX1DkTNu9zcNtdCcn6hkRtB5ILjbhRId4ZOQqx30fXmdecuaXhugQL6eyrhuXtaHJ7PHI+Vm7k9ZJjg=="",
+            ""dev"": true
+        },
+        ""@types/minimatch"": {
+            ""version"": ""3.0.3"",
+            ""resolved"": ""https://registry.npmjs.org/@types/minimatch/-/minimatch-3.0.3.tgz"",
+            ""integrity"": ""sha512-tHq6qdbT9U1IRSGf14CL0pUlULksvY9OZ+5eEgl1N7t+OA3tGvNpxJCzuKQlsNgCVwbAs670L1vcVQi8j9HjnA=="",
+            ""dev"": true
+        },
+        ""@types/mocha"": {
+            ""version"": ""5.2.3"",
+            ""resolved"": ""https://registry.npmjs.org/@types/mocha/-/mocha-5.2.3.tgz"",
+            ""integrity"": ""sha512-C1wVVr7xhKu6c3Mb27dFzNYR05qvHwgtpN+JOYTGc1pKA7dCEDDYpscn7kul+bCUwa3NoGDbzI1pdznSOa397w=="",
+            ""dev"": true
+        },
+        ""@types/node"": {
+            ""version"": ""8.0.47"",
+            ""resolved"": ""https://registry.npmjs.org/@types/node/-/node-8.0.47.tgz"",
+            ""integrity"": ""sha512-kOwL746WVvt/9Phf6/JgX/bsGQvbrK5iUgzyfwZNcKVFcjAUVSpF9HxevLTld2SG9aywYHOILj38arDdY1r/iQ==""
+        },
+        ""@types/ref"": {
+            ""version"": ""0.0.28"",
+            ""resolved"": ""https://registry.npmjs.org/@types/ref/-/ref-0.0.28.tgz"",
+            ""integrity"": ""sha1-FaYSU+0SWQOLR0md4cmwy8pX9Vw="",
+            ""requires"": {
+                ""@types/node"": ""*""
+            }
         },
-        ""is-data-descriptor"": {
-          ""version"": ""1.0.0"",
-          ""resolved"": ""https://registry.npmjs.org/is-data-descriptor/-/is-data-descriptor-1.0.0.tgz"",
-          ""integrity"": ""sha512-jbRXy1FmtAoCjQkVmIVYwuuqDFUbaOeDjmed1tOGPrsMhtJA4rD9tkgA0F1qJ3gRFRXcHYVkdeaP50Q5rE/jLQ=="",
-          ""dev"": true,
-          ""requires"": {
-            ""kind-of"": ""6.0.2""
-          }
+        ""@types/ref-struct"": {
+            ""version"": ""0.0.28"",
+            ""resolved"": ""https://registry.npmjs.org/@types/ref-struct/-/ref-struct-0.0.28.tgz"",
+            ""integrity"": ""sha1-uECorElUEVFdyuIJAQ1axmFVDoQ="",
+            ""requires"": {
+                ""@types/ref"": ""*""
+            }
         },
-        ""is-descriptor"": {
-          ""version"": ""1.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/is-descriptor/-/is-descriptor-1.0.2.tgz"",
-          ""integrity"": ""sha512-2eis5WqQGV7peooDyLmNEPUrps9+SXX5c9pL3xEB+4e9HnGuDa7mB7kHxHw4CbqS9k1T2hOH3miL8n8WtiYVtg=="",
-          ""dev"": true,
-          ""requires"": {
-            ""is-accessor-descriptor"": ""1.0.0"",
-            ""is-data-descriptor"": ""1.0.0"",
-            ""kind-of"": ""6.0.2""
-          }
+        ""@types/shelljs"": {
+            ""version"": ""0.7.8"",
+            ""resolved"": ""https://registry.npmjs.org/@types/shelljs/-/shelljs-0.7.8.tgz"",
+            ""integrity"": ""sha512-M2giRw93PxKS7YjU6GZjtdV9HASdB7TWqizBXe4Ju7AqbKlWvTr0gNO92XH56D/gMxqD/jNHLNfC5hA34yGqrQ=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@types/glob"": ""*"",
+                ""@types/node"": ""*""
+            }
         },
-        ""isobject"": {
-          ""version"": ""3.0.1"",
-          ""resolved"": ""https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz"",
-          ""integrity"": ""sha1-TkMekrEalzFjaqH5yNHMvP2reN8="",
-          ""dev"": true
+        ""@types/sinon"": {
+            ""version"": ""5.0.1"",
+            ""resolved"": ""https://registry.npmjs.org/@types/sinon/-/sinon-5.0.1.tgz"",
+            ""integrity"": ""sha512-yxzBCIjE3lp9lYjfBbIK/LRCoXgCLLbIIBIje7eNCcUIIR2CZZtyX5uto2hVoMSMqLrsRrT6mwwUEd0yFgOwpA=="",
+            ""dev"": true
+        },
+        ""@types/weak"": {
+            ""version"": ""1.0.0"",
+            ""resolved"": ""https://registry.npmjs.org/@types/weak/-/weak-1.0.0.tgz"",
+            ""integrity"": ""sha512-6WXZpeAac3vj5+OfQvlqYEtc88oOgvkcxbrnmBw53Da6gA+MGztL+Hns3BpnyUevgz+4DxsJblgAew1A/tkcng=="",
+            ""dev"": true,
+            ""requires"": {
+                ""@types/node"": ""*""
+            }
         },
-        ""kind-of"": {
-          ""version"": ""6.0.2"",
-          ""resolved"": ""https://registry.npmjs.org/kind-of/-/kind-of-6.0.2.tgz"",
-          ""integrity"": ""sha512-s5kLOcnH0XqDO+FvuaLX8DDjZ18CGFk7VygH40QoKPUQhW4e2rvM0rwUq0t8IQDOwYSeLK01U90OjzBTme2QqA=="",
-          ""dev"": true
-        }
-      }
-    },
-    ""detect-indent"": {
-      ""version"": ""4.0.0"",
-      ""resolved"": ""https://registry.npmjs.org/detect-indent/-/detect-indent-4.0.0.tgz"",
-      ""integrity"": ""sha1-920GQ1LN9Docts5hnE7jqUdd4gg="",
-      ""dev"": true,
-      ""requires"": {
-        ""repeating"": ""2.0.1""
-      }
-    },
-    ""diagnostics"": {
-      ""version"": ""1.1.1"",
-      ""resolved"": ""https://registry.npmjs.org/diagnostics/-/diagnostics-1.1.1.tgz"",
-      ""integrity"": ""sha512-8wn1PmdunLJ9Tqbx+Fx/ZEuHfJf4NKSN2ZBj7SJC/OWRWha843+WsTjqMe1B5E3p28jqBlp+mJ2fPVxPyNgYKQ=="",
-      ""dev"": true,
-      ""requires"": {
-        ""colorspace"": ""1.1.1"",
-        ""enabled"": ""1.0.2"",
-        ""kuler"": ""1.0.1""
-      }
-    },
-    ""diff"": {
-      ""version"": ""3.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/diff/-/diff-3.2.0.tgz"",
-      ""integrity"": ""sha1-yc45Okt8vQsFinJck98pkCeGj/k="",
-      ""dev"": true
-    },
-    ""doctrine"": {
-      ""version"": ""0.7.2"",
-      ""resolved"": ""https://registry.npmjs.org/doctrine/-/doctrine-0.7.2.tgz"",
-      ""integrity"": ""sha1-fLhgNZujvpDgQLJrcpzkv6ZUxSM="",
-      ""dev"": true,
-      ""requires"": {
-        ""esutils"": ""1.1.6"",
-        ""isarray"": ""0.0.1""
-      }
-    },
-    ""emojis-list"": {
-      ""version"": ""2.1.0"",
-      ""resolved"": ""https://registry.npmjs.org/emojis-list/-/emojis-list-2.1.0.tgz"",
-      ""integrity"": ""sha1-TapNnbAPmBmIDHn6RXrlsJof04k="",
-      ""dev"": true
-    },
-    ""enabled"": {
-      ""version"": ""1.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/enabled/-/enabled-1.0.2.tgz"",
-      ""integrity"": ""sha1-ll9lE9LC0cX0ZStkouM5ZGf8L5M="",
-      ""dev"": true,
-      ""requires"": {
-        ""env-variable"": ""0.0.5""
-      }
-    },
-    ""env-variable"": {
-      ""version"": ""0.0.5"",
-      ""resolved"": ""https://registry.npmjs.org/env-variable/-/env-variable-0.0.5.tgz"",
-      ""integrity"": ""sha512-zoB603vQReOFvTg5xMl9I1P2PnHsHQQKTEowsKKD7nseUfJq6UWzK+4YtlWUO1nhiQUxe6XMkk+JleSZD1NZFA=="",
-      ""dev"": true
-    },
-    ""escape-string-regexp"": {
-      ""version"": ""1.0.5"",
-      ""resolved"": ""https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz"",
-      ""integrity"": ""sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ="",
-      ""dev"": true
-    },
-    ""esutils"": {
-      ""version"": ""1.1.6"",
-      ""resolved"": ""https://registry.npmjs.org/esutils/-/esutils-1.1.6.tgz"",
-      ""integrity"": ""sha1-wBzKqa5LiXxtDD4hCuUvPHqEQ3U="",
-      ""dev"": true
-    },
-    ""expand-brackets"": {
-      ""version"": ""0.1.5"",
-      ""resolved"": ""https://registry.npmjs.org/expand-brackets/-/expand-brackets-0.1.5.tgz"",
-      ""integrity"": ""sha1-3wcoTjQqgHzXM6xa9yQR5YHRF3s="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""is-posix-bracket"": ""0.1.1""
-      }
-    },
-    ""expand-range"": {
-      ""version"": ""1.8.2"",
-      ""resolved"": ""https://registry.npmjs.org/expand-range/-/expand-range-1.8.2.tgz"",
-      ""integrity"": ""sha1-opnv/TNf4nIeuujiV+x5ZE/IUzc="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""fill-range"": ""2.2.4""
-      }
-    },
-    ""extend-shallow"": {
-      ""version"": ""3.0.2"",
-      ""resolved"": ""https://registry.npmjs.org/extend-shallow/-/extend-shallow-3.0.2.tgz"",
-      ""integrity"": ""sha1-Jqcarwc7OfshJxcnRhMcJwQCjbg="",
-      ""dev"": true,
-      ""requires"": {
-        ""assign-symbols"": ""1.0.0"",
-        ""is-extendable"": ""1.0.1""
-      },
-      ""dependencies"": {
-        ""is-extendable"": {
-          ""version"": ""1.0.1"",
-          ""resolved"": ""https://registry.npmjs.org/is-extendable/-/is-extendable-1.0.1.tgz"",
-          ""integrity"": ""sha512-arnXMxT1hhoKo9k1LZdmlNyJdDDfy2v0fXjFlmok4+i8ul/6WlbVge9bhM74OpNPQPMGUToDtz+KXa1PneJxOA=="",
-          ""dev"": true,
-          ""requires"": {
-            ""is-plain-object"": ""2.0.4""
-          }
-        }
-      }
-    },
-    ""extglob"": {
-      ""version"": ""0.3.2"",
-      ""resolved"": ""https://registry.npmjs.org/extglob/-/extglob-0.3.2.tgz"",
-      ""integrity"": ""sha1-Lhj/PS9JqydlzskCPwEdqo2DSaE="",
-      ""dev"": true,
-      ""optional"": true,
-      ""requires"": {
-        ""is-extglob"": ""1.0.0""
-      }
-    },
-    ""fast-safe-stringify"": {
-      ""version"": ""2.0.6"",
-      ""resolved"": ""https://registry.npmjs.org/fast-safe-stringify/-/fast-safe-stringify-2.0.6.tgz"",
-      ""integrity"": ""sha512-q8BZ89jjc+mz08rSxROs8VsrBBcn1SIw1kq9NjolL509tkABRk9io01RAjSaEv1Xb2uFLt8VtRiZbGp5H8iDtg=="",
-      ""dev"": true
-    },
-    ""fecha"": {
-      ""version"": ""2.3.3"",
-      ""resolved"": ""https://registry.npmjs.org/fecha/-/fecha-2.3.3.tgz"",
-      ""integrity"": ""sha512-lUGBnIamTAwk4znq5BcqsDaxSmZ9nDVJaij6NvRt/Tg4R69gERA+otPKbS86ROw9nxVMw2/mp1fnaiWqbs6Sdg=="",
-      ""dev"": true
-    },
-    ""ffi"": {
-      ""version"": ""2.2.0"",
-      ""resolved"": ""https://registry.npmjs.org/ffi/-/ffi-2.2.0.tgz"",
-      ""integrity"": ""sha1-vxiwRmain3EiftVoldVDCvRwQvo="",
-      ""requires"": {
-        ""bindings"": ""1.2.1"",
-        ""debug"": ""2.6.9"",
-        ""nan"": ""2.7.0"",
-        ""ref"": ""1.3.5"",
-        ""ref-struct"": ""1.1.0""
-      },
-      ""dependencies"": {
-        ""bindings"": {
-          ""version"": ""1.2.1"",
-          ""resolved"": ""https://registry.npmjs.org/bindings/-/bindings-1.2.1.tgz"",
-          ""integrity"": ""sha1-FK1hE4EtLTfXLme0ystLtyZQXxE=""
+        ""ansi-regex"": {
+            ""version"": ""2.1.1"",
+            ""res",6801,2019-03-15 16:51:42,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/266064828,https://github.com/hyperledger/indy-sdk/pull/1528#discussion_r266064828,jovfer
https://github.com/hyperledger/indy-sdk/pull/1522,https://github.com/hyperledger/indy-sdk/pull/1522,It should be possible (and it will be very helpful and safe) to force Rust compiler to use i32 representation,f37e0a535747ac3936ba95aa74d7f4464999e232,2019-03-11 16:03:00,264305414,"@@ -19,7 +19,12 @@ use utils::ctypes;
 
 pub type IndyHandle = i32;
 
-pub type WalletHandle = i32;
+//pub type WalletHandle = i32;
+#[derive(Debug, Hash, PartialEq, Eq, Copy, Clone)]",7,2019-03-14 11:24:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/264305414,https://github.com/hyperledger/indy-sdk/pull/1522#discussion_r264305414,jovfer
https://github.com/hyperledger/indy-sdk/pull/1522,https://github.com/hyperledger/indy-sdk/pull/1522,"Yes, I added a repr transparent.
Rust documentation is here: https://doc.rust-lang.org/1.26.2/unstable-book/language-features/repr-transparent.html 
",f37e0a535747ac3936ba95aa74d7f4464999e232,2019-03-11 18:09:15,264362105,"@@ -19,7 +19,12 @@ use utils::ctypes;
 
 pub type IndyHandle = i32;
 
-pub type WalletHandle = i32;
+//pub type WalletHandle = i32;
+#[derive(Debug, Hash, PartialEq, Eq, Copy, Clone)]",7,2019-03-14 11:24:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/264362105,https://github.com/hyperledger/indy-sdk/pull/1522#discussion_r264362105,AxelNennker
https://github.com/hyperledger/indy-sdk/pull/1518,https://github.com/hyperledger/indy-sdk/pull/1518,@AxelNennker I don't see usage of this function in the PR. Is it temporary state or you are going to delete it?,b511b7cab75da41473733c2592613eac2cccf63e,2019-03-07 11:59:37,263351761,"@@ -454,130 +454,149 @@ pub fn tails_writer_config() -> String {
     json.to_string()
 }
 
-pub fn init_common_wallet() -> (&'static str, &'static str, &'static str, &'static str) {
+pub fn init_anoncreds_wallet(name: &str) -> (String, String, String, String, String) {
+    test::cleanup_storage(name);
+
+    pool::set_protocol_version(PROTOCOL_VERSION).unwrap();
+
+    let config = json!({""id"": name}).to_string();
+
+    //1. Create and Open wallet
+    wallet::create_wallet(&config, WALLET_CREDENTIALS).unwrap();
+    let wallet_handle = wallet::open_wallet(&config, WALLET_CREDENTIALS).unwrap();
+
+    //2. Issuer1 Creates GVT CredentialDefinition
+    let (issuer1_gvt_cred_deg_id, issuer1_gvt_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID,
+                                            &gvt_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //3. Issuer1 Creates XYZ CredentialDefinition
+    let (issuer1_xyz_cred_deg_id, issuer1_xyz_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID,
+                                            &xyz_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //4. Issuer2 Creates GVT CredentialDefinition
+    let (issuer2_gvt_cred_def_id, issuer2_gvt_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID_2,
+                                            &gvt_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //5. Issuer1 Creates GVT CredentialOffer
+    let issuer1_gvt_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer1_gvt_cred_deg_id).unwrap();
+
+    //6. Issuer1 Creates XYZ CredentialOffer
+    let issuer1_xyz_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer1_xyz_cred_deg_id).unwrap();
+
+    //7. Issuer2 Creates GVT CredentialOffer
+    let issuer2_gvt_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer2_gvt_cred_def_id).unwrap();
+
+    //8. Prover creates MasterSecret
+    prover_create_master_secret(wallet_handle, COMMON_MASTER_SECRET).unwrap();
+
+    // Issuer1 issues GVT Credential
+    //9. Prover creates  Credential Request
+    let (issuer1_gvt_credential_req, issuer1_gvt_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer1_gvt_credential_offer,
+                                                                                                         &issuer1_gvt_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+    //10. Issuer1 creates GVT Credential
+    let (issuer1_gvt_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer1_gvt_credential_offer,
+                                                            &issuer1_gvt_credential_req,
+                                                            &gvt_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //11. Prover stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL1_ID,
+                            &issuer1_gvt_credential_req_metadata,
+                            &issuer1_gvt_cred,
+                            &issuer1_gvt_credential_def_json,
+                            None).unwrap();
+
+    // Issuer1 issue XYZ Credential
+    //12. Prover Creates Credential Request
+    let (issuer1_xyz_credential_req, issuer1_xyz_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer1_xyz_credential_offer,
+                                                                                                         &issuer1_xyz_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+    //13. Issuer1 Creates XYZ Credential
+    let (issuer1_xyz_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer1_xyz_credential_offer,
+                                                            &issuer1_xyz_credential_req,
+                                                            &xyz_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //14. Prover stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL2_ID,
+                            &issuer1_xyz_credential_req_metadata,
+                            &issuer1_xyz_cred,
+                            &issuer1_xyz_credential_def_json,
+                            None).unwrap();
+
+    // Issuer2 issues GVT Credential
+    //15. Prover Creates Credential Request
+    let (issuer2_gvt_credential_req, issuer2_gvt_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer2_gvt_credential_offer,
+                                                                                                         &issuer2_gvt_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+
+    //16. Issuer2 Creates XYZ Credential
+    let (issuer2_gvt_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer2_gvt_credential_offer,
+                                                            &issuer2_gvt_credential_req,
+                                                            &gvt2_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //17. Prover Stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL3_ID,
+                            &issuer2_gvt_credential_req_metadata,
+                            &issuer2_gvt_cred,
+                            &issuer2_gvt_credential_def_json,
+                            None).unwrap();
+
+
+    wallet::close_wallet(wallet_handle).unwrap();
+
+    (issuer1_gvt_credential_def_json,
+     issuer1_gvt_credential_offer,
+     issuer1_gvt_credential_req,
+     issuer1_gvt_cred,
+     config)
+}
+
+pub fn init_common_wallet_once() -> (&'static str, &'static str, &'static str, &'static str) {",,2019-04-04 08:07:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263351761,https://github.com/hyperledger/indy-sdk/pull/1518#discussion_r263351761,jovfer
https://github.com/hyperledger/indy-sdk/pull/1518,https://github.com/hyperledger/indy-sdk/pull/1518,"I think that is a relict of the former code where all tests use _one_ wallet and that is reused. So there is this 'once' stuff that ensures that the wallet is only initialized once.

I kept it because there are some or one test (parallel_auth_encrypt) that tests encryption in parallel and I thought that maybe that test  uses one common wallet. But it turned out that that test also uses separate wallets for the each thread it starts. But I thought maybe we should have a test where several threads work on one wallet in parallel and so I kept this method.",b511b7cab75da41473733c2592613eac2cccf63e,2019-03-07 17:00:44,263476620,"@@ -454,130 +454,149 @@ pub fn tails_writer_config() -> String {
     json.to_string()
 }
 
-pub fn init_common_wallet() -> (&'static str, &'static str, &'static str, &'static str) {
+pub fn init_anoncreds_wallet(name: &str) -> (String, String, String, String, String) {
+    test::cleanup_storage(name);
+
+    pool::set_protocol_version(PROTOCOL_VERSION).unwrap();
+
+    let config = json!({""id"": name}).to_string();
+
+    //1. Create and Open wallet
+    wallet::create_wallet(&config, WALLET_CREDENTIALS).unwrap();
+    let wallet_handle = wallet::open_wallet(&config, WALLET_CREDENTIALS).unwrap();
+
+    //2. Issuer1 Creates GVT CredentialDefinition
+    let (issuer1_gvt_cred_deg_id, issuer1_gvt_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID,
+                                            &gvt_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //3. Issuer1 Creates XYZ CredentialDefinition
+    let (issuer1_xyz_cred_deg_id, issuer1_xyz_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID,
+                                            &xyz_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //4. Issuer2 Creates GVT CredentialDefinition
+    let (issuer2_gvt_cred_def_id, issuer2_gvt_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID_2,
+                                            &gvt_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //5. Issuer1 Creates GVT CredentialOffer
+    let issuer1_gvt_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer1_gvt_cred_deg_id).unwrap();
+
+    //6. Issuer1 Creates XYZ CredentialOffer
+    let issuer1_xyz_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer1_xyz_cred_deg_id).unwrap();
+
+    //7. Issuer2 Creates GVT CredentialOffer
+    let issuer2_gvt_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer2_gvt_cred_def_id).unwrap();
+
+    //8. Prover creates MasterSecret
+    prover_create_master_secret(wallet_handle, COMMON_MASTER_SECRET).unwrap();
+
+    // Issuer1 issues GVT Credential
+    //9. Prover creates  Credential Request
+    let (issuer1_gvt_credential_req, issuer1_gvt_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer1_gvt_credential_offer,
+                                                                                                         &issuer1_gvt_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+    //10. Issuer1 creates GVT Credential
+    let (issuer1_gvt_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer1_gvt_credential_offer,
+                                                            &issuer1_gvt_credential_req,
+                                                            &gvt_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //11. Prover stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL1_ID,
+                            &issuer1_gvt_credential_req_metadata,
+                            &issuer1_gvt_cred,
+                            &issuer1_gvt_credential_def_json,
+                            None).unwrap();
+
+    // Issuer1 issue XYZ Credential
+    //12. Prover Creates Credential Request
+    let (issuer1_xyz_credential_req, issuer1_xyz_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer1_xyz_credential_offer,
+                                                                                                         &issuer1_xyz_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+    //13. Issuer1 Creates XYZ Credential
+    let (issuer1_xyz_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer1_xyz_credential_offer,
+                                                            &issuer1_xyz_credential_req,
+                                                            &xyz_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //14. Prover stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL2_ID,
+                            &issuer1_xyz_credential_req_metadata,
+                            &issuer1_xyz_cred,
+                            &issuer1_xyz_credential_def_json,
+                            None).unwrap();
+
+    // Issuer2 issues GVT Credential
+    //15. Prover Creates Credential Request
+    let (issuer2_gvt_credential_req, issuer2_gvt_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer2_gvt_credential_offer,
+                                                                                                         &issuer2_gvt_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+
+    //16. Issuer2 Creates XYZ Credential
+    let (issuer2_gvt_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer2_gvt_credential_offer,
+                                                            &issuer2_gvt_credential_req,
+                                                            &gvt2_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //17. Prover Stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL3_ID,
+                            &issuer2_gvt_credential_req_metadata,
+                            &issuer2_gvt_cred,
+                            &issuer2_gvt_credential_def_json,
+                            None).unwrap();
+
+
+    wallet::close_wallet(wallet_handle).unwrap();
+
+    (issuer1_gvt_credential_def_json,
+     issuer1_gvt_credential_offer,
+     issuer1_gvt_credential_req,
+     issuer1_gvt_cred,
+     config)
+}
+
+pub fn init_common_wallet_once() -> (&'static str, &'static str, &'static str, &'static str) {",,2019-04-04 08:07:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263476620,https://github.com/hyperledger/indy-sdk/pull/1518#discussion_r263476620,AxelNennker
https://github.com/hyperledger/indy-sdk/pull/1518,https://github.com/hyperledger/indy-sdk/pull/1518,"@AxelNennker There is critical drawback introduced by current PR:
Wallet preparation for Anoncreds is very long operation and prepare wallet every time from scratch (even in parallel) will increase time of testing significantly.

I'm afraid that benefit from parallel run of tests will be totally eliminated by anoncreds wallet preparations.",b511b7cab75da41473733c2592613eac2cccf63e,2019-03-14 10:23:05,265501873,"@@ -454,130 +454,149 @@ pub fn tails_writer_config() -> String {
     json.to_string()
 }
 
-pub fn init_common_wallet() -> (&'static str, &'static str, &'static str, &'static str) {
+pub fn init_anoncreds_wallet(name: &str) -> (String, String, String, String, String) {
+    test::cleanup_storage(name);
+
+    pool::set_protocol_version(PROTOCOL_VERSION).unwrap();
+
+    let config = json!({""id"": name}).to_string();
+
+    //1. Create and Open wallet
+    wallet::create_wallet(&config, WALLET_CREDENTIALS).unwrap();
+    let wallet_handle = wallet::open_wallet(&config, WALLET_CREDENTIALS).unwrap();
+
+    //2. Issuer1 Creates GVT CredentialDefinition
+    let (issuer1_gvt_cred_deg_id, issuer1_gvt_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID,
+                                            &gvt_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //3. Issuer1 Creates XYZ CredentialDefinition
+    let (issuer1_xyz_cred_deg_id, issuer1_xyz_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID,
+                                            &xyz_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //4. Issuer2 Creates GVT CredentialDefinition
+    let (issuer2_gvt_cred_def_id, issuer2_gvt_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID_2,
+                                            &gvt_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //5. Issuer1 Creates GVT CredentialOffer
+    let issuer1_gvt_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer1_gvt_cred_deg_id).unwrap();
+
+    //6. Issuer1 Creates XYZ CredentialOffer
+    let issuer1_xyz_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer1_xyz_cred_deg_id).unwrap();
+
+    //7. Issuer2 Creates GVT CredentialOffer
+    let issuer2_gvt_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer2_gvt_cred_def_id).unwrap();
+
+    //8. Prover creates MasterSecret
+    prover_create_master_secret(wallet_handle, COMMON_MASTER_SECRET).unwrap();
+
+    // Issuer1 issues GVT Credential
+    //9. Prover creates  Credential Request
+    let (issuer1_gvt_credential_req, issuer1_gvt_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer1_gvt_credential_offer,
+                                                                                                         &issuer1_gvt_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+    //10. Issuer1 creates GVT Credential
+    let (issuer1_gvt_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer1_gvt_credential_offer,
+                                                            &issuer1_gvt_credential_req,
+                                                            &gvt_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //11. Prover stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL1_ID,
+                            &issuer1_gvt_credential_req_metadata,
+                            &issuer1_gvt_cred,
+                            &issuer1_gvt_credential_def_json,
+                            None).unwrap();
+
+    // Issuer1 issue XYZ Credential
+    //12. Prover Creates Credential Request
+    let (issuer1_xyz_credential_req, issuer1_xyz_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer1_xyz_credential_offer,
+                                                                                                         &issuer1_xyz_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+    //13. Issuer1 Creates XYZ Credential
+    let (issuer1_xyz_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer1_xyz_credential_offer,
+                                                            &issuer1_xyz_credential_req,
+                                                            &xyz_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //14. Prover stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL2_ID,
+                            &issuer1_xyz_credential_req_metadata,
+                            &issuer1_xyz_cred,
+                            &issuer1_xyz_credential_def_json,
+                            None).unwrap();
+
+    // Issuer2 issues GVT Credential
+    //15. Prover Creates Credential Request
+    let (issuer2_gvt_credential_req, issuer2_gvt_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer2_gvt_credential_offer,
+                                                                                                         &issuer2_gvt_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+
+    //16. Issuer2 Creates XYZ Credential
+    let (issuer2_gvt_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer2_gvt_credential_offer,
+                                                            &issuer2_gvt_credential_req,
+                                                            &gvt2_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //17. Prover Stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL3_ID,
+                            &issuer2_gvt_credential_req_metadata,
+                            &issuer2_gvt_cred,
+                            &issuer2_gvt_credential_def_json,
+                            None).unwrap();
+
+
+    wallet::close_wallet(wallet_handle).unwrap();
+
+    (issuer1_gvt_credential_def_json,
+     issuer1_gvt_credential_offer,
+     issuer1_gvt_credential_req,
+     issuer1_gvt_cred,
+     config)
+}
+
+pub fn init_common_wallet_once() -> (&'static str, &'static str, &'static str, &'static str) {",,2019-04-04 08:07:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/265501873,https://github.com/hyperledger/indy-sdk/pull/1518#discussion_r265501873,jovfer
https://github.com/hyperledger/indy-sdk/pull/1518,https://github.com/hyperledger/indy-sdk/pull/1518,"Problem is that CredentialDefinitions etc are generated without the possibility to NOT store them in a wallet. So they are generated again an again. 
I guess there is nothing we can do - speed things up?
Not sure whether creating one wallet exporting it and importing it into the separate wallets fast enough. Which would leave that one wallet in the indy_home. Maybe data generated during tests should be in the target directory instead of $HOME/.indy_client/ 
I'll look into excluding anoncreds from this PR or ...
I'm open for suggestions. More faster CI/CD servers? Running all the tests locally was never fast...",b511b7cab75da41473733c2592613eac2cccf63e,2019-03-14 12:04:56,265536411,"@@ -454,130 +454,149 @@ pub fn tails_writer_config() -> String {
     json.to_string()
 }
 
-pub fn init_common_wallet() -> (&'static str, &'static str, &'static str, &'static str) {
+pub fn init_anoncreds_wallet(name: &str) -> (String, String, String, String, String) {
+    test::cleanup_storage(name);
+
+    pool::set_protocol_version(PROTOCOL_VERSION).unwrap();
+
+    let config = json!({""id"": name}).to_string();
+
+    //1. Create and Open wallet
+    wallet::create_wallet(&config, WALLET_CREDENTIALS).unwrap();
+    let wallet_handle = wallet::open_wallet(&config, WALLET_CREDENTIALS).unwrap();
+
+    //2. Issuer1 Creates GVT CredentialDefinition
+    let (issuer1_gvt_cred_deg_id, issuer1_gvt_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID,
+                                            &gvt_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //3. Issuer1 Creates XYZ CredentialDefinition
+    let (issuer1_xyz_cred_deg_id, issuer1_xyz_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID,
+                                            &xyz_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //4. Issuer2 Creates GVT CredentialDefinition
+    let (issuer2_gvt_cred_def_id, issuer2_gvt_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID_2,
+                                            &gvt_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //5. Issuer1 Creates GVT CredentialOffer
+    let issuer1_gvt_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer1_gvt_cred_deg_id).unwrap();
+
+    //6. Issuer1 Creates XYZ CredentialOffer
+    let issuer1_xyz_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer1_xyz_cred_deg_id).unwrap();
+
+    //7. Issuer2 Creates GVT CredentialOffer
+    let issuer2_gvt_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer2_gvt_cred_def_id).unwrap();
+
+    //8. Prover creates MasterSecret
+    prover_create_master_secret(wallet_handle, COMMON_MASTER_SECRET).unwrap();
+
+    // Issuer1 issues GVT Credential
+    //9. Prover creates  Credential Request
+    let (issuer1_gvt_credential_req, issuer1_gvt_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer1_gvt_credential_offer,
+                                                                                                         &issuer1_gvt_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+    //10. Issuer1 creates GVT Credential
+    let (issuer1_gvt_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer1_gvt_credential_offer,
+                                                            &issuer1_gvt_credential_req,
+                                                            &gvt_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //11. Prover stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL1_ID,
+                            &issuer1_gvt_credential_req_metadata,
+                            &issuer1_gvt_cred,
+                            &issuer1_gvt_credential_def_json,
+                            None).unwrap();
+
+    // Issuer1 issue XYZ Credential
+    //12. Prover Creates Credential Request
+    let (issuer1_xyz_credential_req, issuer1_xyz_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer1_xyz_credential_offer,
+                                                                                                         &issuer1_xyz_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+    //13. Issuer1 Creates XYZ Credential
+    let (issuer1_xyz_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer1_xyz_credential_offer,
+                                                            &issuer1_xyz_credential_req,
+                                                            &xyz_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //14. Prover stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL2_ID,
+                            &issuer1_xyz_credential_req_metadata,
+                            &issuer1_xyz_cred,
+                            &issuer1_xyz_credential_def_json,
+                            None).unwrap();
+
+    // Issuer2 issues GVT Credential
+    //15. Prover Creates Credential Request
+    let (issuer2_gvt_credential_req, issuer2_gvt_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer2_gvt_credential_offer,
+                                                                                                         &issuer2_gvt_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+
+    //16. Issuer2 Creates XYZ Credential
+    let (issuer2_gvt_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer2_gvt_credential_offer,
+                                                            &issuer2_gvt_credential_req,
+                                                            &gvt2_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //17. Prover Stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL3_ID,
+                            &issuer2_gvt_credential_req_metadata,
+                            &issuer2_gvt_cred,
+                            &issuer2_gvt_credential_def_json,
+                            None).unwrap();
+
+
+    wallet::close_wallet(wallet_handle).unwrap();
+
+    (issuer1_gvt_credential_def_json,
+     issuer1_gvt_credential_offer,
+     issuer1_gvt_credential_req,
+     issuer1_gvt_cred,
+     config)
+}
+
+pub fn init_common_wallet_once() -> (&'static str, &'static str, &'static str, &'static str) {",,2019-04-04 08:07:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/265536411,https://github.com/hyperledger/indy-sdk/pull/1518#discussion_r265536411,AxelNennker
https://github.com/hyperledger/indy-sdk/pull/1518,https://github.com/hyperledger/indy-sdk/pull/1518,I like the idea to try to export smth and re-use it in tests,b511b7cab75da41473733c2592613eac2cccf63e,2019-03-15 15:17:19,266026365,"@@ -454,130 +454,149 @@ pub fn tails_writer_config() -> String {
     json.to_string()
 }
 
-pub fn init_common_wallet() -> (&'static str, &'static str, &'static str, &'static str) {
+pub fn init_anoncreds_wallet(name: &str) -> (String, String, String, String, String) {
+    test::cleanup_storage(name);
+
+    pool::set_protocol_version(PROTOCOL_VERSION).unwrap();
+
+    let config = json!({""id"": name}).to_string();
+
+    //1. Create and Open wallet
+    wallet::create_wallet(&config, WALLET_CREDENTIALS).unwrap();
+    let wallet_handle = wallet::open_wallet(&config, WALLET_CREDENTIALS).unwrap();
+
+    //2. Issuer1 Creates GVT CredentialDefinition
+    let (issuer1_gvt_cred_deg_id, issuer1_gvt_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID,
+                                            &gvt_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //3. Issuer1 Creates XYZ CredentialDefinition
+    let (issuer1_xyz_cred_deg_id, issuer1_xyz_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID,
+                                            &xyz_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //4. Issuer2 Creates GVT CredentialDefinition
+    let (issuer2_gvt_cred_def_id, issuer2_gvt_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID_2,
+                                            &gvt_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //5. Issuer1 Creates GVT CredentialOffer
+    let issuer1_gvt_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer1_gvt_cred_deg_id).unwrap();
+
+    //6. Issuer1 Creates XYZ CredentialOffer
+    let issuer1_xyz_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer1_xyz_cred_deg_id).unwrap();
+
+    //7. Issuer2 Creates GVT CredentialOffer
+    let issuer2_gvt_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer2_gvt_cred_def_id).unwrap();
+
+    //8. Prover creates MasterSecret
+    prover_create_master_secret(wallet_handle, COMMON_MASTER_SECRET).unwrap();
+
+    // Issuer1 issues GVT Credential
+    //9. Prover creates  Credential Request
+    let (issuer1_gvt_credential_req, issuer1_gvt_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer1_gvt_credential_offer,
+                                                                                                         &issuer1_gvt_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+    //10. Issuer1 creates GVT Credential
+    let (issuer1_gvt_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer1_gvt_credential_offer,
+                                                            &issuer1_gvt_credential_req,
+                                                            &gvt_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //11. Prover stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL1_ID,
+                            &issuer1_gvt_credential_req_metadata,
+                            &issuer1_gvt_cred,
+                            &issuer1_gvt_credential_def_json,
+                            None).unwrap();
+
+    // Issuer1 issue XYZ Credential
+    //12. Prover Creates Credential Request
+    let (issuer1_xyz_credential_req, issuer1_xyz_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer1_xyz_credential_offer,
+                                                                                                         &issuer1_xyz_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+    //13. Issuer1 Creates XYZ Credential
+    let (issuer1_xyz_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer1_xyz_credential_offer,
+                                                            &issuer1_xyz_credential_req,
+                                                            &xyz_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //14. Prover stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL2_ID,
+                            &issuer1_xyz_credential_req_metadata,
+                            &issuer1_xyz_cred,
+                            &issuer1_xyz_credential_def_json,
+                            None).unwrap();
+
+    // Issuer2 issues GVT Credential
+    //15. Prover Creates Credential Request
+    let (issuer2_gvt_credential_req, issuer2_gvt_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer2_gvt_credential_offer,
+                                                                                                         &issuer2_gvt_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+
+    //16. Issuer2 Creates XYZ Credential
+    let (issuer2_gvt_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer2_gvt_credential_offer,
+                                                            &issuer2_gvt_credential_req,
+                                                            &gvt2_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //17. Prover Stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL3_ID,
+                            &issuer2_gvt_credential_req_metadata,
+                            &issuer2_gvt_cred,
+                            &issuer2_gvt_credential_def_json,
+                            None).unwrap();
+
+
+    wallet::close_wallet(wallet_handle).unwrap();
+
+    (issuer1_gvt_credential_def_json,
+     issuer1_gvt_credential_offer,
+     issuer1_gvt_credential_req,
+     issuer1_gvt_cred,
+     config)
+}
+
+pub fn init_common_wallet_once() -> (&'static str, &'static str, &'static str, &'static str) {",,2019-04-04 08:07:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/266026365,https://github.com/hyperledger/indy-sdk/pull/1518#discussion_r266026365,jovfer
https://github.com/hyperledger/indy-sdk/pull/1518,https://github.com/hyperledger/indy-sdk/pull/1518,I'll try something. Although the first merge conflicts appeared. Maybe excluding the anoncread changes from this PR gets us forward and fix the anoncreds stuff later. Breaking this up in smaller chunks might be a good idea anyway.,b511b7cab75da41473733c2592613eac2cccf63e,2019-03-15 15:30:02,266032380,"@@ -454,130 +454,149 @@ pub fn tails_writer_config() -> String {
     json.to_string()
 }
 
-pub fn init_common_wallet() -> (&'static str, &'static str, &'static str, &'static str) {
+pub fn init_anoncreds_wallet(name: &str) -> (String, String, String, String, String) {
+    test::cleanup_storage(name);
+
+    pool::set_protocol_version(PROTOCOL_VERSION).unwrap();
+
+    let config = json!({""id"": name}).to_string();
+
+    //1. Create and Open wallet
+    wallet::create_wallet(&config, WALLET_CREDENTIALS).unwrap();
+    let wallet_handle = wallet::open_wallet(&config, WALLET_CREDENTIALS).unwrap();
+
+    //2. Issuer1 Creates GVT CredentialDefinition
+    let (issuer1_gvt_cred_deg_id, issuer1_gvt_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID,
+                                            &gvt_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //3. Issuer1 Creates XYZ CredentialDefinition
+    let (issuer1_xyz_cred_deg_id, issuer1_xyz_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID,
+                                            &xyz_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //4. Issuer2 Creates GVT CredentialDefinition
+    let (issuer2_gvt_cred_def_id, issuer2_gvt_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID_2,
+                                            &gvt_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //5. Issuer1 Creates GVT CredentialOffer
+    let issuer1_gvt_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer1_gvt_cred_deg_id).unwrap();
+
+    //6. Issuer1 Creates XYZ CredentialOffer
+    let issuer1_xyz_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer1_xyz_cred_deg_id).unwrap();
+
+    //7. Issuer2 Creates GVT CredentialOffer
+    let issuer2_gvt_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer2_gvt_cred_def_id).unwrap();
+
+    //8. Prover creates MasterSecret
+    prover_create_master_secret(wallet_handle, COMMON_MASTER_SECRET).unwrap();
+
+    // Issuer1 issues GVT Credential
+    //9. Prover creates  Credential Request
+    let (issuer1_gvt_credential_req, issuer1_gvt_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer1_gvt_credential_offer,
+                                                                                                         &issuer1_gvt_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+    //10. Issuer1 creates GVT Credential
+    let (issuer1_gvt_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer1_gvt_credential_offer,
+                                                            &issuer1_gvt_credential_req,
+                                                            &gvt_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //11. Prover stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL1_ID,
+                            &issuer1_gvt_credential_req_metadata,
+                            &issuer1_gvt_cred,
+                            &issuer1_gvt_credential_def_json,
+                            None).unwrap();
+
+    // Issuer1 issue XYZ Credential
+    //12. Prover Creates Credential Request
+    let (issuer1_xyz_credential_req, issuer1_xyz_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer1_xyz_credential_offer,
+                                                                                                         &issuer1_xyz_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+    //13. Issuer1 Creates XYZ Credential
+    let (issuer1_xyz_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer1_xyz_credential_offer,
+                                                            &issuer1_xyz_credential_req,
+                                                            &xyz_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //14. Prover stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL2_ID,
+                            &issuer1_xyz_credential_req_metadata,
+                            &issuer1_xyz_cred,
+                            &issuer1_xyz_credential_def_json,
+                            None).unwrap();
+
+    // Issuer2 issues GVT Credential
+    //15. Prover Creates Credential Request
+    let (issuer2_gvt_credential_req, issuer2_gvt_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer2_gvt_credential_offer,
+                                                                                                         &issuer2_gvt_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+
+    //16. Issuer2 Creates XYZ Credential
+    let (issuer2_gvt_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer2_gvt_credential_offer,
+                                                            &issuer2_gvt_credential_req,
+                                                            &gvt2_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //17. Prover Stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL3_ID,
+                            &issuer2_gvt_credential_req_metadata,
+                            &issuer2_gvt_cred,
+                            &issuer2_gvt_credential_def_json,
+                            None).unwrap();
+
+
+    wallet::close_wallet(wallet_handle).unwrap();
+
+    (issuer1_gvt_credential_def_json,
+     issuer1_gvt_credential_offer,
+     issuer1_gvt_credential_req,
+     issuer1_gvt_cred,
+     config)
+}
+
+pub fn init_common_wallet_once() -> (&'static str, &'static str, &'static str, &'static str) {",,2019-04-04 08:07:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/266032380,https://github.com/hyperledger/indy-sdk/pull/1518#discussion_r266032380,AxelNennker
https://github.com/hyperledger/indy-sdk/pull/1518,https://github.com/hyperledger/indy-sdk/pull/1518,"@AxelNennker it's up to you. To accept this PR I see 2 options right now:
1) implement importing wallet for anoncreds tests
2) exclude changes around shared wallet for anoncreds from this PR",b511b7cab75da41473733c2592613eac2cccf63e,2019-03-18 15:15:28,266491335,"@@ -454,130 +454,149 @@ pub fn tails_writer_config() -> String {
     json.to_string()
 }
 
-pub fn init_common_wallet() -> (&'static str, &'static str, &'static str, &'static str) {
+pub fn init_anoncreds_wallet(name: &str) -> (String, String, String, String, String) {
+    test::cleanup_storage(name);
+
+    pool::set_protocol_version(PROTOCOL_VERSION).unwrap();
+
+    let config = json!({""id"": name}).to_string();
+
+    //1. Create and Open wallet
+    wallet::create_wallet(&config, WALLET_CREDENTIALS).unwrap();
+    let wallet_handle = wallet::open_wallet(&config, WALLET_CREDENTIALS).unwrap();
+
+    //2. Issuer1 Creates GVT CredentialDefinition
+    let (issuer1_gvt_cred_deg_id, issuer1_gvt_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID,
+                                            &gvt_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //3. Issuer1 Creates XYZ CredentialDefinition
+    let (issuer1_xyz_cred_deg_id, issuer1_xyz_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID,
+                                            &xyz_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //4. Issuer2 Creates GVT CredentialDefinition
+    let (issuer2_gvt_cred_def_id, issuer2_gvt_credential_def_json) =
+        issuer_create_credential_definition(wallet_handle,
+                                            ISSUER_DID_2,
+                                            &gvt_schema_json(),
+                                            TAG_1,
+                                            None,
+                                            Some(&default_cred_def_config())).unwrap();
+
+    //5. Issuer1 Creates GVT CredentialOffer
+    let issuer1_gvt_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer1_gvt_cred_deg_id).unwrap();
+
+    //6. Issuer1 Creates XYZ CredentialOffer
+    let issuer1_xyz_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer1_xyz_cred_deg_id).unwrap();
+
+    //7. Issuer2 Creates GVT CredentialOffer
+    let issuer2_gvt_credential_offer = issuer_create_credential_offer(wallet_handle, &issuer2_gvt_cred_def_id).unwrap();
+
+    //8. Prover creates MasterSecret
+    prover_create_master_secret(wallet_handle, COMMON_MASTER_SECRET).unwrap();
+
+    // Issuer1 issues GVT Credential
+    //9. Prover creates  Credential Request
+    let (issuer1_gvt_credential_req, issuer1_gvt_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer1_gvt_credential_offer,
+                                                                                                         &issuer1_gvt_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+    //10. Issuer1 creates GVT Credential
+    let (issuer1_gvt_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer1_gvt_credential_offer,
+                                                            &issuer1_gvt_credential_req,
+                                                            &gvt_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //11. Prover stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL1_ID,
+                            &issuer1_gvt_credential_req_metadata,
+                            &issuer1_gvt_cred,
+                            &issuer1_gvt_credential_def_json,
+                            None).unwrap();
+
+    // Issuer1 issue XYZ Credential
+    //12. Prover Creates Credential Request
+    let (issuer1_xyz_credential_req, issuer1_xyz_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer1_xyz_credential_offer,
+                                                                                                         &issuer1_xyz_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+    //13. Issuer1 Creates XYZ Credential
+    let (issuer1_xyz_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer1_xyz_credential_offer,
+                                                            &issuer1_xyz_credential_req,
+                                                            &xyz_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //14. Prover stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL2_ID,
+                            &issuer1_xyz_credential_req_metadata,
+                            &issuer1_xyz_cred,
+                            &issuer1_xyz_credential_def_json,
+                            None).unwrap();
+
+    // Issuer2 issues GVT Credential
+    //15. Prover Creates Credential Request
+    let (issuer2_gvt_credential_req, issuer2_gvt_credential_req_metadata) = prover_create_credential_req(wallet_handle,
+                                                                                                         DID_MY1,
+                                                                                                         &issuer2_gvt_credential_offer,
+                                                                                                         &issuer2_gvt_credential_def_json,
+                                                                                                         COMMON_MASTER_SECRET).unwrap();
+
+    //16. Issuer2 Creates XYZ Credential
+    let (issuer2_gvt_cred, _, _) = issuer_create_credential(wallet_handle,
+                                                            &issuer2_gvt_credential_offer,
+                                                            &issuer2_gvt_credential_req,
+                                                            &gvt2_credential_values_json(),
+                                                            None,
+                                                            None).unwrap();
+
+    //17. Prover Stores Credential
+    prover_store_credential(wallet_handle,
+                            CREDENTIAL3_ID,
+                            &issuer2_gvt_credential_req_metadata,
+                            &issuer2_gvt_cred,
+                            &issuer2_gvt_credential_def_json,
+                            None).unwrap();
+
+
+    wallet::close_wallet(wallet_handle).unwrap();
+
+    (issuer1_gvt_credential_def_json,
+     issuer1_gvt_credential_offer,
+     issuer1_gvt_credential_req,
+     issuer1_gvt_cred,
+     config)
+}
+
+pub fn init_common_wallet_once() -> (&'static str, &'static str, &'static str, &'static str) {",,2019-04-04 08:07:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/266491335,https://github.com/hyperledger/indy-sdk/pull/1518#discussion_r266491335,jovfer
https://github.com/hyperledger/indy-sdk/pull/1511,https://github.com/hyperledger/indy-sdk/pull/1511,move to demoCommon,5847a924a33f0916f0ef680fd381d22501483b1e,2019-03-07 11:11:00,263336558,"@@ -0,0 +1,91 @@
+import {DisclosedProof} from ""../dist/src/api/disclosed-proof"";
+import {Connection} from ""../dist/src/api/connection"";
+import {Credential} from ""../dist/src/api/credential"";
+import {StateType} from ""../dist/src"";
+import readlineSync from 'readline-sync'
+import sleepPromise from 'sleep-promise'
+import * as demoCommon from './common'
+
+function getRandomInt(min, max) {",,2019-03-13 10:11:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263336558,https://github.com/hyperledger/indy-sdk/pull/1511#discussion_r263336558,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1511,https://github.com/hyperledger/indy-sdk/pull/1511,pool genesis transactions file is missed,5847a924a33f0916f0ef680fd381d22501483b1e,2019-03-07 12:26:20,263359922,"@@ -33,3 +33,21 @@ npm run doc-gen
 ```
 * A directory will be created locally `./docs` which contains an `index.html` file which can be used to navigate the generated documents.
 
+## Run Demo
+- Install dependencies 
+```
+npm install
+```
+- Compile vcx wrapper
+```
+npm compile
+```
+- Start [Dummy Cloud Agent](../../dummy-cloud-agent)
+- Run Faber agent, representing an institution
+```
+npm run demo:faber
+```
+- Give it a few seconds, then run Alice's agent which will connect with Faber's agent
+```
+npm run demo:alice
+```",51,2019-03-13 10:11:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263359922,https://github.com/hyperledger/indy-sdk/pull/1511#discussion_r263359922,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1511,https://github.com/hyperledger/indy-sdk/pull/1511,reflect that payment plugin is necessary,5847a924a33f0916f0ef680fd381d22501483b1e,2019-03-07 12:28:25,263360572,"@@ -33,3 +33,21 @@ npm run doc-gen
 ```
 * A directory will be created locally `./docs` which contains an `index.html` file which can be used to navigate the generated documents.
 
+## Run Demo
+- Install dependencies 
+```
+npm install
+```
+- Compile vcx wrapper
+```
+npm compile
+```
+- Start [Dummy Cloud Agent](../../dummy-cloud-agent)
+- Run Faber agent, representing an institution
+```
+npm run demo:faber
+```
+- Give it a few seconds, then run Alice's agent which will connect with Faber's agent
+```
+npm run demo:alice
+```",51,2019-03-13 10:11:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263360572,https://github.com/hyperledger/indy-sdk/pull/1511#discussion_r263360572,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1511,https://github.com/hyperledger/indy-sdk/pull/1511,"I've added more documentation now, including mention of libnullpay.",5847a924a33f0916f0ef680fd381d22501483b1e,2019-03-07 17:51:25,263496683,"@@ -33,3 +33,21 @@ npm run doc-gen
 ```
 * A directory will be created locally `./docs` which contains an `index.html` file which can be used to navigate the generated documents.
 
+## Run Demo
+- Install dependencies 
+```
+npm install
+```
+- Compile vcx wrapper
+```
+npm compile
+```
+- Start [Dummy Cloud Agent](../../dummy-cloud-agent)
+- Run Faber agent, representing an institution
+```
+npm run demo:faber
+```
+- Give it a few seconds, then run Alice's agent which will connect with Faber's agent
+```
+npm run demo:alice
+```",51,2019-03-13 10:11:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263496683,https://github.com/hyperledger/indy-sdk/pull/1511#discussion_r263496683,Patrik-Stas
https://github.com/hyperledger/indy-sdk/pull/1507,https://github.com/hyperledger/indy-sdk/pull/1507,should we also send status to awaiting requests?,d629fbe75c219e78b2e1e75b3fad7289bec9137e,2019-02-28 20:23:48,261368587,"@@ -335,7 +335,12 @@ impl<T: Networker> RequestSM<T> {
                                 (RequestState::finish(), None)
                             }
                         } else {
-                            (RequestState::Consensus(state), None)
+                            state.denied_nodes.insert(node_alias.clone());
+                            if state.denied_nodes.len() + state.replies.len() == nodes.len() {",15,2019-03-04 09:36:19,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/261368587,https://github.com/hyperledger/indy-sdk/pull/1507#discussion_r261368587,jovfer
https://github.com/hyperledger/indy-sdk/pull/1505,https://github.com/hyperledger/indy-sdk/pull/1505,if we decide to drop cache in case of catchup failure we probably have to drop it on timeout (few lines above),2e9e0530db20257aff73a9c94e5685f42d774a9d,2019-02-28 20:27:34,261369822,"@@ -71,8 +72,13 @@ pub fn check_nodes_responses_on_status(nodes_votes: &HashMap<(String, usize, Opt
             let positive_votes_cnt = votes_cnt + (node_cnt - reps_cnt);
             let is_consensus_reachable = positive_votes_cnt < node_cnt - f;
             if is_consensus_reachable {
-                //TODO: maybe we should change the error, but it was made to escape changing of ErrorCode returned to client
-                return Err(err_msg(IndyErrorKind::PoolTimeout, ""No consensus possible""));
+                if merkle_tree_factory::drop_cache(pool_name).is_ok() {",,2019-03-13 12:34:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/261369822,https://github.com/hyperledger/indy-sdk/pull/1505#discussion_r261369822,jovfer
https://github.com/hyperledger/indy-sdk/pull/1505,https://github.com/hyperledger/indy-sdk/pull/1505,else branch should cover case when consensus not possible,2e9e0530db20257aff73a9c94e5685f42d774a9d,2019-03-07 13:22:55,263378568,"@@ -52,41 +52,50 @@ pub fn check_nodes_responses_on_status(nodes_votes: &HashMap<(String, usize, Opt
                                        node_cnt: usize,
                                        f: usize,
                                        pool_name: &str) -> IndyResult<CatchupProgress> {
-    //FIXME fetch not just most popular vote but most popular not a timeout
-    if let Some((most_popular_vote, votes_cnt)) = nodes_votes.iter().map(|(key, val)| (key, val.len())).max_by_key(|entry| entry.1) {
-        let is_consensus_reached =
-            votes_cnt == node_cnt - f
-                || votes_cnt == f + 1 && most_popular_vote.0.neq(""timeout"");
-        if is_consensus_reached {
-            if most_popular_vote.0.eq(""timeout"") {
-                return _try_to_restart_catch_up(pool_name, err_msg(IndyErrorKind::PoolTimeout, ""Pool timeout""))
-            }
-
-            return _try_to_catch_up(most_popular_vote, merkle_tree).or_else(|err| {
+    let (votes, timeout_votes): (HashMap<&(String, usize, Option<Vec<String>>), usize>, HashMap<&(String, usize, Option<Vec<String>>), usize>) =
+        nodes_votes
+            .iter()
+            .map(|(key, val)| (key, val.len()))
+            .partition(|((key, _, _), _)| key != ""timeout"");
+
+    let most_popular_not_timeout =
+        votes
+            .iter()
+            .max_by_key(|entry| entry.1);
+
+    let timeout_votes = timeout_votes.iter().last();
+
+    if let Some((most_popular_not_timeout_vote, vote_cnt)) = most_popular_not_timeout {
+        if *vote_cnt == f + 1 {",,2019-03-13 12:34:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263378568,https://github.com/hyperledger/indy-sdk/pull/1505#discussion_r263378568,jovfer
https://github.com/hyperledger/indy-sdk/pull/1495,https://github.com/hyperledger/indy-sdk/pull/1495,please use variables instead of fixed parameters where it's possible,147b5649d1547177f20ce0d0d7987a81370146e0,2019-02-26 16:56:04,260385174,"@@ -38,12 +38,10 @@ build_test_artifacts(){
         cargo clean
 
         # TODO empty for full testing SET_OF_TESTS=''
-        SET_OF_TESTS='--lib --test interaction'
+        SET_OF_TESTS='--test interaction'
 
-        # build - separate step to see origin build output
-        # TODO move RUSTFLAGS to cargo config and do not duplicate it here
         RUSTFLAGS=""-L${TOOLCHAIN_DIR}/sysroot/usr/${TOOLCHAIN_SYSROOT_LIB} -lc -lz -L${TOOLCHAIN_DIR}/${TRIPLET}/lib -L${LIBZMQ_LIB_DIR} -L${SODIUM_LIB_DIR} -lsodium -lzmq -lgnustl_shared"" \
-                    cargo test ${BUILD_TYPE} --target=${TRIPLET} ${SET_OF_TESTS} --no-run
+            cargo build --release --target=${TRIPLET}",,2019-02-28 21:24:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/260385174,https://github.com/hyperledger/indy-sdk/pull/1495#discussion_r260385174,jovfer
https://github.com/hyperledger/indy-sdk/pull/1495,https://github.com/hyperledger/indy-sdk/pull/1495,is this line required because we drop unit tests from the CI scope?,147b5649d1547177f20ce0d0d7987a81370146e0,2019-02-26 16:57:11,260385709,"@@ -73,6 +71,9 @@ execute_on_device(){
     adb -e push \
     ""${LIBZMQ_LIB_DIR}/libzmq.so"" ""/data/local/tmp/libzmq.so""
 
+    adb -e push \",21,2019-02-28 21:24:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/260385709,https://github.com/hyperledger/indy-sdk/pull/1495#discussion_r260385709,jovfer
https://github.com/hyperledger/indy-sdk/pull/1495,https://github.com/hyperledger/indy-sdk/pull/1495,Changed already,147b5649d1547177f20ce0d0d7987a81370146e0,2019-02-27 07:33:07,260621661,"@@ -38,12 +38,10 @@ build_test_artifacts(){
         cargo clean
 
         # TODO empty for full testing SET_OF_TESTS=''
-        SET_OF_TESTS='--lib --test interaction'
+        SET_OF_TESTS='--test interaction'
 
-        # build - separate step to see origin build output
-        # TODO move RUSTFLAGS to cargo config and do not duplicate it here
         RUSTFLAGS=""-L${TOOLCHAIN_DIR}/sysroot/usr/${TOOLCHAIN_SYSROOT_LIB} -lc -lz -L${TOOLCHAIN_DIR}/${TRIPLET}/lib -L${LIBZMQ_LIB_DIR} -L${SODIUM_LIB_DIR} -lsodium -lzmq -lgnustl_shared"" \
-                    cargo test ${BUILD_TYPE} --target=${TRIPLET} ${SET_OF_TESTS} --no-run
+            cargo build --release --target=${TRIPLET}",,2019-02-28 21:24:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/260621661,https://github.com/hyperledger/indy-sdk/pull/1495#discussion_r260621661,KitHat
https://github.com/hyperledger/indy-sdk/pull/1495,https://github.com/hyperledger/indy-sdk/pull/1495,Yep. Libindy is not compiled into any more.,147b5649d1547177f20ce0d0d7987a81370146e0,2019-02-27 07:41:31,260623453,"@@ -73,6 +71,9 @@ execute_on_device(){
     adb -e push \
     ""${LIBZMQ_LIB_DIR}/libzmq.so"" ""/data/local/tmp/libzmq.so""
 
+    adb -e push \",21,2019-02-28 21:24:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/260623453,https://github.com/hyperledger/indy-sdk/pull/1495#discussion_r260623453,KitHat
https://github.com/hyperledger/indy-sdk/pull/1495,https://github.com/hyperledger/indy-sdk/pull/1495,it's important to keep 2 steps: the first one for full build of tests and the second one for parsing tests to running,147b5649d1547177f20ce0d0d7987a81370146e0,2019-02-27 16:25:50,260830182,"@@ -40,10 +40,8 @@ build_test_artifacts(){
         # TODO empty for full testing SET_OF_TESTS=''
         SET_OF_TESTS='--lib --test interaction'
 
-        # build - separate step to see origin build output
-        # TODO move RUSTFLAGS to cargo config and do not duplicate it here
         RUSTFLAGS=""-L${TOOLCHAIN_DIR}/sysroot/usr/${TOOLCHAIN_SYSROOT_LIB} -lc -lz -L${TOOLCHAIN_DIR}/${TRIPLET}/lib -L${LIBZMQ_LIB_DIR} -L${SODIUM_LIB_DIR} -lsodium -lzmq -lgnustl_shared"" \
-                    cargo test ${BUILD_TYPE} --target=${TRIPLET} ${SET_OF_TESTS} --no-run
+            cargo build ${BUILD_TYPE} --target=${TRIPLET}",8,2019-02-28 21:24:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/260830182,https://github.com/hyperledger/indy-sdk/pull/1495#discussion_r260830182,jovfer
https://github.com/hyperledger/indy-sdk/pull/1489,https://github.com/hyperledger/indy-sdk/pull/1489,add `path_temp()` function to utils module to save platform compatibility,31fbea41a381f09dd26a0e4d244f926e067ddf1e,2019-03-13 11:43:44,265087224,"@@ -415,8 +416,34 @@ The same way **Acme** creates and publishes a **Credential Definition** for the
   await ledger.sign_and_submit_request(acme['pool'], acme['wallet'], acme['did'], cred_def_request)
 ```
 
-At this point we have a **Credential Definition** for the **Job-Certificate** Credential Schema published by **Acme** and a
- **Credential Definition** for the **Transcript** Credential Schema published by **Faber**.
+**Acme** anticipates revoking **Job-Certificate* credentials. It decides to create a revocation registry. One of Hyperledger Indy's revocation registry types uses cryptographic accumulators for publishing revoked credentials. For details about the inner working of those accumulators see [here](https://github.com/fabienpe/indy-sdk/blob/master/docs/concepts/revocation/cred-revocation.md)). The use of those accumulators requires the publication of ""validity tails"" outside of the Ledger. For the purpose of this demo, the validity tails are written in a file using a 'blob storage'. 
+
+```python
+    # Acme Agent
+    acme['tails_writer_config'] = json.dumps({'base_dir': ""/tmp/indy_acme_tails"", 'uri_pattern': ''})",27,2019-03-14 09:50:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/265087224,https://github.com/hyperledger/indy-sdk/pull/1489#discussion_r265087224,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1489,https://github.com/hyperledger/indy-sdk/pull/1489,"add 'revoc_reg_config':{'max_cred_num': 5, 'issuance_type': 'ISSUANCE_ON_DEMAND'} to acme dictionary",31fbea41a381f09dd26a0e4d244f926e067ddf1e,2019-03-13 11:45:09,265087638,"@@ -415,8 +416,34 @@ The same way **Acme** creates and publishes a **Credential Definition** for the
   await ledger.sign_and_submit_request(acme['pool'], acme['wallet'], acme['did'], cred_def_request)
 ```
 
-At this point we have a **Credential Definition** for the **Job-Certificate** Credential Schema published by **Acme** and a
- **Credential Definition** for the **Transcript** Credential Schema published by **Faber**.
+**Acme** anticipates revoking **Job-Certificate* credentials. It decides to create a revocation registry. One of Hyperledger Indy's revocation registry types uses cryptographic accumulators for publishing revoked credentials. For details about the inner working of those accumulators see [here](https://github.com/fabienpe/indy-sdk/blob/master/docs/concepts/revocation/cred-revocation.md)). The use of those accumulators requires the publication of ""validity tails"" outside of the Ledger. For the purpose of this demo, the validity tails are written in a file using a 'blob storage'. 
+
+```python
+    # Acme Agent
+    acme['tails_writer_config'] = json.dumps({'base_dir': ""/tmp/indy_acme_tails"", 'uri_pattern': ''})
+    tails_writer = await blob_storage.open_writer('default', acme['tails_writer_config'])
+```
+Once the validity tails are configured, **Acme** can create a new revocation registry for the given credential definition.
+
+```python
+    # Acme Agent
+    (acme['revoc_reg_id'], acme['revoc_reg_def'], acme['revoc_reg_entry']) = \
+        await anoncreds.issuer_create_and_store_revoc_reg(acme['wallet'], acme['did'], 'CL_ACCUM', 'TAG1',
+                                                          acme['job_certificate_cred_def_id'],
+                                                          json.dumps({'max_cred_num': 5,
+                                                                      'issuance_type': 'ISSUANCE_ON_DEMAND'}),
+                                                          tails_writer)",39,2019-03-14 09:50:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/265087638,https://github.com/hyperledger/indy-sdk/pull/1489#discussion_r265087638,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1489,https://github.com/hyperledger/indy-sdk/pull/1489,typo `ussuance`,31fbea41a381f09dd26a0e4d244f926e067ddf1e,2019-03-13 12:09:32,265095389,"@@ -711,16 +738,49 @@ Alice goes through a familiar sequence of interactions.
       ""salary"": {""raw"": ""2400"", ""encoded"": ""2400""},
       ""experience"": {""raw"": ""10"", ""encoded"": ""10""}
   })
-  job_certificate_cred_json, _, _ = \
-      await anoncreds.issuer_create_credential(acme['wallet'], acme['job_certificate_cred_offer'],acme['job_certificate_cred_request'],
-                                               alice_job_certificate_cred_values_json, None, None)
+```
+
+One difference with the ussuance of the Transcript by Faber here is that a **Job-Certificate** can be revoked and the credential creation takes the ID of the revocation registry created earlier by **Acme** and a handle to the blob storage containing the validity tails:",81,2019-03-14 09:50:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/265095389,https://github.com/hyperledger/indy-sdk/pull/1489#discussion_r265095389,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1489,https://github.com/hyperledger/indy-sdk/pull/1489,add registry_type field 'CL_ACCUM' to acme dictionary,31fbea41a381f09dd26a0e4d244f926e067ddf1e,2019-03-13 12:10:49,265095880,"@@ -711,16 +738,49 @@ Alice goes through a familiar sequence of interactions.
       ""salary"": {""raw"": ""2400"", ""encoded"": ""2400""},
       ""experience"": {""raw"": ""10"", ""encoded"": ""10""}
   })
-  job_certificate_cred_json, _, _ = \
-      await anoncreds.issuer_create_credential(acme['wallet'], acme['job_certificate_cred_offer'],acme['job_certificate_cred_request'],
-                                               alice_job_certificate_cred_values_json, None, None)
+```
+
+One difference with the ussuance of the Transcript by Faber here is that a **Job-Certificate** can be revoked and the credential creation takes the ID of the revocation registry created earlier by **Acme** and a handle to the blob storage containing the validity tails:
+
+
+```python
+    # Acme Agent
+    acme['blob_storage_reader_cfg_handle'] = await blob_storage.open_reader('default', acme['tails_writer_config'])
+    acme['job_certificate_cred'], acme['job_certificate_cred_rev_id'], acme['alice_cert_rev_reg_delta'] = \
+        await anoncreds.issuer_create_credential(acme['wallet'], acme['job_certificate_cred_offer'],
+                                                 acme['job_certificate_cred_request'],
+                                                 acme['job_certificate_cred_values'],
+                                                 acme['revoc_reg_id'],
+                                                 acme['blob_storage_reader_cfg_handle'])
+```
+
+Furthermore **Acme** must publish a revocation registry entry on the Ledger so other parties can verify later the revocation state of the credential.
+
+```python
+    # Acme agent
+    acme['revoc_reg_entry_req'] = \
+        await ledger.build_revoc_reg_entry_request(acme['did'], acme['revoc_reg_id'], 'CL_ACCUM',",100,2019-03-14 09:50:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/265095880,https://github.com/hyperledger/indy-sdk/pull/1489#discussion_r265095880,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1488,https://github.com/hyperledger/indy-sdk/pull/1488,I suggest to use env variables instead of moving artifacts to system directories,e00514a3de00496c2ab2152bf416d44fdb788cbf,2019-02-25 19:52:56,259991325,"@@ -0,0 +1,39 @@
+current_dir=$(pwd)
+source ~/.profile
+
+echo ""######Building LIBVCX######""
+cd ../../../libvcx
+cargo build
+echo $(pwd)
+
+echo ""#####Building LibIndy#####""
+cd ../../libindy
+cargo build
+echo $(pwd)
+
+echo ""#####Building LibNullPay####""
+cd ../libnullpay
+cargo build
+echo $(pwd)
+
+echo ""####Building VCX JAR#####""
+echo $current_dir
+cd $current_dir
+cd ..
+./gradlew build
+
+cd $current_dir
+
+
+
+if [[ ""$OSTYPE"" == ""linux-gnu"" ]]; then
+        sudo cp ../../../libvcx/target/debug/libvcx.so /usr/lib/libvcx.so",30,2019-03-18 19:59:46,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/259991325,https://github.com/hyperledger/indy-sdk/pull/1488#discussion_r259991325,jovfer
https://github.com/hyperledger/indy-sdk/pull/1488,https://github.com/hyperledger/indy-sdk/pull/1488,which env variable I should use?,e00514a3de00496c2ab2152bf416d44fdb788cbf,2019-03-08 02:28:24,263646778,"@@ -0,0 +1,39 @@
+current_dir=$(pwd)
+source ~/.profile
+
+echo ""######Building LIBVCX######""
+cd ../../../libvcx
+cargo build
+echo $(pwd)
+
+echo ""#####Building LibIndy#####""
+cd ../../libindy
+cargo build
+echo $(pwd)
+
+echo ""#####Building LibNullPay####""
+cd ../libnullpay
+cargo build
+echo $(pwd)
+
+echo ""####Building VCX JAR#####""
+echo $current_dir
+cd $current_dir
+cd ..
+./gradlew build
+
+cd $current_dir
+
+
+
+if [[ ""$OSTYPE"" == ""linux-gnu"" ]]; then
+        sudo cp ../../../libvcx/target/debug/libvcx.so /usr/lib/libvcx.so",30,2019-03-18 19:59:46,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263646778,https://github.com/hyperledger/indy-sdk/pull/1488#discussion_r263646778,nehalshah50
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,"Not only ""for this edge device"" but for any edge device of this relationship.",a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-04 14:07:48,262071532,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device",22,2019-03-04 14:07:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262071532,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262071532,lovesh
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,Replace `who is authenticated` with `who is authorized`,a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-04 14:16:46,262075229,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update",44,2019-03-04 14:16:46,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262075229,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262075229,lovesh
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,"I think you mean `not authorized` by `not authenticated`. How can a device not authorized to update still update? Do you mean updating itself? Each device should be able to update itslef without requiring any other device. Or do you mean in case of public ledger where writes are restricted with fees/rights, etc",a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-04 14:18:43,262076035,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update",48,2019-03-04 14:26:33,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262076035,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262076035,lovesh
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,In case of microledger?,a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-04 15:11:28,262099650,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.",76,2019-03-04 15:11:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262099650,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262099650,lovesh
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,Missing ending parenthesis,a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-04 15:14:42,262101252,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.
+    - Local DID Doc copy is never updated explicitly.
+    - If a change to DID Doc is needed, the corresponding txn is created and sent to the Ledger.
+    - Different policies can be supported for updating the current DID DOC copy:
+      - The default one may just go to the Ledger every time before accessing the DID/DIDDoc. For example, if edge wants
+        to pack a message, it goes to the Ledger, gets the latest DID Doc, updates the local copy, and uses the local copy
+        for packing.
+      - Other policies may update it by timeout, or update by getting notifications from the Ledger/microledger
+3. In communication between Agents:
+    - DID Doc is never passed from one Agent (Alice) to another (Bob)
+    - DID is the only thing which is passed
+    - The receiver resolves the DID looking at the did method and going to the corresponding ledger (public or micro)
+    - This will allow communication between old agents (not supporting DID Doc) and new ones using the new approach
+4. The Ledger level is opaque. It doesn’t matter if this is public or micro ledger. Exact publishing and resolving strategy are
+   defined by a pluggable Resolvers and doesn’t affect workflows.
+5. To support DID Doc new transactions will be added to Indy Ledger:
+    - DID_DOC
+      - Consists of `did` and `doc`
+      - The ‘doc’ fields is a map of the form {field_id -> field} where field_id is a unique identifier of a field in the doc, and field is one of the fields (either array or a single-value)
+      - The following fields will be there (see [sovrin-did-method](https://sovrin-foundation.github.io/sovrin/spec/did-method-spec-template.html#sovrin-did-method):",95,2019-03-04 15:14:42,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262101252,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262101252,lovesh
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,So no nesting? I mean `field` with mapping type.,a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-04 15:14:59,262101388,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.
+    - Local DID Doc copy is never updated explicitly.
+    - If a change to DID Doc is needed, the corresponding txn is created and sent to the Ledger.
+    - Different policies can be supported for updating the current DID DOC copy:
+      - The default one may just go to the Ledger every time before accessing the DID/DIDDoc. For example, if edge wants
+        to pack a message, it goes to the Ledger, gets the latest DID Doc, updates the local copy, and uses the local copy
+        for packing.
+      - Other policies may update it by timeout, or update by getting notifications from the Ledger/microledger
+3. In communication between Agents:
+    - DID Doc is never passed from one Agent (Alice) to another (Bob)
+    - DID is the only thing which is passed
+    - The receiver resolves the DID looking at the did method and going to the corresponding ledger (public or micro)
+    - This will allow communication between old agents (not supporting DID Doc) and new ones using the new approach
+4. The Ledger level is opaque. It doesn’t matter if this is public or micro ledger. Exact publishing and resolving strategy are
+   defined by a pluggable Resolvers and doesn’t affect workflows.
+5. To support DID Doc new transactions will be added to Indy Ledger:
+    - DID_DOC
+      - Consists of `did` and `doc`
+      - The ‘doc’ fields is a map of the form {field_id -> field} where field_id is a unique identifier of a field in the doc, and field is one of the fields (either array or a single-value)",94,2019-03-04 15:37:18,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262101388,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262101388,lovesh
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,When is this method needed alone? Why can't it have functionlity of `indy_create_did_key`?,a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-04 15:58:34,262123477,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.
+    - Local DID Doc copy is never updated explicitly.
+    - If a change to DID Doc is needed, the corresponding txn is created and sent to the Ledger.
+    - Different policies can be supported for updating the current DID DOC copy:
+      - The default one may just go to the Ledger every time before accessing the DID/DIDDoc. For example, if edge wants
+        to pack a message, it goes to the Ledger, gets the latest DID Doc, updates the local copy, and uses the local copy
+        for packing.
+      - Other policies may update it by timeout, or update by getting notifications from the Ledger/microledger
+3. In communication between Agents:
+    - DID Doc is never passed from one Agent (Alice) to another (Bob)
+    - DID is the only thing which is passed
+    - The receiver resolves the DID looking at the did method and going to the corresponding ledger (public or micro)
+    - This will allow communication between old agents (not supporting DID Doc) and new ones using the new approach
+4. The Ledger level is opaque. It doesn’t matter if this is public or micro ledger. Exact publishing and resolving strategy are
+   defined by a pluggable Resolvers and doesn’t affect workflows.
+5. To support DID Doc new transactions will be added to Indy Ledger:
+    - DID_DOC
+      - Consists of `did` and `doc`
+      - The ‘doc’ fields is a map of the form {field_id -> field} where field_id is a unique identifier of a field in the doc, and field is one of the fields (either array or a single-value)
+      - The following fields will be there (see [sovrin-did-method](https://sovrin-foundation.github.io/sovrin/spec/did-method-spec-template.html#sovrin-did-method):
+         - Public keys
+         - Services
+         - Authentication
+         - etc.
+    - DID_DOC_DELTA
+       - An array of the following values:
+       - Field_id
+       - Operation (ADD/REMOVE/EDIT)
+       - New value (or id of removed value)
+6. DID DOC Updates
+    - Will be done incrementally as requests to the Ledger via DID DOC Deltas
+    - Ledger will be responsible for validation (authentication and authorizations checks) and merging the incremental updates (DID DOC Deltas) to the DID DOC state
+7. Support of multiple did methods
+    - Will be done via Resolvers that can be registered by applications
+    - There will be default resolver for 'peer' (microledger based) method
+    - There will be out-of-the-box support of methods based on Indy ledgers with minumum configuration (SLN, STN and etc...)
+8. Publishing existing DID/DID DOC to another Ledger/microledger
+    - Will be done via explicit export method
+9. Procedure that performs resolving DID will fallback to old wallet structure to allow using existing crypto materials with the new approach
+10. The old (current) DID API will be deprecated
+11. The new DID API will be created to allow:
+     - Registering of DID methods
+     - Creation of DIDs
+     - Building of DID Docs and DID Doc deltas with builder pattern
+     - Publishing of DID Doc and DID Doc deltas
+     - Resolving of DID Docs
+
+## Libindy API
+
+### DID resolver configuration
+
+#### Create DID Resolver instance
+
+```Rust
+// Create DID resolver instance
+//
+// By default supports peer method only. To support additional did methods
+// indy_register_indy_did_method or indy_register_did_method can be called.
+//
+// options: - some options like cache policies
+// returns - did_resolver_handle: handler ot DID Resolver instance
+pub fn indy_create_did_resolver(options) -> Future<did_resolver_handle>
+```
+
+#### Register did method based on Indy pool with did resolver
+
+```Rust
+// Register did method based on Indy pool with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'sov'
+// pool_handle: pool_handle
+// options: some options
+// returns - ()
+pub fn indy_register_indy_did_method(did_resolver_handle,
+                                     method,
+                                     pool_handle,
+                                     options) -> Future<()>
+```
+
+#### Register custom did method with did resolver
+
+```Rust
+// Register custom did method with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'custom'
+// ..callbacks: list of callbacks that define method behaviour
+// options: some options
+// returns - ()
+pub fn indy_register_did_method(did_resolver_handle,
+                                method,
+                                ..callbacks,
+                                options) -> Future<()>
+```
+
+#### Close did resolver and releases all related resources
+
+```Rust
+// Close did resolver and releases all related resources.
+//
+// did_resolver_handle: resolver handle
+// returns - ()
+pub fn indy_close_did_resolver(did_resolver_handle) -> Future<()>
+```
+
+### Resolving DID Doc
+
+#### Resolve DID Doc for DID
+
+```Rust
+// Resolve DID Doc for DID.
+//
+// did_resolver_handle: resolver handle
+// did: did to resolve
+// options: some options, like cache behaviour
+// returns - did_doc: resolved DID Doc
+pub fn indy_resolve_did_doc(did_resolver_handle,
+                            did,
+                            options) -> Future<did_doc>
+```
+
+### DID and DID keys creation
+
+#### Creates a new DID
+
+```Rust
+// Create a new DID.
+//
+// Note: It doesn't create any records in the wallet.
+//
+// did_resolver_handle: resolver handle
+// method: did method to use
+// options: some options
+// returns - did: Generated DID
+pub fn indy_create_did(did_resolver_handle,",211,2019-03-04 15:58:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262123477,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262123477,lovesh
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,How is the current DID tracked? Is there a way to query such state management?,a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-04 16:00:36,262124509,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.
+    - Local DID Doc copy is never updated explicitly.
+    - If a change to DID Doc is needed, the corresponding txn is created and sent to the Ledger.
+    - Different policies can be supported for updating the current DID DOC copy:
+      - The default one may just go to the Ledger every time before accessing the DID/DIDDoc. For example, if edge wants
+        to pack a message, it goes to the Ledger, gets the latest DID Doc, updates the local copy, and uses the local copy
+        for packing.
+      - Other policies may update it by timeout, or update by getting notifications from the Ledger/microledger
+3. In communication between Agents:
+    - DID Doc is never passed from one Agent (Alice) to another (Bob)
+    - DID is the only thing which is passed
+    - The receiver resolves the DID looking at the did method and going to the corresponding ledger (public or micro)
+    - This will allow communication between old agents (not supporting DID Doc) and new ones using the new approach
+4. The Ledger level is opaque. It doesn’t matter if this is public or micro ledger. Exact publishing and resolving strategy are
+   defined by a pluggable Resolvers and doesn’t affect workflows.
+5. To support DID Doc new transactions will be added to Indy Ledger:
+    - DID_DOC
+      - Consists of `did` and `doc`
+      - The ‘doc’ fields is a map of the form {field_id -> field} where field_id is a unique identifier of a field in the doc, and field is one of the fields (either array or a single-value)
+      - The following fields will be there (see [sovrin-did-method](https://sovrin-foundation.github.io/sovrin/spec/did-method-spec-template.html#sovrin-did-method):
+         - Public keys
+         - Services
+         - Authentication
+         - etc.
+    - DID_DOC_DELTA
+       - An array of the following values:
+       - Field_id
+       - Operation (ADD/REMOVE/EDIT)
+       - New value (or id of removed value)
+6. DID DOC Updates
+    - Will be done incrementally as requests to the Ledger via DID DOC Deltas
+    - Ledger will be responsible for validation (authentication and authorizations checks) and merging the incremental updates (DID DOC Deltas) to the DID DOC state
+7. Support of multiple did methods
+    - Will be done via Resolvers that can be registered by applications
+    - There will be default resolver for 'peer' (microledger based) method
+    - There will be out-of-the-box support of methods based on Indy ledgers with minumum configuration (SLN, STN and etc...)
+8. Publishing existing DID/DID DOC to another Ledger/microledger
+    - Will be done via explicit export method
+9. Procedure that performs resolving DID will fallback to old wallet structure to allow using existing crypto materials with the new approach
+10. The old (current) DID API will be deprecated
+11. The new DID API will be created to allow:
+     - Registering of DID methods
+     - Creation of DIDs
+     - Building of DID Docs and DID Doc deltas with builder pattern
+     - Publishing of DID Doc and DID Doc deltas
+     - Resolving of DID Docs
+
+## Libindy API
+
+### DID resolver configuration
+
+#### Create DID Resolver instance
+
+```Rust
+// Create DID resolver instance
+//
+// By default supports peer method only. To support additional did methods
+// indy_register_indy_did_method or indy_register_did_method can be called.
+//
+// options: - some options like cache policies
+// returns - did_resolver_handle: handler ot DID Resolver instance
+pub fn indy_create_did_resolver(options) -> Future<did_resolver_handle>
+```
+
+#### Register did method based on Indy pool with did resolver
+
+```Rust
+// Register did method based on Indy pool with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'sov'
+// pool_handle: pool_handle
+// options: some options
+// returns - ()
+pub fn indy_register_indy_did_method(did_resolver_handle,
+                                     method,
+                                     pool_handle,
+                                     options) -> Future<()>
+```
+
+#### Register custom did method with did resolver
+
+```Rust
+// Register custom did method with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'custom'
+// ..callbacks: list of callbacks that define method behaviour
+// options: some options
+// returns - ()
+pub fn indy_register_did_method(did_resolver_handle,
+                                method,
+                                ..callbacks,
+                                options) -> Future<()>
+```
+
+#### Close did resolver and releases all related resources
+
+```Rust
+// Close did resolver and releases all related resources.
+//
+// did_resolver_handle: resolver handle
+// returns - ()
+pub fn indy_close_did_resolver(did_resolver_handle) -> Future<()>
+```
+
+### Resolving DID Doc
+
+#### Resolve DID Doc for DID
+
+```Rust
+// Resolve DID Doc for DID.
+//
+// did_resolver_handle: resolver handle
+// did: did to resolve
+// options: some options, like cache behaviour
+// returns - did_doc: resolved DID Doc
+pub fn indy_resolve_did_doc(did_resolver_handle,
+                            did,
+                            options) -> Future<did_doc>
+```
+
+### DID and DID keys creation
+
+#### Creates a new DID
+
+```Rust
+// Create a new DID.
+//
+// Note: It doesn't create any records in the wallet.
+//
+// did_resolver_handle: resolver handle
+// method: did method to use
+// options: some options
+// returns - did: Generated DID
+pub fn indy_create_did(did_resolver_handle,
+                       method,
+                       options) -> Future<did>
+```
+
+#### Create a new key pair associated with DID
+
+```Rust
+// Create a new key pair associated with DID.
+//
+// It verifies that key options are compatible with method,
+// creates and stores key in the wallet, creates and stores association
+// of this key with did.
+//
+// Note: It can produce the same data as indy_create_my_did.
+//
+// did_resolver_handle: resolver handle
+// did: did to associate with this key
+// options: some options like key type and seed
+// returns - key_json: json that describes the key. Can be passed to did
+//                     doc builder
+pub fn indy_create_did_key(did_resolver_handle,
+                           did,
+                           options) -> Future<key_json>
+```
+
+### DID Doc creation, updating and publishing
+
+#### Create a new DID Doc builder instance
+
+```Rust
+// Create a new DID Doc builder instance.
+//
+// It tries to resolve did doc for provided did and creates builder that
+// allows to modify did doc and publish it. If did doc isn't exists it
+// starts building from scratch
+//
+// did_resolver_handle: resolver handle
+// did: did to associate did doc
+// options: some options like key type and seed
+// returns - ddoc_builder_handle: did doc builder handle
+pub fn indy_create_did_doc_builder(did_resolver_handle,
+                                   did,
+                                   options) -> Future<ddoc_builder_handle>
+```
+
+#### Add new public key item to DID Doc builder
+
+```Rust
+// Add new public key item to DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.",263,2019-03-04 16:00:37,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262124509,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262124509,lovesh
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,Same question as above about current DID,a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-04 16:01:06,262124772,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.
+    - Local DID Doc copy is never updated explicitly.
+    - If a change to DID Doc is needed, the corresponding txn is created and sent to the Ledger.
+    - Different policies can be supported for updating the current DID DOC copy:
+      - The default one may just go to the Ledger every time before accessing the DID/DIDDoc. For example, if edge wants
+        to pack a message, it goes to the Ledger, gets the latest DID Doc, updates the local copy, and uses the local copy
+        for packing.
+      - Other policies may update it by timeout, or update by getting notifications from the Ledger/microledger
+3. In communication between Agents:
+    - DID Doc is never passed from one Agent (Alice) to another (Bob)
+    - DID is the only thing which is passed
+    - The receiver resolves the DID looking at the did method and going to the corresponding ledger (public or micro)
+    - This will allow communication between old agents (not supporting DID Doc) and new ones using the new approach
+4. The Ledger level is opaque. It doesn’t matter if this is public or micro ledger. Exact publishing and resolving strategy are
+   defined by a pluggable Resolvers and doesn’t affect workflows.
+5. To support DID Doc new transactions will be added to Indy Ledger:
+    - DID_DOC
+      - Consists of `did` and `doc`
+      - The ‘doc’ fields is a map of the form {field_id -> field} where field_id is a unique identifier of a field in the doc, and field is one of the fields (either array or a single-value)
+      - The following fields will be there (see [sovrin-did-method](https://sovrin-foundation.github.io/sovrin/spec/did-method-spec-template.html#sovrin-did-method):
+         - Public keys
+         - Services
+         - Authentication
+         - etc.
+    - DID_DOC_DELTA
+       - An array of the following values:
+       - Field_id
+       - Operation (ADD/REMOVE/EDIT)
+       - New value (or id of removed value)
+6. DID DOC Updates
+    - Will be done incrementally as requests to the Ledger via DID DOC Deltas
+    - Ledger will be responsible for validation (authentication and authorizations checks) and merging the incremental updates (DID DOC Deltas) to the DID DOC state
+7. Support of multiple did methods
+    - Will be done via Resolvers that can be registered by applications
+    - There will be default resolver for 'peer' (microledger based) method
+    - There will be out-of-the-box support of methods based on Indy ledgers with minumum configuration (SLN, STN and etc...)
+8. Publishing existing DID/DID DOC to another Ledger/microledger
+    - Will be done via explicit export method
+9. Procedure that performs resolving DID will fallback to old wallet structure to allow using existing crypto materials with the new approach
+10. The old (current) DID API will be deprecated
+11. The new DID API will be created to allow:
+     - Registering of DID methods
+     - Creation of DIDs
+     - Building of DID Docs and DID Doc deltas with builder pattern
+     - Publishing of DID Doc and DID Doc deltas
+     - Resolving of DID Docs
+
+## Libindy API
+
+### DID resolver configuration
+
+#### Create DID Resolver instance
+
+```Rust
+// Create DID resolver instance
+//
+// By default supports peer method only. To support additional did methods
+// indy_register_indy_did_method or indy_register_did_method can be called.
+//
+// options: - some options like cache policies
+// returns - did_resolver_handle: handler ot DID Resolver instance
+pub fn indy_create_did_resolver(options) -> Future<did_resolver_handle>
+```
+
+#### Register did method based on Indy pool with did resolver
+
+```Rust
+// Register did method based on Indy pool with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'sov'
+// pool_handle: pool_handle
+// options: some options
+// returns - ()
+pub fn indy_register_indy_did_method(did_resolver_handle,
+                                     method,
+                                     pool_handle,
+                                     options) -> Future<()>
+```
+
+#### Register custom did method with did resolver
+
+```Rust
+// Register custom did method with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'custom'
+// ..callbacks: list of callbacks that define method behaviour
+// options: some options
+// returns - ()
+pub fn indy_register_did_method(did_resolver_handle,
+                                method,
+                                ..callbacks,
+                                options) -> Future<()>
+```
+
+#### Close did resolver and releases all related resources
+
+```Rust
+// Close did resolver and releases all related resources.
+//
+// did_resolver_handle: resolver handle
+// returns - ()
+pub fn indy_close_did_resolver(did_resolver_handle) -> Future<()>
+```
+
+### Resolving DID Doc
+
+#### Resolve DID Doc for DID
+
+```Rust
+// Resolve DID Doc for DID.
+//
+// did_resolver_handle: resolver handle
+// did: did to resolve
+// options: some options, like cache behaviour
+// returns - did_doc: resolved DID Doc
+pub fn indy_resolve_did_doc(did_resolver_handle,
+                            did,
+                            options) -> Future<did_doc>
+```
+
+### DID and DID keys creation
+
+#### Creates a new DID
+
+```Rust
+// Create a new DID.
+//
+// Note: It doesn't create any records in the wallet.
+//
+// did_resolver_handle: resolver handle
+// method: did method to use
+// options: some options
+// returns - did: Generated DID
+pub fn indy_create_did(did_resolver_handle,
+                       method,
+                       options) -> Future<did>
+```
+
+#### Create a new key pair associated with DID
+
+```Rust
+// Create a new key pair associated with DID.
+//
+// It verifies that key options are compatible with method,
+// creates and stores key in the wallet, creates and stores association
+// of this key with did.
+//
+// Note: It can produce the same data as indy_create_my_did.
+//
+// did_resolver_handle: resolver handle
+// did: did to associate with this key
+// options: some options like key type and seed
+// returns - key_json: json that describes the key. Can be passed to did
+//                     doc builder
+pub fn indy_create_did_key(did_resolver_handle,
+                           did,
+                           options) -> Future<key_json>
+```
+
+### DID Doc creation, updating and publishing
+
+#### Create a new DID Doc builder instance
+
+```Rust
+// Create a new DID Doc builder instance.
+//
+// It tries to resolve did doc for provided did and creates builder that
+// allows to modify did doc and publish it. If did doc isn't exists it
+// starts building from scratch
+//
+// did_resolver_handle: resolver handle
+// did: did to associate did doc
+// options: some options like key type and seed
+// returns - ddoc_builder_handle: did doc builder handle
+pub fn indy_create_did_doc_builder(did_resolver_handle,
+                                   did,
+                                   options) -> Future<ddoc_builder_handle>
+```
+
+#### Add new public key item to DID Doc builder
+
+```Rust
+// Add new public key item to DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// key_json: key_json in format compatible with did method
+// returns - ():
+pub fn indy_did_doc_add_public_key(ddoc_builder_handle,
+                                   id,
+                                   key_json) -> Future<()>
+```
+
+#### Update public key item in DID Doc builder
+
+```Rust
+// Update public key item in DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.",280,2019-03-04 16:01:06,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262124772,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262124772,lovesh
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,"What is meant by ""referenced inside of DID Doc""?",a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-04 16:01:59,262125214,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.
+    - Local DID Doc copy is never updated explicitly.
+    - If a change to DID Doc is needed, the corresponding txn is created and sent to the Ledger.
+    - Different policies can be supported for updating the current DID DOC copy:
+      - The default one may just go to the Ledger every time before accessing the DID/DIDDoc. For example, if edge wants
+        to pack a message, it goes to the Ledger, gets the latest DID Doc, updates the local copy, and uses the local copy
+        for packing.
+      - Other policies may update it by timeout, or update by getting notifications from the Ledger/microledger
+3. In communication between Agents:
+    - DID Doc is never passed from one Agent (Alice) to another (Bob)
+    - DID is the only thing which is passed
+    - The receiver resolves the DID looking at the did method and going to the corresponding ledger (public or micro)
+    - This will allow communication between old agents (not supporting DID Doc) and new ones using the new approach
+4. The Ledger level is opaque. It doesn’t matter if this is public or micro ledger. Exact publishing and resolving strategy are
+   defined by a pluggable Resolvers and doesn’t affect workflows.
+5. To support DID Doc new transactions will be added to Indy Ledger:
+    - DID_DOC
+      - Consists of `did` and `doc`
+      - The ‘doc’ fields is a map of the form {field_id -> field} where field_id is a unique identifier of a field in the doc, and field is one of the fields (either array or a single-value)
+      - The following fields will be there (see [sovrin-did-method](https://sovrin-foundation.github.io/sovrin/spec/did-method-spec-template.html#sovrin-did-method):
+         - Public keys
+         - Services
+         - Authentication
+         - etc.
+    - DID_DOC_DELTA
+       - An array of the following values:
+       - Field_id
+       - Operation (ADD/REMOVE/EDIT)
+       - New value (or id of removed value)
+6. DID DOC Updates
+    - Will be done incrementally as requests to the Ledger via DID DOC Deltas
+    - Ledger will be responsible for validation (authentication and authorizations checks) and merging the incremental updates (DID DOC Deltas) to the DID DOC state
+7. Support of multiple did methods
+    - Will be done via Resolvers that can be registered by applications
+    - There will be default resolver for 'peer' (microledger based) method
+    - There will be out-of-the-box support of methods based on Indy ledgers with minumum configuration (SLN, STN and etc...)
+8. Publishing existing DID/DID DOC to another Ledger/microledger
+    - Will be done via explicit export method
+9. Procedure that performs resolving DID will fallback to old wallet structure to allow using existing crypto materials with the new approach
+10. The old (current) DID API will be deprecated
+11. The new DID API will be created to allow:
+     - Registering of DID methods
+     - Creation of DIDs
+     - Building of DID Docs and DID Doc deltas with builder pattern
+     - Publishing of DID Doc and DID Doc deltas
+     - Resolving of DID Docs
+
+## Libindy API
+
+### DID resolver configuration
+
+#### Create DID Resolver instance
+
+```Rust
+// Create DID resolver instance
+//
+// By default supports peer method only. To support additional did methods
+// indy_register_indy_did_method or indy_register_did_method can be called.
+//
+// options: - some options like cache policies
+// returns - did_resolver_handle: handler ot DID Resolver instance
+pub fn indy_create_did_resolver(options) -> Future<did_resolver_handle>
+```
+
+#### Register did method based on Indy pool with did resolver
+
+```Rust
+// Register did method based on Indy pool with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'sov'
+// pool_handle: pool_handle
+// options: some options
+// returns - ()
+pub fn indy_register_indy_did_method(did_resolver_handle,
+                                     method,
+                                     pool_handle,
+                                     options) -> Future<()>
+```
+
+#### Register custom did method with did resolver
+
+```Rust
+// Register custom did method with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'custom'
+// ..callbacks: list of callbacks that define method behaviour
+// options: some options
+// returns - ()
+pub fn indy_register_did_method(did_resolver_handle,
+                                method,
+                                ..callbacks,
+                                options) -> Future<()>
+```
+
+#### Close did resolver and releases all related resources
+
+```Rust
+// Close did resolver and releases all related resources.
+//
+// did_resolver_handle: resolver handle
+// returns - ()
+pub fn indy_close_did_resolver(did_resolver_handle) -> Future<()>
+```
+
+### Resolving DID Doc
+
+#### Resolve DID Doc for DID
+
+```Rust
+// Resolve DID Doc for DID.
+//
+// did_resolver_handle: resolver handle
+// did: did to resolve
+// options: some options, like cache behaviour
+// returns - did_doc: resolved DID Doc
+pub fn indy_resolve_did_doc(did_resolver_handle,
+                            did,
+                            options) -> Future<did_doc>
+```
+
+### DID and DID keys creation
+
+#### Creates a new DID
+
+```Rust
+// Create a new DID.
+//
+// Note: It doesn't create any records in the wallet.
+//
+// did_resolver_handle: resolver handle
+// method: did method to use
+// options: some options
+// returns - did: Generated DID
+pub fn indy_create_did(did_resolver_handle,
+                       method,
+                       options) -> Future<did>
+```
+
+#### Create a new key pair associated with DID
+
+```Rust
+// Create a new key pair associated with DID.
+//
+// It verifies that key options are compatible with method,
+// creates and stores key in the wallet, creates and stores association
+// of this key with did.
+//
+// Note: It can produce the same data as indy_create_my_did.
+//
+// did_resolver_handle: resolver handle
+// did: did to associate with this key
+// options: some options like key type and seed
+// returns - key_json: json that describes the key. Can be passed to did
+//                     doc builder
+pub fn indy_create_did_key(did_resolver_handle,
+                           did,
+                           options) -> Future<key_json>
+```
+
+### DID Doc creation, updating and publishing
+
+#### Create a new DID Doc builder instance
+
+```Rust
+// Create a new DID Doc builder instance.
+//
+// It tries to resolve did doc for provided did and creates builder that
+// allows to modify did doc and publish it. If did doc isn't exists it
+// starts building from scratch
+//
+// did_resolver_handle: resolver handle
+// did: did to associate did doc
+// options: some options like key type and seed
+// returns - ddoc_builder_handle: did doc builder handle
+pub fn indy_create_did_doc_builder(did_resolver_handle,
+                                   did,
+                                   options) -> Future<ddoc_builder_handle>
+```
+
+#### Add new public key item to DID Doc builder
+
+```Rust
+// Add new public key item to DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// key_json: key_json in format compatible with did method
+// returns - ():
+pub fn indy_did_doc_add_public_key(ddoc_builder_handle,
+                                   id,
+                                   key_json) -> Future<()>
+```
+
+#### Update public key item in DID Doc builder
+
+```Rust
+// Update public key item in DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// key_json: key_json in format compatible with did method
+// returns - ():
+pub fn indy_did_doc_update_public_key(ddoc_builder_handle,
+                                      id,
+                                      key_json) -> Future<()>
+```
+
+#### Delete public key item in DID Doc builder
+
+```Rust
+// Delete public key item in DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// Note: If key is referenced inside of DID Doc validation error will",299,2019-03-04 16:01:59,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262125214,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262125214,lovesh
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,"Do methods `indy_did_doc_*_public_key`, `indy_did_doc_*_authorization` and `indy_did_doc_*_service_endpoint` make changes to the DID Doc in wallet? Or do they maintain in-memory delta of changes after each such call?",a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-04 16:06:10,262127207,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.
+    - Local DID Doc copy is never updated explicitly.
+    - If a change to DID Doc is needed, the corresponding txn is created and sent to the Ledger.
+    - Different policies can be supported for updating the current DID DOC copy:
+      - The default one may just go to the Ledger every time before accessing the DID/DIDDoc. For example, if edge wants
+        to pack a message, it goes to the Ledger, gets the latest DID Doc, updates the local copy, and uses the local copy
+        for packing.
+      - Other policies may update it by timeout, or update by getting notifications from the Ledger/microledger
+3. In communication between Agents:
+    - DID Doc is never passed from one Agent (Alice) to another (Bob)
+    - DID is the only thing which is passed
+    - The receiver resolves the DID looking at the did method and going to the corresponding ledger (public or micro)
+    - This will allow communication between old agents (not supporting DID Doc) and new ones using the new approach
+4. The Ledger level is opaque. It doesn’t matter if this is public or micro ledger. Exact publishing and resolving strategy are
+   defined by a pluggable Resolvers and doesn’t affect workflows.
+5. To support DID Doc new transactions will be added to Indy Ledger:
+    - DID_DOC
+      - Consists of `did` and `doc`
+      - The ‘doc’ fields is a map of the form {field_id -> field} where field_id is a unique identifier of a field in the doc, and field is one of the fields (either array or a single-value)
+      - The following fields will be there (see [sovrin-did-method](https://sovrin-foundation.github.io/sovrin/spec/did-method-spec-template.html#sovrin-did-method):
+         - Public keys
+         - Services
+         - Authentication
+         - etc.
+    - DID_DOC_DELTA
+       - An array of the following values:
+       - Field_id
+       - Operation (ADD/REMOVE/EDIT)
+       - New value (or id of removed value)
+6. DID DOC Updates
+    - Will be done incrementally as requests to the Ledger via DID DOC Deltas
+    - Ledger will be responsible for validation (authentication and authorizations checks) and merging the incremental updates (DID DOC Deltas) to the DID DOC state
+7. Support of multiple did methods
+    - Will be done via Resolvers that can be registered by applications
+    - There will be default resolver for 'peer' (microledger based) method
+    - There will be out-of-the-box support of methods based on Indy ledgers with minumum configuration (SLN, STN and etc...)
+8. Publishing existing DID/DID DOC to another Ledger/microledger
+    - Will be done via explicit export method
+9. Procedure that performs resolving DID will fallback to old wallet structure to allow using existing crypto materials with the new approach
+10. The old (current) DID API will be deprecated
+11. The new DID API will be created to allow:
+     - Registering of DID methods
+     - Creation of DIDs
+     - Building of DID Docs and DID Doc deltas with builder pattern
+     - Publishing of DID Doc and DID Doc deltas
+     - Resolving of DID Docs
+
+## Libindy API
+
+### DID resolver configuration
+
+#### Create DID Resolver instance
+
+```Rust
+// Create DID resolver instance
+//
+// By default supports peer method only. To support additional did methods
+// indy_register_indy_did_method or indy_register_did_method can be called.
+//
+// options: - some options like cache policies
+// returns - did_resolver_handle: handler ot DID Resolver instance
+pub fn indy_create_did_resolver(options) -> Future<did_resolver_handle>
+```
+
+#### Register did method based on Indy pool with did resolver
+
+```Rust
+// Register did method based on Indy pool with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'sov'
+// pool_handle: pool_handle
+// options: some options
+// returns - ()
+pub fn indy_register_indy_did_method(did_resolver_handle,
+                                     method,
+                                     pool_handle,
+                                     options) -> Future<()>
+```
+
+#### Register custom did method with did resolver
+
+```Rust
+// Register custom did method with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'custom'
+// ..callbacks: list of callbacks that define method behaviour
+// options: some options
+// returns - ()
+pub fn indy_register_did_method(did_resolver_handle,
+                                method,
+                                ..callbacks,
+                                options) -> Future<()>
+```
+
+#### Close did resolver and releases all related resources
+
+```Rust
+// Close did resolver and releases all related resources.
+//
+// did_resolver_handle: resolver handle
+// returns - ()
+pub fn indy_close_did_resolver(did_resolver_handle) -> Future<()>
+```
+
+### Resolving DID Doc
+
+#### Resolve DID Doc for DID
+
+```Rust
+// Resolve DID Doc for DID.
+//
+// did_resolver_handle: resolver handle
+// did: did to resolve
+// options: some options, like cache behaviour
+// returns - did_doc: resolved DID Doc
+pub fn indy_resolve_did_doc(did_resolver_handle,
+                            did,
+                            options) -> Future<did_doc>
+```
+
+### DID and DID keys creation
+
+#### Creates a new DID
+
+```Rust
+// Create a new DID.
+//
+// Note: It doesn't create any records in the wallet.
+//
+// did_resolver_handle: resolver handle
+// method: did method to use
+// options: some options
+// returns - did: Generated DID
+pub fn indy_create_did(did_resolver_handle,
+                       method,
+                       options) -> Future<did>
+```
+
+#### Create a new key pair associated with DID
+
+```Rust
+// Create a new key pair associated with DID.
+//
+// It verifies that key options are compatible with method,
+// creates and stores key in the wallet, creates and stores association
+// of this key with did.
+//
+// Note: It can produce the same data as indy_create_my_did.
+//
+// did_resolver_handle: resolver handle
+// did: did to associate with this key
+// options: some options like key type and seed
+// returns - key_json: json that describes the key. Can be passed to did
+//                     doc builder
+pub fn indy_create_did_key(did_resolver_handle,
+                           did,
+                           options) -> Future<key_json>
+```
+
+### DID Doc creation, updating and publishing
+
+#### Create a new DID Doc builder instance",239,2019-03-04 16:06:10,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262127207,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262127207,lovesh
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,Does this persist the doc? Can this be called repeatedly?,a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-04 16:07:50,262127986,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.
+    - Local DID Doc copy is never updated explicitly.
+    - If a change to DID Doc is needed, the corresponding txn is created and sent to the Ledger.
+    - Different policies can be supported for updating the current DID DOC copy:
+      - The default one may just go to the Ledger every time before accessing the DID/DIDDoc. For example, if edge wants
+        to pack a message, it goes to the Ledger, gets the latest DID Doc, updates the local copy, and uses the local copy
+        for packing.
+      - Other policies may update it by timeout, or update by getting notifications from the Ledger/microledger
+3. In communication between Agents:
+    - DID Doc is never passed from one Agent (Alice) to another (Bob)
+    - DID is the only thing which is passed
+    - The receiver resolves the DID looking at the did method and going to the corresponding ledger (public or micro)
+    - This will allow communication between old agents (not supporting DID Doc) and new ones using the new approach
+4. The Ledger level is opaque. It doesn’t matter if this is public or micro ledger. Exact publishing and resolving strategy are
+   defined by a pluggable Resolvers and doesn’t affect workflows.
+5. To support DID Doc new transactions will be added to Indy Ledger:
+    - DID_DOC
+      - Consists of `did` and `doc`
+      - The ‘doc’ fields is a map of the form {field_id -> field} where field_id is a unique identifier of a field in the doc, and field is one of the fields (either array or a single-value)
+      - The following fields will be there (see [sovrin-did-method](https://sovrin-foundation.github.io/sovrin/spec/did-method-spec-template.html#sovrin-did-method):
+         - Public keys
+         - Services
+         - Authentication
+         - etc.
+    - DID_DOC_DELTA
+       - An array of the following values:
+       - Field_id
+       - Operation (ADD/REMOVE/EDIT)
+       - New value (or id of removed value)
+6. DID DOC Updates
+    - Will be done incrementally as requests to the Ledger via DID DOC Deltas
+    - Ledger will be responsible for validation (authentication and authorizations checks) and merging the incremental updates (DID DOC Deltas) to the DID DOC state
+7. Support of multiple did methods
+    - Will be done via Resolvers that can be registered by applications
+    - There will be default resolver for 'peer' (microledger based) method
+    - There will be out-of-the-box support of methods based on Indy ledgers with minumum configuration (SLN, STN and etc...)
+8. Publishing existing DID/DID DOC to another Ledger/microledger
+    - Will be done via explicit export method
+9. Procedure that performs resolving DID will fallback to old wallet structure to allow using existing crypto materials with the new approach
+10. The old (current) DID API will be deprecated
+11. The new DID API will be created to allow:
+     - Registering of DID methods
+     - Creation of DIDs
+     - Building of DID Docs and DID Doc deltas with builder pattern
+     - Publishing of DID Doc and DID Doc deltas
+     - Resolving of DID Docs
+
+## Libindy API
+
+### DID resolver configuration
+
+#### Create DID Resolver instance
+
+```Rust
+// Create DID resolver instance
+//
+// By default supports peer method only. To support additional did methods
+// indy_register_indy_did_method or indy_register_did_method can be called.
+//
+// options: - some options like cache policies
+// returns - did_resolver_handle: handler ot DID Resolver instance
+pub fn indy_create_did_resolver(options) -> Future<did_resolver_handle>
+```
+
+#### Register did method based on Indy pool with did resolver
+
+```Rust
+// Register did method based on Indy pool with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'sov'
+// pool_handle: pool_handle
+// options: some options
+// returns - ()
+pub fn indy_register_indy_did_method(did_resolver_handle,
+                                     method,
+                                     pool_handle,
+                                     options) -> Future<()>
+```
+
+#### Register custom did method with did resolver
+
+```Rust
+// Register custom did method with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'custom'
+// ..callbacks: list of callbacks that define method behaviour
+// options: some options
+// returns - ()
+pub fn indy_register_did_method(did_resolver_handle,
+                                method,
+                                ..callbacks,
+                                options) -> Future<()>
+```
+
+#### Close did resolver and releases all related resources
+
+```Rust
+// Close did resolver and releases all related resources.
+//
+// did_resolver_handle: resolver handle
+// returns - ()
+pub fn indy_close_did_resolver(did_resolver_handle) -> Future<()>
+```
+
+### Resolving DID Doc
+
+#### Resolve DID Doc for DID
+
+```Rust
+// Resolve DID Doc for DID.
+//
+// did_resolver_handle: resolver handle
+// did: did to resolve
+// options: some options, like cache behaviour
+// returns - did_doc: resolved DID Doc
+pub fn indy_resolve_did_doc(did_resolver_handle,
+                            did,
+                            options) -> Future<did_doc>
+```
+
+### DID and DID keys creation
+
+#### Creates a new DID
+
+```Rust
+// Create a new DID.
+//
+// Note: It doesn't create any records in the wallet.
+//
+// did_resolver_handle: resolver handle
+// method: did method to use
+// options: some options
+// returns - did: Generated DID
+pub fn indy_create_did(did_resolver_handle,
+                       method,
+                       options) -> Future<did>
+```
+
+#### Create a new key pair associated with DID
+
+```Rust
+// Create a new key pair associated with DID.
+//
+// It verifies that key options are compatible with method,
+// creates and stores key in the wallet, creates and stores association
+// of this key with did.
+//
+// Note: It can produce the same data as indy_create_my_did.
+//
+// did_resolver_handle: resolver handle
+// did: did to associate with this key
+// options: some options like key type and seed
+// returns - key_json: json that describes the key. Can be passed to did
+//                     doc builder
+pub fn indy_create_did_key(did_resolver_handle,
+                           did,
+                           options) -> Future<key_json>
+```
+
+### DID Doc creation, updating and publishing
+
+#### Create a new DID Doc builder instance
+
+```Rust
+// Create a new DID Doc builder instance.
+//
+// It tries to resolve did doc for provided did and creates builder that
+// allows to modify did doc and publish it. If did doc isn't exists it
+// starts building from scratch
+//
+// did_resolver_handle: resolver handle
+// did: did to associate did doc
+// options: some options like key type and seed
+// returns - ddoc_builder_handle: did doc builder handle
+pub fn indy_create_did_doc_builder(did_resolver_handle,
+                                   did,
+                                   options) -> Future<ddoc_builder_handle>
+```
+
+#### Add new public key item to DID Doc builder
+
+```Rust
+// Add new public key item to DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// key_json: key_json in format compatible with did method
+// returns - ():
+pub fn indy_did_doc_add_public_key(ddoc_builder_handle,
+                                   id,
+                                   key_json) -> Future<()>
+```
+
+#### Update public key item in DID Doc builder
+
+```Rust
+// Update public key item in DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// key_json: key_json in format compatible with did method
+// returns - ():
+pub fn indy_did_doc_update_public_key(ddoc_builder_handle,
+                                      id,
+                                      key_json) -> Future<()>
+```
+
+#### Delete public key item in DID Doc builder
+
+```Rust
+// Delete public key item in DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// Note: If key is referenced inside of DID Doc validation error will
+// be returned.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// returns - ():
+pub fn indy_did_doc_remove_public_key(ddoc_builder_handle,
+                                      id) -> Future<()>
+```
+
+#### Add new authorization item to DID Doc builder
+
+```Rust
+// Add new authorization item to DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// If no key_json is present and id references current DID this reference
+// must be exists. Otherwise validation error will be returned.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// key_json: key_json in format compatible with did method.
+// returns - ():
+pub fn indy_did_doc_add_authorization(ddoc_builder_handle,
+                                      id,
+                                      Option<key_json>) -> Future<()>
+```
+
+#### Update embedded authorization item with DID Doc builder
+
+```Rust
+// Update embedded authorization item with DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// key_json: key_json in format compatible with did method
+// returns - ():
+pub fn indy_did_doc_update_authorization(ddoc_builder_handle,
+                                         id,
+                                         Option<key_json>) -> Future<()>
+```
+
+#### Delete authorization item with DID Doc builder
+
+```Rust
+// Delete authorization item with DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// returns - ():
+pub fn indy_did_doc_remove_authorization(ddoc_builder_handle,
+                                         id) -> Future<()>
+```
+
+#### Add new service endpoint item to DID Doc builder
+
+```Rust
+// Add new service endpoint item to DID Doc builder.
+//
+// Note: id can be full DID Doc reference or path.
+// In case of path reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of service endpoint
+// endpoint_json: endpoint_json in format compatible with did method.
+// returns - ():
+pub fn indy_did_doc_add_service_endpoint(ddoc_builder_handle,
+                                         id,
+                                         endpoint_json) -> Future<()>
+```
+
+#### Update service endpoint item with DID Doc builder
+
+```Rust
+// Update service endpoint item with DID Doc builder.
+//
+// Note: id can be full DID Doc reference or path .
+// In case of path reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// endpoint_json: endpoint_json in format compatible with did method.
+// returns - ():
+pub fn indy_did_doc_update_service_endpoint(ddoc_builder_handle,
+                                            id,
+                                            endpoint_json) -> Future<()>
+```
+
+#### Delete service endpoint item with DID Doc builder
+
+```Rust
+// Delete service endpoint item with DID Doc builder.
+//
+// Note: id can be full DID Doc reference or path.
+// In case of path reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// returns - ():
+pub fn indy_did_doc_remove_service_endpoint(ddoc_builder_handle,
+                                            id) -> Future<()>
+```
+
+#### Finalize DID Doc builder and return corresonded DID Doc or DID Doc delta
+
+```Rust
+// Finalize DID Doc builder and return corresonded DID Doc or DID Doc delta.
+//
+// Note: Format of delta can be method specific.
+// In case of path reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// returns - did_doc_delta: DID Doc or DID Doc delta
+pub fn indy_did_doc_finalize(ddoc_builder_handle) -> Future<did_doc_delta>",421,2019-03-04 16:07:51,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262127986,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262127986,lovesh
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,Typo in `ddoc_builder_hanle` here and above in a few places,a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-04 16:09:59,262128965,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.
+    - Local DID Doc copy is never updated explicitly.
+    - If a change to DID Doc is needed, the corresponding txn is created and sent to the Ledger.
+    - Different policies can be supported for updating the current DID DOC copy:
+      - The default one may just go to the Ledger every time before accessing the DID/DIDDoc. For example, if edge wants
+        to pack a message, it goes to the Ledger, gets the latest DID Doc, updates the local copy, and uses the local copy
+        for packing.
+      - Other policies may update it by timeout, or update by getting notifications from the Ledger/microledger
+3. In communication between Agents:
+    - DID Doc is never passed from one Agent (Alice) to another (Bob)
+    - DID is the only thing which is passed
+    - The receiver resolves the DID looking at the did method and going to the corresponding ledger (public or micro)
+    - This will allow communication between old agents (not supporting DID Doc) and new ones using the new approach
+4. The Ledger level is opaque. It doesn’t matter if this is public or micro ledger. Exact publishing and resolving strategy are
+   defined by a pluggable Resolvers and doesn’t affect workflows.
+5. To support DID Doc new transactions will be added to Indy Ledger:
+    - DID_DOC
+      - Consists of `did` and `doc`
+      - The ‘doc’ fields is a map of the form {field_id -> field} where field_id is a unique identifier of a field in the doc, and field is one of the fields (either array or a single-value)
+      - The following fields will be there (see [sovrin-did-method](https://sovrin-foundation.github.io/sovrin/spec/did-method-spec-template.html#sovrin-did-method):
+         - Public keys
+         - Services
+         - Authentication
+         - etc.
+    - DID_DOC_DELTA
+       - An array of the following values:
+       - Field_id
+       - Operation (ADD/REMOVE/EDIT)
+       - New value (or id of removed value)
+6. DID DOC Updates
+    - Will be done incrementally as requests to the Ledger via DID DOC Deltas
+    - Ledger will be responsible for validation (authentication and authorizations checks) and merging the incremental updates (DID DOC Deltas) to the DID DOC state
+7. Support of multiple did methods
+    - Will be done via Resolvers that can be registered by applications
+    - There will be default resolver for 'peer' (microledger based) method
+    - There will be out-of-the-box support of methods based on Indy ledgers with minumum configuration (SLN, STN and etc...)
+8. Publishing existing DID/DID DOC to another Ledger/microledger
+    - Will be done via explicit export method
+9. Procedure that performs resolving DID will fallback to old wallet structure to allow using existing crypto materials with the new approach
+10. The old (current) DID API will be deprecated
+11. The new DID API will be created to allow:
+     - Registering of DID methods
+     - Creation of DIDs
+     - Building of DID Docs and DID Doc deltas with builder pattern
+     - Publishing of DID Doc and DID Doc deltas
+     - Resolving of DID Docs
+
+## Libindy API
+
+### DID resolver configuration
+
+#### Create DID Resolver instance
+
+```Rust
+// Create DID resolver instance
+//
+// By default supports peer method only. To support additional did methods
+// indy_register_indy_did_method or indy_register_did_method can be called.
+//
+// options: - some options like cache policies
+// returns - did_resolver_handle: handler ot DID Resolver instance
+pub fn indy_create_did_resolver(options) -> Future<did_resolver_handle>
+```
+
+#### Register did method based on Indy pool with did resolver
+
+```Rust
+// Register did method based on Indy pool with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'sov'
+// pool_handle: pool_handle
+// options: some options
+// returns - ()
+pub fn indy_register_indy_did_method(did_resolver_handle,
+                                     method,
+                                     pool_handle,
+                                     options) -> Future<()>
+```
+
+#### Register custom did method with did resolver
+
+```Rust
+// Register custom did method with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'custom'
+// ..callbacks: list of callbacks that define method behaviour
+// options: some options
+// returns - ()
+pub fn indy_register_did_method(did_resolver_handle,
+                                method,
+                                ..callbacks,
+                                options) -> Future<()>
+```
+
+#### Close did resolver and releases all related resources
+
+```Rust
+// Close did resolver and releases all related resources.
+//
+// did_resolver_handle: resolver handle
+// returns - ()
+pub fn indy_close_did_resolver(did_resolver_handle) -> Future<()>
+```
+
+### Resolving DID Doc
+
+#### Resolve DID Doc for DID
+
+```Rust
+// Resolve DID Doc for DID.
+//
+// did_resolver_handle: resolver handle
+// did: did to resolve
+// options: some options, like cache behaviour
+// returns - did_doc: resolved DID Doc
+pub fn indy_resolve_did_doc(did_resolver_handle,
+                            did,
+                            options) -> Future<did_doc>
+```
+
+### DID and DID keys creation
+
+#### Creates a new DID
+
+```Rust
+// Create a new DID.
+//
+// Note: It doesn't create any records in the wallet.
+//
+// did_resolver_handle: resolver handle
+// method: did method to use
+// options: some options
+// returns - did: Generated DID
+pub fn indy_create_did(did_resolver_handle,
+                       method,
+                       options) -> Future<did>
+```
+
+#### Create a new key pair associated with DID
+
+```Rust
+// Create a new key pair associated with DID.
+//
+// It verifies that key options are compatible with method,
+// creates and stores key in the wallet, creates and stores association
+// of this key with did.
+//
+// Note: It can produce the same data as indy_create_my_did.
+//
+// did_resolver_handle: resolver handle
+// did: did to associate with this key
+// options: some options like key type and seed
+// returns - key_json: json that describes the key. Can be passed to did
+//                     doc builder
+pub fn indy_create_did_key(did_resolver_handle,
+                           did,
+                           options) -> Future<key_json>
+```
+
+### DID Doc creation, updating and publishing
+
+#### Create a new DID Doc builder instance
+
+```Rust
+// Create a new DID Doc builder instance.
+//
+// It tries to resolve did doc for provided did and creates builder that
+// allows to modify did doc and publish it. If did doc isn't exists it
+// starts building from scratch
+//
+// did_resolver_handle: resolver handle
+// did: did to associate did doc
+// options: some options like key type and seed
+// returns - ddoc_builder_handle: did doc builder handle
+pub fn indy_create_did_doc_builder(did_resolver_handle,
+                                   did,
+                                   options) -> Future<ddoc_builder_handle>
+```
+
+#### Add new public key item to DID Doc builder
+
+```Rust
+// Add new public key item to DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// key_json: key_json in format compatible with did method
+// returns - ():
+pub fn indy_did_doc_add_public_key(ddoc_builder_handle,
+                                   id,
+                                   key_json) -> Future<()>
+```
+
+#### Update public key item in DID Doc builder
+
+```Rust
+// Update public key item in DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// key_json: key_json in format compatible with did method
+// returns - ():
+pub fn indy_did_doc_update_public_key(ddoc_builder_handle,
+                                      id,
+                                      key_json) -> Future<()>
+```
+
+#### Delete public key item in DID Doc builder
+
+```Rust
+// Delete public key item in DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// Note: If key is referenced inside of DID Doc validation error will
+// be returned.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// returns - ():
+pub fn indy_did_doc_remove_public_key(ddoc_builder_handle,
+                                      id) -> Future<()>
+```
+
+#### Add new authorization item to DID Doc builder
+
+```Rust
+// Add new authorization item to DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// If no key_json is present and id references current DID this reference
+// must be exists. Otherwise validation error will be returned.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// key_json: key_json in format compatible with did method.
+// returns - ():
+pub fn indy_did_doc_add_authorization(ddoc_builder_handle,
+                                      id,
+                                      Option<key_json>) -> Future<()>
+```
+
+#### Update embedded authorization item with DID Doc builder
+
+```Rust
+// Update embedded authorization item with DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// key_json: key_json in format compatible with did method
+// returns - ():
+pub fn indy_did_doc_update_authorization(ddoc_builder_handle,
+                                         id,
+                                         Option<key_json>) -> Future<()>
+```
+
+#### Delete authorization item with DID Doc builder
+
+```Rust
+// Delete authorization item with DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// returns - ():
+pub fn indy_did_doc_remove_authorization(ddoc_builder_handle,
+                                         id) -> Future<()>
+```
+
+#### Add new service endpoint item to DID Doc builder
+
+```Rust
+// Add new service endpoint item to DID Doc builder.
+//
+// Note: id can be full DID Doc reference or path.
+// In case of path reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of service endpoint
+// endpoint_json: endpoint_json in format compatible with did method.
+// returns - ():
+pub fn indy_did_doc_add_service_endpoint(ddoc_builder_handle,
+                                         id,
+                                         endpoint_json) -> Future<()>
+```
+
+#### Update service endpoint item with DID Doc builder
+
+```Rust
+// Update service endpoint item with DID Doc builder.
+//
+// Note: id can be full DID Doc reference or path .
+// In case of path reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// endpoint_json: endpoint_json in format compatible with did method.
+// returns - ():
+pub fn indy_did_doc_update_service_endpoint(ddoc_builder_handle,
+                                            id,
+                                            endpoint_json) -> Future<()>
+```
+
+#### Delete service endpoint item with DID Doc builder
+
+```Rust
+// Delete service endpoint item with DID Doc builder.
+//
+// Note: id can be full DID Doc reference or path.
+// In case of path reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// returns - ():
+pub fn indy_did_doc_remove_service_endpoint(ddoc_builder_handle,
+                                            id) -> Future<()>
+```
+
+#### Finalize DID Doc builder and return corresonded DID Doc or DID Doc delta
+
+```Rust
+// Finalize DID Doc builder and return corresonded DID Doc or DID Doc delta.
+//
+// Note: Format of delta can be method specific.
+// In case of path reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// returns - did_doc_delta: DID Doc or DID Doc delta
+pub fn indy_did_doc_finalize(ddoc_builder_handle) -> Future<did_doc_delta>
+```
+
+#### Publish DID Doc or DID Doc delta in distributed network
+
+```Rust
+// Publish DID Doc or DID Doc delta in distributed network.
+//
+// did_resolver_handle: resolver handle
+// did_doc_delta: did doc or delta json
+// options: Publish options specific for did method. For indy methods
+//          it should at least contains:
+//          - optional publisher did (can be current DID by default)
+//          - optional keys to sign transaction (can be determined
+//                         automatically)
+// returns - ():
+pub fn indy_did_doc_publish(did_resolver_handle,
+                            did_doc_delta,
+                            options) -> Future<did_doc_json>
+```
+
+## API Example
+
+```Python
+# This python example discovers the following use case:
+#
+# * Alice on Edge Device 1 creates DID and key pair for this DID
+# * Alice on Edge Device 1 builds corresponded DID Doc
+# * Alice on Edge Device 1 sends the DID Doc to Trust Anchor
+# * Trust Anchor signs and publishes this DID Doc on Sovrin pool and Alice
+#   on Edge Device 1 gets the control over DID
+# * Alice on Edge Device 2 generates new key pair for DID
+# * Alice on Edge Device 2 generates corresponded DID Doc delta and sends
+#   it to Edge Device 1
+# * Alice on Edge Device 1 signs and publishes this DID Doc Delta
+#   on Sovrin pool
+# * Alice shares DID with Bob. Bob can resolve DID Doc and trust both keys
+
+
+# ------------ Alice on Edge Device 1 ----------------
+
+# 1. Connect to Sovrin pool
+let pool_handle = ... # open Sovrin pool
+
+# 2. Create DID resolver instance
+let did_resolver_handle = await did.create_did_resolver()
+
+# 3. Register 'sov' DID method with DID resolver
+await did.register_indy_did_method(did_resolver_handle,
+                                   'sov',
+                                    pool_handle, '{}')
+
+# 4. Create new DID with 'sov' method
+let did = await did.create_did(did_resolver_handle, 'sov', '{}')
+
+# 5. Create new key pair associated with DID
+let key_info = await did.create_did_key(did_resolver_handle,
+                                        did,
+                                        '{}')
+
+# 5. Create new instance of DID Doc builder
+let ddoc_builder_hanle =
+     await did.create_did_doc_builder(did_resolver_handle,
+                                      did)
+
+# 6. Add public key to DID Doc with builder
+await did.did_doc_add_public_key(ddoc_builder_hanle,
+                                 'key-0',
+                                 key_info)
+
+# 7. Use this key for authorization
+await did.did_doc_add_authorization(ddoc_builder_hanle,
+                                    'key-0')
+
+# 8. Add optional extra 'role' field to DID Doc
+await did.did_doc_add_extra(ddoc_builder_hanle,
+                            'role',
+                            'TRUST_ANCHOR')
+
+# 9. Finalize builder and get corresponded DID Doc
+let did_doc = await did.did_doc_finalize(ddoc_builder_hanle)
+
+# 10. Send DID Doc to Trust Anchor and DID to Edge Device 2
+# ...
+
+# ------------ Trust Anchor ----------------
+
+# 11. Receive DID Doc from Alice
+let did_doc = ... # Receive DID Doc from Alice
+
+# 12. Create DID Resolver and register 'sov' method
+let did_resolver_handle = ... # Create DID Resolver and register 'sov'
+                              # method
+
+# 13. Publish DID Doc
+await did.did_doc_publish(did_resolver_handle,
+                          did_doc,
+                          toJson({
+                            publisher: 'sov:sadfasasd12323qwe',
+                            signatures: ['key-1']
+                          }))
+
+# ------------ Alice on Edge Device 2 ----------------
+
+# 14. Receive DID from Alice on Edge Device 1
+let did = ... # Receive DID from Alice
+
+# 15. Create DID Resolver and register 'sov' method
+let did_resolver_handle = ... # Create DID Resolver and register 'sov'
+                              # method
+
+# 16. Create new key pair associated with DID
+let key_info = await did.create_did_key(did_resolver_handle,
+                                        did,
+                                        '{}')
+
+# 17. Create new instance of DID Doc builder
+let ddoc_builder_hanle =
+     await did.create_did_doc_builder(did_resolver_handle,
+                                      did)
+
+# 18. Add public key to DID Doc with builder
+await did.did_doc_add_public_key(ddoc_builder_hanle,
+                                 'key-1',
+                                 key_info)
+
+# 19. Use this key for authorization
+await did.did_doc_add_authorization(ddoc_builder_hanle,
+                                    'key-1')
+
+# 20. Finalize builder and get corresponded DID Doc delta
+let did_doc_delta = await did.did_doc_finalize(ddoc_builder_hanle)",552,2019-03-04 16:09:59,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262128965,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262128965,lovesh
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,We don't store DID Doc in wallet at all. Wallet only stores keys related to DID.,a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-04 18:19:37,262182364,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.
+    - Local DID Doc copy is never updated explicitly.
+    - If a change to DID Doc is needed, the corresponding txn is created and sent to the Ledger.
+    - Different policies can be supported for updating the current DID DOC copy:
+      - The default one may just go to the Ledger every time before accessing the DID/DIDDoc. For example, if edge wants
+        to pack a message, it goes to the Ledger, gets the latest DID Doc, updates the local copy, and uses the local copy
+        for packing.
+      - Other policies may update it by timeout, or update by getting notifications from the Ledger/microledger
+3. In communication between Agents:
+    - DID Doc is never passed from one Agent (Alice) to another (Bob)
+    - DID is the only thing which is passed
+    - The receiver resolves the DID looking at the did method and going to the corresponding ledger (public or micro)
+    - This will allow communication between old agents (not supporting DID Doc) and new ones using the new approach
+4. The Ledger level is opaque. It doesn’t matter if this is public or micro ledger. Exact publishing and resolving strategy are
+   defined by a pluggable Resolvers and doesn’t affect workflows.
+5. To support DID Doc new transactions will be added to Indy Ledger:
+    - DID_DOC
+      - Consists of `did` and `doc`
+      - The ‘doc’ fields is a map of the form {field_id -> field} where field_id is a unique identifier of a field in the doc, and field is one of the fields (either array or a single-value)
+      - The following fields will be there (see [sovrin-did-method](https://sovrin-foundation.github.io/sovrin/spec/did-method-spec-template.html#sovrin-did-method):
+         - Public keys
+         - Services
+         - Authentication
+         - etc.
+    - DID_DOC_DELTA
+       - An array of the following values:
+       - Field_id
+       - Operation (ADD/REMOVE/EDIT)
+       - New value (or id of removed value)
+6. DID DOC Updates
+    - Will be done incrementally as requests to the Ledger via DID DOC Deltas
+    - Ledger will be responsible for validation (authentication and authorizations checks) and merging the incremental updates (DID DOC Deltas) to the DID DOC state
+7. Support of multiple did methods
+    - Will be done via Resolvers that can be registered by applications
+    - There will be default resolver for 'peer' (microledger based) method
+    - There will be out-of-the-box support of methods based on Indy ledgers with minumum configuration (SLN, STN and etc...)
+8. Publishing existing DID/DID DOC to another Ledger/microledger
+    - Will be done via explicit export method
+9. Procedure that performs resolving DID will fallback to old wallet structure to allow using existing crypto materials with the new approach
+10. The old (current) DID API will be deprecated
+11. The new DID API will be created to allow:
+     - Registering of DID methods
+     - Creation of DIDs
+     - Building of DID Docs and DID Doc deltas with builder pattern
+     - Publishing of DID Doc and DID Doc deltas
+     - Resolving of DID Docs
+
+## Libindy API
+
+### DID resolver configuration
+
+#### Create DID Resolver instance
+
+```Rust
+// Create DID resolver instance
+//
+// By default supports peer method only. To support additional did methods
+// indy_register_indy_did_method or indy_register_did_method can be called.
+//
+// options: - some options like cache policies
+// returns - did_resolver_handle: handler ot DID Resolver instance
+pub fn indy_create_did_resolver(options) -> Future<did_resolver_handle>
+```
+
+#### Register did method based on Indy pool with did resolver
+
+```Rust
+// Register did method based on Indy pool with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'sov'
+// pool_handle: pool_handle
+// options: some options
+// returns - ()
+pub fn indy_register_indy_did_method(did_resolver_handle,
+                                     method,
+                                     pool_handle,
+                                     options) -> Future<()>
+```
+
+#### Register custom did method with did resolver
+
+```Rust
+// Register custom did method with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'custom'
+// ..callbacks: list of callbacks that define method behaviour
+// options: some options
+// returns - ()
+pub fn indy_register_did_method(did_resolver_handle,
+                                method,
+                                ..callbacks,
+                                options) -> Future<()>
+```
+
+#### Close did resolver and releases all related resources
+
+```Rust
+// Close did resolver and releases all related resources.
+//
+// did_resolver_handle: resolver handle
+// returns - ()
+pub fn indy_close_did_resolver(did_resolver_handle) -> Future<()>
+```
+
+### Resolving DID Doc
+
+#### Resolve DID Doc for DID
+
+```Rust
+// Resolve DID Doc for DID.
+//
+// did_resolver_handle: resolver handle
+// did: did to resolve
+// options: some options, like cache behaviour
+// returns - did_doc: resolved DID Doc
+pub fn indy_resolve_did_doc(did_resolver_handle,
+                            did,
+                            options) -> Future<did_doc>
+```
+
+### DID and DID keys creation
+
+#### Creates a new DID
+
+```Rust
+// Create a new DID.
+//
+// Note: It doesn't create any records in the wallet.
+//
+// did_resolver_handle: resolver handle
+// method: did method to use
+// options: some options
+// returns - did: Generated DID
+pub fn indy_create_did(did_resolver_handle,
+                       method,
+                       options) -> Future<did>
+```
+
+#### Create a new key pair associated with DID
+
+```Rust
+// Create a new key pair associated with DID.
+//
+// It verifies that key options are compatible with method,
+// creates and stores key in the wallet, creates and stores association
+// of this key with did.
+//
+// Note: It can produce the same data as indy_create_my_did.
+//
+// did_resolver_handle: resolver handle
+// did: did to associate with this key
+// options: some options like key type and seed
+// returns - key_json: json that describes the key. Can be passed to did
+//                     doc builder
+pub fn indy_create_did_key(did_resolver_handle,
+                           did,
+                           options) -> Future<key_json>
+```
+
+### DID Doc creation, updating and publishing
+
+#### Create a new DID Doc builder instance",239,2019-03-04 18:19:37,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262182364,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262182364,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,"@lovesh @dhh1128  @ashcherbakov  I am not sure that it is necessary and feasible to get complete Edge devices topology and key/device mapping information from DID Doc. Some applications can provide this information, but it is application level, not libindy level.  What edge device know:

- The list of keys related to this DID stored in wallet
- Device can resolve the latest version of DID Doc and based on this information understand what local keys can be used to perform DID Doc modifications and what keys can be used for A2A communication

But It can be impossible to know on what devices other keys stored without getting some additional information from application user.",a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-06 07:02:38,262812502,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device",22,2019-03-06 07:02:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262812502,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262812502,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,"@lovesh @dhh1128 @ashcherbakov 

1. I think you mean not authorized by not authenticated. 

Yes, it is mistake. Will fix.

2. How can a device not authorized to update still update? Do you mean updating itself? Each device should be able to update itslef without requiring any other device.

Let's consider the following use case:

1. Alice has iPhone. In wallet we she has key pair for some relationship DID that is authorized to perform DID updates (like adding new keys).
2. Alice wants to use also iPad to participate in this relationship.
3. The question is how we can achieve this? You can notice that we need to add key form new edge device (iPad) that isn't authorized to perform updates.

We suggest the following:

1. Alice generates new key pair for this DID on iPad
2. iPad application displays QR code (or doing something similar) with public key info
3. iPhone app scans QR code
4. iPhone app performs DID Doc update by adding public key from iPad
5. iPad now can be used for this relationship communications and DID Doc updates if iPhone app provided enough authorization rights for new key.

Similar use keys is creation of public DID when you need to contact Trust Anchor. It can be solved similar way.

Suggested API allows to perform described operations.

",a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-06 07:14:46,262815377,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update",48,2019-03-06 07:14:46,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262815377,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262815377,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,"@lovesh @dhh1128 @ashcherbakov

> In case of microledger?

It isn't important how DID Doc is shared. There is some storage (public ledger, micro ledger, centralized storage, some ledger between cloud agents) that all connected devices have access and this storage is used to perform DID Doc synchronization. Otherwise you can easy get DID Doc out of think that can cause security and communication problems.",a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-06 07:18:12,262816087,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.",76,2019-03-06 07:18:13,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262816087,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262816087,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,I agree with Slava that Alice's edge device doesn't need to know all keys for all other Alice's edge device. A good example is a static agent (an IoT device) that need to know only the key it owns.,a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-06 07:37:21,262820687,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device",22,2019-03-06 07:37:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262820687,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262820687,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,"Yes, we propose to separate at least the following layers/protocols:
1) Sub-protocol of how DID DOC created and updated by agents
2) Sub-protocol of how DID DOC updates are ordered and synchronized between Alice's devices .
Options: public ledger, BFT-like microledger, CFT-like microledger, Centralized approach, etc.
3) Sub-protocol of how and when Bob get the latest Alice's DID DOC.
We will update the docs with this thinking.",a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-06 07:42:07,262821864,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.",76,2019-03-06 07:42:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262821864,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262821864,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,I think `field_id` can be a combined ID of multiple nested ids,a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-06 07:43:56,262822269,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.
+    - Local DID Doc copy is never updated explicitly.
+    - If a change to DID Doc is needed, the corresponding txn is created and sent to the Ledger.
+    - Different policies can be supported for updating the current DID DOC copy:
+      - The default one may just go to the Ledger every time before accessing the DID/DIDDoc. For example, if edge wants
+        to pack a message, it goes to the Ledger, gets the latest DID Doc, updates the local copy, and uses the local copy
+        for packing.
+      - Other policies may update it by timeout, or update by getting notifications from the Ledger/microledger
+3. In communication between Agents:
+    - DID Doc is never passed from one Agent (Alice) to another (Bob)
+    - DID is the only thing which is passed
+    - The receiver resolves the DID looking at the did method and going to the corresponding ledger (public or micro)
+    - This will allow communication between old agents (not supporting DID Doc) and new ones using the new approach
+4. The Ledger level is opaque. It doesn’t matter if this is public or micro ledger. Exact publishing and resolving strategy are
+   defined by a pluggable Resolvers and doesn’t affect workflows.
+5. To support DID Doc new transactions will be added to Indy Ledger:
+    - DID_DOC
+      - Consists of `did` and `doc`
+      - The ‘doc’ fields is a map of the form {field_id -> field} where field_id is a unique identifier of a field in the doc, and field is one of the fields (either array or a single-value)",94,2019-03-06 07:43:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262822269,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262822269,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,"I think it makes sense to have this method as a separate one because of the following:
1) DID can be generated independent of the key. It can be just a UUID, not necessary a part of a public key
2) It makes the API more clear and clean from my opinion, especially if we want to create multiple keys for a DID in one builder.
3) I think there can be use cases when we want just DID, and keys will be generated latter.",a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-06 07:47:02,262822988,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.
+    - Local DID Doc copy is never updated explicitly.
+    - If a change to DID Doc is needed, the corresponding txn is created and sent to the Ledger.
+    - Different policies can be supported for updating the current DID DOC copy:
+      - The default one may just go to the Ledger every time before accessing the DID/DIDDoc. For example, if edge wants
+        to pack a message, it goes to the Ledger, gets the latest DID Doc, updates the local copy, and uses the local copy
+        for packing.
+      - Other policies may update it by timeout, or update by getting notifications from the Ledger/microledger
+3. In communication between Agents:
+    - DID Doc is never passed from one Agent (Alice) to another (Bob)
+    - DID is the only thing which is passed
+    - The receiver resolves the DID looking at the did method and going to the corresponding ledger (public or micro)
+    - This will allow communication between old agents (not supporting DID Doc) and new ones using the new approach
+4. The Ledger level is opaque. It doesn’t matter if this is public or micro ledger. Exact publishing and resolving strategy are
+   defined by a pluggable Resolvers and doesn’t affect workflows.
+5. To support DID Doc new transactions will be added to Indy Ledger:
+    - DID_DOC
+      - Consists of `did` and `doc`
+      - The ‘doc’ fields is a map of the form {field_id -> field} where field_id is a unique identifier of a field in the doc, and field is one of the fields (either array or a single-value)
+      - The following fields will be there (see [sovrin-did-method](https://sovrin-foundation.github.io/sovrin/spec/did-method-spec-template.html#sovrin-did-method):
+         - Public keys
+         - Services
+         - Authentication
+         - etc.
+    - DID_DOC_DELTA
+       - An array of the following values:
+       - Field_id
+       - Operation (ADD/REMOVE/EDIT)
+       - New value (or id of removed value)
+6. DID DOC Updates
+    - Will be done incrementally as requests to the Ledger via DID DOC Deltas
+    - Ledger will be responsible for validation (authentication and authorizations checks) and merging the incremental updates (DID DOC Deltas) to the DID DOC state
+7. Support of multiple did methods
+    - Will be done via Resolvers that can be registered by applications
+    - There will be default resolver for 'peer' (microledger based) method
+    - There will be out-of-the-box support of methods based on Indy ledgers with minumum configuration (SLN, STN and etc...)
+8. Publishing existing DID/DID DOC to another Ledger/microledger
+    - Will be done via explicit export method
+9. Procedure that performs resolving DID will fallback to old wallet structure to allow using existing crypto materials with the new approach
+10. The old (current) DID API will be deprecated
+11. The new DID API will be created to allow:
+     - Registering of DID methods
+     - Creation of DIDs
+     - Building of DID Docs and DID Doc deltas with builder pattern
+     - Publishing of DID Doc and DID Doc deltas
+     - Resolving of DID Docs
+
+## Libindy API
+
+### DID resolver configuration
+
+#### Create DID Resolver instance
+
+```Rust
+// Create DID resolver instance
+//
+// By default supports peer method only. To support additional did methods
+// indy_register_indy_did_method or indy_register_did_method can be called.
+//
+// options: - some options like cache policies
+// returns - did_resolver_handle: handler ot DID Resolver instance
+pub fn indy_create_did_resolver(options) -> Future<did_resolver_handle>
+```
+
+#### Register did method based on Indy pool with did resolver
+
+```Rust
+// Register did method based on Indy pool with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'sov'
+// pool_handle: pool_handle
+// options: some options
+// returns - ()
+pub fn indy_register_indy_did_method(did_resolver_handle,
+                                     method,
+                                     pool_handle,
+                                     options) -> Future<()>
+```
+
+#### Register custom did method with did resolver
+
+```Rust
+// Register custom did method with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'custom'
+// ..callbacks: list of callbacks that define method behaviour
+// options: some options
+// returns - ()
+pub fn indy_register_did_method(did_resolver_handle,
+                                method,
+                                ..callbacks,
+                                options) -> Future<()>
+```
+
+#### Close did resolver and releases all related resources
+
+```Rust
+// Close did resolver and releases all related resources.
+//
+// did_resolver_handle: resolver handle
+// returns - ()
+pub fn indy_close_did_resolver(did_resolver_handle) -> Future<()>
+```
+
+### Resolving DID Doc
+
+#### Resolve DID Doc for DID
+
+```Rust
+// Resolve DID Doc for DID.
+//
+// did_resolver_handle: resolver handle
+// did: did to resolve
+// options: some options, like cache behaviour
+// returns - did_doc: resolved DID Doc
+pub fn indy_resolve_did_doc(did_resolver_handle,
+                            did,
+                            options) -> Future<did_doc>
+```
+
+### DID and DID keys creation
+
+#### Creates a new DID
+
+```Rust
+// Create a new DID.
+//
+// Note: It doesn't create any records in the wallet.
+//
+// did_resolver_handle: resolver handle
+// method: did method to use
+// options: some options
+// returns - did: Generated DID
+pub fn indy_create_did(did_resolver_handle,",211,2019-03-06 07:47:02,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262822988,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262822988,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,I didn't get the question. The DID is one of the arguments for DID DOC Builder.,a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-06 07:50:23,262823832,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.
+    - Local DID Doc copy is never updated explicitly.
+    - If a change to DID Doc is needed, the corresponding txn is created and sent to the Ledger.
+    - Different policies can be supported for updating the current DID DOC copy:
+      - The default one may just go to the Ledger every time before accessing the DID/DIDDoc. For example, if edge wants
+        to pack a message, it goes to the Ledger, gets the latest DID Doc, updates the local copy, and uses the local copy
+        for packing.
+      - Other policies may update it by timeout, or update by getting notifications from the Ledger/microledger
+3. In communication between Agents:
+    - DID Doc is never passed from one Agent (Alice) to another (Bob)
+    - DID is the only thing which is passed
+    - The receiver resolves the DID looking at the did method and going to the corresponding ledger (public or micro)
+    - This will allow communication between old agents (not supporting DID Doc) and new ones using the new approach
+4. The Ledger level is opaque. It doesn’t matter if this is public or micro ledger. Exact publishing and resolving strategy are
+   defined by a pluggable Resolvers and doesn’t affect workflows.
+5. To support DID Doc new transactions will be added to Indy Ledger:
+    - DID_DOC
+      - Consists of `did` and `doc`
+      - The ‘doc’ fields is a map of the form {field_id -> field} where field_id is a unique identifier of a field in the doc, and field is one of the fields (either array or a single-value)
+      - The following fields will be there (see [sovrin-did-method](https://sovrin-foundation.github.io/sovrin/spec/did-method-spec-template.html#sovrin-did-method):
+         - Public keys
+         - Services
+         - Authentication
+         - etc.
+    - DID_DOC_DELTA
+       - An array of the following values:
+       - Field_id
+       - Operation (ADD/REMOVE/EDIT)
+       - New value (or id of removed value)
+6. DID DOC Updates
+    - Will be done incrementally as requests to the Ledger via DID DOC Deltas
+    - Ledger will be responsible for validation (authentication and authorizations checks) and merging the incremental updates (DID DOC Deltas) to the DID DOC state
+7. Support of multiple did methods
+    - Will be done via Resolvers that can be registered by applications
+    - There will be default resolver for 'peer' (microledger based) method
+    - There will be out-of-the-box support of methods based on Indy ledgers with minumum configuration (SLN, STN and etc...)
+8. Publishing existing DID/DID DOC to another Ledger/microledger
+    - Will be done via explicit export method
+9. Procedure that performs resolving DID will fallback to old wallet structure to allow using existing crypto materials with the new approach
+10. The old (current) DID API will be deprecated
+11. The new DID API will be created to allow:
+     - Registering of DID methods
+     - Creation of DIDs
+     - Building of DID Docs and DID Doc deltas with builder pattern
+     - Publishing of DID Doc and DID Doc deltas
+     - Resolving of DID Docs
+
+## Libindy API
+
+### DID resolver configuration
+
+#### Create DID Resolver instance
+
+```Rust
+// Create DID resolver instance
+//
+// By default supports peer method only. To support additional did methods
+// indy_register_indy_did_method or indy_register_did_method can be called.
+//
+// options: - some options like cache policies
+// returns - did_resolver_handle: handler ot DID Resolver instance
+pub fn indy_create_did_resolver(options) -> Future<did_resolver_handle>
+```
+
+#### Register did method based on Indy pool with did resolver
+
+```Rust
+// Register did method based on Indy pool with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'sov'
+// pool_handle: pool_handle
+// options: some options
+// returns - ()
+pub fn indy_register_indy_did_method(did_resolver_handle,
+                                     method,
+                                     pool_handle,
+                                     options) -> Future<()>
+```
+
+#### Register custom did method with did resolver
+
+```Rust
+// Register custom did method with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'custom'
+// ..callbacks: list of callbacks that define method behaviour
+// options: some options
+// returns - ()
+pub fn indy_register_did_method(did_resolver_handle,
+                                method,
+                                ..callbacks,
+                                options) -> Future<()>
+```
+
+#### Close did resolver and releases all related resources
+
+```Rust
+// Close did resolver and releases all related resources.
+//
+// did_resolver_handle: resolver handle
+// returns - ()
+pub fn indy_close_did_resolver(did_resolver_handle) -> Future<()>
+```
+
+### Resolving DID Doc
+
+#### Resolve DID Doc for DID
+
+```Rust
+// Resolve DID Doc for DID.
+//
+// did_resolver_handle: resolver handle
+// did: did to resolve
+// options: some options, like cache behaviour
+// returns - did_doc: resolved DID Doc
+pub fn indy_resolve_did_doc(did_resolver_handle,
+                            did,
+                            options) -> Future<did_doc>
+```
+
+### DID and DID keys creation
+
+#### Creates a new DID
+
+```Rust
+// Create a new DID.
+//
+// Note: It doesn't create any records in the wallet.
+//
+// did_resolver_handle: resolver handle
+// method: did method to use
+// options: some options
+// returns - did: Generated DID
+pub fn indy_create_did(did_resolver_handle,
+                       method,
+                       options) -> Future<did>
+```
+
+#### Create a new key pair associated with DID
+
+```Rust
+// Create a new key pair associated with DID.
+//
+// It verifies that key options are compatible with method,
+// creates and stores key in the wallet, creates and stores association
+// of this key with did.
+//
+// Note: It can produce the same data as indy_create_my_did.
+//
+// did_resolver_handle: resolver handle
+// did: did to associate with this key
+// options: some options like key type and seed
+// returns - key_json: json that describes the key. Can be passed to did
+//                     doc builder
+pub fn indy_create_did_key(did_resolver_handle,
+                           did,
+                           options) -> Future<key_json>
+```
+
+### DID Doc creation, updating and publishing
+
+#### Create a new DID Doc builder instance
+
+```Rust
+// Create a new DID Doc builder instance.
+//
+// It tries to resolve did doc for provided did and creates builder that
+// allows to modify did doc and publish it. If did doc isn't exists it
+// starts building from scratch
+//
+// did_resolver_handle: resolver handle
+// did: did to associate did doc
+// options: some options like key type and seed
+// returns - ddoc_builder_handle: did doc builder handle
+pub fn indy_create_did_doc_builder(did_resolver_handle,
+                                   did,
+                                   options) -> Future<ddoc_builder_handle>
+```
+
+#### Add new public key item to DID Doc builder
+
+```Rust
+// Add new public key item to DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.",263,2019-03-06 07:50:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262823832,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262823832,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,"This just creates a Delta. No changes to a local copy of DID DOC are made.
How exactly the local DID DOC copy (if any) is changed is defined by a different layer (see the comment with 3 layers).",a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-06 07:52:18,262824290,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.
+    - Local DID Doc copy is never updated explicitly.
+    - If a change to DID Doc is needed, the corresponding txn is created and sent to the Ledger.
+    - Different policies can be supported for updating the current DID DOC copy:
+      - The default one may just go to the Ledger every time before accessing the DID/DIDDoc. For example, if edge wants
+        to pack a message, it goes to the Ledger, gets the latest DID Doc, updates the local copy, and uses the local copy
+        for packing.
+      - Other policies may update it by timeout, or update by getting notifications from the Ledger/microledger
+3. In communication between Agents:
+    - DID Doc is never passed from one Agent (Alice) to another (Bob)
+    - DID is the only thing which is passed
+    - The receiver resolves the DID looking at the did method and going to the corresponding ledger (public or micro)
+    - This will allow communication between old agents (not supporting DID Doc) and new ones using the new approach
+4. The Ledger level is opaque. It doesn’t matter if this is public or micro ledger. Exact publishing and resolving strategy are
+   defined by a pluggable Resolvers and doesn’t affect workflows.
+5. To support DID Doc new transactions will be added to Indy Ledger:
+    - DID_DOC
+      - Consists of `did` and `doc`
+      - The ‘doc’ fields is a map of the form {field_id -> field} where field_id is a unique identifier of a field in the doc, and field is one of the fields (either array or a single-value)
+      - The following fields will be there (see [sovrin-did-method](https://sovrin-foundation.github.io/sovrin/spec/did-method-spec-template.html#sovrin-did-method):
+         - Public keys
+         - Services
+         - Authentication
+         - etc.
+    - DID_DOC_DELTA
+       - An array of the following values:
+       - Field_id
+       - Operation (ADD/REMOVE/EDIT)
+       - New value (or id of removed value)
+6. DID DOC Updates
+    - Will be done incrementally as requests to the Ledger via DID DOC Deltas
+    - Ledger will be responsible for validation (authentication and authorizations checks) and merging the incremental updates (DID DOC Deltas) to the DID DOC state
+7. Support of multiple did methods
+    - Will be done via Resolvers that can be registered by applications
+    - There will be default resolver for 'peer' (microledger based) method
+    - There will be out-of-the-box support of methods based on Indy ledgers with minumum configuration (SLN, STN and etc...)
+8. Publishing existing DID/DID DOC to another Ledger/microledger
+    - Will be done via explicit export method
+9. Procedure that performs resolving DID will fallback to old wallet structure to allow using existing crypto materials with the new approach
+10. The old (current) DID API will be deprecated
+11. The new DID API will be created to allow:
+     - Registering of DID methods
+     - Creation of DIDs
+     - Building of DID Docs and DID Doc deltas with builder pattern
+     - Publishing of DID Doc and DID Doc deltas
+     - Resolving of DID Docs
+
+## Libindy API
+
+### DID resolver configuration
+
+#### Create DID Resolver instance
+
+```Rust
+// Create DID resolver instance
+//
+// By default supports peer method only. To support additional did methods
+// indy_register_indy_did_method or indy_register_did_method can be called.
+//
+// options: - some options like cache policies
+// returns - did_resolver_handle: handler ot DID Resolver instance
+pub fn indy_create_did_resolver(options) -> Future<did_resolver_handle>
+```
+
+#### Register did method based on Indy pool with did resolver
+
+```Rust
+// Register did method based on Indy pool with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'sov'
+// pool_handle: pool_handle
+// options: some options
+// returns - ()
+pub fn indy_register_indy_did_method(did_resolver_handle,
+                                     method,
+                                     pool_handle,
+                                     options) -> Future<()>
+```
+
+#### Register custom did method with did resolver
+
+```Rust
+// Register custom did method with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'custom'
+// ..callbacks: list of callbacks that define method behaviour
+// options: some options
+// returns - ()
+pub fn indy_register_did_method(did_resolver_handle,
+                                method,
+                                ..callbacks,
+                                options) -> Future<()>
+```
+
+#### Close did resolver and releases all related resources
+
+```Rust
+// Close did resolver and releases all related resources.
+//
+// did_resolver_handle: resolver handle
+// returns - ()
+pub fn indy_close_did_resolver(did_resolver_handle) -> Future<()>
+```
+
+### Resolving DID Doc
+
+#### Resolve DID Doc for DID
+
+```Rust
+// Resolve DID Doc for DID.
+//
+// did_resolver_handle: resolver handle
+// did: did to resolve
+// options: some options, like cache behaviour
+// returns - did_doc: resolved DID Doc
+pub fn indy_resolve_did_doc(did_resolver_handle,
+                            did,
+                            options) -> Future<did_doc>
+```
+
+### DID and DID keys creation
+
+#### Creates a new DID
+
+```Rust
+// Create a new DID.
+//
+// Note: It doesn't create any records in the wallet.
+//
+// did_resolver_handle: resolver handle
+// method: did method to use
+// options: some options
+// returns - did: Generated DID
+pub fn indy_create_did(did_resolver_handle,
+                       method,
+                       options) -> Future<did>
+```
+
+#### Create a new key pair associated with DID
+
+```Rust
+// Create a new key pair associated with DID.
+//
+// It verifies that key options are compatible with method,
+// creates and stores key in the wallet, creates and stores association
+// of this key with did.
+//
+// Note: It can produce the same data as indy_create_my_did.
+//
+// did_resolver_handle: resolver handle
+// did: did to associate with this key
+// options: some options like key type and seed
+// returns - key_json: json that describes the key. Can be passed to did
+//                     doc builder
+pub fn indy_create_did_key(did_resolver_handle,
+                           did,
+                           options) -> Future<key_json>
+```
+
+### DID Doc creation, updating and publishing
+
+#### Create a new DID Doc builder instance
+
+```Rust
+// Create a new DID Doc builder instance.
+//
+// It tries to resolve did doc for provided did and creates builder that
+// allows to modify did doc and publish it. If did doc isn't exists it
+// starts building from scratch
+//
+// did_resolver_handle: resolver handle
+// did: did to associate did doc
+// options: some options like key type and seed
+// returns - ddoc_builder_handle: did doc builder handle
+pub fn indy_create_did_doc_builder(did_resolver_handle,
+                                   did,
+                                   options) -> Future<ddoc_builder_handle>
+```
+
+#### Add new public key item to DID Doc builder
+
+```Rust
+// Add new public key item to DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// key_json: key_json in format compatible with did method
+// returns - ():
+pub fn indy_did_doc_add_public_key(ddoc_builder_handle,
+                                   id,
+                                   key_json) -> Future<()>
+```
+
+#### Update public key item in DID Doc builder
+
+```Rust
+// Update public key item in DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// key_json: key_json in format compatible with did method
+// returns - ():
+pub fn indy_did_doc_update_public_key(ddoc_builder_handle,
+                                      id,
+                                      key_json) -> Future<()>
+```
+
+#### Delete public key item in DID Doc builder
+
+```Rust
+// Delete public key item in DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// Note: If key is referenced inside of DID Doc validation error will
+// be returned.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// returns - ():
+pub fn indy_did_doc_remove_public_key(ddoc_builder_handle,
+                                      id) -> Future<()>
+```
+
+#### Add new authorization item to DID Doc builder
+
+```Rust
+// Add new authorization item to DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// If no key_json is present and id references current DID this reference
+// must be exists. Otherwise validation error will be returned.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// key_json: key_json in format compatible with did method.
+// returns - ():
+pub fn indy_did_doc_add_authorization(ddoc_builder_handle,
+                                      id,
+                                      Option<key_json>) -> Future<()>
+```
+
+#### Update embedded authorization item with DID Doc builder
+
+```Rust
+// Update embedded authorization item with DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// key_json: key_json in format compatible with did method
+// returns - ():
+pub fn indy_did_doc_update_authorization(ddoc_builder_handle,
+                                         id,
+                                         Option<key_json>) -> Future<()>
+```
+
+#### Delete authorization item with DID Doc builder
+
+```Rust
+// Delete authorization item with DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// returns - ():
+pub fn indy_did_doc_remove_authorization(ddoc_builder_handle,
+                                         id) -> Future<()>
+```
+
+#### Add new service endpoint item to DID Doc builder
+
+```Rust
+// Add new service endpoint item to DID Doc builder.
+//
+// Note: id can be full DID Doc reference or path.
+// In case of path reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of service endpoint
+// endpoint_json: endpoint_json in format compatible with did method.
+// returns - ():
+pub fn indy_did_doc_add_service_endpoint(ddoc_builder_handle,
+                                         id,
+                                         endpoint_json) -> Future<()>
+```
+
+#### Update service endpoint item with DID Doc builder
+
+```Rust
+// Update service endpoint item with DID Doc builder.
+//
+// Note: id can be full DID Doc reference or path .
+// In case of path reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// endpoint_json: endpoint_json in format compatible with did method.
+// returns - ():
+pub fn indy_did_doc_update_service_endpoint(ddoc_builder_handle,
+                                            id,
+                                            endpoint_json) -> Future<()>
+```
+
+#### Delete service endpoint item with DID Doc builder
+
+```Rust
+// Delete service endpoint item with DID Doc builder.
+//
+// Note: id can be full DID Doc reference or path.
+// In case of path reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// returns - ():
+pub fn indy_did_doc_remove_service_endpoint(ddoc_builder_handle,
+                                            id) -> Future<()>
+```
+
+#### Finalize DID Doc builder and return corresonded DID Doc or DID Doc delta
+
+```Rust
+// Finalize DID Doc builder and return corresonded DID Doc or DID Doc delta.
+//
+// Note: Format of delta can be method specific.
+// In case of path reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// returns - did_doc_delta: DID Doc or DID Doc delta
+pub fn indy_did_doc_finalize(ddoc_builder_handle) -> Future<did_doc_delta>",421,2019-03-06 07:52:18,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262824290,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262824290,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/1487,https://github.com/hyperledger/indy-sdk/pull/1487,"> What is meant by ""referenced inside of DID Doc""?

@lovesh It means used in some DID Doc sections. For example, in authentication section.",a705bcd69be40652b2db43ad7b561fbd45e2ce32,2019-03-06 13:38:51,262943614,"@@ -0,0 +1,590 @@
+# DID Doc Support in Indy
+
+## Purpose
+
+The purpose of this document is to provide vision how we can integrate w3c DIDDoc specification to Indy
+infrastructure and potentially achieve some level of interoperability with 3d party solutions that also
+follow this specification.
+
+## Use Cases
+
+As an identity owner i want to:
+
+1. create a new DID and 1 or multiple related keys
+1. publish corresonded DID Doc to Public Ledger if i have sufficient rights
+1. provide DID Doc to 3d party (Trust Ancher) for publishing to Public Ledger if i have no sufficient rights
+1. publish new DID Doc to microledger
+1. add second key to the DID DOC from a different edge device
+1. rotate a key from an edge device
+1. change authentication/authorization policies from one of the devices
+1. change service endpoints from an edge device
+1. support of multiple endpoints, each working with multiple edge devices
+1. know the recent key for this edge device to be used for signature and A2A communication using this edge device
+1. know if the key on the edge device can be used to perform modification of DID Doc on the ledger/microledger
+1. have multiple keys associated with same DID on edge device
+1. know the most recent DID DOC for the other side of communication
+1. communicate if other side of communication uses a different did method:
+    - For example, communication between entities from STN and SLN
+    - For example, Communication between Indy/Sovrin and UPort
+1. know what key(s) to use for signing/packing/A2A
+1. know what key(s) to use for verification/unpacking/A2A
+1. be able to publish existing DID Doc (maybe not as is) into a different ledger/microledger
+1. be able to re-use existing crypto material in the new approach
+1. communicate with clients using old (existing) approach
+1. use different keys for A2A and client-to-ledger communication
+
+### Create new DID and DID DOC
+
+![Alt](./create-did-ddoc.svg ""Create new DID and DID DOC"")
+
+### Create key on 2nd Edge Device
+
+![Alt](./create-key-2nd-device.svg ""Create key on 2nd Edge Device"")
+
+### Rotate a key by an Edge Device who is authenticated to do the update
+
+![Alt](./rotate-key-with-auth.svg ""Rotate a key by an Edge Device who is authenticated to do the updatee"")
+
+### Rotate a key by an Edge Device who is not authenticated to do the update
+
+![Alt](./rotate-key-without-auth.svg ""Rotate a key by an Edge Device who is not authenticated to do the updatee"")
+
+### A2A Communication
+
+![Alt](./a2a.svg ""A2A Communication"")
+
+## Identity structure
+
+On Indy SDK level DID-related identity has the following structure:
+
+- DID Method
+- Id string
+- Keys (private and public) on different edge devices
+  - Private keys are not shared between devices (the only possible exception is backup)
+- Authorization, authentication and discovery meta information:
+  - Public copy on ledger as DID DOC
+  - Optional local copy or cache
+
+## Design principles
+
+1. Each edge device stores the following information for every owned DID:
+    - Fully-qualified Did - Identifies data in storages
+    - Private and public keys associated with the DID from this edge device - in Wallet
+2. Each edge device can optionally store cached local copy of DID Doc for owned DID:
+    - The current DID Doc copy is used for signing/pack.
+    - The current DID Doc copy is synchronized between devices only through the Ledger (Public or microledger).
+    - DID Doc is never sent from one device to another.
+    - Local DID Doc copy is never updated explicitly.
+    - If a change to DID Doc is needed, the corresponding txn is created and sent to the Ledger.
+    - Different policies can be supported for updating the current DID DOC copy:
+      - The default one may just go to the Ledger every time before accessing the DID/DIDDoc. For example, if edge wants
+        to pack a message, it goes to the Ledger, gets the latest DID Doc, updates the local copy, and uses the local copy
+        for packing.
+      - Other policies may update it by timeout, or update by getting notifications from the Ledger/microledger
+3. In communication between Agents:
+    - DID Doc is never passed from one Agent (Alice) to another (Bob)
+    - DID is the only thing which is passed
+    - The receiver resolves the DID looking at the did method and going to the corresponding ledger (public or micro)
+    - This will allow communication between old agents (not supporting DID Doc) and new ones using the new approach
+4. The Ledger level is opaque. It doesn’t matter if this is public or micro ledger. Exact publishing and resolving strategy are
+   defined by a pluggable Resolvers and doesn’t affect workflows.
+5. To support DID Doc new transactions will be added to Indy Ledger:
+    - DID_DOC
+      - Consists of `did` and `doc`
+      - The ‘doc’ fields is a map of the form {field_id -> field} where field_id is a unique identifier of a field in the doc, and field is one of the fields (either array or a single-value)
+      - The following fields will be there (see [sovrin-did-method](https://sovrin-foundation.github.io/sovrin/spec/did-method-spec-template.html#sovrin-did-method):
+         - Public keys
+         - Services
+         - Authentication
+         - etc.
+    - DID_DOC_DELTA
+       - An array of the following values:
+       - Field_id
+       - Operation (ADD/REMOVE/EDIT)
+       - New value (or id of removed value)
+6. DID DOC Updates
+    - Will be done incrementally as requests to the Ledger via DID DOC Deltas
+    - Ledger will be responsible for validation (authentication and authorizations checks) and merging the incremental updates (DID DOC Deltas) to the DID DOC state
+7. Support of multiple did methods
+    - Will be done via Resolvers that can be registered by applications
+    - There will be default resolver for 'peer' (microledger based) method
+    - There will be out-of-the-box support of methods based on Indy ledgers with minumum configuration (SLN, STN and etc...)
+8. Publishing existing DID/DID DOC to another Ledger/microledger
+    - Will be done via explicit export method
+9. Procedure that performs resolving DID will fallback to old wallet structure to allow using existing crypto materials with the new approach
+10. The old (current) DID API will be deprecated
+11. The new DID API will be created to allow:
+     - Registering of DID methods
+     - Creation of DIDs
+     - Building of DID Docs and DID Doc deltas with builder pattern
+     - Publishing of DID Doc and DID Doc deltas
+     - Resolving of DID Docs
+
+## Libindy API
+
+### DID resolver configuration
+
+#### Create DID Resolver instance
+
+```Rust
+// Create DID resolver instance
+//
+// By default supports peer method only. To support additional did methods
+// indy_register_indy_did_method or indy_register_did_method can be called.
+//
+// options: - some options like cache policies
+// returns - did_resolver_handle: handler ot DID Resolver instance
+pub fn indy_create_did_resolver(options) -> Future<did_resolver_handle>
+```
+
+#### Register did method based on Indy pool with did resolver
+
+```Rust
+// Register did method based on Indy pool with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'sov'
+// pool_handle: pool_handle
+// options: some options
+// returns - ()
+pub fn indy_register_indy_did_method(did_resolver_handle,
+                                     method,
+                                     pool_handle,
+                                     options) -> Future<()>
+```
+
+#### Register custom did method with did resolver
+
+```Rust
+// Register custom did method with did resolver.
+//
+// did_resolver_handle: resolver handle
+// method: method name, for example, 'custom'
+// ..callbacks: list of callbacks that define method behaviour
+// options: some options
+// returns - ()
+pub fn indy_register_did_method(did_resolver_handle,
+                                method,
+                                ..callbacks,
+                                options) -> Future<()>
+```
+
+#### Close did resolver and releases all related resources
+
+```Rust
+// Close did resolver and releases all related resources.
+//
+// did_resolver_handle: resolver handle
+// returns - ()
+pub fn indy_close_did_resolver(did_resolver_handle) -> Future<()>
+```
+
+### Resolving DID Doc
+
+#### Resolve DID Doc for DID
+
+```Rust
+// Resolve DID Doc for DID.
+//
+// did_resolver_handle: resolver handle
+// did: did to resolve
+// options: some options, like cache behaviour
+// returns - did_doc: resolved DID Doc
+pub fn indy_resolve_did_doc(did_resolver_handle,
+                            did,
+                            options) -> Future<did_doc>
+```
+
+### DID and DID keys creation
+
+#### Creates a new DID
+
+```Rust
+// Create a new DID.
+//
+// Note: It doesn't create any records in the wallet.
+//
+// did_resolver_handle: resolver handle
+// method: did method to use
+// options: some options
+// returns - did: Generated DID
+pub fn indy_create_did(did_resolver_handle,
+                       method,
+                       options) -> Future<did>
+```
+
+#### Create a new key pair associated with DID
+
+```Rust
+// Create a new key pair associated with DID.
+//
+// It verifies that key options are compatible with method,
+// creates and stores key in the wallet, creates and stores association
+// of this key with did.
+//
+// Note: It can produce the same data as indy_create_my_did.
+//
+// did_resolver_handle: resolver handle
+// did: did to associate with this key
+// options: some options like key type and seed
+// returns - key_json: json that describes the key. Can be passed to did
+//                     doc builder
+pub fn indy_create_did_key(did_resolver_handle,
+                           did,
+                           options) -> Future<key_json>
+```
+
+### DID Doc creation, updating and publishing
+
+#### Create a new DID Doc builder instance
+
+```Rust
+// Create a new DID Doc builder instance.
+//
+// It tries to resolve did doc for provided did and creates builder that
+// allows to modify did doc and publish it. If did doc isn't exists it
+// starts building from scratch
+//
+// did_resolver_handle: resolver handle
+// did: did to associate did doc
+// options: some options like key type and seed
+// returns - ddoc_builder_handle: did doc builder handle
+pub fn indy_create_did_doc_builder(did_resolver_handle,
+                                   did,
+                                   options) -> Future<ddoc_builder_handle>
+```
+
+#### Add new public key item to DID Doc builder
+
+```Rust
+// Add new public key item to DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// key_json: key_json in format compatible with did method
+// returns - ():
+pub fn indy_did_doc_add_public_key(ddoc_builder_handle,
+                                   id,
+                                   key_json) -> Future<()>
+```
+
+#### Update public key item in DID Doc builder
+
+```Rust
+// Update public key item in DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// ddoc_builder_handle: builder handle
+// id: identifier of key
+// key_json: key_json in format compatible with did method
+// returns - ():
+pub fn indy_did_doc_update_public_key(ddoc_builder_handle,
+                                      id,
+                                      key_json) -> Future<()>
+```
+
+#### Delete public key item in DID Doc builder
+
+```Rust
+// Delete public key item in DID Doc builder.
+//
+// Note: id can be full DID Doc reference or fragment.
+// In case of fragment reference will be related to current DID.
+//
+// Note: If key is referenced inside of DID Doc validation error will",299,2019-03-06 13:39:10,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262943614,https://github.com/hyperledger/indy-sdk/pull/1487#discussion_r262943614,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1479,https://github.com/hyperledger/indy-sdk/pull/1479,"suggest adding const dictionary like:
`extention = {""darwin"": "".dylib"", ""linux"": "".so"", ""win32"": "".dll""}`",5d1a0371f32cac5177a0366f3a76dbb96b5a2a72,2019-02-18 06:00:19,257565445,"@@ -27,7 +28,7 @@
 
 async def main():
 
-    payment_plugin = cdll.LoadLibrary(""libnullpay.so"")
+    payment_plugin = cdll.LoadLibrary(""libnullpay.dylib"" if platform.system() == 'Darwin' else ""libnullpay.so"")",,2019-03-06 08:34:17,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/257565445,https://github.com/hyperledger/indy-sdk/pull/1479#discussion_r257565445,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1479,https://github.com/hyperledger/indy-sdk/pull/1479,"Thanks for review, I've just noticed there's already `file_ext()` to determine the postfix in demo_utils, so I've refactored it a bit and reused.",5d1a0371f32cac5177a0366f3a76dbb96b5a2a72,2019-03-04 11:12:39,262016088,"@@ -27,7 +28,7 @@
 
 async def main():
 
-    payment_plugin = cdll.LoadLibrary(""libnullpay.so"")
+    payment_plugin = cdll.LoadLibrary(""libnullpay.dylib"" if platform.system() == 'Darwin' else ""libnullpay.so"")",,2019-03-06 08:34:17,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262016088,https://github.com/hyperledger/indy-sdk/pull/1479#discussion_r262016088,Patrik-Stas
https://github.com/hyperledger/indy-sdk/pull/1474,https://github.com/hyperledger/indy-sdk/pull/1474,"you can use `if let Some` to avoid inner match here.
like
```
    if let Some(attr) = proof_req.requested_attributes.get(attr_name) {
        Ok(attr.non_revoked.clone().or(proof_req.non_revoked.clone().or(None)))
    } else if let Some(attr) = proof_req.requested_predicates.get(attr_name) {
        // Handle case for predicates
        Ok(attr.non_revoked.clone().or(proof_req.non_revoked.clone().or(None)))
    } else {
        Err(VcxError::from_msg(VcxErrorKind::InvalidProofCredentialData, format!(""Attribute not found for: {}"", attr_name)))
    }
``` ",56d9964da5b358a2e36c493c8ad0788802566315,2019-03-15 06:32:59,265862423,"@@ -127,12 +127,22 @@ fn credential_def_identifiers(credentials: &str, proof_req: &ProofRequestData) -
 }
 
 fn _get_revocation_interval(attr_name: &str, proof_req: &ProofRequestData) -> VcxResult<Option<NonRevokedInterval>> {
-    let attr = proof_req.requested_attributes.get(attr_name)
-        .ok_or(VcxError::from_msg(VcxErrorKind::InvalidProofCredentialData, format!(""Attribute not found for: {}"", attr_name)))?;
-
-    Ok(attr.non_revoked.clone().or(proof_req.non_revoked.clone().or(None)))
-
-    // Todo: Handle case for predicates
+    match proof_req.requested_attributes.get(attr_name) {
+        Some(attr) => {
+            return Ok(attr.non_revoked.clone().or(proof_req.non_revoked.clone().or(None)));
+        },
+        None => {
+            // Handle case for predicates
+            match proof_req.requested_predicates.get(attr_name) {
+                Some (attr) => {
+                    return Ok(attr.non_revoked.clone().or(proof_req.non_revoked.clone().or(None)));
+                },
+                None => {
+                    return Err(VcxError::from_msg(VcxErrorKind::InvalidProofCredentialData, format!(""Attribute not found for: {}"", attr_name)));
+                }
+            }
+        }
+    }",17,2019-03-18 15:26:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/265862423,https://github.com/hyperledger/indy-sdk/pull/1474#discussion_r265862423,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1474,https://github.com/hyperledger/indy-sdk/pull/1474,`revealed` is redundant for predicates,56d9964da5b358a2e36c493c8ad0788802566315,2019-03-15 06:37:15,265863117,"@@ -300,21 +310,35 @@ impl DisclosedProof {
         Ok(rtn.to_string())
     }
 
-    fn build_requested_credentials_json(&self, credentials_identifiers: &Vec<CredInfo>, self_attested_attrs: &str) -> VcxResult<String> {
+    fn build_requested_credentials_json(&self, 
+                                        credentials_identifiers: &Vec<CredInfo>, 
+                                        self_attested_attrs: &str,
+                                        proof_req: &ProofRequestData) -> VcxResult<String> {
         let mut rtn: Value = json!({
               ""self_attested_attributes"":{},
               ""requested_attributes"":{},
               ""requested_predicates"":{}
         });
-        //Todo: need to do same for predicates and self_attested
-        //Todo: need to handle if the attribute is not revealed
+        // do same for predicates and self_attested
         if let Value::Object(ref mut map) = rtn[""requested_attributes""] {
             for ref cred_info in credentials_identifiers {
-                let insert_val = json!({""cred_id"": cred_info.referent, ""revealed"": true, ""timestamp"": cred_info.timestamp});
-                map.insert(cred_info.requested_attr.to_owned(), insert_val);
+                if let Some(ref attr) = proof_req.requested_attributes.get(&cred_info.requested_attr) {
+                    let insert_val = json!({""cred_id"": cred_info.referent, ""revealed"": true, ""timestamp"": cred_info.timestamp});",43,2019-03-18 15:26:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/265863117,https://github.com/hyperledger/indy-sdk/pull/1474#discussion_r265863117,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1474,https://github.com/hyperledger/indy-sdk/pull/1474,"there is unused `RequestedCreds` structure with the outdated format in this file.
maybe we better actualize and use it instead of serde Value?",56d9964da5b358a2e36c493c8ad0788802566315,2019-03-15 06:39:26,265863466,"@@ -300,21 +310,35 @@ impl DisclosedProof {
         Ok(rtn.to_string())
     }
 
-    fn build_requested_credentials_json(&self, credentials_identifiers: &Vec<CredInfo>, self_attested_attrs: &str) -> VcxResult<String> {
+    fn build_requested_credentials_json(&self, 
+                                        credentials_identifiers: &Vec<CredInfo>, 
+                                        self_attested_attrs: &str,
+                                        proof_req: &ProofRequestData) -> VcxResult<String> {
         let mut rtn: Value = json!({",30,2019-03-18 15:26:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/265863466,https://github.com/hyperledger/indy-sdk/pull/1474#discussion_r265863466,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1474,https://github.com/hyperledger/indy-sdk/pull/1474,I believe all ProofRequestData fields can be public and we can just create an object without intermediate value.,56d9964da5b358a2e36c493c8ad0788802566315,2019-03-15 06:54:24,265865894,"@@ -829,7 +856,22 @@ mod tests {
         });
 
         let proof: DisclosedProof = Default::default();
-        let requested_credential = proof.build_requested_credentials_json(&creds, &self_attested_attrs).unwrap();
+        let proof_req = json!({
+            ""nonce"": ""123432421212"",
+            ""name"": ""proof_req_1"",
+            ""version"": ""0.1"",
+            ""requested_attributes"": {
+                ""height_1"": {
+                    ""name"": ""height_1"",
+                    ""non_revoked"":  {""from"": 123, ""to"": 456}
+                },
+                ""zip_2"": { ""name"": ""zip_2"" }
+            },
+            ""requested_predicates"": {},
+            ""non_revoked"": {""from"": 098, ""to"": 123}
+        });
+        let proof_req: ProofRequestData = serde_json::from_value(proof_req).unwrap();",97,2019-03-18 15:26:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/265865894,https://github.com/hyperledger/indy-sdk/pull/1474#discussion_r265865894,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1474,https://github.com/hyperledger/indy-sdk/pull/1474,What about others vcx wrapper? Do we need updates there?,56d9964da5b358a2e36c493c8ad0788802566315,2019-03-15 07:06:15,265867942,"@@ -24,7 +24,7 @@ def proof_state(self, x):
         self._proof_state = x
 
     @staticmethod
-    async def create(source_id: str, name: str, requested_attrs: list, revocation_interval: dict):",4,2019-03-18 15:26:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/265867942,https://github.com/hyperledger/indy-sdk/pull/1474#discussion_r265867942,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1474,https://github.com/hyperledger/indy-sdk/pull/1474,"Probably, but the use of the serde Value is not part of the change I made (this part of the code is a year old) and is a bigger change than I was planning to get into adding the predicate support ...",56d9964da5b358a2e36c493c8ad0788802566315,2019-03-15 19:51:32,266125788,"@@ -300,21 +310,35 @@ impl DisclosedProof {
         Ok(rtn.to_string())
     }
 
-    fn build_requested_credentials_json(&self, credentials_identifiers: &Vec<CredInfo>, self_attested_attrs: &str) -> VcxResult<String> {
+    fn build_requested_credentials_json(&self, 
+                                        credentials_identifiers: &Vec<CredInfo>, 
+                                        self_attested_attrs: &str,
+                                        proof_req: &ProofRequestData) -> VcxResult<String> {
         let mut rtn: Value = json!({",30,2019-03-18 15:26:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/266125788,https://github.com/hyperledger/indy-sdk/pull/1474#discussion_r266125788,ianco
https://github.com/hyperledger/indy-sdk/pull/1474,https://github.com/hyperledger/indy-sdk/pull/1474,"This is how ProofRequestData is handled consistently in all unit tests.  The nonce, name and version aren't explicitly ""pub"".",56d9964da5b358a2e36c493c8ad0788802566315,2019-03-15 20:06:42,266130184,"@@ -829,7 +856,22 @@ mod tests {
         });
 
         let proof: DisclosedProof = Default::default();
-        let requested_credential = proof.build_requested_credentials_json(&creds, &self_attested_attrs).unwrap();
+        let proof_req = json!({
+            ""nonce"": ""123432421212"",
+            ""name"": ""proof_req_1"",
+            ""version"": ""0.1"",
+            ""requested_attributes"": {
+                ""height_1"": {
+                    ""name"": ""height_1"",
+                    ""non_revoked"":  {""from"": 123, ""to"": 456}
+                },
+                ""zip_2"": { ""name"": ""zip_2"" }
+            },
+            ""requested_predicates"": {},
+            ""non_revoked"": {""from"": 098, ""to"": 123}
+        });
+        let proof_req: ProofRequestData = serde_json::from_value(proof_req).unwrap();",97,2019-03-18 15:26:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/266130184,https://github.com/hyperledger/indy-sdk/pull/1474#discussion_r266130184,ianco
https://github.com/hyperledger/indy-sdk/pull/1474,https://github.com/hyperledger/indy-sdk/pull/1474,"Good catch, I'm not familiar with any of the other wrappers (Java, ios, node) but they would need a similar change.

I don't have a local environment that I can test changes to any of these wrappers.
",56d9964da5b358a2e36c493c8ad0788802566315,2019-03-15 20:11:14,266131445,"@@ -24,7 +24,7 @@ def proof_state(self, x):
         self._proof_state = x
 
     @staticmethod
-    async def create(source_id: str, name: str, requested_attrs: list, revocation_interval: dict):",4,2019-03-18 15:26:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/266131445,https://github.com/hyperledger/indy-sdk/pull/1474#discussion_r266131445,ianco
https://github.com/hyperledger/indy-sdk/pull/1474,https://github.com/hyperledger/indy-sdk/pull/1474,ok. agree. I believe we can skip it ,56d9964da5b358a2e36c493c8ad0788802566315,2019-03-18 14:55:38,266480466,"@@ -300,21 +310,35 @@ impl DisclosedProof {
         Ok(rtn.to_string())
     }
 
-    fn build_requested_credentials_json(&self, credentials_identifiers: &Vec<CredInfo>, self_attested_attrs: &str) -> VcxResult<String> {
+    fn build_requested_credentials_json(&self, 
+                                        credentials_identifiers: &Vec<CredInfo>, 
+                                        self_attested_attrs: &str,
+                                        proof_req: &ProofRequestData) -> VcxResult<String> {
         let mut rtn: Value = json!({",30,2019-03-18 15:26:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/266480466,https://github.com/hyperledger/indy-sdk/pull/1474#discussion_r266480466,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1470,https://github.com/hyperledger/indy-sdk/pull/1470,it's the second usage of `tails_writer_config` by Issuer. Let's add it as a field for Issuer.,930f0b793b9ba0d9a4f79f0bc92045149ca87bb7,2019-02-11 05:49:15,255385344,"@@ -45,481 +45,533 @@ use utils::domain::anoncreds::revocation_registry::RevocationRegistry;
 
 use std::thread;
 
-#[cfg(feature = ""revocation_tests"")]
-#[test]
-fn anoncreds_revocation_interaction_test_issuance_by_demand() {
-    utils::setup();
 
-    // Open Pool
-    let pool_handle = pool::create_and_open_pool_ledger(POOL).unwrap();
+struct Pool{
+    pool_handle : i32
+}
 
-    // Issuer creates wallet, gets wallet handle
-    let issuer_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
 
-    // Issuer create DID
-    let (issuer_did, _) = did::create_store_and_publish_my_did_from_trustee(issuer_wallet_handle, pool_handle).unwrap();
+struct Issuer{
+    issuer_wallet_handle: i32,
+    issuer_did : String,
 
-    // Prover creates wallet, gets wallet handle
-    let prover_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+    schema_id : String,
+    cred_def_id : String,
+    rev_reg_id : String,
 
-    // Prover create DID
-    let (prover_did, prover_verkey) = did::create_my_did(prover_wallet_handle, ""{}"").unwrap();
+    revoc_registry_config: String
+}
 
-    // Issuer publish Prover DID
-    let nym_request = ledger::build_nym_request(&issuer_did, &prover_did, Some(&prover_verkey), None, None).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
 
-    // ISSUER post to Ledger Schema, CredentialDefinition, RevocationRegistry
+struct Prover{
 
-    // Issuer creates Schema
-    let (schema_id, schema_json) = anoncreds::issuer_create_schema(&issuer_did,
-                                                                        GVT_SCHEMA_NAME,
-                                                                        SCHEMA_VERSION,
-                                                                        GVT_SCHEMA_ATTRIBUTES).unwrap();
-
-    // !!IMPORTANT!!
-    // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
-    // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
-
-    // Issuer posts Schema to Ledger
-    let schema_request = ledger::build_schema_request(&issuer_did, &schema_json).unwrap();
-    let schema_response = ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &schema_request).unwrap();
-
-    // Issuer gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&issuer_did), &schema_id).unwrap();
-    let get_schema_response = ledger::submit_request_with_retries(pool_handle, &get_schema_request, &schema_response).unwrap();
-    let (_, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Issuer creates CredentialDefinition
-    let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(issuer_wallet_handle,
-                                                                                           &issuer_did,
-                                                                                           &schema_json,
-                                                                                           TAG_1,
-                                                                                           None,
-                                                                                           Some(&anoncreds::revocation_cred_def_config())).unwrap();
-
-    // Issuer post CredentialDefinition to Ledger
-    let cred_def_request = ledger::build_cred_def_txn(&issuer_did, &cred_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &cred_def_request).unwrap();
-
-    // Issuer creates RevocationRegistry
-    let tails_writer_config = anoncreds::tails_writer_config();
-    let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
-
-    let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
-        anoncreds::issuer_create_and_store_revoc_reg(issuer_wallet_handle,
-                                                               &issuer_did,
-                                                               None,
-                                                               TAG_1,
-                                                               &cred_def_id,
-                                                               r#""{""max_cred_num"":5, ""issuance_type"":""ISSUANCE_ON_DEMAND""}""#,
-                                                               tails_writer_handle).unwrap();
-
-    // Issuer posts RevocationRegistryDefinition to Ledger
-    let rev_reg_def_request = ledger::build_revoc_reg_def_request(&issuer_did, &rev_reg_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_def_request).unwrap();
-
-    // Issuer posts RevocationRegistryEntry to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &rev_reg_entry_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
+    wallet_handle : i32,
+    did: String,
+    verkey : String,
+    master_secret_id : String,
+    cred_def_id : Option<String>,
+    cred_req_metadata_json : Option<String>
 
+}
 
-    // Issuance Credential for Prover
 
-    // Prover creates Master Secret
-    anoncreds::prover_create_master_secret(prover_wallet_handle, COMMON_MASTER_SECRET).unwrap();
+struct Verifier{
+    proof_request : String
+}
 
-    // Issuer creates Credential Offer
-    let cred_offer_json = anoncreds::issuer_create_credential_offer(issuer_wallet_handle, &cred_def_id).unwrap();
-    let cred_offer: CredentialOffer = serde_json::from_str(&cred_offer_json).unwrap();
-
-    // Prover gets CredentialDefinition from Ledger
-    let get_cred_def_request = ledger::build_get_cred_def_request(Some(&prover_did), &cred_offer.cred_def_id).unwrap();
-    let get_cred_def_response = ledger::submit_request(pool_handle, &get_cred_def_request).unwrap();
-    let (cred_def_id, cred_def_json) = ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap();
-
-    // Prover creates Credential Request
-    let (cred_req_json, cred_req_metadata_json) = anoncreds::prover_create_credential_req(prover_wallet_handle,
-                                                                                               &prover_did,
-                                                                                               &cred_offer_json,
-                                                                                               &cred_def_json,
-                                                                                               COMMON_MASTER_SECRET).unwrap();
-
-    // Issuer creates TailsReader
-    let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
-
-    // Issuer creates Credential
-    let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(issuer_wallet_handle,
-                                                                                                  &cred_offer_json,
-                                                                                                  &cred_req_json,
-                                                                                                  &anoncreds::gvt_credential_values_json(),
-                                                                                                  Some(&rev_reg_id),
-                                                                                                  Some(blob_storage_reader_handle)).unwrap();
-    let revoc_reg_delta_json = revoc_reg_delta_json.unwrap();
-    let cred_rev_id = cred_rev_id.unwrap();
-
-    // Issuer posts RevocationRegistryDelta to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &revoc_reg_delta_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
-
-    // Prover gets RevocationRegistryDefinition
-    let credential: Credential = serde_json::from_str(&cred_json).unwrap();
-    let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(Some(&prover_did), &credential.rev_reg_id.unwrap()).unwrap();
-    let get_rev_reg_def_response = ledger::submit_request(pool_handle, &get_rev_reg_def_request).unwrap();
-    let (_, revoc_reg_def_json) = ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap();
-
-    // Prover store received Credential
-    anoncreds::prover_store_credential(prover_wallet_handle,
-                                            CREDENTIAL1_ID,
-                                            &cred_req_metadata_json,
-                                            &cred_json,
-                                            &cred_def_json,
-                                            Some(&revoc_reg_def_json)).unwrap();
-
-    let credentials = anoncreds::prover_get_credentials(prover_wallet_handle, &json!({""schema_name"": GVT_SCHEMA_NAME}).to_string()).unwrap();
-    let credentials: Vec<serde_json::Value> = serde_json::from_str(&credentials).unwrap();
-    assert_eq!(credentials.len(), 1);
 
-    // Verifying Prover Credential
-    thread::sleep(std::time::Duration::from_secs(3));
+impl Pool {
 
-    let to = time::get_time().sec as u64;
 
-    let proof_request = json!({
-           ""nonce"":""123432421212"",
-           ""name"":""proof_req_1"",
-           ""version"":""0.1"",
-           ""requested_attributes"": json!({
-               ""attr1_referent"": json!({
-                   ""name"":""name""
-               })
-           }),
-           ""requested_predicates"": json!({
-               ""predicate1_referent"": json!({ ""name"":""age"", ""p_type"":"">="", ""p_value"":18 })
-           }),
-           ""non_revoked"": json!({ ""to"": to.clone() })
-        }).to_string();
+    pub fn new() -> Pool {
+        Pool{ pool_handle : pool::create_and_open_pool_ledger(POOL).unwrap() }
+    }
 
-    // Prover gets Credentials for Proof Request
-    let credentials_json = anoncreds::prover_get_credentials_for_proof_req(prover_wallet_handle, &proof_request).unwrap();
-    let cred_info = anoncreds::get_credential_for_attr_referent(&credentials_json, ""attr1_referent"");
-
-    // Prover gets RevocationRegistryDelta from Ledger
-    let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(Some(&prover_did), &cred_info.rev_reg_id.clone().unwrap(), None, to).unwrap();
-    let get_rev_reg_delta_response = ledger::submit_request(pool_handle, &get_rev_reg_delta_request).unwrap();
-    let (rev_reg_id, revoc_reg_delta_json, timestamp) = ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap();
-
-    // Prover creates RevocationState
-    let rev_state_json = anoncreds::create_revocation_state(blob_storage_reader_handle,
-                                                                 &revoc_reg_def_json,
-                                                                 &revoc_reg_delta_json,
-                                                                 timestamp,
-                                                                 &cred_info.cred_rev_id.clone().unwrap()).unwrap();
-
-    // Prover gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&prover_did), &cred_info.schema_id).unwrap();
-    let get_schema_response = ledger::submit_request(pool_handle, &get_schema_request).unwrap();
-    let (schema_id, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Prover creates Proof
-    let requested_credentials_json = json!({
-             ""self_attested_attributes"": json!({}),
-             ""requested_attributes"": json!({
-                ""attr1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp,  ""revealed"":true })
-             }),
-             ""requested_predicates"": json!({
-                ""predicate1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp })
-             })
-        }).to_string();
+    pub fn close(self) {
+        let _ = pool::close(self.pool_handle);
+    }
+
+
+    pub fn submit_nym(&self, issuer_did: &str, issuer_wallet_handle: i32, prover_did: &str, prover_verkey : Option<&str>)
+    {
+        let nym_request = ledger::build_nym_request(issuer_did, prover_did, prover_verkey, None, None).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
+    }
+
+    pub fn submit_schema(&self, issuer_did: &str, issuer_wallet_handle: i32, schema_json: &str) -> String {
+        let schema_request = ledger::build_schema_request(issuer_did, schema_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &schema_request).unwrap()
+    }
+
+    pub fn get_schema(&self, did: Option<&str>, schema_id: &str) -> (String, String){
+        let get_schema_request = ledger::build_get_schema_request(did, schema_id).unwrap();
+        let get_schema_response = ledger::submit_request(self.pool_handle, &get_schema_request).unwrap();
+        ledger::parse_get_schema_response(&get_schema_response).unwrap()
+
+    }
+
+    pub fn submit_cred_def(&self, issuer_did: &str, issuer_wallet_handle: i32, cred_def_json: &str) -> String {
+        let cred_def_request = ledger::build_cred_def_txn(issuer_did, cred_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &cred_def_request).unwrap()
+
+    }
+
+    pub fn get_cred_def(&self, did : Option<&str>, cred_def_id : &str ) -> (String, String) /* (cred_def_id, cred_def_json) */{
+        let get_cred_def_request = ledger::build_get_cred_def_request(did, cred_def_id).unwrap();
+        let get_cred_def_response = ledger::submit_request(self.pool_handle, &get_cred_def_request).unwrap();
+        ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_def(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_def_json : &str) -> String {
+        let rev_reg_def_request = ledger::build_revoc_reg_def_request(issuer_did, rev_reg_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_def_request).unwrap()
+    }
+
+    pub fn get_revoc_reg_def(&self, did: Option<&str>, revoc_reg_def_id : &str) -> (String, String) /* revoc_reg_def_id, revo_reg_def_json */ {
+        let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(did, &revoc_reg_def_id).unwrap();
+        let get_rev_reg_def_response = ledger::submit_request(self.pool_handle, &get_rev_reg_def_request).unwrap();
+        ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_entry(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_id : &str, rev_reg_entry_json: &str) -> String{
+        let rev_reg_entry_request =
+            ledger::build_revoc_reg_entry_request(issuer_did, rev_reg_id, REVOC_REG_TYPE, rev_reg_entry_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_entry_request).unwrap()
+
+    }
+
+    pub fn get_revoc_reg_delta(&self, did: Option<&str>, revoc_reg_def_id : &str, from : Option<u64>, to : u64) -> (String,String, u64) /* rev_reg_id, revoc_reg_delta_json, timestamp */ {
+        let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(did, revoc_reg_def_id, from, to).unwrap();
+        let get_rev_reg_delta_response = ledger::submit_request(self.pool_handle, &get_rev_reg_delta_request).unwrap();
+        ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap()
+    }
+
+
+}
+
+
+impl Issuer {
+
+
+    pub fn new(pool: &Pool) -> Issuer{
+
+        let wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+        Issuer {
+            // Issuer creates wallet, gets wallet handle
+            issuer_wallet_handle: wallet_handle,
+
+            // Issuer create DID
+            issuer_did: did::create_store_and_publish_my_did_from_trustee(wallet_handle, pool.pool_handle).unwrap().0,
+
+            schema_id: String::new(),
+            rev_reg_id : String::new(),
+            cred_def_id : String::new(),
+
+            revoc_registry_config : String::new()
+
+        }
+    }
+
+    // creates schema , credential definition and revocation registry
+    pub fn create_initial_ledger_state(& mut self, pool : &Pool, revoc_registry_config : &str)
+    {
+
+        self.revoc_registry_config = String::from(revoc_registry_config);
+
+        // Issuer creates Schema
+        let (schema_id, schema_json) = anoncreds::issuer_create_schema(&self.issuer_did,
+                                                                       GVT_SCHEMA_NAME,
+                                                                       SCHEMA_VERSION,
+                                                                       GVT_SCHEMA_ATTRIBUTES).unwrap();
+
+        // !!IMPORTANT!!
+        // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
+        // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
+        let _schema_response = pool.submit_schema(&self.issuer_did, self.issuer_wallet_handle,&schema_json);
+        // Issuer gets Schema from Ledger
+        let (_ , schema_json) = pool.get_schema(Some(&self.issuer_did),&schema_id);
+
+        self.schema_id = schema_id;
+
+        // Issuer creates CredentialDefinition
+        let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(self.issuer_wallet_handle,
+                                                                                          &self.issuer_did,
+                                                                                          &schema_json,
+                                                                                          TAG_1,
+                                                                                          None,
+                                                                                          Some(&anoncreds::revocation_cred_def_config())).unwrap();
+
+        // Issuer post CredentialDefinition to Ledger
+        pool.submit_cred_def(&self.issuer_did,self.issuer_wallet_handle,&cred_def_json);
+
+        self.cred_def_id = cred_def_id;
+
+        // Issuer creates RevocationRegistry
+        let tails_writer_config = anoncreds::tails_writer_config();
+        let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
 
-    let schemas_json = json!({
+        let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
+            anoncreds::issuer_create_and_store_revoc_reg(self.issuer_wallet_handle,
+                                                         &self.issuer_did,
+                                                         None,
+                                                         TAG_1,
+                                                         &self.cred_def_id,
+                                                         &self.revoc_registry_config,
+                                                         tails_writer_handle).unwrap();
+
+        // Issuer posts RevocationRegistryDefinition to Ledger
+        pool.submit_revoc_reg_def(&self.issuer_did, self.issuer_wallet_handle, &rev_reg_def_json);
+
+
+        self.rev_reg_id = rev_reg_id;
+
+        // Issuer posts RevocationRegistryEntry to Ledger
+        pool.submit_revoc_reg_entry(&self.issuer_did,self.issuer_wallet_handle, &self.rev_reg_id, &rev_reg_entry_json);
+    }
+
+    pub fn make_credential_offer(&self) -> String
+    {
+        let cred_offer_json = anoncreds::issuer_create_credential_offer(self.issuer_wallet_handle, &self.cred_def_id).unwrap();
+        cred_offer_json
+    }
+
+    pub fn issue_credential(&self, pool: &Pool, cred_offer_json: &str, cred_req_json: &str, cred_values_json: &str) -> (String, String, Option<String>)
+    {
+
+        use serde_json::Value;
+
+        let tails_writer_config = anoncreds::tails_writer_config();",,2019-02-15 14:25:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/255385344,https://github.com/hyperledger/indy-sdk/pull/1470#discussion_r255385344,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1470,https://github.com/hyperledger/indy-sdk/pull/1470,Maybe add `issuance_type` field to avoid regular parsing of config?,930f0b793b9ba0d9a4f79f0bc92045149ca87bb7,2019-02-11 05:52:01,255385552,"@@ -45,481 +45,533 @@ use utils::domain::anoncreds::revocation_registry::RevocationRegistry;
 
 use std::thread;
 
-#[cfg(feature = ""revocation_tests"")]
-#[test]
-fn anoncreds_revocation_interaction_test_issuance_by_demand() {
-    utils::setup();
 
-    // Open Pool
-    let pool_handle = pool::create_and_open_pool_ledger(POOL).unwrap();
+struct Pool{
+    pool_handle : i32
+}
 
-    // Issuer creates wallet, gets wallet handle
-    let issuer_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
 
-    // Issuer create DID
-    let (issuer_did, _) = did::create_store_and_publish_my_did_from_trustee(issuer_wallet_handle, pool_handle).unwrap();
+struct Issuer{
+    issuer_wallet_handle: i32,
+    issuer_did : String,
 
-    // Prover creates wallet, gets wallet handle
-    let prover_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+    schema_id : String,
+    cred_def_id : String,
+    rev_reg_id : String,
 
-    // Prover create DID
-    let (prover_did, prover_verkey) = did::create_my_did(prover_wallet_handle, ""{}"").unwrap();
+    revoc_registry_config: String
+}
 
-    // Issuer publish Prover DID
-    let nym_request = ledger::build_nym_request(&issuer_did, &prover_did, Some(&prover_verkey), None, None).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
 
-    // ISSUER post to Ledger Schema, CredentialDefinition, RevocationRegistry
+struct Prover{
 
-    // Issuer creates Schema
-    let (schema_id, schema_json) = anoncreds::issuer_create_schema(&issuer_did,
-                                                                        GVT_SCHEMA_NAME,
-                                                                        SCHEMA_VERSION,
-                                                                        GVT_SCHEMA_ATTRIBUTES).unwrap();
-
-    // !!IMPORTANT!!
-    // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
-    // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
-
-    // Issuer posts Schema to Ledger
-    let schema_request = ledger::build_schema_request(&issuer_did, &schema_json).unwrap();
-    let schema_response = ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &schema_request).unwrap();
-
-    // Issuer gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&issuer_did), &schema_id).unwrap();
-    let get_schema_response = ledger::submit_request_with_retries(pool_handle, &get_schema_request, &schema_response).unwrap();
-    let (_, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Issuer creates CredentialDefinition
-    let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(issuer_wallet_handle,
-                                                                                           &issuer_did,
-                                                                                           &schema_json,
-                                                                                           TAG_1,
-                                                                                           None,
-                                                                                           Some(&anoncreds::revocation_cred_def_config())).unwrap();
-
-    // Issuer post CredentialDefinition to Ledger
-    let cred_def_request = ledger::build_cred_def_txn(&issuer_did, &cred_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &cred_def_request).unwrap();
-
-    // Issuer creates RevocationRegistry
-    let tails_writer_config = anoncreds::tails_writer_config();
-    let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
-
-    let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
-        anoncreds::issuer_create_and_store_revoc_reg(issuer_wallet_handle,
-                                                               &issuer_did,
-                                                               None,
-                                                               TAG_1,
-                                                               &cred_def_id,
-                                                               r#""{""max_cred_num"":5, ""issuance_type"":""ISSUANCE_ON_DEMAND""}""#,
-                                                               tails_writer_handle).unwrap();
-
-    // Issuer posts RevocationRegistryDefinition to Ledger
-    let rev_reg_def_request = ledger::build_revoc_reg_def_request(&issuer_did, &rev_reg_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_def_request).unwrap();
-
-    // Issuer posts RevocationRegistryEntry to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &rev_reg_entry_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
+    wallet_handle : i32,
+    did: String,
+    verkey : String,
+    master_secret_id : String,
+    cred_def_id : Option<String>,
+    cred_req_metadata_json : Option<String>
 
+}
 
-    // Issuance Credential for Prover
 
-    // Prover creates Master Secret
-    anoncreds::prover_create_master_secret(prover_wallet_handle, COMMON_MASTER_SECRET).unwrap();
+struct Verifier{
+    proof_request : String
+}
 
-    // Issuer creates Credential Offer
-    let cred_offer_json = anoncreds::issuer_create_credential_offer(issuer_wallet_handle, &cred_def_id).unwrap();
-    let cred_offer: CredentialOffer = serde_json::from_str(&cred_offer_json).unwrap();
-
-    // Prover gets CredentialDefinition from Ledger
-    let get_cred_def_request = ledger::build_get_cred_def_request(Some(&prover_did), &cred_offer.cred_def_id).unwrap();
-    let get_cred_def_response = ledger::submit_request(pool_handle, &get_cred_def_request).unwrap();
-    let (cred_def_id, cred_def_json) = ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap();
-
-    // Prover creates Credential Request
-    let (cred_req_json, cred_req_metadata_json) = anoncreds::prover_create_credential_req(prover_wallet_handle,
-                                                                                               &prover_did,
-                                                                                               &cred_offer_json,
-                                                                                               &cred_def_json,
-                                                                                               COMMON_MASTER_SECRET).unwrap();
-
-    // Issuer creates TailsReader
-    let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
-
-    // Issuer creates Credential
-    let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(issuer_wallet_handle,
-                                                                                                  &cred_offer_json,
-                                                                                                  &cred_req_json,
-                                                                                                  &anoncreds::gvt_credential_values_json(),
-                                                                                                  Some(&rev_reg_id),
-                                                                                                  Some(blob_storage_reader_handle)).unwrap();
-    let revoc_reg_delta_json = revoc_reg_delta_json.unwrap();
-    let cred_rev_id = cred_rev_id.unwrap();
-
-    // Issuer posts RevocationRegistryDelta to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &revoc_reg_delta_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
-
-    // Prover gets RevocationRegistryDefinition
-    let credential: Credential = serde_json::from_str(&cred_json).unwrap();
-    let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(Some(&prover_did), &credential.rev_reg_id.unwrap()).unwrap();
-    let get_rev_reg_def_response = ledger::submit_request(pool_handle, &get_rev_reg_def_request).unwrap();
-    let (_, revoc_reg_def_json) = ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap();
-
-    // Prover store received Credential
-    anoncreds::prover_store_credential(prover_wallet_handle,
-                                            CREDENTIAL1_ID,
-                                            &cred_req_metadata_json,
-                                            &cred_json,
-                                            &cred_def_json,
-                                            Some(&revoc_reg_def_json)).unwrap();
-
-    let credentials = anoncreds::prover_get_credentials(prover_wallet_handle, &json!({""schema_name"": GVT_SCHEMA_NAME}).to_string()).unwrap();
-    let credentials: Vec<serde_json::Value> = serde_json::from_str(&credentials).unwrap();
-    assert_eq!(credentials.len(), 1);
 
-    // Verifying Prover Credential
-    thread::sleep(std::time::Duration::from_secs(3));
+impl Pool {
 
-    let to = time::get_time().sec as u64;
 
-    let proof_request = json!({
-           ""nonce"":""123432421212"",
-           ""name"":""proof_req_1"",
-           ""version"":""0.1"",
-           ""requested_attributes"": json!({
-               ""attr1_referent"": json!({
-                   ""name"":""name""
-               })
-           }),
-           ""requested_predicates"": json!({
-               ""predicate1_referent"": json!({ ""name"":""age"", ""p_type"":"">="", ""p_value"":18 })
-           }),
-           ""non_revoked"": json!({ ""to"": to.clone() })
-        }).to_string();
+    pub fn new() -> Pool {
+        Pool{ pool_handle : pool::create_and_open_pool_ledger(POOL).unwrap() }
+    }
 
-    // Prover gets Credentials for Proof Request
-    let credentials_json = anoncreds::prover_get_credentials_for_proof_req(prover_wallet_handle, &proof_request).unwrap();
-    let cred_info = anoncreds::get_credential_for_attr_referent(&credentials_json, ""attr1_referent"");
-
-    // Prover gets RevocationRegistryDelta from Ledger
-    let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(Some(&prover_did), &cred_info.rev_reg_id.clone().unwrap(), None, to).unwrap();
-    let get_rev_reg_delta_response = ledger::submit_request(pool_handle, &get_rev_reg_delta_request).unwrap();
-    let (rev_reg_id, revoc_reg_delta_json, timestamp) = ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap();
-
-    // Prover creates RevocationState
-    let rev_state_json = anoncreds::create_revocation_state(blob_storage_reader_handle,
-                                                                 &revoc_reg_def_json,
-                                                                 &revoc_reg_delta_json,
-                                                                 timestamp,
-                                                                 &cred_info.cred_rev_id.clone().unwrap()).unwrap();
-
-    // Prover gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&prover_did), &cred_info.schema_id).unwrap();
-    let get_schema_response = ledger::submit_request(pool_handle, &get_schema_request).unwrap();
-    let (schema_id, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Prover creates Proof
-    let requested_credentials_json = json!({
-             ""self_attested_attributes"": json!({}),
-             ""requested_attributes"": json!({
-                ""attr1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp,  ""revealed"":true })
-             }),
-             ""requested_predicates"": json!({
-                ""predicate1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp })
-             })
-        }).to_string();
+    pub fn close(self) {
+        let _ = pool::close(self.pool_handle);
+    }
+
+
+    pub fn submit_nym(&self, issuer_did: &str, issuer_wallet_handle: i32, prover_did: &str, prover_verkey : Option<&str>)
+    {
+        let nym_request = ledger::build_nym_request(issuer_did, prover_did, prover_verkey, None, None).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
+    }
+
+    pub fn submit_schema(&self, issuer_did: &str, issuer_wallet_handle: i32, schema_json: &str) -> String {
+        let schema_request = ledger::build_schema_request(issuer_did, schema_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &schema_request).unwrap()
+    }
+
+    pub fn get_schema(&self, did: Option<&str>, schema_id: &str) -> (String, String){
+        let get_schema_request = ledger::build_get_schema_request(did, schema_id).unwrap();
+        let get_schema_response = ledger::submit_request(self.pool_handle, &get_schema_request).unwrap();
+        ledger::parse_get_schema_response(&get_schema_response).unwrap()
+
+    }
+
+    pub fn submit_cred_def(&self, issuer_did: &str, issuer_wallet_handle: i32, cred_def_json: &str) -> String {
+        let cred_def_request = ledger::build_cred_def_txn(issuer_did, cred_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &cred_def_request).unwrap()
+
+    }
+
+    pub fn get_cred_def(&self, did : Option<&str>, cred_def_id : &str ) -> (String, String) /* (cred_def_id, cred_def_json) */{
+        let get_cred_def_request = ledger::build_get_cred_def_request(did, cred_def_id).unwrap();
+        let get_cred_def_response = ledger::submit_request(self.pool_handle, &get_cred_def_request).unwrap();
+        ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_def(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_def_json : &str) -> String {
+        let rev_reg_def_request = ledger::build_revoc_reg_def_request(issuer_did, rev_reg_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_def_request).unwrap()
+    }
+
+    pub fn get_revoc_reg_def(&self, did: Option<&str>, revoc_reg_def_id : &str) -> (String, String) /* revoc_reg_def_id, revo_reg_def_json */ {
+        let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(did, &revoc_reg_def_id).unwrap();
+        let get_rev_reg_def_response = ledger::submit_request(self.pool_handle, &get_rev_reg_def_request).unwrap();
+        ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_entry(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_id : &str, rev_reg_entry_json: &str) -> String{
+        let rev_reg_entry_request =
+            ledger::build_revoc_reg_entry_request(issuer_did, rev_reg_id, REVOC_REG_TYPE, rev_reg_entry_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_entry_request).unwrap()
+
+    }
+
+    pub fn get_revoc_reg_delta(&self, did: Option<&str>, revoc_reg_def_id : &str, from : Option<u64>, to : u64) -> (String,String, u64) /* rev_reg_id, revoc_reg_delta_json, timestamp */ {
+        let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(did, revoc_reg_def_id, from, to).unwrap();
+        let get_rev_reg_delta_response = ledger::submit_request(self.pool_handle, &get_rev_reg_delta_request).unwrap();
+        ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap()
+    }
+
+
+}
+
+
+impl Issuer {
+
+
+    pub fn new(pool: &Pool) -> Issuer{
+
+        let wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+        Issuer {
+            // Issuer creates wallet, gets wallet handle
+            issuer_wallet_handle: wallet_handle,
+
+            // Issuer create DID
+            issuer_did: did::create_store_and_publish_my_did_from_trustee(wallet_handle, pool.pool_handle).unwrap().0,
+
+            schema_id: String::new(),
+            rev_reg_id : String::new(),
+            cred_def_id : String::new(),
+
+            revoc_registry_config : String::new()
+
+        }
+    }
+
+    // creates schema , credential definition and revocation registry
+    pub fn create_initial_ledger_state(& mut self, pool : &Pool, revoc_registry_config : &str)
+    {
+
+        self.revoc_registry_config = String::from(revoc_registry_config);
+
+        // Issuer creates Schema
+        let (schema_id, schema_json) = anoncreds::issuer_create_schema(&self.issuer_did,
+                                                                       GVT_SCHEMA_NAME,
+                                                                       SCHEMA_VERSION,
+                                                                       GVT_SCHEMA_ATTRIBUTES).unwrap();
+
+        // !!IMPORTANT!!
+        // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
+        // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
+        let _schema_response = pool.submit_schema(&self.issuer_did, self.issuer_wallet_handle,&schema_json);
+        // Issuer gets Schema from Ledger
+        let (_ , schema_json) = pool.get_schema(Some(&self.issuer_did),&schema_id);
+
+        self.schema_id = schema_id;
+
+        // Issuer creates CredentialDefinition
+        let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(self.issuer_wallet_handle,
+                                                                                          &self.issuer_did,
+                                                                                          &schema_json,
+                                                                                          TAG_1,
+                                                                                          None,
+                                                                                          Some(&anoncreds::revocation_cred_def_config())).unwrap();
+
+        // Issuer post CredentialDefinition to Ledger
+        pool.submit_cred_def(&self.issuer_did,self.issuer_wallet_handle,&cred_def_json);
+
+        self.cred_def_id = cred_def_id;
+
+        // Issuer creates RevocationRegistry
+        let tails_writer_config = anoncreds::tails_writer_config();
+        let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
 
-    let schemas_json = json!({
+        let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
+            anoncreds::issuer_create_and_store_revoc_reg(self.issuer_wallet_handle,
+                                                         &self.issuer_did,
+                                                         None,
+                                                         TAG_1,
+                                                         &self.cred_def_id,
+                                                         &self.revoc_registry_config,
+                                                         tails_writer_handle).unwrap();
+
+        // Issuer posts RevocationRegistryDefinition to Ledger
+        pool.submit_revoc_reg_def(&self.issuer_did, self.issuer_wallet_handle, &rev_reg_def_json);
+
+
+        self.rev_reg_id = rev_reg_id;
+
+        // Issuer posts RevocationRegistryEntry to Ledger
+        pool.submit_revoc_reg_entry(&self.issuer_did,self.issuer_wallet_handle, &self.rev_reg_id, &rev_reg_entry_json);
+    }
+
+    pub fn make_credential_offer(&self) -> String
+    {
+        let cred_offer_json = anoncreds::issuer_create_credential_offer(self.issuer_wallet_handle, &self.cred_def_id).unwrap();
+        cred_offer_json
+    }
+
+    pub fn issue_credential(&self, pool: &Pool, cred_offer_json: &str, cred_req_json: &str, cred_values_json: &str) -> (String, String, Option<String>)
+    {
+
+        use serde_json::Value;
+
+        let tails_writer_config = anoncreds::tails_writer_config();
+        // Issuer creates TailsReader
+        let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
+
+        // Issuer creates Credential
+        // NOte that  the function returns revoc_reg_delta_json as None in case
+        // the revocation registry was created with the strategy ISSUANCE_BY_DEFAULT
+        let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(self.issuer_wallet_handle,
+                                                                                                 &cred_offer_json,
+                                                                                                 &cred_req_json,
+                                                                                                 cred_values_json,
+                                                                                                 Some(&self.rev_reg_id),
+                                                                                                 Some(blob_storage_reader_handle)).unwrap();
+
+
+
+        // Issuer does not have to post rev_reg_delta to ledger in case of the strategy ISSUANCE_BY_DEFAULT
+        let revoc_reg_config_value : Value = serde_json::from_str(&self.revoc_registry_config).unwrap();
+        let issuance_type = revoc_reg_config_value.as_object().unwrap().get(""issuance_type"").unwrap().as_str().unwrap();
+
+        // Issuer posts RevocationRegistryDelta to Ledger
+        if issuance_type  == ""ISSUANCE_ON_DEMAND"" {",,2019-02-15 14:25:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/255385552,https://github.com/hyperledger/indy-sdk/pull/1470#discussion_r255385552,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1470,https://github.com/hyperledger/indy-sdk/pull/1470,"I suggest storing Schemas, CredDefs, and RevRegDefs in some Prover cache. (for this test it can me simple HashMaps). When Prover needs some entity first check the cache and then asks Ledger.",930f0b793b9ba0d9a4f79f0bc92045149ca87bb7,2019-02-11 05:56:28,255385932,"@@ -45,481 +45,533 @@ use utils::domain::anoncreds::revocation_registry::RevocationRegistry;
 
 use std::thread;
 
-#[cfg(feature = ""revocation_tests"")]
-#[test]
-fn anoncreds_revocation_interaction_test_issuance_by_demand() {
-    utils::setup();
 
-    // Open Pool
-    let pool_handle = pool::create_and_open_pool_ledger(POOL).unwrap();
+struct Pool{
+    pool_handle : i32
+}
 
-    // Issuer creates wallet, gets wallet handle
-    let issuer_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
 
-    // Issuer create DID
-    let (issuer_did, _) = did::create_store_and_publish_my_did_from_trustee(issuer_wallet_handle, pool_handle).unwrap();
+struct Issuer{
+    issuer_wallet_handle: i32,
+    issuer_did : String,
 
-    // Prover creates wallet, gets wallet handle
-    let prover_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+    schema_id : String,
+    cred_def_id : String,
+    rev_reg_id : String,
 
-    // Prover create DID
-    let (prover_did, prover_verkey) = did::create_my_did(prover_wallet_handle, ""{}"").unwrap();
+    revoc_registry_config: String
+}
 
-    // Issuer publish Prover DID
-    let nym_request = ledger::build_nym_request(&issuer_did, &prover_did, Some(&prover_verkey), None, None).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
 
-    // ISSUER post to Ledger Schema, CredentialDefinition, RevocationRegistry
+struct Prover{
 
-    // Issuer creates Schema
-    let (schema_id, schema_json) = anoncreds::issuer_create_schema(&issuer_did,
-                                                                        GVT_SCHEMA_NAME,
-                                                                        SCHEMA_VERSION,
-                                                                        GVT_SCHEMA_ATTRIBUTES).unwrap();
-
-    // !!IMPORTANT!!
-    // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
-    // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
-
-    // Issuer posts Schema to Ledger
-    let schema_request = ledger::build_schema_request(&issuer_did, &schema_json).unwrap();
-    let schema_response = ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &schema_request).unwrap();
-
-    // Issuer gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&issuer_did), &schema_id).unwrap();
-    let get_schema_response = ledger::submit_request_with_retries(pool_handle, &get_schema_request, &schema_response).unwrap();
-    let (_, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Issuer creates CredentialDefinition
-    let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(issuer_wallet_handle,
-                                                                                           &issuer_did,
-                                                                                           &schema_json,
-                                                                                           TAG_1,
-                                                                                           None,
-                                                                                           Some(&anoncreds::revocation_cred_def_config())).unwrap();
-
-    // Issuer post CredentialDefinition to Ledger
-    let cred_def_request = ledger::build_cred_def_txn(&issuer_did, &cred_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &cred_def_request).unwrap();
-
-    // Issuer creates RevocationRegistry
-    let tails_writer_config = anoncreds::tails_writer_config();
-    let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
-
-    let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
-        anoncreds::issuer_create_and_store_revoc_reg(issuer_wallet_handle,
-                                                               &issuer_did,
-                                                               None,
-                                                               TAG_1,
-                                                               &cred_def_id,
-                                                               r#""{""max_cred_num"":5, ""issuance_type"":""ISSUANCE_ON_DEMAND""}""#,
-                                                               tails_writer_handle).unwrap();
-
-    // Issuer posts RevocationRegistryDefinition to Ledger
-    let rev_reg_def_request = ledger::build_revoc_reg_def_request(&issuer_did, &rev_reg_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_def_request).unwrap();
-
-    // Issuer posts RevocationRegistryEntry to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &rev_reg_entry_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
+    wallet_handle : i32,
+    did: String,
+    verkey : String,
+    master_secret_id : String,
+    cred_def_id : Option<String>,
+    cred_req_metadata_json : Option<String>
 
+}
 
-    // Issuance Credential for Prover
 
-    // Prover creates Master Secret
-    anoncreds::prover_create_master_secret(prover_wallet_handle, COMMON_MASTER_SECRET).unwrap();
+struct Verifier{
+    proof_request : String
+}
 
-    // Issuer creates Credential Offer
-    let cred_offer_json = anoncreds::issuer_create_credential_offer(issuer_wallet_handle, &cred_def_id).unwrap();
-    let cred_offer: CredentialOffer = serde_json::from_str(&cred_offer_json).unwrap();
-
-    // Prover gets CredentialDefinition from Ledger
-    let get_cred_def_request = ledger::build_get_cred_def_request(Some(&prover_did), &cred_offer.cred_def_id).unwrap();
-    let get_cred_def_response = ledger::submit_request(pool_handle, &get_cred_def_request).unwrap();
-    let (cred_def_id, cred_def_json) = ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap();
-
-    // Prover creates Credential Request
-    let (cred_req_json, cred_req_metadata_json) = anoncreds::prover_create_credential_req(prover_wallet_handle,
-                                                                                               &prover_did,
-                                                                                               &cred_offer_json,
-                                                                                               &cred_def_json,
-                                                                                               COMMON_MASTER_SECRET).unwrap();
-
-    // Issuer creates TailsReader
-    let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
-
-    // Issuer creates Credential
-    let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(issuer_wallet_handle,
-                                                                                                  &cred_offer_json,
-                                                                                                  &cred_req_json,
-                                                                                                  &anoncreds::gvt_credential_values_json(),
-                                                                                                  Some(&rev_reg_id),
-                                                                                                  Some(blob_storage_reader_handle)).unwrap();
-    let revoc_reg_delta_json = revoc_reg_delta_json.unwrap();
-    let cred_rev_id = cred_rev_id.unwrap();
-
-    // Issuer posts RevocationRegistryDelta to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &revoc_reg_delta_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
-
-    // Prover gets RevocationRegistryDefinition
-    let credential: Credential = serde_json::from_str(&cred_json).unwrap();
-    let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(Some(&prover_did), &credential.rev_reg_id.unwrap()).unwrap();
-    let get_rev_reg_def_response = ledger::submit_request(pool_handle, &get_rev_reg_def_request).unwrap();
-    let (_, revoc_reg_def_json) = ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap();
-
-    // Prover store received Credential
-    anoncreds::prover_store_credential(prover_wallet_handle,
-                                            CREDENTIAL1_ID,
-                                            &cred_req_metadata_json,
-                                            &cred_json,
-                                            &cred_def_json,
-                                            Some(&revoc_reg_def_json)).unwrap();
-
-    let credentials = anoncreds::prover_get_credentials(prover_wallet_handle, &json!({""schema_name"": GVT_SCHEMA_NAME}).to_string()).unwrap();
-    let credentials: Vec<serde_json::Value> = serde_json::from_str(&credentials).unwrap();
-    assert_eq!(credentials.len(), 1);
 
-    // Verifying Prover Credential
-    thread::sleep(std::time::Duration::from_secs(3));
+impl Pool {
 
-    let to = time::get_time().sec as u64;
 
-    let proof_request = json!({
-           ""nonce"":""123432421212"",
-           ""name"":""proof_req_1"",
-           ""version"":""0.1"",
-           ""requested_attributes"": json!({
-               ""attr1_referent"": json!({
-                   ""name"":""name""
-               })
-           }),
-           ""requested_predicates"": json!({
-               ""predicate1_referent"": json!({ ""name"":""age"", ""p_type"":"">="", ""p_value"":18 })
-           }),
-           ""non_revoked"": json!({ ""to"": to.clone() })
-        }).to_string();
+    pub fn new() -> Pool {
+        Pool{ pool_handle : pool::create_and_open_pool_ledger(POOL).unwrap() }
+    }
 
-    // Prover gets Credentials for Proof Request
-    let credentials_json = anoncreds::prover_get_credentials_for_proof_req(prover_wallet_handle, &proof_request).unwrap();
-    let cred_info = anoncreds::get_credential_for_attr_referent(&credentials_json, ""attr1_referent"");
-
-    // Prover gets RevocationRegistryDelta from Ledger
-    let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(Some(&prover_did), &cred_info.rev_reg_id.clone().unwrap(), None, to).unwrap();
-    let get_rev_reg_delta_response = ledger::submit_request(pool_handle, &get_rev_reg_delta_request).unwrap();
-    let (rev_reg_id, revoc_reg_delta_json, timestamp) = ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap();
-
-    // Prover creates RevocationState
-    let rev_state_json = anoncreds::create_revocation_state(blob_storage_reader_handle,
-                                                                 &revoc_reg_def_json,
-                                                                 &revoc_reg_delta_json,
-                                                                 timestamp,
-                                                                 &cred_info.cred_rev_id.clone().unwrap()).unwrap();
-
-    // Prover gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&prover_did), &cred_info.schema_id).unwrap();
-    let get_schema_response = ledger::submit_request(pool_handle, &get_schema_request).unwrap();
-    let (schema_id, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Prover creates Proof
-    let requested_credentials_json = json!({
-             ""self_attested_attributes"": json!({}),
-             ""requested_attributes"": json!({
-                ""attr1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp,  ""revealed"":true })
-             }),
-             ""requested_predicates"": json!({
-                ""predicate1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp })
-             })
-        }).to_string();
+    pub fn close(self) {
+        let _ = pool::close(self.pool_handle);
+    }
+
+
+    pub fn submit_nym(&self, issuer_did: &str, issuer_wallet_handle: i32, prover_did: &str, prover_verkey : Option<&str>)
+    {
+        let nym_request = ledger::build_nym_request(issuer_did, prover_did, prover_verkey, None, None).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
+    }
+
+    pub fn submit_schema(&self, issuer_did: &str, issuer_wallet_handle: i32, schema_json: &str) -> String {
+        let schema_request = ledger::build_schema_request(issuer_did, schema_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &schema_request).unwrap()
+    }
+
+    pub fn get_schema(&self, did: Option<&str>, schema_id: &str) -> (String, String){
+        let get_schema_request = ledger::build_get_schema_request(did, schema_id).unwrap();
+        let get_schema_response = ledger::submit_request(self.pool_handle, &get_schema_request).unwrap();
+        ledger::parse_get_schema_response(&get_schema_response).unwrap()
+
+    }
+
+    pub fn submit_cred_def(&self, issuer_did: &str, issuer_wallet_handle: i32, cred_def_json: &str) -> String {
+        let cred_def_request = ledger::build_cred_def_txn(issuer_did, cred_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &cred_def_request).unwrap()
+
+    }
+
+    pub fn get_cred_def(&self, did : Option<&str>, cred_def_id : &str ) -> (String, String) /* (cred_def_id, cred_def_json) */{
+        let get_cred_def_request = ledger::build_get_cred_def_request(did, cred_def_id).unwrap();
+        let get_cred_def_response = ledger::submit_request(self.pool_handle, &get_cred_def_request).unwrap();
+        ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_def(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_def_json : &str) -> String {
+        let rev_reg_def_request = ledger::build_revoc_reg_def_request(issuer_did, rev_reg_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_def_request).unwrap()
+    }
+
+    pub fn get_revoc_reg_def(&self, did: Option<&str>, revoc_reg_def_id : &str) -> (String, String) /* revoc_reg_def_id, revo_reg_def_json */ {
+        let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(did, &revoc_reg_def_id).unwrap();
+        let get_rev_reg_def_response = ledger::submit_request(self.pool_handle, &get_rev_reg_def_request).unwrap();
+        ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_entry(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_id : &str, rev_reg_entry_json: &str) -> String{
+        let rev_reg_entry_request =
+            ledger::build_revoc_reg_entry_request(issuer_did, rev_reg_id, REVOC_REG_TYPE, rev_reg_entry_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_entry_request).unwrap()
+
+    }
+
+    pub fn get_revoc_reg_delta(&self, did: Option<&str>, revoc_reg_def_id : &str, from : Option<u64>, to : u64) -> (String,String, u64) /* rev_reg_id, revoc_reg_delta_json, timestamp */ {
+        let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(did, revoc_reg_def_id, from, to).unwrap();
+        let get_rev_reg_delta_response = ledger::submit_request(self.pool_handle, &get_rev_reg_delta_request).unwrap();
+        ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap()
+    }
+
+
+}
+
+
+impl Issuer {
+
+
+    pub fn new(pool: &Pool) -> Issuer{
+
+        let wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+        Issuer {
+            // Issuer creates wallet, gets wallet handle
+            issuer_wallet_handle: wallet_handle,
+
+            // Issuer create DID
+            issuer_did: did::create_store_and_publish_my_did_from_trustee(wallet_handle, pool.pool_handle).unwrap().0,
+
+            schema_id: String::new(),
+            rev_reg_id : String::new(),
+            cred_def_id : String::new(),
+
+            revoc_registry_config : String::new()
+
+        }
+    }
+
+    // creates schema , credential definition and revocation registry
+    pub fn create_initial_ledger_state(& mut self, pool : &Pool, revoc_registry_config : &str)
+    {
+
+        self.revoc_registry_config = String::from(revoc_registry_config);
+
+        // Issuer creates Schema
+        let (schema_id, schema_json) = anoncreds::issuer_create_schema(&self.issuer_did,
+                                                                       GVT_SCHEMA_NAME,
+                                                                       SCHEMA_VERSION,
+                                                                       GVT_SCHEMA_ATTRIBUTES).unwrap();
+
+        // !!IMPORTANT!!
+        // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
+        // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
+        let _schema_response = pool.submit_schema(&self.issuer_did, self.issuer_wallet_handle,&schema_json);
+        // Issuer gets Schema from Ledger
+        let (_ , schema_json) = pool.get_schema(Some(&self.issuer_did),&schema_id);
+
+        self.schema_id = schema_id;
+
+        // Issuer creates CredentialDefinition
+        let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(self.issuer_wallet_handle,
+                                                                                          &self.issuer_did,
+                                                                                          &schema_json,
+                                                                                          TAG_1,
+                                                                                          None,
+                                                                                          Some(&anoncreds::revocation_cred_def_config())).unwrap();
+
+        // Issuer post CredentialDefinition to Ledger
+        pool.submit_cred_def(&self.issuer_did,self.issuer_wallet_handle,&cred_def_json);
+
+        self.cred_def_id = cred_def_id;
+
+        // Issuer creates RevocationRegistry
+        let tails_writer_config = anoncreds::tails_writer_config();
+        let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
 
-    let schemas_json = json!({
+        let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
+            anoncreds::issuer_create_and_store_revoc_reg(self.issuer_wallet_handle,
+                                                         &self.issuer_did,
+                                                         None,
+                                                         TAG_1,
+                                                         &self.cred_def_id,
+                                                         &self.revoc_registry_config,
+                                                         tails_writer_handle).unwrap();
+
+        // Issuer posts RevocationRegistryDefinition to Ledger
+        pool.submit_revoc_reg_def(&self.issuer_did, self.issuer_wallet_handle, &rev_reg_def_json);
+
+
+        self.rev_reg_id = rev_reg_id;
+
+        // Issuer posts RevocationRegistryEntry to Ledger
+        pool.submit_revoc_reg_entry(&self.issuer_did,self.issuer_wallet_handle, &self.rev_reg_id, &rev_reg_entry_json);
+    }
+
+    pub fn make_credential_offer(&self) -> String
+    {
+        let cred_offer_json = anoncreds::issuer_create_credential_offer(self.issuer_wallet_handle, &self.cred_def_id).unwrap();
+        cred_offer_json
+    }
+
+    pub fn issue_credential(&self, pool: &Pool, cred_offer_json: &str, cred_req_json: &str, cred_values_json: &str) -> (String, String, Option<String>)
+    {
+
+        use serde_json::Value;
+
+        let tails_writer_config = anoncreds::tails_writer_config();
+        // Issuer creates TailsReader
+        let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
+
+        // Issuer creates Credential
+        // NOte that  the function returns revoc_reg_delta_json as None in case
+        // the revocation registry was created with the strategy ISSUANCE_BY_DEFAULT
+        let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(self.issuer_wallet_handle,
+                                                                                                 &cred_offer_json,
+                                                                                                 &cred_req_json,
+                                                                                                 cred_values_json,
+                                                                                                 Some(&self.rev_reg_id),
+                                                                                                 Some(blob_storage_reader_handle)).unwrap();
+
+
+
+        // Issuer does not have to post rev_reg_delta to ledger in case of the strategy ISSUANCE_BY_DEFAULT
+        let revoc_reg_config_value : Value = serde_json::from_str(&self.revoc_registry_config).unwrap();
+        let issuance_type = revoc_reg_config_value.as_object().unwrap().get(""issuance_type"").unwrap().as_str().unwrap();
+
+        // Issuer posts RevocationRegistryDelta to Ledger
+        if issuance_type  == ""ISSUANCE_ON_DEMAND"" {
+            pool.submit_revoc_reg_entry(&self.issuer_did, self.issuer_wallet_handle, &self.rev_reg_id, &revoc_reg_delta_json.clone().unwrap());
+        }
+
+        (cred_json, cred_rev_id.unwrap(), revoc_reg_delta_json)
+    }
+
+    pub fn revoke_credential(&self, pool : &Pool, cred_rev_id: &str) -> String
+    {
+
+        let tails_writer_config = anoncreds::tails_writer_config();
+        // Issuer creates TailsReader
+        let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
+
+        // Issuer revokes cred_info
+        let rev_reg_delta_json = anoncreds::issuer_revoke_credential(self.issuer_wallet_handle, blob_storage_reader_handle, &self.rev_reg_id, &cred_rev_id).unwrap();
+
+        // Issuer post RevocationRegistryDelta to Ledger
+        pool.submit_revoc_reg_entry(&self.issuer_did,self.issuer_wallet_handle,&self.rev_reg_id,&rev_reg_delta_json);
+
+        rev_reg_delta_json
+    }
+
+    pub fn close(&self)
+    {
+        wallet::close_wallet(self.issuer_wallet_handle).unwrap();
+    }
+}
+
+
+impl Prover
+{
+    pub fn new(master_secret_id : Option<&str>) -> Prover
+    {
+        // Prover creates wallet, gets wallet handle
+        let prover_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+        // Prover create DID
+        let (prover_did, prover_verkey) = did::create_my_did(prover_wallet_handle, ""{}"").unwrap();
+        // Prover creates Master Secret
+        let master_secret_id = master_secret_id.unwrap_or(COMMON_MASTER_SECRET);
+        anoncreds::prover_create_master_secret(prover_wallet_handle, master_secret_id).unwrap();
+
+        Prover{ wallet_handle: prover_wallet_handle,
+                did: prover_did.clone(),
+                verkey: prover_verkey.clone(),
+                master_secret_id : String::from(master_secret_id),
+                cred_def_id: None,
+                cred_req_metadata_json : None
+             }
+    }
+
+
+    pub fn make_credential_request(&mut self, pool: &Pool,  cred_offer_json :  &str ) -> String
+    {
+        // Prover gets CredentialDefinition from Ledger
+        let cred_offer: CredentialOffer = serde_json::from_str(&cred_offer_json).unwrap();
+        let (cred_def_id, cred_def_json) = pool.get_cred_def(Some(&self.did), &cred_offer.cred_def_id);
+        self.cred_def_id = Some(cred_def_id);
+
+        // Prover creates Credential Request
+        let (cred_req_json, cred_req_metadata_json) = anoncreds::prover_create_credential_req(self.wallet_handle,
+                                                                                              &self.did,
+                                                                                              &cred_offer_json,
+                                                                                              &cred_def_json,
+                                                                                              &self.master_secret_id).unwrap();
+        self.cred_req_metadata_json = Some(cred_req_metadata_json);
+        cred_req_json
+    }
+
+
+    pub fn store_credentials(&self, pool: &Pool, cred_json: &str, cred_id: &str)
+    {
+        let credential: Credential = serde_json::from_str(&cred_json).unwrap();
+
+        // Prover gets CredentialDefinition from Ledger
+        let (_ , cred_def_json) = pool.get_cred_def(Some(&self.did), &self.cred_def_id.clone().unwrap());",471,2019-02-15 14:25:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/255385932,https://github.com/hyperledger/indy-sdk/pull/1470#discussion_r255385932,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1470,https://github.com/hyperledger/indy-sdk/pull/1470,move this import to the top of file,930f0b793b9ba0d9a4f79f0bc92045149ca87bb7,2019-02-11 05:57:12,255385993,"@@ -45,481 +45,533 @@ use utils::domain::anoncreds::revocation_registry::RevocationRegistry;
 
 use std::thread;
 
-#[cfg(feature = ""revocation_tests"")]
-#[test]
-fn anoncreds_revocation_interaction_test_issuance_by_demand() {
-    utils::setup();
 
-    // Open Pool
-    let pool_handle = pool::create_and_open_pool_ledger(POOL).unwrap();
+struct Pool{
+    pool_handle : i32
+}
 
-    // Issuer creates wallet, gets wallet handle
-    let issuer_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
 
-    // Issuer create DID
-    let (issuer_did, _) = did::create_store_and_publish_my_did_from_trustee(issuer_wallet_handle, pool_handle).unwrap();
+struct Issuer{
+    issuer_wallet_handle: i32,
+    issuer_did : String,
 
-    // Prover creates wallet, gets wallet handle
-    let prover_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+    schema_id : String,
+    cred_def_id : String,
+    rev_reg_id : String,
 
-    // Prover create DID
-    let (prover_did, prover_verkey) = did::create_my_did(prover_wallet_handle, ""{}"").unwrap();
+    revoc_registry_config: String
+}
 
-    // Issuer publish Prover DID
-    let nym_request = ledger::build_nym_request(&issuer_did, &prover_did, Some(&prover_verkey), None, None).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
 
-    // ISSUER post to Ledger Schema, CredentialDefinition, RevocationRegistry
+struct Prover{
 
-    // Issuer creates Schema
-    let (schema_id, schema_json) = anoncreds::issuer_create_schema(&issuer_did,
-                                                                        GVT_SCHEMA_NAME,
-                                                                        SCHEMA_VERSION,
-                                                                        GVT_SCHEMA_ATTRIBUTES).unwrap();
-
-    // !!IMPORTANT!!
-    // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
-    // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
-
-    // Issuer posts Schema to Ledger
-    let schema_request = ledger::build_schema_request(&issuer_did, &schema_json).unwrap();
-    let schema_response = ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &schema_request).unwrap();
-
-    // Issuer gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&issuer_did), &schema_id).unwrap();
-    let get_schema_response = ledger::submit_request_with_retries(pool_handle, &get_schema_request, &schema_response).unwrap();
-    let (_, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Issuer creates CredentialDefinition
-    let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(issuer_wallet_handle,
-                                                                                           &issuer_did,
-                                                                                           &schema_json,
-                                                                                           TAG_1,
-                                                                                           None,
-                                                                                           Some(&anoncreds::revocation_cred_def_config())).unwrap();
-
-    // Issuer post CredentialDefinition to Ledger
-    let cred_def_request = ledger::build_cred_def_txn(&issuer_did, &cred_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &cred_def_request).unwrap();
-
-    // Issuer creates RevocationRegistry
-    let tails_writer_config = anoncreds::tails_writer_config();
-    let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
-
-    let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
-        anoncreds::issuer_create_and_store_revoc_reg(issuer_wallet_handle,
-                                                               &issuer_did,
-                                                               None,
-                                                               TAG_1,
-                                                               &cred_def_id,
-                                                               r#""{""max_cred_num"":5, ""issuance_type"":""ISSUANCE_ON_DEMAND""}""#,
-                                                               tails_writer_handle).unwrap();
-
-    // Issuer posts RevocationRegistryDefinition to Ledger
-    let rev_reg_def_request = ledger::build_revoc_reg_def_request(&issuer_did, &rev_reg_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_def_request).unwrap();
-
-    // Issuer posts RevocationRegistryEntry to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &rev_reg_entry_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
+    wallet_handle : i32,
+    did: String,
+    verkey : String,
+    master_secret_id : String,
+    cred_def_id : Option<String>,
+    cred_req_metadata_json : Option<String>
 
+}
 
-    // Issuance Credential for Prover
 
-    // Prover creates Master Secret
-    anoncreds::prover_create_master_secret(prover_wallet_handle, COMMON_MASTER_SECRET).unwrap();
+struct Verifier{
+    proof_request : String
+}
 
-    // Issuer creates Credential Offer
-    let cred_offer_json = anoncreds::issuer_create_credential_offer(issuer_wallet_handle, &cred_def_id).unwrap();
-    let cred_offer: CredentialOffer = serde_json::from_str(&cred_offer_json).unwrap();
-
-    // Prover gets CredentialDefinition from Ledger
-    let get_cred_def_request = ledger::build_get_cred_def_request(Some(&prover_did), &cred_offer.cred_def_id).unwrap();
-    let get_cred_def_response = ledger::submit_request(pool_handle, &get_cred_def_request).unwrap();
-    let (cred_def_id, cred_def_json) = ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap();
-
-    // Prover creates Credential Request
-    let (cred_req_json, cred_req_metadata_json) = anoncreds::prover_create_credential_req(prover_wallet_handle,
-                                                                                               &prover_did,
-                                                                                               &cred_offer_json,
-                                                                                               &cred_def_json,
-                                                                                               COMMON_MASTER_SECRET).unwrap();
-
-    // Issuer creates TailsReader
-    let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
-
-    // Issuer creates Credential
-    let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(issuer_wallet_handle,
-                                                                                                  &cred_offer_json,
-                                                                                                  &cred_req_json,
-                                                                                                  &anoncreds::gvt_credential_values_json(),
-                                                                                                  Some(&rev_reg_id),
-                                                                                                  Some(blob_storage_reader_handle)).unwrap();
-    let revoc_reg_delta_json = revoc_reg_delta_json.unwrap();
-    let cred_rev_id = cred_rev_id.unwrap();
-
-    // Issuer posts RevocationRegistryDelta to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &revoc_reg_delta_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
-
-    // Prover gets RevocationRegistryDefinition
-    let credential: Credential = serde_json::from_str(&cred_json).unwrap();
-    let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(Some(&prover_did), &credential.rev_reg_id.unwrap()).unwrap();
-    let get_rev_reg_def_response = ledger::submit_request(pool_handle, &get_rev_reg_def_request).unwrap();
-    let (_, revoc_reg_def_json) = ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap();
-
-    // Prover store received Credential
-    anoncreds::prover_store_credential(prover_wallet_handle,
-                                            CREDENTIAL1_ID,
-                                            &cred_req_metadata_json,
-                                            &cred_json,
-                                            &cred_def_json,
-                                            Some(&revoc_reg_def_json)).unwrap();
-
-    let credentials = anoncreds::prover_get_credentials(prover_wallet_handle, &json!({""schema_name"": GVT_SCHEMA_NAME}).to_string()).unwrap();
-    let credentials: Vec<serde_json::Value> = serde_json::from_str(&credentials).unwrap();
-    assert_eq!(credentials.len(), 1);
 
-    // Verifying Prover Credential
-    thread::sleep(std::time::Duration::from_secs(3));
+impl Pool {
 
-    let to = time::get_time().sec as u64;
 
-    let proof_request = json!({
-           ""nonce"":""123432421212"",
-           ""name"":""proof_req_1"",
-           ""version"":""0.1"",
-           ""requested_attributes"": json!({
-               ""attr1_referent"": json!({
-                   ""name"":""name""
-               })
-           }),
-           ""requested_predicates"": json!({
-               ""predicate1_referent"": json!({ ""name"":""age"", ""p_type"":"">="", ""p_value"":18 })
-           }),
-           ""non_revoked"": json!({ ""to"": to.clone() })
-        }).to_string();
+    pub fn new() -> Pool {
+        Pool{ pool_handle : pool::create_and_open_pool_ledger(POOL).unwrap() }
+    }
 
-    // Prover gets Credentials for Proof Request
-    let credentials_json = anoncreds::prover_get_credentials_for_proof_req(prover_wallet_handle, &proof_request).unwrap();
-    let cred_info = anoncreds::get_credential_for_attr_referent(&credentials_json, ""attr1_referent"");
-
-    // Prover gets RevocationRegistryDelta from Ledger
-    let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(Some(&prover_did), &cred_info.rev_reg_id.clone().unwrap(), None, to).unwrap();
-    let get_rev_reg_delta_response = ledger::submit_request(pool_handle, &get_rev_reg_delta_request).unwrap();
-    let (rev_reg_id, revoc_reg_delta_json, timestamp) = ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap();
-
-    // Prover creates RevocationState
-    let rev_state_json = anoncreds::create_revocation_state(blob_storage_reader_handle,
-                                                                 &revoc_reg_def_json,
-                                                                 &revoc_reg_delta_json,
-                                                                 timestamp,
-                                                                 &cred_info.cred_rev_id.clone().unwrap()).unwrap();
-
-    // Prover gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&prover_did), &cred_info.schema_id).unwrap();
-    let get_schema_response = ledger::submit_request(pool_handle, &get_schema_request).unwrap();
-    let (schema_id, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Prover creates Proof
-    let requested_credentials_json = json!({
-             ""self_attested_attributes"": json!({}),
-             ""requested_attributes"": json!({
-                ""attr1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp,  ""revealed"":true })
-             }),
-             ""requested_predicates"": json!({
-                ""predicate1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp })
-             })
-        }).to_string();
+    pub fn close(self) {
+        let _ = pool::close(self.pool_handle);
+    }
+
+
+    pub fn submit_nym(&self, issuer_did: &str, issuer_wallet_handle: i32, prover_did: &str, prover_verkey : Option<&str>)
+    {
+        let nym_request = ledger::build_nym_request(issuer_did, prover_did, prover_verkey, None, None).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
+    }
+
+    pub fn submit_schema(&self, issuer_did: &str, issuer_wallet_handle: i32, schema_json: &str) -> String {
+        let schema_request = ledger::build_schema_request(issuer_did, schema_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &schema_request).unwrap()
+    }
+
+    pub fn get_schema(&self, did: Option<&str>, schema_id: &str) -> (String, String){
+        let get_schema_request = ledger::build_get_schema_request(did, schema_id).unwrap();
+        let get_schema_response = ledger::submit_request(self.pool_handle, &get_schema_request).unwrap();
+        ledger::parse_get_schema_response(&get_schema_response).unwrap()
+
+    }
+
+    pub fn submit_cred_def(&self, issuer_did: &str, issuer_wallet_handle: i32, cred_def_json: &str) -> String {
+        let cred_def_request = ledger::build_cred_def_txn(issuer_did, cred_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &cred_def_request).unwrap()
+
+    }
+
+    pub fn get_cred_def(&self, did : Option<&str>, cred_def_id : &str ) -> (String, String) /* (cred_def_id, cred_def_json) */{
+        let get_cred_def_request = ledger::build_get_cred_def_request(did, cred_def_id).unwrap();
+        let get_cred_def_response = ledger::submit_request(self.pool_handle, &get_cred_def_request).unwrap();
+        ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_def(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_def_json : &str) -> String {
+        let rev_reg_def_request = ledger::build_revoc_reg_def_request(issuer_did, rev_reg_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_def_request).unwrap()
+    }
+
+    pub fn get_revoc_reg_def(&self, did: Option<&str>, revoc_reg_def_id : &str) -> (String, String) /* revoc_reg_def_id, revo_reg_def_json */ {
+        let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(did, &revoc_reg_def_id).unwrap();
+        let get_rev_reg_def_response = ledger::submit_request(self.pool_handle, &get_rev_reg_def_request).unwrap();
+        ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_entry(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_id : &str, rev_reg_entry_json: &str) -> String{
+        let rev_reg_entry_request =
+            ledger::build_revoc_reg_entry_request(issuer_did, rev_reg_id, REVOC_REG_TYPE, rev_reg_entry_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_entry_request).unwrap()
+
+    }
+
+    pub fn get_revoc_reg_delta(&self, did: Option<&str>, revoc_reg_def_id : &str, from : Option<u64>, to : u64) -> (String,String, u64) /* rev_reg_id, revoc_reg_delta_json, timestamp */ {
+        let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(did, revoc_reg_def_id, from, to).unwrap();
+        let get_rev_reg_delta_response = ledger::submit_request(self.pool_handle, &get_rev_reg_delta_request).unwrap();
+        ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap()
+    }
+
+
+}
+
+
+impl Issuer {
+
+
+    pub fn new(pool: &Pool) -> Issuer{
+
+        let wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+        Issuer {
+            // Issuer creates wallet, gets wallet handle
+            issuer_wallet_handle: wallet_handle,
+
+            // Issuer create DID
+            issuer_did: did::create_store_and_publish_my_did_from_trustee(wallet_handle, pool.pool_handle).unwrap().0,
+
+            schema_id: String::new(),
+            rev_reg_id : String::new(),
+            cred_def_id : String::new(),
+
+            revoc_registry_config : String::new()
+
+        }
+    }
+
+    // creates schema , credential definition and revocation registry
+    pub fn create_initial_ledger_state(& mut self, pool : &Pool, revoc_registry_config : &str)
+    {
+
+        self.revoc_registry_config = String::from(revoc_registry_config);
+
+        // Issuer creates Schema
+        let (schema_id, schema_json) = anoncreds::issuer_create_schema(&self.issuer_did,
+                                                                       GVT_SCHEMA_NAME,
+                                                                       SCHEMA_VERSION,
+                                                                       GVT_SCHEMA_ATTRIBUTES).unwrap();
+
+        // !!IMPORTANT!!
+        // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
+        // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
+        let _schema_response = pool.submit_schema(&self.issuer_did, self.issuer_wallet_handle,&schema_json);
+        // Issuer gets Schema from Ledger
+        let (_ , schema_json) = pool.get_schema(Some(&self.issuer_did),&schema_id);
+
+        self.schema_id = schema_id;
+
+        // Issuer creates CredentialDefinition
+        let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(self.issuer_wallet_handle,
+                                                                                          &self.issuer_did,
+                                                                                          &schema_json,
+                                                                                          TAG_1,
+                                                                                          None,
+                                                                                          Some(&anoncreds::revocation_cred_def_config())).unwrap();
+
+        // Issuer post CredentialDefinition to Ledger
+        pool.submit_cred_def(&self.issuer_did,self.issuer_wallet_handle,&cred_def_json);
+
+        self.cred_def_id = cred_def_id;
+
+        // Issuer creates RevocationRegistry
+        let tails_writer_config = anoncreds::tails_writer_config();
+        let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
 
-    let schemas_json = json!({
+        let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
+            anoncreds::issuer_create_and_store_revoc_reg(self.issuer_wallet_handle,
+                                                         &self.issuer_did,
+                                                         None,
+                                                         TAG_1,
+                                                         &self.cred_def_id,
+                                                         &self.revoc_registry_config,
+                                                         tails_writer_handle).unwrap();
+
+        // Issuer posts RevocationRegistryDefinition to Ledger
+        pool.submit_revoc_reg_def(&self.issuer_did, self.issuer_wallet_handle, &rev_reg_def_json);
+
+
+        self.rev_reg_id = rev_reg_id;
+
+        // Issuer posts RevocationRegistryEntry to Ledger
+        pool.submit_revoc_reg_entry(&self.issuer_did,self.issuer_wallet_handle, &self.rev_reg_id, &rev_reg_entry_json);
+    }
+
+    pub fn make_credential_offer(&self) -> String
+    {
+        let cred_offer_json = anoncreds::issuer_create_credential_offer(self.issuer_wallet_handle, &self.cred_def_id).unwrap();
+        cred_offer_json
+    }
+
+    pub fn issue_credential(&self, pool: &Pool, cred_offer_json: &str, cred_req_json: &str, cred_values_json: &str) -> (String, String, Option<String>)
+    {
+
+        use serde_json::Value;
+
+        let tails_writer_config = anoncreds::tails_writer_config();
+        // Issuer creates TailsReader
+        let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
+
+        // Issuer creates Credential
+        // NOte that  the function returns revoc_reg_delta_json as None in case
+        // the revocation registry was created with the strategy ISSUANCE_BY_DEFAULT
+        let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(self.issuer_wallet_handle,
+                                                                                                 &cred_offer_json,
+                                                                                                 &cred_req_json,
+                                                                                                 cred_values_json,
+                                                                                                 Some(&self.rev_reg_id),
+                                                                                                 Some(blob_storage_reader_handle)).unwrap();
+
+
+
+        // Issuer does not have to post rev_reg_delta to ledger in case of the strategy ISSUANCE_BY_DEFAULT
+        let revoc_reg_config_value : Value = serde_json::from_str(&self.revoc_registry_config).unwrap();
+        let issuance_type = revoc_reg_config_value.as_object().unwrap().get(""issuance_type"").unwrap().as_str().unwrap();
+
+        // Issuer posts RevocationRegistryDelta to Ledger
+        if issuance_type  == ""ISSUANCE_ON_DEMAND"" {
+            pool.submit_revoc_reg_entry(&self.issuer_did, self.issuer_wallet_handle, &self.rev_reg_id, &revoc_reg_delta_json.clone().unwrap());
+        }
+
+        (cred_json, cred_rev_id.unwrap(), revoc_reg_delta_json)
+    }
+
+    pub fn revoke_credential(&self, pool : &Pool, cred_rev_id: &str) -> String
+    {
+
+        let tails_writer_config = anoncreds::tails_writer_config();
+        // Issuer creates TailsReader
+        let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
+
+        // Issuer revokes cred_info
+        let rev_reg_delta_json = anoncreds::issuer_revoke_credential(self.issuer_wallet_handle, blob_storage_reader_handle, &self.rev_reg_id, &cred_rev_id).unwrap();
+
+        // Issuer post RevocationRegistryDelta to Ledger
+        pool.submit_revoc_reg_entry(&self.issuer_did,self.issuer_wallet_handle,&self.rev_reg_id,&rev_reg_delta_json);
+
+        rev_reg_delta_json
+    }
+
+    pub fn close(&self)
+    {
+        wallet::close_wallet(self.issuer_wallet_handle).unwrap();
+    }
+}
+
+
+impl Prover
+{
+    pub fn new(master_secret_id : Option<&str>) -> Prover
+    {
+        // Prover creates wallet, gets wallet handle
+        let prover_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+        // Prover create DID
+        let (prover_did, prover_verkey) = did::create_my_did(prover_wallet_handle, ""{}"").unwrap();
+        // Prover creates Master Secret
+        let master_secret_id = master_secret_id.unwrap_or(COMMON_MASTER_SECRET);
+        anoncreds::prover_create_master_secret(prover_wallet_handle, master_secret_id).unwrap();
+
+        Prover{ wallet_handle: prover_wallet_handle,
+                did: prover_did.clone(),
+                verkey: prover_verkey.clone(),
+                master_secret_id : String::from(master_secret_id),
+                cred_def_id: None,
+                cred_req_metadata_json : None
+             }
+    }
+
+
+    pub fn make_credential_request(&mut self, pool: &Pool,  cred_offer_json :  &str ) -> String
+    {
+        // Prover gets CredentialDefinition from Ledger
+        let cred_offer: CredentialOffer = serde_json::from_str(&cred_offer_json).unwrap();
+        let (cred_def_id, cred_def_json) = pool.get_cred_def(Some(&self.did), &cred_offer.cred_def_id);
+        self.cred_def_id = Some(cred_def_id);
+
+        // Prover creates Credential Request
+        let (cred_req_json, cred_req_metadata_json) = anoncreds::prover_create_credential_req(self.wallet_handle,
+                                                                                              &self.did,
+                                                                                              &cred_offer_json,
+                                                                                              &cred_def_json,
+                                                                                              &self.master_secret_id).unwrap();
+        self.cred_req_metadata_json = Some(cred_req_metadata_json);
+        cred_req_json
+    }
+
+
+    pub fn store_credentials(&self, pool: &Pool, cred_json: &str, cred_id: &str)
+    {
+        let credential: Credential = serde_json::from_str(&cred_json).unwrap();
+
+        // Prover gets CredentialDefinition from Ledger
+        let (_ , cred_def_json) = pool.get_cred_def(Some(&self.did), &self.cred_def_id.clone().unwrap());
+
+        // Prover gets RevocationRegistryDefinition
+        let (_, revoc_reg_def_json) = pool.get_revoc_reg_def(None,&credential.rev_reg_id.unwrap());
+
+        // Prover stores received Credential
+        anoncreds::prover_store_credential(self.wallet_handle,
+                                           cred_id,
+                                           &self.cred_req_metadata_json.clone().unwrap(),
+                                           &cred_json,
+                                           &cred_def_json,
+                                           Some(&revoc_reg_def_json)).unwrap();
+    }
+
+    pub fn make_proof(&self, pool : &Pool, proof_request: &str, attr1_referent: &str, from: Option<u64>, to: u64 ) -> String
+    {
+
+        use serde_json::Value;",,2019-02-15 14:25:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/255385993,https://github.com/hyperledger/indy-sdk/pull/1470#discussion_r255385993,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1470,https://github.com/hyperledger/indy-sdk/pull/1470,"`prover_get_credentials_for_proof_req` is marked as deprecated now.
could you use `indy_prover_search_credentials_for_proof_req` instead?",930f0b793b9ba0d9a4f79f0bc92045149ca87bb7,2019-02-11 05:58:49,255386139,"@@ -45,481 +45,533 @@ use utils::domain::anoncreds::revocation_registry::RevocationRegistry;
 
 use std::thread;
 
-#[cfg(feature = ""revocation_tests"")]
-#[test]
-fn anoncreds_revocation_interaction_test_issuance_by_demand() {
-    utils::setup();
 
-    // Open Pool
-    let pool_handle = pool::create_and_open_pool_ledger(POOL).unwrap();
+struct Pool{
+    pool_handle : i32
+}
 
-    // Issuer creates wallet, gets wallet handle
-    let issuer_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
 
-    // Issuer create DID
-    let (issuer_did, _) = did::create_store_and_publish_my_did_from_trustee(issuer_wallet_handle, pool_handle).unwrap();
+struct Issuer{
+    issuer_wallet_handle: i32,
+    issuer_did : String,
 
-    // Prover creates wallet, gets wallet handle
-    let prover_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+    schema_id : String,
+    cred_def_id : String,
+    rev_reg_id : String,
 
-    // Prover create DID
-    let (prover_did, prover_verkey) = did::create_my_did(prover_wallet_handle, ""{}"").unwrap();
+    revoc_registry_config: String
+}
 
-    // Issuer publish Prover DID
-    let nym_request = ledger::build_nym_request(&issuer_did, &prover_did, Some(&prover_verkey), None, None).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
 
-    // ISSUER post to Ledger Schema, CredentialDefinition, RevocationRegistry
+struct Prover{
 
-    // Issuer creates Schema
-    let (schema_id, schema_json) = anoncreds::issuer_create_schema(&issuer_did,
-                                                                        GVT_SCHEMA_NAME,
-                                                                        SCHEMA_VERSION,
-                                                                        GVT_SCHEMA_ATTRIBUTES).unwrap();
-
-    // !!IMPORTANT!!
-    // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
-    // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
-
-    // Issuer posts Schema to Ledger
-    let schema_request = ledger::build_schema_request(&issuer_did, &schema_json).unwrap();
-    let schema_response = ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &schema_request).unwrap();
-
-    // Issuer gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&issuer_did), &schema_id).unwrap();
-    let get_schema_response = ledger::submit_request_with_retries(pool_handle, &get_schema_request, &schema_response).unwrap();
-    let (_, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Issuer creates CredentialDefinition
-    let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(issuer_wallet_handle,
-                                                                                           &issuer_did,
-                                                                                           &schema_json,
-                                                                                           TAG_1,
-                                                                                           None,
-                                                                                           Some(&anoncreds::revocation_cred_def_config())).unwrap();
-
-    // Issuer post CredentialDefinition to Ledger
-    let cred_def_request = ledger::build_cred_def_txn(&issuer_did, &cred_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &cred_def_request).unwrap();
-
-    // Issuer creates RevocationRegistry
-    let tails_writer_config = anoncreds::tails_writer_config();
-    let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
-
-    let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
-        anoncreds::issuer_create_and_store_revoc_reg(issuer_wallet_handle,
-                                                               &issuer_did,
-                                                               None,
-                                                               TAG_1,
-                                                               &cred_def_id,
-                                                               r#""{""max_cred_num"":5, ""issuance_type"":""ISSUANCE_ON_DEMAND""}""#,
-                                                               tails_writer_handle).unwrap();
-
-    // Issuer posts RevocationRegistryDefinition to Ledger
-    let rev_reg_def_request = ledger::build_revoc_reg_def_request(&issuer_did, &rev_reg_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_def_request).unwrap();
-
-    // Issuer posts RevocationRegistryEntry to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &rev_reg_entry_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
+    wallet_handle : i32,
+    did: String,
+    verkey : String,
+    master_secret_id : String,
+    cred_def_id : Option<String>,
+    cred_req_metadata_json : Option<String>
 
+}
 
-    // Issuance Credential for Prover
 
-    // Prover creates Master Secret
-    anoncreds::prover_create_master_secret(prover_wallet_handle, COMMON_MASTER_SECRET).unwrap();
+struct Verifier{
+    proof_request : String
+}
 
-    // Issuer creates Credential Offer
-    let cred_offer_json = anoncreds::issuer_create_credential_offer(issuer_wallet_handle, &cred_def_id).unwrap();
-    let cred_offer: CredentialOffer = serde_json::from_str(&cred_offer_json).unwrap();
-
-    // Prover gets CredentialDefinition from Ledger
-    let get_cred_def_request = ledger::build_get_cred_def_request(Some(&prover_did), &cred_offer.cred_def_id).unwrap();
-    let get_cred_def_response = ledger::submit_request(pool_handle, &get_cred_def_request).unwrap();
-    let (cred_def_id, cred_def_json) = ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap();
-
-    // Prover creates Credential Request
-    let (cred_req_json, cred_req_metadata_json) = anoncreds::prover_create_credential_req(prover_wallet_handle,
-                                                                                               &prover_did,
-                                                                                               &cred_offer_json,
-                                                                                               &cred_def_json,
-                                                                                               COMMON_MASTER_SECRET).unwrap();
-
-    // Issuer creates TailsReader
-    let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
-
-    // Issuer creates Credential
-    let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(issuer_wallet_handle,
-                                                                                                  &cred_offer_json,
-                                                                                                  &cred_req_json,
-                                                                                                  &anoncreds::gvt_credential_values_json(),
-                                                                                                  Some(&rev_reg_id),
-                                                                                                  Some(blob_storage_reader_handle)).unwrap();
-    let revoc_reg_delta_json = revoc_reg_delta_json.unwrap();
-    let cred_rev_id = cred_rev_id.unwrap();
-
-    // Issuer posts RevocationRegistryDelta to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &revoc_reg_delta_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
-
-    // Prover gets RevocationRegistryDefinition
-    let credential: Credential = serde_json::from_str(&cred_json).unwrap();
-    let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(Some(&prover_did), &credential.rev_reg_id.unwrap()).unwrap();
-    let get_rev_reg_def_response = ledger::submit_request(pool_handle, &get_rev_reg_def_request).unwrap();
-    let (_, revoc_reg_def_json) = ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap();
-
-    // Prover store received Credential
-    anoncreds::prover_store_credential(prover_wallet_handle,
-                                            CREDENTIAL1_ID,
-                                            &cred_req_metadata_json,
-                                            &cred_json,
-                                            &cred_def_json,
-                                            Some(&revoc_reg_def_json)).unwrap();
-
-    let credentials = anoncreds::prover_get_credentials(prover_wallet_handle, &json!({""schema_name"": GVT_SCHEMA_NAME}).to_string()).unwrap();
-    let credentials: Vec<serde_json::Value> = serde_json::from_str(&credentials).unwrap();
-    assert_eq!(credentials.len(), 1);
 
-    // Verifying Prover Credential
-    thread::sleep(std::time::Duration::from_secs(3));
+impl Pool {
 
-    let to = time::get_time().sec as u64;
 
-    let proof_request = json!({
-           ""nonce"":""123432421212"",
-           ""name"":""proof_req_1"",
-           ""version"":""0.1"",
-           ""requested_attributes"": json!({
-               ""attr1_referent"": json!({
-                   ""name"":""name""
-               })
-           }),
-           ""requested_predicates"": json!({
-               ""predicate1_referent"": json!({ ""name"":""age"", ""p_type"":"">="", ""p_value"":18 })
-           }),
-           ""non_revoked"": json!({ ""to"": to.clone() })
-        }).to_string();
+    pub fn new() -> Pool {
+        Pool{ pool_handle : pool::create_and_open_pool_ledger(POOL).unwrap() }
+    }
 
-    // Prover gets Credentials for Proof Request
-    let credentials_json = anoncreds::prover_get_credentials_for_proof_req(prover_wallet_handle, &proof_request).unwrap();
-    let cred_info = anoncreds::get_credential_for_attr_referent(&credentials_json, ""attr1_referent"");
-
-    // Prover gets RevocationRegistryDelta from Ledger
-    let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(Some(&prover_did), &cred_info.rev_reg_id.clone().unwrap(), None, to).unwrap();
-    let get_rev_reg_delta_response = ledger::submit_request(pool_handle, &get_rev_reg_delta_request).unwrap();
-    let (rev_reg_id, revoc_reg_delta_json, timestamp) = ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap();
-
-    // Prover creates RevocationState
-    let rev_state_json = anoncreds::create_revocation_state(blob_storage_reader_handle,
-                                                                 &revoc_reg_def_json,
-                                                                 &revoc_reg_delta_json,
-                                                                 timestamp,
-                                                                 &cred_info.cred_rev_id.clone().unwrap()).unwrap();
-
-    // Prover gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&prover_did), &cred_info.schema_id).unwrap();
-    let get_schema_response = ledger::submit_request(pool_handle, &get_schema_request).unwrap();
-    let (schema_id, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Prover creates Proof
-    let requested_credentials_json = json!({
-             ""self_attested_attributes"": json!({}),
-             ""requested_attributes"": json!({
-                ""attr1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp,  ""revealed"":true })
-             }),
-             ""requested_predicates"": json!({
-                ""predicate1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp })
-             })
-        }).to_string();
+    pub fn close(self) {
+        let _ = pool::close(self.pool_handle);
+    }
+
+
+    pub fn submit_nym(&self, issuer_did: &str, issuer_wallet_handle: i32, prover_did: &str, prover_verkey : Option<&str>)
+    {
+        let nym_request = ledger::build_nym_request(issuer_did, prover_did, prover_verkey, None, None).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
+    }
+
+    pub fn submit_schema(&self, issuer_did: &str, issuer_wallet_handle: i32, schema_json: &str) -> String {
+        let schema_request = ledger::build_schema_request(issuer_did, schema_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &schema_request).unwrap()
+    }
+
+    pub fn get_schema(&self, did: Option<&str>, schema_id: &str) -> (String, String){
+        let get_schema_request = ledger::build_get_schema_request(did, schema_id).unwrap();
+        let get_schema_response = ledger::submit_request(self.pool_handle, &get_schema_request).unwrap();
+        ledger::parse_get_schema_response(&get_schema_response).unwrap()
+
+    }
+
+    pub fn submit_cred_def(&self, issuer_did: &str, issuer_wallet_handle: i32, cred_def_json: &str) -> String {
+        let cred_def_request = ledger::build_cred_def_txn(issuer_did, cred_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &cred_def_request).unwrap()
+
+    }
+
+    pub fn get_cred_def(&self, did : Option<&str>, cred_def_id : &str ) -> (String, String) /* (cred_def_id, cred_def_json) */{
+        let get_cred_def_request = ledger::build_get_cred_def_request(did, cred_def_id).unwrap();
+        let get_cred_def_response = ledger::submit_request(self.pool_handle, &get_cred_def_request).unwrap();
+        ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_def(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_def_json : &str) -> String {
+        let rev_reg_def_request = ledger::build_revoc_reg_def_request(issuer_did, rev_reg_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_def_request).unwrap()
+    }
+
+    pub fn get_revoc_reg_def(&self, did: Option<&str>, revoc_reg_def_id : &str) -> (String, String) /* revoc_reg_def_id, revo_reg_def_json */ {
+        let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(did, &revoc_reg_def_id).unwrap();
+        let get_rev_reg_def_response = ledger::submit_request(self.pool_handle, &get_rev_reg_def_request).unwrap();
+        ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_entry(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_id : &str, rev_reg_entry_json: &str) -> String{
+        let rev_reg_entry_request =
+            ledger::build_revoc_reg_entry_request(issuer_did, rev_reg_id, REVOC_REG_TYPE, rev_reg_entry_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_entry_request).unwrap()
+
+    }
+
+    pub fn get_revoc_reg_delta(&self, did: Option<&str>, revoc_reg_def_id : &str, from : Option<u64>, to : u64) -> (String,String, u64) /* rev_reg_id, revoc_reg_delta_json, timestamp */ {
+        let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(did, revoc_reg_def_id, from, to).unwrap();
+        let get_rev_reg_delta_response = ledger::submit_request(self.pool_handle, &get_rev_reg_delta_request).unwrap();
+        ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap()
+    }
+
+
+}
+
+
+impl Issuer {
+
+
+    pub fn new(pool: &Pool) -> Issuer{
+
+        let wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+        Issuer {
+            // Issuer creates wallet, gets wallet handle
+            issuer_wallet_handle: wallet_handle,
+
+            // Issuer create DID
+            issuer_did: did::create_store_and_publish_my_did_from_trustee(wallet_handle, pool.pool_handle).unwrap().0,
+
+            schema_id: String::new(),
+            rev_reg_id : String::new(),
+            cred_def_id : String::new(),
+
+            revoc_registry_config : String::new()
+
+        }
+    }
+
+    // creates schema , credential definition and revocation registry
+    pub fn create_initial_ledger_state(& mut self, pool : &Pool, revoc_registry_config : &str)
+    {
+
+        self.revoc_registry_config = String::from(revoc_registry_config);
+
+        // Issuer creates Schema
+        let (schema_id, schema_json) = anoncreds::issuer_create_schema(&self.issuer_did,
+                                                                       GVT_SCHEMA_NAME,
+                                                                       SCHEMA_VERSION,
+                                                                       GVT_SCHEMA_ATTRIBUTES).unwrap();
+
+        // !!IMPORTANT!!
+        // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
+        // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
+        let _schema_response = pool.submit_schema(&self.issuer_did, self.issuer_wallet_handle,&schema_json);
+        // Issuer gets Schema from Ledger
+        let (_ , schema_json) = pool.get_schema(Some(&self.issuer_did),&schema_id);
+
+        self.schema_id = schema_id;
+
+        // Issuer creates CredentialDefinition
+        let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(self.issuer_wallet_handle,
+                                                                                          &self.issuer_did,
+                                                                                          &schema_json,
+                                                                                          TAG_1,
+                                                                                          None,
+                                                                                          Some(&anoncreds::revocation_cred_def_config())).unwrap();
+
+        // Issuer post CredentialDefinition to Ledger
+        pool.submit_cred_def(&self.issuer_did,self.issuer_wallet_handle,&cred_def_json);
+
+        self.cred_def_id = cred_def_id;
+
+        // Issuer creates RevocationRegistry
+        let tails_writer_config = anoncreds::tails_writer_config();
+        let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
 
-    let schemas_json = json!({
+        let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
+            anoncreds::issuer_create_and_store_revoc_reg(self.issuer_wallet_handle,
+                                                         &self.issuer_did,
+                                                         None,
+                                                         TAG_1,
+                                                         &self.cred_def_id,
+                                                         &self.revoc_registry_config,
+                                                         tails_writer_handle).unwrap();
+
+        // Issuer posts RevocationRegistryDefinition to Ledger
+        pool.submit_revoc_reg_def(&self.issuer_did, self.issuer_wallet_handle, &rev_reg_def_json);
+
+
+        self.rev_reg_id = rev_reg_id;
+
+        // Issuer posts RevocationRegistryEntry to Ledger
+        pool.submit_revoc_reg_entry(&self.issuer_did,self.issuer_wallet_handle, &self.rev_reg_id, &rev_reg_entry_json);
+    }
+
+    pub fn make_credential_offer(&self) -> String
+    {
+        let cred_offer_json = anoncreds::issuer_create_credential_offer(self.issuer_wallet_handle, &self.cred_def_id).unwrap();
+        cred_offer_json
+    }
+
+    pub fn issue_credential(&self, pool: &Pool, cred_offer_json: &str, cred_req_json: &str, cred_values_json: &str) -> (String, String, Option<String>)
+    {
+
+        use serde_json::Value;
+
+        let tails_writer_config = anoncreds::tails_writer_config();
+        // Issuer creates TailsReader
+        let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
+
+        // Issuer creates Credential
+        // NOte that  the function returns revoc_reg_delta_json as None in case
+        // the revocation registry was created with the strategy ISSUANCE_BY_DEFAULT
+        let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(self.issuer_wallet_handle,
+                                                                                                 &cred_offer_json,
+                                                                                                 &cred_req_json,
+                                                                                                 cred_values_json,
+                                                                                                 Some(&self.rev_reg_id),
+                                                                                                 Some(blob_storage_reader_handle)).unwrap();
+
+
+
+        // Issuer does not have to post rev_reg_delta to ledger in case of the strategy ISSUANCE_BY_DEFAULT
+        let revoc_reg_config_value : Value = serde_json::from_str(&self.revoc_registry_config).unwrap();
+        let issuance_type = revoc_reg_config_value.as_object().unwrap().get(""issuance_type"").unwrap().as_str().unwrap();
+
+        // Issuer posts RevocationRegistryDelta to Ledger
+        if issuance_type  == ""ISSUANCE_ON_DEMAND"" {
+            pool.submit_revoc_reg_entry(&self.issuer_did, self.issuer_wallet_handle, &self.rev_reg_id, &revoc_reg_delta_json.clone().unwrap());
+        }
+
+        (cred_json, cred_rev_id.unwrap(), revoc_reg_delta_json)
+    }
+
+    pub fn revoke_credential(&self, pool : &Pool, cred_rev_id: &str) -> String
+    {
+
+        let tails_writer_config = anoncreds::tails_writer_config();
+        // Issuer creates TailsReader
+        let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
+
+        // Issuer revokes cred_info
+        let rev_reg_delta_json = anoncreds::issuer_revoke_credential(self.issuer_wallet_handle, blob_storage_reader_handle, &self.rev_reg_id, &cred_rev_id).unwrap();
+
+        // Issuer post RevocationRegistryDelta to Ledger
+        pool.submit_revoc_reg_entry(&self.issuer_did,self.issuer_wallet_handle,&self.rev_reg_id,&rev_reg_delta_json);
+
+        rev_reg_delta_json
+    }
+
+    pub fn close(&self)
+    {
+        wallet::close_wallet(self.issuer_wallet_handle).unwrap();
+    }
+}
+
+
+impl Prover
+{
+    pub fn new(master_secret_id : Option<&str>) -> Prover
+    {
+        // Prover creates wallet, gets wallet handle
+        let prover_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+        // Prover create DID
+        let (prover_did, prover_verkey) = did::create_my_did(prover_wallet_handle, ""{}"").unwrap();
+        // Prover creates Master Secret
+        let master_secret_id = master_secret_id.unwrap_or(COMMON_MASTER_SECRET);
+        anoncreds::prover_create_master_secret(prover_wallet_handle, master_secret_id).unwrap();
+
+        Prover{ wallet_handle: prover_wallet_handle,
+                did: prover_did.clone(),
+                verkey: prover_verkey.clone(),
+                master_secret_id : String::from(master_secret_id),
+                cred_def_id: None,
+                cred_req_metadata_json : None
+             }
+    }
+
+
+    pub fn make_credential_request(&mut self, pool: &Pool,  cred_offer_json :  &str ) -> String
+    {
+        // Prover gets CredentialDefinition from Ledger
+        let cred_offer: CredentialOffer = serde_json::from_str(&cred_offer_json).unwrap();
+        let (cred_def_id, cred_def_json) = pool.get_cred_def(Some(&self.did), &cred_offer.cred_def_id);
+        self.cred_def_id = Some(cred_def_id);
+
+        // Prover creates Credential Request
+        let (cred_req_json, cred_req_metadata_json) = anoncreds::prover_create_credential_req(self.wallet_handle,
+                                                                                              &self.did,
+                                                                                              &cred_offer_json,
+                                                                                              &cred_def_json,
+                                                                                              &self.master_secret_id).unwrap();
+        self.cred_req_metadata_json = Some(cred_req_metadata_json);
+        cred_req_json
+    }
+
+
+    pub fn store_credentials(&self, pool: &Pool, cred_json: &str, cred_id: &str)
+    {
+        let credential: Credential = serde_json::from_str(&cred_json).unwrap();
+
+        // Prover gets CredentialDefinition from Ledger
+        let (_ , cred_def_json) = pool.get_cred_def(Some(&self.did), &self.cred_def_id.clone().unwrap());
+
+        // Prover gets RevocationRegistryDefinition
+        let (_, revoc_reg_def_json) = pool.get_revoc_reg_def(None,&credential.rev_reg_id.unwrap());
+
+        // Prover stores received Credential
+        anoncreds::prover_store_credential(self.wallet_handle,
+                                           cred_id,
+                                           &self.cred_req_metadata_json.clone().unwrap(),
+                                           &cred_json,
+                                           &cred_def_json,
+                                           Some(&revoc_reg_def_json)).unwrap();
+    }
+
+    pub fn make_proof(&self, pool : &Pool, proof_request: &str, attr1_referent: &str, from: Option<u64>, to: u64 ) -> String
+    {
+
+        use serde_json::Value;
+        // Prover gets Credentials for Proof Request
+        let credentials_json = anoncreds::prover_get_credentials_for_proof_req(self.wallet_handle, &proof_request).unwrap();",,2019-02-15 14:25:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/255386139,https://github.com/hyperledger/indy-sdk/pull/1470#discussion_r255386139,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1470,https://github.com/hyperledger/indy-sdk/pull/1470,Well spotted. Fixed,930f0b793b9ba0d9a4f79f0bc92045149ca87bb7,2019-02-15 08:40:01,257144711,"@@ -45,481 +45,533 @@ use utils::domain::anoncreds::revocation_registry::RevocationRegistry;
 
 use std::thread;
 
-#[cfg(feature = ""revocation_tests"")]
-#[test]
-fn anoncreds_revocation_interaction_test_issuance_by_demand() {
-    utils::setup();
 
-    // Open Pool
-    let pool_handle = pool::create_and_open_pool_ledger(POOL).unwrap();
+struct Pool{
+    pool_handle : i32
+}
 
-    // Issuer creates wallet, gets wallet handle
-    let issuer_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
 
-    // Issuer create DID
-    let (issuer_did, _) = did::create_store_and_publish_my_did_from_trustee(issuer_wallet_handle, pool_handle).unwrap();
+struct Issuer{
+    issuer_wallet_handle: i32,
+    issuer_did : String,
 
-    // Prover creates wallet, gets wallet handle
-    let prover_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+    schema_id : String,
+    cred_def_id : String,
+    rev_reg_id : String,
 
-    // Prover create DID
-    let (prover_did, prover_verkey) = did::create_my_did(prover_wallet_handle, ""{}"").unwrap();
+    revoc_registry_config: String
+}
 
-    // Issuer publish Prover DID
-    let nym_request = ledger::build_nym_request(&issuer_did, &prover_did, Some(&prover_verkey), None, None).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
 
-    // ISSUER post to Ledger Schema, CredentialDefinition, RevocationRegistry
+struct Prover{
 
-    // Issuer creates Schema
-    let (schema_id, schema_json) = anoncreds::issuer_create_schema(&issuer_did,
-                                                                        GVT_SCHEMA_NAME,
-                                                                        SCHEMA_VERSION,
-                                                                        GVT_SCHEMA_ATTRIBUTES).unwrap();
-
-    // !!IMPORTANT!!
-    // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
-    // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
-
-    // Issuer posts Schema to Ledger
-    let schema_request = ledger::build_schema_request(&issuer_did, &schema_json).unwrap();
-    let schema_response = ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &schema_request).unwrap();
-
-    // Issuer gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&issuer_did), &schema_id).unwrap();
-    let get_schema_response = ledger::submit_request_with_retries(pool_handle, &get_schema_request, &schema_response).unwrap();
-    let (_, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Issuer creates CredentialDefinition
-    let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(issuer_wallet_handle,
-                                                                                           &issuer_did,
-                                                                                           &schema_json,
-                                                                                           TAG_1,
-                                                                                           None,
-                                                                                           Some(&anoncreds::revocation_cred_def_config())).unwrap();
-
-    // Issuer post CredentialDefinition to Ledger
-    let cred_def_request = ledger::build_cred_def_txn(&issuer_did, &cred_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &cred_def_request).unwrap();
-
-    // Issuer creates RevocationRegistry
-    let tails_writer_config = anoncreds::tails_writer_config();
-    let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
-
-    let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
-        anoncreds::issuer_create_and_store_revoc_reg(issuer_wallet_handle,
-                                                               &issuer_did,
-                                                               None,
-                                                               TAG_1,
-                                                               &cred_def_id,
-                                                               r#""{""max_cred_num"":5, ""issuance_type"":""ISSUANCE_ON_DEMAND""}""#,
-                                                               tails_writer_handle).unwrap();
-
-    // Issuer posts RevocationRegistryDefinition to Ledger
-    let rev_reg_def_request = ledger::build_revoc_reg_def_request(&issuer_did, &rev_reg_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_def_request).unwrap();
-
-    // Issuer posts RevocationRegistryEntry to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &rev_reg_entry_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
+    wallet_handle : i32,
+    did: String,
+    verkey : String,
+    master_secret_id : String,
+    cred_def_id : Option<String>,
+    cred_req_metadata_json : Option<String>
 
+}
 
-    // Issuance Credential for Prover
 
-    // Prover creates Master Secret
-    anoncreds::prover_create_master_secret(prover_wallet_handle, COMMON_MASTER_SECRET).unwrap();
+struct Verifier{
+    proof_request : String
+}
 
-    // Issuer creates Credential Offer
-    let cred_offer_json = anoncreds::issuer_create_credential_offer(issuer_wallet_handle, &cred_def_id).unwrap();
-    let cred_offer: CredentialOffer = serde_json::from_str(&cred_offer_json).unwrap();
-
-    // Prover gets CredentialDefinition from Ledger
-    let get_cred_def_request = ledger::build_get_cred_def_request(Some(&prover_did), &cred_offer.cred_def_id).unwrap();
-    let get_cred_def_response = ledger::submit_request(pool_handle, &get_cred_def_request).unwrap();
-    let (cred_def_id, cred_def_json) = ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap();
-
-    // Prover creates Credential Request
-    let (cred_req_json, cred_req_metadata_json) = anoncreds::prover_create_credential_req(prover_wallet_handle,
-                                                                                               &prover_did,
-                                                                                               &cred_offer_json,
-                                                                                               &cred_def_json,
-                                                                                               COMMON_MASTER_SECRET).unwrap();
-
-    // Issuer creates TailsReader
-    let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
-
-    // Issuer creates Credential
-    let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(issuer_wallet_handle,
-                                                                                                  &cred_offer_json,
-                                                                                                  &cred_req_json,
-                                                                                                  &anoncreds::gvt_credential_values_json(),
-                                                                                                  Some(&rev_reg_id),
-                                                                                                  Some(blob_storage_reader_handle)).unwrap();
-    let revoc_reg_delta_json = revoc_reg_delta_json.unwrap();
-    let cred_rev_id = cred_rev_id.unwrap();
-
-    // Issuer posts RevocationRegistryDelta to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &revoc_reg_delta_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
-
-    // Prover gets RevocationRegistryDefinition
-    let credential: Credential = serde_json::from_str(&cred_json).unwrap();
-    let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(Some(&prover_did), &credential.rev_reg_id.unwrap()).unwrap();
-    let get_rev_reg_def_response = ledger::submit_request(pool_handle, &get_rev_reg_def_request).unwrap();
-    let (_, revoc_reg_def_json) = ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap();
-
-    // Prover store received Credential
-    anoncreds::prover_store_credential(prover_wallet_handle,
-                                            CREDENTIAL1_ID,
-                                            &cred_req_metadata_json,
-                                            &cred_json,
-                                            &cred_def_json,
-                                            Some(&revoc_reg_def_json)).unwrap();
-
-    let credentials = anoncreds::prover_get_credentials(prover_wallet_handle, &json!({""schema_name"": GVT_SCHEMA_NAME}).to_string()).unwrap();
-    let credentials: Vec<serde_json::Value> = serde_json::from_str(&credentials).unwrap();
-    assert_eq!(credentials.len(), 1);
 
-    // Verifying Prover Credential
-    thread::sleep(std::time::Duration::from_secs(3));
+impl Pool {
 
-    let to = time::get_time().sec as u64;
 
-    let proof_request = json!({
-           ""nonce"":""123432421212"",
-           ""name"":""proof_req_1"",
-           ""version"":""0.1"",
-           ""requested_attributes"": json!({
-               ""attr1_referent"": json!({
-                   ""name"":""name""
-               })
-           }),
-           ""requested_predicates"": json!({
-               ""predicate1_referent"": json!({ ""name"":""age"", ""p_type"":"">="", ""p_value"":18 })
-           }),
-           ""non_revoked"": json!({ ""to"": to.clone() })
-        }).to_string();
+    pub fn new() -> Pool {
+        Pool{ pool_handle : pool::create_and_open_pool_ledger(POOL).unwrap() }
+    }
 
-    // Prover gets Credentials for Proof Request
-    let credentials_json = anoncreds::prover_get_credentials_for_proof_req(prover_wallet_handle, &proof_request).unwrap();
-    let cred_info = anoncreds::get_credential_for_attr_referent(&credentials_json, ""attr1_referent"");
-
-    // Prover gets RevocationRegistryDelta from Ledger
-    let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(Some(&prover_did), &cred_info.rev_reg_id.clone().unwrap(), None, to).unwrap();
-    let get_rev_reg_delta_response = ledger::submit_request(pool_handle, &get_rev_reg_delta_request).unwrap();
-    let (rev_reg_id, revoc_reg_delta_json, timestamp) = ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap();
-
-    // Prover creates RevocationState
-    let rev_state_json = anoncreds::create_revocation_state(blob_storage_reader_handle,
-                                                                 &revoc_reg_def_json,
-                                                                 &revoc_reg_delta_json,
-                                                                 timestamp,
-                                                                 &cred_info.cred_rev_id.clone().unwrap()).unwrap();
-
-    // Prover gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&prover_did), &cred_info.schema_id).unwrap();
-    let get_schema_response = ledger::submit_request(pool_handle, &get_schema_request).unwrap();
-    let (schema_id, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Prover creates Proof
-    let requested_credentials_json = json!({
-             ""self_attested_attributes"": json!({}),
-             ""requested_attributes"": json!({
-                ""attr1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp,  ""revealed"":true })
-             }),
-             ""requested_predicates"": json!({
-                ""predicate1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp })
-             })
-        }).to_string();
+    pub fn close(self) {
+        let _ = pool::close(self.pool_handle);
+    }
+
+
+    pub fn submit_nym(&self, issuer_did: &str, issuer_wallet_handle: i32, prover_did: &str, prover_verkey : Option<&str>)
+    {
+        let nym_request = ledger::build_nym_request(issuer_did, prover_did, prover_verkey, None, None).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
+    }
+
+    pub fn submit_schema(&self, issuer_did: &str, issuer_wallet_handle: i32, schema_json: &str) -> String {
+        let schema_request = ledger::build_schema_request(issuer_did, schema_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &schema_request).unwrap()
+    }
+
+    pub fn get_schema(&self, did: Option<&str>, schema_id: &str) -> (String, String){
+        let get_schema_request = ledger::build_get_schema_request(did, schema_id).unwrap();
+        let get_schema_response = ledger::submit_request(self.pool_handle, &get_schema_request).unwrap();
+        ledger::parse_get_schema_response(&get_schema_response).unwrap()
+
+    }
+
+    pub fn submit_cred_def(&self, issuer_did: &str, issuer_wallet_handle: i32, cred_def_json: &str) -> String {
+        let cred_def_request = ledger::build_cred_def_txn(issuer_did, cred_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &cred_def_request).unwrap()
+
+    }
+
+    pub fn get_cred_def(&self, did : Option<&str>, cred_def_id : &str ) -> (String, String) /* (cred_def_id, cred_def_json) */{
+        let get_cred_def_request = ledger::build_get_cred_def_request(did, cred_def_id).unwrap();
+        let get_cred_def_response = ledger::submit_request(self.pool_handle, &get_cred_def_request).unwrap();
+        ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_def(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_def_json : &str) -> String {
+        let rev_reg_def_request = ledger::build_revoc_reg_def_request(issuer_did, rev_reg_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_def_request).unwrap()
+    }
+
+    pub fn get_revoc_reg_def(&self, did: Option<&str>, revoc_reg_def_id : &str) -> (String, String) /* revoc_reg_def_id, revo_reg_def_json */ {
+        let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(did, &revoc_reg_def_id).unwrap();
+        let get_rev_reg_def_response = ledger::submit_request(self.pool_handle, &get_rev_reg_def_request).unwrap();
+        ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_entry(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_id : &str, rev_reg_entry_json: &str) -> String{
+        let rev_reg_entry_request =
+            ledger::build_revoc_reg_entry_request(issuer_did, rev_reg_id, REVOC_REG_TYPE, rev_reg_entry_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_entry_request).unwrap()
+
+    }
+
+    pub fn get_revoc_reg_delta(&self, did: Option<&str>, revoc_reg_def_id : &str, from : Option<u64>, to : u64) -> (String,String, u64) /* rev_reg_id, revoc_reg_delta_json, timestamp */ {
+        let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(did, revoc_reg_def_id, from, to).unwrap();
+        let get_rev_reg_delta_response = ledger::submit_request(self.pool_handle, &get_rev_reg_delta_request).unwrap();
+        ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap()
+    }
+
+
+}
+
+
+impl Issuer {
+
+
+    pub fn new(pool: &Pool) -> Issuer{
+
+        let wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+        Issuer {
+            // Issuer creates wallet, gets wallet handle
+            issuer_wallet_handle: wallet_handle,
+
+            // Issuer create DID
+            issuer_did: did::create_store_and_publish_my_did_from_trustee(wallet_handle, pool.pool_handle).unwrap().0,
+
+            schema_id: String::new(),
+            rev_reg_id : String::new(),
+            cred_def_id : String::new(),
+
+            revoc_registry_config : String::new()
+
+        }
+    }
+
+    // creates schema , credential definition and revocation registry
+    pub fn create_initial_ledger_state(& mut self, pool : &Pool, revoc_registry_config : &str)
+    {
+
+        self.revoc_registry_config = String::from(revoc_registry_config);
+
+        // Issuer creates Schema
+        let (schema_id, schema_json) = anoncreds::issuer_create_schema(&self.issuer_did,
+                                                                       GVT_SCHEMA_NAME,
+                                                                       SCHEMA_VERSION,
+                                                                       GVT_SCHEMA_ATTRIBUTES).unwrap();
+
+        // !!IMPORTANT!!
+        // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
+        // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
+        let _schema_response = pool.submit_schema(&self.issuer_did, self.issuer_wallet_handle,&schema_json);
+        // Issuer gets Schema from Ledger
+        let (_ , schema_json) = pool.get_schema(Some(&self.issuer_did),&schema_id);
+
+        self.schema_id = schema_id;
+
+        // Issuer creates CredentialDefinition
+        let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(self.issuer_wallet_handle,
+                                                                                          &self.issuer_did,
+                                                                                          &schema_json,
+                                                                                          TAG_1,
+                                                                                          None,
+                                                                                          Some(&anoncreds::revocation_cred_def_config())).unwrap();
+
+        // Issuer post CredentialDefinition to Ledger
+        pool.submit_cred_def(&self.issuer_did,self.issuer_wallet_handle,&cred_def_json);
+
+        self.cred_def_id = cred_def_id;
+
+        // Issuer creates RevocationRegistry
+        let tails_writer_config = anoncreds::tails_writer_config();
+        let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
 
-    let schemas_json = json!({
+        let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
+            anoncreds::issuer_create_and_store_revoc_reg(self.issuer_wallet_handle,
+                                                         &self.issuer_did,
+                                                         None,
+                                                         TAG_1,
+                                                         &self.cred_def_id,
+                                                         &self.revoc_registry_config,
+                                                         tails_writer_handle).unwrap();
+
+        // Issuer posts RevocationRegistryDefinition to Ledger
+        pool.submit_revoc_reg_def(&self.issuer_did, self.issuer_wallet_handle, &rev_reg_def_json);
+
+
+        self.rev_reg_id = rev_reg_id;
+
+        // Issuer posts RevocationRegistryEntry to Ledger
+        pool.submit_revoc_reg_entry(&self.issuer_did,self.issuer_wallet_handle, &self.rev_reg_id, &rev_reg_entry_json);
+    }
+
+    pub fn make_credential_offer(&self) -> String
+    {
+        let cred_offer_json = anoncreds::issuer_create_credential_offer(self.issuer_wallet_handle, &self.cred_def_id).unwrap();
+        cred_offer_json
+    }
+
+    pub fn issue_credential(&self, pool: &Pool, cred_offer_json: &str, cred_req_json: &str, cred_values_json: &str) -> (String, String, Option<String>)
+    {
+
+        use serde_json::Value;
+
+        let tails_writer_config = anoncreds::tails_writer_config();",,2019-02-15 14:25:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/257144711,https://github.com/hyperledger/indy-sdk/pull/1470#discussion_r257144711,olegbou777
https://github.com/hyperledger/indy-sdk/pull/1470,https://github.com/hyperledger/indy-sdk/pull/1470,"'revoc_registry_config' field is removed
'issuance_type' field is added ",930f0b793b9ba0d9a4f79f0bc92045149ca87bb7,2019-02-15 09:02:02,257151047,"@@ -45,481 +45,533 @@ use utils::domain::anoncreds::revocation_registry::RevocationRegistry;
 
 use std::thread;
 
-#[cfg(feature = ""revocation_tests"")]
-#[test]
-fn anoncreds_revocation_interaction_test_issuance_by_demand() {
-    utils::setup();
 
-    // Open Pool
-    let pool_handle = pool::create_and_open_pool_ledger(POOL).unwrap();
+struct Pool{
+    pool_handle : i32
+}
 
-    // Issuer creates wallet, gets wallet handle
-    let issuer_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
 
-    // Issuer create DID
-    let (issuer_did, _) = did::create_store_and_publish_my_did_from_trustee(issuer_wallet_handle, pool_handle).unwrap();
+struct Issuer{
+    issuer_wallet_handle: i32,
+    issuer_did : String,
 
-    // Prover creates wallet, gets wallet handle
-    let prover_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+    schema_id : String,
+    cred_def_id : String,
+    rev_reg_id : String,
 
-    // Prover create DID
-    let (prover_did, prover_verkey) = did::create_my_did(prover_wallet_handle, ""{}"").unwrap();
+    revoc_registry_config: String
+}
 
-    // Issuer publish Prover DID
-    let nym_request = ledger::build_nym_request(&issuer_did, &prover_did, Some(&prover_verkey), None, None).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
 
-    // ISSUER post to Ledger Schema, CredentialDefinition, RevocationRegistry
+struct Prover{
 
-    // Issuer creates Schema
-    let (schema_id, schema_json) = anoncreds::issuer_create_schema(&issuer_did,
-                                                                        GVT_SCHEMA_NAME,
-                                                                        SCHEMA_VERSION,
-                                                                        GVT_SCHEMA_ATTRIBUTES).unwrap();
-
-    // !!IMPORTANT!!
-    // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
-    // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
-
-    // Issuer posts Schema to Ledger
-    let schema_request = ledger::build_schema_request(&issuer_did, &schema_json).unwrap();
-    let schema_response = ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &schema_request).unwrap();
-
-    // Issuer gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&issuer_did), &schema_id).unwrap();
-    let get_schema_response = ledger::submit_request_with_retries(pool_handle, &get_schema_request, &schema_response).unwrap();
-    let (_, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Issuer creates CredentialDefinition
-    let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(issuer_wallet_handle,
-                                                                                           &issuer_did,
-                                                                                           &schema_json,
-                                                                                           TAG_1,
-                                                                                           None,
-                                                                                           Some(&anoncreds::revocation_cred_def_config())).unwrap();
-
-    // Issuer post CredentialDefinition to Ledger
-    let cred_def_request = ledger::build_cred_def_txn(&issuer_did, &cred_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &cred_def_request).unwrap();
-
-    // Issuer creates RevocationRegistry
-    let tails_writer_config = anoncreds::tails_writer_config();
-    let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
-
-    let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
-        anoncreds::issuer_create_and_store_revoc_reg(issuer_wallet_handle,
-                                                               &issuer_did,
-                                                               None,
-                                                               TAG_1,
-                                                               &cred_def_id,
-                                                               r#""{""max_cred_num"":5, ""issuance_type"":""ISSUANCE_ON_DEMAND""}""#,
-                                                               tails_writer_handle).unwrap();
-
-    // Issuer posts RevocationRegistryDefinition to Ledger
-    let rev_reg_def_request = ledger::build_revoc_reg_def_request(&issuer_did, &rev_reg_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_def_request).unwrap();
-
-    // Issuer posts RevocationRegistryEntry to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &rev_reg_entry_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
+    wallet_handle : i32,
+    did: String,
+    verkey : String,
+    master_secret_id : String,
+    cred_def_id : Option<String>,
+    cred_req_metadata_json : Option<String>
 
+}
 
-    // Issuance Credential for Prover
 
-    // Prover creates Master Secret
-    anoncreds::prover_create_master_secret(prover_wallet_handle, COMMON_MASTER_SECRET).unwrap();
+struct Verifier{
+    proof_request : String
+}
 
-    // Issuer creates Credential Offer
-    let cred_offer_json = anoncreds::issuer_create_credential_offer(issuer_wallet_handle, &cred_def_id).unwrap();
-    let cred_offer: CredentialOffer = serde_json::from_str(&cred_offer_json).unwrap();
-
-    // Prover gets CredentialDefinition from Ledger
-    let get_cred_def_request = ledger::build_get_cred_def_request(Some(&prover_did), &cred_offer.cred_def_id).unwrap();
-    let get_cred_def_response = ledger::submit_request(pool_handle, &get_cred_def_request).unwrap();
-    let (cred_def_id, cred_def_json) = ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap();
-
-    // Prover creates Credential Request
-    let (cred_req_json, cred_req_metadata_json) = anoncreds::prover_create_credential_req(prover_wallet_handle,
-                                                                                               &prover_did,
-                                                                                               &cred_offer_json,
-                                                                                               &cred_def_json,
-                                                                                               COMMON_MASTER_SECRET).unwrap();
-
-    // Issuer creates TailsReader
-    let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
-
-    // Issuer creates Credential
-    let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(issuer_wallet_handle,
-                                                                                                  &cred_offer_json,
-                                                                                                  &cred_req_json,
-                                                                                                  &anoncreds::gvt_credential_values_json(),
-                                                                                                  Some(&rev_reg_id),
-                                                                                                  Some(blob_storage_reader_handle)).unwrap();
-    let revoc_reg_delta_json = revoc_reg_delta_json.unwrap();
-    let cred_rev_id = cred_rev_id.unwrap();
-
-    // Issuer posts RevocationRegistryDelta to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &revoc_reg_delta_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
-
-    // Prover gets RevocationRegistryDefinition
-    let credential: Credential = serde_json::from_str(&cred_json).unwrap();
-    let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(Some(&prover_did), &credential.rev_reg_id.unwrap()).unwrap();
-    let get_rev_reg_def_response = ledger::submit_request(pool_handle, &get_rev_reg_def_request).unwrap();
-    let (_, revoc_reg_def_json) = ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap();
-
-    // Prover store received Credential
-    anoncreds::prover_store_credential(prover_wallet_handle,
-                                            CREDENTIAL1_ID,
-                                            &cred_req_metadata_json,
-                                            &cred_json,
-                                            &cred_def_json,
-                                            Some(&revoc_reg_def_json)).unwrap();
-
-    let credentials = anoncreds::prover_get_credentials(prover_wallet_handle, &json!({""schema_name"": GVT_SCHEMA_NAME}).to_string()).unwrap();
-    let credentials: Vec<serde_json::Value> = serde_json::from_str(&credentials).unwrap();
-    assert_eq!(credentials.len(), 1);
 
-    // Verifying Prover Credential
-    thread::sleep(std::time::Duration::from_secs(3));
+impl Pool {
 
-    let to = time::get_time().sec as u64;
 
-    let proof_request = json!({
-           ""nonce"":""123432421212"",
-           ""name"":""proof_req_1"",
-           ""version"":""0.1"",
-           ""requested_attributes"": json!({
-               ""attr1_referent"": json!({
-                   ""name"":""name""
-               })
-           }),
-           ""requested_predicates"": json!({
-               ""predicate1_referent"": json!({ ""name"":""age"", ""p_type"":"">="", ""p_value"":18 })
-           }),
-           ""non_revoked"": json!({ ""to"": to.clone() })
-        }).to_string();
+    pub fn new() -> Pool {
+        Pool{ pool_handle : pool::create_and_open_pool_ledger(POOL).unwrap() }
+    }
 
-    // Prover gets Credentials for Proof Request
-    let credentials_json = anoncreds::prover_get_credentials_for_proof_req(prover_wallet_handle, &proof_request).unwrap();
-    let cred_info = anoncreds::get_credential_for_attr_referent(&credentials_json, ""attr1_referent"");
-
-    // Prover gets RevocationRegistryDelta from Ledger
-    let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(Some(&prover_did), &cred_info.rev_reg_id.clone().unwrap(), None, to).unwrap();
-    let get_rev_reg_delta_response = ledger::submit_request(pool_handle, &get_rev_reg_delta_request).unwrap();
-    let (rev_reg_id, revoc_reg_delta_json, timestamp) = ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap();
-
-    // Prover creates RevocationState
-    let rev_state_json = anoncreds::create_revocation_state(blob_storage_reader_handle,
-                                                                 &revoc_reg_def_json,
-                                                                 &revoc_reg_delta_json,
-                                                                 timestamp,
-                                                                 &cred_info.cred_rev_id.clone().unwrap()).unwrap();
-
-    // Prover gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&prover_did), &cred_info.schema_id).unwrap();
-    let get_schema_response = ledger::submit_request(pool_handle, &get_schema_request).unwrap();
-    let (schema_id, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Prover creates Proof
-    let requested_credentials_json = json!({
-             ""self_attested_attributes"": json!({}),
-             ""requested_attributes"": json!({
-                ""attr1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp,  ""revealed"":true })
-             }),
-             ""requested_predicates"": json!({
-                ""predicate1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp })
-             })
-        }).to_string();
+    pub fn close(self) {
+        let _ = pool::close(self.pool_handle);
+    }
+
+
+    pub fn submit_nym(&self, issuer_did: &str, issuer_wallet_handle: i32, prover_did: &str, prover_verkey : Option<&str>)
+    {
+        let nym_request = ledger::build_nym_request(issuer_did, prover_did, prover_verkey, None, None).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
+    }
+
+    pub fn submit_schema(&self, issuer_did: &str, issuer_wallet_handle: i32, schema_json: &str) -> String {
+        let schema_request = ledger::build_schema_request(issuer_did, schema_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &schema_request).unwrap()
+    }
+
+    pub fn get_schema(&self, did: Option<&str>, schema_id: &str) -> (String, String){
+        let get_schema_request = ledger::build_get_schema_request(did, schema_id).unwrap();
+        let get_schema_response = ledger::submit_request(self.pool_handle, &get_schema_request).unwrap();
+        ledger::parse_get_schema_response(&get_schema_response).unwrap()
+
+    }
+
+    pub fn submit_cred_def(&self, issuer_did: &str, issuer_wallet_handle: i32, cred_def_json: &str) -> String {
+        let cred_def_request = ledger::build_cred_def_txn(issuer_did, cred_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &cred_def_request).unwrap()
+
+    }
+
+    pub fn get_cred_def(&self, did : Option<&str>, cred_def_id : &str ) -> (String, String) /* (cred_def_id, cred_def_json) */{
+        let get_cred_def_request = ledger::build_get_cred_def_request(did, cred_def_id).unwrap();
+        let get_cred_def_response = ledger::submit_request(self.pool_handle, &get_cred_def_request).unwrap();
+        ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_def(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_def_json : &str) -> String {
+        let rev_reg_def_request = ledger::build_revoc_reg_def_request(issuer_did, rev_reg_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_def_request).unwrap()
+    }
+
+    pub fn get_revoc_reg_def(&self, did: Option<&str>, revoc_reg_def_id : &str) -> (String, String) /* revoc_reg_def_id, revo_reg_def_json */ {
+        let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(did, &revoc_reg_def_id).unwrap();
+        let get_rev_reg_def_response = ledger::submit_request(self.pool_handle, &get_rev_reg_def_request).unwrap();
+        ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_entry(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_id : &str, rev_reg_entry_json: &str) -> String{
+        let rev_reg_entry_request =
+            ledger::build_revoc_reg_entry_request(issuer_did, rev_reg_id, REVOC_REG_TYPE, rev_reg_entry_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_entry_request).unwrap()
+
+    }
+
+    pub fn get_revoc_reg_delta(&self, did: Option<&str>, revoc_reg_def_id : &str, from : Option<u64>, to : u64) -> (String,String, u64) /* rev_reg_id, revoc_reg_delta_json, timestamp */ {
+        let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(did, revoc_reg_def_id, from, to).unwrap();
+        let get_rev_reg_delta_response = ledger::submit_request(self.pool_handle, &get_rev_reg_delta_request).unwrap();
+        ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap()
+    }
+
+
+}
+
+
+impl Issuer {
+
+
+    pub fn new(pool: &Pool) -> Issuer{
+
+        let wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+        Issuer {
+            // Issuer creates wallet, gets wallet handle
+            issuer_wallet_handle: wallet_handle,
+
+            // Issuer create DID
+            issuer_did: did::create_store_and_publish_my_did_from_trustee(wallet_handle, pool.pool_handle).unwrap().0,
+
+            schema_id: String::new(),
+            rev_reg_id : String::new(),
+            cred_def_id : String::new(),
+
+            revoc_registry_config : String::new()
+
+        }
+    }
+
+    // creates schema , credential definition and revocation registry
+    pub fn create_initial_ledger_state(& mut self, pool : &Pool, revoc_registry_config : &str)
+    {
+
+        self.revoc_registry_config = String::from(revoc_registry_config);
+
+        // Issuer creates Schema
+        let (schema_id, schema_json) = anoncreds::issuer_create_schema(&self.issuer_did,
+                                                                       GVT_SCHEMA_NAME,
+                                                                       SCHEMA_VERSION,
+                                                                       GVT_SCHEMA_ATTRIBUTES).unwrap();
+
+        // !!IMPORTANT!!
+        // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
+        // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
+        let _schema_response = pool.submit_schema(&self.issuer_did, self.issuer_wallet_handle,&schema_json);
+        // Issuer gets Schema from Ledger
+        let (_ , schema_json) = pool.get_schema(Some(&self.issuer_did),&schema_id);
+
+        self.schema_id = schema_id;
+
+        // Issuer creates CredentialDefinition
+        let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(self.issuer_wallet_handle,
+                                                                                          &self.issuer_did,
+                                                                                          &schema_json,
+                                                                                          TAG_1,
+                                                                                          None,
+                                                                                          Some(&anoncreds::revocation_cred_def_config())).unwrap();
+
+        // Issuer post CredentialDefinition to Ledger
+        pool.submit_cred_def(&self.issuer_did,self.issuer_wallet_handle,&cred_def_json);
+
+        self.cred_def_id = cred_def_id;
+
+        // Issuer creates RevocationRegistry
+        let tails_writer_config = anoncreds::tails_writer_config();
+        let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
 
-    let schemas_json = json!({
+        let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
+            anoncreds::issuer_create_and_store_revoc_reg(self.issuer_wallet_handle,
+                                                         &self.issuer_did,
+                                                         None,
+                                                         TAG_1,
+                                                         &self.cred_def_id,
+                                                         &self.revoc_registry_config,
+                                                         tails_writer_handle).unwrap();
+
+        // Issuer posts RevocationRegistryDefinition to Ledger
+        pool.submit_revoc_reg_def(&self.issuer_did, self.issuer_wallet_handle, &rev_reg_def_json);
+
+
+        self.rev_reg_id = rev_reg_id;
+
+        // Issuer posts RevocationRegistryEntry to Ledger
+        pool.submit_revoc_reg_entry(&self.issuer_did,self.issuer_wallet_handle, &self.rev_reg_id, &rev_reg_entry_json);
+    }
+
+    pub fn make_credential_offer(&self) -> String
+    {
+        let cred_offer_json = anoncreds::issuer_create_credential_offer(self.issuer_wallet_handle, &self.cred_def_id).unwrap();
+        cred_offer_json
+    }
+
+    pub fn issue_credential(&self, pool: &Pool, cred_offer_json: &str, cred_req_json: &str, cred_values_json: &str) -> (String, String, Option<String>)
+    {
+
+        use serde_json::Value;
+
+        let tails_writer_config = anoncreds::tails_writer_config();
+        // Issuer creates TailsReader
+        let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
+
+        // Issuer creates Credential
+        // NOte that  the function returns revoc_reg_delta_json as None in case
+        // the revocation registry was created with the strategy ISSUANCE_BY_DEFAULT
+        let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(self.issuer_wallet_handle,
+                                                                                                 &cred_offer_json,
+                                                                                                 &cred_req_json,
+                                                                                                 cred_values_json,
+                                                                                                 Some(&self.rev_reg_id),
+                                                                                                 Some(blob_storage_reader_handle)).unwrap();
+
+
+
+        // Issuer does not have to post rev_reg_delta to ledger in case of the strategy ISSUANCE_BY_DEFAULT
+        let revoc_reg_config_value : Value = serde_json::from_str(&self.revoc_registry_config).unwrap();
+        let issuance_type = revoc_reg_config_value.as_object().unwrap().get(""issuance_type"").unwrap().as_str().unwrap();
+
+        // Issuer posts RevocationRegistryDelta to Ledger
+        if issuance_type  == ""ISSUANCE_ON_DEMAND"" {",,2019-02-15 14:25:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/257151047,https://github.com/hyperledger/indy-sdk/pull/1470#discussion_r257151047,olegbou777
https://github.com/hyperledger/indy-sdk/pull/1470,https://github.com/hyperledger/indy-sdk/pull/1470,done,930f0b793b9ba0d9a4f79f0bc92045149ca87bb7,2019-02-15 09:03:20,257151377,"@@ -45,481 +45,533 @@ use utils::domain::anoncreds::revocation_registry::RevocationRegistry;
 
 use std::thread;
 
-#[cfg(feature = ""revocation_tests"")]
-#[test]
-fn anoncreds_revocation_interaction_test_issuance_by_demand() {
-    utils::setup();
 
-    // Open Pool
-    let pool_handle = pool::create_and_open_pool_ledger(POOL).unwrap();
+struct Pool{
+    pool_handle : i32
+}
 
-    // Issuer creates wallet, gets wallet handle
-    let issuer_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
 
-    // Issuer create DID
-    let (issuer_did, _) = did::create_store_and_publish_my_did_from_trustee(issuer_wallet_handle, pool_handle).unwrap();
+struct Issuer{
+    issuer_wallet_handle: i32,
+    issuer_did : String,
 
-    // Prover creates wallet, gets wallet handle
-    let prover_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+    schema_id : String,
+    cred_def_id : String,
+    rev_reg_id : String,
 
-    // Prover create DID
-    let (prover_did, prover_verkey) = did::create_my_did(prover_wallet_handle, ""{}"").unwrap();
+    revoc_registry_config: String
+}
 
-    // Issuer publish Prover DID
-    let nym_request = ledger::build_nym_request(&issuer_did, &prover_did, Some(&prover_verkey), None, None).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
 
-    // ISSUER post to Ledger Schema, CredentialDefinition, RevocationRegistry
+struct Prover{
 
-    // Issuer creates Schema
-    let (schema_id, schema_json) = anoncreds::issuer_create_schema(&issuer_did,
-                                                                        GVT_SCHEMA_NAME,
-                                                                        SCHEMA_VERSION,
-                                                                        GVT_SCHEMA_ATTRIBUTES).unwrap();
-
-    // !!IMPORTANT!!
-    // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
-    // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
-
-    // Issuer posts Schema to Ledger
-    let schema_request = ledger::build_schema_request(&issuer_did, &schema_json).unwrap();
-    let schema_response = ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &schema_request).unwrap();
-
-    // Issuer gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&issuer_did), &schema_id).unwrap();
-    let get_schema_response = ledger::submit_request_with_retries(pool_handle, &get_schema_request, &schema_response).unwrap();
-    let (_, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Issuer creates CredentialDefinition
-    let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(issuer_wallet_handle,
-                                                                                           &issuer_did,
-                                                                                           &schema_json,
-                                                                                           TAG_1,
-                                                                                           None,
-                                                                                           Some(&anoncreds::revocation_cred_def_config())).unwrap();
-
-    // Issuer post CredentialDefinition to Ledger
-    let cred_def_request = ledger::build_cred_def_txn(&issuer_did, &cred_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &cred_def_request).unwrap();
-
-    // Issuer creates RevocationRegistry
-    let tails_writer_config = anoncreds::tails_writer_config();
-    let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
-
-    let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
-        anoncreds::issuer_create_and_store_revoc_reg(issuer_wallet_handle,
-                                                               &issuer_did,
-                                                               None,
-                                                               TAG_1,
-                                                               &cred_def_id,
-                                                               r#""{""max_cred_num"":5, ""issuance_type"":""ISSUANCE_ON_DEMAND""}""#,
-                                                               tails_writer_handle).unwrap();
-
-    // Issuer posts RevocationRegistryDefinition to Ledger
-    let rev_reg_def_request = ledger::build_revoc_reg_def_request(&issuer_did, &rev_reg_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_def_request).unwrap();
-
-    // Issuer posts RevocationRegistryEntry to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &rev_reg_entry_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
+    wallet_handle : i32,
+    did: String,
+    verkey : String,
+    master_secret_id : String,
+    cred_def_id : Option<String>,
+    cred_req_metadata_json : Option<String>
 
+}
 
-    // Issuance Credential for Prover
 
-    // Prover creates Master Secret
-    anoncreds::prover_create_master_secret(prover_wallet_handle, COMMON_MASTER_SECRET).unwrap();
+struct Verifier{
+    proof_request : String
+}
 
-    // Issuer creates Credential Offer
-    let cred_offer_json = anoncreds::issuer_create_credential_offer(issuer_wallet_handle, &cred_def_id).unwrap();
-    let cred_offer: CredentialOffer = serde_json::from_str(&cred_offer_json).unwrap();
-
-    // Prover gets CredentialDefinition from Ledger
-    let get_cred_def_request = ledger::build_get_cred_def_request(Some(&prover_did), &cred_offer.cred_def_id).unwrap();
-    let get_cred_def_response = ledger::submit_request(pool_handle, &get_cred_def_request).unwrap();
-    let (cred_def_id, cred_def_json) = ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap();
-
-    // Prover creates Credential Request
-    let (cred_req_json, cred_req_metadata_json) = anoncreds::prover_create_credential_req(prover_wallet_handle,
-                                                                                               &prover_did,
-                                                                                               &cred_offer_json,
-                                                                                               &cred_def_json,
-                                                                                               COMMON_MASTER_SECRET).unwrap();
-
-    // Issuer creates TailsReader
-    let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
-
-    // Issuer creates Credential
-    let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(issuer_wallet_handle,
-                                                                                                  &cred_offer_json,
-                                                                                                  &cred_req_json,
-                                                                                                  &anoncreds::gvt_credential_values_json(),
-                                                                                                  Some(&rev_reg_id),
-                                                                                                  Some(blob_storage_reader_handle)).unwrap();
-    let revoc_reg_delta_json = revoc_reg_delta_json.unwrap();
-    let cred_rev_id = cred_rev_id.unwrap();
-
-    // Issuer posts RevocationRegistryDelta to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &revoc_reg_delta_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
-
-    // Prover gets RevocationRegistryDefinition
-    let credential: Credential = serde_json::from_str(&cred_json).unwrap();
-    let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(Some(&prover_did), &credential.rev_reg_id.unwrap()).unwrap();
-    let get_rev_reg_def_response = ledger::submit_request(pool_handle, &get_rev_reg_def_request).unwrap();
-    let (_, revoc_reg_def_json) = ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap();
-
-    // Prover store received Credential
-    anoncreds::prover_store_credential(prover_wallet_handle,
-                                            CREDENTIAL1_ID,
-                                            &cred_req_metadata_json,
-                                            &cred_json,
-                                            &cred_def_json,
-                                            Some(&revoc_reg_def_json)).unwrap();
-
-    let credentials = anoncreds::prover_get_credentials(prover_wallet_handle, &json!({""schema_name"": GVT_SCHEMA_NAME}).to_string()).unwrap();
-    let credentials: Vec<serde_json::Value> = serde_json::from_str(&credentials).unwrap();
-    assert_eq!(credentials.len(), 1);
 
-    // Verifying Prover Credential
-    thread::sleep(std::time::Duration::from_secs(3));
+impl Pool {
 
-    let to = time::get_time().sec as u64;
 
-    let proof_request = json!({
-           ""nonce"":""123432421212"",
-           ""name"":""proof_req_1"",
-           ""version"":""0.1"",
-           ""requested_attributes"": json!({
-               ""attr1_referent"": json!({
-                   ""name"":""name""
-               })
-           }),
-           ""requested_predicates"": json!({
-               ""predicate1_referent"": json!({ ""name"":""age"", ""p_type"":"">="", ""p_value"":18 })
-           }),
-           ""non_revoked"": json!({ ""to"": to.clone() })
-        }).to_string();
+    pub fn new() -> Pool {
+        Pool{ pool_handle : pool::create_and_open_pool_ledger(POOL).unwrap() }
+    }
 
-    // Prover gets Credentials for Proof Request
-    let credentials_json = anoncreds::prover_get_credentials_for_proof_req(prover_wallet_handle, &proof_request).unwrap();
-    let cred_info = anoncreds::get_credential_for_attr_referent(&credentials_json, ""attr1_referent"");
-
-    // Prover gets RevocationRegistryDelta from Ledger
-    let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(Some(&prover_did), &cred_info.rev_reg_id.clone().unwrap(), None, to).unwrap();
-    let get_rev_reg_delta_response = ledger::submit_request(pool_handle, &get_rev_reg_delta_request).unwrap();
-    let (rev_reg_id, revoc_reg_delta_json, timestamp) = ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap();
-
-    // Prover creates RevocationState
-    let rev_state_json = anoncreds::create_revocation_state(blob_storage_reader_handle,
-                                                                 &revoc_reg_def_json,
-                                                                 &revoc_reg_delta_json,
-                                                                 timestamp,
-                                                                 &cred_info.cred_rev_id.clone().unwrap()).unwrap();
-
-    // Prover gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&prover_did), &cred_info.schema_id).unwrap();
-    let get_schema_response = ledger::submit_request(pool_handle, &get_schema_request).unwrap();
-    let (schema_id, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Prover creates Proof
-    let requested_credentials_json = json!({
-             ""self_attested_attributes"": json!({}),
-             ""requested_attributes"": json!({
-                ""attr1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp,  ""revealed"":true })
-             }),
-             ""requested_predicates"": json!({
-                ""predicate1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp })
-             })
-        }).to_string();
+    pub fn close(self) {
+        let _ = pool::close(self.pool_handle);
+    }
+
+
+    pub fn submit_nym(&self, issuer_did: &str, issuer_wallet_handle: i32, prover_did: &str, prover_verkey : Option<&str>)
+    {
+        let nym_request = ledger::build_nym_request(issuer_did, prover_did, prover_verkey, None, None).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
+    }
+
+    pub fn submit_schema(&self, issuer_did: &str, issuer_wallet_handle: i32, schema_json: &str) -> String {
+        let schema_request = ledger::build_schema_request(issuer_did, schema_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &schema_request).unwrap()
+    }
+
+    pub fn get_schema(&self, did: Option<&str>, schema_id: &str) -> (String, String){
+        let get_schema_request = ledger::build_get_schema_request(did, schema_id).unwrap();
+        let get_schema_response = ledger::submit_request(self.pool_handle, &get_schema_request).unwrap();
+        ledger::parse_get_schema_response(&get_schema_response).unwrap()
+
+    }
+
+    pub fn submit_cred_def(&self, issuer_did: &str, issuer_wallet_handle: i32, cred_def_json: &str) -> String {
+        let cred_def_request = ledger::build_cred_def_txn(issuer_did, cred_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &cred_def_request).unwrap()
+
+    }
+
+    pub fn get_cred_def(&self, did : Option<&str>, cred_def_id : &str ) -> (String, String) /* (cred_def_id, cred_def_json) */{
+        let get_cred_def_request = ledger::build_get_cred_def_request(did, cred_def_id).unwrap();
+        let get_cred_def_response = ledger::submit_request(self.pool_handle, &get_cred_def_request).unwrap();
+        ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_def(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_def_json : &str) -> String {
+        let rev_reg_def_request = ledger::build_revoc_reg_def_request(issuer_did, rev_reg_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_def_request).unwrap()
+    }
+
+    pub fn get_revoc_reg_def(&self, did: Option<&str>, revoc_reg_def_id : &str) -> (String, String) /* revoc_reg_def_id, revo_reg_def_json */ {
+        let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(did, &revoc_reg_def_id).unwrap();
+        let get_rev_reg_def_response = ledger::submit_request(self.pool_handle, &get_rev_reg_def_request).unwrap();
+        ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_entry(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_id : &str, rev_reg_entry_json: &str) -> String{
+        let rev_reg_entry_request =
+            ledger::build_revoc_reg_entry_request(issuer_did, rev_reg_id, REVOC_REG_TYPE, rev_reg_entry_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_entry_request).unwrap()
+
+    }
+
+    pub fn get_revoc_reg_delta(&self, did: Option<&str>, revoc_reg_def_id : &str, from : Option<u64>, to : u64) -> (String,String, u64) /* rev_reg_id, revoc_reg_delta_json, timestamp */ {
+        let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(did, revoc_reg_def_id, from, to).unwrap();
+        let get_rev_reg_delta_response = ledger::submit_request(self.pool_handle, &get_rev_reg_delta_request).unwrap();
+        ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap()
+    }
+
+
+}
+
+
+impl Issuer {
+
+
+    pub fn new(pool: &Pool) -> Issuer{
+
+        let wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+        Issuer {
+            // Issuer creates wallet, gets wallet handle
+            issuer_wallet_handle: wallet_handle,
+
+            // Issuer create DID
+            issuer_did: did::create_store_and_publish_my_did_from_trustee(wallet_handle, pool.pool_handle).unwrap().0,
+
+            schema_id: String::new(),
+            rev_reg_id : String::new(),
+            cred_def_id : String::new(),
+
+            revoc_registry_config : String::new()
+
+        }
+    }
+
+    // creates schema , credential definition and revocation registry
+    pub fn create_initial_ledger_state(& mut self, pool : &Pool, revoc_registry_config : &str)
+    {
+
+        self.revoc_registry_config = String::from(revoc_registry_config);
+
+        // Issuer creates Schema
+        let (schema_id, schema_json) = anoncreds::issuer_create_schema(&self.issuer_did,
+                                                                       GVT_SCHEMA_NAME,
+                                                                       SCHEMA_VERSION,
+                                                                       GVT_SCHEMA_ATTRIBUTES).unwrap();
+
+        // !!IMPORTANT!!
+        // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
+        // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
+        let _schema_response = pool.submit_schema(&self.issuer_did, self.issuer_wallet_handle,&schema_json);
+        // Issuer gets Schema from Ledger
+        let (_ , schema_json) = pool.get_schema(Some(&self.issuer_did),&schema_id);
+
+        self.schema_id = schema_id;
+
+        // Issuer creates CredentialDefinition
+        let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(self.issuer_wallet_handle,
+                                                                                          &self.issuer_did,
+                                                                                          &schema_json,
+                                                                                          TAG_1,
+                                                                                          None,
+                                                                                          Some(&anoncreds::revocation_cred_def_config())).unwrap();
+
+        // Issuer post CredentialDefinition to Ledger
+        pool.submit_cred_def(&self.issuer_did,self.issuer_wallet_handle,&cred_def_json);
+
+        self.cred_def_id = cred_def_id;
+
+        // Issuer creates RevocationRegistry
+        let tails_writer_config = anoncreds::tails_writer_config();
+        let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
 
-    let schemas_json = json!({
+        let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
+            anoncreds::issuer_create_and_store_revoc_reg(self.issuer_wallet_handle,
+                                                         &self.issuer_did,
+                                                         None,
+                                                         TAG_1,
+                                                         &self.cred_def_id,
+                                                         &self.revoc_registry_config,
+                                                         tails_writer_handle).unwrap();
+
+        // Issuer posts RevocationRegistryDefinition to Ledger
+        pool.submit_revoc_reg_def(&self.issuer_did, self.issuer_wallet_handle, &rev_reg_def_json);
+
+
+        self.rev_reg_id = rev_reg_id;
+
+        // Issuer posts RevocationRegistryEntry to Ledger
+        pool.submit_revoc_reg_entry(&self.issuer_did,self.issuer_wallet_handle, &self.rev_reg_id, &rev_reg_entry_json);
+    }
+
+    pub fn make_credential_offer(&self) -> String
+    {
+        let cred_offer_json = anoncreds::issuer_create_credential_offer(self.issuer_wallet_handle, &self.cred_def_id).unwrap();
+        cred_offer_json
+    }
+
+    pub fn issue_credential(&self, pool: &Pool, cred_offer_json: &str, cred_req_json: &str, cred_values_json: &str) -> (String, String, Option<String>)
+    {
+
+        use serde_json::Value;
+
+        let tails_writer_config = anoncreds::tails_writer_config();
+        // Issuer creates TailsReader
+        let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
+
+        // Issuer creates Credential
+        // NOte that  the function returns revoc_reg_delta_json as None in case
+        // the revocation registry was created with the strategy ISSUANCE_BY_DEFAULT
+        let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(self.issuer_wallet_handle,
+                                                                                                 &cred_offer_json,
+                                                                                                 &cred_req_json,
+                                                                                                 cred_values_json,
+                                                                                                 Some(&self.rev_reg_id),
+                                                                                                 Some(blob_storage_reader_handle)).unwrap();
+
+
+
+        // Issuer does not have to post rev_reg_delta to ledger in case of the strategy ISSUANCE_BY_DEFAULT
+        let revoc_reg_config_value : Value = serde_json::from_str(&self.revoc_registry_config).unwrap();
+        let issuance_type = revoc_reg_config_value.as_object().unwrap().get(""issuance_type"").unwrap().as_str().unwrap();
+
+        // Issuer posts RevocationRegistryDelta to Ledger
+        if issuance_type  == ""ISSUANCE_ON_DEMAND"" {
+            pool.submit_revoc_reg_entry(&self.issuer_did, self.issuer_wallet_handle, &self.rev_reg_id, &revoc_reg_delta_json.clone().unwrap());
+        }
+
+        (cred_json, cred_rev_id.unwrap(), revoc_reg_delta_json)
+    }
+
+    pub fn revoke_credential(&self, pool : &Pool, cred_rev_id: &str) -> String
+    {
+
+        let tails_writer_config = anoncreds::tails_writer_config();
+        // Issuer creates TailsReader
+        let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
+
+        // Issuer revokes cred_info
+        let rev_reg_delta_json = anoncreds::issuer_revoke_credential(self.issuer_wallet_handle, blob_storage_reader_handle, &self.rev_reg_id, &cred_rev_id).unwrap();
+
+        // Issuer post RevocationRegistryDelta to Ledger
+        pool.submit_revoc_reg_entry(&self.issuer_did,self.issuer_wallet_handle,&self.rev_reg_id,&rev_reg_delta_json);
+
+        rev_reg_delta_json
+    }
+
+    pub fn close(&self)
+    {
+        wallet::close_wallet(self.issuer_wallet_handle).unwrap();
+    }
+}
+
+
+impl Prover
+{
+    pub fn new(master_secret_id : Option<&str>) -> Prover
+    {
+        // Prover creates wallet, gets wallet handle
+        let prover_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+        // Prover create DID
+        let (prover_did, prover_verkey) = did::create_my_did(prover_wallet_handle, ""{}"").unwrap();
+        // Prover creates Master Secret
+        let master_secret_id = master_secret_id.unwrap_or(COMMON_MASTER_SECRET);
+        anoncreds::prover_create_master_secret(prover_wallet_handle, master_secret_id).unwrap();
+
+        Prover{ wallet_handle: prover_wallet_handle,
+                did: prover_did.clone(),
+                verkey: prover_verkey.clone(),
+                master_secret_id : String::from(master_secret_id),
+                cred_def_id: None,
+                cred_req_metadata_json : None
+             }
+    }
+
+
+    pub fn make_credential_request(&mut self, pool: &Pool,  cred_offer_json :  &str ) -> String
+    {
+        // Prover gets CredentialDefinition from Ledger
+        let cred_offer: CredentialOffer = serde_json::from_str(&cred_offer_json).unwrap();
+        let (cred_def_id, cred_def_json) = pool.get_cred_def(Some(&self.did), &cred_offer.cred_def_id);
+        self.cred_def_id = Some(cred_def_id);
+
+        // Prover creates Credential Request
+        let (cred_req_json, cred_req_metadata_json) = anoncreds::prover_create_credential_req(self.wallet_handle,
+                                                                                              &self.did,
+                                                                                              &cred_offer_json,
+                                                                                              &cred_def_json,
+                                                                                              &self.master_secret_id).unwrap();
+        self.cred_req_metadata_json = Some(cred_req_metadata_json);
+        cred_req_json
+    }
+
+
+    pub fn store_credentials(&self, pool: &Pool, cred_json: &str, cred_id: &str)
+    {
+        let credential: Credential = serde_json::from_str(&cred_json).unwrap();
+
+        // Prover gets CredentialDefinition from Ledger
+        let (_ , cred_def_json) = pool.get_cred_def(Some(&self.did), &self.cred_def_id.clone().unwrap());
+
+        // Prover gets RevocationRegistryDefinition
+        let (_, revoc_reg_def_json) = pool.get_revoc_reg_def(None,&credential.rev_reg_id.unwrap());
+
+        // Prover stores received Credential
+        anoncreds::prover_store_credential(self.wallet_handle,
+                                           cred_id,
+                                           &self.cred_req_metadata_json.clone().unwrap(),
+                                           &cred_json,
+                                           &cred_def_json,
+                                           Some(&revoc_reg_def_json)).unwrap();
+    }
+
+    pub fn make_proof(&self, pool : &Pool, proof_request: &str, attr1_referent: &str, from: Option<u64>, to: u64 ) -> String
+    {
+
+        use serde_json::Value;",,2019-02-15 14:25:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/257151377,https://github.com/hyperledger/indy-sdk/pull/1470#discussion_r257151377,olegbou777
https://github.com/hyperledger/indy-sdk/pull/1470,https://github.com/hyperledger/indy-sdk/pull/1470,Done,930f0b793b9ba0d9a4f79f0bc92045149ca87bb7,2019-02-15 10:37:22,257183930,"@@ -45,481 +45,533 @@ use utils::domain::anoncreds::revocation_registry::RevocationRegistry;
 
 use std::thread;
 
-#[cfg(feature = ""revocation_tests"")]
-#[test]
-fn anoncreds_revocation_interaction_test_issuance_by_demand() {
-    utils::setup();
 
-    // Open Pool
-    let pool_handle = pool::create_and_open_pool_ledger(POOL).unwrap();
+struct Pool{
+    pool_handle : i32
+}
 
-    // Issuer creates wallet, gets wallet handle
-    let issuer_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
 
-    // Issuer create DID
-    let (issuer_did, _) = did::create_store_and_publish_my_did_from_trustee(issuer_wallet_handle, pool_handle).unwrap();
+struct Issuer{
+    issuer_wallet_handle: i32,
+    issuer_did : String,
 
-    // Prover creates wallet, gets wallet handle
-    let prover_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+    schema_id : String,
+    cred_def_id : String,
+    rev_reg_id : String,
 
-    // Prover create DID
-    let (prover_did, prover_verkey) = did::create_my_did(prover_wallet_handle, ""{}"").unwrap();
+    revoc_registry_config: String
+}
 
-    // Issuer publish Prover DID
-    let nym_request = ledger::build_nym_request(&issuer_did, &prover_did, Some(&prover_verkey), None, None).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
 
-    // ISSUER post to Ledger Schema, CredentialDefinition, RevocationRegistry
+struct Prover{
 
-    // Issuer creates Schema
-    let (schema_id, schema_json) = anoncreds::issuer_create_schema(&issuer_did,
-                                                                        GVT_SCHEMA_NAME,
-                                                                        SCHEMA_VERSION,
-                                                                        GVT_SCHEMA_ATTRIBUTES).unwrap();
-
-    // !!IMPORTANT!!
-    // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
-    // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
-
-    // Issuer posts Schema to Ledger
-    let schema_request = ledger::build_schema_request(&issuer_did, &schema_json).unwrap();
-    let schema_response = ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &schema_request).unwrap();
-
-    // Issuer gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&issuer_did), &schema_id).unwrap();
-    let get_schema_response = ledger::submit_request_with_retries(pool_handle, &get_schema_request, &schema_response).unwrap();
-    let (_, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Issuer creates CredentialDefinition
-    let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(issuer_wallet_handle,
-                                                                                           &issuer_did,
-                                                                                           &schema_json,
-                                                                                           TAG_1,
-                                                                                           None,
-                                                                                           Some(&anoncreds::revocation_cred_def_config())).unwrap();
-
-    // Issuer post CredentialDefinition to Ledger
-    let cred_def_request = ledger::build_cred_def_txn(&issuer_did, &cred_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &cred_def_request).unwrap();
-
-    // Issuer creates RevocationRegistry
-    let tails_writer_config = anoncreds::tails_writer_config();
-    let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
-
-    let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
-        anoncreds::issuer_create_and_store_revoc_reg(issuer_wallet_handle,
-                                                               &issuer_did,
-                                                               None,
-                                                               TAG_1,
-                                                               &cred_def_id,
-                                                               r#""{""max_cred_num"":5, ""issuance_type"":""ISSUANCE_ON_DEMAND""}""#,
-                                                               tails_writer_handle).unwrap();
-
-    // Issuer posts RevocationRegistryDefinition to Ledger
-    let rev_reg_def_request = ledger::build_revoc_reg_def_request(&issuer_did, &rev_reg_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_def_request).unwrap();
-
-    // Issuer posts RevocationRegistryEntry to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &rev_reg_entry_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
+    wallet_handle : i32,
+    did: String,
+    verkey : String,
+    master_secret_id : String,
+    cred_def_id : Option<String>,
+    cred_req_metadata_json : Option<String>
 
+}
 
-    // Issuance Credential for Prover
 
-    // Prover creates Master Secret
-    anoncreds::prover_create_master_secret(prover_wallet_handle, COMMON_MASTER_SECRET).unwrap();
+struct Verifier{
+    proof_request : String
+}
 
-    // Issuer creates Credential Offer
-    let cred_offer_json = anoncreds::issuer_create_credential_offer(issuer_wallet_handle, &cred_def_id).unwrap();
-    let cred_offer: CredentialOffer = serde_json::from_str(&cred_offer_json).unwrap();
-
-    // Prover gets CredentialDefinition from Ledger
-    let get_cred_def_request = ledger::build_get_cred_def_request(Some(&prover_did), &cred_offer.cred_def_id).unwrap();
-    let get_cred_def_response = ledger::submit_request(pool_handle, &get_cred_def_request).unwrap();
-    let (cred_def_id, cred_def_json) = ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap();
-
-    // Prover creates Credential Request
-    let (cred_req_json, cred_req_metadata_json) = anoncreds::prover_create_credential_req(prover_wallet_handle,
-                                                                                               &prover_did,
-                                                                                               &cred_offer_json,
-                                                                                               &cred_def_json,
-                                                                                               COMMON_MASTER_SECRET).unwrap();
-
-    // Issuer creates TailsReader
-    let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
-
-    // Issuer creates Credential
-    let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(issuer_wallet_handle,
-                                                                                                  &cred_offer_json,
-                                                                                                  &cred_req_json,
-                                                                                                  &anoncreds::gvt_credential_values_json(),
-                                                                                                  Some(&rev_reg_id),
-                                                                                                  Some(blob_storage_reader_handle)).unwrap();
-    let revoc_reg_delta_json = revoc_reg_delta_json.unwrap();
-    let cred_rev_id = cred_rev_id.unwrap();
-
-    // Issuer posts RevocationRegistryDelta to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &revoc_reg_delta_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
-
-    // Prover gets RevocationRegistryDefinition
-    let credential: Credential = serde_json::from_str(&cred_json).unwrap();
-    let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(Some(&prover_did), &credential.rev_reg_id.unwrap()).unwrap();
-    let get_rev_reg_def_response = ledger::submit_request(pool_handle, &get_rev_reg_def_request).unwrap();
-    let (_, revoc_reg_def_json) = ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap();
-
-    // Prover store received Credential
-    anoncreds::prover_store_credential(prover_wallet_handle,
-                                            CREDENTIAL1_ID,
-                                            &cred_req_metadata_json,
-                                            &cred_json,
-                                            &cred_def_json,
-                                            Some(&revoc_reg_def_json)).unwrap();
-
-    let credentials = anoncreds::prover_get_credentials(prover_wallet_handle, &json!({""schema_name"": GVT_SCHEMA_NAME}).to_string()).unwrap();
-    let credentials: Vec<serde_json::Value> = serde_json::from_str(&credentials).unwrap();
-    assert_eq!(credentials.len(), 1);
 
-    // Verifying Prover Credential
-    thread::sleep(std::time::Duration::from_secs(3));
+impl Pool {
 
-    let to = time::get_time().sec as u64;
 
-    let proof_request = json!({
-           ""nonce"":""123432421212"",
-           ""name"":""proof_req_1"",
-           ""version"":""0.1"",
-           ""requested_attributes"": json!({
-               ""attr1_referent"": json!({
-                   ""name"":""name""
-               })
-           }),
-           ""requested_predicates"": json!({
-               ""predicate1_referent"": json!({ ""name"":""age"", ""p_type"":"">="", ""p_value"":18 })
-           }),
-           ""non_revoked"": json!({ ""to"": to.clone() })
-        }).to_string();
+    pub fn new() -> Pool {
+        Pool{ pool_handle : pool::create_and_open_pool_ledger(POOL).unwrap() }
+    }
 
-    // Prover gets Credentials for Proof Request
-    let credentials_json = anoncreds::prover_get_credentials_for_proof_req(prover_wallet_handle, &proof_request).unwrap();
-    let cred_info = anoncreds::get_credential_for_attr_referent(&credentials_json, ""attr1_referent"");
-
-    // Prover gets RevocationRegistryDelta from Ledger
-    let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(Some(&prover_did), &cred_info.rev_reg_id.clone().unwrap(), None, to).unwrap();
-    let get_rev_reg_delta_response = ledger::submit_request(pool_handle, &get_rev_reg_delta_request).unwrap();
-    let (rev_reg_id, revoc_reg_delta_json, timestamp) = ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap();
-
-    // Prover creates RevocationState
-    let rev_state_json = anoncreds::create_revocation_state(blob_storage_reader_handle,
-                                                                 &revoc_reg_def_json,
-                                                                 &revoc_reg_delta_json,
-                                                                 timestamp,
-                                                                 &cred_info.cred_rev_id.clone().unwrap()).unwrap();
-
-    // Prover gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&prover_did), &cred_info.schema_id).unwrap();
-    let get_schema_response = ledger::submit_request(pool_handle, &get_schema_request).unwrap();
-    let (schema_id, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Prover creates Proof
-    let requested_credentials_json = json!({
-             ""self_attested_attributes"": json!({}),
-             ""requested_attributes"": json!({
-                ""attr1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp,  ""revealed"":true })
-             }),
-             ""requested_predicates"": json!({
-                ""predicate1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp })
-             })
-        }).to_string();
+    pub fn close(self) {
+        let _ = pool::close(self.pool_handle);
+    }
+
+
+    pub fn submit_nym(&self, issuer_did: &str, issuer_wallet_handle: i32, prover_did: &str, prover_verkey : Option<&str>)
+    {
+        let nym_request = ledger::build_nym_request(issuer_did, prover_did, prover_verkey, None, None).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
+    }
+
+    pub fn submit_schema(&self, issuer_did: &str, issuer_wallet_handle: i32, schema_json: &str) -> String {
+        let schema_request = ledger::build_schema_request(issuer_did, schema_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &schema_request).unwrap()
+    }
+
+    pub fn get_schema(&self, did: Option<&str>, schema_id: &str) -> (String, String){
+        let get_schema_request = ledger::build_get_schema_request(did, schema_id).unwrap();
+        let get_schema_response = ledger::submit_request(self.pool_handle, &get_schema_request).unwrap();
+        ledger::parse_get_schema_response(&get_schema_response).unwrap()
+
+    }
+
+    pub fn submit_cred_def(&self, issuer_did: &str, issuer_wallet_handle: i32, cred_def_json: &str) -> String {
+        let cred_def_request = ledger::build_cred_def_txn(issuer_did, cred_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &cred_def_request).unwrap()
+
+    }
+
+    pub fn get_cred_def(&self, did : Option<&str>, cred_def_id : &str ) -> (String, String) /* (cred_def_id, cred_def_json) */{
+        let get_cred_def_request = ledger::build_get_cred_def_request(did, cred_def_id).unwrap();
+        let get_cred_def_response = ledger::submit_request(self.pool_handle, &get_cred_def_request).unwrap();
+        ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_def(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_def_json : &str) -> String {
+        let rev_reg_def_request = ledger::build_revoc_reg_def_request(issuer_did, rev_reg_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_def_request).unwrap()
+    }
+
+    pub fn get_revoc_reg_def(&self, did: Option<&str>, revoc_reg_def_id : &str) -> (String, String) /* revoc_reg_def_id, revo_reg_def_json */ {
+        let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(did, &revoc_reg_def_id).unwrap();
+        let get_rev_reg_def_response = ledger::submit_request(self.pool_handle, &get_rev_reg_def_request).unwrap();
+        ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_entry(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_id : &str, rev_reg_entry_json: &str) -> String{
+        let rev_reg_entry_request =
+            ledger::build_revoc_reg_entry_request(issuer_did, rev_reg_id, REVOC_REG_TYPE, rev_reg_entry_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_entry_request).unwrap()
+
+    }
+
+    pub fn get_revoc_reg_delta(&self, did: Option<&str>, revoc_reg_def_id : &str, from : Option<u64>, to : u64) -> (String,String, u64) /* rev_reg_id, revoc_reg_delta_json, timestamp */ {
+        let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(did, revoc_reg_def_id, from, to).unwrap();
+        let get_rev_reg_delta_response = ledger::submit_request(self.pool_handle, &get_rev_reg_delta_request).unwrap();
+        ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap()
+    }
+
+
+}
+
+
+impl Issuer {
+
+
+    pub fn new(pool: &Pool) -> Issuer{
+
+        let wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+        Issuer {
+            // Issuer creates wallet, gets wallet handle
+            issuer_wallet_handle: wallet_handle,
+
+            // Issuer create DID
+            issuer_did: did::create_store_and_publish_my_did_from_trustee(wallet_handle, pool.pool_handle).unwrap().0,
+
+            schema_id: String::new(),
+            rev_reg_id : String::new(),
+            cred_def_id : String::new(),
+
+            revoc_registry_config : String::new()
+
+        }
+    }
+
+    // creates schema , credential definition and revocation registry
+    pub fn create_initial_ledger_state(& mut self, pool : &Pool, revoc_registry_config : &str)
+    {
+
+        self.revoc_registry_config = String::from(revoc_registry_config);
+
+        // Issuer creates Schema
+        let (schema_id, schema_json) = anoncreds::issuer_create_schema(&self.issuer_did,
+                                                                       GVT_SCHEMA_NAME,
+                                                                       SCHEMA_VERSION,
+                                                                       GVT_SCHEMA_ATTRIBUTES).unwrap();
+
+        // !!IMPORTANT!!
+        // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
+        // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
+        let _schema_response = pool.submit_schema(&self.issuer_did, self.issuer_wallet_handle,&schema_json);
+        // Issuer gets Schema from Ledger
+        let (_ , schema_json) = pool.get_schema(Some(&self.issuer_did),&schema_id);
+
+        self.schema_id = schema_id;
+
+        // Issuer creates CredentialDefinition
+        let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(self.issuer_wallet_handle,
+                                                                                          &self.issuer_did,
+                                                                                          &schema_json,
+                                                                                          TAG_1,
+                                                                                          None,
+                                                                                          Some(&anoncreds::revocation_cred_def_config())).unwrap();
+
+        // Issuer post CredentialDefinition to Ledger
+        pool.submit_cred_def(&self.issuer_did,self.issuer_wallet_handle,&cred_def_json);
+
+        self.cred_def_id = cred_def_id;
+
+        // Issuer creates RevocationRegistry
+        let tails_writer_config = anoncreds::tails_writer_config();
+        let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
 
-    let schemas_json = json!({
+        let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
+            anoncreds::issuer_create_and_store_revoc_reg(self.issuer_wallet_handle,
+                                                         &self.issuer_did,
+                                                         None,
+                                                         TAG_1,
+                                                         &self.cred_def_id,
+                                                         &self.revoc_registry_config,
+                                                         tails_writer_handle).unwrap();
+
+        // Issuer posts RevocationRegistryDefinition to Ledger
+        pool.submit_revoc_reg_def(&self.issuer_did, self.issuer_wallet_handle, &rev_reg_def_json);
+
+
+        self.rev_reg_id = rev_reg_id;
+
+        // Issuer posts RevocationRegistryEntry to Ledger
+        pool.submit_revoc_reg_entry(&self.issuer_did,self.issuer_wallet_handle, &self.rev_reg_id, &rev_reg_entry_json);
+    }
+
+    pub fn make_credential_offer(&self) -> String
+    {
+        let cred_offer_json = anoncreds::issuer_create_credential_offer(self.issuer_wallet_handle, &self.cred_def_id).unwrap();
+        cred_offer_json
+    }
+
+    pub fn issue_credential(&self, pool: &Pool, cred_offer_json: &str, cred_req_json: &str, cred_values_json: &str) -> (String, String, Option<String>)
+    {
+
+        use serde_json::Value;
+
+        let tails_writer_config = anoncreds::tails_writer_config();
+        // Issuer creates TailsReader
+        let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
+
+        // Issuer creates Credential
+        // NOte that  the function returns revoc_reg_delta_json as None in case
+        // the revocation registry was created with the strategy ISSUANCE_BY_DEFAULT
+        let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(self.issuer_wallet_handle,
+                                                                                                 &cred_offer_json,
+                                                                                                 &cred_req_json,
+                                                                                                 cred_values_json,
+                                                                                                 Some(&self.rev_reg_id),
+                                                                                                 Some(blob_storage_reader_handle)).unwrap();
+
+
+
+        // Issuer does not have to post rev_reg_delta to ledger in case of the strategy ISSUANCE_BY_DEFAULT
+        let revoc_reg_config_value : Value = serde_json::from_str(&self.revoc_registry_config).unwrap();
+        let issuance_type = revoc_reg_config_value.as_object().unwrap().get(""issuance_type"").unwrap().as_str().unwrap();
+
+        // Issuer posts RevocationRegistryDelta to Ledger
+        if issuance_type  == ""ISSUANCE_ON_DEMAND"" {
+            pool.submit_revoc_reg_entry(&self.issuer_did, self.issuer_wallet_handle, &self.rev_reg_id, &revoc_reg_delta_json.clone().unwrap());
+        }
+
+        (cred_json, cred_rev_id.unwrap(), revoc_reg_delta_json)
+    }
+
+    pub fn revoke_credential(&self, pool : &Pool, cred_rev_id: &str) -> String
+    {
+
+        let tails_writer_config = anoncreds::tails_writer_config();
+        // Issuer creates TailsReader
+        let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
+
+        // Issuer revokes cred_info
+        let rev_reg_delta_json = anoncreds::issuer_revoke_credential(self.issuer_wallet_handle, blob_storage_reader_handle, &self.rev_reg_id, &cred_rev_id).unwrap();
+
+        // Issuer post RevocationRegistryDelta to Ledger
+        pool.submit_revoc_reg_entry(&self.issuer_did,self.issuer_wallet_handle,&self.rev_reg_id,&rev_reg_delta_json);
+
+        rev_reg_delta_json
+    }
+
+    pub fn close(&self)
+    {
+        wallet::close_wallet(self.issuer_wallet_handle).unwrap();
+    }
+}
+
+
+impl Prover
+{
+    pub fn new(master_secret_id : Option<&str>) -> Prover
+    {
+        // Prover creates wallet, gets wallet handle
+        let prover_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+        // Prover create DID
+        let (prover_did, prover_verkey) = did::create_my_did(prover_wallet_handle, ""{}"").unwrap();
+        // Prover creates Master Secret
+        let master_secret_id = master_secret_id.unwrap_or(COMMON_MASTER_SECRET);
+        anoncreds::prover_create_master_secret(prover_wallet_handle, master_secret_id).unwrap();
+
+        Prover{ wallet_handle: prover_wallet_handle,
+                did: prover_did.clone(),
+                verkey: prover_verkey.clone(),
+                master_secret_id : String::from(master_secret_id),
+                cred_def_id: None,
+                cred_req_metadata_json : None
+             }
+    }
+
+
+    pub fn make_credential_request(&mut self, pool: &Pool,  cred_offer_json :  &str ) -> String
+    {
+        // Prover gets CredentialDefinition from Ledger
+        let cred_offer: CredentialOffer = serde_json::from_str(&cred_offer_json).unwrap();
+        let (cred_def_id, cred_def_json) = pool.get_cred_def(Some(&self.did), &cred_offer.cred_def_id);
+        self.cred_def_id = Some(cred_def_id);
+
+        // Prover creates Credential Request
+        let (cred_req_json, cred_req_metadata_json) = anoncreds::prover_create_credential_req(self.wallet_handle,
+                                                                                              &self.did,
+                                                                                              &cred_offer_json,
+                                                                                              &cred_def_json,
+                                                                                              &self.master_secret_id).unwrap();
+        self.cred_req_metadata_json = Some(cred_req_metadata_json);
+        cred_req_json
+    }
+
+
+    pub fn store_credentials(&self, pool: &Pool, cred_json: &str, cred_id: &str)
+    {
+        let credential: Credential = serde_json::from_str(&cred_json).unwrap();
+
+        // Prover gets CredentialDefinition from Ledger
+        let (_ , cred_def_json) = pool.get_cred_def(Some(&self.did), &self.cred_def_id.clone().unwrap());
+
+        // Prover gets RevocationRegistryDefinition
+        let (_, revoc_reg_def_json) = pool.get_revoc_reg_def(None,&credential.rev_reg_id.unwrap());
+
+        // Prover stores received Credential
+        anoncreds::prover_store_credential(self.wallet_handle,
+                                           cred_id,
+                                           &self.cred_req_metadata_json.clone().unwrap(),
+                                           &cred_json,
+                                           &cred_def_json,
+                                           Some(&revoc_reg_def_json)).unwrap();
+    }
+
+    pub fn make_proof(&self, pool : &Pool, proof_request: &str, attr1_referent: &str, from: Option<u64>, to: u64 ) -> String
+    {
+
+        use serde_json::Value;
+        // Prover gets Credentials for Proof Request
+        let credentials_json = anoncreds::prover_get_credentials_for_proof_req(self.wallet_handle, &proof_request).unwrap();",,2019-02-15 14:25:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/257183930,https://github.com/hyperledger/indy-sdk/pull/1470#discussion_r257183930,olegbou777
https://github.com/hyperledger/indy-sdk/pull/1470,https://github.com/hyperledger/indy-sdk/pull/1470,Do you insist for this change in current PR?,930f0b793b9ba0d9a4f79f0bc92045149ca87bb7,2019-02-15 10:42:19,257185465,"@@ -45,481 +45,533 @@ use utils::domain::anoncreds::revocation_registry::RevocationRegistry;
 
 use std::thread;
 
-#[cfg(feature = ""revocation_tests"")]
-#[test]
-fn anoncreds_revocation_interaction_test_issuance_by_demand() {
-    utils::setup();
 
-    // Open Pool
-    let pool_handle = pool::create_and_open_pool_ledger(POOL).unwrap();
+struct Pool{
+    pool_handle : i32
+}
 
-    // Issuer creates wallet, gets wallet handle
-    let issuer_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
 
-    // Issuer create DID
-    let (issuer_did, _) = did::create_store_and_publish_my_did_from_trustee(issuer_wallet_handle, pool_handle).unwrap();
+struct Issuer{
+    issuer_wallet_handle: i32,
+    issuer_did : String,
 
-    // Prover creates wallet, gets wallet handle
-    let prover_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+    schema_id : String,
+    cred_def_id : String,
+    rev_reg_id : String,
 
-    // Prover create DID
-    let (prover_did, prover_verkey) = did::create_my_did(prover_wallet_handle, ""{}"").unwrap();
+    revoc_registry_config: String
+}
 
-    // Issuer publish Prover DID
-    let nym_request = ledger::build_nym_request(&issuer_did, &prover_did, Some(&prover_verkey), None, None).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
 
-    // ISSUER post to Ledger Schema, CredentialDefinition, RevocationRegistry
+struct Prover{
 
-    // Issuer creates Schema
-    let (schema_id, schema_json) = anoncreds::issuer_create_schema(&issuer_did,
-                                                                        GVT_SCHEMA_NAME,
-                                                                        SCHEMA_VERSION,
-                                                                        GVT_SCHEMA_ATTRIBUTES).unwrap();
-
-    // !!IMPORTANT!!
-    // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
-    // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
-
-    // Issuer posts Schema to Ledger
-    let schema_request = ledger::build_schema_request(&issuer_did, &schema_json).unwrap();
-    let schema_response = ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &schema_request).unwrap();
-
-    // Issuer gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&issuer_did), &schema_id).unwrap();
-    let get_schema_response = ledger::submit_request_with_retries(pool_handle, &get_schema_request, &schema_response).unwrap();
-    let (_, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Issuer creates CredentialDefinition
-    let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(issuer_wallet_handle,
-                                                                                           &issuer_did,
-                                                                                           &schema_json,
-                                                                                           TAG_1,
-                                                                                           None,
-                                                                                           Some(&anoncreds::revocation_cred_def_config())).unwrap();
-
-    // Issuer post CredentialDefinition to Ledger
-    let cred_def_request = ledger::build_cred_def_txn(&issuer_did, &cred_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &cred_def_request).unwrap();
-
-    // Issuer creates RevocationRegistry
-    let tails_writer_config = anoncreds::tails_writer_config();
-    let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
-
-    let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
-        anoncreds::issuer_create_and_store_revoc_reg(issuer_wallet_handle,
-                                                               &issuer_did,
-                                                               None,
-                                                               TAG_1,
-                                                               &cred_def_id,
-                                                               r#""{""max_cred_num"":5, ""issuance_type"":""ISSUANCE_ON_DEMAND""}""#,
-                                                               tails_writer_handle).unwrap();
-
-    // Issuer posts RevocationRegistryDefinition to Ledger
-    let rev_reg_def_request = ledger::build_revoc_reg_def_request(&issuer_did, &rev_reg_def_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_def_request).unwrap();
-
-    // Issuer posts RevocationRegistryEntry to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &rev_reg_entry_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
+    wallet_handle : i32,
+    did: String,
+    verkey : String,
+    master_secret_id : String,
+    cred_def_id : Option<String>,
+    cred_req_metadata_json : Option<String>
 
+}
 
-    // Issuance Credential for Prover
 
-    // Prover creates Master Secret
-    anoncreds::prover_create_master_secret(prover_wallet_handle, COMMON_MASTER_SECRET).unwrap();
+struct Verifier{
+    proof_request : String
+}
 
-    // Issuer creates Credential Offer
-    let cred_offer_json = anoncreds::issuer_create_credential_offer(issuer_wallet_handle, &cred_def_id).unwrap();
-    let cred_offer: CredentialOffer = serde_json::from_str(&cred_offer_json).unwrap();
-
-    // Prover gets CredentialDefinition from Ledger
-    let get_cred_def_request = ledger::build_get_cred_def_request(Some(&prover_did), &cred_offer.cred_def_id).unwrap();
-    let get_cred_def_response = ledger::submit_request(pool_handle, &get_cred_def_request).unwrap();
-    let (cred_def_id, cred_def_json) = ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap();
-
-    // Prover creates Credential Request
-    let (cred_req_json, cred_req_metadata_json) = anoncreds::prover_create_credential_req(prover_wallet_handle,
-                                                                                               &prover_did,
-                                                                                               &cred_offer_json,
-                                                                                               &cred_def_json,
-                                                                                               COMMON_MASTER_SECRET).unwrap();
-
-    // Issuer creates TailsReader
-    let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
-
-    // Issuer creates Credential
-    let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(issuer_wallet_handle,
-                                                                                                  &cred_offer_json,
-                                                                                                  &cred_req_json,
-                                                                                                  &anoncreds::gvt_credential_values_json(),
-                                                                                                  Some(&rev_reg_id),
-                                                                                                  Some(blob_storage_reader_handle)).unwrap();
-    let revoc_reg_delta_json = revoc_reg_delta_json.unwrap();
-    let cred_rev_id = cred_rev_id.unwrap();
-
-    // Issuer posts RevocationRegistryDelta to Ledger
-    let rev_reg_entry_request =
-        ledger::build_revoc_reg_entry_request(&issuer_did, &rev_reg_id, REVOC_REG_TYPE, &revoc_reg_delta_json).unwrap();
-    ledger::sign_and_submit_request(pool_handle, issuer_wallet_handle, &issuer_did, &rev_reg_entry_request).unwrap();
-
-    // Prover gets RevocationRegistryDefinition
-    let credential: Credential = serde_json::from_str(&cred_json).unwrap();
-    let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(Some(&prover_did), &credential.rev_reg_id.unwrap()).unwrap();
-    let get_rev_reg_def_response = ledger::submit_request(pool_handle, &get_rev_reg_def_request).unwrap();
-    let (_, revoc_reg_def_json) = ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap();
-
-    // Prover store received Credential
-    anoncreds::prover_store_credential(prover_wallet_handle,
-                                            CREDENTIAL1_ID,
-                                            &cred_req_metadata_json,
-                                            &cred_json,
-                                            &cred_def_json,
-                                            Some(&revoc_reg_def_json)).unwrap();
-
-    let credentials = anoncreds::prover_get_credentials(prover_wallet_handle, &json!({""schema_name"": GVT_SCHEMA_NAME}).to_string()).unwrap();
-    let credentials: Vec<serde_json::Value> = serde_json::from_str(&credentials).unwrap();
-    assert_eq!(credentials.len(), 1);
 
-    // Verifying Prover Credential
-    thread::sleep(std::time::Duration::from_secs(3));
+impl Pool {
 
-    let to = time::get_time().sec as u64;
 
-    let proof_request = json!({
-           ""nonce"":""123432421212"",
-           ""name"":""proof_req_1"",
-           ""version"":""0.1"",
-           ""requested_attributes"": json!({
-               ""attr1_referent"": json!({
-                   ""name"":""name""
-               })
-           }),
-           ""requested_predicates"": json!({
-               ""predicate1_referent"": json!({ ""name"":""age"", ""p_type"":"">="", ""p_value"":18 })
-           }),
-           ""non_revoked"": json!({ ""to"": to.clone() })
-        }).to_string();
+    pub fn new() -> Pool {
+        Pool{ pool_handle : pool::create_and_open_pool_ledger(POOL).unwrap() }
+    }
 
-    // Prover gets Credentials for Proof Request
-    let credentials_json = anoncreds::prover_get_credentials_for_proof_req(prover_wallet_handle, &proof_request).unwrap();
-    let cred_info = anoncreds::get_credential_for_attr_referent(&credentials_json, ""attr1_referent"");
-
-    // Prover gets RevocationRegistryDelta from Ledger
-    let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(Some(&prover_did), &cred_info.rev_reg_id.clone().unwrap(), None, to).unwrap();
-    let get_rev_reg_delta_response = ledger::submit_request(pool_handle, &get_rev_reg_delta_request).unwrap();
-    let (rev_reg_id, revoc_reg_delta_json, timestamp) = ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap();
-
-    // Prover creates RevocationState
-    let rev_state_json = anoncreds::create_revocation_state(blob_storage_reader_handle,
-                                                                 &revoc_reg_def_json,
-                                                                 &revoc_reg_delta_json,
-                                                                 timestamp,
-                                                                 &cred_info.cred_rev_id.clone().unwrap()).unwrap();
-
-    // Prover gets Schema from Ledger
-    let get_schema_request = ledger::build_get_schema_request(Some(&prover_did), &cred_info.schema_id).unwrap();
-    let get_schema_response = ledger::submit_request(pool_handle, &get_schema_request).unwrap();
-    let (schema_id, schema_json) = ledger::parse_get_schema_response(&get_schema_response).unwrap();
-
-    // Prover creates Proof
-    let requested_credentials_json = json!({
-             ""self_attested_attributes"": json!({}),
-             ""requested_attributes"": json!({
-                ""attr1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp,  ""revealed"":true })
-             }),
-             ""requested_predicates"": json!({
-                ""predicate1_referent"": json!({ ""cred_id"": cred_info.referent, ""timestamp"": timestamp })
-             })
-        }).to_string();
+    pub fn close(self) {
+        let _ = pool::close(self.pool_handle);
+    }
+
+
+    pub fn submit_nym(&self, issuer_did: &str, issuer_wallet_handle: i32, prover_did: &str, prover_verkey : Option<&str>)
+    {
+        let nym_request = ledger::build_nym_request(issuer_did, prover_did, prover_verkey, None, None).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, &issuer_did, &nym_request).unwrap();
+    }
+
+    pub fn submit_schema(&self, issuer_did: &str, issuer_wallet_handle: i32, schema_json: &str) -> String {
+        let schema_request = ledger::build_schema_request(issuer_did, schema_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &schema_request).unwrap()
+    }
+
+    pub fn get_schema(&self, did: Option<&str>, schema_id: &str) -> (String, String){
+        let get_schema_request = ledger::build_get_schema_request(did, schema_id).unwrap();
+        let get_schema_response = ledger::submit_request(self.pool_handle, &get_schema_request).unwrap();
+        ledger::parse_get_schema_response(&get_schema_response).unwrap()
+
+    }
+
+    pub fn submit_cred_def(&self, issuer_did: &str, issuer_wallet_handle: i32, cred_def_json: &str) -> String {
+        let cred_def_request = ledger::build_cred_def_txn(issuer_did, cred_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &cred_def_request).unwrap()
+
+    }
+
+    pub fn get_cred_def(&self, did : Option<&str>, cred_def_id : &str ) -> (String, String) /* (cred_def_id, cred_def_json) */{
+        let get_cred_def_request = ledger::build_get_cred_def_request(did, cred_def_id).unwrap();
+        let get_cred_def_response = ledger::submit_request(self.pool_handle, &get_cred_def_request).unwrap();
+        ledger::parse_get_cred_def_response(&get_cred_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_def(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_def_json : &str) -> String {
+        let rev_reg_def_request = ledger::build_revoc_reg_def_request(issuer_did, rev_reg_def_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_def_request).unwrap()
+    }
+
+    pub fn get_revoc_reg_def(&self, did: Option<&str>, revoc_reg_def_id : &str) -> (String, String) /* revoc_reg_def_id, revo_reg_def_json */ {
+        let get_rev_reg_def_request = ledger::build_get_revoc_reg_def_request(did, &revoc_reg_def_id).unwrap();
+        let get_rev_reg_def_response = ledger::submit_request(self.pool_handle, &get_rev_reg_def_request).unwrap();
+        ledger::parse_get_revoc_reg_def_response(&get_rev_reg_def_response).unwrap()
+    }
+
+    pub fn submit_revoc_reg_entry(&self, issuer_did: &str, issuer_wallet_handle: i32, rev_reg_id : &str, rev_reg_entry_json: &str) -> String{
+        let rev_reg_entry_request =
+            ledger::build_revoc_reg_entry_request(issuer_did, rev_reg_id, REVOC_REG_TYPE, rev_reg_entry_json).unwrap();
+        ledger::sign_and_submit_request(self.pool_handle, issuer_wallet_handle, issuer_did, &rev_reg_entry_request).unwrap()
+
+    }
+
+    pub fn get_revoc_reg_delta(&self, did: Option<&str>, revoc_reg_def_id : &str, from : Option<u64>, to : u64) -> (String,String, u64) /* rev_reg_id, revoc_reg_delta_json, timestamp */ {
+        let get_rev_reg_delta_request = ledger::build_get_revoc_reg_delta_request(did, revoc_reg_def_id, from, to).unwrap();
+        let get_rev_reg_delta_response = ledger::submit_request(self.pool_handle, &get_rev_reg_delta_request).unwrap();
+        ledger::parse_get_revoc_reg_delta_response(&get_rev_reg_delta_response).unwrap()
+    }
+
+
+}
+
+
+impl Issuer {
+
+
+    pub fn new(pool: &Pool) -> Issuer{
+
+        let wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+        Issuer {
+            // Issuer creates wallet, gets wallet handle
+            issuer_wallet_handle: wallet_handle,
+
+            // Issuer create DID
+            issuer_did: did::create_store_and_publish_my_did_from_trustee(wallet_handle, pool.pool_handle).unwrap().0,
+
+            schema_id: String::new(),
+            rev_reg_id : String::new(),
+            cred_def_id : String::new(),
+
+            revoc_registry_config : String::new()
+
+        }
+    }
+
+    // creates schema , credential definition and revocation registry
+    pub fn create_initial_ledger_state(& mut self, pool : &Pool, revoc_registry_config : &str)
+    {
+
+        self.revoc_registry_config = String::from(revoc_registry_config);
+
+        // Issuer creates Schema
+        let (schema_id, schema_json) = anoncreds::issuer_create_schema(&self.issuer_did,
+                                                                       GVT_SCHEMA_NAME,
+                                                                       SCHEMA_VERSION,
+                                                                       GVT_SCHEMA_ATTRIBUTES).unwrap();
+
+        // !!IMPORTANT!!
+        // It is important Post and Get Schema from Ledger and parse it to get the correct Schema JSON and correspondent it seq_no in Ledger
+        // After that we can create CredentialDefinition for received Schema(not for result of indy_issuer_create_schema)
+        let _schema_response = pool.submit_schema(&self.issuer_did, self.issuer_wallet_handle,&schema_json);
+        // Issuer gets Schema from Ledger
+        let (_ , schema_json) = pool.get_schema(Some(&self.issuer_did),&schema_id);
+
+        self.schema_id = schema_id;
+
+        // Issuer creates CredentialDefinition
+        let (cred_def_id, cred_def_json) = anoncreds::issuer_create_credential_definition(self.issuer_wallet_handle,
+                                                                                          &self.issuer_did,
+                                                                                          &schema_json,
+                                                                                          TAG_1,
+                                                                                          None,
+                                                                                          Some(&anoncreds::revocation_cred_def_config())).unwrap();
+
+        // Issuer post CredentialDefinition to Ledger
+        pool.submit_cred_def(&self.issuer_did,self.issuer_wallet_handle,&cred_def_json);
+
+        self.cred_def_id = cred_def_id;
+
+        // Issuer creates RevocationRegistry
+        let tails_writer_config = anoncreds::tails_writer_config();
+        let tails_writer_handle = blob_storage::open_writer(""default"", &tails_writer_config).unwrap();
 
-    let schemas_json = json!({
+        let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) =
+            anoncreds::issuer_create_and_store_revoc_reg(self.issuer_wallet_handle,
+                                                         &self.issuer_did,
+                                                         None,
+                                                         TAG_1,
+                                                         &self.cred_def_id,
+                                                         &self.revoc_registry_config,
+                                                         tails_writer_handle).unwrap();
+
+        // Issuer posts RevocationRegistryDefinition to Ledger
+        pool.submit_revoc_reg_def(&self.issuer_did, self.issuer_wallet_handle, &rev_reg_def_json);
+
+
+        self.rev_reg_id = rev_reg_id;
+
+        // Issuer posts RevocationRegistryEntry to Ledger
+        pool.submit_revoc_reg_entry(&self.issuer_did,self.issuer_wallet_handle, &self.rev_reg_id, &rev_reg_entry_json);
+    }
+
+    pub fn make_credential_offer(&self) -> String
+    {
+        let cred_offer_json = anoncreds::issuer_create_credential_offer(self.issuer_wallet_handle, &self.cred_def_id).unwrap();
+        cred_offer_json
+    }
+
+    pub fn issue_credential(&self, pool: &Pool, cred_offer_json: &str, cred_req_json: &str, cred_values_json: &str) -> (String, String, Option<String>)
+    {
+
+        use serde_json::Value;
+
+        let tails_writer_config = anoncreds::tails_writer_config();
+        // Issuer creates TailsReader
+        let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
+
+        // Issuer creates Credential
+        // NOte that  the function returns revoc_reg_delta_json as None in case
+        // the revocation registry was created with the strategy ISSUANCE_BY_DEFAULT
+        let (cred_json, cred_rev_id, revoc_reg_delta_json) = anoncreds::issuer_create_credential(self.issuer_wallet_handle,
+                                                                                                 &cred_offer_json,
+                                                                                                 &cred_req_json,
+                                                                                                 cred_values_json,
+                                                                                                 Some(&self.rev_reg_id),
+                                                                                                 Some(blob_storage_reader_handle)).unwrap();
+
+
+
+        // Issuer does not have to post rev_reg_delta to ledger in case of the strategy ISSUANCE_BY_DEFAULT
+        let revoc_reg_config_value : Value = serde_json::from_str(&self.revoc_registry_config).unwrap();
+        let issuance_type = revoc_reg_config_value.as_object().unwrap().get(""issuance_type"").unwrap().as_str().unwrap();
+
+        // Issuer posts RevocationRegistryDelta to Ledger
+        if issuance_type  == ""ISSUANCE_ON_DEMAND"" {
+            pool.submit_revoc_reg_entry(&self.issuer_did, self.issuer_wallet_handle, &self.rev_reg_id, &revoc_reg_delta_json.clone().unwrap());
+        }
+
+        (cred_json, cred_rev_id.unwrap(), revoc_reg_delta_json)
+    }
+
+    pub fn revoke_credential(&self, pool : &Pool, cred_rev_id: &str) -> String
+    {
+
+        let tails_writer_config = anoncreds::tails_writer_config();
+        // Issuer creates TailsReader
+        let blob_storage_reader_handle = blob_storage::open_reader(TYPE, &tails_writer_config).unwrap();
+
+        // Issuer revokes cred_info
+        let rev_reg_delta_json = anoncreds::issuer_revoke_credential(self.issuer_wallet_handle, blob_storage_reader_handle, &self.rev_reg_id, &cred_rev_id).unwrap();
+
+        // Issuer post RevocationRegistryDelta to Ledger
+        pool.submit_revoc_reg_entry(&self.issuer_did,self.issuer_wallet_handle,&self.rev_reg_id,&rev_reg_delta_json);
+
+        rev_reg_delta_json
+    }
+
+    pub fn close(&self)
+    {
+        wallet::close_wallet(self.issuer_wallet_handle).unwrap();
+    }
+}
+
+
+impl Prover
+{
+    pub fn new(master_secret_id : Option<&str>) -> Prover
+    {
+        // Prover creates wallet, gets wallet handle
+        let prover_wallet_handle = wallet::create_and_open_default_wallet().unwrap();
+        // Prover create DID
+        let (prover_did, prover_verkey) = did::create_my_did(prover_wallet_handle, ""{}"").unwrap();
+        // Prover creates Master Secret
+        let master_secret_id = master_secret_id.unwrap_or(COMMON_MASTER_SECRET);
+        anoncreds::prover_create_master_secret(prover_wallet_handle, master_secret_id).unwrap();
+
+        Prover{ wallet_handle: prover_wallet_handle,
+                did: prover_did.clone(),
+                verkey: prover_verkey.clone(),
+                master_secret_id : String::from(master_secret_id),
+                cred_def_id: None,
+                cred_req_metadata_json : None
+             }
+    }
+
+
+    pub fn make_credential_request(&mut self, pool: &Pool,  cred_offer_json :  &str ) -> String
+    {
+        // Prover gets CredentialDefinition from Ledger
+        let cred_offer: CredentialOffer = serde_json::from_str(&cred_offer_json).unwrap();
+        let (cred_def_id, cred_def_json) = pool.get_cred_def(Some(&self.did), &cred_offer.cred_def_id);
+        self.cred_def_id = Some(cred_def_id);
+
+        // Prover creates Credential Request
+        let (cred_req_json, cred_req_metadata_json) = anoncreds::prover_create_credential_req(self.wallet_handle,
+                                                                                              &self.did,
+                                                                                              &cred_offer_json,
+                                                                                              &cred_def_json,
+                                                                                              &self.master_secret_id).unwrap();
+        self.cred_req_metadata_json = Some(cred_req_metadata_json);
+        cred_req_json
+    }
+
+
+    pub fn store_credentials(&self, pool: &Pool, cred_json: &str, cred_id: &str)
+    {
+        let credential: Credential = serde_json::from_str(&cred_json).unwrap();
+
+        // Prover gets CredentialDefinition from Ledger
+        let (_ , cred_def_json) = pool.get_cred_def(Some(&self.did), &self.cred_def_id.clone().unwrap());",471,2019-02-15 14:25:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/257185465,https://github.com/hyperledger/indy-sdk/pull/1470#discussion_r257185465,olegbou777
https://github.com/hyperledger/indy-sdk/pull/1466,https://github.com/hyperledger/indy-sdk/pull/1466,I believe the year must be 2019.,7dc291a2433d9c92050890c56f3694d6f8624cf1,2019-02-08 08:07:11,254982201,"@@ -1,13 +1,13 @@
 # Changelog
 
-## 1.8.0 - 2018-1-31
+## 1.8.0 - 2018-01-31",,2019-02-12 08:52:39,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/254982201,https://github.com/hyperledger/indy-sdk/pull/1466#discussion_r254982201,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1466,https://github.com/hyperledger/indy-sdk/pull/1466,Resolved,7dc291a2433d9c92050890c56f3694d6f8624cf1,2019-02-08 10:17:01,255017844,"@@ -1,13 +1,13 @@
 # Changelog
 
-## 1.8.0 - 2018-1-31
+## 1.8.0 - 2018-01-31",,2019-02-12 08:52:39,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/255017844,https://github.com/hyperledger/indy-sdk/pull/1466#discussion_r255017844,jovfer
https://github.com/hyperledger/indy-sdk/pull/1464,https://github.com/hyperledger/indy-sdk/pull/1464,Is pub required here,1660d905d81ad14899128f3cf66ff31f30a99c19,2019-02-15 11:58:57,257207590,"@@ -1,62 +1,104 @@
-extern crate serde;
-extern crate rmp_serde;
-extern crate libc;
-
-use self::rmp_serde::encode;
-use self::rmp_serde::Deserializer;
-use serde::Deserialize;
-use serde_json;
 use settings;
 use utils::constants::*;
-use utils::error;
-use utils::libindy::wallet;
+use messages::{A2AMessage, A2AMessageV1, A2AMessageV2, A2AMessageKinds, prepare_message_for_agency, parse_response_from_agency};
+use messages::message_type::MessageTypes;
+use utils::{error, httpclient};
+use utils::libindy::{wallet, anoncreds};
 use utils::libindy::signus::create_and_store_my_did;
-use utils::httpclient;
-use messages::{Bundled, MsgType, bundle_for_agency, unbundle_from_agency};
 
-
-#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, PartialOrd)]
-struct ConnectMsg {
+#[derive(Serialize, Deserialize, Debug)]
+pub struct Connect {
     #[serde(rename = ""@type"")]
-    msg_type: MsgType,
+    pub msg_type: MessageTypes,",,2019-02-28 15:01:49,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/257207590,https://github.com/hyperledger/indy-sdk/pull/1464#discussion_r257207590,jovfer
https://github.com/hyperledger/indy-sdk/pull/1464,https://github.com/hyperledger/indy-sdk/pull/1464,Probably it's better to use `_real_proof_demo` name here,1660d905d81ad14899128f3cf66ff31f30a99c19,2019-02-15 11:59:28,257207724,"@@ -243,30 +246,27 @@ mod tests {
         let (_, delta, timestamp) = ::utils::libindy::anoncreds::get_rev_reg_delta_json(&rev_reg_id.clone().unwrap(), None, None).unwrap();
         println!(""revoking credential"");
         ::issuer_credential::revoke_credential(issuer_handle).unwrap();
-        let (_, delta_after_revoke, _) = ::utils::libindy::anoncreds::get_rev_reg_delta_json(&rev_reg_id.unwrap(), Some(timestamp+1), None).unwrap();
+        let (_, delta_after_revoke, _) = ::utils::libindy::anoncreds::get_rev_reg_delta_json(&rev_reg_id.unwrap(), Some(timestamp + 1), None).unwrap();
         assert_ne!(delta, delta_after_revoke);
     }
 
-    #[cfg(feature = ""agency"")]
-    #[cfg(feature = ""pool_tests"")]
-    #[test]
-    fn test_real_proof() {
+    fn real_proof_demo() {",,2019-02-28 15:01:49,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/257207724,https://github.com/hyperledger/indy-sdk/pull/1464#discussion_r257207724,jovfer
https://github.com/hyperledger/indy-sdk/pull/1464,https://github.com/hyperledger/indy-sdk/pull/1464,Fix spaces please,1660d905d81ad14899128f3cf66ff31f30a99c19,2019-02-15 12:01:52,257208331,"@@ -294,11 +386,11 @@ mod tests {
         let host = ""http://www.whocares.org"";
         let wallet_key = ""test_key"";
         let config = json!({
-            ""agency_url"": host.to_string(),
-            ""agency_did"": agency_did.to_string(),
-            ""agency_verkey"": agency_vk.to_string(),
-            ""wallet_key"": wallet_key.to_string(),
-        });
+""agency_url"": host.to_string(),",,2019-02-28 15:01:49,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/257208331,https://github.com/hyperledger/indy-sdk/pull/1464#discussion_r257208331,jovfer
https://github.com/hyperledger/indy-sdk/pull/1464,https://github.com/hyperledger/indy-sdk/pull/1464,Fix spaces please,1660d905d81ad14899128f3cf66ff31f30a99c19,2019-02-15 12:07:47,257209860,"@@ -13,7 +13,7 @@ def testing() {
                 'android-test': { androidTesting() },
                 'macos-test'  : { macosTesting() },
                 'ios-test'    : { iosTesting() },
-                'redhat-test' : { rhelTesting() },
+'redhat-test' : { rhelTesting() },",,2019-02-28 15:01:49,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/257209860,https://github.com/hyperledger/indy-sdk/pull/1464#discussion_r257209860,jovfer
https://github.com/hyperledger/indy-sdk/pull/1464,https://github.com/hyperledger/indy-sdk/pull/1464,Double-check type change,1660d905d81ad14899128f3cf66ff31f30a99c19,2019-02-15 12:13:29,257211609,"@@ -204,144 +275,48 @@ pub struct Message {
 }
 
 impl Message {
-    pub fn new() -> Message {
-        Message {
-            status_code: String::new(),
-            payload: None,
-            sender_did: String::new(),
-            uid: String::new(),
-            msg_type: String::new(),
-            ref_msg_id: None,
-            delivery_details: Vec::new(),
-            decrypted_payload: None,
-        }    
-    }
-
     pub fn decrypt(&self, vk: &str) -> Message {
+        // TODO: must be Result
         let mut new_message = self.clone();
         if let Some(ref payload) = self.payload {
             let payload = ::messages::to_u8(payload);
-            match ::utils::libindy::crypto::parse_msg(&vk, &payload) {
-                Ok(x) => {
-                    new_message.decrypted_payload = to_json(&x.1)
-                        .map(|i| i.to_string())
-                        .ok();
-                }
-                Err(_) => (),
-            };
+            let payload = ::utils::libindy::crypto::parse_msg(&vk, &payload).unwrap_or((String::new(), Vec::new()));
+            new_message.decrypted_payload = rmp_serde::from_slice(&payload.1[..]).ok();
         }
         new_message.payload = None;
         new_message
     }
 }
 
-#[derive(Serialize, Deserialize, Debug, PartialEq, PartialOrd, Clone)]
-#[serde(rename_all = ""camelCase"")]
-pub struct GetMessagesResponse {
-    #[serde(rename = ""@type"")]
-    msg_type: MsgType,
-    msgs: Vec<Message>,
-}
-
-fn parse_get_messages_response(response: Vec<u8>) -> Result<Vec<Message>, u32> {
-    trace!(""parse_get_messages_response >>>"");
-    let data = unbundle_from_agency(response)?;
-
-    trace!(""get_message response: {:?}"", data[0]);
-    let mut de = Deserializer::new(&data[0][..]);
-    let response: GetMessagesResponse = match Deserialize::deserialize(&mut de) {
-        Ok(x) => x,
-        Err(x) => {
-            error!(""Could not parse messagepack: {}"", x);
-
-            return Err(error::INVALID_MSGPACK.code_num)
-        },
-    };
-
-    Ok(response.msgs.to_owned())
-}
-
-#[derive(Serialize, Deserialize, Debug, PartialEq, PartialOrd, Clone)]
-#[serde(rename_all = ""camelCase"")]
-pub struct GetConnectionMessagesResponse {
-    #[serde(rename = ""@type"")]
-    msg_type: MsgType,
-    msgs_by_conns: Vec<ConnectionMessages>,
-}
-
-#[derive(Serialize, Deserialize, Debug, PartialEq, PartialOrd, Clone)]
-pub struct ConnectionMessages {
-    #[serde(rename = ""pairwiseDID"")]
-    pub pairwise_did: String,
-    pub msgs: Vec<Message>,
-}
-
-fn parse_get_connection_messages_response(response: Vec<u8>) -> Result<Vec<ConnectionMessages>, u32> {
-    trace!(""parse_get_connection_messages_response >>>"");
-
-    let data = unbundle_from_agency(response)?;
-
-    trace!(""parse_get_connection_message response: {:?}"", data[0]);
-    let mut de = Deserializer::new(&data[0][..]);
-    let response: GetConnectionMessagesResponse = match Deserialize::deserialize(&mut de) {
-        Ok(x) => x,
-        Err(x) => {
-            error!(""Could not parse messagepack: {}"", x);
-
-            return Err(error::INVALID_MSGPACK.code_num)
-        },
-    };
-
-    let mut connection_messages = Vec::new();
-    for connection in response.msgs_by_conns.iter() {
-        let vk = ::utils::libindy::signus::get_local_verkey(&connection.pairwise_did)?;
-        let mut new_messages = Vec::new();
-        for message in connection.msgs.iter() {
-            new_messages.push(message.decrypt(&vk));
-        }
-        connection_messages.push(ConnectionMessages {
-            pairwise_did: connection.pairwise_did.clone(),
-            msgs: new_messages,
-        })
-    }
-    Ok(connection_messages)
-}
-
 pub fn get_connection_messages(pw_did: &str, pw_vk: &str, agent_did: &str, agent_vk: &str, msg_uid: Option<Vec<String>>) -> Result<Vec<Message>, u32> {
     trace!(""get_connection_messages >>> pw_did: {}, pw_vk: {}, agent_vk: {}, msg_uid: {:?}"",
            pw_did, pw_vk, agent_vk, msg_uid);
 
-    match get_messages()
-        .to(&pw_did)
-        .to_vk(&pw_vk)
-        .agent_did(&agent_did)
-        .agent_vk(&agent_vk)
-        .uid(msg_uid)
-        .send_secure() {
-        Err(x) => {
-            error!(""could not post get_messages: {}"", x);
-            Err(error::POST_MSG_FAILURE.code_num)
-        },
-        Ok(response) => {
-            if response.len() == 0 {
-                Err(error::POST_MSG_FAILURE.code_num)
-            } else {
-                trace!(""message returned: {:?}"", response[0]);
-                Ok(response)
-            }
-        },
-    }
+    let response = get_messages()
+        .to(&pw_did)?
+        .to_vk(&pw_vk)?
+        .agent_did(&agent_did)?
+        .agent_vk(&agent_vk)?
+        .uid(msg_uid)?
+        .send_secure()
+        .map_err(|err| {
+            error!(""could not post get_messages: {}"", err);
+            error::POST_MSG_FAILURE.code_num
+        })?;
+
+    trace!(""message returned: {:?}"", response);
+    Ok(response)
 }
 
-pub fn get_ref_msg(msg_id: &str, pw_did: &str, pw_vk: &str, agent_did: &str, agent_vk: &str) -> Result<(String, Vec<u8>), u32> {
+pub fn get_ref_msg(msg_id: &str, pw_did: &str, pw_vk: &str, agent_did: &str, agent_vk: &str) -> Result<(String, Vec<i8>), u32> {",531,2019-02-28 15:01:49,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/257211609,https://github.com/hyperledger/indy-sdk/pull/1464#discussion_r257211609,jovfer
https://github.com/hyperledger/indy-sdk/pull/1464,https://github.com/hyperledger/indy-sdk/pull/1464,Double-check `pub` here,1660d905d81ad14899128f3cf66ff31f30a99c19,2019-02-15 12:14:42,257211884,"@@ -1,154 +1,163 @@
-extern crate rust_base58;
-extern crate serde_json;
-extern crate serde;
-extern crate rmp_serde;
-extern crate base64;
-
 use settings;
-use utils::httpclient;
-use utils::error;
 use messages::*;
-use messages::send_message::CreateMessagePayload;
+use messages::message_type::{MessageTypes, MessageTypeV1, MessageTypeV2};
+use utils::{httpclient, error};
 use utils::constants::*;
-use serde::Deserialize;
-use self::rmp_serde::Deserializer;
-use self::rmp_serde::encode;
-use std::str;
-
-
-#[derive(Clone, Deserialize, Serialize, Debug, PartialEq, PartialOrd)]
-#[serde(rename_all = ""camelCase"")]
-pub struct KeyDlgProofPayload {
-    #[serde(rename = ""agentDID"")]
-    pub agent_did: String,
-    #[serde(rename = ""agentDelegatedKey"")]
-    pub agent_delegated_key: String,
-    #[serde(rename = ""signature"")]
-    pub signature: String,
-}
 
-#[derive(Clone, Serialize, Debug, PartialEq, PartialOrd)]
-#[serde(rename_all = ""camelCase"")]
-struct SendMsgDetailPayload {
+#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
+pub struct SendInviteMessageDetails {
     #[serde(rename = ""@type"")]
-    msg_type: MsgType,
+    msg_type: MessageTypeV1,
     #[serde(rename = ""keyDlgProof"")]
-    key_proof: KeyDlgProofPayload,
+    key_dlg_proof: KeyDlgProof,
+    #[serde(rename = ""targetName"")]
+    target_name: Option<String>,
     #[serde(rename = ""phoneNo"")]
-    #[serde(skip_serializing_if = ""Option::is_none"")]
-    phone: Option<String>,
-    #[serde(rename = ""includePublicDID"")]
+    phone_no: Option<String>,
+    #[serde(rename = ""usePublicDID"")]
     include_public_did: bool,
 }
 
-#[derive(Clone, Serialize, Debug, PartialEq, PartialOrd)]
-#[serde(rename_all = ""camelCase"")]
-struct AcceptMsgDetailPayload {
+#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
+pub struct ConnectionRequest {
     #[serde(rename = ""@type"")]
-    msg_type: MsgType,
+    msg_type: MessageTypeV2,
+    #[serde(rename = ""sendMsg"")]
+    send_msg: bool,
+    #[serde(skip_serializing_if = ""Option::is_none"")]
+    uid: Option<String>,
+    #[serde(rename = ""replyToMsgId"")]
+    reply_to_msg_id: Option<String>,
     #[serde(rename = ""keyDlgProof"")]
-    key_proof: KeyDlgProofPayload,
-    sender_detail: Option<SenderDetail>,
-    sender_agency_detail: Option<SenderAgencyDetail>,
-    answer_status_code: Option<String>
+    key_dlg_proof: KeyDlgProof,
+    #[serde(rename = ""targetName"")]
+    target_name: Option<String>,
+    #[serde(rename = ""phoneNo"")]
+    phone_no: Option<String>,
+    #[serde(rename = ""usePublicDID"")]
+    include_public_did: bool,
 }
 
-#[derive(Clone, Serialize, Debug, PartialEq, PartialOrd)]
-#[serde(rename_all = ""camelCase"")]
-struct SendInvitePayload{
-    create_payload: CreateMessagePayload,
-    msg_detail_payload: SendMsgDetailPayload,
+#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
+pub struct ConnectionRequestResponse {
+    #[serde(rename = ""@type"")]
+    msg_type: MessageTypeV2,
+    uid: String,
+    #[serde(rename = ""inviteDetail"")]
+    invite_detail: InviteDetail,
+    #[serde(rename = ""urlToInviteDetail"")]
+    url_to_invite_detail: String,
+    sent: bool,
 }
 
-#[derive(Clone, Serialize, Debug, PartialEq, PartialOrd)]
-#[serde(rename_all = ""camelCase"")]
-struct AcceptInvitePayload{
-    create_payload: CreateMessagePayload,
-    msg_detail_payload: AcceptMsgDetailPayload,
+#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
+pub struct AcceptInviteMessageDetails {
+    #[serde(rename = ""@type"")]
+    msg_type: MessageTypeV1,
+    #[serde(rename = ""keyDlgProof"")]
+    key_dlg_proof: KeyDlgProof,
+    #[serde(rename = ""senderDetail"")]
+    sender_detail: Option<SenderDetail>,
+    #[serde(rename = ""senderAgencyDetail"")]
+    sender_agency_detail: Option<SenderAgencyDetail>,
+    #[serde(rename = ""answerStatusCode"")]
+    answer_status_code: Option<MessageStatusCode>,
 }
 
-#[derive(Clone, Serialize, Debug, PartialEq, PartialOrd)]
-#[serde(rename_all = ""camelCase"")]
-pub struct SendInvite {
-    #[serde(rename = ""to"")]
-    to_did: String,
-    to_vk: String,
-    #[serde(skip_serializing, default)]
-    payload: SendInvitePayload,
-    #[serde(skip_serializing, default)]
-    validate_rc: u32,
-    agent_did: String,
-    agent_vk: String,
-    #[serde(rename = ""publicDID"")]
+#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
+pub struct ConnectionRequestAnswer {
+    #[serde(rename = ""@type"")]
+    msg_type: MessageTypeV2,
+    #[serde(rename = ""sendMsg"")]
+    send_msg: bool,
     #[serde(skip_serializing_if = ""Option::is_none"")]
-    public_did: Option<String>,
+    uid: Option<String>,
+    #[serde(rename = ""replyToMsgId"")]
+    reply_to_msg_id: Option<String>,
+    #[serde(rename = ""keyDlgProof"")]
+    key_dlg_proof: KeyDlgProof,
+    #[serde(rename = ""senderDetail"")]
+    sender_detail: Option<SenderDetail>,
+    #[serde(rename = ""senderAgencyDetail"")]
+    sender_agency_detail: Option<SenderAgencyDetail>,
+    #[serde(rename = ""answerStatusCode"")]
+    answer_status_code: Option<MessageStatusCode>,
 }
 
-#[derive(Clone, Serialize, Debug, PartialEq, PartialOrd)]
+#[derive(Clone, Deserialize, Serialize, Debug, PartialEq)]
 #[serde(rename_all = ""camelCase"")]
-pub struct AcceptInvite {
-    #[serde(rename = ""to"")]
-    to_did: String,
-    to_vk: String,
-    #[serde(skip_serializing, default)]
-    payload: AcceptInvitePayload,
-    #[serde(skip_serializing, default)]
-    validate_rc: u32,
+pub struct KeyDlgProof {
+    #[serde(rename = ""agentDID"")]
     agent_did: String,
-    agent_vk: String,
+    #[serde(rename = ""agentDelegatedKey"")]
+    agent_delegated_key: String,
+    #[serde(rename = ""signature"")]
+    signature: String,
 }
 
-#[derive(Clone, Deserialize, Serialize, Debug, PartialEq, PartialOrd)]
+#[derive(Clone, Deserialize, Serialize, Debug, PartialEq)]
 #[serde(rename_all = ""camelCase"")]
 pub struct SenderDetail {
-    pub name: Option<String>,
-    pub agent_key_dlg_proof: KeyDlgProofPayload,
+    name: Option<String>,
+    agent_key_dlg_proof: KeyDlgProof,
     #[serde(rename = ""DID"")]
     pub did: String,
-    pub logo_url: Option<String>,
+    logo_url: Option<String>,
     #[serde(rename = ""verKey"")]
     pub verkey: String,
     #[serde(rename = ""publicDID"")]
     #[serde(skip_serializing_if = ""Option::is_none"")]
     pub public_did: Option<String>,
 }
 
-#[derive(Clone, Deserialize, Serialize, Debug, PartialEq, PartialOrd)]
+#[derive(Clone, Deserialize, Serialize, Debug, PartialEq)]
 #[serde(rename_all = ""camelCase"")]
 pub struct SenderAgencyDetail {
     #[serde(rename = ""DID"")]
-    pub did: String,
+    did: String,
     #[serde(rename = ""verKey"")]
-    pub verkey: String,
-    pub endpoint: String,
+    verkey: String,
+    endpoint: String,
 }
 
-#[derive(Clone, Deserialize, Serialize, Debug, PartialEq, PartialOrd)]
+#[derive(Clone, Deserialize, Serialize, Debug, PartialEq)]
 #[serde(rename_all = ""camelCase"")]
 pub struct InviteDetail {
-    status_code: String,
+    pub status_code: String,",,2019-02-28 15:01:49,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/257211884,https://github.com/hyperledger/indy-sdk/pull/1464#discussion_r257211884,jovfer
https://github.com/hyperledger/indy-sdk/pull/1464,https://github.com/hyperledger/indy-sdk/pull/1464,"```suggestion
            let did = cap.name(""did"").map(String::s.as_str);
```",1660d905d81ad14899128f3cf66ff31f30a99c19,2019-02-15 12:20:26,257213388,"@@ -0,0 +1,159 @@
+use settings;
+
+use serde::{de, Deserializer, Deserialize, Serializer, Serialize};
+use serde_json::Value;
+use regex::Regex;
+use messages::A2AMessageKinds;
+use utils::error;
+
+pub const MESSAGE_VERSION_V1: &str = ""1.0"";
+pub const MESSAGE_VERSION_V2: &str = ""2.0"";
+pub const DID: &str = ""did:sov:123456789abcdefghi1234"";
+
+#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]
+#[serde(untagged)]
+pub enum MessageTypes {
+    MessageTypeV1(MessageTypeV1),
+    MessageTypeV2(MessageTypeV2),
+}
+
+impl MessageTypes {
+    pub fn build_v1(kind: A2AMessageKinds) -> MessageTypeV1 {
+        MessageTypeV1 {
+            name: kind.name(),
+            ver: MESSAGE_VERSION_V1.to_string(),
+        }
+    }
+
+    pub fn build_v2(kind: A2AMessageKinds) -> MessageTypeV2 {
+        MessageTypeV2 {
+            did: DID.to_string(),
+            family: kind.family(),
+            version: MESSAGE_VERSION_V2.to_string(),
+            type_: kind.name(),
+        }
+    }
+
+    pub fn build(kind: A2AMessageKinds) -> MessageTypes {
+        match settings::get_protocol_type() {
+            settings::ProtocolTypes::V1 => MessageTypes::MessageTypeV1(MessageTypes::build_v1(kind)),
+            settings::ProtocolTypes::V2 => MessageTypes::MessageTypeV2(MessageTypes::build_v2(kind))
+        }
+    }
+
+    pub fn name<'a>(&'a self) -> &'a str {
+        match self {
+            MessageTypes::MessageTypeV1(type_) => type_.name.as_str(),
+            MessageTypes::MessageTypeV2(type_) => type_.type_.as_str(),
+        }
+    }
+
+    pub fn version<'a>(&'a self) -> &'a str {
+        match self {
+            MessageTypes::MessageTypeV1(type_) => type_.ver.as_str(),
+            MessageTypes::MessageTypeV2(type_) => type_.version.as_str(),
+        }
+    }
+}
+
+#[derive(Clone, Deserialize, Serialize, Debug, PartialEq)]
+pub struct MessageTypeV1 {
+    pub name: String,
+    pub ver: String,
+}
+
+#[derive(Debug, Clone, PartialEq)]
+pub struct MessageTypeV2 {
+    pub did: String,
+    pub family: MessageFamilies,
+    pub version: String,
+    pub type_: String,
+}
+
+#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]
+pub enum MessageFamilies {
+    Routing,
+    Onboarding,
+    Pairwise,
+    Configs,
+    CredentialExchange,
+    Unknown(String),
+}
+
+impl From<String> for MessageFamilies {
+    fn from(family: String) -> Self {
+        match family.as_str() {
+            ""routing"" => MessageFamilies::Routing,
+            ""onboarding"" => MessageFamilies::Onboarding,
+            ""pairwise"" => MessageFamilies::Pairwise,
+            ""configs"" => MessageFamilies::Configs,
+            ""credential-exchange"" => MessageFamilies::CredentialExchange,
+            family @ _ => MessageFamilies::Unknown(family.to_string())
+        }
+    }
+}
+
+impl ::std::string::ToString for MessageFamilies {
+    fn to_string(&self) -> String {
+        match self {
+            MessageFamilies::Routing => ""routing"".to_string(),
+            MessageFamilies::Onboarding => ""onboarding"".to_string(),
+            MessageFamilies::Pairwise => ""pairwise"".to_string(),
+            MessageFamilies::CredentialExchange => ""credential_exchange"".to_string(),
+            MessageFamilies::Configs => ""configs"".to_string(),
+            MessageFamilies::Unknown(family) => family.to_string()
+        }
+    }
+}
+
+
+fn parse_message_type(message_type: &str) -> Result<(String, String, String, String), u32> {
+    lazy_static! {
+        static ref RE: Regex = Regex::new(r""(?x)
+            (?P<did>[\d\w:]*);
+            (?P<spec>.*)/
+            (?P<family>.*)/
+            (?P<version>.*)/
+            (?P<type>.*)"").unwrap();
+    }
+
+    RE.captures(message_type)
+        .and_then(|cap| {
+            let did = cap.name(""did"").map(|s| s.as_str());",,2019-02-28 15:01:49,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/257213388,https://github.com/hyperledger/indy-sdk/pull/1464#discussion_r257213388,jovfer
https://github.com/hyperledger/indy-sdk/pull/1464,https://github.com/hyperledger/indy-sdk/pull/1464,This version depends on massage family,1660d905d81ad14899128f3cf66ff31f30a99c19,2019-02-15 12:24:27,257214626,"@@ -0,0 +1,143 @@
+use serde::{de, Deserializer, Deserialize, Serializer, Serialize};
+use serde_json::Value;
+use regex::Regex;
+use failure::{err_msg, Error};
+use domain::a2a::A2AMessageKinds;
+
+pub const MESSAGE_VERSION_V1: &str = ""1.0"";
+pub const MESSAGE_VERSION_V2: &str = ""2.0"";
+
+pub const DID: &str = ""did:sov:123456789abcdefghi1234"";
+
+#[derive(Debug, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum MessageTypes {
+    MessageTypeV1(MessageTypeV1),
+    MessageTypeV2(MessageTypeV2),
+}
+
+impl MessageTypes {
+    pub fn build_v1(kind: A2AMessageKinds) -> MessageTypes {
+        MessageTypes::MessageTypeV1(MessageTypeV1 {
+            name: kind.name(),
+            ver: MESSAGE_VERSION_V1.to_string(),
+        })
+    }
+
+    pub fn build_v2(kind: A2AMessageKinds) -> MessageTypes {
+        MessageTypes::MessageTypeV2(MessageTypeV2 {
+            did: DID.to_string(),
+            family: kind.family(),
+            version: MESSAGE_VERSION_V2.to_string(),",,2019-02-28 15:01:49,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/257214626,https://github.com/hyperledger/indy-sdk/pull/1464#discussion_r257214626,jovfer
https://github.com/hyperledger/indy-sdk/pull/1460,https://github.com/hyperledger/indy-sdk/pull/1460,I suggest to use platform specific directive instead of commenting code,cf0ddc821f9653036e7b67ffb95dae181c4042bb,2019-02-07 07:36:42,254571428,"@@ -23,9 +23,10 @@ use std::ffi::CString;
 
 #[no_mangle]
 pub extern fn nullpay_init() -> ErrorCode {
-    if let Err(err) = utils::logger::LibnullpayLogger::init() {",,2019-02-08 10:51:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/254571428,https://github.com/hyperledger/indy-sdk/pull/1460#discussion_r254571428,jovfer
https://github.com/hyperledger/indy-sdk/pull/1460,https://github.com/hyperledger/indy-sdk/pull/1460,"Please add reference to ticket in Jira devoted to removing this hotfix.
~~If possible and only few functions are unused, please move global directive to particular functions~~ too many entries, agree, global directive better here",cf0ddc821f9653036e7b67ffb95dae181c4042bb,2019-02-07 07:41:11,254572244,"@@ -1,3 +1,6 @@
+#![allow(dead_code)]",,2019-02-08 10:50:52,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/254572244,https://github.com/hyperledger/indy-sdk/pull/1460#discussion_r254572244,jovfer
https://github.com/hyperledger/indy-sdk/pull/1460,https://github.com/hyperledger/indy-sdk/pull/1460,Also please add comment and reference to ticket/bug in Jira about resolving mobile platform problem,cf0ddc821f9653036e7b67ffb95dae181c4042bb,2019-02-07 07:42:10,254572390,"@@ -23,9 +23,10 @@ use std::ffi::CString;
 
 #[no_mangle]
 pub extern fn nullpay_init() -> ErrorCode {
-    if let Err(err) = utils::logger::LibnullpayLogger::init() {",,2019-02-08 10:51:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/254572390,https://github.com/hyperledger/indy-sdk/pull/1460#discussion_r254572390,jovfer
https://github.com/hyperledger/indy-sdk/pull/1460,https://github.com/hyperledger/indy-sdk/pull/1460,I added directives.  ,cf0ddc821f9653036e7b67ffb95dae181c4042bb,2019-02-07 17:06:14,254780957,"@@ -23,9 +23,10 @@ use std::ffi::CString;
 
 #[no_mangle]
 pub extern fn nullpay_init() -> ErrorCode {
-    if let Err(err) = utils::logger::LibnullpayLogger::init() {",,2019-02-08 10:51:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/254780957,https://github.com/hyperledger/indy-sdk/pull/1460#discussion_r254780957,mattraffel
https://github.com/hyperledger/indy-sdk/pull/1460,https://github.com/hyperledger/indy-sdk/pull/1460,"After new changes below it's seems like these 2 allows are not required now, isn't it?",cf0ddc821f9653036e7b67ffb95dae181c4042bb,2019-02-07 17:33:38,254791557,"@@ -1,3 +1,6 @@
+#![allow(dead_code)]",,2019-02-08 10:50:52,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/254791557,https://github.com/hyperledger/indy-sdk/pull/1460#discussion_r254791557,jovfer
https://github.com/hyperledger/indy-sdk/pull/1460,https://github.com/hyperledger/indy-sdk/pull/1460,agreed.  ,cf0ddc821f9653036e7b67ffb95dae181c4042bb,2019-02-07 17:36:54,254792809,"@@ -1,3 +1,6 @@
+#![allow(dead_code)]",,2019-02-08 10:50:52,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/254792809,https://github.com/hyperledger/indy-sdk/pull/1460#discussion_r254792809,mattraffel
https://github.com/hyperledger/indy-sdk/pull/1459,https://github.com/hyperledger/indy-sdk/pull/1459,"I suggest using dictionaries for extensions and paths like:
`extention = {""darwin"": "".dylib"", ""linux"": "".so"", ""win32"": "".dll""}`",007c32b973d5a7807a96eab334031a985e5b8686,2019-02-18 06:10:34,257567090,"@@ -18,14 +19,21 @@ export class VCXRuntime {
 
   constructor (config: IVCXRuntimeConfig = {}) {
     this._config = config
-     // initialize FFI
+        // initialize FFI
     const libraryPath = this._initializeBasepath()
     this.ffi = ffi.Library(libraryPath, FFIConfiguration)
   }
 
   private _initializeBasepath = (): string => {
-    const library = 'libvcx.so' // TODO: FIXME provide better way to resolve library
+    const platform = os.platform()
+    const postfix = (platform === 'darwin') ? 'dylib' : (platform === 'win32') ? 'dll' : 'so'
+    const library = `libvcx.${postfix}`
+    const libDir = (platform === 'darwin')
+        ? '/usr/local/lib/'
+        : (platform === 'win32')
+            ? 'c:\\windows\\system32\\'
+            : '/usr/lib/'",,2019-03-14 08:01:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/257567090,https://github.com/hyperledger/indy-sdk/pull/1459#discussion_r257567090,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1459,https://github.com/hyperledger/indy-sdk/pull/1459,our CI runs vcx python tests on Ubuntu only. I believe we have to leave `/usr/lib` or to build it properly base on os.,007c32b973d5a7807a96eab334031a985e5b8686,2019-02-18 06:16:02,257567800,"@@ -20,7 +20,7 @@ describe('vcxInit', () => {
 // these tests were created to only test that the ffi could be called with each function
 
 describe('Using the vcx ffi directly', () => {
-  const path = '/usr/lib/libvcx.so'
+  const path = '/usr/local/lib/libvcx.so'
   const run = new VCXRuntime({ basepath: path })",,2019-03-14 08:01:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/257567800,https://github.com/hyperledger/indy-sdk/pull/1459#discussion_r257567800,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1459,https://github.com/hyperledger/indy-sdk/pull/1459,changed,007c32b973d5a7807a96eab334031a985e5b8686,2019-03-04 11:53:16,262028169,"@@ -18,14 +19,21 @@ export class VCXRuntime {
 
   constructor (config: IVCXRuntimeConfig = {}) {
     this._config = config
-     // initialize FFI
+        // initialize FFI
     const libraryPath = this._initializeBasepath()
     this.ffi = ffi.Library(libraryPath, FFIConfiguration)
   }
 
   private _initializeBasepath = (): string => {
-    const library = 'libvcx.so' // TODO: FIXME provide better way to resolve library
+    const platform = os.platform()
+    const postfix = (platform === 'darwin') ? 'dylib' : (platform === 'win32') ? 'dll' : 'so'
+    const library = `libvcx.${postfix}`
+    const libDir = (platform === 'darwin')
+        ? '/usr/local/lib/'
+        : (platform === 'win32')
+            ? 'c:\\windows\\system32\\'
+            : '/usr/lib/'",,2019-03-14 08:01:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262028169,https://github.com/hyperledger/indy-sdk/pull/1459#discussion_r262028169,Patrik-Stas
https://github.com/hyperledger/indy-sdk/pull/1459,https://github.com/hyperledger/indy-sdk/pull/1459,reverted,007c32b973d5a7807a96eab334031a985e5b8686,2019-03-04 11:53:26,262028211,"@@ -20,7 +20,7 @@ describe('vcxInit', () => {
 // these tests were created to only test that the ffi could be called with each function
 
 describe('Using the vcx ffi directly', () => {
-  const path = '/usr/lib/libvcx.so'
+  const path = '/usr/local/lib/libvcx.so'
   const run = new VCXRuntime({ basepath: path })",,2019-03-14 08:01:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/262028211,https://github.com/hyperledger/indy-sdk/pull/1459#discussion_r262028211,Patrik-Stas
https://github.com/hyperledger/indy-sdk/pull/1454,https://github.com/hyperledger/indy-sdk/pull/1454,"1. I suggest to remove submitter_did param as it can be hard-coded or auto-generated for each request
2. Do we need to return cache timestamp also?
3. I suggest to add options_json that will allow to:

- Skip caching
- Provide required freshness",c9fb7694d96b135cbc5c8e89643a60e704438315,2019-02-12 12:48:52,255937302,"@@ -0,0 +1,103 @@
+# Caching of data from ledger
+
+Currently whenever credential definitions and/or schemas is needed, it is being fetched from the ledger.
+This operation may last multiple seconds and is slowing down usage of credentials.
+Caching also enables usage of anoncreds in areas where user do not have internet coverage (eg. Using passport credential on foreign airport).
+
+## Goals and ideas
+
+* Allow users to cache credential definitions and schemas.
+  * Local wallet to be used because although this data is public, possession of some credential definition or schema reveals possession of respective credential. 
+* Provide higher level api for fetching this data so it is easier to use.
+  * Caching should be transparent to the user.
+* Enable purging of old (not needed more) data.
+  
+## Public API
+
+Note: In all calls `pool_handle` may be removed if did resolver is implemented.
+
+```Rust
+/// Gets credential definition json data for specified credential definition id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of credential definition.
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_cred_def(command_handle: IndyHandle,
+                                pool_handle: IndyHandle,
+                                wallet_handle: IndyHandle,
+                                submitter_did: *const c_char,",39,2019-03-07 13:10:34,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/255937302,https://github.com/hyperledger/indy-sdk/pull/1454#discussion_r255937302,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1454,https://github.com/hyperledger/indy-sdk/pull/1454,"3. Skip caching have sense in a meaning do not store retrieved value inside of cache.
    For freshness, I think that schema and credential_def cannot be updated (without change of id) so freshness is not needed. For that reason I do not see need for cache timestamp.",c9fb7694d96b135cbc5c8e89643a60e704438315,2019-02-13 15:25:01,256444911,"@@ -0,0 +1,103 @@
+# Caching of data from ledger
+
+Currently whenever credential definitions and/or schemas is needed, it is being fetched from the ledger.
+This operation may last multiple seconds and is slowing down usage of credentials.
+Caching also enables usage of anoncreds in areas where user do not have internet coverage (eg. Using passport credential on foreign airport).
+
+## Goals and ideas
+
+* Allow users to cache credential definitions and schemas.
+  * Local wallet to be used because although this data is public, possession of some credential definition or schema reveals possession of respective credential. 
+* Provide higher level api for fetching this data so it is easier to use.
+  * Caching should be transparent to the user.
+* Enable purging of old (not needed more) data.
+  
+## Public API
+
+Note: In all calls `pool_handle` may be removed if did resolver is implemented.
+
+```Rust
+/// Gets credential definition json data for specified credential definition id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of credential definition.
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_cred_def(command_handle: IndyHandle,
+                                pool_handle: IndyHandle,
+                                wallet_handle: IndyHandle,
+                                submitter_did: *const c_char,",39,2019-03-07 13:10:34,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/256444911,https://github.com/hyperledger/indy-sdk/pull/1454#discussion_r256444911,dkulic
https://github.com/hyperledger/indy-sdk/pull/1454,https://github.com/hyperledger/indy-sdk/pull/1454,In my understanding CredDef and Schema can be updated. Schema can get backward compatible changes.  Keys in CredDef can be rotated in some cases. Also some entities we plan to cache like DID Doc can be updated much often. @ashcherbakov What do you think?,c9fb7694d96b135cbc5c8e89643a60e704438315,2019-02-14 06:50:26,256708034,"@@ -0,0 +1,103 @@
+# Caching of data from ledger
+
+Currently whenever credential definitions and/or schemas is needed, it is being fetched from the ledger.
+This operation may last multiple seconds and is slowing down usage of credentials.
+Caching also enables usage of anoncreds in areas where user do not have internet coverage (eg. Using passport credential on foreign airport).
+
+## Goals and ideas
+
+* Allow users to cache credential definitions and schemas.
+  * Local wallet to be used because although this data is public, possession of some credential definition or schema reveals possession of respective credential. 
+* Provide higher level api for fetching this data so it is easier to use.
+  * Caching should be transparent to the user.
+* Enable purging of old (not needed more) data.
+  
+## Public API
+
+Note: In all calls `pool_handle` may be removed if did resolver is implemented.
+
+```Rust
+/// Gets credential definition json data for specified credential definition id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of credential definition.
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_cred_def(command_handle: IndyHandle,
+                                pool_handle: IndyHandle,
+                                wallet_handle: IndyHandle,
+                                submitter_did: *const c_char,",39,2019-03-07 13:10:34,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/256708034,https://github.com/hyperledger/indy-sdk/pull/1454#discussion_r256708034,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1454,https://github.com/hyperledger/indy-sdk/pull/1454,"I believe we need to decide what exact option to use or provide an API for configuration of cache. For example, we can add behavior configuration to indy_init() method.",c9fb7694d96b135cbc5c8e89643a60e704438315,2019-03-07 10:56:24,263331712,"@@ -0,0 +1,113 @@
+# Caching of data from ledger
+
+Currently whenever credential definitions and/or schemas is needed, it is being fetched from the ledger.
+This operation may last multiple seconds and is slowing down usage of credentials.
+Caching also enables usage of anoncreds in areas where user do not have internet coverage (eg. Using passport credential on foreign airport).
+
+## Goals and ideas
+
+* Allow users to cache credential definitions and schemas.
+  * Local wallet to be used because although this data is public, possession of some credential definition or schema reveals possession of respective credential. 
+* Provide higher level api for fetching this data so it is easier to use.
+  * Caching should be transparent to the user.
+* Enable purging of old (not needed more) data.
+  
+## Public API
+
+Note: In all calls `pool_handle` may be removed if did resolver is implemented.
+
+```Rust
+/// Gets credential definition json data for specified credential definition id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of credential definition.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_cred_def(command_handle: IndyHandle,
+                                pool_handle: IndyHandle,
+                                wallet_handle: IndyHandle,
+                                submitter_did: *const c_char,
+                                id: *const c_char,
+                                options_json: *const c_char,
+                                cb: Option<extern fn(command_handle_: IndyHandle,
+                                                     err: ErrorCode,
+                                                     cred_def_json: *const c_char)>) -> ErrorCode {
+}
+
+/// Gets schema json data for specified schema id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of schema.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_schema(command_handle: IndyHandle,
+                              pool_handle: IndyHandle,
+                              wallet_handle: IndyHandle,
+                              submitter_did: *const c_char,
+                              id: *const c_char,
+                              options_json: *const c_char,
+                              cb: Option<extern fn(command_handle_: IndyHandle,
+                                                   err: ErrorCode,
+                                                   schema_json: *const c_char)>) -> ErrorCode {
+}
+```
+
+## Storing of the data into wallet
+
+Data would be stored with specific cache type so that it is separated and easy to be managed.
+Schema_id or cred_def_id would be used for id of wallet data.
+This way data may be fetched very efficiently and also easy to be deleted when needed.
+
+## Purging the cache
+
+Several methods may be implemented for purging the cached data:
+
+#### Purge all",85,2019-03-07 13:10:34,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263331712,https://github.com/hyperledger/indy-sdk/pull/1454#discussion_r263331712,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1454,https://github.com/hyperledger/indy-sdk/pull/1454,"I believe we can use  something similar to http-cache control headers:

```http
Cache-Control: max-age=<seconds>
Cache-Control: max-stale[=<seconds>]
Cache-Control: min-fresh=<seconds>
Cache-Control: no-cache 
Cache-Control: no-store
Cache-Control: no-transform
Cache-Control: only-if-cached
```

",c9fb7694d96b135cbc5c8e89643a60e704438315,2019-03-07 11:07:54,263335502,"@@ -0,0 +1,113 @@
+# Caching of data from ledger
+
+Currently whenever credential definitions and/or schemas is needed, it is being fetched from the ledger.
+This operation may last multiple seconds and is slowing down usage of credentials.
+Caching also enables usage of anoncreds in areas where user do not have internet coverage (eg. Using passport credential on foreign airport).
+
+## Goals and ideas
+
+* Allow users to cache credential definitions and schemas.
+  * Local wallet to be used because although this data is public, possession of some credential definition or schema reveals possession of respective credential. 
+* Provide higher level api for fetching this data so it is easier to use.
+  * Caching should be transparent to the user.
+* Enable purging of old (not needed more) data.
+  
+## Public API
+
+Note: In all calls `pool_handle` may be removed if did resolver is implemented.
+
+```Rust
+/// Gets credential definition json data for specified credential definition id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of credential definition.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,",32,2019-03-07 13:10:34,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263335502,https://github.com/hyperledger/indy-sdk/pull/1454#discussion_r263335502,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1454,https://github.com/hyperledger/indy-sdk/pull/1454,"To define purge behavior i also suggest to look to http cache options:

```http
Cache-Control: max-age=<seconds>
Cache-Control: max-stale[=<seconds>]
Cache-Control: min-fresh=<seconds>
Cache-Control: no-cache 
Cache-Control: no-store
Cache-Control: no-transform
Cache-Control: only-if-cached
```

In this case we can define exact behavior for each entity.",c9fb7694d96b135cbc5c8e89643a60e704438315,2019-03-07 11:09:32,263336042,"@@ -0,0 +1,113 @@
+# Caching of data from ledger
+
+Currently whenever credential definitions and/or schemas is needed, it is being fetched from the ledger.
+This operation may last multiple seconds and is slowing down usage of credentials.
+Caching also enables usage of anoncreds in areas where user do not have internet coverage (eg. Using passport credential on foreign airport).
+
+## Goals and ideas
+
+* Allow users to cache credential definitions and schemas.
+  * Local wallet to be used because although this data is public, possession of some credential definition or schema reveals possession of respective credential. 
+* Provide higher level api for fetching this data so it is easier to use.
+  * Caching should be transparent to the user.
+* Enable purging of old (not needed more) data.
+  
+## Public API
+
+Note: In all calls `pool_handle` may be removed if did resolver is implemented.
+
+```Rust
+/// Gets credential definition json data for specified credential definition id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of credential definition.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_cred_def(command_handle: IndyHandle,
+                                pool_handle: IndyHandle,
+                                wallet_handle: IndyHandle,
+                                submitter_did: *const c_char,
+                                id: *const c_char,
+                                options_json: *const c_char,
+                                cb: Option<extern fn(command_handle_: IndyHandle,
+                                                     err: ErrorCode,
+                                                     cred_def_json: *const c_char)>) -> ErrorCode {
+}
+
+/// Gets schema json data for specified schema id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of schema.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_schema(command_handle: IndyHandle,
+                              pool_handle: IndyHandle,
+                              wallet_handle: IndyHandle,
+                              submitter_did: *const c_char,
+                              id: *const c_char,
+                              options_json: *const c_char,
+                              cb: Option<extern fn(command_handle_: IndyHandle,
+                                                   err: ErrorCode,
+                                                   schema_json: *const c_char)>) -> ErrorCode {
+}
+```
+
+## Storing of the data into wallet
+
+Data would be stored with specific cache type so that it is separated and easy to be managed.
+Schema_id or cred_def_id would be used for id of wallet data.
+This way data may be fetched very efficiently and also easy to be deleted when needed.
+
+## Purging the cache
+
+Several methods may be implemented for purging the cached data:
+
+#### Purge all",85,2019-03-07 13:10:34,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263336042,https://github.com/hyperledger/indy-sdk/pull/1454#discussion_r263336042,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1454,https://github.com/hyperledger/indy-sdk/pull/1454,@dkulic @jovfer @ashcherbakov @dhh1128 What do you think on ^?,c9fb7694d96b135cbc5c8e89643a60e704438315,2019-03-07 11:11:18,263336665,"@@ -0,0 +1,113 @@
+# Caching of data from ledger
+
+Currently whenever credential definitions and/or schemas is needed, it is being fetched from the ledger.
+This operation may last multiple seconds and is slowing down usage of credentials.
+Caching also enables usage of anoncreds in areas where user do not have internet coverage (eg. Using passport credential on foreign airport).
+
+## Goals and ideas
+
+* Allow users to cache credential definitions and schemas.
+  * Local wallet to be used because although this data is public, possession of some credential definition or schema reveals possession of respective credential. 
+* Provide higher level api for fetching this data so it is easier to use.
+  * Caching should be transparent to the user.
+* Enable purging of old (not needed more) data.
+  
+## Public API
+
+Note: In all calls `pool_handle` may be removed if did resolver is implemented.
+
+```Rust
+/// Gets credential definition json data for specified credential definition id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of credential definition.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_cred_def(command_handle: IndyHandle,
+                                pool_handle: IndyHandle,
+                                wallet_handle: IndyHandle,
+                                submitter_did: *const c_char,
+                                id: *const c_char,
+                                options_json: *const c_char,
+                                cb: Option<extern fn(command_handle_: IndyHandle,
+                                                     err: ErrorCode,
+                                                     cred_def_json: *const c_char)>) -> ErrorCode {
+}
+
+/// Gets schema json data for specified schema id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of schema.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_schema(command_handle: IndyHandle,
+                              pool_handle: IndyHandle,
+                              wallet_handle: IndyHandle,
+                              submitter_did: *const c_char,
+                              id: *const c_char,
+                              options_json: *const c_char,
+                              cb: Option<extern fn(command_handle_: IndyHandle,
+                                                   err: ErrorCode,
+                                                   schema_json: *const c_char)>) -> ErrorCode {
+}
+```
+
+## Storing of the data into wallet
+
+Data would be stored with specific cache type so that it is separated and easy to be managed.
+Schema_id or cred_def_id would be used for id of wallet data.
+This way data may be fetched very efficiently and also easy to be deleted when needed.
+
+## Purging the cache
+
+Several methods may be implemented for purging the cached data:
+
+#### Purge all",85,2019-03-07 13:10:34,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263336665,https://github.com/hyperledger/indy-sdk/pull/1454#discussion_r263336665,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1454,https://github.com/hyperledger/indy-sdk/pull/1454,"Some of these options look very useful. I would like not to have too many options, which may be too confusing. I especially like: max-age, only-if-cached.",c9fb7694d96b135cbc5c8e89643a60e704438315,2019-03-07 13:14:01,263375474,"@@ -0,0 +1,113 @@
+# Caching of data from ledger
+
+Currently whenever credential definitions and/or schemas is needed, it is being fetched from the ledger.
+This operation may last multiple seconds and is slowing down usage of credentials.
+Caching also enables usage of anoncreds in areas where user do not have internet coverage (eg. Using passport credential on foreign airport).
+
+## Goals and ideas
+
+* Allow users to cache credential definitions and schemas.
+  * Local wallet to be used because although this data is public, possession of some credential definition or schema reveals possession of respective credential. 
+* Provide higher level api for fetching this data so it is easier to use.
+  * Caching should be transparent to the user.
+* Enable purging of old (not needed more) data.
+  
+## Public API
+
+Note: In all calls `pool_handle` may be removed if did resolver is implemented.
+
+```Rust
+/// Gets credential definition json data for specified credential definition id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of credential definition.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,",32,2019-03-07 13:14:32,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263375474,https://github.com/hyperledger/indy-sdk/pull/1454#discussion_r263375474,dkulic
https://github.com/hyperledger/indy-sdk/pull/1454,https://github.com/hyperledger/indy-sdk/pull/1454,"I am not sure I follow your thoughts regarding defining exact behavior for each entity. Do you mean adding specific caching policy to each entity, so that purging process may selectively purge only entities which satisfy its own policy? If this is the case, that seams to complicated...",c9fb7694d96b135cbc5c8e89643a60e704438315,2019-03-07 13:18:42,263377082,"@@ -0,0 +1,113 @@
+# Caching of data from ledger
+
+Currently whenever credential definitions and/or schemas is needed, it is being fetched from the ledger.
+This operation may last multiple seconds and is slowing down usage of credentials.
+Caching also enables usage of anoncreds in areas where user do not have internet coverage (eg. Using passport credential on foreign airport).
+
+## Goals and ideas
+
+* Allow users to cache credential definitions and schemas.
+  * Local wallet to be used because although this data is public, possession of some credential definition or schema reveals possession of respective credential. 
+* Provide higher level api for fetching this data so it is easier to use.
+  * Caching should be transparent to the user.
+* Enable purging of old (not needed more) data.
+  
+## Public API
+
+Note: In all calls `pool_handle` may be removed if did resolver is implemented.
+
+```Rust
+/// Gets credential definition json data for specified credential definition id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of credential definition.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_cred_def(command_handle: IndyHandle,
+                                pool_handle: IndyHandle,
+                                wallet_handle: IndyHandle,
+                                submitter_did: *const c_char,
+                                id: *const c_char,
+                                options_json: *const c_char,
+                                cb: Option<extern fn(command_handle_: IndyHandle,
+                                                     err: ErrorCode,
+                                                     cred_def_json: *const c_char)>) -> ErrorCode {
+}
+
+/// Gets schema json data for specified schema id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of schema.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_schema(command_handle: IndyHandle,
+                              pool_handle: IndyHandle,
+                              wallet_handle: IndyHandle,
+                              submitter_did: *const c_char,
+                              id: *const c_char,
+                              options_json: *const c_char,
+                              cb: Option<extern fn(command_handle_: IndyHandle,
+                                                   err: ErrorCode,
+                                                   schema_json: *const c_char)>) -> ErrorCode {
+}
+```
+
+## Storing of the data into wallet
+
+Data would be stored with specific cache type so that it is separated and easy to be managed.
+Schema_id or cred_def_id would be used for id of wallet data.
+This way data may be fetched very efficiently and also easy to be deleted when needed.
+
+## Purging the cache
+
+Several methods may be implemented for purging the cached data:
+
+#### Purge all",85,2019-03-07 13:18:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263377082,https://github.com/hyperledger/indy-sdk/pull/1454#discussion_r263377082,dkulic
https://github.com/hyperledger/indy-sdk/pull/1454,https://github.com/hyperledger/indy-sdk/pull/1454,"@dkulic The idea is very simple:

1. When app asks for some entity it can explicitly say how long it want to store this entity in cache
2. On start app can call `purge` method that will remove all outdated records. ",c9fb7694d96b135cbc5c8e89643a60e704438315,2019-03-07 14:00:57,263393776,"@@ -0,0 +1,113 @@
+# Caching of data from ledger
+
+Currently whenever credential definitions and/or schemas is needed, it is being fetched from the ledger.
+This operation may last multiple seconds and is slowing down usage of credentials.
+Caching also enables usage of anoncreds in areas where user do not have internet coverage (eg. Using passport credential on foreign airport).
+
+## Goals and ideas
+
+* Allow users to cache credential definitions and schemas.
+  * Local wallet to be used because although this data is public, possession of some credential definition or schema reveals possession of respective credential. 
+* Provide higher level api for fetching this data so it is easier to use.
+  * Caching should be transparent to the user.
+* Enable purging of old (not needed more) data.
+  
+## Public API
+
+Note: In all calls `pool_handle` may be removed if did resolver is implemented.
+
+```Rust
+/// Gets credential definition json data for specified credential definition id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of credential definition.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_cred_def(command_handle: IndyHandle,
+                                pool_handle: IndyHandle,
+                                wallet_handle: IndyHandle,
+                                submitter_did: *const c_char,
+                                id: *const c_char,
+                                options_json: *const c_char,
+                                cb: Option<extern fn(command_handle_: IndyHandle,
+                                                     err: ErrorCode,
+                                                     cred_def_json: *const c_char)>) -> ErrorCode {
+}
+
+/// Gets schema json data for specified schema id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of schema.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_schema(command_handle: IndyHandle,
+                              pool_handle: IndyHandle,
+                              wallet_handle: IndyHandle,
+                              submitter_did: *const c_char,
+                              id: *const c_char,
+                              options_json: *const c_char,
+                              cb: Option<extern fn(command_handle_: IndyHandle,
+                                                   err: ErrorCode,
+                                                   schema_json: *const c_char)>) -> ErrorCode {
+}
+```
+
+## Storing of the data into wallet
+
+Data would be stored with specific cache type so that it is separated and easy to be managed.
+Schema_id or cred_def_id would be used for id of wallet data.
+This way data may be fetched very efficiently and also easy to be deleted when needed.
+
+## Purging the cache
+
+Several methods may be implemented for purging the cached data:
+
+#### Purge all",85,2019-03-07 14:01:06,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263393776,https://github.com/hyperledger/indy-sdk/pull/1454#discussion_r263393776,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1454,https://github.com/hyperledger/indy-sdk/pull/1454,That sounds doable. :),c9fb7694d96b135cbc5c8e89643a60e704438315,2019-03-07 14:03:14,263394758,"@@ -0,0 +1,113 @@
+# Caching of data from ledger
+
+Currently whenever credential definitions and/or schemas is needed, it is being fetched from the ledger.
+This operation may last multiple seconds and is slowing down usage of credentials.
+Caching also enables usage of anoncreds in areas where user do not have internet coverage (eg. Using passport credential on foreign airport).
+
+## Goals and ideas
+
+* Allow users to cache credential definitions and schemas.
+  * Local wallet to be used because although this data is public, possession of some credential definition or schema reveals possession of respective credential. 
+* Provide higher level api for fetching this data so it is easier to use.
+  * Caching should be transparent to the user.
+* Enable purging of old (not needed more) data.
+  
+## Public API
+
+Note: In all calls `pool_handle` may be removed if did resolver is implemented.
+
+```Rust
+/// Gets credential definition json data for specified credential definition id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of credential definition.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_cred_def(command_handle: IndyHandle,
+                                pool_handle: IndyHandle,
+                                wallet_handle: IndyHandle,
+                                submitter_did: *const c_char,
+                                id: *const c_char,
+                                options_json: *const c_char,
+                                cb: Option<extern fn(command_handle_: IndyHandle,
+                                                     err: ErrorCode,
+                                                     cred_def_json: *const c_char)>) -> ErrorCode {
+}
+
+/// Gets schema json data for specified schema id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of schema.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_schema(command_handle: IndyHandle,
+                              pool_handle: IndyHandle,
+                              wallet_handle: IndyHandle,
+                              submitter_did: *const c_char,
+                              id: *const c_char,
+                              options_json: *const c_char,
+                              cb: Option<extern fn(command_handle_: IndyHandle,
+                                                   err: ErrorCode,
+                                                   schema_json: *const c_char)>) -> ErrorCode {
+}
+```
+
+## Storing of the data into wallet
+
+Data would be stored with specific cache type so that it is separated and easy to be managed.
+Schema_id or cred_def_id would be used for id of wallet data.
+This way data may be fetched very efficiently and also easy to be deleted when needed.
+
+## Purging the cache
+
+Several methods may be implemented for purging the cached data:
+
+#### Purge all",85,2019-03-07 14:03:14,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263394758,https://github.com/hyperledger/indy-sdk/pull/1454#discussion_r263394758,dkulic
https://github.com/hyperledger/indy-sdk/pull/1454,https://github.com/hyperledger/indy-sdk/pull/1454,also purge can have `force` param that will remove all cache records. ,c9fb7694d96b135cbc5c8e89643a60e704438315,2019-03-07 14:07:25,263396475,"@@ -0,0 +1,113 @@
+# Caching of data from ledger
+
+Currently whenever credential definitions and/or schemas is needed, it is being fetched from the ledger.
+This operation may last multiple seconds and is slowing down usage of credentials.
+Caching also enables usage of anoncreds in areas where user do not have internet coverage (eg. Using passport credential on foreign airport).
+
+## Goals and ideas
+
+* Allow users to cache credential definitions and schemas.
+  * Local wallet to be used because although this data is public, possession of some credential definition or schema reveals possession of respective credential. 
+* Provide higher level api for fetching this data so it is easier to use.
+  * Caching should be transparent to the user.
+* Enable purging of old (not needed more) data.
+  
+## Public API
+
+Note: In all calls `pool_handle` may be removed if did resolver is implemented.
+
+```Rust
+/// Gets credential definition json data for specified credential definition id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of credential definition.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_cred_def(command_handle: IndyHandle,
+                                pool_handle: IndyHandle,
+                                wallet_handle: IndyHandle,
+                                submitter_did: *const c_char,
+                                id: *const c_char,
+                                options_json: *const c_char,
+                                cb: Option<extern fn(command_handle_: IndyHandle,
+                                                     err: ErrorCode,
+                                                     cred_def_json: *const c_char)>) -> ErrorCode {
+}
+
+/// Gets schema json data for specified schema id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of schema.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_schema(command_handle: IndyHandle,
+                              pool_handle: IndyHandle,
+                              wallet_handle: IndyHandle,
+                              submitter_did: *const c_char,
+                              id: *const c_char,
+                              options_json: *const c_char,
+                              cb: Option<extern fn(command_handle_: IndyHandle,
+                                                   err: ErrorCode,
+                                                   schema_json: *const c_char)>) -> ErrorCode {
+}
+```
+
+## Storing of the data into wallet
+
+Data would be stored with specific cache type so that it is separated and easy to be managed.
+Schema_id or cred_def_id would be used for id of wallet data.
+This way data may be fetched very efficiently and also easy to be deleted when needed.
+
+## Purging the cache
+
+Several methods may be implemented for purging the cached data:
+
+#### Purge all",85,2019-03-07 14:07:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263396475,https://github.com/hyperledger/indy-sdk/pull/1454#discussion_r263396475,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1454,https://github.com/hyperledger/indy-sdk/pull/1454,"I like the timeout idea, because you may lock in some cache items in cache forever. (eg. so you may use your passport on foreign airport, without internet).",c9fb7694d96b135cbc5c8e89643a60e704438315,2019-03-07 14:12:03,263398418,"@@ -0,0 +1,113 @@
+# Caching of data from ledger
+
+Currently whenever credential definitions and/or schemas is needed, it is being fetched from the ledger.
+This operation may last multiple seconds and is slowing down usage of credentials.
+Caching also enables usage of anoncreds in areas where user do not have internet coverage (eg. Using passport credential on foreign airport).
+
+## Goals and ideas
+
+* Allow users to cache credential definitions and schemas.
+  * Local wallet to be used because although this data is public, possession of some credential definition or schema reveals possession of respective credential. 
+* Provide higher level api for fetching this data so it is easier to use.
+  * Caching should be transparent to the user.
+* Enable purging of old (not needed more) data.
+  
+## Public API
+
+Note: In all calls `pool_handle` may be removed if did resolver is implemented.
+
+```Rust
+/// Gets credential definition json data for specified credential definition id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of credential definition.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_cred_def(command_handle: IndyHandle,
+                                pool_handle: IndyHandle,
+                                wallet_handle: IndyHandle,
+                                submitter_did: *const c_char,
+                                id: *const c_char,
+                                options_json: *const c_char,
+                                cb: Option<extern fn(command_handle_: IndyHandle,
+                                                     err: ErrorCode,
+                                                     cred_def_json: *const c_char)>) -> ErrorCode {
+}
+
+/// Gets schema json data for specified schema id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of schema.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_schema(command_handle: IndyHandle,
+                              pool_handle: IndyHandle,
+                              wallet_handle: IndyHandle,
+                              submitter_did: *const c_char,
+                              id: *const c_char,
+                              options_json: *const c_char,
+                              cb: Option<extern fn(command_handle_: IndyHandle,
+                                                   err: ErrorCode,
+                                                   schema_json: *const c_char)>) -> ErrorCode {
+}
+```
+
+## Storing of the data into wallet
+
+Data would be stored with specific cache type so that it is separated and easy to be managed.
+Schema_id or cred_def_id would be used for id of wallet data.
+This way data may be fetched very efficiently and also easy to be deleted when needed.
+
+## Purging the cache
+
+Several methods may be implemented for purging the cached data:
+
+#### Purge all",85,2019-03-07 14:12:03,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/263398418,https://github.com/hyperledger/indy-sdk/pull/1454#discussion_r263398418,dkulic
https://github.com/hyperledger/indy-sdk/pull/1454,https://github.com/hyperledger/indy-sdk/pull/1454,"After some thoughts I figured out I do not like idea about purging on start/specifying ttl for every entity. I would expect that normally you would want data to be in cache for longer time, so you may during request choose max-age of data you want. I would modify it like this:
1. When requesting a data, app may use some cache control options (like max-age, no-cache, no-store, only-if-cached, for eg.)
2. purge method would have option of specifying max-age (or similar), so older data would be deleted. ",c9fb7694d96b135cbc5c8e89643a60e704438315,2019-03-20 14:03:53,267354175,"@@ -0,0 +1,113 @@
+# Caching of data from ledger
+
+Currently whenever credential definitions and/or schemas is needed, it is being fetched from the ledger.
+This operation may last multiple seconds and is slowing down usage of credentials.
+Caching also enables usage of anoncreds in areas where user do not have internet coverage (eg. Using passport credential on foreign airport).
+
+## Goals and ideas
+
+* Allow users to cache credential definitions and schemas.
+  * Local wallet to be used because although this data is public, possession of some credential definition or schema reveals possession of respective credential. 
+* Provide higher level api for fetching this data so it is easier to use.
+  * Caching should be transparent to the user.
+* Enable purging of old (not needed more) data.
+  
+## Public API
+
+Note: In all calls `pool_handle` may be removed if did resolver is implemented.
+
+```Rust
+/// Gets credential definition json data for specified credential definition id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of credential definition.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_cred_def(command_handle: IndyHandle,
+                                pool_handle: IndyHandle,
+                                wallet_handle: IndyHandle,
+                                submitter_did: *const c_char,
+                                id: *const c_char,
+                                options_json: *const c_char,
+                                cb: Option<extern fn(command_handle_: IndyHandle,
+                                                     err: ErrorCode,
+                                                     cred_def_json: *const c_char)>) -> ErrorCode {
+}
+
+/// Gets schema json data for specified schema id.
+/// If data is present inside of cache, cached data is returned.
+/// Otherwise data is fetched from the ledger and stored inside of cache for future use.
+/// 
+/// #Params
+/// command_handle: command handle to map callback to caller context.
+/// pool_handle: pool handle (created by open_pool_ledger).
+/// wallet_handle: wallet handle (created by open_wallet).
+/// submitter_did: DID of the submitter stored in secured Wallet.
+/// id: identifier of schema.
+/// options_json:
+///  {
+///    forceUpdate: (optional, false by default) Force update of record in cache from the ledger,
+///  }
+/// cb: Callback that takes command result as parameter.
+#[no_mangle]
+pub extern fn indy_get_schema(command_handle: IndyHandle,
+                              pool_handle: IndyHandle,
+                              wallet_handle: IndyHandle,
+                              submitter_did: *const c_char,
+                              id: *const c_char,
+                              options_json: *const c_char,
+                              cb: Option<extern fn(command_handle_: IndyHandle,
+                                                   err: ErrorCode,
+                                                   schema_json: *const c_char)>) -> ErrorCode {
+}
+```
+
+## Storing of the data into wallet
+
+Data would be stored with specific cache type so that it is separated and easy to be managed.
+Schema_id or cred_def_id would be used for id of wallet data.
+This way data may be fetched very efficiently and also easy to be deleted when needed.
+
+## Purging the cache
+
+Several methods may be implemented for purging the cached data:
+
+#### Purge all",85,2019-03-20 14:03:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/267354175,https://github.com/hyperledger/indy-sdk/pull/1454#discussion_r267354175,dkulic
https://github.com/hyperledger/indy-sdk/pull/1452,https://github.com/hyperledger/indy-sdk/pull/1452,"I suggest to re-use file from libindy subfolder. Probably have to move it from `^/libindy/ci` to `^/ci/`
Or just keep as is and do not change buildTestEnv helper",002d12c6bb75f6673915d3991c6605690e5e2ba3,2019-02-05 11:52:22,253832628,"@@ -0,0 +1,79 @@
+FROM amazonlinux:2017.03",,2019-02-13 09:22:36,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/253832628,https://github.com/hyperledger/indy-sdk/pull/1452#discussion_r253832628,jovfer
https://github.com/hyperledger/indy-sdk/pull/1452,https://github.com/hyperledger/indy-sdk/pull/1452,I suggest to not introduce new parameter in this function. ,002d12c6bb75f6673915d3991c6605690e5e2ba3,2019-02-05 11:52:30,253832664,"@@ -509,7 +510,7 @@ def linuxVcxBuild(file, env_name, network_name) {
     }
 }
 
-def linuxModuleTesting(file, env_name, network_name, module_tester) {
+def linuxModuleTesting(file, env_name, network_name, module_tester, directory) {",,2019-02-13 09:22:36,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/253832664,https://github.com/hyperledger/indy-sdk/pull/1452#discussion_r253832664,jovfer
https://github.com/hyperledger/indy-sdk/pull/1452,https://github.com/hyperledger/indy-sdk/pull/1452,I suggest to exclude this file from Android-related PR,002d12c6bb75f6673915d3991c6605690e5e2ba3,2019-02-05 11:53:03,253832814,"@@ -0,0 +1,74 @@
+%global commit @commit@",,2019-02-13 09:22:36,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/253832814,https://github.com/hyperledger/indy-sdk/pull/1452#discussion_r253832814,jovfer
https://github.com/hyperledger/indy-sdk/pull/1452,https://github.com/hyperledger/indy-sdk/pull/1452,I suggest to exclude this file from Android-related PR,002d12c6bb75f6673915d3991c6605690e5e2ba3,2019-02-05 11:53:54,253833044,"@@ -0,0 +1,36 @@
+#!/bin/bash -xe",,2019-02-13 09:22:36,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/253833044,https://github.com/hyperledger/indy-sdk/pull/1452#discussion_r253833044,jovfer
https://github.com/hyperledger/indy-sdk/pull/1452,https://github.com/hyperledger/indy-sdk/pull/1452,I suggest to use same file for libindy and libnullpay,002d12c6bb75f6673915d3991c6605690e5e2ba3,2019-02-05 12:07:59,253837217,"@@ -0,0 +1,68 @@
+FROM ubuntu:16.04",,2019-02-13 09:22:36,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/253837217,https://github.com/hyperledger/indy-sdk/pull/1452#discussion_r253837217,jovfer
https://github.com/hyperledger/indy-sdk/pull/1452,https://github.com/hyperledger/indy-sdk/pull/1452,Is it possible to re-use similar file from libindy subdir?,002d12c6bb75f6673915d3991c6605690e5e2ba3,2019-02-05 12:08:14,253837290,"@@ -0,0 +1,225 @@
+#!/usr/bin/env bash",,2019-02-13 09:22:36,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/253837290,https://github.com/hyperledger/indy-sdk/pull/1452#discussion_r253837290,jovfer
https://github.com/hyperledger/indy-sdk/pull/1446,https://github.com/hyperledger/indy-sdk/pull/1446,AFAIR there is genesis txn file in this folder. Are we actually would like to have one more configuration?,bd7c5bd368bc57d25c0a94c4456b4cc98d72478b,2019-02-05 14:16:35,253879970,"@@ -0,0 +1,4 @@
+{""reqSignature"":{},""txn"":{""data"":{""data"":{""alias"":""Node1"",""blskey"":""4N8aUNHSgjQVgkpm8nhNEfDf6txHznoYREg9kirmJrkivgL4oSEimFF6nsQ6M41QvhM2Z33nves5vfSn9n1UwNFJBYtWVnHYMATn76vLuL3zU88KyeAYcHfsih3He6UHcXDxcaecHVz6jhCYz1P2UZn2bDVruL5wXpehgBfBaLKm3Ba"",""blskey_pop"":""RahHYiCvoNCtPTrVtP7nMC5eTYrsUA8WjXbdhNc8debh1agE9bGiJxWBXYNFbnJXoXhWFMvyqhqhRoq737YQemH5ik9oL7R4NTTCz2LEZhkgLJzB3QRQqJyBNyv7acbdHrAT8nQ9UkLbaVL9NBpnWXBTw4LEMePaSHEw66RzPNdAX1"",""client_ip"":""10.0.0.2"",""client_port"":9702,""node_ip"":""10.0.0.2"",""node_port"":9701,""services"":[""VALIDATOR""]},""dest"":""Gw6pDLhcBcoQesN72qfotTgFa7cbuqZpkX3Xo6pLhPhv""},""metadata"":{""from"":""Th7MpTaRZVRYnPiabds81Y""},""type"":""0""},""txnMetadata"":{""seqNo"":1,""txnId"":""fea82e10e894419fe2bea7d96296a6d46f50f93f9eeda954ec461b2ed2950b62""},""ver"":""1""}",,2019-02-12 09:11:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/253879970,https://github.com/hyperledger/indy-sdk/pull/1446#discussion_r253879970,jovfer
https://github.com/hyperledger/indy-sdk/pull/1446,https://github.com/hyperledger/indy-sdk/pull/1446,"You're right this extra config is not necessary, I removed it.
",bd7c5bd368bc57d25c0a94c4456b4cc98d72478b,2019-02-05 23:57:17,254094896,"@@ -0,0 +1,4 @@
+{""reqSignature"":{},""txn"":{""data"":{""data"":{""alias"":""Node1"",""blskey"":""4N8aUNHSgjQVgkpm8nhNEfDf6txHznoYREg9kirmJrkivgL4oSEimFF6nsQ6M41QvhM2Z33nves5vfSn9n1UwNFJBYtWVnHYMATn76vLuL3zU88KyeAYcHfsih3He6UHcXDxcaecHVz6jhCYz1P2UZn2bDVruL5wXpehgBfBaLKm3Ba"",""blskey_pop"":""RahHYiCvoNCtPTrVtP7nMC5eTYrsUA8WjXbdhNc8debh1agE9bGiJxWBXYNFbnJXoXhWFMvyqhqhRoq737YQemH5ik9oL7R4NTTCz2LEZhkgLJzB3QRQqJyBNyv7acbdHrAT8nQ9UkLbaVL9NBpnWXBTw4LEMePaSHEw66RzPNdAX1"",""client_ip"":""10.0.0.2"",""client_port"":9702,""node_ip"":""10.0.0.2"",""node_port"":9701,""services"":[""VALIDATOR""]},""dest"":""Gw6pDLhcBcoQesN72qfotTgFa7cbuqZpkX3Xo6pLhPhv""},""metadata"":{""from"":""Th7MpTaRZVRYnPiabds81Y""},""type"":""0""},""txnMetadata"":{""seqNo"":1,""txnId"":""fea82e10e894419fe2bea7d96296a6d46f50f93f9eeda954ec461b2ed2950b62""},""ver"":""1""}",,2019-02-12 09:11:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/254094896,https://github.com/hyperledger/indy-sdk/pull/1446#discussion_r254094896,ianco
https://github.com/hyperledger/indy-sdk/pull/1446,https://github.com/hyperledger/indy-sdk/pull/1446,"I think this file isn't needed, as it's just a copy of sample-config.json",bd7c5bd368bc57d25c0a94c4456b4cc98d72478b,2019-02-08 15:43:03,255123597,"@@ -0,0 +1,24 @@
+{",,2019-02-12 09:11:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/255123597,https://github.com/hyperledger/indy-sdk/pull/1446#discussion_r255123597,glowkey
https://github.com/hyperledger/indy-sdk/pull/1446,https://github.com/hyperledger/indy-sdk/pull/1446,"There's an instance of this in the tests for src/api/vcx.rs that hasn't been updated. (also other instances of delete_wallet and init_wallet).

Change Cargo.toml to have:

default = [""agency"",""pool_tests""]

To see the problems.",bd7c5bd368bc57d25c0a94c4456b4cc98d72478b,2019-02-08 15:45:34,255124617,"@@ -14,15 +14,14 @@ pub static mut WALLET_HANDLE: i32 = 0;
 
 pub fn get_wallet_handle() -> i32 { unsafe { WALLET_HANDLE } }
 
-pub fn create_wallet(wallet_name: &str, wallet_type: Option<&str>) -> Result<(), u32> {
+pub fn create_wallet(wallet_name: &str, wallet_type: Option<&str>, storage_config: Option<&str>, storage_creds: Option<&str>) -> Result<(), u32> {",5,2019-02-12 09:11:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/255124617,https://github.com/hyperledger/indy-sdk/pull/1446#discussion_r255124617,glowkey
https://github.com/hyperledger/indy-sdk/pull/1446,https://github.com/hyperledger/indy-sdk/pull/1446,File is removed.,bd7c5bd368bc57d25c0a94c4456b4cc98d72478b,2019-02-08 16:57:24,255154649,"@@ -0,0 +1,24 @@
+{",,2019-02-12 09:11:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/255154649,https://github.com/hyperledger/indy-sdk/pull/1446#discussion_r255154649,ianco
https://github.com/hyperledger/indy-sdk/pull/1446,https://github.com/hyperledger/indy-sdk/pull/1446,"@glowkey   thanks for the review, files are updates.
",bd7c5bd368bc57d25c0a94c4456b4cc98d72478b,2019-02-08 16:57:43,255154805,"@@ -14,15 +14,14 @@ pub static mut WALLET_HANDLE: i32 = 0;
 
 pub fn get_wallet_handle() -> i32 { unsafe { WALLET_HANDLE } }
 
-pub fn create_wallet(wallet_name: &str, wallet_type: Option<&str>) -> Result<(), u32> {
+pub fn create_wallet(wallet_name: &str, wallet_type: Option<&str>, storage_config: Option<&str>, storage_creds: Option<&str>) -> Result<(), u32> {",5,2019-02-12 09:11:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/255154805,https://github.com/hyperledger/indy-sdk/pull/1446#discussion_r255154805,ianco
https://github.com/hyperledger/indy-sdk/pull/1442,https://github.com/hyperledger/indy-sdk/pull/1442,Trace default?,330eeed2a673895f017b6ed4425cf7c1fc2d92a2,2019-02-04 17:47:48,253572334,"@@ -140,7 +140,7 @@ impl LibvcxDefaultLogger {
 
         // ensures that the test that is calling this wont fail simply because
         // the user did not set the RUST_LOG env var.
-        let pattern = Some(env::var(""RUST_LOG"").unwrap_or(""debug"".to_string()));
+        let pattern = Some(env::var(""RUST_LOG"").unwrap_or(""trace"".to_string()));",5,2019-02-04 17:52:33,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/253572334,https://github.com/hyperledger/indy-sdk/pull/1442#discussion_r253572334,hadleym
https://github.com/hyperledger/indy-sdk/pull/1442,https://github.com/hyperledger/indy-sdk/pull/1442,I'm confused on how this is an optional parameter.  I guess its no different than when we had it originally be an empty string upon creation.  Perhaps in a future iteration we require it as a parameter to create?,330eeed2a673895f017b6ed4425cf7c1fc2d92a2,2019-02-04 17:51:38,253573730,"@@ -18,7 +18,7 @@ pub struct CredentialDef {
     tag: String,
     name: String,
     source_id: String,
-    issuer_did: String,
+    issuer_did: Option<String>,",5,2019-02-04 17:52:33,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/253573730,https://github.com/hyperledger/indy-sdk/pull/1442#discussion_r253573730,hadleym
https://github.com/hyperledger/indy-sdk/pull/1442,https://github.com/hyperledger/indy-sdk/pull/1442,"Yes, this is optional. It is not required in the code and must be optional in order to not break compatibility.",330eeed2a673895f017b6ed4425cf7c1fc2d92a2,2019-02-04 17:54:23,253574819,"@@ -18,7 +18,7 @@ pub struct CredentialDef {
     tag: String,
     name: String,
     source_id: String,
-    issuer_did: String,
+    issuer_did: Option<String>,",5,2019-02-04 17:54:24,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/253574819,https://github.com/hyperledger/indy-sdk/pull/1442#discussion_r253574819,glowkey
https://github.com/hyperledger/indy-sdk/pull/1442,https://github.com/hyperledger/indy-sdk/pull/1442,"Yes, most of the vcx statements are trace so that should be the default.",330eeed2a673895f017b6ed4425cf7c1fc2d92a2,2019-02-04 17:54:25,253574830,"@@ -140,7 +140,7 @@ impl LibvcxDefaultLogger {
 
         // ensures that the test that is calling this wont fail simply because
         // the user did not set the RUST_LOG env var.
-        let pattern = Some(env::var(""RUST_LOG"").unwrap_or(""debug"".to_string()));
+        let pattern = Some(env::var(""RUST_LOG"").unwrap_or(""trace"".to_string()));",5,2019-02-04 17:54:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/253574830,https://github.com/hyperledger/indy-sdk/pull/1442#discussion_r253574830,glowkey
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,it's better to refer to the function name in Python wrapper. leave `did.key_for_did`,00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 05:42:14,251286840,"@@ -391,80 +391,113 @@ def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
     return decrypted_message
 
 
-async def pack_message(wallet_handle: int, message: str, recv_key_list: str, sender: str) -> str:
+async def pack_message(wallet_handle: int, 
+                       message: str, 
+                       recipient_verkeys: list,
+                       sender_verkey: str ) -> bytes:
     """"""
-    Packs a message (Experimental)
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    Note to use DID keys with this function you can call did.key_for_did to get key id (verkey)
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)",,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251286840,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251286840,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,should be `unpack_message`,00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 05:44:07,251287098,"@@ -391,80 +391,113 @@ def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
     return decrypted_message
 
 
-async def pack_message(wallet_handle: int, message: str, recv_key_list: str, sender: str) -> str:
+async def pack_message(wallet_handle: int, 
+                       message: str, 
+                       recipient_verkeys: list,
+                       sender_verkey: str ) -> bytes:
     """"""
-    Packs a message (Experimental)
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    Note to use DID keys with this function you can call did.key_for_did to get key id (verkey)
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
     for specific DID.
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param message: the message to be authcrypted for multiple parties
-    :param recv_key_list: a list in json format of receiver's verkeys
-    :param sender: the sender's verkey as a string When None is used in this parameter, anoncrypt is used
-    :return: a json string following the Auth or Anon AMES format
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the message being sent as a string. If it's JSON formatted it should be converted to a string
+    recipient_verkeys: a list of Strings which are recipient verkeys
+    sender_verkey: the sender's verkey as a string. -> When None is passed in this parameter, anoncrypt mode is used
+
+    returns an Agent Wire Message format as a byte array. See HIPE 0028 for detailed formats
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recv_key_list: %r, my_vk: %r"",
+    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recipient_verkeys: %r, sender_verkey: %r"",
                  wallet_handle,
                  message,
-                 recv_key_list,
-                 my_vk)
+                 recipient_verkeys,
+                 sender_verkey)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
 
     if not hasattr(pack_message, ""cb""):
         logger.debug(""pack_message: Creating callback"")
-        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_message = c_char_p(message.encode('utf-8'))
-    c_recv_key_list = c_char_p(recv_key_list.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
-
-    auth_ames = await do_call('indy_pack_message',
-                        c_wallet_handle,
-                        c_message,
-                        c_recv_key_list,
-                        c_my_vk,
-                        pack_message.cb)
-
-    auth_ames.decode()
+    msg_bytes = message.encode(""utf-8"")
+    c_msg_len = c_uint32(len(msg_bytes))
+    c_recipient_verkeys = c_char_p(json.dumps(recipient_verkeys).encode('utf-8'))
+    c_sender_vk = c_char_p(sender_verkey.encode('utf-8')) if sender_verkey is not None else None
+    res = await do_call('indy_pack_message',
+                                      c_wallet_handle,
+                                      msg_bytes,
+                                      c_msg_len,
+                                      c_recipient_verkeys,
+                                      c_sender_vk,
+                                      pack_message.cb)
     logger.debug(""pack_message: <<< res: %r"", res)
     return res
 
+async def unpack_message(wallet_handle: int,
+                        jwe: str) -> str:
 
-async def unpack_message(wallet_handle: int, ames_json: str, my_vk: str) -> (str, str):
     """"""
-    Experimental. Deserializes a AMES json string and decrypts the message returning the message and the sender's verkey if it was an AuthAMES.
-    If it is an AnonAMES it will deserialize, decrypt, and return the message with an empty sender_vk string.
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param ames_json: a json string serialized using either AuthAMES or AnonAMES
-    :param my_vk: the verkey to authcrypt with
-    :return: message: the unencrypted message
-             sender_vk: the sender's verkey if AuthAMES, else an empty string
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
+    for specific DID.
+
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the output of a pack message
+
+    #Returns -> See HIPE 0028 for details
+    (Authcrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+        ""sender_verkey"": <sender verkey used to encrypt>
+    }
+
+    (Anoncrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+    }
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""unpack_message: >>> wallet_handle: %r, ames_json: %r, my_vk: %r"",
+    logger.debug(""unpack_message: >>> wallet_handle: %r, jwe: %r"",
                  wallet_handle,
-                 ames_json,
-                 my_vk)
+                 jwe)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
+        
 
     if not hasattr(unpack_message, ""cb""):
-        logger.debug(""unpack_message: Creating callback"")
-        unpack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        logger.debug(""pack_message: Creating callback"")",,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251287098,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251287098,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,I believe better fail on decoding than return different data types,00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 05:46:59,251287444,"@@ -391,80 +391,113 @@ def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
     return decrypted_message
 
 
-async def pack_message(wallet_handle: int, message: str, recv_key_list: str, sender: str) -> str:
+async def pack_message(wallet_handle: int, 
+                       message: str, 
+                       recipient_verkeys: list,
+                       sender_verkey: str ) -> bytes:
     """"""
-    Packs a message (Experimental)
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    Note to use DID keys with this function you can call did.key_for_did to get key id (verkey)
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
     for specific DID.
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param message: the message to be authcrypted for multiple parties
-    :param recv_key_list: a list in json format of receiver's verkeys
-    :param sender: the sender's verkey as a string When None is used in this parameter, anoncrypt is used
-    :return: a json string following the Auth or Anon AMES format
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the message being sent as a string. If it's JSON formatted it should be converted to a string
+    recipient_verkeys: a list of Strings which are recipient verkeys
+    sender_verkey: the sender's verkey as a string. -> When None is passed in this parameter, anoncrypt mode is used
+
+    returns an Agent Wire Message format as a byte array. See HIPE 0028 for detailed formats
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recv_key_list: %r, my_vk: %r"",
+    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recipient_verkeys: %r, sender_verkey: %r"",
                  wallet_handle,
                  message,
-                 recv_key_list,
-                 my_vk)
+                 recipient_verkeys,
+                 sender_verkey)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
 
     if not hasattr(pack_message, ""cb""):
         logger.debug(""pack_message: Creating callback"")
-        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_message = c_char_p(message.encode('utf-8'))
-    c_recv_key_list = c_char_p(recv_key_list.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
-
-    auth_ames = await do_call('indy_pack_message',
-                        c_wallet_handle,
-                        c_message,
-                        c_recv_key_list,
-                        c_my_vk,
-                        pack_message.cb)
-
-    auth_ames.decode()
+    msg_bytes = message.encode(""utf-8"")
+    c_msg_len = c_uint32(len(msg_bytes))
+    c_recipient_verkeys = c_char_p(json.dumps(recipient_verkeys).encode('utf-8'))
+    c_sender_vk = c_char_p(sender_verkey.encode('utf-8')) if sender_verkey is not None else None
+    res = await do_call('indy_pack_message',
+                                      c_wallet_handle,
+                                      msg_bytes,
+                                      c_msg_len,
+                                      c_recipient_verkeys,
+                                      c_sender_vk,
+                                      pack_message.cb)
     logger.debug(""pack_message: <<< res: %r"", res)
     return res
 
+async def unpack_message(wallet_handle: int,
+                        jwe: str) -> str:
 
-async def unpack_message(wallet_handle: int, ames_json: str, my_vk: str) -> (str, str):
     """"""
-    Experimental. Deserializes a AMES json string and decrypts the message returning the message and the sender's verkey if it was an AuthAMES.
-    If it is an AnonAMES it will deserialize, decrypt, and return the message with an empty sender_vk string.
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param ames_json: a json string serialized using either AuthAMES or AnonAMES
-    :param my_vk: the verkey to authcrypt with
-    :return: message: the unencrypted message
-             sender_vk: the sender's verkey if AuthAMES, else an empty string
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
+    for specific DID.
+
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the output of a pack message
+
+    #Returns -> See HIPE 0028 for details
+    (Authcrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+        ""sender_verkey"": <sender verkey used to encrypt>
+    }
+
+    (Anoncrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+    }
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""unpack_message: >>> wallet_handle: %r, ames_json: %r, my_vk: %r"",
+    logger.debug(""unpack_message: >>> wallet_handle: %r, jwe: %r"",
                  wallet_handle,
-                 ames_json,
-                 my_vk)
+                 jwe)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
+        
 
     if not hasattr(unpack_message, ""cb""):
-        logger.debug(""unpack_message: Creating callback"")
-        unpack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        logger.debug(""pack_message: Creating callback"")
+        unpack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_ames_json = c_char_p(ames_json.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
-
-    message, sender_vk = await do_call('indy_unpack_messasge',
-                                       c_wallet_handle,
-                                       c_ames_json,
-                                       c_my_vk,
-                                       unpack_message.cb)
+    c_jwe_len = c_uint32(len(jwe))
+    unpack_message_bytes = await do_call('indy_unpack_message',
+                                         c_wallet_handle,
+                                         jwe,
+                                         c_jwe_len,
+                                         unpack_message.cb)
+
+    try:
+        unpack_message_str = unpack_message_bytes.decode('utf-8', 'strict')
+    except UnicodeDecodeError:
+        logger.debug(""unpack_message: wrapper decode error <<< res: %r"", unpack_message_bytes)
+        return unpack_message_bytes",,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251287444,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251287444,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,should be `unpack_message_str` as formatting value,00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 05:47:41,251287528,"@@ -391,80 +391,113 @@ def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
     return decrypted_message
 
 
-async def pack_message(wallet_handle: int, message: str, recv_key_list: str, sender: str) -> str:
+async def pack_message(wallet_handle: int, 
+                       message: str, 
+                       recipient_verkeys: list,
+                       sender_verkey: str ) -> bytes:
     """"""
-    Packs a message (Experimental)
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    Note to use DID keys with this function you can call did.key_for_did to get key id (verkey)
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
     for specific DID.
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param message: the message to be authcrypted for multiple parties
-    :param recv_key_list: a list in json format of receiver's verkeys
-    :param sender: the sender's verkey as a string When None is used in this parameter, anoncrypt is used
-    :return: a json string following the Auth or Anon AMES format
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the message being sent as a string. If it's JSON formatted it should be converted to a string
+    recipient_verkeys: a list of Strings which are recipient verkeys
+    sender_verkey: the sender's verkey as a string. -> When None is passed in this parameter, anoncrypt mode is used
+
+    returns an Agent Wire Message format as a byte array. See HIPE 0028 for detailed formats
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recv_key_list: %r, my_vk: %r"",
+    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recipient_verkeys: %r, sender_verkey: %r"",
                  wallet_handle,
                  message,
-                 recv_key_list,
-                 my_vk)
+                 recipient_verkeys,
+                 sender_verkey)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
 
     if not hasattr(pack_message, ""cb""):
         logger.debug(""pack_message: Creating callback"")
-        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_message = c_char_p(message.encode('utf-8'))
-    c_recv_key_list = c_char_p(recv_key_list.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
-
-    auth_ames = await do_call('indy_pack_message',
-                        c_wallet_handle,
-                        c_message,
-                        c_recv_key_list,
-                        c_my_vk,
-                        pack_message.cb)
-
-    auth_ames.decode()
+    msg_bytes = message.encode(""utf-8"")
+    c_msg_len = c_uint32(len(msg_bytes))
+    c_recipient_verkeys = c_char_p(json.dumps(recipient_verkeys).encode('utf-8'))
+    c_sender_vk = c_char_p(sender_verkey.encode('utf-8')) if sender_verkey is not None else None
+    res = await do_call('indy_pack_message',
+                                      c_wallet_handle,
+                                      msg_bytes,
+                                      c_msg_len,
+                                      c_recipient_verkeys,
+                                      c_sender_vk,
+                                      pack_message.cb)
     logger.debug(""pack_message: <<< res: %r"", res)
     return res
 
+async def unpack_message(wallet_handle: int,
+                        jwe: str) -> str:
 
-async def unpack_message(wallet_handle: int, ames_json: str, my_vk: str) -> (str, str):
     """"""
-    Experimental. Deserializes a AMES json string and decrypts the message returning the message and the sender's verkey if it was an AuthAMES.
-    If it is an AnonAMES it will deserialize, decrypt, and return the message with an empty sender_vk string.
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param ames_json: a json string serialized using either AuthAMES or AnonAMES
-    :param my_vk: the verkey to authcrypt with
-    :return: message: the unencrypted message
-             sender_vk: the sender's verkey if AuthAMES, else an empty string
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
+    for specific DID.
+
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the output of a pack message
+
+    #Returns -> See HIPE 0028 for details
+    (Authcrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+        ""sender_verkey"": <sender verkey used to encrypt>
+    }
+
+    (Anoncrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+    }
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""unpack_message: >>> wallet_handle: %r, ames_json: %r, my_vk: %r"",
+    logger.debug(""unpack_message: >>> wallet_handle: %r, jwe: %r"",
                  wallet_handle,
-                 ames_json,
-                 my_vk)
+                 jwe)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
+        
 
     if not hasattr(unpack_message, ""cb""):
-        logger.debug(""unpack_message: Creating callback"")
-        unpack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        logger.debug(""pack_message: Creating callback"")
+        unpack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_ames_json = c_char_p(ames_json.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
-
-    message, sender_vk = await do_call('indy_unpack_messasge',
-                                       c_wallet_handle,
-                                       c_ames_json,
-                                       c_my_vk,
-                                       unpack_message.cb)
+    c_jwe_len = c_uint32(len(jwe))
+    unpack_message_bytes = await do_call('indy_unpack_message',
+                                         c_wallet_handle,
+                                         jwe,
+                                         c_jwe_len,
+                                         unpack_message.cb)
+
+    try:
+        unpack_message_str = unpack_message_bytes.decode('utf-8', 'strict')
+    except UnicodeDecodeError:
+        logger.debug(""unpack_message: wrapper decode error <<< res: %r"", unpack_message_bytes)
+        return unpack_message_bytes
+
+    logger.debug(""unpack_message: <<< res: %r"", unpack_message)",,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251287528,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251287528,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,"you can use `identity_my1` fixture here
`
async def test_pack_message_authcrypt_works(wallet_handle, identity_my1, verkey_my2, pack_message):
sender_verkey, _ = identity_my1
`",00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 05:52:11,251288139,"@@ -0,0 +1,56 @@
+import json
+import pytest
+import asyncio
+
+from indy import IndyError
+from indy import crypto, did
+
+from indy.error import ErrorCode
+
+@pytest.mark.asyncio
+async def test_pack_message_authcrypt_works(wallet_handle, seed_my1, verkey_my2, pack_message):
+    sender_verkey = await did.create_key(wallet_handle, json.dumps({'seed': seed_my1}))",,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251288139,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251288139,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,you use `pack_message` fixture as a message in the previous test,00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 05:54:38,251288434,"@@ -0,0 +1,56 @@
+import json
+import pytest
+import asyncio
+
+from indy import IndyError
+from indy import crypto, did
+
+from indy.error import ErrorCode
+
+@pytest.mark.asyncio
+async def test_pack_message_authcrypt_works(wallet_handle, seed_my1, verkey_my2, pack_message):
+    sender_verkey = await did.create_key(wallet_handle, json.dumps({'seed': seed_my1}))
+    receiver_verkeys = [verkey_my2]
+    packed_message_bytes = await crypto.pack_message(wallet_handle, pack_message, receiver_verkeys, sender_verkey)
+    packed_message_json = packed_message_bytes.decode(""utf-8"")
+    json_message = json.loads(packed_message_json)
+    assert json_message['protected'] != """"
+    assert json_message['tag'] != """"
+    assert json_message['ciphertext'] != """"
+    assert json_message['iv'] != """"
+
+@pytest.mark.asyncio
+async def test_pack_message_anoncrypt_works(wallet_handle, verkey_my2):
+    receiver_verkeys = [verkey_my2]
+    packed_message_bytes = await crypto.pack_message(wallet_handle, ""pack_message"", receiver_verkeys, None)",,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251288434,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251288434,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,`assert json_message['protected']` gives the same result,00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 05:56:42,251288663,"@@ -0,0 +1,56 @@
+import json
+import pytest
+import asyncio
+
+from indy import IndyError
+from indy import crypto, did
+
+from indy.error import ErrorCode
+
+@pytest.mark.asyncio
+async def test_pack_message_authcrypt_works(wallet_handle, seed_my1, verkey_my2, pack_message):
+    sender_verkey = await did.create_key(wallet_handle, json.dumps({'seed': seed_my1}))
+    receiver_verkeys = [verkey_my2]
+    packed_message_bytes = await crypto.pack_message(wallet_handle, pack_message, receiver_verkeys, sender_verkey)
+    packed_message_json = packed_message_bytes.decode(""utf-8"")
+    json_message = json.loads(packed_message_json)
+    assert json_message['protected'] != """"",,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251288663,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251288663,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,remove print,00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 05:57:02,251288732,"@@ -0,0 +1,56 @@
+import json
+import pytest
+import asyncio
+
+from indy import IndyError
+from indy import crypto, did
+
+from indy.error import ErrorCode
+
+@pytest.mark.asyncio
+async def test_pack_message_authcrypt_works(wallet_handle, seed_my1, verkey_my2, pack_message):
+    sender_verkey = await did.create_key(wallet_handle, json.dumps({'seed': seed_my1}))
+    receiver_verkeys = [verkey_my2]
+    packed_message_bytes = await crypto.pack_message(wallet_handle, pack_message, receiver_verkeys, sender_verkey)
+    packed_message_json = packed_message_bytes.decode(""utf-8"")
+    json_message = json.loads(packed_message_json)
+    assert json_message['protected'] != """"
+    assert json_message['tag'] != """"
+    assert json_message['ciphertext'] != """"
+    assert json_message['iv'] != """"
+
+@pytest.mark.asyncio
+async def test_pack_message_anoncrypt_works(wallet_handle, verkey_my2):
+    receiver_verkeys = [verkey_my2]
+    packed_message_bytes = await crypto.pack_message(wallet_handle, ""pack_message"", receiver_verkeys, None)
+    packed_message_json = packed_message_bytes.decode(""utf-8"")
+    json_message = json.loads(packed_message_json)
+    print(json_message)",,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251288732,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251288732,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,"please check `test_pack_message_invalid_verkey`, `test_pack_message_invalid_receiver_verkey` and `test_pack_message_invalid_wallet_handle` tests
they are looks strange ",00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 06:00:25,251289441,"@@ -0,0 +1,56 @@
+import json
+import pytest
+import asyncio
+
+from indy import IndyError
+from indy import crypto, did
+
+from indy.error import ErrorCode
+
+@pytest.mark.asyncio
+async def test_pack_message_authcrypt_works(wallet_handle, seed_my1, verkey_my2, pack_message):
+    sender_verkey = await did.create_key(wallet_handle, json.dumps({'seed': seed_my1}))
+    receiver_verkeys = [verkey_my2]
+    packed_message_bytes = await crypto.pack_message(wallet_handle, pack_message, receiver_verkeys, sender_verkey)
+    packed_message_json = packed_message_bytes.decode(""utf-8"")
+    json_message = json.loads(packed_message_json)
+    assert json_message['protected'] != """"
+    assert json_message['tag'] != """"
+    assert json_message['ciphertext'] != """"
+    assert json_message['iv'] != """"
+
+@pytest.mark.asyncio
+async def test_pack_message_anoncrypt_works(wallet_handle, verkey_my2):
+    receiver_verkeys = [verkey_my2]
+    packed_message_bytes = await crypto.pack_message(wallet_handle, ""pack_message"", receiver_verkeys, None)
+    packed_message_json = packed_message_bytes.decode(""utf-8"")
+    json_message = json.loads(packed_message_json)
+    print(json_message)
+    assert json_message['protected'] != """"
+    assert json_message['tag'] != """"
+    assert json_message['ciphertext'] != """"
+    assert json_message['iv'] != """"
+
+@pytest.mark.asyncio
+async def test_pack_message_invalid_verkey(wallet_handle, verkey_my2):
+    sender_verkey = ""INVALID""
+    receiver_verkeys = [verkey_my2]
+    with pytest.raises(IndyError) as e:
+        pack_message = await crypto.pack_message(wallet_handle, ""pack_message"", receiver_verkeys, ""Invalid_VERKEY"")
+    assert ErrorCode.WalletItemNotFound == e.value.error_code",38,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251289441,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251289441,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,use `identity_my` and `identity_steward1` instead,00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 06:01:43,251289576,"@@ -0,0 +1,54 @@
+import json
+import pytest
+import asyncio
+
+from indy import IndyError
+from indy import crypto, did, wallet
+
+from indy.error import ErrorCode
+
+@pytest.mark.asyncio
+async def test_pack_message_and_unpack_message_authcrypt_works(wallet_handle, seed_steward1, seed_my1, pack_message):
+    #setup keys
+    sender_vk = await did.create_key(wallet_handle, json.dumps({'seed': seed_my1}))
+    steward_vk = await did.create_key(wallet_handle, json.dumps({'seed': seed_steward1}))",,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251289576,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251289576,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,"why do you do `decode('utf-8', 'strict')` on result of `unpack_message` but don't on result of `pack_message`?",00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 06:04:51,251289902,"@@ -391,80 +391,113 @@ def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
     return decrypted_message
 
 
-async def pack_message(wallet_handle: int, message: str, recv_key_list: str, sender: str) -> str:
+async def pack_message(wallet_handle: int, 
+                       message: str, 
+                       recipient_verkeys: list,
+                       sender_verkey: str ) -> bytes:
     """"""
-    Packs a message (Experimental)
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    Note to use DID keys with this function you can call did.key_for_did to get key id (verkey)
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
     for specific DID.
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param message: the message to be authcrypted for multiple parties
-    :param recv_key_list: a list in json format of receiver's verkeys
-    :param sender: the sender's verkey as a string When None is used in this parameter, anoncrypt is used
-    :return: a json string following the Auth or Anon AMES format
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the message being sent as a string. If it's JSON formatted it should be converted to a string
+    recipient_verkeys: a list of Strings which are recipient verkeys
+    sender_verkey: the sender's verkey as a string. -> When None is passed in this parameter, anoncrypt mode is used
+
+    returns an Agent Wire Message format as a byte array. See HIPE 0028 for detailed formats
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recv_key_list: %r, my_vk: %r"",
+    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recipient_verkeys: %r, sender_verkey: %r"",
                  wallet_handle,
                  message,
-                 recv_key_list,
-                 my_vk)
+                 recipient_verkeys,
+                 sender_verkey)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
 
     if not hasattr(pack_message, ""cb""):
         logger.debug(""pack_message: Creating callback"")
-        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_message = c_char_p(message.encode('utf-8'))
-    c_recv_key_list = c_char_p(recv_key_list.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
-
-    auth_ames = await do_call('indy_pack_message',
-                        c_wallet_handle,
-                        c_message,
-                        c_recv_key_list,
-                        c_my_vk,
-                        pack_message.cb)
-
-    auth_ames.decode()
+    msg_bytes = message.encode(""utf-8"")
+    c_msg_len = c_uint32(len(msg_bytes))
+    c_recipient_verkeys = c_char_p(json.dumps(recipient_verkeys).encode('utf-8'))
+    c_sender_vk = c_char_p(sender_verkey.encode('utf-8')) if sender_verkey is not None else None
+    res = await do_call('indy_pack_message',
+                                      c_wallet_handle,
+                                      msg_bytes,
+                                      c_msg_len,
+                                      c_recipient_verkeys,
+                                      c_sender_vk,
+                                      pack_message.cb)
     logger.debug(""pack_message: <<< res: %r"", res)
     return res
 
+async def unpack_message(wallet_handle: int,
+                        jwe: str) -> str:
 
-async def unpack_message(wallet_handle: int, ames_json: str, my_vk: str) -> (str, str):
     """"""
-    Experimental. Deserializes a AMES json string and decrypts the message returning the message and the sender's verkey if it was an AuthAMES.
-    If it is an AnonAMES it will deserialize, decrypt, and return the message with an empty sender_vk string.
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param ames_json: a json string serialized using either AuthAMES or AnonAMES
-    :param my_vk: the verkey to authcrypt with
-    :return: message: the unencrypted message
-             sender_vk: the sender's verkey if AuthAMES, else an empty string
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
+    for specific DID.
+
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the output of a pack message
+
+    #Returns -> See HIPE 0028 for details
+    (Authcrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+        ""sender_verkey"": <sender verkey used to encrypt>
+    }
+
+    (Anoncrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+    }
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""unpack_message: >>> wallet_handle: %r, ames_json: %r, my_vk: %r"",
+    logger.debug(""unpack_message: >>> wallet_handle: %r, jwe: %r"",
                  wallet_handle,
-                 ames_json,
-                 my_vk)
+                 jwe)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
+        
 
     if not hasattr(unpack_message, ""cb""):
-        logger.debug(""unpack_message: Creating callback"")
-        unpack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        logger.debug(""pack_message: Creating callback"")
+        unpack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_ames_json = c_char_p(ames_json.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
-
-    message, sender_vk = await do_call('indy_unpack_messasge',
-                                       c_wallet_handle,
-                                       c_ames_json,
-                                       c_my_vk,
-                                       unpack_message.cb)
+    c_jwe_len = c_uint32(len(jwe))
+    unpack_message_bytes = await do_call('indy_unpack_message',
+                                         c_wallet_handle,
+                                         jwe,
+                                         c_jwe_len,
+                                         unpack_message.cb)
+
+    try:
+        unpack_message_str = unpack_message_bytes.decode('utf-8', 'strict')",,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251289902,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251289902,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,same result as what? I'm not sure I understand.,00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 06:25:27,251292736,"@@ -0,0 +1,56 @@
+import json
+import pytest
+import asyncio
+
+from indy import IndyError
+from indy import crypto, did
+
+from indy.error import ErrorCode
+
+@pytest.mark.asyncio
+async def test_pack_message_authcrypt_works(wallet_handle, seed_my1, verkey_my2, pack_message):
+    sender_verkey = await did.create_key(wallet_handle, json.dumps({'seed': seed_my1}))
+    receiver_verkeys = [verkey_my2]
+    packed_message_bytes = await crypto.pack_message(wallet_handle, pack_message, receiver_verkeys, sender_verkey)
+    packed_message_json = packed_message_bytes.decode(""utf-8"")
+    json_message = json.loads(packed_message_json)
+    assert json_message['protected'] != """"",,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251292736,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251292736,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,I agree with this conclusion. I'll return the error rather than return a different type.,00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 06:36:10,251294336,"@@ -391,80 +391,113 @@ def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
     return decrypted_message
 
 
-async def pack_message(wallet_handle: int, message: str, recv_key_list: str, sender: str) -> str:
+async def pack_message(wallet_handle: int, 
+                       message: str, 
+                       recipient_verkeys: list,
+                       sender_verkey: str ) -> bytes:
     """"""
-    Packs a message (Experimental)
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    Note to use DID keys with this function you can call did.key_for_did to get key id (verkey)
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
     for specific DID.
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param message: the message to be authcrypted for multiple parties
-    :param recv_key_list: a list in json format of receiver's verkeys
-    :param sender: the sender's verkey as a string When None is used in this parameter, anoncrypt is used
-    :return: a json string following the Auth or Anon AMES format
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the message being sent as a string. If it's JSON formatted it should be converted to a string
+    recipient_verkeys: a list of Strings which are recipient verkeys
+    sender_verkey: the sender's verkey as a string. -> When None is passed in this parameter, anoncrypt mode is used
+
+    returns an Agent Wire Message format as a byte array. See HIPE 0028 for detailed formats
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recv_key_list: %r, my_vk: %r"",
+    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recipient_verkeys: %r, sender_verkey: %r"",
                  wallet_handle,
                  message,
-                 recv_key_list,
-                 my_vk)
+                 recipient_verkeys,
+                 sender_verkey)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
 
     if not hasattr(pack_message, ""cb""):
         logger.debug(""pack_message: Creating callback"")
-        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_message = c_char_p(message.encode('utf-8'))
-    c_recv_key_list = c_char_p(recv_key_list.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
-
-    auth_ames = await do_call('indy_pack_message',
-                        c_wallet_handle,
-                        c_message,
-                        c_recv_key_list,
-                        c_my_vk,
-                        pack_message.cb)
-
-    auth_ames.decode()
+    msg_bytes = message.encode(""utf-8"")
+    c_msg_len = c_uint32(len(msg_bytes))
+    c_recipient_verkeys = c_char_p(json.dumps(recipient_verkeys).encode('utf-8'))
+    c_sender_vk = c_char_p(sender_verkey.encode('utf-8')) if sender_verkey is not None else None
+    res = await do_call('indy_pack_message',
+                                      c_wallet_handle,
+                                      msg_bytes,
+                                      c_msg_len,
+                                      c_recipient_verkeys,
+                                      c_sender_vk,
+                                      pack_message.cb)
     logger.debug(""pack_message: <<< res: %r"", res)
     return res
 
+async def unpack_message(wallet_handle: int,
+                        jwe: str) -> str:
 
-async def unpack_message(wallet_handle: int, ames_json: str, my_vk: str) -> (str, str):
     """"""
-    Experimental. Deserializes a AMES json string and decrypts the message returning the message and the sender's verkey if it was an AuthAMES.
-    If it is an AnonAMES it will deserialize, decrypt, and return the message with an empty sender_vk string.
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param ames_json: a json string serialized using either AuthAMES or AnonAMES
-    :param my_vk: the verkey to authcrypt with
-    :return: message: the unencrypted message
-             sender_vk: the sender's verkey if AuthAMES, else an empty string
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
+    for specific DID.
+
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the output of a pack message
+
+    #Returns -> See HIPE 0028 for details
+    (Authcrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+        ""sender_verkey"": <sender verkey used to encrypt>
+    }
+
+    (Anoncrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+    }
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""unpack_message: >>> wallet_handle: %r, ames_json: %r, my_vk: %r"",
+    logger.debug(""unpack_message: >>> wallet_handle: %r, jwe: %r"",
                  wallet_handle,
-                 ames_json,
-                 my_vk)
+                 jwe)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
+        
 
     if not hasattr(unpack_message, ""cb""):
-        logger.debug(""unpack_message: Creating callback"")
-        unpack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        logger.debug(""pack_message: Creating callback"")
+        unpack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_ames_json = c_char_p(ames_json.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
-
-    message, sender_vk = await do_call('indy_unpack_messasge',
-                                       c_wallet_handle,
-                                       c_ames_json,
-                                       c_my_vk,
-                                       unpack_message.cb)
+    c_jwe_len = c_uint32(len(jwe))
+    unpack_message_bytes = await do_call('indy_unpack_message',
+                                         c_wallet_handle,
+                                         jwe,
+                                         c_jwe_len,
+                                         unpack_message.cb)
+
+    try:
+        unpack_message_str = unpack_message_bytes.decode('utf-8', 'strict')
+    except UnicodeDecodeError:
+        logger.debug(""unpack_message: wrapper decode error <<< res: %r"", unpack_message_bytes)
+        return unpack_message_bytes",,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251294336,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251294336,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,"`assert json_message['protected']` and `assert json_message['protected'] != """"` ",00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 06:36:20,251294365,"@@ -0,0 +1,56 @@
+import json
+import pytest
+import asyncio
+
+from indy import IndyError
+from indy import crypto, did
+
+from indy.error import ErrorCode
+
+@pytest.mark.asyncio
+async def test_pack_message_authcrypt_works(wallet_handle, seed_my1, verkey_my2, pack_message):
+    sender_verkey = await did.create_key(wallet_handle, json.dumps({'seed': seed_my1}))
+    receiver_verkeys = [verkey_my2]
+    packed_message_bytes = await crypto.pack_message(wallet_handle, pack_message, receiver_verkeys, sender_verkey)
+    packed_message_json = packed_message_bytes.decode(""utf-8"")
+    json_message = json.loads(packed_message_json)
+    assert json_message['protected'] != """"",,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251294365,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251294365,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,I've updated this to have correct parameters except the part that should cause the error. This will make it easier to understand the test. Is that what looked strange or was it something else?,00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 06:40:59,251294993,"@@ -0,0 +1,56 @@
+import json
+import pytest
+import asyncio
+
+from indy import IndyError
+from indy import crypto, did
+
+from indy.error import ErrorCode
+
+@pytest.mark.asyncio
+async def test_pack_message_authcrypt_works(wallet_handle, seed_my1, verkey_my2, pack_message):
+    sender_verkey = await did.create_key(wallet_handle, json.dumps({'seed': seed_my1}))
+    receiver_verkeys = [verkey_my2]
+    packed_message_bytes = await crypto.pack_message(wallet_handle, pack_message, receiver_verkeys, sender_verkey)
+    packed_message_json = packed_message_bytes.decode(""utf-8"")
+    json_message = json.loads(packed_message_json)
+    assert json_message['protected'] != """"
+    assert json_message['tag'] != """"
+    assert json_message['ciphertext'] != """"
+    assert json_message['iv'] != """"
+
+@pytest.mark.asyncio
+async def test_pack_message_anoncrypt_works(wallet_handle, verkey_my2):
+    receiver_verkeys = [verkey_my2]
+    packed_message_bytes = await crypto.pack_message(wallet_handle, ""pack_message"", receiver_verkeys, None)
+    packed_message_json = packed_message_bytes.decode(""utf-8"")
+    json_message = json.loads(packed_message_json)
+    print(json_message)
+    assert json_message['protected'] != """"
+    assert json_message['tag'] != """"
+    assert json_message['ciphertext'] != """"
+    assert json_message['iv'] != """"
+
+@pytest.mark.asyncio
+async def test_pack_message_invalid_verkey(wallet_handle, verkey_my2):
+    sender_verkey = ""INVALID""
+    receiver_verkeys = [verkey_my2]
+    with pytest.raises(IndyError) as e:
+        pack_message = await crypto.pack_message(wallet_handle, ""pack_message"", receiver_verkeys, ""Invalid_VERKEY"")
+    assert ErrorCode.WalletItemNotFound == e.value.error_code",38,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251294993,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251294993,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,"pack_message does not assume the type of encoding that will be used by the consumer because it doesn't assume the transport layer used. For example, in an HTTP Request, a JSON object can be put directly into the body of the request. However, if the transport layer is a URL then it should be base64URL encoded. However, in unpack_message it can be assumed that the API consumer will be processing the JSON object returned. In this case, we are assuming that the language will process JSON based on a specific type (string in Python) in which case we can handle the encoding for the consumer and adhere to the DRY principle.

For consistency sake, I believe it should be the same across all APIs, so we should update the rust, .NET (PR #1437) and Java wrapper. Additionally, my first pass on the nodejs wrapper will need some help too (PR incoming).   ",00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 06:45:08,251295554,"@@ -391,80 +391,113 @@ def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
     return decrypted_message
 
 
-async def pack_message(wallet_handle: int, message: str, recv_key_list: str, sender: str) -> str:
+async def pack_message(wallet_handle: int, 
+                       message: str, 
+                       recipient_verkeys: list,
+                       sender_verkey: str ) -> bytes:
     """"""
-    Packs a message (Experimental)
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    Note to use DID keys with this function you can call did.key_for_did to get key id (verkey)
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
     for specific DID.
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param message: the message to be authcrypted for multiple parties
-    :param recv_key_list: a list in json format of receiver's verkeys
-    :param sender: the sender's verkey as a string When None is used in this parameter, anoncrypt is used
-    :return: a json string following the Auth or Anon AMES format
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the message being sent as a string. If it's JSON formatted it should be converted to a string
+    recipient_verkeys: a list of Strings which are recipient verkeys
+    sender_verkey: the sender's verkey as a string. -> When None is passed in this parameter, anoncrypt mode is used
+
+    returns an Agent Wire Message format as a byte array. See HIPE 0028 for detailed formats
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recv_key_list: %r, my_vk: %r"",
+    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recipient_verkeys: %r, sender_verkey: %r"",
                  wallet_handle,
                  message,
-                 recv_key_list,
-                 my_vk)
+                 recipient_verkeys,
+                 sender_verkey)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
 
     if not hasattr(pack_message, ""cb""):
         logger.debug(""pack_message: Creating callback"")
-        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_message = c_char_p(message.encode('utf-8'))
-    c_recv_key_list = c_char_p(recv_key_list.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
-
-    auth_ames = await do_call('indy_pack_message',
-                        c_wallet_handle,
-                        c_message,
-                        c_recv_key_list,
-                        c_my_vk,
-                        pack_message.cb)
-
-    auth_ames.decode()
+    msg_bytes = message.encode(""utf-8"")
+    c_msg_len = c_uint32(len(msg_bytes))
+    c_recipient_verkeys = c_char_p(json.dumps(recipient_verkeys).encode('utf-8'))
+    c_sender_vk = c_char_p(sender_verkey.encode('utf-8')) if sender_verkey is not None else None
+    res = await do_call('indy_pack_message',
+                                      c_wallet_handle,
+                                      msg_bytes,
+                                      c_msg_len,
+                                      c_recipient_verkeys,
+                                      c_sender_vk,
+                                      pack_message.cb)
     logger.debug(""pack_message: <<< res: %r"", res)
     return res
 
+async def unpack_message(wallet_handle: int,
+                        jwe: str) -> str:
 
-async def unpack_message(wallet_handle: int, ames_json: str, my_vk: str) -> (str, str):
     """"""
-    Experimental. Deserializes a AMES json string and decrypts the message returning the message and the sender's verkey if it was an AuthAMES.
-    If it is an AnonAMES it will deserialize, decrypt, and return the message with an empty sender_vk string.
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param ames_json: a json string serialized using either AuthAMES or AnonAMES
-    :param my_vk: the verkey to authcrypt with
-    :return: message: the unencrypted message
-             sender_vk: the sender's verkey if AuthAMES, else an empty string
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
+    for specific DID.
+
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the output of a pack message
+
+    #Returns -> See HIPE 0028 for details
+    (Authcrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+        ""sender_verkey"": <sender verkey used to encrypt>
+    }
+
+    (Anoncrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+    }
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""unpack_message: >>> wallet_handle: %r, ames_json: %r, my_vk: %r"",
+    logger.debug(""unpack_message: >>> wallet_handle: %r, jwe: %r"",
                  wallet_handle,
-                 ames_json,
-                 my_vk)
+                 jwe)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
+        
 
     if not hasattr(unpack_message, ""cb""):
-        logger.debug(""unpack_message: Creating callback"")
-        unpack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        logger.debug(""pack_message: Creating callback"")
+        unpack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_ames_json = c_char_p(ames_json.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
-
-    message, sender_vk = await do_call('indy_unpack_messasge',
-                                       c_wallet_handle,
-                                       c_ames_json,
-                                       c_my_vk,
-                                       unpack_message.cb)
+    c_jwe_len = c_uint32(len(jwe))
+    unpack_message_bytes = await do_call('indy_unpack_message',
+                                         c_wallet_handle,
+                                         jwe,
+                                         c_jwe_len,
+                                         unpack_message.cb)
+
+    try:
+        unpack_message_str = unpack_message_bytes.decode('utf-8', 'strict')",,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251295554,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251295554,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,"just leave  `unpack_message_bytes.decode('utf-8', 'strict')`
it doesn't make sense
`
    except UnicodeDecodeError:
        return UnicodeDecodeError
`
",00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 07:04:44,251298862,"@@ -391,80 +391,112 @@ def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
     return decrypted_message
 
 
-async def pack_message(wallet_handle: int, message: str, recv_key_list: str, sender: str) -> str:
+async def pack_message(wallet_handle: int, 
+                       message: str, 
+                       recipient_verkeys: list,
+                       sender_verkey: str ) -> bytes:
     """"""
-    Packs a message (Experimental)
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
     Note to use DID keys with this function you can call did.key_for_did to get key id (verkey)
     for specific DID.
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param message: the message to be authcrypted for multiple parties
-    :param recv_key_list: a list in json format of receiver's verkeys
-    :param sender: the sender's verkey as a string When None is used in this parameter, anoncrypt is used
-    :return: a json string following the Auth or Anon AMES format
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the message being sent as a string. If it's JSON formatted it should be converted to a string
+    recipient_verkeys: a list of Strings which are recipient verkeys
+    sender_verkey: the sender's verkey as a string. -> When None is passed in this parameter, anoncrypt mode is used
+
+    returns an Agent Wire Message format as a byte array. See HIPE 0028 for detailed formats
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recv_key_list: %r, my_vk: %r"",
+    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recipient_verkeys: %r, sender_verkey: %r"",
                  wallet_handle,
                  message,
-                 recv_key_list,
-                 my_vk)
+                 recipient_verkeys,
+                 sender_verkey)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
 
     if not hasattr(pack_message, ""cb""):
         logger.debug(""pack_message: Creating callback"")
-        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_message = c_char_p(message.encode('utf-8'))
-    c_recv_key_list = c_char_p(recv_key_list.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
-
-    auth_ames = await do_call('indy_pack_message',
-                        c_wallet_handle,
-                        c_message,
-                        c_recv_key_list,
-                        c_my_vk,
-                        pack_message.cb)
-
-    auth_ames.decode()
+    msg_bytes = message.encode(""utf-8"")
+    c_msg_len = c_uint32(len(msg_bytes))
+    c_recipient_verkeys = c_char_p(json.dumps(recipient_verkeys).encode('utf-8'))
+    c_sender_vk = c_char_p(sender_verkey.encode('utf-8')) if sender_verkey is not None else None
+    res = await do_call('indy_pack_message',
+                                      c_wallet_handle,
+                                      msg_bytes,
+                                      c_msg_len,
+                                      c_recipient_verkeys,
+                                      c_sender_vk,
+                                      pack_message.cb)
     logger.debug(""pack_message: <<< res: %r"", res)
     return res
 
+async def unpack_message(wallet_handle: int,
+                        jwe: str) -> str:
 
-async def unpack_message(wallet_handle: int, ames_json: str, my_vk: str) -> (str, str):
     """"""
-    Experimental. Deserializes a AMES json string and decrypts the message returning the message and the sender's verkey if it was an AuthAMES.
-    If it is an AnonAMES it will deserialize, decrypt, and return the message with an empty sender_vk string.
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param ames_json: a json string serialized using either AuthAMES or AnonAMES
-    :param my_vk: the verkey to authcrypt with
-    :return: message: the unencrypted message
-             sender_vk: the sender's verkey if AuthAMES, else an empty string
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
+    for specific DID.
+
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the output of a pack message
+
+    #Returns -> See HIPE 0028 for details
+    (Authcrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+        ""sender_verkey"": <sender verkey used to encrypt>
+    }
+
+    (Anoncrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+    }
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""unpack_message: >>> wallet_handle: %r, ames_json: %r, my_vk: %r"",
+    logger.debug(""unpack_message: >>> wallet_handle: %r, jwe: %r"",
                  wallet_handle,
-                 ames_json,
-                 my_vk)
+                 jwe)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
+        
 
     if not hasattr(unpack_message, ""cb""):
         logger.debug(""unpack_message: Creating callback"")
-        unpack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        unpack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_ames_json = c_char_p(ames_json.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
+    c_jwe_len = c_uint32(len(jwe))
+    unpack_message_bytes = await do_call('indy_unpack_message',
+                                         c_wallet_handle,
+                                         jwe,
+                                         c_jwe_len,
+                                         unpack_message.cb)
 
-    message, sender_vk = await do_call('indy_unpack_messasge',
-                                       c_wallet_handle,
-                                       c_ames_json,
-                                       c_my_vk,
-                                       unpack_message.cb)
+    try:
+        unpack_message_str = unpack_message_bytes.decode('utf-8', 'strict')
+    except UnicodeDecodeError:
+        return UnicodeDecodeError",,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251298862,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251298862,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,use `did.key_for_did` instead,00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 07:05:12,251298961,"@@ -391,80 +391,112 @@ def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
     return decrypted_message
 
 
-async def pack_message(wallet_handle: int, message: str, recv_key_list: str, sender: str) -> str:
+async def pack_message(wallet_handle: int, 
+                       message: str, 
+                       recipient_verkeys: list,
+                       sender_verkey: str ) -> bytes:
     """"""
-    Packs a message (Experimental)
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
     Note to use DID keys with this function you can call did.key_for_did to get key id (verkey)
     for specific DID.
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param message: the message to be authcrypted for multiple parties
-    :param recv_key_list: a list in json format of receiver's verkeys
-    :param sender: the sender's verkey as a string When None is used in this parameter, anoncrypt is used
-    :return: a json string following the Auth or Anon AMES format
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the message being sent as a string. If it's JSON formatted it should be converted to a string
+    recipient_verkeys: a list of Strings which are recipient verkeys
+    sender_verkey: the sender's verkey as a string. -> When None is passed in this parameter, anoncrypt mode is used
+
+    returns an Agent Wire Message format as a byte array. See HIPE 0028 for detailed formats
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recv_key_list: %r, my_vk: %r"",
+    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recipient_verkeys: %r, sender_verkey: %r"",
                  wallet_handle,
                  message,
-                 recv_key_list,
-                 my_vk)
+                 recipient_verkeys,
+                 sender_verkey)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
 
     if not hasattr(pack_message, ""cb""):
         logger.debug(""pack_message: Creating callback"")
-        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_message = c_char_p(message.encode('utf-8'))
-    c_recv_key_list = c_char_p(recv_key_list.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
-
-    auth_ames = await do_call('indy_pack_message',
-                        c_wallet_handle,
-                        c_message,
-                        c_recv_key_list,
-                        c_my_vk,
-                        pack_message.cb)
-
-    auth_ames.decode()
+    msg_bytes = message.encode(""utf-8"")
+    c_msg_len = c_uint32(len(msg_bytes))
+    c_recipient_verkeys = c_char_p(json.dumps(recipient_verkeys).encode('utf-8'))
+    c_sender_vk = c_char_p(sender_verkey.encode('utf-8')) if sender_verkey is not None else None
+    res = await do_call('indy_pack_message',
+                                      c_wallet_handle,
+                                      msg_bytes,
+                                      c_msg_len,
+                                      c_recipient_verkeys,
+                                      c_sender_vk,
+                                      pack_message.cb)
     logger.debug(""pack_message: <<< res: %r"", res)
     return res
 
+async def unpack_message(wallet_handle: int,
+                        jwe: str) -> str:
 
-async def unpack_message(wallet_handle: int, ames_json: str, my_vk: str) -> (str, str):
     """"""
-    Experimental. Deserializes a AMES json string and decrypts the message returning the message and the sender's verkey if it was an AuthAMES.
-    If it is an AnonAMES it will deserialize, decrypt, and return the message with an empty sender_vk string.
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param ames_json: a json string serialized using either AuthAMES or AnonAMES
-    :param my_vk: the verkey to authcrypt with
-    :return: message: the unencrypted message
-             sender_vk: the sender's verkey if AuthAMES, else an empty string
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)",,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251298961,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251298961,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,"ahh gotcha, thanks",00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 07:09:28,251299691,"@@ -0,0 +1,56 @@
+import json
+import pytest
+import asyncio
+
+from indy import IndyError
+from indy import crypto, did
+
+from indy.error import ErrorCode
+
+@pytest.mark.asyncio
+async def test_pack_message_authcrypt_works(wallet_handle, seed_my1, verkey_my2, pack_message):
+    sender_verkey = await did.create_key(wallet_handle, json.dumps({'seed': seed_my1}))
+    receiver_verkeys = [verkey_my2]
+    packed_message_bytes = await crypto.pack_message(wallet_handle, pack_message, receiver_verkeys, sender_verkey)
+    packed_message_json = packed_message_bytes.decode(""utf-8"")
+    json_message = json.loads(packed_message_json)
+    assert json_message['protected'] != """"",,2019-01-28 07:28:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251299691,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251299691,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,"After speaking with @Artemkaaas He's submitted a PR already #1439 for nodejs. If we agree that this should be do this we'd need to update all the wrappers. In the case of python, this works fine, however in other wrappers (rust) the strong typing of the language makes it more difficult to handle this for the consumer. For example, in rust we'd need to remove the future return type, which would change it to a synchronous call for the consumer. However, with rust serde_json is able to process the JSON from a vec<u8> which helps a bit.

Curious to hear @jovfer opinion.  @TelegramSam and @dbluhm what's your thoughts on this given you're the one's who will likely be using the python wrapper the most right away?",00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 07:26:43,251302537,"@@ -391,80 +391,113 @@ def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
     return decrypted_message
 
 
-async def pack_message(wallet_handle: int, message: str, recv_key_list: str, sender: str) -> str:
+async def pack_message(wallet_handle: int, 
+                       message: str, 
+                       recipient_verkeys: list,
+                       sender_verkey: str ) -> bytes:
     """"""
-    Packs a message (Experimental)
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    Note to use DID keys with this function you can call did.key_for_did to get key id (verkey)
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
     for specific DID.
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param message: the message to be authcrypted for multiple parties
-    :param recv_key_list: a list in json format of receiver's verkeys
-    :param sender: the sender's verkey as a string When None is used in this parameter, anoncrypt is used
-    :return: a json string following the Auth or Anon AMES format
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the message being sent as a string. If it's JSON formatted it should be converted to a string
+    recipient_verkeys: a list of Strings which are recipient verkeys
+    sender_verkey: the sender's verkey as a string. -> When None is passed in this parameter, anoncrypt mode is used
+
+    returns an Agent Wire Message format as a byte array. See HIPE 0028 for detailed formats
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recv_key_list: %r, my_vk: %r"",
+    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recipient_verkeys: %r, sender_verkey: %r"",
                  wallet_handle,
                  message,
-                 recv_key_list,
-                 my_vk)
+                 recipient_verkeys,
+                 sender_verkey)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
 
     if not hasattr(pack_message, ""cb""):
         logger.debug(""pack_message: Creating callback"")
-        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_message = c_char_p(message.encode('utf-8'))
-    c_recv_key_list = c_char_p(recv_key_list.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
-
-    auth_ames = await do_call('indy_pack_message',
-                        c_wallet_handle,
-                        c_message,
-                        c_recv_key_list,
-                        c_my_vk,
-                        pack_message.cb)
-
-    auth_ames.decode()
+    msg_bytes = message.encode(""utf-8"")
+    c_msg_len = c_uint32(len(msg_bytes))
+    c_recipient_verkeys = c_char_p(json.dumps(recipient_verkeys).encode('utf-8'))
+    c_sender_vk = c_char_p(sender_verkey.encode('utf-8')) if sender_verkey is not None else None
+    res = await do_call('indy_pack_message',
+                                      c_wallet_handle,
+                                      msg_bytes,
+                                      c_msg_len,
+                                      c_recipient_verkeys,
+                                      c_sender_vk,
+                                      pack_message.cb)
     logger.debug(""pack_message: <<< res: %r"", res)
     return res
 
+async def unpack_message(wallet_handle: int,
+                        jwe: str) -> str:
 
-async def unpack_message(wallet_handle: int, ames_json: str, my_vk: str) -> (str, str):
     """"""
-    Experimental. Deserializes a AMES json string and decrypts the message returning the message and the sender's verkey if it was an AuthAMES.
-    If it is an AnonAMES it will deserialize, decrypt, and return the message with an empty sender_vk string.
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param ames_json: a json string serialized using either AuthAMES or AnonAMES
-    :param my_vk: the verkey to authcrypt with
-    :return: message: the unencrypted message
-             sender_vk: the sender's verkey if AuthAMES, else an empty string
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
+    for specific DID.
+
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the output of a pack message
+
+    #Returns -> See HIPE 0028 for details
+    (Authcrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+        ""sender_verkey"": <sender verkey used to encrypt>
+    }
+
+    (Anoncrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+    }
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""unpack_message: >>> wallet_handle: %r, ames_json: %r, my_vk: %r"",
+    logger.debug(""unpack_message: >>> wallet_handle: %r, jwe: %r"",
                  wallet_handle,
-                 ames_json,
-                 my_vk)
+                 jwe)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
+        
 
     if not hasattr(unpack_message, ""cb""):
-        logger.debug(""unpack_message: Creating callback"")
-        unpack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        logger.debug(""pack_message: Creating callback"")
+        unpack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_ames_json = c_char_p(ames_json.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
-
-    message, sender_vk = await do_call('indy_unpack_messasge',
-                                       c_wallet_handle,
-                                       c_ames_json,
-                                       c_my_vk,
-                                       unpack_message.cb)
+    c_jwe_len = c_uint32(len(jwe))
+    unpack_message_bytes = await do_call('indy_unpack_message',
+                                         c_wallet_handle,
+                                         jwe,
+                                         c_jwe_len,
+                                         unpack_message.cb)
+
+    try:
+        unpack_message_str = unpack_message_bytes.decode('utf-8', 'strict')",,2019-01-28 07:31:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251302537,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251302537,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1438,https://github.com/hyperledger/indy-sdk/pull/1438,"I strongly suggest to keep the same type for input parameter `msg` of pack and result of unpack.

and for current implementation I suggest to use bytes for pack/unpack as its current approach across all wrappers",00124e7bbc506bb954d33bfa3ad4a1a6ba491dd2,2019-01-28 11:14:31,251372385,"@@ -391,80 +391,113 @@ def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
     return decrypted_message
 
 
-async def pack_message(wallet_handle: int, message: str, recv_key_list: str, sender: str) -> str:
+async def pack_message(wallet_handle: int, 
+                       message: str, 
+                       recipient_verkeys: list,
+                       sender_verkey: str ) -> bytes:
     """"""
-    Packs a message (Experimental)
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    Note to use DID keys with this function you can call did.key_for_did to get key id (verkey)
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
     for specific DID.
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param message: the message to be authcrypted for multiple parties
-    :param recv_key_list: a list in json format of receiver's verkeys
-    :param sender: the sender's verkey as a string When None is used in this parameter, anoncrypt is used
-    :return: a json string following the Auth or Anon AMES format
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the message being sent as a string. If it's JSON formatted it should be converted to a string
+    recipient_verkeys: a list of Strings which are recipient verkeys
+    sender_verkey: the sender's verkey as a string. -> When None is passed in this parameter, anoncrypt mode is used
+
+    returns an Agent Wire Message format as a byte array. See HIPE 0028 for detailed formats
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recv_key_list: %r, my_vk: %r"",
+    logger.debug(""pack_message: >>> wallet_handle: %r, message: %r, recipient_verkeys: %r, sender_verkey: %r"",
                  wallet_handle,
                  message,
-                 recv_key_list,
-                 my_vk)
+                 recipient_verkeys,
+                 sender_verkey)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
 
     if not hasattr(pack_message, ""cb""):
         logger.debug(""pack_message: Creating callback"")
-        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        pack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_message = c_char_p(message.encode('utf-8'))
-    c_recv_key_list = c_char_p(recv_key_list.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
-
-    auth_ames = await do_call('indy_pack_message',
-                        c_wallet_handle,
-                        c_message,
-                        c_recv_key_list,
-                        c_my_vk,
-                        pack_message.cb)
-
-    auth_ames.decode()
+    msg_bytes = message.encode(""utf-8"")
+    c_msg_len = c_uint32(len(msg_bytes))
+    c_recipient_verkeys = c_char_p(json.dumps(recipient_verkeys).encode('utf-8'))
+    c_sender_vk = c_char_p(sender_verkey.encode('utf-8')) if sender_verkey is not None else None
+    res = await do_call('indy_pack_message',
+                                      c_wallet_handle,
+                                      msg_bytes,
+                                      c_msg_len,
+                                      c_recipient_verkeys,
+                                      c_sender_vk,
+                                      pack_message.cb)
     logger.debug(""pack_message: <<< res: %r"", res)
     return res
 
+async def unpack_message(wallet_handle: int,
+                        jwe: str) -> str:
 
-async def unpack_message(wallet_handle: int, ames_json: str, my_vk: str) -> (str, str):
     """"""
-    Experimental. Deserializes a AMES json string and decrypts the message returning the message and the sender's verkey if it was an AuthAMES.
-    If it is an AnonAMES it will deserialize, decrypt, and return the message with an empty sender_vk string.
+    Packs a message by encrypting the message and serializes it in a JWE-like format (Experimental)
 
-    :param wallet_handle: wallet handler (created by open_wallet).
-    :param ames_json: a json string serialized using either AuthAMES or AnonAMES
-    :param my_vk: the verkey to authcrypt with
-    :return: message: the unencrypted message
-             sender_vk: the sender's verkey if AuthAMES, else an empty string
+    Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
+    for specific DID.
+
+    #Params
+    command_handle: command handle to map callback to user context.
+    wallet_handle: wallet handler (created by open_wallet)
+    message: the output of a pack message
+
+    #Returns -> See HIPE 0028 for details
+    (Authcrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+        ""sender_verkey"": <sender verkey used to encrypt>
+    }
+
+    (Anoncrypt mode)
+
+    {
+        ""message"": <decrypted message>,
+        ""recipient_verkey"": <recipient verkey used to decrypt>,
+    }
     """"""
 
     logger = logging.getLogger(__name__)
-    logger.debug(""unpack_message: >>> wallet_handle: %r, ames_json: %r, my_vk: %r"",
+    logger.debug(""unpack_message: >>> wallet_handle: %r, jwe: %r"",
                  wallet_handle,
-                 ames_json,
-                 my_vk)
+                 jwe)
+
+    def transform_cb(arr_ptr: POINTER(c_uint8), arr_len: c_uint32):
+        return bytes(arr_ptr[:arr_len]),
+        
 
     if not hasattr(unpack_message, ""cb""):
-        logger.debug(""unpack_message: Creating callback"")
-        unpack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, c_char_p))
+        logger.debug(""pack_message: Creating callback"")
+        unpack_message.cb = create_cb(CFUNCTYPE(None, c_int32, c_int32, POINTER(c_uint8), c_uint32), transform_cb)
 
     c_wallet_handle = c_int32(wallet_handle)
-    c_ames_json = c_char_p(ames_json.encode('utf-8'))
-    c_my_vk = c_char_p(my_vk.encode('utf-8'))
-
-    message, sender_vk = await do_call('indy_unpack_messasge',
-                                       c_wallet_handle,
-                                       c_ames_json,
-                                       c_my_vk,
-                                       unpack_message.cb)
+    c_jwe_len = c_uint32(len(jwe))
+    unpack_message_bytes = await do_call('indy_unpack_message',
+                                         c_wallet_handle,
+                                         jwe,
+                                         c_jwe_len,
+                                         unpack_message.cb)
+
+    try:
+        unpack_message_str = unpack_message_bytes.decode('utf-8', 'strict')",,2019-01-28 11:14:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251372385,https://github.com/hyperledger/indy-sdk/pull/1438#discussion_r251372385,jovfer
https://github.com/hyperledger/indy-sdk/pull/1434,https://github.com/hyperledger/indy-sdk/pull/1434,I suggest to just return `address.starts_with(&prefix)` as result,17ac8bfb5607d14cd909fe57087b6df5b2b30c57,2019-01-25 11:15:19,250949824,"@@ -169,26 +169,39 @@ pub fn list_addresses() -> Result<Vec<String>, u32> {
     Ok(serde_json::from_str(&addresses).or(Err(error::INVALID_JSON.code_num))?)
 }
 
+fn is_valid_address(address: &str, method: &str) -> bool {
+    let prefix = format!(""pay:{}"", method);
+
+    if address.starts_with(&prefix) {",,2019-01-25 14:39:16,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/250949824,https://github.com/hyperledger/indy-sdk/pull/1434#discussion_r250949824,jovfer
https://github.com/hyperledger/indy-sdk/pull/1434,https://github.com/hyperledger/indy-sdk/pull/1434,"@glowkey @hadleym I think it's useful to add something as `else` branch.
1) Should it be an error to throw from function as result?
2) If no, please add `warn` or `info` or `debug` log. I think it's should be debug+ level (not trace), but don't have enough context to suggest exact level...",17ac8bfb5607d14cd909fe57087b6df5b2b30c57,2019-01-25 11:16:28,250950124,"@@ -169,26 +169,39 @@ pub fn list_addresses() -> Result<Vec<String>, u32> {
     Ok(serde_json::from_str(&addresses).or(Err(error::INVALID_JSON.code_num))?)
 }
 
+fn is_valid_address(address: &str, method: &str) -> bool {
+    let prefix = format!(""pay:{}"", method);
+
+    if address.starts_with(&prefix) {
+        return true
+    }
+
+    return false
+}
+
 pub fn get_wallet_token_info() -> Result<WalletInfo, u32> {
     trace!(""get_wallet_token_info >>>"");
 
     let addresses = list_addresses()?;
 
+    let method = settings::get_config_value(settings::CONFIG_PAYMENT_METHOD)?;
     let mut balance = 0;
     let mut wallet_info = Vec::new();
 
     for address in addresses.iter() {
-        let mut info = get_address_info(&address)?;
+        if is_valid_address(&address, &method) {
+            debug!(""getting address info for {}"", address);
+            let mut info = get_address_info(&address)?;
 
-        for utxo in info.utxo.iter() { balance += utxo.amount as u64; }
+            for utxo in info.utxo.iter() { balance += utxo.amount as u64; }
 
-        wallet_info.push(info);
+            wallet_info.push(info);
+        }",32,2019-01-25 14:39:16,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/250950124,https://github.com/hyperledger/indy-sdk/pull/1434#discussion_r250950124,jovfer
https://github.com/hyperledger/indy-sdk/pull/1434,https://github.com/hyperledger/indy-sdk/pull/1434,Good suggestion. I have added a warning log statement.,17ac8bfb5607d14cd909fe57087b6df5b2b30c57,2019-01-25 14:38:51,251006628,"@@ -169,26 +169,39 @@ pub fn list_addresses() -> Result<Vec<String>, u32> {
     Ok(serde_json::from_str(&addresses).or(Err(error::INVALID_JSON.code_num))?)
 }
 
+fn is_valid_address(address: &str, method: &str) -> bool {
+    let prefix = format!(""pay:{}"", method);
+
+    if address.starts_with(&prefix) {
+        return true
+    }
+
+    return false
+}
+
 pub fn get_wallet_token_info() -> Result<WalletInfo, u32> {
     trace!(""get_wallet_token_info >>>"");
 
     let addresses = list_addresses()?;
 
+    let method = settings::get_config_value(settings::CONFIG_PAYMENT_METHOD)?;
     let mut balance = 0;
     let mut wallet_info = Vec::new();
 
     for address in addresses.iter() {
-        let mut info = get_address_info(&address)?;
+        if is_valid_address(&address, &method) {
+            debug!(""getting address info for {}"", address);
+            let mut info = get_address_info(&address)?;
 
-        for utxo in info.utxo.iter() { balance += utxo.amount as u64; }
+            for utxo in info.utxo.iter() { balance += utxo.amount as u64; }
 
-        wallet_info.push(info);
+            wallet_info.push(info);
+        }",32,2019-01-25 14:39:16,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251006628,https://github.com/hyperledger/indy-sdk/pull/1434#discussion_r251006628,glowkey
https://github.com/hyperledger/indy-sdk/pull/1428,https://github.com/hyperledger/indy-sdk/pull/1428,"It fails because of integration tests.
There is an import of some libindy modules by path here (tests/utils.mod.rs) including domain folder.
so, you need to import the file containing `memzeroize` macro there also.
because mod.rs contains submodules I suggest moving memzeroize macro to separate file.
steps to achieve memzeroize macro works here:
1) move memzeroize macro into a separate file (maybe src/utils/memzeroize.rs)
2) add 
 `#[macro_use]
pub mod zeroize;` into `src/utils/mod.rs`
3) add
 `#[macro_use]
#[allow(unused_macros)]
#[path = ""../../src/utils/zeroize.rs""]
pub mod zeroize;` into `tests/utils/mod.rs`",66dc636016076e172b4d0c41f3f94488205e7d99,2019-01-22 13:24:45,249776730,"@@ -24,6 +27,20 @@ impl Key {
     }
 }
 
+//Can't figure out why this macro can't be found in `cargo test` because
+//if works for src/utils/crypto/randombytes/sodium
+//memzeroize!(Key, signkey);
+",,2019-01-22 22:57:52,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249776730,https://github.com/hyperledger/indy-sdk/pull/1428#discussion_r249776730,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1428,https://github.com/hyperledger/indy-sdk/pull/1428,"@mikelodder7 it's better to use `allow(some_warning)` for minimal context, like near module import and without `!` (if possible). But we can do it later and do not block the PR",66dc636016076e172b4d0c41f3f94488205e7d99,2019-01-22 20:49:17,249954371,"@@ -1,7 +1,11 @@
-#![allow(dead_code)]
+#![allow(dead_code, unused_macros)]",2,2019-01-22 22:57:52,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249954371,https://github.com/hyperledger/indy-sdk/pull/1428#discussion_r249954371,jovfer
https://github.com/hyperledger/indy-sdk/pull/1421,https://github.com/hyperledger/indy-sdk/pull/1421,"Each object extends GCWatcher, so this is where the release function is defined.  It no longer throws an error.",93d1a9592110fc9cfa51dd81369fbddbd3b094f6,2019-01-18 20:11:10,249171928,"@@ -1,21 +1,14 @@
 import * as weak from 'weak'
-import { VCXInternalError } from '../errors'
 
 export abstract class GCWatcher {
   protected abstract _releaseFn: any
   // LibVCX handles invalid handles
   private _handleRef!: number
 
-  public async release (): Promise<number> {
-    try {
-      const rc = this._releaseFn(this._handleRef)
-      if (rc) {
-        throw rc
-      }
-      return rc
-    } catch (err) {
-      throw new VCXInternalError(err)
-    }
+  public async release (): Promise<void> {",19,2019-01-21 13:06:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249171928,https://github.com/hyperledger/indy-sdk/pull/1421#discussion_r249171928,hadleym
https://github.com/hyperledger/indy-sdk/pull/1421,https://github.com/hyperledger/indy-sdk/pull/1421,This try/catch is no longer necessary due to the changes in the code above.,93d1a9592110fc9cfa51dd81369fbddbd3b094f6,2019-01-18 20:11:50,249172103,"@@ -31,14 +24,7 @@ export abstract class GCWatcher {
     const release = this._releaseFn
     const handle = this._handleRef
     weak.addCallback(weakRef, () => {
-      try {
-        const rc = release(handle)
-        if (rc) {
-          throw rc
-        }
-      } catch (err) {
-        throw new VCXInternalError(err)
-      }
+      release(handle)",38,2019-01-21 13:06:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249172103,https://github.com/hyperledger/indy-sdk/pull/1421#discussion_r249172103,hadleym
https://github.com/hyperledger/indy-sdk/pull/1421,https://github.com/hyperledger/indy-sdk/pull/1421,"Can you write a comment saying ""why"" we're not throwing an error? Unpredictable node GC for example.",93d1a9592110fc9cfa51dd81369fbddbd3b094f6,2019-01-18 20:22:09,249174872,"@@ -31,14 +24,7 @@ export abstract class GCWatcher {
     const release = this._releaseFn
     const handle = this._handleRef
     weak.addCallback(weakRef, () => {
-      try {
-        const rc = release(handle)
-        if (rc) {
-          throw rc
-        }
-      } catch (err) {
-        throw new VCXInternalError(err)
-      }
+      release(handle)",38,2019-01-21 13:06:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249174872,https://github.com/hyperledger/indy-sdk/pull/1421#discussion_r249174872,glowkey
https://github.com/hyperledger/indy-sdk/pull/1418,https://github.com/hyperledger/indy-sdk/pull/1418,"Did you try to build the indy-pool docker image after changes?
It is broken. Another version `1.6.757` has been validated by QA according to comment in correspondent Indy-Node ticket. ",f063cebd0dcda0ab7c469eb2ab2d23aadc8d992d,2019-01-18 05:53:46,248934347,"@@ -26,7 +26,7 @@ RUN useradd -ms /bin/bash -u $uid indy
 
 ARG indy_plenum_ver=1.6.641
 ARG indy_anoncreds_ver=1.0.32
-ARG indy_node_ver=1.6.740
+ARG indy_node_ver=1.6.756",,2019-01-22 20:22:45,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/248934347,https://github.com/hyperledger/indy-sdk/pull/1418#discussion_r248934347,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1418,https://github.com/hyperledger/indy-sdk/pull/1418,Please updated documentation for the correspondent methods in Indy wrappers to reflect NETWORK_MONITOR role.,f063cebd0dcda0ab7c469eb2ab2d23aadc8d992d,2019-01-18 06:00:39,248935113,"@@ -363,6 +363,7 @@ pub extern fn indy_build_get_ddo_request(command_handle: IndyHandle,
 ///                             TRUSTEE
 ///                             STEWARD
 ///                             TRUST_ANCHOR
+///                             NETWORK_MONITOR
 ///                             empty string to reset role
 /// cb: Callback that takes command result as parameter.
 ///",7,2019-01-22 20:22:45,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/248935113,https://github.com/hyperledger/indy-sdk/pull/1418#discussion_r248935113,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1418,https://github.com/hyperledger/indy-sdk/pull/1418,"Yes.  It worked for me.  I can update to .757 though.   What was the errors you saw?
",f063cebd0dcda0ab7c469eb2ab2d23aadc8d992d,2019-01-18 13:53:01,249049302,"@@ -26,7 +26,7 @@ RUN useradd -ms /bin/bash -u $uid indy
 
 ARG indy_plenum_ver=1.6.641
 ARG indy_anoncreds_ver=1.0.32
-ARG indy_node_ver=1.6.740
+ARG indy_node_ver=1.6.756",,2019-01-22 20:22:45,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249049302,https://github.com/hyperledger/indy-sdk/pull/1418#discussion_r249049302,mattraffel
https://github.com/hyperledger/indy-sdk/pull/1418,https://github.com/hyperledger/indy-sdk/pull/1418,"It can't work because of Indy-Node 1.6.756 depended on another version indy-plenum which also must be changed. 
Moreover, I found that 1.6.756 was published with the wrong dependency on distro and was fixed in this PR: https://github.com/hyperledger/indy-node/pull/1126/files ",f063cebd0dcda0ab7c469eb2ab2d23aadc8d992d,2019-01-18 14:54:27,249070247,"@@ -26,7 +26,7 @@ RUN useradd -ms /bin/bash -u $uid indy
 
 ARG indy_plenum_ver=1.6.641
 ARG indy_anoncreds_ver=1.0.32
-ARG indy_node_ver=1.6.740
+ARG indy_node_ver=1.6.756",,2019-01-22 20:22:45,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249070247,https://github.com/hyperledger/indy-sdk/pull/1418#discussion_r249070247,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1418,https://github.com/hyperledger/indy-sdk/pull/1418,"here is output from jenkins ci
`[Ubuntu Test: build and test libindy] The following packages have unmet dependencies:
[Ubuntu Test: build and test libindy]  indy-node : Depends: indy-plenum (= 1.6.652) but 1.6.641 is to be installed
[Ubuntu Test: build and test libindy]              Depends: distro (= 1.3.0) but it is not installable
[Ubuntu Test: build and test libindy] [91mE: Unable to correct problems, you have held broken packages.`",f063cebd0dcda0ab7c469eb2ab2d23aadc8d992d,2019-01-18 15:20:53,249079612,"@@ -26,7 +26,7 @@ RUN useradd -ms /bin/bash -u $uid indy
 
 ARG indy_plenum_ver=1.6.641
 ARG indy_anoncreds_ver=1.0.32
-ARG indy_node_ver=1.6.740
+ARG indy_node_ver=1.6.756",,2019-01-22 20:22:45,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249079612,https://github.com/hyperledger/indy-sdk/pull/1418#discussion_r249079612,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1418,https://github.com/hyperledger/indy-sdk/pull/1418,updated.,f063cebd0dcda0ab7c469eb2ab2d23aadc8d992d,2019-01-20 22:48:30,249299466,"@@ -26,7 +26,7 @@ RUN useradd -ms /bin/bash -u $uid indy
 
 ARG indy_plenum_ver=1.6.641
 ARG indy_anoncreds_ver=1.0.32
-ARG indy_node_ver=1.6.740
+ARG indy_node_ver=1.6.756",,2019-01-22 20:22:45,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249299466,https://github.com/hyperledger/indy-sdk/pull/1418#discussion_r249299466,mattraffel
https://github.com/hyperledger/indy-sdk/pull/1417,https://github.com/hyperledger/indy-sdk/pull/1417,This information is outdated for the moment. Libindy now provides get_current_error method that returns deep information about error that includes descriptive message based on full error chain and backtrace.,a2b6e19f72678f28c7930d320eb57b526aa52485,2019-01-18 07:55:25,248952395,"@@ -0,0 +1,71 @@
+# Architecture
+
+## Summary
+At a high level the IndySDK is designed to be a software development kit that has many components to support and grow the Indy ecosystem. Two of the main functionalities that the IndySDK supports is communication with the Indy Ledger and formation of Indy Agents. At a deeper level, IndySDK contains a few libraries, but the primary focus of the IndySDK has been around libindy. Other additional libraries include vcx and libnullpay.
+
+Libindy is the primary library intended to serve as a foundation for all things Hyperledger Indy. The core functionality of the ledger includes functionality to:
+
+* Use anonymous credentials
+* Store arbitrary data in a wallet
+* Core cryptographic functionality like encrypting and decrypting messages for other users
+* Perform CRUD operations with both on ledger and pairwise (off-ledger) DIDs
+* Communicate with the Indy Ledger
+* Support payment functionality
+* Support a standard wallet API to interact with different DBs
+
+Since this library was written in rust with a C-Callable API layer, it's also supports easier porting to other languages that support calling a C interface such as Python, Java, Objective C, and Node.js.
+
+At a high level the architecture has been designed in an extensible way to support the use of high level commands. A visual diagram of the architecture is provided below.
+
+![](sdk-overview.png)
+
+
+### Wrapper Layer
+
+The wrapper layer is for wrapping the C-Callable APIs to allow functionality to be supported in many different programming languages. If you'd like to learn more about using the SDK wrappers there's [How-to guides](doc/how-tos), [samples](samples), and [reference agents](https://github.com/hyperledger/indy-agent) that can help. Here's some links to the different wrappers available.
+
+* [Python](wrappers/python/README.md)
+* [NodeJS](wrappers/nodejs/README.md)
+* [Java](wrappers/java/README.md)
+* [iOS](wrappers/ios/README.md)
+* [.Net](wrappers/dotnet/README.md)
+* [Rust](wrappers/rust/README.md)
+
+If you'd like to begin working on the SDK, a good place to start is making sure all of the wrappers support all of the APIs exposed by the C-Callable layer. This is done by adding foreign function interface (FFI) calls to the wrappers. Examples of this can be found in already supported APIs listed. Additionally, providing how-to guides and samples showing how to consume the wrappers is another good place to help contribute.
+
+### API Layer
+
+Next up, we've got the C-Callable API layer which is where we expose functionality and logic which can be consumed by the wrapper layers. The API layer and below is written in Rust but supports only simple native C types like integers, strings, and byte arrays. Complex data structures are intentional avoided to allow for a boarder support between the API layer and the Wrapper layer. Since most languages support the use of FFI functions (e.g. C interfaces called in a Python program) this allows us to keep functionality in lockstep by writing it in Rust and then porting it to other languages.
+
+In this layer we expose 11 different modules which group together similar functionality. The modules are listed in the image above with descriptions, parameter usage, and other details of the specific API calls being commented in the wrappers and the API layer. The primary purpose of this layer is to convert the c types to rust types and to call commandExecutor to communicate with the command layer.
+
+Some other important aspects that should be considered between the functional side of libindy (code written in rust) and the wrapper is around memory management. One of the important boundaries that was set when architecting this SDK is that memory that is created in the wrapper layer is managed and closed by the wrapper layer. Similarly any memory that is allocated to the functional side is closed out by the functional side. This allows for cleaner management of memory and  
+
+### Command Layer
+
+In the command layer, this is where functions combine the the majority of their logic. The command layer consumes the service layers and passes data between different services as is needed rather than allowing services to communicate directly with each other. When a particular command is called by the API layer by the CommandExecutor which then calls internal commands for each individual function. A command module will call one or many services to execute a function and then return the results back up to the API layer and then passed back up to the wrapper layer. Along with routing the commands to their respective module calls, the CommandExecutor also handles the creation of the services that are consumed by the command modules.
+
+
+### Service Layer
+
+Within the service layer we have very low level functions that can be consumed by the command layer. These low level functions are common functions which may be needed in many different command modules. For example within the crypto service, there is a common function to create a cryptographic key with a common interface to allow for key creation to happen for many different cryptographic material. The current implementation supports the creation of ed25519 keys, but could easily add support for secp256k1 keys as well.
+
+Another example of the functions supported at the wallet service layer is the ability to take a key that was created and to be able to add it to a database that's exposed through a common wallet interface. This common wallet interface allows for different DBs to be plugged in to the wallet interface depending on the needs of the application.
+
+In summary, the service layer can be thought of as a suite of helper primitives that will be consumed many times by the command layer. This helps libindy to adhere to the DRY (Don't repeat yourself) programming paradigm. Another advantage of the service layer is that it creates a clean, modular approach to quickly add new functionality at the API and command layers.
+
+### Errors
+
+This is where errors are specified in rust types which get translated at the API layer into errorcodes. Since only simple native c-types are used, libindy opts to pass integer error codes along the C-callable layer if some action fails in libindy. This allows wrapper consumers to gracefully detect errors that occurred in the SDK. A list of the errors can be found [here](../../../libindy/src/api/mod.rs). The comments give a short description of why the error may have occurred, but they won't help with debugging much. Alternatively, an excellent community maintained document would be to expand on the reasoning and solutions to why common error codes occur in certain situations.",59,2019-01-30 07:53:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/248952395,https://github.com/hyperledger/indy-sdk/pull/1417#discussion_r248952395,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1417,https://github.com/hyperledger/indy-sdk/pull/1417,I haven't been apart of this work and I figured that there's more than one place where there's incorrect information in here. My hope was to get something started and have one of the core maintainers to libindy make changes to it to accurately represent the layers. Ultimately the goal of this doc was to outline some of the things I learned while working in the codebase that could help others when they want to contribute to libindy. Would you be able to add the corrections to this?,a2b6e19f72678f28c7930d320eb57b526aa52485,2019-01-18 11:03:56,249004665,"@@ -0,0 +1,71 @@
+# Architecture
+
+## Summary
+At a high level the IndySDK is designed to be a software development kit that has many components to support and grow the Indy ecosystem. Two of the main functionalities that the IndySDK supports is communication with the Indy Ledger and formation of Indy Agents. At a deeper level, IndySDK contains a few libraries, but the primary focus of the IndySDK has been around libindy. Other additional libraries include vcx and libnullpay.
+
+Libindy is the primary library intended to serve as a foundation for all things Hyperledger Indy. The core functionality of the ledger includes functionality to:
+
+* Use anonymous credentials
+* Store arbitrary data in a wallet
+* Core cryptographic functionality like encrypting and decrypting messages for other users
+* Perform CRUD operations with both on ledger and pairwise (off-ledger) DIDs
+* Communicate with the Indy Ledger
+* Support payment functionality
+* Support a standard wallet API to interact with different DBs
+
+Since this library was written in rust with a C-Callable API layer, it's also supports easier porting to other languages that support calling a C interface such as Python, Java, Objective C, and Node.js.
+
+At a high level the architecture has been designed in an extensible way to support the use of high level commands. A visual diagram of the architecture is provided below.
+
+![](sdk-overview.png)
+
+
+### Wrapper Layer
+
+The wrapper layer is for wrapping the C-Callable APIs to allow functionality to be supported in many different programming languages. If you'd like to learn more about using the SDK wrappers there's [How-to guides](doc/how-tos), [samples](samples), and [reference agents](https://github.com/hyperledger/indy-agent) that can help. Here's some links to the different wrappers available.
+
+* [Python](wrappers/python/README.md)
+* [NodeJS](wrappers/nodejs/README.md)
+* [Java](wrappers/java/README.md)
+* [iOS](wrappers/ios/README.md)
+* [.Net](wrappers/dotnet/README.md)
+* [Rust](wrappers/rust/README.md)
+
+If you'd like to begin working on the SDK, a good place to start is making sure all of the wrappers support all of the APIs exposed by the C-Callable layer. This is done by adding foreign function interface (FFI) calls to the wrappers. Examples of this can be found in already supported APIs listed. Additionally, providing how-to guides and samples showing how to consume the wrappers is another good place to help contribute.
+
+### API Layer
+
+Next up, we've got the C-Callable API layer which is where we expose functionality and logic which can be consumed by the wrapper layers. The API layer and below is written in Rust but supports only simple native C types like integers, strings, and byte arrays. Complex data structures are intentional avoided to allow for a boarder support between the API layer and the Wrapper layer. Since most languages support the use of FFI functions (e.g. C interfaces called in a Python program) this allows us to keep functionality in lockstep by writing it in Rust and then porting it to other languages.
+
+In this layer we expose 11 different modules which group together similar functionality. The modules are listed in the image above with descriptions, parameter usage, and other details of the specific API calls being commented in the wrappers and the API layer. The primary purpose of this layer is to convert the c types to rust types and to call commandExecutor to communicate with the command layer.
+
+Some other important aspects that should be considered between the functional side of libindy (code written in rust) and the wrapper is around memory management. One of the important boundaries that was set when architecting this SDK is that memory that is created in the wrapper layer is managed and closed by the wrapper layer. Similarly any memory that is allocated to the functional side is closed out by the functional side. This allows for cleaner management of memory and  
+
+### Command Layer
+
+In the command layer, this is where functions combine the the majority of their logic. The command layer consumes the service layers and passes data between different services as is needed rather than allowing services to communicate directly with each other. When a particular command is called by the API layer by the CommandExecutor which then calls internal commands for each individual function. A command module will call one or many services to execute a function and then return the results back up to the API layer and then passed back up to the wrapper layer. Along with routing the commands to their respective module calls, the CommandExecutor also handles the creation of the services that are consumed by the command modules.
+
+
+### Service Layer
+
+Within the service layer we have very low level functions that can be consumed by the command layer. These low level functions are common functions which may be needed in many different command modules. For example within the crypto service, there is a common function to create a cryptographic key with a common interface to allow for key creation to happen for many different cryptographic material. The current implementation supports the creation of ed25519 keys, but could easily add support for secp256k1 keys as well.
+
+Another example of the functions supported at the wallet service layer is the ability to take a key that was created and to be able to add it to a database that's exposed through a common wallet interface. This common wallet interface allows for different DBs to be plugged in to the wallet interface depending on the needs of the application.
+
+In summary, the service layer can be thought of as a suite of helper primitives that will be consumed many times by the command layer. This helps libindy to adhere to the DRY (Don't repeat yourself) programming paradigm. Another advantage of the service layer is that it creates a clean, modular approach to quickly add new functionality at the API and command layers.
+
+### Errors
+
+This is where errors are specified in rust types which get translated at the API layer into errorcodes. Since only simple native c-types are used, libindy opts to pass integer error codes along the C-callable layer if some action fails in libindy. This allows wrapper consumers to gracefully detect errors that occurred in the SDK. A list of the errors can be found [here](../../../libindy/src/api/mod.rs). The comments give a short description of why the error may have occurred, but they won't help with debugging much. Alternatively, an excellent community maintained document would be to expand on the reasoning and solutions to why common error codes occur in certain situations.",59,2019-01-30 07:53:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249004665,https://github.com/hyperledger/indy-sdk/pull/1417#discussion_r249004665,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1407,https://github.com/hyperledger/indy-sdk/pull/1407,"as far as I remember the initial plan was to use github.io to render .NET documentation. and there were some issues with it. Like `.io` is not enabled for HL/indy-sdk repo. And may be something else.
@srottem @tmarkovski could you share more details about this topic?",cf4b22aaeb16c9582758c322f238ce0ce349f5e1,2019-01-21 16:09:46,249507001,"@@ -9,7 +9,7 @@ Pull requests welcome!
 
 ### Documentation
 
-Documentation for the .NET wrapper is available [here](http://hyperledger.github.io/indy-sdk/wrappers/dotnet/docs/index.html).
+Documentation for the .NET wrapper is available [here](https://github.com/hyperledger/indy-sdk/blob/master/wrappers/dotnet/docs/index.html).",5,2019-01-28 22:35:17,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249507001,https://github.com/hyperledger/indy-sdk/pull/1407#discussion_r249507001,jovfer
https://github.com/hyperledger/indy-sdk/pull/1407,https://github.com/hyperledger/indy-sdk/pull/1407,sure @jovfer . waiting for their inputs. thanks.,cf4b22aaeb16c9582758c322f238ce0ce349f5e1,2019-01-21 19:39:36,249561721,"@@ -9,7 +9,7 @@ Pull requests welcome!
 
 ### Documentation
 
-Documentation for the .NET wrapper is available [here](http://hyperledger.github.io/indy-sdk/wrappers/dotnet/docs/index.html).
+Documentation for the .NET wrapper is available [here](https://github.com/hyperledger/indy-sdk/blob/master/wrappers/dotnet/docs/index.html).",5,2019-01-28 22:35:17,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249561721,https://github.com/hyperledger/indy-sdk/pull/1407#discussion_r249561721,vikpande
https://github.com/hyperledger/indy-sdk/pull/1407,https://github.com/hyperledger/indy-sdk/pull/1407,"Correct.  The repo needs to be configured with ""Github Pages"" with the source as the Master branch. See here for details: https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/.",cf4b22aaeb16c9582758c322f238ce0ce349f5e1,2019-01-21 21:06:49,249579050,"@@ -9,7 +9,7 @@ Pull requests welcome!
 
 ### Documentation
 
-Documentation for the .NET wrapper is available [here](http://hyperledger.github.io/indy-sdk/wrappers/dotnet/docs/index.html).
+Documentation for the .NET wrapper is available [here](https://github.com/hyperledger/indy-sdk/blob/master/wrappers/dotnet/docs/index.html).",5,2019-01-28 22:35:17,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249579050,https://github.com/hyperledger/indy-sdk/pull/1407#discussion_r249579050,srottem
https://github.com/hyperledger/indy-sdk/pull/1407,https://github.com/hyperledger/indy-sdk/pull/1407,"thanks @srottem , guess maintainers/admin can do that, since i dont have access to it :-) ",cf4b22aaeb16c9582758c322f238ce0ce349f5e1,2019-01-22 18:42:33,249910716,"@@ -9,7 +9,7 @@ Pull requests welcome!
 
 ### Documentation
 
-Documentation for the .NET wrapper is available [here](http://hyperledger.github.io/indy-sdk/wrappers/dotnet/docs/index.html).
+Documentation for the .NET wrapper is available [here](https://github.com/hyperledger/indy-sdk/blob/master/wrappers/dotnet/docs/index.html).",5,2019-01-28 22:35:17,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249910716,https://github.com/hyperledger/indy-sdk/pull/1407#discussion_r249910716,vikpande
https://github.com/hyperledger/indy-sdk/pull/1407,https://github.com/hyperledger/indy-sdk/pull/1407,"Me neither.  We've been waiting for this to happen for more than a year now and it's been brought up on RocketChat multiple times, so I'm guessing no one wants to do it.",cf4b22aaeb16c9582758c322f238ce0ce349f5e1,2019-01-22 21:39:10,249970362,"@@ -9,7 +9,7 @@ Pull requests welcome!
 
 ### Documentation
 
-Documentation for the .NET wrapper is available [here](http://hyperledger.github.io/indy-sdk/wrappers/dotnet/docs/index.html).
+Documentation for the .NET wrapper is available [here](https://github.com/hyperledger/indy-sdk/blob/master/wrappers/dotnet/docs/index.html).",5,2019-01-28 22:35:17,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249970362,https://github.com/hyperledger/indy-sdk/pull/1407#discussion_r249970362,srottem
https://github.com/hyperledger/indy-sdk/pull/1407,https://github.com/hyperledger/indy-sdk/pull/1407,"As far as I know there are 2 main blockers:
- no one in core team has permission to enable .io
- probably there are some contradictions between this documentation and HIPE https://github.com/hyperledger/indy-hipe/tree/master/text/0025-indy-docs-framework

The first one seems just technical question for HL-desk, as I have seen some .io for others HL projects.
I will figure out how to resolve the second one.
@srottem Are you available in rocket.chat of sovrin or hyperledger for this discussion?",cf4b22aaeb16c9582758c322f238ce0ce349f5e1,2019-01-23 09:54:47,250122310,"@@ -9,7 +9,7 @@ Pull requests welcome!
 
 ### Documentation
 
-Documentation for the .NET wrapper is available [here](http://hyperledger.github.io/indy-sdk/wrappers/dotnet/docs/index.html).
+Documentation for the .NET wrapper is available [here](https://github.com/hyperledger/indy-sdk/blob/master/wrappers/dotnet/docs/index.html).",5,2019-01-28 22:35:17,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/250122310,https://github.com/hyperledger/indy-sdk/pull/1407#discussion_r250122310,jovfer
https://github.com/hyperledger/indy-sdk/pull/1407,https://github.com/hyperledger/indy-sdk/pull/1407,thanks guys @srottem @jovfer . I am in the sovrin working group and will flag this in the call today. will update you today about the inputs i receive. ,cf4b22aaeb16c9582758c322f238ce0ce349f5e1,2019-01-28 06:17:57,251291731,"@@ -9,7 +9,7 @@ Pull requests welcome!
 
 ### Documentation
 
-Documentation for the .NET wrapper is available [here](http://hyperledger.github.io/indy-sdk/wrappers/dotnet/docs/index.html).
+Documentation for the .NET wrapper is available [here](https://github.com/hyperledger/indy-sdk/blob/master/wrappers/dotnet/docs/index.html).",5,2019-01-28 22:35:17,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/251291731,https://github.com/hyperledger/indy-sdk/pull/1407#discussion_r251291731,vikpande
https://github.com/hyperledger/indy-sdk/pull/1402,https://github.com/hyperledger/indy-sdk/pull/1402,Please replace println by logging (if possible),881f552fffd839f6f4e06d8d46082bdade280ebb,2019-01-15 00:05:33,247713796,"@@ -212,7 +215,8 @@ impl Credential {
         match self.state {
             VcxStateType::VcxStateOfferSent => {
                 //Check for messages
-                let _ = self._check_msg();
+                let result = self._check_msg();
+                println!(""*******************result {:?}"", result);",,2019-01-17 07:50:30,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/247713796,https://github.com/hyperledger/indy-sdk/pull/1402#discussion_r247713796,jovfer
https://github.com/hyperledger/indy-sdk/pull/1400,https://github.com/hyperledger/indy-sdk/pull/1400,Only backtrace should be optional from my point of view. Also it is good to add note how to get backtrace in comments.,f04cabe47a00be1df20fda53af29046023ea5d6b,2019-01-14 13:47:13,247496692,"@@ -165,13 +166,17 @@ class ErrorCode(IntEnum):
 
     # Operation is not supported for payment method
     PaymentOperationNotSupportedError = 704,
-    
+
     # Extra funds on inputs
     PaymentExtraFundsError = 705
 
 
 class IndyError(Exception):
     # error_code: ErrorCode
+    # message: Optional[str]",,2019-01-21 09:36:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/247496692,https://github.com/hyperledger/indy-sdk/pull/1400#discussion_r247496692,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1400,https://github.com/hyperledger/indy-sdk/pull/1400,And i suggest to rename backtrace to indy_backtrace,f04cabe47a00be1df20fda53af29046023ea5d6b,2019-01-14 13:47:32,247496775,"@@ -165,13 +166,17 @@ class ErrorCode(IntEnum):
 
     # Operation is not supported for payment method
     PaymentOperationNotSupportedError = 704,
-    
+
     # Extra funds on inputs
     PaymentExtraFundsError = 705
 
 
 class IndyError(Exception):
     # error_code: ErrorCode
+    # message: Optional[str]",,2019-01-21 09:36:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/247496775,https://github.com/hyperledger/indy-sdk/pull/1400#discussion_r247496775,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1400,https://github.com/hyperledger/indy-sdk/pull/1400,"> Only backtrace should be optional from my point of view. Also it is good to add note how to get backtrace in comments.

I have put message and backtrace as optional fields to save backward compatibility (init IndyError with error code only). ",f04cabe47a00be1df20fda53af29046023ea5d6b,2019-01-15 05:52:17,247771087,"@@ -165,13 +166,17 @@ class ErrorCode(IntEnum):
 
     # Operation is not supported for payment method
     PaymentOperationNotSupportedError = 704,
-    
+
     # Extra funds on inputs
     PaymentExtraFundsError = 705
 
 
 class IndyError(Exception):
     # error_code: ErrorCode
+    # message: Optional[str]",,2019-01-21 09:36:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/247771087,https://github.com/hyperledger/indy-sdk/pull/1400#discussion_r247771087,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1400,https://github.com/hyperledger/indy-sdk/pull/1400,I suggest to rename it to “map”,f04cabe47a00be1df20fda53af29046023ea5d6b,2019-01-17 18:46:58,248794634,"@@ -158,7 +158,14 @@ impl IndyError {
     pub fn extend<D>(self, msg: D) -> IndyError
         where D: fmt::Display + fmt::Debug + Send + Sync + 'static {
         let kind = self.kind();
-        self.to_indy(kind, msg)
+        let inner = Arc::try_unwrap(self.inner).unwrap();
+        IndyError { inner: Arc::new(inner.map(|_| msg).context(kind)) }
+    }
+
+    pub fn extend_with_type<D>(self, kind: IndyErrorKind, msg: D) -> IndyError",,2019-01-21 09:36:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/248794634,https://github.com/hyperledger/indy-sdk/pull/1400#discussion_r248794634,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1397,https://github.com/hyperledger/indy-sdk/pull/1397,"1. I believe we need to provide more information on when this method should be called. 
2. Today we voted to avoid error_hanlde
3. I don't like the idea of returning error code here. It can cause recursion calls to resolve errors
4. We need to add information about returned pointer lifetime to description.
5. We need to add information on when we resolve back-trace",c349adf2521f25d8cb95a3c986fb73151e8f3e30,2019-01-11 16:22:02,247173487,"@@ -257,5 +258,31 @@ pub extern fn indy_set_runtime_config(config: *const c_char) -> ErrorCode {
 
     trace!(""indy_set_runtime_config: <<< res: {:?}"", res);
 
+    res
+}
+
+/// Get details for last occurred error",,2019-01-14 13:41:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/247173487,https://github.com/hyperledger/indy-sdk/pull/1397#discussion_r247173487,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1397,https://github.com/hyperledger/indy-sdk/pull/1397,6. As i remembered we decided to rename it to get_current_error.,c349adf2521f25d8cb95a3c986fb73151e8f3e30,2019-01-11 16:22:37,247173668,"@@ -257,5 +258,31 @@ pub extern fn indy_set_runtime_config(config: *const c_char) -> ErrorCode {
 
     trace!(""indy_set_runtime_config: <<< res: {:?}"", res);
 
+    res
+}
+
+/// Get details for last occurred error",,2019-01-14 13:41:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/247173668,https://github.com/hyperledger/indy-sdk/pull/1397#discussion_r247173668,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1397,https://github.com/hyperledger/indy-sdk/pull/1397,TO Discuss: Should we clean previous error on success? ,c349adf2521f25d8cb95a3c986fb73151e8f3e30,2019-01-11 16:31:26,247176755,"@@ -1,46 +1,66 @@
-macro_rules! result_to_err_code {
-    ($result:ident) => {
+macro_rules! prepare_result {
+    ($result:ident) => {{
+        trace!(""prepare_result: >>> {:?}"", $result);
         match $result {
             Ok(_) => ErrorCode::Success,
-            Err(err) => err.into()
-        };
-    }
+            Err(err) => {
+                set_last_error(&err);
+                err.into()
+            }
+        }
+    }}
 }
 
-macro_rules! result_to_err_code_1 {
-    ($result:ident, $default_value:expr) => {
+macro_rules! prepare_result_1 {
+    ($result:ident, $default_value:expr) => {{
+        trace!(""prepare_result_1: >>> {:?}"", $result);
         match $result {
             Ok(res) => (ErrorCode::Success, res),
-            Err(err) => (err.into(), $default_value)
-        };
-    }
+            Err(err) => {
+                set_last_error(&err);
+                (err.into(), $default_value)
+            }
+        }
+    }}
 }
 
-macro_rules! result_to_err_code_2 {
-    ($result:ident, $default_value1:expr, $default_value2:expr) => {
+macro_rules! prepare_result_2 {
+    ($result:ident, $default_value1:expr, $default_value2:expr) => {{
+        trace!(""prepare_result_2: >>> {:?}"", $result);
         match $result {
             Ok((res1, res2)) => (ErrorCode::Success, res1, res2),
-            Err(err) => (err.into(), $default_value1, $default_value2)
-        };
-    }
+            Err(err) => {",47,2019-01-14 13:41:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/247176755,https://github.com/hyperledger/indy-sdk/pull/1397#discussion_r247176755,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1397,https://github.com/hyperledger/indy-sdk/pull/1397,Do we really need LAST_ERROR in prelude? ,c349adf2521f25d8cb95a3c986fb73151e8f3e30,2019-01-11 16:32:59,247177324,"@@ -2,15 +2,18 @@ use std::cell;
 use std::fmt;
 use std::io;
 use std::sync::Arc;
+use std::ffi::CString;
+use std::cell::RefCell;
 
 use failure::{Backtrace, Context, Fail};
 use indy_crypto::errors::IndyCryptoError;
 use log;
 
 use api::ErrorCode;
+use utils::ctypes;
 
 pub mod prelude {
-    pub use super::{err_msg, IndyError, IndyErrorExt, IndyErrorKind, IndyResult, IndyResultExt};
+    pub use super::{err_msg, IndyError, IndyErrorExt, IndyErrorKind, IndyResult, IndyResultExt, LAST_ERROR, set_last_error};",,2019-01-14 13:41:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/247177324,https://github.com/hyperledger/indy-sdk/pull/1397#discussion_r247177324,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1397,https://github.com/hyperledger/indy-sdk/pull/1397,Does it need to be public?,c349adf2521f25d8cb95a3c986fb73151e8f3e30,2019-01-11 16:33:30,247177520,"@@ -360,3 +426,17 @@ impl<E> IndyErrorExt for E where E: Fail
     }
 }
 
+thread_local! {
+    pub static LAST_ERROR: RefCell<Option<CString>> = RefCell::new(None);",,2019-01-14 13:41:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/247177520,https://github.com/hyperledger/indy-sdk/pull/1397#discussion_r247177520,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1397,https://github.com/hyperledger/indy-sdk/pull/1397,"we can get access to thread variable only inside `with` closure.
we can avoid making LAST_ERROR public by adding setter which accepts `*mut *const c_char` param (in my opinion this worse).  ",c349adf2521f25d8cb95a3c986fb73151e8f3e30,2019-01-14 07:12:41,247396984,"@@ -360,3 +426,17 @@ impl<E> IndyErrorExt for E where E: Fail
     }
 }
 
+thread_local! {
+    pub static LAST_ERROR: RefCell<Option<CString>> = RefCell::new(None);",,2019-01-14 13:41:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/247396984,https://github.com/hyperledger/indy-sdk/pull/1397#discussion_r247396984,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1394,https://github.com/hyperledger/indy-sdk/pull/1394,There is `_submit_retry` helper in other cli test module. I suggest to re-use it,a0b0e70cc22a199d12b78e31fbae300b16819901,2019-01-10 11:26:01,246724021,"@@ -659,11 +660,44 @@ pub mod tests {
 
     mod did_rotate_key {
         use super::*;
+        use std::thread::sleep;
+        use std::time::Duration;
         #[cfg(feature = ""nullpay_plugin"")]
         use commands::common::tests::load_null_payment_plugin;
         #[cfg(feature = ""nullpay_plugin"")]
         use commands::ledger::tests::{set_fees, create_address_and_mint_sources, get_source_input, FEES, OUTPUT};
 
+        fn ensure_nym_written(ctx: &CommandContext, did: &str, verkey: &str) {
+            let pool_handle = ensure_connected_pool_handle(ctx).unwrap();
+            let wallet_handle = ensure_opened_wallet_handle(ctx).unwrap();
+            let mut cnt = 0;
+            while cnt <= 3 {",,2019-01-11 09:43:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/246724021,https://github.com/hyperledger/indy-sdk/pull/1394#discussion_r246724021,jovfer
https://github.com/hyperledger/indy-sdk/pull/1394,https://github.com/hyperledger/indy-sdk/pull/1394,Re-used,a0b0e70cc22a199d12b78e31fbae300b16819901,2019-01-10 13:04:05,246749974,"@@ -659,11 +660,44 @@ pub mod tests {
 
     mod did_rotate_key {
         use super::*;
+        use std::thread::sleep;
+        use std::time::Duration;
         #[cfg(feature = ""nullpay_plugin"")]
         use commands::common::tests::load_null_payment_plugin;
         #[cfg(feature = ""nullpay_plugin"")]
         use commands::ledger::tests::{set_fees, create_address_and_mint_sources, get_source_input, FEES, OUTPUT};
 
+        fn ensure_nym_written(ctx: &CommandContext, did: &str, verkey: &str) {
+            let pool_handle = ensure_connected_pool_handle(ctx).unwrap();
+            let wallet_handle = ensure_opened_wallet_handle(ctx).unwrap();
+            let mut cnt = 0;
+            while cnt <= 3 {",,2019-01-11 09:43:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/246749974,https://github.com/hyperledger/indy-sdk/pull/1394#discussion_r246749974,KitHat
https://github.com/hyperledger/indy-sdk/pull/1394,https://github.com/hyperledger/indy-sdk/pull/1394,"```suggestion
```",a0b0e70cc22a199d12b78e31fbae300b16819901,2019-01-11 09:37:33,247052774,"@@ -664,6 +665,28 @@ pub mod tests {
         #[cfg(feature = ""nullpay_plugin"")]
         use commands::ledger::tests::{set_fees, create_address_and_mint_sources, get_source_input, FEES, OUTPUT};
 
+        fn ensure_nym_written(ctx: &CommandContext, did: &str, verkey: &str) {
+            let wallet_handle = ensure_opened_wallet_handle(ctx).unwrap();
+            let request = Ledger::build_get_nym_request(None, did).unwrap();
+            let request = Ledger::sign_request(wallet_handle, did, &request).unwrap();
+            submit_retry(ctx, &request, |response| {
+                let res = req_for_nym(response);
+                match res {
+                    Some(ref verkey_received) if verkey_received == verkey => Ok(()),
+                    _ => Err(())
+                }
+            }).unwrap()
+        }
+
+        fn req_for_nym(response: &str) -> Option<String> {
+            let parsed = serde_json::from_str::<serde_json::Value>(&response).ok()?;
+            let parsed = parsed.as_object()?;",,2019-01-11 09:43:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/247052774,https://github.com/hyperledger/indy-sdk/pull/1394#discussion_r247052774,jovfer
https://github.com/hyperledger/indy-sdk/pull/1378,https://github.com/hyperledger/indy-sdk/pull/1378,"In current codebase we have some lack of unit-tests coverage.
@mattraffel please fix it for updated functionality: add something like `request_handler_process_reqnack_event_from_consensus_state_works_for_consensus_reached` but for mixed events. E.g. check what for 4 nodes in pool 1 NACK + 1 REJECT hasn't finished request processing.",5c4fe1fbfe3f74f1d751ecac0a3974dd6932ce88,2018-12-29 22:07:48,244514120,"@@ -285,7 +285,10 @@ impl<T: Networker> RequestSM<T> {
             }
             RequestState::Consensus(mut state) => {
                 match re {
-                    RequestEvent::Reply(_, raw_msg, node_alias, req_id) => {
+                    RequestEvent::Reply(_, raw_msg, node_alias, req_id) |",5,2019-01-09 18:19:01,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/244514120,https://github.com/hyperledger/indy-sdk/pull/1378#discussion_r244514120,jovfer
https://github.com/hyperledger/indy-sdk/pull/1378,https://github.com/hyperledger/indy-sdk/pull/1378,Probably we should duplicate some test-cases for single and consensus types,5c4fe1fbfe3f74f1d751ecac0a3974dd6932ce88,2018-12-29 22:12:41,244514416,"@@ -285,7 +285,10 @@ impl<T: Networker> RequestSM<T> {
             }
             RequestState::Consensus(mut state) => {
                 match re {
-                    RequestEvent::Reply(_, raw_msg, node_alias, req_id) => {
+                    RequestEvent::Reply(_, raw_msg, node_alias, req_id) |",5,2019-01-09 18:19:01,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/244514416,https://github.com/hyperledger/indy-sdk/pull/1378#discussion_r244514416,jovfer
https://github.com/hyperledger/indy-sdk/pull/1378,https://github.com/hyperledger/indy-sdk/pull/1378,"Added a test case for mixed events.   I can add more if needed.  I do not understand the other request to ""duplicate some test-cases"".  Not sure what we should be duplicating and changing.  Can you clarify?",5c4fe1fbfe3f74f1d751ecac0a3974dd6932ce88,2019-01-07 17:44:10,245739362,"@@ -285,7 +285,10 @@ impl<T: Networker> RequestSM<T> {
             }
             RequestState::Consensus(mut state) => {
                 match re {
-                    RequestEvent::Reply(_, raw_msg, node_alias, req_id) => {
+                    RequestEvent::Reply(_, raw_msg, node_alias, req_id) |",5,2019-01-09 18:19:01,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/245739362,https://github.com/hyperledger/indy-sdk/pull/1378#discussion_r245739362,mattraffel
https://github.com/hyperledger/indy-sdk/pull/1378,https://github.com/hyperledger/indy-sdk/pull/1378,"I have some concerns about this test.
First we create a request handler with 1 node and `f = 0`. Then we send to it 3 responses -- it just doesn't make sense.
What I suggest to do is to write a test that would fail before and pass right now.
Example:
* Create a request handler with 4 nodes and `f = 1`
* Start with sending a `CustomConsensusEvent`
* Send one `Reply` and two `Reject`messages with different data in each `Reject`
* Check that state of request handler is still not finished
* Send one more `Reject` with data that equals to one of the previous `Reject` messages
* Check that state of request handler changed to `Finish`

I think that this one will be enough to verify the changes made for consensus case and reject. The same test should implemented for renack and both of them for single case.",5c4fe1fbfe3f74f1d751ecac0a3974dd6932ce88,2019-01-09 11:40:13,246351329,"@@ -945,6 +928,16 @@ pub mod tests {
             assert_match!(RequestState::Finish(_), request_handler.request_wrapper.unwrap().state);
         }
 
+        #[test]
+        fn request_handler_process_reply_event_from_consensus_state_works_for_consensus_reached_with_mixed_msgs() {",64,2019-01-09 18:19:01,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/246351329,https://github.com/hyperledger/indy-sdk/pull/1378#discussion_r246351329,KitHat
https://github.com/hyperledger/indy-sdk/pull/1371,https://github.com/hyperledger/indy-sdk/pull/1371,"It isn't good idea to use ""map"" for side effect action. Simple ""if let"" will be better. Anyway we will merge it fix during merging changes from Wrapper Errors PR.  ",81e6e13757a5a1274adaa3f4f8be8c70ab65744c,2019-01-21 08:16:57,249354397,"@@ -301,11 +302,21 @@ pub mod delete_command {
         let id = get_str_param(""name"", params).map_err(error_err!())?;
         let key = get_str_param(""key"", params).map_err(error_err!())?;
         let key_derivation_method = get_opt_str_param(""key_derivation_method"", params).map_err(error_err!())?;
+        let storage_credentials = get_opt_object_param(""storage_credentials"", params).map_err(error_err!())?;
 
         let config = _read_wallet_config(id)
             .map_err(|_| println_err!(""Wallet \""{}\"" isn't attached to CLI"", id))?;
 
-        let credentials: String = json!({ ""key"": key.clone(), ""key_derivation_method"": map_key_derivation_method(key_derivation_method)? }).to_string();
+        let credentials = {
+            let mut json = JSONMap::new();
+
+            json.insert(""key"".to_string(), serde_json::Value::String(key.to_string()));
+            json.insert(""key_derivation_method"".to_string(), serde_json::Value::String(map_key_derivation_method(key_derivation_method)?.to_string()));
+
+            storage_credentials.map(|creds| json.insert(""storage_credentials"".to_string(), creds));",24,2019-01-21 08:16:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249354397,https://github.com/hyperledger/indy-sdk/pull/1371#discussion_r249354397,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1365,https://github.com/hyperledger/indy-sdk/pull/1365,Is it intentional to remove last two items from the list?,e90d6e6896ab1fd5c787835d3a8a9f203f1b921a,2019-01-23 10:02:41,250125352,"@@ -1,26 +1,25 @@
-﻿# Getting Started with Libindy
+﻿# Indy Walkthrough
 
 ## A Developer Guide for Building Indy Clients Using Libindy
 
 ![logo](https://raw.githubusercontent.com/hyperledger/indy-node/master/collateral/logos/indy-logo.png)
 
-* [Getting Started with Libndy](#getting-started-with-libindy)
-  * [What Indy and Libindy are and Why They Matter](#what-indy-and-libindy-are-and-why-they-matter)
-  * [What We'll Cover](#what-well-cover)
-  * [About Alice](#about-alice)
-  * [Infrastructure Preparation](#infrastructure-preparation)
-      * [Step 1: Getting Trust Anchor Credentials for Faber, Acme, Thrift and Government](#step-1-getting-trust-anchor-credentials-for-faber-acme-thrift-and-government)
-      * [Step 2: Connecting to the Indy Nodes Pool](#step-2-connecting-to-the-indy-nodes-pool)
-      * [Step 3: Getting the Ownership for Stewards's Verinym](#step-3-getting-the-ownership-for-stewardss-verinym)
-      * [Step 4: Onboarding Faber, Acme, Thrift and Government by the Steward](#step-4-onboarding-faber-acme-thrift-and-government-by-steward)
-        * [Connecting the Establishment](#connecting-the-establishment)
-        * [Getting the Verinym](#getting-verinym)
-      * [Step 5: Credential Schemas Setup](#step-5-credential-schemas-setup)
-      * [Step 6: Credential Definition Setup](#step-6-credential-definition-setup)
-  * [Alice Gets a Transcript](#alice-gets-a-transcript)
-  * [Apply for a Job](#apply-for-a-job)
-  * [Apply for a Loan](#apply-for-a-loan)",23,2019-02-01 11:59:49,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/250125352,https://github.com/hyperledger/indy-sdk/pull/1365#discussion_r250125352,jovfer
https://github.com/hyperledger/indy-sdk/pull/1355,https://github.com/hyperledger/indy-sdk/pull/1355,is it possible to avoid duplication against `^/libindy/include`,513da40963453b67cd929b4b5f660a1f0e9b4437,2019-02-25 21:33:40,260027846,"@@ -0,0 +1,282 @@
+#ifndef __anoncreds__included__",1,2019-02-25 21:33:40,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/260027846,https://github.com/hyperledger/indy-sdk/pull/1355#discussion_r260027846,jovfer
https://github.com/hyperledger/indy-sdk/pull/1350,https://github.com/hyperledger/indy-sdk/pull/1350,Please remove `[Node.js](../../not-yet-written.md) |`,72da54ecb858148cbcb94fc1a09e085e24bb00f5,2018-12-12 05:44:22,240888233,"@@ -0,0 +1,76 @@
+# Rotate a Key
+
+Indy-SDK Developer Walkthrough #2, NodEJS Edition
+
+[ [Python](../python/README.md) | [Java](../java/README.md) | [.NET](../../not-yet-written.md) | [Node.js](../../not-yet-written.md) | [Objective C](../../not-yet-written.md) | [Rust](../rust/README.md)]
+",6,2018-12-12 08:34:02,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/240888233,https://github.com/hyperledger/indy-sdk/pull/1350#discussion_r240888233,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1350,https://github.com/hyperledger/indy-sdk/pull/1350,@Artemkaaas Done :-),72da54ecb858148cbcb94fc1a09e085e24bb00f5,2018-12-12 08:34:25,240919868,"@@ -0,0 +1,76 @@
+# Rotate a Key
+
+Indy-SDK Developer Walkthrough #2, NodEJS Edition
+
+[ [Python](../python/README.md) | [Java](../java/README.md) | [.NET](../../not-yet-written.md) | [Node.js](../../not-yet-written.md) | [Objective C](../../not-yet-written.md) | [Rust](../rust/README.md)]
+",6,2018-12-12 08:34:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/240919868,https://github.com/hyperledger/indy-sdk/pull/1350#discussion_r240919868,xaviernopre
https://github.com/hyperledger/indy-sdk/pull/1338,https://github.com/hyperledger/indy-sdk/pull/1338,"Why did you remove `libindy`?
Seems it didn't work https://github.com/hyperledger/indy-sdk/pull/1338/files#diff-784e48cf773f094f413c2349c36392f4R488 ?

CI fialed with:
`[ios-test] 
[ios-test] Testing failed:
[ios-test] 	'indy_core.h' file not found
[ios-test] 	'libindy/indy_types.h' file not found
[ios-test] ** TEST FAILED **` 

Maybe we should update our pipeline too? 
https://github.com/hyperledger/indy-sdk/blob/master/Jenkinsfile.ci#L232

I already have tried to comment 56 and 57 lines.",21921b8ef22981ad4d186c39f7cb14effc44dd1b,2018-12-11 06:23:34,240485260,"@@ -1,22 +1,23 @@
 source 'https://github.com/CocoaPods/Specs.git'
 source 'https://github.com/hyperledger/indy-sdk.git'
-platform :ios, '10.2'
+platform :ios, '12.1'
 
 workspace 'Indy.xcworkspace'
 
 def appPods
-    pod 'libsodium'
+    pod 'libsodium', ""1.0.12""
     pod 'libzmq',""4.2.3""
-    pod 'OpenSSL'
-    pod 'libindy', ""1.6.4-739""",13,2018-12-11 08:25:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/240485260,https://github.com/hyperledger/indy-sdk/pull/1338#discussion_r240485260,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1337,https://github.com/hyperledger/indy-sdk/pull/1337,What is the reason to specify fixed version here?,cb275f115ab9c6e95c1041d4541a462b2e17d4bf,2018-12-04 15:57:23,238723337,"@@ -30,7 +30,7 @@ log = { version = ""0.4.1"", features = [""std""] }
 num-traits = ""0.2""
 num-derive = ""0.2""
 indy-sys = { path =""indy-sys"", version = ""=1.6.8"" }
-libc = ""0.2.21""
+libc = ""=0.2.41""",5,2018-12-04 15:57:23,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/238723337,https://github.com/hyperledger/indy-sdk/pull/1337#discussion_r238723337,jovfer
https://github.com/hyperledger/indy-sdk/pull/1334,https://github.com/hyperledger/indy-sdk/pull/1334,Good catch.,d455650180175067798355fb2b798bc2348a978f,2018-12-04 14:41:54,238689364,"@@ -25,21 +27,23 @@ def test_default_logging():
 #
 # This test is skipped because Logger Cannot be
 # Initialized twice in the same process
-@pytest.mark.skip
-def test_set_logger():
+@pytest.mark.asyncio
+@pytest.mark.usefixtures('vcx_init_test_mode')
+async def test_set_logger():
     num_entries = c_int(0)
 
     assert (num_entries.value == 0)
 
     def _log_fn(_level, _target, _message, _module_path, _file, _line):
+        print(_message.decode())
         num_entries.value += 1
 
     try:
         set_logger(_log_fn)
     except VcxError as e:
         pytest.fail(""Error in VcxLogger.set_logger: %s"", e)
 
-    error_message(1000)
+    await Connection.create('123')  # complex async LibVCX call",,2018-12-07 10:32:09,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/238689364,https://github.com/hyperledger/indy-sdk/pull/1334#discussion_r238689364,hadleym
https://github.com/hyperledger/indy-sdk/pull/1334,https://github.com/hyperledger/indy-sdk/pull/1334,"This is much cleaner, now.",d455650180175067798355fb2b798bc2348a978f,2018-12-04 15:06:22,238699839,"@@ -34,10 +34,20 @@ def do_call(name: str, *args):
     return future
 
 
+def do_call_sync(name: str, *args):",15,2018-12-07 10:32:09,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/238699839,https://github.com/hyperledger/indy-sdk/pull/1334#discussion_r238699839,hadleym
https://github.com/hyperledger/indy-sdk/pull/1332,https://github.com/hyperledger/indy-sdk/pull/1332,"It will panic for an empty array.
I think better use:
`array_type.get(0).and_then(serde_json::Value::as_str)`",81b39570c6d8ecbfb9829b7d8071c88ac01ce02e,2018-12-14 05:57:03,241650604,"@@ -392,28 +416,41 @@ pub fn encode_attributes(attributes: &str) -> Result<String, IssuerCredError> {
         }
     };
 
-    for (attr, vec) in map.iter_mut(){
-        let list = match vec.as_array_mut() {
-            Some(x) => x,
-            None => {
+    let mut dictionary = HashMap::new();
+
+    for (attr, attr_data) in map.iter_mut(){
+        let first_attr : String = match attr_data {
+            serde_json::Value::Array(array_type) => {
+
+                let i = &array_type[0];
+                let attrib_value = match i.as_str(){",,2018-12-17 21:11:33,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/241650604,https://github.com/hyperledger/indy-sdk/pull/1332#discussion_r241650604,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1332,https://github.com/hyperledger/indy-sdk/pull/1332,Here is redundant creation of String. You can leave &str in both cases.,81b39570c6d8ecbfb9829b7d8071c88ac01ce02e,2018-12-14 06:00:00,241650960,"@@ -392,28 +416,41 @@ pub fn encode_attributes(attributes: &str) -> Result<String, IssuerCredError> {
         }
     };
 
-    for (attr, vec) in map.iter_mut(){
-        let list = match vec.as_array_mut() {
-            Some(x) => x,
-            None => {
+    let mut dictionary = HashMap::new();
+
+    for (attr, attr_data) in map.iter_mut(){
+        let first_attr : String = match attr_data {
+            serde_json::Value::Array(array_type) => {
+
+                let i = &array_type[0];
+                let attrib_value = match i.as_str(){
+                    Some(v) => v,
+                    None => {
+                        warn!(""Cannot encode attribute: {}"", error::INVALID_ATTRIBUTES_STRUCTURE.message);
+                        return Err(IssuerCredError::CommonError(error::INVALID_ATTRIBUTES_STRUCTURE.code_num))
+                    },
+                };
+
+                warn!(""Old attribute format detected. See vcx_issuer_create_credential api for additional information."");
+                attrib_value.to_string()",,2018-12-17 21:11:33,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/241650960,https://github.com/hyperledger/indy-sdk/pull/1332#discussion_r241650960,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1332,https://github.com/hyperledger/indy-sdk/pull/1332,Maybe better to use `encode` function to get expected values instead of hardcoded?,81b39570c6d8ecbfb9829b7d8071c88ac01ce02e,2018-12-14 06:01:59,241651171,"@@ -1041,4 +1079,224 @@ pub mod tests {
         let payment = serde_json::to_string(&credential.get_payment_txn().unwrap()).unwrap();
         assert!(payment.len() > 20);
     }
+
+    #[test]
+    fn test_encode_with_several_attributes_success() {
+
+        /*
+        for reference....expectation is encode_attributes returns this:
+
+        let expected = json!({
+          ""address2"": {
+            ""encoded"": ""68086943237164982734333428280784300550565381723532936263016368251445461241953"",
+            ""raw"": ""101 Wilson Lane""
+          },
+          ""zip"": {
+            ""encoded"": ""87121"",
+            ""raw"": ""87121""
+          },
+          ""city"": {
+            ""encoded"": ""101327353979588246869873249766058188995681113722618593621043638294296500696424"",
+            ""raw"": ""SLC""
+          },
+          ""address1"": {
+            ""encoded"": ""63690509275174663089934667471948380740244018358024875547775652380902762701972"",
+            ""raw"": ""101 Tela Lane""
+          },
+          ""state"": {
+            ""encoded"": ""93856629670657830351991220989031130499313559332549427637940645777813964461231"",
+            ""raw"": ""UT""
+          }
+        });
+        */
+
+        static TEST_CREDENTIAL_DATA: &str =
+            r#""{""address2"":[""101 Wilson Lane""],
+            ""zip"":[""87121""],
+            ""state"":[""UT""],
+            ""city"":[""SLC""],
+            ""address1"":[""101 Tela Lane""]
+            }""#;
+
+        let results_json = encode_attributes(TEST_CREDENTIAL_DATA).unwrap();
+
+        let results : Value = serde_json::from_str(&results_json).unwrap();
+        let address2 : &Value = &results[""address2""];
+
+        assert_eq!(""68086943237164982734333428280784300550565381723532936263016368251445461241953"", address2[""encoded""]);",,2018-12-17 21:11:33,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/241651171,https://github.com/hyperledger/indy-sdk/pull/1332#discussion_r241651171,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1332,https://github.com/hyperledger/indy-sdk/pull/1332,"maybe better:
`        assert_eq!(IssuerCredError::CommonError(INVALID_JSON.code_num), encode_attributes(BAD_TEST_CREDENTIAL_DATA).unwrap_err());
`
or just
`assert!(encode_attributes(BAD_TEST_CREDENTIAL_DATA).is_err())`
instad of match ?",81b39570c6d8ecbfb9829b7d8071c88ac01ce02e,2018-12-14 06:09:53,241652031,"@@ -1041,4 +1079,224 @@ pub mod tests {
         let payment = serde_json::to_string(&credential.get_payment_txn().unwrap()).unwrap();
         assert!(payment.len() > 20);
     }
+
+    #[test]
+    fn test_encode_with_several_attributes_success() {
+
+        /*
+        for reference....expectation is encode_attributes returns this:
+
+        let expected = json!({
+          ""address2"": {
+            ""encoded"": ""68086943237164982734333428280784300550565381723532936263016368251445461241953"",
+            ""raw"": ""101 Wilson Lane""
+          },
+          ""zip"": {
+            ""encoded"": ""87121"",
+            ""raw"": ""87121""
+          },
+          ""city"": {
+            ""encoded"": ""101327353979588246869873249766058188995681113722618593621043638294296500696424"",
+            ""raw"": ""SLC""
+          },
+          ""address1"": {
+            ""encoded"": ""63690509275174663089934667471948380740244018358024875547775652380902762701972"",
+            ""raw"": ""101 Tela Lane""
+          },
+          ""state"": {
+            ""encoded"": ""93856629670657830351991220989031130499313559332549427637940645777813964461231"",
+            ""raw"": ""UT""
+          }
+        });
+        */
+
+        static TEST_CREDENTIAL_DATA: &str =
+            r#""{""address2"":[""101 Wilson Lane""],
+            ""zip"":[""87121""],
+            ""state"":[""UT""],
+            ""city"":[""SLC""],
+            ""address1"":[""101 Tela Lane""]
+            }""#;
+
+        let results_json = encode_attributes(TEST_CREDENTIAL_DATA).unwrap();
+
+        let results : Value = serde_json::from_str(&results_json).unwrap();
+        let address2 : &Value = &results[""address2""];
+
+        assert_eq!(""68086943237164982734333428280784300550565381723532936263016368251445461241953"", address2[""encoded""]);
+        assert_eq!(""101 Wilson Lane"", address2[""raw""]);
+
+        let state : &Value = &results[""state""];
+        assert_eq!(""93856629670657830351991220989031130499313559332549427637940645777813964461231"", state[""encoded""]);
+        assert_eq!(""UT"", state[""raw""]);
+
+        let zip : &Value = &results[""zip""];
+        assert_eq!(""87121"", zip[""encoded""]);
+        assert_eq!(""87121"", zip[""raw""]);
+
+    }
+
+    #[test]
+    fn test_encode_with_one_attribute_success() {
+
+        let expected = json!({
+          ""address2"": {
+            ""encoded"": ""68086943237164982734333428280784300550565381723532936263016368251445461241953"",
+            ""raw"": ""101 Wilson Lane""
+          }
+        });
+
+        static TEST_CREDENTIAL_DATA: &str =
+        r#""{""address2"":[""101 Wilson Lane""]}""#;
+
+        let expected_json = serde_json::to_string_pretty(&expected).unwrap();
+
+        let results_json = encode_attributes(TEST_CREDENTIAL_DATA).unwrap();
+
+        assert_eq!(expected_json, results_json, ""encode_attributes failed to return expected results"");
+    }
+
+    #[test]
+    fn test_encode_with_new_format_several_attributes_success() {
+
+        /*
+        for reference....expectation is encode_attributes returns this:
+
+        let expected = json!({
+          ""address2"": {
+            ""encoded"": ""68086943237164982734333428280784300550565381723532936263016368251445461241953"",
+            ""raw"": ""101 Wilson Lane""
+          },
+          ""zip"": {
+            ""encoded"": ""87121"",
+            ""raw"": ""87121""
+          },
+          ""city"": {
+            ""encoded"": ""101327353979588246869873249766058188995681113722618593621043638294296500696424"",
+            ""raw"": ""SLC""
+          },
+          ""address1"": {
+            ""encoded"": ""63690509275174663089934667471948380740244018358024875547775652380902762701972"",
+            ""raw"": ""101 Tela Lane""
+          },
+          ""state"": {
+            ""encoded"": ""93856629670657830351991220989031130499313559332549427637940645777813964461231"",
+            ""raw"": ""UT""
+          }
+        });
+        */
+
+        static TEST_CREDENTIAL_DATA: &str =
+            r#""{""address2"":""101 Wilson Lane"",
+            ""zip"":""87121"",
+            ""state"":""UT"",
+            ""city"":""SLC"",
+            ""address1"":""101 Tela Lane""
+            }""#;
+
+        let results_json = encode_attributes(TEST_CREDENTIAL_DATA).unwrap();
+
+        let results : Value = serde_json::from_str(&results_json).unwrap();
+        let address2 : &Value = &results[""address2""];
+
+        assert_eq!(""68086943237164982734333428280784300550565381723532936263016368251445461241953"", address2[""encoded""]);
+        assert_eq!(""101 Wilson Lane"", address2[""raw""]);
+
+        let state : &Value = &results[""state""];
+        assert_eq!(""93856629670657830351991220989031130499313559332549427637940645777813964461231"", state[""encoded""]);
+        assert_eq!(""UT"", state[""raw""]);
+
+        let zip : &Value = &results[""zip""];
+        assert_eq!(""87121"", zip[""encoded""]);
+        assert_eq!(""87121"", zip[""raw""]);
+
+    }
+
+    #[test]
+    fn test_encode_with_new_format_one_attribute_success() {
+
+        let expected = json!({
+          ""address2"": {
+            ""encoded"": ""68086943237164982734333428280784300550565381723532936263016368251445461241953"",
+            ""raw"": ""101 Wilson Lane""
+          }
+        });
+
+        static TEST_CREDENTIAL_DATA: &str =
+        r#""{""address2"": ""101 Wilson Lane""}""#;
+
+        let expected_json = serde_json::to_string_pretty(&expected).unwrap();
+
+        let results_json = encode_attributes(TEST_CREDENTIAL_DATA).unwrap();
+
+        assert_eq!(expected_json, results_json, ""encode_attributes failed to return expected results"");
+    }
+
+    #[test]
+    fn test_encode_with_mixed_format_several_attributes_success() {
+
+        /*
+        for reference....expectation is encode_attributes returns this:
+
+        let expected = json!({
+          ""address2"": {
+            ""encoded"": ""68086943237164982734333428280784300550565381723532936263016368251445461241953"",
+            ""raw"": ""101 Wilson Lane""
+          },
+          ""zip"": {
+            ""encoded"": ""87121"",
+            ""raw"": ""87121""
+          },
+          ""city"": {
+            ""encoded"": ""101327353979588246869873249766058188995681113722618593621043638294296500696424"",
+            ""raw"": ""SLC""
+          },
+          ""address1"": {
+            ""encoded"": ""63690509275174663089934667471948380740244018358024875547775652380902762701972"",
+            ""raw"": ""101 Tela Lane""
+          },
+          ""state"": {
+            ""encoded"": ""93856629670657830351991220989031130499313559332549427637940645777813964461231"",
+            ""raw"": ""UT""
+          }
+        });
+        */
+
+        static TEST_CREDENTIAL_DATA: &str =
+            r#""{""address2"":[""101 Wilson Lane""],
+            ""zip"":""87121"",
+            ""state"":""UT"",
+            ""city"":[""SLC""],
+            ""address1"":""101 Tela Lane""
+            }""#;
+
+        let results_json = encode_attributes(TEST_CREDENTIAL_DATA).unwrap();
+
+        let results : Value = serde_json::from_str(&results_json).unwrap();
+        let address2 : &Value = &results[""address2""];
+
+        assert_eq!(""68086943237164982734333428280784300550565381723532936263016368251445461241953"", address2[""encoded""]);
+        assert_eq!(""101 Wilson Lane"", address2[""raw""]);
+
+        let state : &Value = &results[""state""];
+        assert_eq!(""93856629670657830351991220989031130499313559332549427637940645777813964461231"", state[""encoded""]);
+        assert_eq!(""UT"", state[""raw""]);
+
+        let zip : &Value = &results[""zip""];
+        assert_eq!(""87121"", zip[""encoded""]);
+        assert_eq!(""87121"", zip[""raw""]);
+
+    }
+
+    #[test]
+    fn test_encode_bad_format_returns_error()
+    {
+        static BAD_TEST_CREDENTIAL_DATA: &str =
+            r#""{""format doesnt make sense""}""#;
+
+        match encode_attributes(BAD_TEST_CREDENTIAL_DATA) {
+            Ok(_) => assert!(false, ""expected an error from encode_attributes""),
+            Err(_) => {}
+        }",,2018-12-17 21:11:33,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/241652031,https://github.com/hyperledger/indy-sdk/pull/1332#discussion_r241652031,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1332,https://github.com/hyperledger/indy-sdk/pull/1332,"Why did you leave this mapping? It is absolutely useless.
`
> var attr = {key: ""value""}
> const attrsVCX = Object.keys(attr).reduce((accum, attrKey) => ({ ...accum, [attrKey]: attr[attrKey] }), {})
> console.log(attrsVCX)
{ key: 'value' }
`

An interface `IIssuerCredentialVCXAttributes` should be changed also because it specifies the old format.",81b39570c6d8ecbfb9829b7d8071c88ac01ce02e,2018-12-17 05:41:40,242030671,"@@ -67,7 +67,7 @@ export class IssuerCredential extends VCXBaseWithState<IIssuerCredentialData> {
                          credentialName, price }: IIssuerCredentialCreateData): Promise<IssuerCredential> {
     try {
       const attrsVCX: IIssuerCredentialVCXAttributes = Object.keys(attr)
-      .reduce((accum, attrKey) => ({ ...accum, [attrKey]: [attr[attrKey]] }), {})
+      .reduce((accum, attrKey) => ({ ...accum, [attrKey]: attr[attrKey] }), {})",,2018-12-17 21:11:33,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/242030671,https://github.com/hyperledger/indy-sdk/pull/1332#discussion_r242030671,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1332,https://github.com/hyperledger/indy-sdk/pull/1332,I needed someone to review to confirm that code wasn't needed any more.  correction checked in.,81b39570c6d8ecbfb9829b7d8071c88ac01ce02e,2018-12-17 21:11:24,242317386,"@@ -67,7 +67,7 @@ export class IssuerCredential extends VCXBaseWithState<IIssuerCredentialData> {
                          credentialName, price }: IIssuerCredentialCreateData): Promise<IssuerCredential> {
     try {
       const attrsVCX: IIssuerCredentialVCXAttributes = Object.keys(attr)
-      .reduce((accum, attrKey) => ({ ...accum, [attrKey]: [attr[attrKey]] }), {})
+      .reduce((accum, attrKey) => ({ ...accum, [attrKey]: attr[attrKey] }), {})",,2018-12-17 21:11:33,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/242317386,https://github.com/hyperledger/indy-sdk/pull/1332#discussion_r242317386,mattraffel
https://github.com/hyperledger/indy-sdk/pull/1332,https://github.com/hyperledger/indy-sdk/pull/1332,@glowkey @mattraffel should we handle array[2] as specific case when encoding already done by application level? Or may be we should accept only array of single element.,81b39570c6d8ecbfb9829b7d8071c88ac01ce02e,2018-12-18 09:33:32,242462678,"@@ -392,28 +416,45 @@ pub fn encode_attributes(attributes: &str) -> Result<String, IssuerCredError> {
         }
     };
 
-    for (attr, vec) in map.iter_mut(){
-        let list = match vec.as_array_mut() {
-            Some(x) => x,
-            None => {
+    let mut dictionary = HashMap::new();
+
+    for (attr, attr_data) in map.iter_mut(){
+        let first_attr : &str = match attr_data {
+            // old style input such as {""address2"":[""101 Wilson Lane""]}
+            serde_json::Value::Array(array_type) => {
+
+                let attrib_value : &str = match array_type.get(0).and_then(serde_json::Value::as_str) {",68,2018-12-18 09:33:33,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/242462678,https://github.com/hyperledger/indy-sdk/pull/1332#discussion_r242462678,jovfer
https://github.com/hyperledger/indy-sdk/pull/1332,https://github.com/hyperledger/indy-sdk/pull/1332,"I feel that is a change in scope and separate story.   From what I see in the code, our API is documented that the inputs are raw, not encoded.  So if a consumer is encoding the input prior, its new/different functionality.",81b39570c6d8ecbfb9829b7d8071c88ac01ce02e,2018-12-18 14:26:06,242556268,"@@ -392,28 +416,45 @@ pub fn encode_attributes(attributes: &str) -> Result<String, IssuerCredError> {
         }
     };
 
-    for (attr, vec) in map.iter_mut(){
-        let list = match vec.as_array_mut() {
-            Some(x) => x,
-            None => {
+    let mut dictionary = HashMap::new();
+
+    for (attr, attr_data) in map.iter_mut(){
+        let first_attr : &str = match attr_data {
+            // old style input such as {""address2"":[""101 Wilson Lane""]}
+            serde_json::Value::Array(array_type) => {
+
+                let attrib_value : &str = match array_type.get(0).and_then(serde_json::Value::as_str) {",68,2018-12-18 14:26:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/242556268,https://github.com/hyperledger/indy-sdk/pull/1332#discussion_r242556268,mattraffel
https://github.com/hyperledger/indy-sdk/pull/1332,https://github.com/hyperledger/indy-sdk/pull/1332,agree,81b39570c6d8ecbfb9829b7d8071c88ac01ce02e,2018-12-18 16:38:17,242612571,"@@ -392,28 +416,45 @@ pub fn encode_attributes(attributes: &str) -> Result<String, IssuerCredError> {
         }
     };
 
-    for (attr, vec) in map.iter_mut(){
-        let list = match vec.as_array_mut() {
-            Some(x) => x,
-            None => {
+    let mut dictionary = HashMap::new();
+
+    for (attr, attr_data) in map.iter_mut(){
+        let first_attr : &str = match attr_data {
+            // old style input such as {""address2"":[""101 Wilson Lane""]}
+            serde_json::Value::Array(array_type) => {
+
+                let attrib_value : &str = match array_type.get(0).and_then(serde_json::Value::as_str) {",68,2018-12-18 16:38:17,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/242612571,https://github.com/hyperledger/indy-sdk/pull/1332#discussion_r242612571,jovfer
https://github.com/hyperledger/indy-sdk/pull/1326,https://github.com/hyperledger/indy-sdk/pull/1326,"I suggest reverting these changes. 
We already fixed indy-sys to use `libc` types.",e32f0636f1729add486ac92efcce2976bb0137f3,2018-12-05 10:40:09,239013039,"@@ -24,7 +26,7 @@ mod log_tests {
     use indy::future::Future;
 
     static mut COUNT: u32 = 0;
-    extern fn custom_log(_context: *const c_void,",,2018-12-05 14:41:55,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/239013039,https://github.com/hyperledger/indy-sdk/pull/1326#discussion_r239013039,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1322,https://github.com/hyperledger/indy-sdk/pull/1322,rm,56b9d8afdc077fe83bd26de7d40d92317ccbca2f,2018-11-29 09:36:34,237410681,"@@ -1948,6 +2090,7 @@ mod medium_cases {
 
             let node_request = ledger::build_node_request(&did, &did, NODE_DATA).unwrap();
             let response = ledger::sign_and_submit_request(pool_handle, wallet_handle, &did, &node_request).unwrap();
+            println!(""{}"", response);",,2018-11-30 12:27:47,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/237410681,https://github.com/hyperledger/indy-sdk/pull/1322#discussion_r237410681,jovfer
https://github.com/hyperledger/indy-sdk/pull/1322,https://github.com/hyperledger/indy-sdk/pull/1322,Is this logic same for read and write requests?,56b9d8afdc077fe83bd26de7d40d92317ccbca2f,2018-11-29 09:38:12,237411240,"@@ -542,21 +542,70 @@ impl LedgerService {
         Ok(res)
     }
 
-    pub fn parse_response<T>(response: &str) -> Result<Reply<T>, LedgerError> where T: DeserializeOwned + ReplyType {
+    pub fn get_response_metadata(&self, response: &str) -> Result<String, LedgerError> {
+        info!(""get_response_metadata >>> response: {:?}"", response);
+
+        let message: Message<serde_json::Value> = serde_json::from_str(response)
+            .map_err(|err|
+                LedgerError::InvalidTransaction(format!(""Cannot deserialize transaction Response: {:?}"", err)))?;
+
+        let response_object: Reply<serde_json::Value> = LedgerService::handle_response_message_type(message)?;
+        let response_result = response_object.result();
+
+        let response_metadata = match response_result[""ver""].as_str() {",24,2018-11-30 12:27:47,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/237411240,https://github.com/hyperledger/indy-sdk/pull/1322#discussion_r237411240,jovfer
https://github.com/hyperledger/indy-sdk/pull/1322,https://github.com/hyperledger/indy-sdk/pull/1322,yes,56b9d8afdc077fe83bd26de7d40d92317ccbca2f,2018-11-29 10:09:04,237422429,"@@ -542,21 +542,70 @@ impl LedgerService {
         Ok(res)
     }
 
-    pub fn parse_response<T>(response: &str) -> Result<Reply<T>, LedgerError> where T: DeserializeOwned + ReplyType {
+    pub fn get_response_metadata(&self, response: &str) -> Result<String, LedgerError> {
+        info!(""get_response_metadata >>> response: {:?}"", response);
+
+        let message: Message<serde_json::Value> = serde_json::from_str(response)
+            .map_err(|err|
+                LedgerError::InvalidTransaction(format!(""Cannot deserialize transaction Response: {:?}"", err)))?;
+
+        let response_object: Reply<serde_json::Value> = LedgerService::handle_response_message_type(message)?;
+        let response_result = response_object.result();
+
+        let response_metadata = match response_result[""ver""].as_str() {",24,2018-11-30 12:27:47,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/237422429,https://github.com/hyperledger/indy-sdk/pull/1322#discussion_r237422429,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1320,https://github.com/hyperledger/indy-sdk/pull/1320,As for now `setupRust` isn't used in ubuntu/redhat branches. As result future `cargo clippy` will fail. Please add `setupRust` for linuxTesting and similar steps,0c1b4d1ff7837d3663dda890c677776145206de6,2018-12-10 13:36:25,240210606,"@@ -1251,6 +1258,7 @@ def downloadPackagingUtils() {
 
 def setupRust() {
     sh ""rustup default 1.29.0""
+    sh ""rustup component add clippy-preview""",,2019-02-28 23:50:40,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/240210606,https://github.com/hyperledger/indy-sdk/pull/1320#discussion_r240210606,jovfer
https://github.com/hyperledger/indy-sdk/pull/1320,https://github.com/hyperledger/indy-sdk/pull/1320,I decided it would be better to run static analysis as a separate stage. Adding clippy is abstracted to a different section now and should work on linux systems.,0c1b4d1ff7837d3663dda890c677776145206de6,2018-12-10 22:11:08,240400883,"@@ -1251,6 +1258,7 @@ def downloadPackagingUtils() {
 
 def setupRust() {
     sh ""rustup default 1.29.0""
+    sh ""rustup component add clippy-preview""",,2019-02-28 23:50:40,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/240400883,https://github.com/hyperledger/indy-sdk/pull/1320#discussion_r240400883,stevengubler
https://github.com/hyperledger/indy-sdk/pull/1320,https://github.com/hyperledger/indy-sdk/pull/1320,"you should use docker here
```
    node('ubuntu') {
        checkout scm
        def testEnv = buildTestEnv(""ci/ubuntu.dockerfile ci"", ""Ubuntu"")

        testEnv.inside {
            setupRust()
            sh ""rustup component add clippy-preview""
            sh ""cd ${dir} && cargo clippy -- -W clippy::style -W clippy::correctness -W clippy::complexity -W clippy::perf""
        }
    }
```",0c1b4d1ff7837d3663dda890c677776145206de6,2018-12-12 15:43:01,241066364,"@@ -92,6 +95,23 @@ def notifyingFailure() {
     }
 }
 
+def staticValidation() {
+    parallel([
+        'libindy'    : { runValdiationRust('libindy') },
+        'libnullpay' : { runValdiationRust('libnullpay') },
+        'libvcx'     : { runValdiationRust('vcx/libvcx') }
+    ])
+}
+
+def runValdiationRust(dir) {
+    node('ubuntu') {
+        setupRust()
+        sh ""rustup component add clippy-preview""
+        sh ""cd ${dir}""
+        sh ""cargo clippy -- -W clippy::style -W clippy::correctness -W clippy::complexity -W clippy::perf""
+    }
+}",37,2019-02-28 23:50:40,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/241066364,https://github.com/hyperledger/indy-sdk/pull/1320#discussion_r241066364,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1320,https://github.com/hyperledger/indy-sdk/pull/1320,"What's the advantage to using docker here? Having to build the dockerfile adds a significant amount of time to the whole process. 
I understand the logic of avoiding installing clippy on the native executors, but I'm not sure the trade-off is worth it.",0c1b4d1ff7837d3663dda890c677776145206de6,2018-12-12 23:21:00,241221904,"@@ -92,6 +95,23 @@ def notifyingFailure() {
     }
 }
 
+def staticValidation() {
+    parallel([
+        'libindy'    : { runValdiationRust('libindy') },
+        'libnullpay' : { runValdiationRust('libnullpay') },
+        'libvcx'     : { runValdiationRust('vcx/libvcx') }
+    ])
+}
+
+def runValdiationRust(dir) {
+    node('ubuntu') {
+        setupRust()
+        sh ""rustup component add clippy-preview""
+        sh ""cd ${dir}""
+        sh ""cargo clippy -- -W clippy::style -W clippy::correctness -W clippy::complexity -W clippy::perf""
+    }
+}",37,2019-02-28 23:50:40,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/241221904,https://github.com/hyperledger/indy-sdk/pull/1320#discussion_r241221904,stevengubler
https://github.com/hyperledger/indy-sdk/pull/1320,https://github.com/hyperledger/indy-sdk/pull/1320,"There is no rust on native executors.
Building the dockerfile takes a long time only for the first time or when dockerfile has been changed.  The cache will be used for next buildings. We use common dockerfile for testing on ubuntu. So, using docker file doesn't affect our CI significantly. ",0c1b4d1ff7837d3663dda890c677776145206de6,2018-12-13 05:34:31,241275946,"@@ -92,6 +95,23 @@ def notifyingFailure() {
     }
 }
 
+def staticValidation() {
+    parallel([
+        'libindy'    : { runValdiationRust('libindy') },
+        'libnullpay' : { runValdiationRust('libnullpay') },
+        'libvcx'     : { runValdiationRust('vcx/libvcx') }
+    ])
+}
+
+def runValdiationRust(dir) {
+    node('ubuntu') {
+        setupRust()
+        sh ""rustup component add clippy-preview""
+        sh ""cd ${dir}""
+        sh ""cargo clippy -- -W clippy::style -W clippy::correctness -W clippy::complexity -W clippy::perf""
+    }
+}",37,2019-02-28 23:50:40,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/241275946,https://github.com/hyperledger/indy-sdk/pull/1320#discussion_r241275946,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1320,https://github.com/hyperledger/indy-sdk/pull/1320,"- there is no file `ci/static-validation.dockerfile` in indy-sdk repo
- add `checkout scm` before building test env
- use this instead `def testEnv = dockerBuild('static-validation-ubuntu', ""ci/static-validation.dockerfile ci"")`",0c1b4d1ff7837d3663dda890c677776145206de6,2019-01-10 12:06:59,246734661,"@@ -92,6 +95,24 @@ def notifyingFailure() {
     }
 }
 
+def staticValidation() {
+    parallel([
+        'libindy'    : { runValdiationRust('libindy') },
+        'libnullpay' : { runValdiationRust('libnullpay') },
+        'libvcx'     : { runValdiationRust('vcx/libvcx') },
+        'cli'        : { runValdiationRust('cli') }
+    ])
+}
+
+def runValdiationRust(dir) {
+    node('ubuntu') {
+        def testEnv = buildTestEnv(""ci/static-validation.dockerfile ci"", ""static-validation-ubuntu"")",,2019-02-28 23:50:40,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/246734661,https://github.com/hyperledger/indy-sdk/pull/1320#discussion_r246734661,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1320,https://github.com/hyperledger/indy-sdk/pull/1320,"Wow, I missed a bunch of stuff, haha. Everything should be fixed now",0c1b4d1ff7837d3663dda890c677776145206de6,2019-01-10 20:04:03,246902944,"@@ -92,6 +95,24 @@ def notifyingFailure() {
     }
 }
 
+def staticValidation() {
+    parallel([
+        'libindy'    : { runValdiationRust('libindy') },
+        'libnullpay' : { runValdiationRust('libnullpay') },
+        'libvcx'     : { runValdiationRust('vcx/libvcx') },
+        'cli'        : { runValdiationRust('cli') }
+    ])
+}
+
+def runValdiationRust(dir) {
+    node('ubuntu') {
+        def testEnv = buildTestEnv(""ci/static-validation.dockerfile ci"", ""static-validation-ubuntu"")",,2019-02-28 23:50:40,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/246902944,https://github.com/hyperledger/indy-sdk/pull/1320#discussion_r246902944,stevengubler
https://github.com/hyperledger/indy-sdk/pull/1315,https://github.com/hyperledger/indy-sdk/pull/1315,"small thing, I feel this code analysis tag for resharper should be removed.  not everyone uses resharper.  unless the intent is to make resharper a requirement for this project.",4a948889a3651d24e997a7cd53c27ad7247c5450,2018-12-07 16:28:53,239867455,"@@ -13,12 +14,13 @@ namespace Hyperledger.Indy.WalletApi
     /// Represents a wallet that stores key value records and provides static methods for managing
     /// wallets.
     /// </summary>
+    [SuppressMessage(""ReSharper"", ""InconsistentNaming"")]
     public sealed class Wallet : IDisposable",13,2018-12-07 16:30:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/239867455,https://github.com/hyperledger/indy-sdk/pull/1315#discussion_r239867455,mattraffel
https://github.com/hyperledger/indy-sdk/pull/1314,https://github.com/hyperledger/indy-sdk/pull/1314,"@kdenhartog

Hi,

Thanks for contribution. I suggest to perform some changes to make our terminology and internal API better:

You added new `authenticated_encrypt/authenticated_decrypt` method, but they don't perform what is usually mean on this in cryptography. Look to https://en.wikipedia.org/wiki/Authenticated_encryption. It defines output of authcrypt as a pair (ciphertext, mac). 

In crypto service we already have a function that provides similar output it is `encrypt`. It can be better to rename existing `encrypt/encrypt_sealed` to `authcrypt/anoncrypt`, but on other hand we already have conception on combo-box and i suggest to start using original NaCl names `box/box_open` and `seal_box/seal_box_open`

What `authenticated_encrypt` is actually doing is creation of combo box and i suggest to rename it to `combo_box` and `authenticated_decrypt` tp `combo_box_open`. Existing method `create_combo_box` doesn't look valuable and we don't have corresponded `open` pair.

As a result I suggest the following:

1. Rename `authenticated_encrypt/authenticated_encrypt` to `combo_box/combo_box_open`
2. Rename `encrypt/decrypt/encrypt_sealed/decrypt_sealed` to `box/box_open/sealed_box/sealed_box_open`
3. Remove existing `create_combo_box` method and just inline it.

@jovfer what do you think?",563beb07ca0aee8fca7d15562bfe3e9bb45dad16,2018-11-26 08:29:44,236157600,"@@ -296,6 +296,36 @@ impl CryptoService {
         Ok(decrypted_doc)
     }
 
+    pub fn authenticated_encrypt(&self, my_key: &Key, their_vk: &str, doc: &[u8]) -> Result<Vec<u8>, CryptoError> {
+        let msg = self.create_combo_box(my_key, their_vk, doc)?;
+
+        let msg_pack = msg.to_msg_pack()
+            .map_err(|e| CommonError::InvalidState(format!(""Can't serialize ComboBox: {:?}"", e)))?;
+
+        let res = self.encrypt_sealed(&their_vk, &msg_pack)?;
+
+        Ok(res)
+    }
+
+    pub fn authenticated_decrypt(&self, my_key: &Key, doc: &[u8]) -> Result<(String, Vec<u8>), CryptoError> {",91,2018-12-28 12:07:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/236157600,https://github.com/hyperledger/indy-sdk/pull/1314#discussion_r236157600,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1314,https://github.com/hyperledger/indy-sdk/pull/1314,"@kdenhartog 

We discussed with Sergey that ```authenticated_encrypt``` is exposed as a public API. And it is better to keep it as is and remove number 1 from requested changes.",563beb07ca0aee8fca7d15562bfe3e9bb45dad16,2018-11-26 08:43:45,236161077,"@@ -296,6 +296,36 @@ impl CryptoService {
         Ok(decrypted_doc)
     }
 
+    pub fn authenticated_encrypt(&self, my_key: &Key, their_vk: &str, doc: &[u8]) -> Result<Vec<u8>, CryptoError> {
+        let msg = self.create_combo_box(my_key, their_vk, doc)?;
+
+        let msg_pack = msg.to_msg_pack()
+            .map_err(|e| CommonError::InvalidState(format!(""Can't serialize ComboBox: {:?}"", e)))?;
+
+        let res = self.encrypt_sealed(&their_vk, &msg_pack)?;
+
+        Ok(res)
+    }
+
+    pub fn authenticated_decrypt(&self, my_key: &Key, doc: &[u8]) -> Result<(String, Vec<u8>), CryptoError> {",91,2018-12-28 12:07:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/236161077,https://github.com/hyperledger/indy-sdk/pull/1314#discussion_r236161077,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1314,https://github.com/hyperledger/indy-sdk/pull/1314,"All of these changes work except for the proposed ""box"" function name. This is a reserved keyword for rust it appears, so I've changed it to be ""crypto_box"" and ""crypto_box_open"". To remain aligned with libsodium using this pattern, I've also changed ""sealed_box"" to ""crypto_box_seal"" and ""sealed_box_open"" to ""crypto_box_seal_open"". These changes are in the commit below this, but if you'd like me to rename the sealed functions to your proposal I can.",563beb07ca0aee8fca7d15562bfe3e9bb45dad16,2018-11-26 18:41:20,236378145,"@@ -296,6 +296,36 @@ impl CryptoService {
         Ok(decrypted_doc)
     }
 
+    pub fn authenticated_encrypt(&self, my_key: &Key, their_vk: &str, doc: &[u8]) -> Result<Vec<u8>, CryptoError> {
+        let msg = self.create_combo_box(my_key, their_vk, doc)?;
+
+        let msg_pack = msg.to_msg_pack()
+            .map_err(|e| CommonError::InvalidState(format!(""Can't serialize ComboBox: {:?}"", e)))?;
+
+        let res = self.encrypt_sealed(&their_vk, &msg_pack)?;
+
+        Ok(res)
+    }
+
+    pub fn authenticated_decrypt(&self, my_key: &Key, doc: &[u8]) -> Result<(String, Vec<u8>), CryptoError> {",91,2018-12-28 12:07:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/236378145,https://github.com/hyperledger/indy-sdk/pull/1314#discussion_r236378145,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1307,https://github.com/hyperledger/indy-sdk/pull/1307,It would be great to have unit tests for every creation of the expected key,aadc406d585dd64578b4609ea85d705f74fd0c93,2018-11-21 12:21:03,235365346,"@@ -192,7 +192,9 @@ fn _parse_reply_for_builtin_sp(json_msg: &SJsonValue, type_: &str) -> Option<Vec
                                                           json_msg[""ref""].as_u64()) {
                 trace!(""TransactionHandler::parse_reply_for_builtin_sp: GET_CRED_DEF sign_type {:?}, sch_seq_no: {:?}"", sign_type, sch_seq_no);
                 let marker = if ProtocolVersion::is_node_1_3() { '\x03' } else { '3' };
-                format!("":{}:{}:{}"", marker, sign_type, sch_seq_no)
+                let tag = if ProtocolVersion::is_node_1_3() { None } else { json_msg[""tag""].as_str() };",5,2018-11-21 12:21:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/235365346,https://github.com/hyperledger/indy-sdk/pull/1307#discussion_r235365346,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/1306,https://github.com/hyperledger/indy-sdk/pull/1306,"> s a simple HTTP server which implements Agent2Agent communication protocol required for full VCX work.

Change to: is simple implementation of VCX compatible Cloud Agent. The main purpose of this implementation is VCX testing, demos and documentation of VCX protocol. There is an parallel work on providing reference implementation of Agent2Agent protocol in indy-agent repo. We plan to migrate to this protocol and implementation soon.",0544044146fcf788187aebdfc08dde785012a155,2018-11-26 09:42:17,236180246,"@@ -70,13 +70,18 @@ A set of libvcx wrappers for developing vcx-based applications in your favorite
 
 Indy SDK provides libvcx wrappers for the following programming languages and platforms:
 
-* [Java](/vcx/wrappers/java/vcx/README.md)
+* [Java](/vcx/wrappers/java/README.md)
 * [Python](/vcx/wrappers/python3/README.md)
 * [iOS](vcx/wrappers/ios/README.md)
 * [NodeJS](/vcx/wrappers/node/README.md)
 
 These wrappers are currently in **experimental** state and it is not part of official releases.
 
+### Dummy Cloud Agent
+[Dummy Cloud Agent](/vcx/dummy-cloud-agent/README.md) is a simple HTTP server which implements Agent2Agent communication protocol required for full VCX work.",,2018-11-26 12:20:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/236180246,https://github.com/hyperledger/indy-sdk/pull/1306#discussion_r236180246,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1306,https://github.com/hyperledger/indy-sdk/pull/1306,I suggest to chage `Install` to `Install or build`,0544044146fcf788187aebdfc08dde785012a155,2018-11-26 10:25:14,236195455,"@@ -136,5 +115,30 @@ To build libvcx on your own you can follow these steps --
 5) Run `android_build.sh aarm64` to build libvcx for aarm64 architecture.(Other architerctures will follow soon)
 6) Tests are not working on Android as of now.
 
+## How to build VCX from source
+
+## Linux 
+1) Install rust and rustup (https://www.rust-lang.org/install.html). 
+2) [Install Libindy](../README.md#installing-the-sdk) ",95,2018-11-26 12:20:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/236195455,https://github.com/hyperledger/indy-sdk/pull/1306#discussion_r236195455,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1306,https://github.com/hyperledger/indy-sdk/pull/1306,"The same here:

Change to: is simple implementation of VCX compatible Cloud Agent. The main purpose of this implementation is VCX testing, demos and documentation of VCX protocol. There is an parallel work on providing reference implementation of Agent2Agent protocol in indy-agent repo. We plan to migrate to this protocol and implementation soon.",0544044146fcf788187aebdfc08dde785012a155,2018-11-26 10:28:02,236196405,"@@ -0,0 +1,8 @@
+# Dummy Cloud Agent
+
+This is a simple HTTP server which implements Agent2Agent communication protocol required for full [VCX](../README.md) work.",,2018-11-26 12:20:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/236196405,https://github.com/hyperledger/indy-sdk/pull/1306#discussion_r236196405,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1306,https://github.com/hyperledger/indy-sdk/pull/1306,Seems number 2 is duplicated with the same text,0544044146fcf788187aebdfc08dde785012a155,2018-11-26 10:39:17,236200280,"@@ -6,4 +6,14 @@ alice.py - a script that acts as an individual by accepting a connection offer,
 
 pool.txn - genesis files for connecting to an indy pool (existing file connects to libindy/sovtoken ledger)
 
-To run these install the latest vcx python package and execute the faber.py script first with ""python3.6 faber.py"".  This script will explain what it is doing and output invite details.  When the invite details are displayed start the alice.py script with ""python3.6 alice.py"".  This script will ask for invite details which can copy/pasted from the output of the faber.py script.  Once the connection is established the faber.py script will send a credential offer, credential and proof request.  The alice.py script will request a credential, store it and offer proof when asked.  Once they have interacted they will both exit.
+To run these follow the next steps:
+ 1) install the latest vcx python package
+ 2) start Dummy Cloud Agent according to instruction: https://github.com/hyperledger/indy-sdk/tree/master/vcx/dummy-cloud-agent/README.md",7,2018-11-26 12:20:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/236200280,https://github.com/hyperledger/indy-sdk/pull/1306#discussion_r236200280,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1306,https://github.com/hyperledger/indy-sdk/pull/1306,I suggest to add this demo link to main README.md near VCX section,0544044146fcf788187aebdfc08dde785012a155,2018-11-26 10:40:28,236200730,"@@ -6,4 +6,14 @@ alice.py - a script that acts as an individual by accepting a connection offer,
 
 pool.txn - genesis files for connecting to an indy pool (existing file connects to libindy/sovtoken ledger)",2,2018-11-26 12:20:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/236200730,https://github.com/hyperledger/indy-sdk/pull/1306#discussion_r236200730,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1302,https://github.com/hyperledger/indy-sdk/pull/1302,"```suggestion
                stash includes: 'libindy/target/release/libindy.so,libindy/target/release/libindy.a', name: 'LibindyUbuntuBuildResult'
```",9242dbf81999263052c0dbbcbd720790fdb43d73,2018-11-21 09:42:30,235314299,"@@ -243,21 +243,17 @@ def linuxLibindyBuild(file, env_name, network_name, stashBuildResults) {
 
         poolInst = openPool(env_name, network_name)
 
-        def testEnv
-
-        dir('libindy') {
-            echo ""${env_name} Libindy Test: Build docker image""
-            testEnv = dockerHelpers.build('libindy', file)
-
-            testEnv.inside(""--ip=\""10.0.0.3\"" --network=${network_name}"") {
-                echo ""${env_name} Test: Test""
+        def testEnv = buildTestEnv(file, env_name)
 
-                echo ""${env_name} Libindy Test: Build""
-                sh ""RUST_BACKTRACE=1 cargo build --release --features \""fatal_warnings sodium_static\""""
+        testEnv.inside {
+            echo ""${env_name} Libindy Test: Build""
+            sh '''
+                cd libindy
+                cargo build --release --features ""fatal_warnings sodium_static""
+            '''
 
-                if (stashBuildResults) {
-                    stash includes: 'target/release/libindy.so,target/release/libindy.a', name: 'LibindyUbuntuBuildResult'
-                }
+            if (stashBuildResults) {
+                stash includes: 'libindy/target/release/libindy.so,target/release/libindy.a', name: 'LibindyUbuntuBuildResult'",,2018-11-22 05:14:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/235314299,https://github.com/hyperledger/indy-sdk/pull/1302#discussion_r235314299,jovfer
https://github.com/hyperledger/indy-sdk/pull/1302,https://github.com/hyperledger/indy-sdk/pull/1302,"```suggestion
```",9242dbf81999263052c0dbbcbd720790fdb43d73,2018-11-21 09:45:34,235315413,"@@ -14,52 +14,50 @@ static mut LOGGER: Option<Box<(&'static Log)>> = None;
 
 pub struct Logger {}",,2018-11-22 05:14:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/235315413,https://github.com/hyperledger/indy-sdk/pull/1302#discussion_r235315413,jovfer
https://github.com/hyperledger/indy-sdk/pull/1302,https://github.com/hyperledger/indy-sdk/pull/1302,Can we use IndyError from the wrapper instead of dummy-agent version?,9242dbf81999263052c0dbbcbd720790fdb43d73,2018-11-21 09:49:13,235316829,"@@ -1,423 +1,53 @@
+use indyrs::crypto;
 use futures::*;
-use futures::sync::oneshot;
-use std::collections::HashMap;
-use std::os::raw::c_char;
-use std::sync::Mutex;
 use super::IndyError;",,2018-11-22 05:14:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/235316829,https://github.com/hyperledger/indy-sdk/pull/1302#discussion_r235316829,jovfer
https://github.com/hyperledger/indy-sdk/pull/1299,https://github.com/hyperledger/indy-sdk/pull/1299,please clean-up,6a81a212213b387995404b6781e16bdd9c600a18,2018-11-20 11:18:03,234962620,"@@ -6,12 +6,12 @@ fn main() {
     let target = env::var(""TARGET"").unwrap();
     println!(""target={}"", target);
 
-    let sodium_static = env::var(""CARGO_FEATURE_SODIUM_STATIC"").ok();
-    println!(""sodium_static={:?}"", sodium_static);
-
-    if sodium_static.is_some() {
-        println!(""cargo:rustc-link-lib=static=sodium"");
-    }
+//    let sodium_static = env::var(""CARGO_FEATURE_SODIUM_STATIC"").ok();",,2018-11-20 11:19:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/234962620,https://github.com/hyperledger/indy-sdk/pull/1299#discussion_r234962620,jovfer
https://github.com/hyperledger/indy-sdk/pull/1294,https://github.com/hyperledger/indy-sdk/pull/1294,Is reducing the number of attributes due to our agency limitations?,4dd6117a87a72654581987602f2154baeb8e35a5,2018-11-19 19:01:08,234742123,"@@ -76,7 +77,7 @@ mod tests {
     #[cfg(feature = ""pool_tests"")]
     #[test]
     fn test_real_proof() {
-        let number_of_attributes = 50;
+        let number_of_attributes = 10;",15,2018-11-19 20:40:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/234742123,https://github.com/hyperledger/indy-sdk/pull/1294#discussion_r234742123,hadleym
https://github.com/hyperledger/indy-sdk/pull/1294,https://github.com/hyperledger/indy-sdk/pull/1294,"This would be more 'rust' like:
```
    pub fn use_public_did(&mut self, did: &Option<String>) -> &mut Self {
        if let Some(x) = did {
            self.payload.configs.push(AttrValue {
                name: ""publicDid"".to_string(),
                value: x.to_string(),
            });
        };
        self
    }
```",4dd6117a87a72654581987602f2154baeb8e35a5,2018-11-19 19:52:35,234759304,"@@ -80,6 +80,17 @@ impl UpdateProfileData{
         }
     }
 
+    pub fn use_public_did(&mut self, did: &Option<String>) -> &mut Self {",4,2018-11-19 20:40:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/234759304,https://github.com/hyperledger/indy-sdk/pull/1294#discussion_r234759304,hadleym
https://github.com/hyperledger/indy-sdk/pull/1294,https://github.com/hyperledger/indy-sdk/pull/1294,Yes.  It will make it more compatible.,4dd6117a87a72654581987602f2154baeb8e35a5,2018-11-19 20:02:26,234762489,"@@ -76,7 +77,7 @@ mod tests {
     #[cfg(feature = ""pool_tests"")]
     #[test]
     fn test_real_proof() {
-        let number_of_attributes = 50;
+        let number_of_attributes = 10;",15,2018-11-19 20:40:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/234762489,https://github.com/hyperledger/indy-sdk/pull/1294#discussion_r234762489,glowkey
https://github.com/hyperledger/indy-sdk/pull/1288,https://github.com/hyperledger/indy-sdk/pull/1288,"When this was an evernym project, our philosophy was all extern crate statements were only in the lib.rs file.   The reason was clarity:  it made it easy to update, correct references to external crates.   Do we want to continue this pattern now?",f8ff683348c10e9d539a2173c3bff9f9fefb11bb,2018-11-13 20:20:45,233207370,"@@ -0,0 +1,148 @@
+extern crate log;
+extern crate libc;
+",,2018-11-14 10:17:17,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/233207370,https://github.com/hyperledger/indy-sdk/pull/1288#discussion_r233207370,mattraffel
https://github.com/hyperledger/indy-sdk/pull/1286,https://github.com/hyperledger/indy-sdk/pull/1286,I would like to see @srottem thoughts on changing these data types.  There is a slight difference between int and IntPtr that isn't obvious.,72a121cc7544b9eca34179a367d47bd369b7c404,2018-11-20 22:35:34,235194585,"@@ -225,14 +225,14 @@ private static void ProverGetCredentialsCallbackMethod(int xcommand_handle, int
 #if __IOS__
         [MonoPInvokeCallback(typeof(ProverSearchCredentialsCompletedDelegate))]
 #endif
-        private static void ProverSearchCredentialsCallbackMethod(int xcommand_handle, int err, IntPtr search_handle, int total_count)
+        private static void ProverSearchCredentialsCallbackMethod(int xcommand_handle, int err, int search_handle, int total_count)
         {
             var taskCompletionSource = PendingCommands.Remove<CredentialSearch>(xcommand_handle);",7,2018-11-26 09:57:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/235194585,https://github.com/hyperledger/indy-sdk/pull/1286#discussion_r235194585,mattraffel
https://github.com/hyperledger/indy-sdk/pull/1282,https://github.com/hyperledger/indy-sdk/pull/1282,As i understand it is a public interface of plugin. You designed it different way that we are thinking. I suggest to check https://github.com/hyperledger/indy-sdk/tree/master/doc/design/006-cli-plugins and libnullpay as an available example. ,090f28be0742f3250138b91253c1587ff68dc085,2018-11-19 13:19:08,234614315,"@@ -0,0 +1,1781 @@
+extern crate libc;
+extern crate time;
+extern crate indy_common;
+extern crate indy_crypto;
+extern crate serde_json;
+
+use indy_common::api::ErrorCode;
+use indy_common::utils::sequence::SequenceUtils;
+use indy_common::utils::cstring::CStringUtils;
+use indy_common::utils::crypto::base64;
+use indy_common::wallet_storage::storage::{WalletStorage, StorageRecord, StorageIterator, Tag, TagName, EncryptedValue};
+use postgres_storage::storage::WalletStorageType;
+use indy_common::wallet_storage::language;
+use indy_common::errors::wallet::WalletStorageError;
+
+use self::libc::c_char;
+
+use std::collections::HashMap;
+use std::ffi::CString;
+use std::sync::Mutex;
+use std::str;
+
+
+struct PostgresStorageContext {
+    // TODO save handle, config and credentials in case we need to re-connect to database
+    _xhandle: i32,        // reference returned to client to track open wallet connection
+    id: String,          // wallet name
+    _config: String,      // wallet config
+    _credentials: String, // wallet credentials
+    phandle: Box<::postgres_storage::PostgresStorage>  // reference to a postgres database connection
+}
+
+#[derive(Debug, Clone)]
+struct PostgresWalletRecord {
+    id: CString,
+    type_: CString,
+    value: Vec<u8>,
+    tags: CString
+}
+
+#[derive(Debug, Clone)]
+struct PostgresWalletRecordSet {
+    idx: usize,
+    records: Vec<PostgresWalletRecord>,
+    count: usize
+}
+
+lazy_static! {
+    // store a PostgresStorage object (contains a connection) 
+    static ref POSTGRES_OPEN_WALLETS: Mutex<HashMap<i32, PostgresStorageContext>> = Default::default();
+}
+
+lazy_static! {
+    // metadata for active wallets
+    static ref POSTGRES_ACTIVE_METADATAS: Mutex<HashMap<i32, CString>> = Default::default();
+}
+
+lazy_static! {
+    // cache of Postgres fetched records
+    static ref POSTGRES_ACTIVE_RECORDS: Mutex<HashMap<i32, PostgresWalletRecord>> = Default::default();
+}
+
+lazy_static! {
+    // cache of active Postgres searches
+    // TODO figure out  athread-safe PostgresStorageIterator
+    // static ref POSTGRES_ACTIVE_SEARCHES: Mutex<HashMap<i32, Box<::postgres_storage::PostgresStorageIterator>>> = Default::default();
+    static ref POSTGRES_ACTIVE_SEARCHES: Mutex<HashMap<i32, PostgresWalletRecordSet>> = Default::default();
+}
+
+pub struct PostgresWallet {}
+
+impl PostgresWallet {",73,2018-12-11 12:55:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/234614315,https://github.com/hyperledger/indy-sdk/pull/1282#discussion_r234614315,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1282,https://github.com/hyperledger/indy-sdk/pull/1282,"I suggest don't use structs to group functions. Modules are designed for this in Rust. There is some old examples of this approach in our codebase, but now we are working on removing this.",090f28be0742f3250138b91253c1587ff68dc085,2018-11-19 13:20:19,234614645,"@@ -0,0 +1,1781 @@
+extern crate libc;
+extern crate time;
+extern crate indy_common;
+extern crate indy_crypto;
+extern crate serde_json;
+
+use indy_common::api::ErrorCode;
+use indy_common::utils::sequence::SequenceUtils;
+use indy_common::utils::cstring::CStringUtils;
+use indy_common::utils::crypto::base64;
+use indy_common::wallet_storage::storage::{WalletStorage, StorageRecord, StorageIterator, Tag, TagName, EncryptedValue};
+use postgres_storage::storage::WalletStorageType;
+use indy_common::wallet_storage::language;
+use indy_common::errors::wallet::WalletStorageError;
+
+use self::libc::c_char;
+
+use std::collections::HashMap;
+use std::ffi::CString;
+use std::sync::Mutex;
+use std::str;
+
+
+struct PostgresStorageContext {
+    // TODO save handle, config and credentials in case we need to re-connect to database
+    _xhandle: i32,        // reference returned to client to track open wallet connection
+    id: String,          // wallet name
+    _config: String,      // wallet config
+    _credentials: String, // wallet credentials
+    phandle: Box<::postgres_storage::PostgresStorage>  // reference to a postgres database connection
+}
+
+#[derive(Debug, Clone)]
+struct PostgresWalletRecord {
+    id: CString,
+    type_: CString,
+    value: Vec<u8>,
+    tags: CString
+}
+
+#[derive(Debug, Clone)]
+struct PostgresWalletRecordSet {
+    idx: usize,
+    records: Vec<PostgresWalletRecord>,
+    count: usize
+}
+
+lazy_static! {
+    // store a PostgresStorage object (contains a connection) 
+    static ref POSTGRES_OPEN_WALLETS: Mutex<HashMap<i32, PostgresStorageContext>> = Default::default();
+}
+
+lazy_static! {
+    // metadata for active wallets
+    static ref POSTGRES_ACTIVE_METADATAS: Mutex<HashMap<i32, CString>> = Default::default();
+}
+
+lazy_static! {
+    // cache of Postgres fetched records
+    static ref POSTGRES_ACTIVE_RECORDS: Mutex<HashMap<i32, PostgresWalletRecord>> = Default::default();
+}
+
+lazy_static! {
+    // cache of active Postgres searches
+    // TODO figure out  athread-safe PostgresStorageIterator
+    // static ref POSTGRES_ACTIVE_SEARCHES: Mutex<HashMap<i32, Box<::postgres_storage::PostgresStorageIterator>>> = Default::default();
+    static ref POSTGRES_ACTIVE_SEARCHES: Mutex<HashMap<i32, PostgresWalletRecordSet>> = Default::default();
+}
+
+pub struct PostgresWallet {}
+
+impl PostgresWallet {",73,2018-12-11 12:55:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/234614645,https://github.com/hyperledger/indy-sdk/pull/1282#discussion_r234614645,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1282,https://github.com/hyperledger/indy-sdk/pull/1282,"I expect there to be only one public function:

```
pub fn postgress_storage_init() 
```

User of plugin will call it on the beginning and this function will call register_storage_type internally. All another function and moduled should be private.",090f28be0742f3250138b91253c1587ff68dc085,2018-11-19 13:22:58,234615398,"@@ -0,0 +1,28 @@
+#![cfg_attr(feature = ""fatal_warnings"", deny(warnings))]
+
+extern crate base64;",3,2018-12-11 12:55:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/234615398,https://github.com/hyperledger/indy-sdk/pull/1282#discussion_r234615398,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1282,https://github.com/hyperledger/indy-sdk/pull/1282,"> wallet register postgres so_file=libindystrgpostgres.dylib prefix=postgreswallet_fn_

CLI already provide load-plugin command to load 3d party plugins. Also there is corresponded command line option.",090f28be0742f3250138b91253c1587ff68dc085,2018-11-19 13:24:22,234615819,"@@ -0,0 +1,16 @@
+# commands to create, open, etc a postgres wallet in CLI
+# run cli as:
+# RUST_BACKTRACE=1 LD_LIBRARY_PATH=../samples/storage/storage-postgres/target/debug/ cargo run ../samples/storage/storage-postgres/cli_ps_test.txt
+# register the postgres plug-in
+wallet register postgres so_file=libindystrgpostgres.dylib prefix=postgreswallet_fn_",,2018-12-11 12:55:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/234615819,https://github.com/hyperledger/indy-sdk/pull/1282#discussion_r234615819,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1282,https://github.com/hyperledger/indy-sdk/pull/1282,Why you call this *Wallet* if it is *Storage* ?,090f28be0742f3250138b91253c1587ff68dc085,2018-11-19 13:26:57,234616600,"@@ -0,0 +1,1781 @@
+extern crate libc;
+extern crate time;
+extern crate indy_common;
+extern crate indy_crypto;
+extern crate serde_json;
+
+use indy_common::api::ErrorCode;
+use indy_common::utils::sequence::SequenceUtils;
+use indy_common::utils::cstring::CStringUtils;
+use indy_common::utils::crypto::base64;
+use indy_common::wallet_storage::storage::{WalletStorage, StorageRecord, StorageIterator, Tag, TagName, EncryptedValue};
+use postgres_storage::storage::WalletStorageType;
+use indy_common::wallet_storage::language;
+use indy_common::errors::wallet::WalletStorageError;
+
+use self::libc::c_char;
+
+use std::collections::HashMap;
+use std::ffi::CString;
+use std::sync::Mutex;
+use std::str;
+
+
+struct PostgresStorageContext {
+    // TODO save handle, config and credentials in case we need to re-connect to database
+    _xhandle: i32,        // reference returned to client to track open wallet connection
+    id: String,          // wallet name
+    _config: String,      // wallet config
+    _credentials: String, // wallet credentials
+    phandle: Box<::postgres_storage::PostgresStorage>  // reference to a postgres database connection
+}
+
+#[derive(Debug, Clone)]
+struct PostgresWalletRecord {",35,2018-12-11 12:55:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/234616600,https://github.com/hyperledger/indy-sdk/pull/1282#discussion_r234616600,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1282,https://github.com/hyperledger/indy-sdk/pull/1282,libindy uses one execution thread to handle all storage operation and in the future it will be at least one thread per storage. As a result you can remove the most of mutexes and implement lazy fetching of records without big problems.,090f28be0742f3250138b91253c1587ff68dc085,2018-11-19 13:27:31,234616764,"@@ -0,0 +1,1781 @@
+extern crate libc;
+extern crate time;
+extern crate indy_common;
+extern crate indy_crypto;
+extern crate serde_json;
+
+use indy_common::api::ErrorCode;
+use indy_common::utils::sequence::SequenceUtils;
+use indy_common::utils::cstring::CStringUtils;
+use indy_common::utils::crypto::base64;
+use indy_common::wallet_storage::storage::{WalletStorage, StorageRecord, StorageIterator, Tag, TagName, EncryptedValue};
+use postgres_storage::storage::WalletStorageType;
+use indy_common::wallet_storage::language;
+use indy_common::errors::wallet::WalletStorageError;
+
+use self::libc::c_char;
+
+use std::collections::HashMap;
+use std::ffi::CString;
+use std::sync::Mutex;
+use std::str;
+
+
+struct PostgresStorageContext {
+    // TODO save handle, config and credentials in case we need to re-connect to database
+    _xhandle: i32,        // reference returned to client to track open wallet connection
+    id: String,          // wallet name
+    _config: String,      // wallet config
+    _credentials: String, // wallet credentials
+    phandle: Box<::postgres_storage::PostgresStorage>  // reference to a postgres database connection
+}
+
+#[derive(Debug, Clone)]
+struct PostgresWalletRecord {
+    id: CString,
+    type_: CString,
+    value: Vec<u8>,
+    tags: CString
+}
+
+#[derive(Debug, Clone)]
+struct PostgresWalletRecordSet {
+    idx: usize,
+    records: Vec<PostgresWalletRecord>,
+    count: usize
+}
+
+lazy_static! {
+    // store a PostgresStorage object (contains a connection) 
+    static ref POSTGRES_OPEN_WALLETS: Mutex<HashMap<i32, PostgresStorageContext>> = Default::default();",51,2018-12-11 12:55:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/234616764,https://github.com/hyperledger/indy-sdk/pull/1282#discussion_r234616764,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1275,https://github.com/hyperledger/indy-sdk/pull/1275,Something's wrong here.  I think you should remove all your libindy changes.,a3aa34f118c8ebb38ec66c9bea2683f1d6b73696,2018-11-09 15:41:29,232296160,"@@ -673,7 +673,7 @@ mod high_cases {
                 },
             });
 
-            let request = ledger::build_get_schema_request(Some(IDENTIFIER), &anoncreds::gvt_schema_id()).unwrap();
+            let request = ledger::build_get_scuse utils::ctypes;hema_request(Some(IDENTIFIER), &anoncreds::gvt_schema_id()).unwrap();",,2018-11-13 18:48:50,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/232296160,https://github.com/hyperledger/indy-sdk/pull/1275#discussion_r232296160,glowkey
https://github.com/hyperledger/indy-sdk/pull/1275,https://github.com/hyperledger/indy-sdk/pull/1275,I think this is an error.,a3aa34f118c8ebb38ec66c9bea2683f1d6b73696,2018-11-09 15:42:46,232296641,"@@ -19,6 +19,7 @@ typedef unsigned int vcx_wallet_search_handle_t;
 typedef unsigned int vcx_bool_t;
 typedef unsigned int count_t;
 typedef unsigned long vcx_price_t;
+typedef unsinged int vcx_u32_t;",,2018-11-13 18:48:50,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/232296641,https://github.com/hyperledger/indy-sdk/pull/1275#discussion_r232296641,glowkey
https://github.com/hyperledger/indy-sdk/pull/1275,https://github.com/hyperledger/indy-sdk/pull/1275,Can we add comments to describe these functions?,a3aa34f118c8ebb38ec66c9bea2683f1d6b73696,2018-11-09 15:43:05,232296758,"@@ -1577,6 +1578,33 @@ vcx_error_t vcx_wallet_validate_payment_address(int32_t command_handle,
                                              const char *payment_address,
                                              void (*cb)(int32_t, vcx_error_t));
 
+
+vcx_error_t vcx_set_default_logger( const char * pattern );",13,2018-11-13 18:48:50,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/232296758,https://github.com/hyperledger/indy-sdk/pull/1275#discussion_r232296758,glowkey
https://github.com/hyperledger/indy-sdk/pull/1275,https://github.com/hyperledger/indy-sdk/pull/1275,Agreed. Looks like some libindy files modifications slipped by me.,a3aa34f118c8ebb38ec66c9bea2683f1d6b73696,2018-11-09 16:16:16,232308407,"@@ -673,7 +673,7 @@ mod high_cases {
                 },
             });
 
-            let request = ledger::build_get_schema_request(Some(IDENTIFIER), &anoncreds::gvt_schema_id()).unwrap();
+            let request = ledger::build_get_scuse utils::ctypes;hema_request(Some(IDENTIFIER), &anoncreds::gvt_schema_id()).unwrap();",,2018-11-13 18:48:50,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/232308407,https://github.com/hyperledger/indy-sdk/pull/1275#discussion_r232308407,hadleym
https://github.com/hyperledger/indy-sdk/pull/1275,https://github.com/hyperledger/indy-sdk/pull/1275,Typo fixed,a3aa34f118c8ebb38ec66c9bea2683f1d6b73696,2018-11-09 16:40:55,232317233,"@@ -1577,6 +1578,33 @@ vcx_error_t vcx_wallet_validate_payment_address(int32_t command_handle,
                                              const char *payment_address,
                                              void (*cb)(int32_t, vcx_error_t));
 
+
+vcx_error_t vcx_set_default_logger( const char * pattern );",13,2018-11-13 18:48:50,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/232317233,https://github.com/hyperledger/indy-sdk/pull/1275#discussion_r232317233,hadleym
https://github.com/hyperledger/indy-sdk/pull/1275,https://github.com/hyperledger/indy-sdk/pull/1275,Can't we just use the RUST_LOG env variable for the default logger?  Seems easy and gets rid of this workaround.,a3aa34f118c8ebb38ec66c9bea2683f1d6b73696,2018-11-12 15:34:09,232703442,"@@ -187,9 +185,20 @@ pub fn test_agency_mode_enabled() -> bool {
 }
 
 pub fn process_config_string(config: &str) -> Result<u32, u32> {
+    use utils::logger::LibvcxDefaultLogger;
+    use serde_json::Value;
     let configuration: Value = serde_json::from_str(config).or(Err(error::INVALID_JSON.code_num))?;
     if let Value::Object(ref map) = configuration {
         for (key, value) in map {
+            if key == DEFAULT_LOGGING_KEY {",,2018-11-13 18:48:50,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/232703442,https://github.com/hyperledger/indy-sdk/pull/1275#discussion_r232703442,glowkey
https://github.com/hyperledger/indy-sdk/pull/1275,https://github.com/hyperledger/indy-sdk/pull/1275,"yes, working on this change.
",a3aa34f118c8ebb38ec66c9bea2683f1d6b73696,2018-11-13 16:38:57,233124622,"@@ -187,9 +185,20 @@ pub fn test_agency_mode_enabled() -> bool {
 }
 
 pub fn process_config_string(config: &str) -> Result<u32, u32> {
+    use utils::logger::LibvcxDefaultLogger;
+    use serde_json::Value;
     let configuration: Value = serde_json::from_str(config).or(Err(error::INVALID_JSON.code_num))?;
     if let Value::Object(ref map) = configuration {
         for (key, value) in map {
+            if key == DEFAULT_LOGGING_KEY {",,2018-11-13 18:48:50,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/233124622,https://github.com/hyperledger/indy-sdk/pull/1275#discussion_r233124622,hadleym
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,There is should be note here about limited support of issuance strategies here. Also please specify the ticket in IndySDK HL Jira,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-11-14 15:36:44,233497476,"@@ -26,9 +26,11 @@ use utils::threadpool::spawn;
 ///
 /// tag: way to create a unique credential def with the same schema and issuer did.
 ///
-//Todo: Provide more info about the config
-/// config: revocation info
-///
+/// revocation details: type-specific configuration of credential definition revocation
+///     support_revocation: true|false - Optional, by default its false",9,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/233497476,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r233497476,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,Please create a ticket in IndySDK HL Jira and referent to it,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-11-14 15:37:52,233497964,"@@ -457,11 +457,32 @@ pub extern fn vcx_disclosed_proof_retrieve_credentials(command_handle: u32,
 /// handle: Proof handle that was provided during creation. Used to identify the disclosed proof object
 ///
 /// selected_credentials: a json string with a credential for each proof request attribute.
-/// List of possible credentials for each attribute is returned from vcx_disclosed_proof_retrieve_credentials
-/// # Examples selected_credential -> ""{""req_attr_0"":cred_info}"" Where cred_info is returned from retrieve credentials
+///     List of possible credentials for each attribute is returned from vcx_disclosed_proof_retrieve_credentials,
+///         (user needs to select specific credential to use from list of credentials)
+///         {
+///             ""attrs"":{
+///                 String:{// Attribute key: This may not be the same as the attr name ex. ""age_1"" where attribute name is ""age""
+///                     ""credential"": {
+///                         ""cred_info"":{
+///                             ""referent"":String,
+///                             ""attrs"":{ String: String }, // ex. {""age"": ""111"", ""name"": ""Bob""}
+///                             ""schema_id"": String,
+///                             ""cred_def_id"": String,
+///                             ""rev_reg_id"":Option<String>,
+///                             ""cred_rev_id"":Option<String>,
+///                             },
+///                         ""interval"":Option<{to: Option<u64>, from:: Option<u64>}>
+///                     }, // This is the exact credential information selected from list of
+///                        // credentials returned from vcx_disclosed_proof_retrieve_credentials
+///                     ""tails_file"": Option<""String"">, // Path to tails file for this credential
+///                 },
+///            },
+///           ""predicates"":{ WILL PROVIDE MORE DETAILS WHEN PREDICATES ARE IMPLEMENTED }",,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/233497964,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r233497964,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,It seems like misuse of allowed interval requested by Verifier. Verifier provides bounds for acceptable timestamp interval for whole proof request or specific attribute. Proover should choose something and fetch information from ledger.  See next comment around `get_rev_reg_delta_json`.,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-11-14 15:52:16,233504720,"@@ -75,35 +73,134 @@ pub struct RequestedCreds {
 
 #[derive(Debug, Deserialize, Serialize, PartialEq)]
 pub struct CredInfo {
+    pub requested_attr: String,
     pub referent: String,
     pub schema_id: String,
     pub cred_def_id: String,
+    pub rev_reg_id: Option<String>,
+    pub cred_rev_id: Option<String>,
+    pub revocation_interval: Option<NonRevokedInterval>,
+    pub tails_file: Option<String>,
+    pub timestamp: Option<u64>
 }
 
-fn credential_def_identifiers(credentials: &str) -> Result<Vec<(String, String, String, String)>, ProofError> {
+fn credential_def_identifiers(credentials: &str, proof_req: &ProofRequestData)
+    -> Result<Vec<CredInfo>, ProofError> {
+
     let mut rtn = Vec::new();
 
     let credentials: Value = serde_json::from_str(credentials)
-        .or(Err(ProofError::CommonError(error::INVALID_JSON.code_num)))?;
+        .or(Err(ProofError::InvalidJson()))?;
 
     if let Value::Object(ref attrs) = credentials[""attrs""] {
         for (requested_attr, value) in attrs {
-            if let Some(ref attr_obj) = value.get(""cred_info"") {
-                rtn.push((
-                    requested_attr.to_string(),
-                    serde_utils::get_value_to_string(""referent"", attr_obj)
-                        .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""schema_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""cred_def_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?
-                 ));
-            }
+            if let (Some(referent), Some(schema_id), Some(cred_def_id)) =
+            (value[""credential""][""cred_info""][""referent""].as_str(),
+             value[""credential""][""cred_info""][""schema_id""].as_str(),
+             value[""credential""][""cred_info""][""cred_def_id""].as_str()) {
+
+                let rev_reg_id = value[""credential""][""cred_info""][""rev_reg_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let cred_rev_id = value[""credential""][""cred_info""][""cred_rev_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let tails_file = value[""tails_file""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                rtn.push(
+                    CredInfo {
+                        requested_attr: requested_attr.to_string(),
+                        referent: referent.to_string(),
+                        schema_id: schema_id.to_string(),
+                        cred_def_id: cred_def_id.to_string(),
+                        revocation_interval: _get_revocation_interval(&requested_attr, &proof_req)?,
+                        timestamp: None,
+                        rev_reg_id,
+                        cred_rev_id,
+                        tails_file,
+                    }
+                );
+            } else { return Err(ProofError::InvalidCredData()) }
         }
     }
+
     Ok(rtn)
 }
 
+fn _get_revocation_interval(attr_name: &str, proof_req: &ProofRequestData)
+    -> Result<Option<NonRevokedInterval>, ProofError> {
+
+    if let Some(ref attr) = proof_req.requested_attributes.get(attr_name) {
+
+        if let Some(ref interval) = attr.non_revoked {
+            return Ok(Some(NonRevokedInterval {from: interval.from, to: interval.to}))
+        }
+        else if let Some(ref interval) = proof_req.non_revoked {
+            return Ok(Some(NonRevokedInterval { from: interval.from, to: interval.to }))
+        }
+
+        return Ok(None)
+    }
+    // Todo: Handle case for predicates
+
+    Err(ProofError::InvalidCredData())
+}
+
+// Also updates timestamp in credentials_identifiers
+fn build_rev_states_json(credentials_identifiers: &mut Vec<CredInfo>) -> Result<String, ProofError> {
+    let mut rtn: Value = json!({});
+    let mut timestamps: HashMap<String, u64> = HashMap::new();
+
+    for cred_info in credentials_identifiers.iter_mut() {
+        if let (Some(rev_reg_id), Some(cred_rev_id), Some(tails_file)) =
+        (&cred_info.rev_reg_id, &cred_info.cred_rev_id, &cred_info.tails_file) {
+
+            if rtn.get(&rev_reg_id).is_none() {
+                let (from, to) = if let Some(ref interval) = cred_info.revocation_interval
+                    { (interval.from, interval.to) }",130,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/233504720,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r233504720,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,"This call should be `from` last known and cached by Proover state to the chosen one timestamp. In case of no cache on proover side, `from` should be `None`.",846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-11-14 15:53:45,233505433,"@@ -75,35 +73,134 @@ pub struct RequestedCreds {
 
 #[derive(Debug, Deserialize, Serialize, PartialEq)]
 pub struct CredInfo {
+    pub requested_attr: String,
     pub referent: String,
     pub schema_id: String,
     pub cred_def_id: String,
+    pub rev_reg_id: Option<String>,
+    pub cred_rev_id: Option<String>,
+    pub revocation_interval: Option<NonRevokedInterval>,
+    pub tails_file: Option<String>,
+    pub timestamp: Option<u64>
 }
 
-fn credential_def_identifiers(credentials: &str) -> Result<Vec<(String, String, String, String)>, ProofError> {
+fn credential_def_identifiers(credentials: &str, proof_req: &ProofRequestData)
+    -> Result<Vec<CredInfo>, ProofError> {
+
     let mut rtn = Vec::new();
 
     let credentials: Value = serde_json::from_str(credentials)
-        .or(Err(ProofError::CommonError(error::INVALID_JSON.code_num)))?;
+        .or(Err(ProofError::InvalidJson()))?;
 
     if let Value::Object(ref attrs) = credentials[""attrs""] {
         for (requested_attr, value) in attrs {
-            if let Some(ref attr_obj) = value.get(""cred_info"") {
-                rtn.push((
-                    requested_attr.to_string(),
-                    serde_utils::get_value_to_string(""referent"", attr_obj)
-                        .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""schema_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""cred_def_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?
-                 ));
-            }
+            if let (Some(referent), Some(schema_id), Some(cred_def_id)) =
+            (value[""credential""][""cred_info""][""referent""].as_str(),
+             value[""credential""][""cred_info""][""schema_id""].as_str(),
+             value[""credential""][""cred_info""][""cred_def_id""].as_str()) {
+
+                let rev_reg_id = value[""credential""][""cred_info""][""rev_reg_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let cred_rev_id = value[""credential""][""cred_info""][""cred_rev_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let tails_file = value[""tails_file""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                rtn.push(
+                    CredInfo {
+                        requested_attr: requested_attr.to_string(),
+                        referent: referent.to_string(),
+                        schema_id: schema_id.to_string(),
+                        cred_def_id: cred_def_id.to_string(),
+                        revocation_interval: _get_revocation_interval(&requested_attr, &proof_req)?,
+                        timestamp: None,
+                        rev_reg_id,
+                        cred_rev_id,
+                        tails_file,
+                    }
+                );
+            } else { return Err(ProofError::InvalidCredData()) }
         }
     }
+
     Ok(rtn)
 }
 
+fn _get_revocation_interval(attr_name: &str, proof_req: &ProofRequestData)
+    -> Result<Option<NonRevokedInterval>, ProofError> {
+
+    if let Some(ref attr) = proof_req.requested_attributes.get(attr_name) {
+
+        if let Some(ref interval) = attr.non_revoked {
+            return Ok(Some(NonRevokedInterval {from: interval.from, to: interval.to}))
+        }
+        else if let Some(ref interval) = proof_req.non_revoked {
+            return Ok(Some(NonRevokedInterval { from: interval.from, to: interval.to }))
+        }
+
+        return Ok(None)
+    }
+    // Todo: Handle case for predicates
+
+    Err(ProofError::InvalidCredData())
+}
+
+// Also updates timestamp in credentials_identifiers
+fn build_rev_states_json(credentials_identifiers: &mut Vec<CredInfo>) -> Result<String, ProofError> {
+    let mut rtn: Value = json!({});
+    let mut timestamps: HashMap<String, u64> = HashMap::new();
+
+    for cred_info in credentials_identifiers.iter_mut() {
+        if let (Some(rev_reg_id), Some(cred_rev_id), Some(tails_file)) =
+        (&cred_info.rev_reg_id, &cred_info.cred_rev_id, &cred_info.tails_file) {
+
+            if rtn.get(&rev_reg_id).is_none() {
+                let (from, to) = if let Some(ref interval) = cred_info.revocation_interval
+                    { (interval.from, interval.to) }
+                else { (None, None )};
+
+                let (_, rev_reg_def_json) = get_rev_reg_def_json(&rev_reg_id)
+                    .map_err(|e| ProofError::CommonError(e))?;
+
+                let (rev_reg_id, rev_reg_delta_json, timestamp) = get_rev_reg_delta_json(",,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/233505433,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r233505433,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,"Proover should `create` revocation state only at first proof presenting. It may be very CPU and network complex operation, so for next presentations the proover should use cached value and `update_revocation_state` ",846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-11-14 15:56:44,233506785,"@@ -75,35 +73,134 @@ pub struct RequestedCreds {
 
 #[derive(Debug, Deserialize, Serialize, PartialEq)]
 pub struct CredInfo {
+    pub requested_attr: String,
     pub referent: String,
     pub schema_id: String,
     pub cred_def_id: String,
+    pub rev_reg_id: Option<String>,
+    pub cred_rev_id: Option<String>,
+    pub revocation_interval: Option<NonRevokedInterval>,
+    pub tails_file: Option<String>,
+    pub timestamp: Option<u64>
 }
 
-fn credential_def_identifiers(credentials: &str) -> Result<Vec<(String, String, String, String)>, ProofError> {
+fn credential_def_identifiers(credentials: &str, proof_req: &ProofRequestData)
+    -> Result<Vec<CredInfo>, ProofError> {
+
     let mut rtn = Vec::new();
 
     let credentials: Value = serde_json::from_str(credentials)
-        .or(Err(ProofError::CommonError(error::INVALID_JSON.code_num)))?;
+        .or(Err(ProofError::InvalidJson()))?;
 
     if let Value::Object(ref attrs) = credentials[""attrs""] {
         for (requested_attr, value) in attrs {
-            if let Some(ref attr_obj) = value.get(""cred_info"") {
-                rtn.push((
-                    requested_attr.to_string(),
-                    serde_utils::get_value_to_string(""referent"", attr_obj)
-                        .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""schema_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""cred_def_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?
-                 ));
-            }
+            if let (Some(referent), Some(schema_id), Some(cred_def_id)) =
+            (value[""credential""][""cred_info""][""referent""].as_str(),
+             value[""credential""][""cred_info""][""schema_id""].as_str(),
+             value[""credential""][""cred_info""][""cred_def_id""].as_str()) {
+
+                let rev_reg_id = value[""credential""][""cred_info""][""rev_reg_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let cred_rev_id = value[""credential""][""cred_info""][""cred_rev_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let tails_file = value[""tails_file""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                rtn.push(
+                    CredInfo {
+                        requested_attr: requested_attr.to_string(),
+                        referent: referent.to_string(),
+                        schema_id: schema_id.to_string(),
+                        cred_def_id: cred_def_id.to_string(),
+                        revocation_interval: _get_revocation_interval(&requested_attr, &proof_req)?,
+                        timestamp: None,
+                        rev_reg_id,
+                        cred_rev_id,
+                        tails_file,
+                    }
+                );
+            } else { return Err(ProofError::InvalidCredData()) }
         }
     }
+
     Ok(rtn)
 }
 
+fn _get_revocation_interval(attr_name: &str, proof_req: &ProofRequestData)
+    -> Result<Option<NonRevokedInterval>, ProofError> {
+
+    if let Some(ref attr) = proof_req.requested_attributes.get(attr_name) {
+
+        if let Some(ref interval) = attr.non_revoked {
+            return Ok(Some(NonRevokedInterval {from: interval.from, to: interval.to}))
+        }
+        else if let Some(ref interval) = proof_req.non_revoked {
+            return Ok(Some(NonRevokedInterval { from: interval.from, to: interval.to }))
+        }
+
+        return Ok(None)
+    }
+    // Todo: Handle case for predicates
+
+    Err(ProofError::InvalidCredData())
+}
+
+// Also updates timestamp in credentials_identifiers
+fn build_rev_states_json(credentials_identifiers: &mut Vec<CredInfo>) -> Result<String, ProofError> {
+    let mut rtn: Value = json!({});
+    let mut timestamps: HashMap<String, u64> = HashMap::new();
+
+    for cred_info in credentials_identifiers.iter_mut() {
+        if let (Some(rev_reg_id), Some(cred_rev_id), Some(tails_file)) =
+        (&cred_info.rev_reg_id, &cred_info.cred_rev_id, &cred_info.tails_file) {
+
+            if rtn.get(&rev_reg_id).is_none() {
+                let (from, to) = if let Some(ref interval) = cred_info.revocation_interval
+                    { (interval.from, interval.to) }
+                else { (None, None )};
+
+                let (_, rev_reg_def_json) = get_rev_reg_def_json(&rev_reg_id)
+                    .map_err(|e| ProofError::CommonError(e))?;
+
+                let (rev_reg_id, rev_reg_delta_json, timestamp) = get_rev_reg_delta_json(
+                    &rev_reg_id,
+                    from,
+                    to
+                ).map_err(|e| ProofError::CommonError(e))?;
+
+                let rev_state_json = anoncreds::libindy_prover_create_revocation_state(",,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/233506785,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r233506785,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,"In a proof request, there are two places a user could specify ""non_revoked"". At the proof level and the attribute level (attribute level overrides the proof level). Libvcx logic for selecting the ""from"" and ""to"" values is in `fn _get_revocation_interval(attr_name: &str, proof_req: &ProofRequestData). ` If an attribute doesn't specify an interval it looks at the proof level which then defaults to to=None, and from=None if the proof level doesn't specify. 

If (to and from) = None, src/utils/libindy/ledger.rs `pub fn get_rev_reg_delta_json(rev_reg_id: &str, from: Option<u64>, to: Option<u64>)` generates the to value as the current time. 

I'm not sure the problem with this.",846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-11-15 15:24:01,233886524,"@@ -75,35 +73,134 @@ pub struct RequestedCreds {
 
 #[derive(Debug, Deserialize, Serialize, PartialEq)]
 pub struct CredInfo {
+    pub requested_attr: String,
     pub referent: String,
     pub schema_id: String,
     pub cred_def_id: String,
+    pub rev_reg_id: Option<String>,
+    pub cred_rev_id: Option<String>,
+    pub revocation_interval: Option<NonRevokedInterval>,
+    pub tails_file: Option<String>,
+    pub timestamp: Option<u64>
 }
 
-fn credential_def_identifiers(credentials: &str) -> Result<Vec<(String, String, String, String)>, ProofError> {
+fn credential_def_identifiers(credentials: &str, proof_req: &ProofRequestData)
+    -> Result<Vec<CredInfo>, ProofError> {
+
     let mut rtn = Vec::new();
 
     let credentials: Value = serde_json::from_str(credentials)
-        .or(Err(ProofError::CommonError(error::INVALID_JSON.code_num)))?;
+        .or(Err(ProofError::InvalidJson()))?;
 
     if let Value::Object(ref attrs) = credentials[""attrs""] {
         for (requested_attr, value) in attrs {
-            if let Some(ref attr_obj) = value.get(""cred_info"") {
-                rtn.push((
-                    requested_attr.to_string(),
-                    serde_utils::get_value_to_string(""referent"", attr_obj)
-                        .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""schema_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""cred_def_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?
-                 ));
-            }
+            if let (Some(referent), Some(schema_id), Some(cred_def_id)) =
+            (value[""credential""][""cred_info""][""referent""].as_str(),
+             value[""credential""][""cred_info""][""schema_id""].as_str(),
+             value[""credential""][""cred_info""][""cred_def_id""].as_str()) {
+
+                let rev_reg_id = value[""credential""][""cred_info""][""rev_reg_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let cred_rev_id = value[""credential""][""cred_info""][""cred_rev_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let tails_file = value[""tails_file""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                rtn.push(
+                    CredInfo {
+                        requested_attr: requested_attr.to_string(),
+                        referent: referent.to_string(),
+                        schema_id: schema_id.to_string(),
+                        cred_def_id: cred_def_id.to_string(),
+                        revocation_interval: _get_revocation_interval(&requested_attr, &proof_req)?,
+                        timestamp: None,
+                        rev_reg_id,
+                        cred_rev_id,
+                        tails_file,
+                    }
+                );
+            } else { return Err(ProofError::InvalidCredData()) }
         }
     }
+
     Ok(rtn)
 }
 
+fn _get_revocation_interval(attr_name: &str, proof_req: &ProofRequestData)
+    -> Result<Option<NonRevokedInterval>, ProofError> {
+
+    if let Some(ref attr) = proof_req.requested_attributes.get(attr_name) {
+
+        if let Some(ref interval) = attr.non_revoked {
+            return Ok(Some(NonRevokedInterval {from: interval.from, to: interval.to}))
+        }
+        else if let Some(ref interval) = proof_req.non_revoked {
+            return Ok(Some(NonRevokedInterval { from: interval.from, to: interval.to }))
+        }
+
+        return Ok(None)
+    }
+    // Todo: Handle case for predicates
+
+    Err(ProofError::InvalidCredData())
+}
+
+// Also updates timestamp in credentials_identifiers
+fn build_rev_states_json(credentials_identifiers: &mut Vec<CredInfo>) -> Result<String, ProofError> {
+    let mut rtn: Value = json!({});
+    let mut timestamps: HashMap<String, u64> = HashMap::new();
+
+    for cred_info in credentials_identifiers.iter_mut() {
+        if let (Some(rev_reg_id), Some(cred_rev_id), Some(tails_file)) =
+        (&cred_info.rev_reg_id, &cred_info.cred_rev_id, &cred_info.tails_file) {
+
+            if rtn.get(&rev_reg_id).is_none() {
+                let (from, to) = if let Some(ref interval) = cred_info.revocation_interval
+                    { (interval.from, interval.to) }",130,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/233886524,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r233886524,ryMarsh44
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,I do not understand this comment.,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-11-15 15:37:23,233892449,"@@ -75,35 +73,134 @@ pub struct RequestedCreds {
 
 #[derive(Debug, Deserialize, Serialize, PartialEq)]
 pub struct CredInfo {
+    pub requested_attr: String,
     pub referent: String,
     pub schema_id: String,
     pub cred_def_id: String,
+    pub rev_reg_id: Option<String>,
+    pub cred_rev_id: Option<String>,
+    pub revocation_interval: Option<NonRevokedInterval>,
+    pub tails_file: Option<String>,
+    pub timestamp: Option<u64>
 }
 
-fn credential_def_identifiers(credentials: &str) -> Result<Vec<(String, String, String, String)>, ProofError> {
+fn credential_def_identifiers(credentials: &str, proof_req: &ProofRequestData)
+    -> Result<Vec<CredInfo>, ProofError> {
+
     let mut rtn = Vec::new();
 
     let credentials: Value = serde_json::from_str(credentials)
-        .or(Err(ProofError::CommonError(error::INVALID_JSON.code_num)))?;
+        .or(Err(ProofError::InvalidJson()))?;
 
     if let Value::Object(ref attrs) = credentials[""attrs""] {
         for (requested_attr, value) in attrs {
-            if let Some(ref attr_obj) = value.get(""cred_info"") {
-                rtn.push((
-                    requested_attr.to_string(),
-                    serde_utils::get_value_to_string(""referent"", attr_obj)
-                        .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""schema_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""cred_def_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?
-                 ));
-            }
+            if let (Some(referent), Some(schema_id), Some(cred_def_id)) =
+            (value[""credential""][""cred_info""][""referent""].as_str(),
+             value[""credential""][""cred_info""][""schema_id""].as_str(),
+             value[""credential""][""cred_info""][""cred_def_id""].as_str()) {
+
+                let rev_reg_id = value[""credential""][""cred_info""][""rev_reg_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let cred_rev_id = value[""credential""][""cred_info""][""cred_rev_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let tails_file = value[""tails_file""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                rtn.push(
+                    CredInfo {
+                        requested_attr: requested_attr.to_string(),
+                        referent: referent.to_string(),
+                        schema_id: schema_id.to_string(),
+                        cred_def_id: cred_def_id.to_string(),
+                        revocation_interval: _get_revocation_interval(&requested_attr, &proof_req)?,
+                        timestamp: None,
+                        rev_reg_id,
+                        cred_rev_id,
+                        tails_file,
+                    }
+                );
+            } else { return Err(ProofError::InvalidCredData()) }
         }
     }
+
     Ok(rtn)
 }
 
+fn _get_revocation_interval(attr_name: &str, proof_req: &ProofRequestData)
+    -> Result<Option<NonRevokedInterval>, ProofError> {
+
+    if let Some(ref attr) = proof_req.requested_attributes.get(attr_name) {
+
+        if let Some(ref interval) = attr.non_revoked {
+            return Ok(Some(NonRevokedInterval {from: interval.from, to: interval.to}))
+        }
+        else if let Some(ref interval) = proof_req.non_revoked {
+            return Ok(Some(NonRevokedInterval { from: interval.from, to: interval.to }))
+        }
+
+        return Ok(None)
+    }
+    // Todo: Handle case for predicates
+
+    Err(ProofError::InvalidCredData())
+}
+
+// Also updates timestamp in credentials_identifiers
+fn build_rev_states_json(credentials_identifiers: &mut Vec<CredInfo>) -> Result<String, ProofError> {
+    let mut rtn: Value = json!({});
+    let mut timestamps: HashMap<String, u64> = HashMap::new();
+
+    for cred_info in credentials_identifiers.iter_mut() {
+        if let (Some(rev_reg_id), Some(cred_rev_id), Some(tails_file)) =
+        (&cred_info.rev_reg_id, &cred_info.cred_rev_id, &cred_info.tails_file) {
+
+            if rtn.get(&rev_reg_id).is_none() {
+                let (from, to) = if let Some(ref interval) = cred_info.revocation_interval
+                    { (interval.from, interval.to) }
+                else { (None, None )};
+
+                let (_, rev_reg_def_json) = get_rev_reg_def_json(&rev_reg_id)
+                    .map_err(|e| ProofError::CommonError(e))?;
+
+                let (rev_reg_id, rev_reg_delta_json, timestamp) = get_rev_reg_delta_json(",,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/233892449,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r233892449,ryMarsh44
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,"Yep, both places should used in combination like it's done now - local one can override common value.
As result proover will know allowed interval per attribute to proof non-revoked status.
In other words: Verifier will accept proof if attribute is non-revoked for some timestamp inside `from` - `to` interval.",846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-11-15 15:54:49,233900585,"@@ -75,35 +73,134 @@ pub struct RequestedCreds {
 
 #[derive(Debug, Deserialize, Serialize, PartialEq)]
 pub struct CredInfo {
+    pub requested_attr: String,
     pub referent: String,
     pub schema_id: String,
     pub cred_def_id: String,
+    pub rev_reg_id: Option<String>,
+    pub cred_rev_id: Option<String>,
+    pub revocation_interval: Option<NonRevokedInterval>,
+    pub tails_file: Option<String>,
+    pub timestamp: Option<u64>
 }
 
-fn credential_def_identifiers(credentials: &str) -> Result<Vec<(String, String, String, String)>, ProofError> {
+fn credential_def_identifiers(credentials: &str, proof_req: &ProofRequestData)
+    -> Result<Vec<CredInfo>, ProofError> {
+
     let mut rtn = Vec::new();
 
     let credentials: Value = serde_json::from_str(credentials)
-        .or(Err(ProofError::CommonError(error::INVALID_JSON.code_num)))?;
+        .or(Err(ProofError::InvalidJson()))?;
 
     if let Value::Object(ref attrs) = credentials[""attrs""] {
         for (requested_attr, value) in attrs {
-            if let Some(ref attr_obj) = value.get(""cred_info"") {
-                rtn.push((
-                    requested_attr.to_string(),
-                    serde_utils::get_value_to_string(""referent"", attr_obj)
-                        .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""schema_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""cred_def_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?
-                 ));
-            }
+            if let (Some(referent), Some(schema_id), Some(cred_def_id)) =
+            (value[""credential""][""cred_info""][""referent""].as_str(),
+             value[""credential""][""cred_info""][""schema_id""].as_str(),
+             value[""credential""][""cred_info""][""cred_def_id""].as_str()) {
+
+                let rev_reg_id = value[""credential""][""cred_info""][""rev_reg_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let cred_rev_id = value[""credential""][""cred_info""][""cred_rev_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let tails_file = value[""tails_file""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                rtn.push(
+                    CredInfo {
+                        requested_attr: requested_attr.to_string(),
+                        referent: referent.to_string(),
+                        schema_id: schema_id.to_string(),
+                        cred_def_id: cred_def_id.to_string(),
+                        revocation_interval: _get_revocation_interval(&requested_attr, &proof_req)?,
+                        timestamp: None,
+                        rev_reg_id,
+                        cred_rev_id,
+                        tails_file,
+                    }
+                );
+            } else { return Err(ProofError::InvalidCredData()) }
         }
     }
+
     Ok(rtn)
 }
 
+fn _get_revocation_interval(attr_name: &str, proof_req: &ProofRequestData)
+    -> Result<Option<NonRevokedInterval>, ProofError> {
+
+    if let Some(ref attr) = proof_req.requested_attributes.get(attr_name) {
+
+        if let Some(ref interval) = attr.non_revoked {
+            return Ok(Some(NonRevokedInterval {from: interval.from, to: interval.to}))
+        }
+        else if let Some(ref interval) = proof_req.non_revoked {
+            return Ok(Some(NonRevokedInterval { from: interval.from, to: interval.to }))
+        }
+
+        return Ok(None)
+    }
+    // Todo: Handle case for predicates
+
+    Err(ProofError::InvalidCredData())
+}
+
+// Also updates timestamp in credentials_identifiers
+fn build_rev_states_json(credentials_identifiers: &mut Vec<CredInfo>) -> Result<String, ProofError> {
+    let mut rtn: Value = json!({});
+    let mut timestamps: HashMap<String, u64> = HashMap::new();
+
+    for cred_info in credentials_identifiers.iter_mut() {
+        if let (Some(rev_reg_id), Some(cred_rev_id), Some(tails_file)) =
+        (&cred_info.rev_reg_id, &cred_info.cred_rev_id, &cred_info.tails_file) {
+
+            if rtn.get(&rev_reg_id).is_none() {
+                let (from, to) = if let Some(ref interval) = cred_info.revocation_interval
+                    { (interval.from, interval.to) }",130,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/233900585,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r233900585,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,It's just a second part of the previous comment. Please see update above,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-11-15 15:56:21,233901242,"@@ -75,35 +73,134 @@ pub struct RequestedCreds {
 
 #[derive(Debug, Deserialize, Serialize, PartialEq)]
 pub struct CredInfo {
+    pub requested_attr: String,
     pub referent: String,
     pub schema_id: String,
     pub cred_def_id: String,
+    pub rev_reg_id: Option<String>,
+    pub cred_rev_id: Option<String>,
+    pub revocation_interval: Option<NonRevokedInterval>,
+    pub tails_file: Option<String>,
+    pub timestamp: Option<u64>
 }
 
-fn credential_def_identifiers(credentials: &str) -> Result<Vec<(String, String, String, String)>, ProofError> {
+fn credential_def_identifiers(credentials: &str, proof_req: &ProofRequestData)
+    -> Result<Vec<CredInfo>, ProofError> {
+
     let mut rtn = Vec::new();
 
     let credentials: Value = serde_json::from_str(credentials)
-        .or(Err(ProofError::CommonError(error::INVALID_JSON.code_num)))?;
+        .or(Err(ProofError::InvalidJson()))?;
 
     if let Value::Object(ref attrs) = credentials[""attrs""] {
         for (requested_attr, value) in attrs {
-            if let Some(ref attr_obj) = value.get(""cred_info"") {
-                rtn.push((
-                    requested_attr.to_string(),
-                    serde_utils::get_value_to_string(""referent"", attr_obj)
-                        .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""schema_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""cred_def_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?
-                 ));
-            }
+            if let (Some(referent), Some(schema_id), Some(cred_def_id)) =
+            (value[""credential""][""cred_info""][""referent""].as_str(),
+             value[""credential""][""cred_info""][""schema_id""].as_str(),
+             value[""credential""][""cred_info""][""cred_def_id""].as_str()) {
+
+                let rev_reg_id = value[""credential""][""cred_info""][""rev_reg_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let cred_rev_id = value[""credential""][""cred_info""][""cred_rev_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let tails_file = value[""tails_file""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                rtn.push(
+                    CredInfo {
+                        requested_attr: requested_attr.to_string(),
+                        referent: referent.to_string(),
+                        schema_id: schema_id.to_string(),
+                        cred_def_id: cred_def_id.to_string(),
+                        revocation_interval: _get_revocation_interval(&requested_attr, &proof_req)?,
+                        timestamp: None,
+                        rev_reg_id,
+                        cred_rev_id,
+                        tails_file,
+                    }
+                );
+            } else { return Err(ProofError::InvalidCredData()) }
         }
     }
+
     Ok(rtn)
 }
 
+fn _get_revocation_interval(attr_name: &str, proof_req: &ProofRequestData)
+    -> Result<Option<NonRevokedInterval>, ProofError> {
+
+    if let Some(ref attr) = proof_req.requested_attributes.get(attr_name) {
+
+        if let Some(ref interval) = attr.non_revoked {
+            return Ok(Some(NonRevokedInterval {from: interval.from, to: interval.to}))
+        }
+        else if let Some(ref interval) = proof_req.non_revoked {
+            return Ok(Some(NonRevokedInterval { from: interval.from, to: interval.to }))
+        }
+
+        return Ok(None)
+    }
+    // Todo: Handle case for predicates
+
+    Err(ProofError::InvalidCredData())
+}
+
+// Also updates timestamp in credentials_identifiers
+fn build_rev_states_json(credentials_identifiers: &mut Vec<CredInfo>) -> Result<String, ProofError> {
+    let mut rtn: Value = json!({});
+    let mut timestamps: HashMap<String, u64> = HashMap::new();
+
+    for cred_info in credentials_identifiers.iter_mut() {
+        if let (Some(rev_reg_id), Some(cred_rev_id), Some(tails_file)) =
+        (&cred_info.rev_reg_id, &cred_info.cred_rev_id, &cred_info.tails_file) {
+
+            if rtn.get(&rev_reg_id).is_none() {
+                let (from, to) = if let Some(ref interval) = cred_info.revocation_interval
+                    { (interval.from, interval.to) }
+                else { (None, None )};
+
+                let (_, rev_reg_def_json) = get_rev_reg_def_json(&rev_reg_id)
+                    .map_err(|e| ProofError::CommonError(e))?;
+
+                let (rev_reg_id, rev_reg_delta_json, timestamp) = get_rev_reg_delta_json(",,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/233901242,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r233901242,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,"This interval must no be used ""as is"" for boundaries of `get_rev_reg_delta` request to the ledger",846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-11-15 15:57:21,233901722,"@@ -75,35 +73,134 @@ pub struct RequestedCreds {
 
 #[derive(Debug, Deserialize, Serialize, PartialEq)]
 pub struct CredInfo {
+    pub requested_attr: String,
     pub referent: String,
     pub schema_id: String,
     pub cred_def_id: String,
+    pub rev_reg_id: Option<String>,
+    pub cred_rev_id: Option<String>,
+    pub revocation_interval: Option<NonRevokedInterval>,
+    pub tails_file: Option<String>,
+    pub timestamp: Option<u64>
 }
 
-fn credential_def_identifiers(credentials: &str) -> Result<Vec<(String, String, String, String)>, ProofError> {
+fn credential_def_identifiers(credentials: &str, proof_req: &ProofRequestData)
+    -> Result<Vec<CredInfo>, ProofError> {
+
     let mut rtn = Vec::new();
 
     let credentials: Value = serde_json::from_str(credentials)
-        .or(Err(ProofError::CommonError(error::INVALID_JSON.code_num)))?;
+        .or(Err(ProofError::InvalidJson()))?;
 
     if let Value::Object(ref attrs) = credentials[""attrs""] {
         for (requested_attr, value) in attrs {
-            if let Some(ref attr_obj) = value.get(""cred_info"") {
-                rtn.push((
-                    requested_attr.to_string(),
-                    serde_utils::get_value_to_string(""referent"", attr_obj)
-                        .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""schema_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""cred_def_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?
-                 ));
-            }
+            if let (Some(referent), Some(schema_id), Some(cred_def_id)) =
+            (value[""credential""][""cred_info""][""referent""].as_str(),
+             value[""credential""][""cred_info""][""schema_id""].as_str(),
+             value[""credential""][""cred_info""][""cred_def_id""].as_str()) {
+
+                let rev_reg_id = value[""credential""][""cred_info""][""rev_reg_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let cred_rev_id = value[""credential""][""cred_info""][""cred_rev_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let tails_file = value[""tails_file""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                rtn.push(
+                    CredInfo {
+                        requested_attr: requested_attr.to_string(),
+                        referent: referent.to_string(),
+                        schema_id: schema_id.to_string(),
+                        cred_def_id: cred_def_id.to_string(),
+                        revocation_interval: _get_revocation_interval(&requested_attr, &proof_req)?,
+                        timestamp: None,
+                        rev_reg_id,
+                        cred_rev_id,
+                        tails_file,
+                    }
+                );
+            } else { return Err(ProofError::InvalidCredData()) }
         }
     }
+
     Ok(rtn)
 }
 
+fn _get_revocation_interval(attr_name: &str, proof_req: &ProofRequestData)
+    -> Result<Option<NonRevokedInterval>, ProofError> {
+
+    if let Some(ref attr) = proof_req.requested_attributes.get(attr_name) {
+
+        if let Some(ref interval) = attr.non_revoked {
+            return Ok(Some(NonRevokedInterval {from: interval.from, to: interval.to}))
+        }
+        else if let Some(ref interval) = proof_req.non_revoked {
+            return Ok(Some(NonRevokedInterval { from: interval.from, to: interval.to }))
+        }
+
+        return Ok(None)
+    }
+    // Todo: Handle case for predicates
+
+    Err(ProofError::InvalidCredData())
+}
+
+// Also updates timestamp in credentials_identifiers
+fn build_rev_states_json(credentials_identifiers: &mut Vec<CredInfo>) -> Result<String, ProofError> {
+    let mut rtn: Value = json!({});
+    let mut timestamps: HashMap<String, u64> = HashMap::new();
+
+    for cred_info in credentials_identifiers.iter_mut() {
+        if let (Some(rev_reg_id), Some(cred_rev_id), Some(tails_file)) =
+        (&cred_info.rev_reg_id, &cred_info.cred_rev_id, &cred_info.tails_file) {
+
+            if rtn.get(&rev_reg_id).is_none() {
+                let (from, to) = if let Some(ref interval) = cred_info.revocation_interval
+                    { (interval.from, interval.to) }",130,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/233901722,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r233901722,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,"Proover should choose timestamp from this ""allowed"" interval. And request delta from his latest state to chosen timestamp.",846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-11-15 15:59:39,233902746,"@@ -75,35 +73,134 @@ pub struct RequestedCreds {
 
 #[derive(Debug, Deserialize, Serialize, PartialEq)]
 pub struct CredInfo {
+    pub requested_attr: String,
     pub referent: String,
     pub schema_id: String,
     pub cred_def_id: String,
+    pub rev_reg_id: Option<String>,
+    pub cred_rev_id: Option<String>,
+    pub revocation_interval: Option<NonRevokedInterval>,
+    pub tails_file: Option<String>,
+    pub timestamp: Option<u64>
 }
 
-fn credential_def_identifiers(credentials: &str) -> Result<Vec<(String, String, String, String)>, ProofError> {
+fn credential_def_identifiers(credentials: &str, proof_req: &ProofRequestData)
+    -> Result<Vec<CredInfo>, ProofError> {
+
     let mut rtn = Vec::new();
 
     let credentials: Value = serde_json::from_str(credentials)
-        .or(Err(ProofError::CommonError(error::INVALID_JSON.code_num)))?;
+        .or(Err(ProofError::InvalidJson()))?;
 
     if let Value::Object(ref attrs) = credentials[""attrs""] {
         for (requested_attr, value) in attrs {
-            if let Some(ref attr_obj) = value.get(""cred_info"") {
-                rtn.push((
-                    requested_attr.to_string(),
-                    serde_utils::get_value_to_string(""referent"", attr_obj)
-                        .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""schema_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""cred_def_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?
-                 ));
-            }
+            if let (Some(referent), Some(schema_id), Some(cred_def_id)) =
+            (value[""credential""][""cred_info""][""referent""].as_str(),
+             value[""credential""][""cred_info""][""schema_id""].as_str(),
+             value[""credential""][""cred_info""][""cred_def_id""].as_str()) {
+
+                let rev_reg_id = value[""credential""][""cred_info""][""rev_reg_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let cred_rev_id = value[""credential""][""cred_info""][""cred_rev_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let tails_file = value[""tails_file""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                rtn.push(
+                    CredInfo {
+                        requested_attr: requested_attr.to_string(),
+                        referent: referent.to_string(),
+                        schema_id: schema_id.to_string(),
+                        cred_def_id: cred_def_id.to_string(),
+                        revocation_interval: _get_revocation_interval(&requested_attr, &proof_req)?,
+                        timestamp: None,
+                        rev_reg_id,
+                        cred_rev_id,
+                        tails_file,
+                    }
+                );
+            } else { return Err(ProofError::InvalidCredData()) }
         }
     }
+
     Ok(rtn)
 }
 
+fn _get_revocation_interval(attr_name: &str, proof_req: &ProofRequestData)
+    -> Result<Option<NonRevokedInterval>, ProofError> {
+
+    if let Some(ref attr) = proof_req.requested_attributes.get(attr_name) {
+
+        if let Some(ref interval) = attr.non_revoked {
+            return Ok(Some(NonRevokedInterval {from: interval.from, to: interval.to}))
+        }
+        else if let Some(ref interval) = proof_req.non_revoked {
+            return Ok(Some(NonRevokedInterval { from: interval.from, to: interval.to }))
+        }
+
+        return Ok(None)
+    }
+    // Todo: Handle case for predicates
+
+    Err(ProofError::InvalidCredData())
+}
+
+// Also updates timestamp in credentials_identifiers
+fn build_rev_states_json(credentials_identifiers: &mut Vec<CredInfo>) -> Result<String, ProofError> {
+    let mut rtn: Value = json!({});
+    let mut timestamps: HashMap<String, u64> = HashMap::new();
+
+    for cred_info in credentials_identifiers.iter_mut() {
+        if let (Some(rev_reg_id), Some(cred_rev_id), Some(tails_file)) =
+        (&cred_info.rev_reg_id, &cred_info.cred_rev_id, &cred_info.tails_file) {
+
+            if rtn.get(&rev_reg_id).is_none() {
+                let (from, to) = if let Some(ref interval) = cred_info.revocation_interval
+                    { (interval.from, interval.to) }",130,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/233902746,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r233902746,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,Is this the ticket you are talking about? https://jira.hyperledger.org/browse/IS-1074,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-11-16 12:42:49,234191437,"@@ -26,9 +26,11 @@ use utils::threadpool::spawn;
 ///
 /// tag: way to create a unique credential def with the same schema and issuer did.
 ///
-//Todo: Provide more info about the config
-/// config: revocation info
-///
+/// revocation details: type-specific configuration of credential definition revocation
+///     support_revocation: true|false - Optional, by default its false",9,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/234191437,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r234191437,dkulic
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,"yes, this one seems good to be mentioned here",846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-11-20 11:16:56,234962258,"@@ -26,9 +26,11 @@ use utils::threadpool::spawn;
 ///
 /// tag: way to create a unique credential def with the same schema and issuer did.
 ///
-//Todo: Provide more info about the config
-/// config: revocation info
-///
+/// revocation details: type-specific configuration of credential definition revocation
+///     support_revocation: true|false - Optional, by default its false",9,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/234962258,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r234962258,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,https://jira.hyperledger.org/browse/IS-1095,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-11-27 12:50:08,236648317,"@@ -457,11 +457,32 @@ pub extern fn vcx_disclosed_proof_retrieve_credentials(command_handle: u32,
 /// handle: Proof handle that was provided during creation. Used to identify the disclosed proof object
 ///
 /// selected_credentials: a json string with a credential for each proof request attribute.
-/// List of possible credentials for each attribute is returned from vcx_disclosed_proof_retrieve_credentials
-/// # Examples selected_credential -> ""{""req_attr_0"":cred_info}"" Where cred_info is returned from retrieve credentials
+///     List of possible credentials for each attribute is returned from vcx_disclosed_proof_retrieve_credentials,
+///         (user needs to select specific credential to use from list of credentials)
+///         {
+///             ""attrs"":{
+///                 String:{// Attribute key: This may not be the same as the attr name ex. ""age_1"" where attribute name is ""age""
+///                     ""credential"": {
+///                         ""cred_info"":{
+///                             ""referent"":String,
+///                             ""attrs"":{ String: String }, // ex. {""age"": ""111"", ""name"": ""Bob""}
+///                             ""schema_id"": String,
+///                             ""cred_def_id"": String,
+///                             ""rev_reg_id"":Option<String>,
+///                             ""cred_rev_id"":Option<String>,
+///                             },
+///                         ""interval"":Option<{to: Option<u64>, from:: Option<u64>}>
+///                     }, // This is the exact credential information selected from list of
+///                        // credentials returned from vcx_disclosed_proof_retrieve_credentials
+///                     ""tails_file"": Option<""String"">, // Path to tails file for this credential
+///                 },
+///            },
+///           ""predicates"":{ WILL PROVIDE MORE DETAILS WHEN PREDICATES ARE IMPLEMENTED }",,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/236648317,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r236648317,dkulic
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,You want ticket mentioned in the code? Is that a good idea? :),846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-11-28 10:03:31,237014734,"@@ -26,9 +26,11 @@ use utils::threadpool::spawn;
 ///
 /// tag: way to create a unique credential def with the same schema and issuer did.
 ///
-//Todo: Provide more info about the config
-/// config: revocation info
-///
+/// revocation details: type-specific configuration of credential definition revocation
+///     support_revocation: true|false - Optional, by default its false",9,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/237014734,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r237014734,dkulic
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,@dkulic please include ref to the issue into codebase comments (I think short comment + IS-1075 will be enough),846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-11-28 10:11:01,237017401,"@@ -26,9 +26,11 @@ use utils::threadpool::spawn;
 ///
 /// tag: way to create a unique credential def with the same schema and issuer did.
 ///
-//Todo: Provide more info about the config
-/// config: revocation info
-///
+/// revocation details: type-specific configuration of credential definition revocation
+///     support_revocation: true|false - Optional, by default its false",9,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/237017401,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r237017401,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,"OK, np. ",846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-11-28 10:12:43,237018071,"@@ -26,9 +26,11 @@ use utils::threadpool::spawn;
 ///
 /// tag: way to create a unique credential def with the same schema and issuer did.
 ///
-//Todo: Provide more info about the config
-/// config: revocation info
-///
+/// revocation details: type-specific configuration of credential definition revocation
+///     support_revocation: true|false - Optional, by default its false",9,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/237018071,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r237018071,dkulic
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,@glowkey What the process for VCX to make breaking changes in API?,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-06 12:28:27,239434449,"@@ -35,6 +72,7 @@ pub extern fn vcx_proof_create(command_handle: u32,
                                source_id: *const c_char,
                                requested_attrs: *const c_char,
                                requested_predicates: *const c_char,
+                               revocation_interval: *const c_char,",57,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/239434449,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r239434449,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,please fix incorrect merge,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-06 12:29:44,239434779,"@@ -47,21 +60,33 @@ impl CredentialDef {
         CredentialDef::from_string_with_version(&input).or(Err(CredDefError::CreateCredDefError()))
     }
 
-    pub fn to_string(&self) -> String {
-        self.to_string_with_version()
-    }
+    pub fn to_string(&self) -> String { self.to_string_with_version() }
 
     pub fn get_source_id(&self) -> &String { &self.source_id }
 
+    pub fn get_rev_reg_id(&self) -> Option<String> { self.rev_reg_id.clone() }
+
+    pub fn get_tails_file(&self) -> Option<String> {self.tails_file.clone() }
+
+    pub fn get_rev_reg_def(&self) -> Option<String> { self.rev_reg_def.clone() }
+
     pub fn get_cred_def_id(&self) -> &String { &self.id }
 
     pub fn set_name(&mut self, name: String) { self.name = name.clone(); }
 
     pub fn set_source_id(&mut self, source_id: String) { self.source_id = source_id.clone(); }
 
+<<<<<<< HEAD",,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/239434779,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r239434779,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,please fix incorrect merge,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-06 12:30:06,239434893,"@@ -83,98 +108,87 @@ pub fn create_new_credentialdef(source_id: String,
                                 issuer_did: String,
                                 schema_id: String,
                                 tag: String,
+<<<<<<< HEAD",,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/239434893,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r239434893,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,In general it's possible situation that Proover should prepare multiply state of same revocation registry for different timestamp. But it's acceptable to merge first version without this functionality for MVP quality.,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-06 12:33:52,239435899,"@@ -75,35 +74,191 @@ pub struct RequestedCreds {
 
 #[derive(Debug, Deserialize, Serialize, PartialEq)]
 pub struct CredInfo {
+    pub requested_attr: String,
     pub referent: String,
     pub schema_id: String,
     pub cred_def_id: String,
+    pub rev_reg_id: Option<String>,
+    pub cred_rev_id: Option<String>,
+    pub revocation_interval: Option<NonRevokedInterval>,
+    pub tails_file: Option<String>,
+    pub timestamp: Option<u64>
 }
 
-fn credential_def_identifiers(credentials: &str) -> Result<Vec<(String, String, String, String)>, ProofError> {
+fn credential_def_identifiers(credentials: &str, proof_req: &ProofRequestData)
+    -> Result<Vec<CredInfo>, ProofError> {
+
     let mut rtn = Vec::new();
 
     let credentials: Value = serde_json::from_str(credentials)
-        .or(Err(ProofError::CommonError(error::INVALID_JSON.code_num)))?;
+        .or(Err(ProofError::InvalidJson()))?;
 
     if let Value::Object(ref attrs) = credentials[""attrs""] {
         for (requested_attr, value) in attrs {
-            if let Some(ref attr_obj) = value.get(""cred_info"") {
-                rtn.push((
-                    requested_attr.to_string(),
-                    serde_utils::get_value_to_string(""referent"", attr_obj)
-                        .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""schema_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""cred_def_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?
-                 ));
-            }
+            if let (Some(referent), Some(schema_id), Some(cred_def_id)) =
+            (value[""credential""][""cred_info""][""referent""].as_str(),
+             value[""credential""][""cred_info""][""schema_id""].as_str(),
+             value[""credential""][""cred_info""][""cred_def_id""].as_str()) {
+
+                let rev_reg_id = value[""credential""][""cred_info""][""rev_reg_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let cred_rev_id = value[""credential""][""cred_info""][""cred_rev_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let tails_file = value[""tails_file""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                rtn.push(
+                    CredInfo {
+                        requested_attr: requested_attr.to_string(),
+                        referent: referent.to_string(),
+                        schema_id: schema_id.to_string(),
+                        cred_def_id: cred_def_id.to_string(),
+                        revocation_interval: _get_revocation_interval(&requested_attr, &proof_req)?,
+                        timestamp: None,
+                        rev_reg_id,
+                        cred_rev_id,
+                        tails_file,
+                    }
+                );
+            } else { return Err(ProofError::InvalidCredData()) }
         }
     }
+
     Ok(rtn)
 }
 
+fn _get_revocation_interval(attr_name: &str, proof_req: &ProofRequestData)
+    -> Result<Option<NonRevokedInterval>, ProofError> {
+
+    if let Some(ref attr) = proof_req.requested_attributes.get(attr_name) {
+
+        if let Some(ref interval) = attr.non_revoked {
+            return Ok(Some(NonRevokedInterval {from: interval.from, to: interval.to}))
+        }
+        else if let Some(ref interval) = proof_req.non_revoked {
+            return Ok(Some(NonRevokedInterval { from: interval.from, to: interval.to }))
+        }
+
+        return Ok(None)
+    }
+    // Todo: Handle case for predicates
+
+    Err(ProofError::InvalidCredData())
+}
+
+// Also updates timestamp in credentials_identifiers
+fn build_rev_states_json(credentials_identifiers: &mut Vec<CredInfo>) -> Result<String, ProofError> {
+    let mut rtn: Value = json!({});
+    let mut timestamps: HashMap<String, u64> = HashMap::new();
+
+    for cred_info in credentials_identifiers.iter_mut() {
+        if let (Some(rev_reg_id), Some(cred_rev_id), Some(tails_file)) =
+        (&cred_info.rev_reg_id, &cred_info.cred_rev_id, &cred_info.tails_file) {
+
+            if rtn.get(&rev_reg_id).is_none() {
+                let (from, to) = if let Some(ref interval) = cred_info.revocation_interval
+                    { (interval.from, interval.to) }
+                else { (None, None )};
+
+//                let from = from.unwrap_or(0);
+//                let to = to.unwrap_or(time::get_time().sec as u64);
+                let cache = get_rev_reg_cache(&rev_reg_id);
+
+                let (rev_state_json, timestamp) = if let Some(cached_rev_state) = cache.rev_state {
+                    if cached_rev_state.timestamp >= from.unwrap_or(0)
+                        && cached_rev_state.timestamp <= to.unwrap_or(time::get_time().sec as u64) {
+                        (cached_rev_state.value, cached_rev_state.timestamp)
+                    } else {
+                        let from = match from {
+                            Some(from) if from >= cached_rev_state.timestamp => {
+                                Some(cached_rev_state.timestamp)
+                            },
+                            _ => None
+                        };
+
+                        let (_, rev_reg_def_json) = get_rev_reg_def_json(&rev_reg_id)
+                            .map_err(|e| ProofError::CommonError(e))?;
+
+                        let (rev_reg_id, rev_reg_delta_json, timestamp) = get_rev_reg_delta_json(
+                            &rev_reg_id,
+                            from,
+                            to
+                        ).map_err(|e| ProofError::CommonError(e))?;
+
+                        let rev_state_json = anoncreds::libindy_prover_update_revocation_state(
+                            &rev_reg_def_json,
+                            &cached_rev_state.value,
+                            &rev_reg_delta_json,
+                            &cred_rev_id,
+                            &tails_file
+                        ).map_err(|e| ProofError::CommonError(e))?;
+
+                        if timestamp > cached_rev_state.timestamp {
+                            let new_cache = RevRegCache {
+                                rev_state: Some(RevState {
+                                    timestamp: timestamp,
+                                    value: rev_state_json.clone()
+                                })
+                            };
+                            set_rev_reg_cache(&rev_reg_id, &new_cache);
+                        }
+
+                        (rev_state_json, timestamp)
+                    }
+                } else {
+                    let (_, rev_reg_def_json) = get_rev_reg_def_json(&rev_reg_id)
+                        .map_err(|e| ProofError::CommonError(e))?;
+
+                    let (rev_reg_id, rev_reg_delta_json, timestamp) = get_rev_reg_delta_json(
+                        &rev_reg_id,
+                        None,
+                        to
+                    ).map_err(|e| ProofError::CommonError(e))?;
+
+                    let rev_state_json = anoncreds::libindy_prover_create_revocation_state(
+                        &rev_reg_def_json,
+                        &rev_reg_delta_json,
+                        &cred_rev_id,
+                        &tails_file
+                    ).map_err(|e| ProofError::CommonError(e))?;
+
+                    let new_cache = RevRegCache {
+                        rev_state: Some(RevState {
+                            timestamp: timestamp,
+                            value: rev_state_json.clone()
+                        })
+                    };
+                    set_rev_reg_cache(&rev_reg_id, &new_cache);
+
+                    (rev_state_json, timestamp)
+                };
+
+                let rev_state_json: Value = serde_json::from_str(&rev_state_json)
+                    .or(Err(ProofError::InvalidJson()))?;
+
+                rtn[rev_reg_id.to_string()] = json!({timestamp.to_string(): rev_state_json});",211,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/239435899,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r239435899,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,"May be it's better to rename the structure to `RevRegStateCache` ? (and also update prefix constant above)
Or we are going to add fields to this structure in the future?",846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-06 12:42:45,239438354,"@@ -0,0 +1,191 @@
+extern crate serde_json;
+
+use utils::libindy::wallet::{add_record, get_record, update_record_value};
+
+static CACHE_TYPE: &str = ""cache"";
+static REV_REG_CACHE_PREFIX: &str = ""rev_reg:"";
+
+///
+/// Cache object for rev reg cache
+///
+#[derive(Serialize, Deserialize, Debug, Default, PartialEq)]
+pub struct RevRegCache {",12,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/239438354,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r239438354,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,@glowkey @dkulic I don't like the idea of mixing anoncreds and ledger logic inside `utils/libindy/ledger.rs` but if it's common approach in VCX for now - we can accept it and don't perform global refactoring in scope of this PR,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-06 12:48:16,239439700,"@@ -84,3 +90,359 @@ pub fn libindy_build_create_credential_def_txn(submitter_did: &str,
         .wait()
         .map_err(map_rust_indy_sdk_error_code)
 }
+
+pub fn libindy_build_revoc_reg_def_request(submitter_did: &str,
+                                           rev_reg_def_json: &str) -> Result<String, u32> {
+    ledger::build_revoc_reg_def_request(submitter_did, rev_reg_def_json)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+
+pub fn libindy_build_revoc_reg_entry_request(submitter_did: &str,
+                                             rev_reg_id: &str,
+                                             rev_def_type: &str,
+                                             value: &str) -> Result<String, u32> {
+    ledger::build_revoc_reg_entry_request(submitter_did, rev_reg_id, rev_def_type, value)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_build_get_revoc_reg_def_request(submitter_did: &str, rev_reg_id: &str) -> Result<String, u32> {
+    ledger::build_get_revoc_reg_def_request(Some(submitter_did), rev_reg_id)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_parse_get_revoc_reg_def_response(rev_reg_def_json: &str) -> Result<(String, String), u32> {
+    ledger::parse_get_revoc_reg_def_response(rev_reg_def_json)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_build_get_revoc_reg_delta_request(submitter_did: &str,
+                                                 rev_reg_id: &str,
+                                                 from: i64,
+                                                 to: i64) -> Result<String, u32> {
+    ledger::build_get_revoc_reg_delta_request(Some(submitter_did),
+                                              rev_reg_id,
+                                              from,
+                                              to)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+fn libindy_build_get_revoc_reg_request(submitter_did: &str, rev_reg_id: &str, timestamp: u64)
+    -> Result<String, u32> {
+    ledger::build_get_revoc_reg_request(Some(submitter_did),
+                                        rev_reg_id,
+                                        timestamp as i64)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+fn libindy_parse_get_revoc_reg_response(get_rev_reg_resp: &str) -> Result<(String, String, u64), u32> {
+    ledger::parse_get_revoc_reg_response(get_rev_reg_resp)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_parse_get_revoc_reg_delta_response(get_rev_reg_delta_response: &str)
+    -> Result<(String, String, u64), u32> {
+    ledger::parse_get_revoc_reg_delta_response(get_rev_reg_delta_response)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn create_schema(name: &str, version: &str, data: &str) -> Result<(String, Option<PaymentTxn>), u32> {
+    if settings::test_indy_mode_enabled() {
+        return Ok((SCHEMA_ID.to_string(), Some(PaymentTxn::from_parts(r#""[""pay:null:9UFgyjuJxi1i1HD""]""#,r#""[{""amount"":4,""extra"":null,""recipient"":""pay:null:xkIsxem0YNtHrRO""}]""#,1, false).unwrap(), )));
+    }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    let (id, create_schema) = libindy_issuer_create_schema(&submitter_did, name, version, data)?;
+
+    let request = libindy_build_schema_request(&submitter_did, &create_schema)?;
+
+    let (payment, response) = pay_for_txn(&request, SCHEMA_TXN_TYPE)?;
+
+    _check_create_schema_response(&response)?;
+
+    Ok((id, payment))
+}
+
+fn _check_create_schema_response(response: &str) -> Result<(), u32> {
+    let response: Value = serde_json::from_str(response).or(Err(error::INVALID_JSON.code_num))?;
+
+    if let Some(_) = response.get(""result"") { return Ok(()) };
+
+    warn!(""No result found in ledger txn. Must be Rejected"");
+
+    if response[""op""] == json!(""REJECT"") {
+        match response.get(""reason"") {
+            Some(r) => return Err(error::DUPLICATE_SCHEMA.code_num),
+            None => return Err(error::UNKNOWN_SCHEMA_REJECTION.code_num),
+        }
+    }
+
+    Err(error::UNKNOWN_SCHEMA_REJECTION.code_num)
+}
+
+pub fn get_schema_json(schema_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((SCHEMA_ID.to_string(), SCHEMA_JSON.to_string()))}
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+    libindy_build_get_schema_request(&submitter_did, schema_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_schema_response(&response))
+}
+
+pub fn create_cred_def(issuer_did: &str,
+                       schema_json: &str,
+                       tag: &str,
+                       sig_type: Option<&str>,
+                       support_revocation: Option<bool>) -> Result<(String, Option<PaymentTxn>), u32> {
+    if settings::test_indy_mode_enabled() {
+        return Ok((CRED_DEF_ID.to_string(), Some(PaymentTxn::from_parts(r#""[""pay:null:9UFgyjuJxi1i1HD""]""#,r#""[{""amount"":4,""extra"":null,""recipient"":""pay:null:xkIsxem0YNtHrRO""}]""#,1, false).unwrap())));
+    }
+
+    let config_json = json!({""support_revocation"": support_revocation.unwrap_or(false)}).to_string();
+
+    let (id, cred_def_json) = libindy_create_and_store_credential_def(issuer_did,
+                                                                      schema_json,
+                                                                      tag,
+                                                                      sig_type,
+                                                                      &config_json)?;
+
+    let cred_def_req = libindy_build_create_credential_def_txn(issuer_did, &cred_def_json)?;
+
+    let (payment, response) = pay_for_txn(&cred_def_req, CRED_DEF_TXN_TYPE)?;
+
+    Ok((id, payment))
+}
+
+pub fn get_cred_def_json(cred_def_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((CRED_DEF_ID.to_string(), CRED_DEF_JSON.to_string())); }
+
+    libindy_build_get_credential_def_txn(cred_def_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_cred_def_response(&response))
+}
+
+pub fn create_rev_reg_def(issuer_did: &str, cred_def_id: &str, tails_file: &str, max_creds: u32)
+    -> Result<(String, String, String, Option<PaymentTxn>), u32> {
+    debug!(""creating revocation registry definition with issuer_did: {}, cred_def_id: {}, tails_file_path: {}, max_creds: {}"",
+           issuer_did, cred_def_id, tails_file, max_creds);
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_DEF_JSON.to_string(), """".to_string(), None)); }
+
+    let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) = libindy_create_and_store_revoc_reg(
+        issuer_did,
+        cred_def_id,
+        tails_file,
+        max_creds
+    )?;
+
+    let rev_reg_def_req = libindy_build_revoc_reg_def_request(issuer_did, &rev_reg_def_json)?;
+
+    let (payment, _) = pay_for_txn(&rev_reg_def_req, REV_REG_DEF_TXN_TYPE)?;
+
+    Ok((rev_reg_id, rev_reg_def_json, rev_reg_entry_json, payment))
+}
+
+pub fn get_rev_reg_def_json(rev_reg_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_DEF_JSON.to_string())); }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    libindy_build_get_revoc_reg_def_request(&submitter_did, rev_reg_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_def_response(&response))
+}
+
+pub fn post_rev_reg_delta(issuer_did: &str, rev_reg_id: &str, rev_reg_entry_json: &str)
+                          -> Result<(Option<PaymentTxn>, String), u32> {
+    libindy_build_revoc_reg_entry_request(issuer_did, rev_reg_id, REVOC_REG_TYPE, rev_reg_entry_json)
+        .and_then(|req| pay_for_txn(&req, REV_REG_DELTA_TXN_TYPE))
+}
+
+pub fn get_rev_reg_delta_json(rev_reg_id: &str, from: Option<u64>, to: Option<u64>)
+    -> Result<(String, String, u64), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_REG_DELTA_JSON.to_string(), 1)); }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+    let from: i64 = if let Some(_from) = from { _from as i64 } else { -1 };
+    let to = if let Some(_to) = to { _to as i64 } else { time::get_time().sec };
+
+    libindy_build_get_revoc_reg_delta_request(&submitter_did, rev_reg_id, from, to)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_delta_response(&response))
+}
+
+pub fn get_rev_reg(rev_reg_id: &str, timestamp: u64) -> Result<(String, String, u64), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_REG_JSON.to_string(), 1)); }
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    libindy_build_get_revoc_reg_request(&submitter_did, rev_reg_id, timestamp)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_response(&response))
+}
+
+pub fn revoke_credential(tails_file: &str, rev_reg_id: &str, cred_rev_id: &str)",,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/239439700,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r239439700,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,"If we would like to append fields to the same structure, how do you think, is it good idea to fetch whole structure each time?",846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-06 12:52:06,239440808,"@@ -0,0 +1,191 @@
+extern crate serde_json;
+
+use utils::libindy::wallet::{add_record, get_record, update_record_value};
+
+static CACHE_TYPE: &str = ""cache"";
+static REV_REG_CACHE_PREFIX: &str = ""rev_reg:"";
+
+///
+/// Cache object for rev reg cache
+///
+#[derive(Serialize, Deserialize, Debug, Default, PartialEq)]
+pub struct RevRegCache {",12,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/239440808,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r239440808,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,I agree.  There is a separate anoncreds.rs module that can be used.,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-06 14:42:06,239477569,"@@ -84,3 +90,359 @@ pub fn libindy_build_create_credential_def_txn(submitter_did: &str,
         .wait()
         .map_err(map_rust_indy_sdk_error_code)
 }
+
+pub fn libindy_build_revoc_reg_def_request(submitter_did: &str,
+                                           rev_reg_def_json: &str) -> Result<String, u32> {
+    ledger::build_revoc_reg_def_request(submitter_did, rev_reg_def_json)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+
+pub fn libindy_build_revoc_reg_entry_request(submitter_did: &str,
+                                             rev_reg_id: &str,
+                                             rev_def_type: &str,
+                                             value: &str) -> Result<String, u32> {
+    ledger::build_revoc_reg_entry_request(submitter_did, rev_reg_id, rev_def_type, value)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_build_get_revoc_reg_def_request(submitter_did: &str, rev_reg_id: &str) -> Result<String, u32> {
+    ledger::build_get_revoc_reg_def_request(Some(submitter_did), rev_reg_id)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_parse_get_revoc_reg_def_response(rev_reg_def_json: &str) -> Result<(String, String), u32> {
+    ledger::parse_get_revoc_reg_def_response(rev_reg_def_json)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_build_get_revoc_reg_delta_request(submitter_did: &str,
+                                                 rev_reg_id: &str,
+                                                 from: i64,
+                                                 to: i64) -> Result<String, u32> {
+    ledger::build_get_revoc_reg_delta_request(Some(submitter_did),
+                                              rev_reg_id,
+                                              from,
+                                              to)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+fn libindy_build_get_revoc_reg_request(submitter_did: &str, rev_reg_id: &str, timestamp: u64)
+    -> Result<String, u32> {
+    ledger::build_get_revoc_reg_request(Some(submitter_did),
+                                        rev_reg_id,
+                                        timestamp as i64)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+fn libindy_parse_get_revoc_reg_response(get_rev_reg_resp: &str) -> Result<(String, String, u64), u32> {
+    ledger::parse_get_revoc_reg_response(get_rev_reg_resp)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_parse_get_revoc_reg_delta_response(get_rev_reg_delta_response: &str)
+    -> Result<(String, String, u64), u32> {
+    ledger::parse_get_revoc_reg_delta_response(get_rev_reg_delta_response)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn create_schema(name: &str, version: &str, data: &str) -> Result<(String, Option<PaymentTxn>), u32> {
+    if settings::test_indy_mode_enabled() {
+        return Ok((SCHEMA_ID.to_string(), Some(PaymentTxn::from_parts(r#""[""pay:null:9UFgyjuJxi1i1HD""]""#,r#""[{""amount"":4,""extra"":null,""recipient"":""pay:null:xkIsxem0YNtHrRO""}]""#,1, false).unwrap(), )));
+    }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    let (id, create_schema) = libindy_issuer_create_schema(&submitter_did, name, version, data)?;
+
+    let request = libindy_build_schema_request(&submitter_did, &create_schema)?;
+
+    let (payment, response) = pay_for_txn(&request, SCHEMA_TXN_TYPE)?;
+
+    _check_create_schema_response(&response)?;
+
+    Ok((id, payment))
+}
+
+fn _check_create_schema_response(response: &str) -> Result<(), u32> {
+    let response: Value = serde_json::from_str(response).or(Err(error::INVALID_JSON.code_num))?;
+
+    if let Some(_) = response.get(""result"") { return Ok(()) };
+
+    warn!(""No result found in ledger txn. Must be Rejected"");
+
+    if response[""op""] == json!(""REJECT"") {
+        match response.get(""reason"") {
+            Some(r) => return Err(error::DUPLICATE_SCHEMA.code_num),
+            None => return Err(error::UNKNOWN_SCHEMA_REJECTION.code_num),
+        }
+    }
+
+    Err(error::UNKNOWN_SCHEMA_REJECTION.code_num)
+}
+
+pub fn get_schema_json(schema_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((SCHEMA_ID.to_string(), SCHEMA_JSON.to_string()))}
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+    libindy_build_get_schema_request(&submitter_did, schema_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_schema_response(&response))
+}
+
+pub fn create_cred_def(issuer_did: &str,
+                       schema_json: &str,
+                       tag: &str,
+                       sig_type: Option<&str>,
+                       support_revocation: Option<bool>) -> Result<(String, Option<PaymentTxn>), u32> {
+    if settings::test_indy_mode_enabled() {
+        return Ok((CRED_DEF_ID.to_string(), Some(PaymentTxn::from_parts(r#""[""pay:null:9UFgyjuJxi1i1HD""]""#,r#""[{""amount"":4,""extra"":null,""recipient"":""pay:null:xkIsxem0YNtHrRO""}]""#,1, false).unwrap())));
+    }
+
+    let config_json = json!({""support_revocation"": support_revocation.unwrap_or(false)}).to_string();
+
+    let (id, cred_def_json) = libindy_create_and_store_credential_def(issuer_did,
+                                                                      schema_json,
+                                                                      tag,
+                                                                      sig_type,
+                                                                      &config_json)?;
+
+    let cred_def_req = libindy_build_create_credential_def_txn(issuer_did, &cred_def_json)?;
+
+    let (payment, response) = pay_for_txn(&cred_def_req, CRED_DEF_TXN_TYPE)?;
+
+    Ok((id, payment))
+}
+
+pub fn get_cred_def_json(cred_def_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((CRED_DEF_ID.to_string(), CRED_DEF_JSON.to_string())); }
+
+    libindy_build_get_credential_def_txn(cred_def_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_cred_def_response(&response))
+}
+
+pub fn create_rev_reg_def(issuer_did: &str, cred_def_id: &str, tails_file: &str, max_creds: u32)
+    -> Result<(String, String, String, Option<PaymentTxn>), u32> {
+    debug!(""creating revocation registry definition with issuer_did: {}, cred_def_id: {}, tails_file_path: {}, max_creds: {}"",
+           issuer_did, cred_def_id, tails_file, max_creds);
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_DEF_JSON.to_string(), """".to_string(), None)); }
+
+    let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) = libindy_create_and_store_revoc_reg(
+        issuer_did,
+        cred_def_id,
+        tails_file,
+        max_creds
+    )?;
+
+    let rev_reg_def_req = libindy_build_revoc_reg_def_request(issuer_did, &rev_reg_def_json)?;
+
+    let (payment, _) = pay_for_txn(&rev_reg_def_req, REV_REG_DEF_TXN_TYPE)?;
+
+    Ok((rev_reg_id, rev_reg_def_json, rev_reg_entry_json, payment))
+}
+
+pub fn get_rev_reg_def_json(rev_reg_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_DEF_JSON.to_string())); }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    libindy_build_get_revoc_reg_def_request(&submitter_did, rev_reg_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_def_response(&response))
+}
+
+pub fn post_rev_reg_delta(issuer_did: &str, rev_reg_id: &str, rev_reg_entry_json: &str)
+                          -> Result<(Option<PaymentTxn>, String), u32> {
+    libindy_build_revoc_reg_entry_request(issuer_did, rev_reg_id, REVOC_REG_TYPE, rev_reg_entry_json)
+        .and_then(|req| pay_for_txn(&req, REV_REG_DELTA_TXN_TYPE))
+}
+
+pub fn get_rev_reg_delta_json(rev_reg_id: &str, from: Option<u64>, to: Option<u64>)
+    -> Result<(String, String, u64), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_REG_DELTA_JSON.to_string(), 1)); }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+    let from: i64 = if let Some(_from) = from { _from as i64 } else { -1 };
+    let to = if let Some(_to) = to { _to as i64 } else { time::get_time().sec };
+
+    libindy_build_get_revoc_reg_delta_request(&submitter_did, rev_reg_id, from, to)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_delta_response(&response))
+}
+
+pub fn get_rev_reg(rev_reg_id: &str, timestamp: u64) -> Result<(String, String, u64), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_REG_JSON.to_string(), 1)); }
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    libindy_build_get_revoc_reg_request(&submitter_did, rev_reg_id, timestamp)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_response(&response))
+}
+
+pub fn revoke_credential(tails_file: &str, rev_reg_id: &str, cred_rev_id: &str)",,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/239477569,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r239477569,glowkey
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,Because libvcx has not yet reached 1.0 its API is still considered unstable.  Libvcx can follow whatever process the indy-sdk has for managing these kinds of changes.,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-06 20:02:47,239594986,"@@ -35,6 +72,7 @@ pub extern fn vcx_proof_create(command_handle: u32,
                                source_id: *const c_char,
                                requested_attrs: *const c_char,
                                requested_predicates: *const c_char,
+                               revocation_interval: *const c_char,",57,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/239594986,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r239594986,glowkey
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,For now I suggest to allow breaking-changes here,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-07 09:33:45,239743886,"@@ -35,6 +72,7 @@ pub extern fn vcx_proof_create(command_handle: u32,
                                source_id: *const c_char,
                                requested_attrs: *const c_char,
                                requested_predicates: *const c_char,
+                               revocation_interval: *const c_char,",57,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/239743886,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r239743886,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,OK.,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-07 12:24:06,239790036,"@@ -47,21 +60,33 @@ impl CredentialDef {
         CredentialDef::from_string_with_version(&input).or(Err(CredDefError::CreateCredDefError()))
     }
 
-    pub fn to_string(&self) -> String {
-        self.to_string_with_version()
-    }
+    pub fn to_string(&self) -> String { self.to_string_with_version() }
 
     pub fn get_source_id(&self) -> &String { &self.source_id }
 
+    pub fn get_rev_reg_id(&self) -> Option<String> { self.rev_reg_id.clone() }
+
+    pub fn get_tails_file(&self) -> Option<String> {self.tails_file.clone() }
+
+    pub fn get_rev_reg_def(&self) -> Option<String> { self.rev_reg_def.clone() }
+
     pub fn get_cred_def_id(&self) -> &String { &self.id }
 
     pub fn set_name(&mut self, name: String) { self.name = name.clone(); }
 
     pub fn set_source_id(&mut self, source_id: String) { self.source_id = source_id.clone(); }
 
+<<<<<<< HEAD",,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/239790036,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r239790036,dkulic
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,OK,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-07 12:24:26,239790111,"@@ -75,35 +74,191 @@ pub struct RequestedCreds {
 
 #[derive(Debug, Deserialize, Serialize, PartialEq)]
 pub struct CredInfo {
+    pub requested_attr: String,
     pub referent: String,
     pub schema_id: String,
     pub cred_def_id: String,
+    pub rev_reg_id: Option<String>,
+    pub cred_rev_id: Option<String>,
+    pub revocation_interval: Option<NonRevokedInterval>,
+    pub tails_file: Option<String>,
+    pub timestamp: Option<u64>
 }
 
-fn credential_def_identifiers(credentials: &str) -> Result<Vec<(String, String, String, String)>, ProofError> {
+fn credential_def_identifiers(credentials: &str, proof_req: &ProofRequestData)
+    -> Result<Vec<CredInfo>, ProofError> {
+
     let mut rtn = Vec::new();
 
     let credentials: Value = serde_json::from_str(credentials)
-        .or(Err(ProofError::CommonError(error::INVALID_JSON.code_num)))?;
+        .or(Err(ProofError::InvalidJson()))?;
 
     if let Value::Object(ref attrs) = credentials[""attrs""] {
         for (requested_attr, value) in attrs {
-            if let Some(ref attr_obj) = value.get(""cred_info"") {
-                rtn.push((
-                    requested_attr.to_string(),
-                    serde_utils::get_value_to_string(""referent"", attr_obj)
-                        .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""schema_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""cred_def_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?
-                 ));
-            }
+            if let (Some(referent), Some(schema_id), Some(cred_def_id)) =
+            (value[""credential""][""cred_info""][""referent""].as_str(),
+             value[""credential""][""cred_info""][""schema_id""].as_str(),
+             value[""credential""][""cred_info""][""cred_def_id""].as_str()) {
+
+                let rev_reg_id = value[""credential""][""cred_info""][""rev_reg_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let cred_rev_id = value[""credential""][""cred_info""][""cred_rev_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let tails_file = value[""tails_file""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                rtn.push(
+                    CredInfo {
+                        requested_attr: requested_attr.to_string(),
+                        referent: referent.to_string(),
+                        schema_id: schema_id.to_string(),
+                        cred_def_id: cred_def_id.to_string(),
+                        revocation_interval: _get_revocation_interval(&requested_attr, &proof_req)?,
+                        timestamp: None,
+                        rev_reg_id,
+                        cred_rev_id,
+                        tails_file,
+                    }
+                );
+            } else { return Err(ProofError::InvalidCredData()) }
         }
     }
+
     Ok(rtn)
 }
 
+fn _get_revocation_interval(attr_name: &str, proof_req: &ProofRequestData)
+    -> Result<Option<NonRevokedInterval>, ProofError> {
+
+    if let Some(ref attr) = proof_req.requested_attributes.get(attr_name) {
+
+        if let Some(ref interval) = attr.non_revoked {
+            return Ok(Some(NonRevokedInterval {from: interval.from, to: interval.to}))
+        }
+        else if let Some(ref interval) = proof_req.non_revoked {
+            return Ok(Some(NonRevokedInterval { from: interval.from, to: interval.to }))
+        }
+
+        return Ok(None)
+    }
+    // Todo: Handle case for predicates
+
+    Err(ProofError::InvalidCredData())
+}
+
+// Also updates timestamp in credentials_identifiers
+fn build_rev_states_json(credentials_identifiers: &mut Vec<CredInfo>) -> Result<String, ProofError> {
+    let mut rtn: Value = json!({});
+    let mut timestamps: HashMap<String, u64> = HashMap::new();
+
+    for cred_info in credentials_identifiers.iter_mut() {
+        if let (Some(rev_reg_id), Some(cred_rev_id), Some(tails_file)) =
+        (&cred_info.rev_reg_id, &cred_info.cred_rev_id, &cred_info.tails_file) {
+
+            if rtn.get(&rev_reg_id).is_none() {
+                let (from, to) = if let Some(ref interval) = cred_info.revocation_interval
+                    { (interval.from, interval.to) }
+                else { (None, None )};
+
+//                let from = from.unwrap_or(0);
+//                let to = to.unwrap_or(time::get_time().sec as u64);
+                let cache = get_rev_reg_cache(&rev_reg_id);
+
+                let (rev_state_json, timestamp) = if let Some(cached_rev_state) = cache.rev_state {
+                    if cached_rev_state.timestamp >= from.unwrap_or(0)
+                        && cached_rev_state.timestamp <= to.unwrap_or(time::get_time().sec as u64) {
+                        (cached_rev_state.value, cached_rev_state.timestamp)
+                    } else {
+                        let from = match from {
+                            Some(from) if from >= cached_rev_state.timestamp => {
+                                Some(cached_rev_state.timestamp)
+                            },
+                            _ => None
+                        };
+
+                        let (_, rev_reg_def_json) = get_rev_reg_def_json(&rev_reg_id)
+                            .map_err(|e| ProofError::CommonError(e))?;
+
+                        let (rev_reg_id, rev_reg_delta_json, timestamp) = get_rev_reg_delta_json(
+                            &rev_reg_id,
+                            from,
+                            to
+                        ).map_err(|e| ProofError::CommonError(e))?;
+
+                        let rev_state_json = anoncreds::libindy_prover_update_revocation_state(
+                            &rev_reg_def_json,
+                            &cached_rev_state.value,
+                            &rev_reg_delta_json,
+                            &cred_rev_id,
+                            &tails_file
+                        ).map_err(|e| ProofError::CommonError(e))?;
+
+                        if timestamp > cached_rev_state.timestamp {
+                            let new_cache = RevRegCache {
+                                rev_state: Some(RevState {
+                                    timestamp: timestamp,
+                                    value: rev_state_json.clone()
+                                })
+                            };
+                            set_rev_reg_cache(&rev_reg_id, &new_cache);
+                        }
+
+                        (rev_state_json, timestamp)
+                    }
+                } else {
+                    let (_, rev_reg_def_json) = get_rev_reg_def_json(&rev_reg_id)
+                        .map_err(|e| ProofError::CommonError(e))?;
+
+                    let (rev_reg_id, rev_reg_delta_json, timestamp) = get_rev_reg_delta_json(
+                        &rev_reg_id,
+                        None,
+                        to
+                    ).map_err(|e| ProofError::CommonError(e))?;
+
+                    let rev_state_json = anoncreds::libindy_prover_create_revocation_state(
+                        &rev_reg_def_json,
+                        &rev_reg_delta_json,
+                        &cred_rev_id,
+                        &tails_file
+                    ).map_err(|e| ProofError::CommonError(e))?;
+
+                    let new_cache = RevRegCache {
+                        rev_state: Some(RevState {
+                            timestamp: timestamp,
+                            value: rev_state_json.clone()
+                        })
+                    };
+                    set_rev_reg_cache(&rev_reg_id, &new_cache);
+
+                    (rev_state_json, timestamp)
+                };
+
+                let rev_state_json: Value = serde_json::from_str(&rev_state_json)
+                    .or(Err(ProofError::InvalidJson()))?;
+
+                rtn[rev_reg_id.to_string()] = json!({timestamp.to_string(): rev_state_json});",211,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/239790111,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r239790111,dkulic
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,"I assumed in the future this structure may grow, so I guess the name should be like that (not too specific for this case, but in general to revocation). I am not sure, which name is the best for that purpose.
My idea is to lower the cost by having only one record in wallet. So you fetch it and possibly use multiple cached values.",846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-07 12:27:33,239790882,"@@ -0,0 +1,191 @@
+extern crate serde_json;
+
+use utils::libindy::wallet::{add_record, get_record, update_record_value};
+
+static CACHE_TYPE: &str = ""cache"";
+static REV_REG_CACHE_PREFIX: &str = ""rev_reg:"";
+
+///
+/// Cache object for rev reg cache
+///
+#[derive(Serialize, Deserialize, Debug, Default, PartialEq)]
+pub struct RevRegCache {",12,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/239790882,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r239790882,dkulic
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,"Is this blocking the ticket to be merged?
",846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-10 10:01:04,240146993,"@@ -84,3 +90,359 @@ pub fn libindy_build_create_credential_def_txn(submitter_did: &str,
         .wait()
         .map_err(map_rust_indy_sdk_error_code)
 }
+
+pub fn libindy_build_revoc_reg_def_request(submitter_did: &str,
+                                           rev_reg_def_json: &str) -> Result<String, u32> {
+    ledger::build_revoc_reg_def_request(submitter_did, rev_reg_def_json)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+
+pub fn libindy_build_revoc_reg_entry_request(submitter_did: &str,
+                                             rev_reg_id: &str,
+                                             rev_def_type: &str,
+                                             value: &str) -> Result<String, u32> {
+    ledger::build_revoc_reg_entry_request(submitter_did, rev_reg_id, rev_def_type, value)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_build_get_revoc_reg_def_request(submitter_did: &str, rev_reg_id: &str) -> Result<String, u32> {
+    ledger::build_get_revoc_reg_def_request(Some(submitter_did), rev_reg_id)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_parse_get_revoc_reg_def_response(rev_reg_def_json: &str) -> Result<(String, String), u32> {
+    ledger::parse_get_revoc_reg_def_response(rev_reg_def_json)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_build_get_revoc_reg_delta_request(submitter_did: &str,
+                                                 rev_reg_id: &str,
+                                                 from: i64,
+                                                 to: i64) -> Result<String, u32> {
+    ledger::build_get_revoc_reg_delta_request(Some(submitter_did),
+                                              rev_reg_id,
+                                              from,
+                                              to)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+fn libindy_build_get_revoc_reg_request(submitter_did: &str, rev_reg_id: &str, timestamp: u64)
+    -> Result<String, u32> {
+    ledger::build_get_revoc_reg_request(Some(submitter_did),
+                                        rev_reg_id,
+                                        timestamp as i64)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+fn libindy_parse_get_revoc_reg_response(get_rev_reg_resp: &str) -> Result<(String, String, u64), u32> {
+    ledger::parse_get_revoc_reg_response(get_rev_reg_resp)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_parse_get_revoc_reg_delta_response(get_rev_reg_delta_response: &str)
+    -> Result<(String, String, u64), u32> {
+    ledger::parse_get_revoc_reg_delta_response(get_rev_reg_delta_response)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn create_schema(name: &str, version: &str, data: &str) -> Result<(String, Option<PaymentTxn>), u32> {
+    if settings::test_indy_mode_enabled() {
+        return Ok((SCHEMA_ID.to_string(), Some(PaymentTxn::from_parts(r#""[""pay:null:9UFgyjuJxi1i1HD""]""#,r#""[{""amount"":4,""extra"":null,""recipient"":""pay:null:xkIsxem0YNtHrRO""}]""#,1, false).unwrap(), )));
+    }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    let (id, create_schema) = libindy_issuer_create_schema(&submitter_did, name, version, data)?;
+
+    let request = libindy_build_schema_request(&submitter_did, &create_schema)?;
+
+    let (payment, response) = pay_for_txn(&request, SCHEMA_TXN_TYPE)?;
+
+    _check_create_schema_response(&response)?;
+
+    Ok((id, payment))
+}
+
+fn _check_create_schema_response(response: &str) -> Result<(), u32> {
+    let response: Value = serde_json::from_str(response).or(Err(error::INVALID_JSON.code_num))?;
+
+    if let Some(_) = response.get(""result"") { return Ok(()) };
+
+    warn!(""No result found in ledger txn. Must be Rejected"");
+
+    if response[""op""] == json!(""REJECT"") {
+        match response.get(""reason"") {
+            Some(r) => return Err(error::DUPLICATE_SCHEMA.code_num),
+            None => return Err(error::UNKNOWN_SCHEMA_REJECTION.code_num),
+        }
+    }
+
+    Err(error::UNKNOWN_SCHEMA_REJECTION.code_num)
+}
+
+pub fn get_schema_json(schema_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((SCHEMA_ID.to_string(), SCHEMA_JSON.to_string()))}
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+    libindy_build_get_schema_request(&submitter_did, schema_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_schema_response(&response))
+}
+
+pub fn create_cred_def(issuer_did: &str,
+                       schema_json: &str,
+                       tag: &str,
+                       sig_type: Option<&str>,
+                       support_revocation: Option<bool>) -> Result<(String, Option<PaymentTxn>), u32> {
+    if settings::test_indy_mode_enabled() {
+        return Ok((CRED_DEF_ID.to_string(), Some(PaymentTxn::from_parts(r#""[""pay:null:9UFgyjuJxi1i1HD""]""#,r#""[{""amount"":4,""extra"":null,""recipient"":""pay:null:xkIsxem0YNtHrRO""}]""#,1, false).unwrap())));
+    }
+
+    let config_json = json!({""support_revocation"": support_revocation.unwrap_or(false)}).to_string();
+
+    let (id, cred_def_json) = libindy_create_and_store_credential_def(issuer_did,
+                                                                      schema_json,
+                                                                      tag,
+                                                                      sig_type,
+                                                                      &config_json)?;
+
+    let cred_def_req = libindy_build_create_credential_def_txn(issuer_did, &cred_def_json)?;
+
+    let (payment, response) = pay_for_txn(&cred_def_req, CRED_DEF_TXN_TYPE)?;
+
+    Ok((id, payment))
+}
+
+pub fn get_cred_def_json(cred_def_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((CRED_DEF_ID.to_string(), CRED_DEF_JSON.to_string())); }
+
+    libindy_build_get_credential_def_txn(cred_def_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_cred_def_response(&response))
+}
+
+pub fn create_rev_reg_def(issuer_did: &str, cred_def_id: &str, tails_file: &str, max_creds: u32)
+    -> Result<(String, String, String, Option<PaymentTxn>), u32> {
+    debug!(""creating revocation registry definition with issuer_did: {}, cred_def_id: {}, tails_file_path: {}, max_creds: {}"",
+           issuer_did, cred_def_id, tails_file, max_creds);
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_DEF_JSON.to_string(), """".to_string(), None)); }
+
+    let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) = libindy_create_and_store_revoc_reg(
+        issuer_did,
+        cred_def_id,
+        tails_file,
+        max_creds
+    )?;
+
+    let rev_reg_def_req = libindy_build_revoc_reg_def_request(issuer_did, &rev_reg_def_json)?;
+
+    let (payment, _) = pay_for_txn(&rev_reg_def_req, REV_REG_DEF_TXN_TYPE)?;
+
+    Ok((rev_reg_id, rev_reg_def_json, rev_reg_entry_json, payment))
+}
+
+pub fn get_rev_reg_def_json(rev_reg_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_DEF_JSON.to_string())); }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    libindy_build_get_revoc_reg_def_request(&submitter_did, rev_reg_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_def_response(&response))
+}
+
+pub fn post_rev_reg_delta(issuer_did: &str, rev_reg_id: &str, rev_reg_entry_json: &str)
+                          -> Result<(Option<PaymentTxn>, String), u32> {
+    libindy_build_revoc_reg_entry_request(issuer_did, rev_reg_id, REVOC_REG_TYPE, rev_reg_entry_json)
+        .and_then(|req| pay_for_txn(&req, REV_REG_DELTA_TXN_TYPE))
+}
+
+pub fn get_rev_reg_delta_json(rev_reg_id: &str, from: Option<u64>, to: Option<u64>)
+    -> Result<(String, String, u64), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_REG_DELTA_JSON.to_string(), 1)); }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+    let from: i64 = if let Some(_from) = from { _from as i64 } else { -1 };
+    let to = if let Some(_to) = to { _to as i64 } else { time::get_time().sec };
+
+    libindy_build_get_revoc_reg_delta_request(&submitter_did, rev_reg_id, from, to)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_delta_response(&response))
+}
+
+pub fn get_rev_reg(rev_reg_id: &str, timestamp: u64) -> Result<(String, String, u64), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_REG_JSON.to_string(), 1)); }
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    libindy_build_get_revoc_reg_request(&submitter_did, rev_reg_id, timestamp)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_response(&response))
+}
+
+pub fn revoke_credential(tails_file: &str, rev_reg_id: &str, cred_rev_id: &str)",,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/240146993,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r240146993,dkulic
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,I think so,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-10 10:43:11,240161084,"@@ -84,3 +90,359 @@ pub fn libindy_build_create_credential_def_txn(submitter_did: &str,
         .wait()
         .map_err(map_rust_indy_sdk_error_code)
 }
+
+pub fn libindy_build_revoc_reg_def_request(submitter_did: &str,
+                                           rev_reg_def_json: &str) -> Result<String, u32> {
+    ledger::build_revoc_reg_def_request(submitter_did, rev_reg_def_json)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+
+pub fn libindy_build_revoc_reg_entry_request(submitter_did: &str,
+                                             rev_reg_id: &str,
+                                             rev_def_type: &str,
+                                             value: &str) -> Result<String, u32> {
+    ledger::build_revoc_reg_entry_request(submitter_did, rev_reg_id, rev_def_type, value)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_build_get_revoc_reg_def_request(submitter_did: &str, rev_reg_id: &str) -> Result<String, u32> {
+    ledger::build_get_revoc_reg_def_request(Some(submitter_did), rev_reg_id)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_parse_get_revoc_reg_def_response(rev_reg_def_json: &str) -> Result<(String, String), u32> {
+    ledger::parse_get_revoc_reg_def_response(rev_reg_def_json)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_build_get_revoc_reg_delta_request(submitter_did: &str,
+                                                 rev_reg_id: &str,
+                                                 from: i64,
+                                                 to: i64) -> Result<String, u32> {
+    ledger::build_get_revoc_reg_delta_request(Some(submitter_did),
+                                              rev_reg_id,
+                                              from,
+                                              to)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+fn libindy_build_get_revoc_reg_request(submitter_did: &str, rev_reg_id: &str, timestamp: u64)
+    -> Result<String, u32> {
+    ledger::build_get_revoc_reg_request(Some(submitter_did),
+                                        rev_reg_id,
+                                        timestamp as i64)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+fn libindy_parse_get_revoc_reg_response(get_rev_reg_resp: &str) -> Result<(String, String, u64), u32> {
+    ledger::parse_get_revoc_reg_response(get_rev_reg_resp)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_parse_get_revoc_reg_delta_response(get_rev_reg_delta_response: &str)
+    -> Result<(String, String, u64), u32> {
+    ledger::parse_get_revoc_reg_delta_response(get_rev_reg_delta_response)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn create_schema(name: &str, version: &str, data: &str) -> Result<(String, Option<PaymentTxn>), u32> {
+    if settings::test_indy_mode_enabled() {
+        return Ok((SCHEMA_ID.to_string(), Some(PaymentTxn::from_parts(r#""[""pay:null:9UFgyjuJxi1i1HD""]""#,r#""[{""amount"":4,""extra"":null,""recipient"":""pay:null:xkIsxem0YNtHrRO""}]""#,1, false).unwrap(), )));
+    }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    let (id, create_schema) = libindy_issuer_create_schema(&submitter_did, name, version, data)?;
+
+    let request = libindy_build_schema_request(&submitter_did, &create_schema)?;
+
+    let (payment, response) = pay_for_txn(&request, SCHEMA_TXN_TYPE)?;
+
+    _check_create_schema_response(&response)?;
+
+    Ok((id, payment))
+}
+
+fn _check_create_schema_response(response: &str) -> Result<(), u32> {
+    let response: Value = serde_json::from_str(response).or(Err(error::INVALID_JSON.code_num))?;
+
+    if let Some(_) = response.get(""result"") { return Ok(()) };
+
+    warn!(""No result found in ledger txn. Must be Rejected"");
+
+    if response[""op""] == json!(""REJECT"") {
+        match response.get(""reason"") {
+            Some(r) => return Err(error::DUPLICATE_SCHEMA.code_num),
+            None => return Err(error::UNKNOWN_SCHEMA_REJECTION.code_num),
+        }
+    }
+
+    Err(error::UNKNOWN_SCHEMA_REJECTION.code_num)
+}
+
+pub fn get_schema_json(schema_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((SCHEMA_ID.to_string(), SCHEMA_JSON.to_string()))}
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+    libindy_build_get_schema_request(&submitter_did, schema_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_schema_response(&response))
+}
+
+pub fn create_cred_def(issuer_did: &str,
+                       schema_json: &str,
+                       tag: &str,
+                       sig_type: Option<&str>,
+                       support_revocation: Option<bool>) -> Result<(String, Option<PaymentTxn>), u32> {
+    if settings::test_indy_mode_enabled() {
+        return Ok((CRED_DEF_ID.to_string(), Some(PaymentTxn::from_parts(r#""[""pay:null:9UFgyjuJxi1i1HD""]""#,r#""[{""amount"":4,""extra"":null,""recipient"":""pay:null:xkIsxem0YNtHrRO""}]""#,1, false).unwrap())));
+    }
+
+    let config_json = json!({""support_revocation"": support_revocation.unwrap_or(false)}).to_string();
+
+    let (id, cred_def_json) = libindy_create_and_store_credential_def(issuer_did,
+                                                                      schema_json,
+                                                                      tag,
+                                                                      sig_type,
+                                                                      &config_json)?;
+
+    let cred_def_req = libindy_build_create_credential_def_txn(issuer_did, &cred_def_json)?;
+
+    let (payment, response) = pay_for_txn(&cred_def_req, CRED_DEF_TXN_TYPE)?;
+
+    Ok((id, payment))
+}
+
+pub fn get_cred_def_json(cred_def_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((CRED_DEF_ID.to_string(), CRED_DEF_JSON.to_string())); }
+
+    libindy_build_get_credential_def_txn(cred_def_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_cred_def_response(&response))
+}
+
+pub fn create_rev_reg_def(issuer_did: &str, cred_def_id: &str, tails_file: &str, max_creds: u32)
+    -> Result<(String, String, String, Option<PaymentTxn>), u32> {
+    debug!(""creating revocation registry definition with issuer_did: {}, cred_def_id: {}, tails_file_path: {}, max_creds: {}"",
+           issuer_did, cred_def_id, tails_file, max_creds);
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_DEF_JSON.to_string(), """".to_string(), None)); }
+
+    let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) = libindy_create_and_store_revoc_reg(
+        issuer_did,
+        cred_def_id,
+        tails_file,
+        max_creds
+    )?;
+
+    let rev_reg_def_req = libindy_build_revoc_reg_def_request(issuer_did, &rev_reg_def_json)?;
+
+    let (payment, _) = pay_for_txn(&rev_reg_def_req, REV_REG_DEF_TXN_TYPE)?;
+
+    Ok((rev_reg_id, rev_reg_def_json, rev_reg_entry_json, payment))
+}
+
+pub fn get_rev_reg_def_json(rev_reg_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_DEF_JSON.to_string())); }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    libindy_build_get_revoc_reg_def_request(&submitter_did, rev_reg_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_def_response(&response))
+}
+
+pub fn post_rev_reg_delta(issuer_did: &str, rev_reg_id: &str, rev_reg_entry_json: &str)
+                          -> Result<(Option<PaymentTxn>, String), u32> {
+    libindy_build_revoc_reg_entry_request(issuer_did, rev_reg_id, REVOC_REG_TYPE, rev_reg_entry_json)
+        .and_then(|req| pay_for_txn(&req, REV_REG_DELTA_TXN_TYPE))
+}
+
+pub fn get_rev_reg_delta_json(rev_reg_id: &str, from: Option<u64>, to: Option<u64>)
+    -> Result<(String, String, u64), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_REG_DELTA_JSON.to_string(), 1)); }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+    let from: i64 = if let Some(_from) = from { _from as i64 } else { -1 };
+    let to = if let Some(_to) = to { _to as i64 } else { time::get_time().sec };
+
+    libindy_build_get_revoc_reg_delta_request(&submitter_did, rev_reg_id, from, to)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_delta_response(&response))
+}
+
+pub fn get_rev_reg(rev_reg_id: &str, timestamp: u64) -> Result<(String, String, u64), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_REG_JSON.to_string(), 1)); }
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    libindy_build_get_revoc_reg_request(&submitter_did, rev_reg_id, timestamp)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_response(&response))
+}
+
+pub fn revoke_credential(tails_file: &str, rev_reg_id: &str, cred_rev_id: &str)",,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/240161084,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r240161084,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,"OK, so libvcx should be refactored in this ticket also? :)
",846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-10 10:50:27,240163459,"@@ -84,3 +90,359 @@ pub fn libindy_build_create_credential_def_txn(submitter_did: &str,
         .wait()
         .map_err(map_rust_indy_sdk_error_code)
 }
+
+pub fn libindy_build_revoc_reg_def_request(submitter_did: &str,
+                                           rev_reg_def_json: &str) -> Result<String, u32> {
+    ledger::build_revoc_reg_def_request(submitter_did, rev_reg_def_json)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+
+pub fn libindy_build_revoc_reg_entry_request(submitter_did: &str,
+                                             rev_reg_id: &str,
+                                             rev_def_type: &str,
+                                             value: &str) -> Result<String, u32> {
+    ledger::build_revoc_reg_entry_request(submitter_did, rev_reg_id, rev_def_type, value)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_build_get_revoc_reg_def_request(submitter_did: &str, rev_reg_id: &str) -> Result<String, u32> {
+    ledger::build_get_revoc_reg_def_request(Some(submitter_did), rev_reg_id)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_parse_get_revoc_reg_def_response(rev_reg_def_json: &str) -> Result<(String, String), u32> {
+    ledger::parse_get_revoc_reg_def_response(rev_reg_def_json)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_build_get_revoc_reg_delta_request(submitter_did: &str,
+                                                 rev_reg_id: &str,
+                                                 from: i64,
+                                                 to: i64) -> Result<String, u32> {
+    ledger::build_get_revoc_reg_delta_request(Some(submitter_did),
+                                              rev_reg_id,
+                                              from,
+                                              to)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+fn libindy_build_get_revoc_reg_request(submitter_did: &str, rev_reg_id: &str, timestamp: u64)
+    -> Result<String, u32> {
+    ledger::build_get_revoc_reg_request(Some(submitter_did),
+                                        rev_reg_id,
+                                        timestamp as i64)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+fn libindy_parse_get_revoc_reg_response(get_rev_reg_resp: &str) -> Result<(String, String, u64), u32> {
+    ledger::parse_get_revoc_reg_response(get_rev_reg_resp)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_parse_get_revoc_reg_delta_response(get_rev_reg_delta_response: &str)
+    -> Result<(String, String, u64), u32> {
+    ledger::parse_get_revoc_reg_delta_response(get_rev_reg_delta_response)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn create_schema(name: &str, version: &str, data: &str) -> Result<(String, Option<PaymentTxn>), u32> {
+    if settings::test_indy_mode_enabled() {
+        return Ok((SCHEMA_ID.to_string(), Some(PaymentTxn::from_parts(r#""[""pay:null:9UFgyjuJxi1i1HD""]""#,r#""[{""amount"":4,""extra"":null,""recipient"":""pay:null:xkIsxem0YNtHrRO""}]""#,1, false).unwrap(), )));
+    }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    let (id, create_schema) = libindy_issuer_create_schema(&submitter_did, name, version, data)?;
+
+    let request = libindy_build_schema_request(&submitter_did, &create_schema)?;
+
+    let (payment, response) = pay_for_txn(&request, SCHEMA_TXN_TYPE)?;
+
+    _check_create_schema_response(&response)?;
+
+    Ok((id, payment))
+}
+
+fn _check_create_schema_response(response: &str) -> Result<(), u32> {
+    let response: Value = serde_json::from_str(response).or(Err(error::INVALID_JSON.code_num))?;
+
+    if let Some(_) = response.get(""result"") { return Ok(()) };
+
+    warn!(""No result found in ledger txn. Must be Rejected"");
+
+    if response[""op""] == json!(""REJECT"") {
+        match response.get(""reason"") {
+            Some(r) => return Err(error::DUPLICATE_SCHEMA.code_num),
+            None => return Err(error::UNKNOWN_SCHEMA_REJECTION.code_num),
+        }
+    }
+
+    Err(error::UNKNOWN_SCHEMA_REJECTION.code_num)
+}
+
+pub fn get_schema_json(schema_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((SCHEMA_ID.to_string(), SCHEMA_JSON.to_string()))}
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+    libindy_build_get_schema_request(&submitter_did, schema_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_schema_response(&response))
+}
+
+pub fn create_cred_def(issuer_did: &str,
+                       schema_json: &str,
+                       tag: &str,
+                       sig_type: Option<&str>,
+                       support_revocation: Option<bool>) -> Result<(String, Option<PaymentTxn>), u32> {
+    if settings::test_indy_mode_enabled() {
+        return Ok((CRED_DEF_ID.to_string(), Some(PaymentTxn::from_parts(r#""[""pay:null:9UFgyjuJxi1i1HD""]""#,r#""[{""amount"":4,""extra"":null,""recipient"":""pay:null:xkIsxem0YNtHrRO""}]""#,1, false).unwrap())));
+    }
+
+    let config_json = json!({""support_revocation"": support_revocation.unwrap_or(false)}).to_string();
+
+    let (id, cred_def_json) = libindy_create_and_store_credential_def(issuer_did,
+                                                                      schema_json,
+                                                                      tag,
+                                                                      sig_type,
+                                                                      &config_json)?;
+
+    let cred_def_req = libindy_build_create_credential_def_txn(issuer_did, &cred_def_json)?;
+
+    let (payment, response) = pay_for_txn(&cred_def_req, CRED_DEF_TXN_TYPE)?;
+
+    Ok((id, payment))
+}
+
+pub fn get_cred_def_json(cred_def_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((CRED_DEF_ID.to_string(), CRED_DEF_JSON.to_string())); }
+
+    libindy_build_get_credential_def_txn(cred_def_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_cred_def_response(&response))
+}
+
+pub fn create_rev_reg_def(issuer_did: &str, cred_def_id: &str, tails_file: &str, max_creds: u32)
+    -> Result<(String, String, String, Option<PaymentTxn>), u32> {
+    debug!(""creating revocation registry definition with issuer_did: {}, cred_def_id: {}, tails_file_path: {}, max_creds: {}"",
+           issuer_did, cred_def_id, tails_file, max_creds);
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_DEF_JSON.to_string(), """".to_string(), None)); }
+
+    let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) = libindy_create_and_store_revoc_reg(
+        issuer_did,
+        cred_def_id,
+        tails_file,
+        max_creds
+    )?;
+
+    let rev_reg_def_req = libindy_build_revoc_reg_def_request(issuer_did, &rev_reg_def_json)?;
+
+    let (payment, _) = pay_for_txn(&rev_reg_def_req, REV_REG_DEF_TXN_TYPE)?;
+
+    Ok((rev_reg_id, rev_reg_def_json, rev_reg_entry_json, payment))
+}
+
+pub fn get_rev_reg_def_json(rev_reg_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_DEF_JSON.to_string())); }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    libindy_build_get_revoc_reg_def_request(&submitter_did, rev_reg_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_def_response(&response))
+}
+
+pub fn post_rev_reg_delta(issuer_did: &str, rev_reg_id: &str, rev_reg_entry_json: &str)
+                          -> Result<(Option<PaymentTxn>, String), u32> {
+    libindy_build_revoc_reg_entry_request(issuer_did, rev_reg_id, REVOC_REG_TYPE, rev_reg_entry_json)
+        .and_then(|req| pay_for_txn(&req, REV_REG_DELTA_TXN_TYPE))
+}
+
+pub fn get_rev_reg_delta_json(rev_reg_id: &str, from: Option<u64>, to: Option<u64>)
+    -> Result<(String, String, u64), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_REG_DELTA_JSON.to_string(), 1)); }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+    let from: i64 = if let Some(_from) = from { _from as i64 } else { -1 };
+    let to = if let Some(_to) = to { _to as i64 } else { time::get_time().sec };
+
+    libindy_build_get_revoc_reg_delta_request(&submitter_did, rev_reg_id, from, to)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_delta_response(&response))
+}
+
+pub fn get_rev_reg(rev_reg_id: &str, timestamp: u64) -> Result<(String, String, u64), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_REG_JSON.to_string(), 1)); }
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    libindy_build_get_revoc_reg_request(&submitter_did, rev_reg_id, timestamp)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_response(&response))
+}
+
+pub fn revoke_credential(tails_file: &str, rev_reg_id: &str, cred_rev_id: &str)",,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/240163459,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r240163459,dkulic
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,@dkulic As far as I understood @glowkey - such kind of mixing is not a style for VCX. So please organize new code similar as it's done in existing codebase.,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-10 10:59:30,240166329,"@@ -84,3 +90,359 @@ pub fn libindy_build_create_credential_def_txn(submitter_did: &str,
         .wait()
         .map_err(map_rust_indy_sdk_error_code)
 }
+
+pub fn libindy_build_revoc_reg_def_request(submitter_did: &str,
+                                           rev_reg_def_json: &str) -> Result<String, u32> {
+    ledger::build_revoc_reg_def_request(submitter_did, rev_reg_def_json)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+
+pub fn libindy_build_revoc_reg_entry_request(submitter_did: &str,
+                                             rev_reg_id: &str,
+                                             rev_def_type: &str,
+                                             value: &str) -> Result<String, u32> {
+    ledger::build_revoc_reg_entry_request(submitter_did, rev_reg_id, rev_def_type, value)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_build_get_revoc_reg_def_request(submitter_did: &str, rev_reg_id: &str) -> Result<String, u32> {
+    ledger::build_get_revoc_reg_def_request(Some(submitter_did), rev_reg_id)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_parse_get_revoc_reg_def_response(rev_reg_def_json: &str) -> Result<(String, String), u32> {
+    ledger::parse_get_revoc_reg_def_response(rev_reg_def_json)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_build_get_revoc_reg_delta_request(submitter_did: &str,
+                                                 rev_reg_id: &str,
+                                                 from: i64,
+                                                 to: i64) -> Result<String, u32> {
+    ledger::build_get_revoc_reg_delta_request(Some(submitter_did),
+                                              rev_reg_id,
+                                              from,
+                                              to)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+fn libindy_build_get_revoc_reg_request(submitter_did: &str, rev_reg_id: &str, timestamp: u64)
+    -> Result<String, u32> {
+    ledger::build_get_revoc_reg_request(Some(submitter_did),
+                                        rev_reg_id,
+                                        timestamp as i64)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+fn libindy_parse_get_revoc_reg_response(get_rev_reg_resp: &str) -> Result<(String, String, u64), u32> {
+    ledger::parse_get_revoc_reg_response(get_rev_reg_resp)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_parse_get_revoc_reg_delta_response(get_rev_reg_delta_response: &str)
+    -> Result<(String, String, u64), u32> {
+    ledger::parse_get_revoc_reg_delta_response(get_rev_reg_delta_response)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn create_schema(name: &str, version: &str, data: &str) -> Result<(String, Option<PaymentTxn>), u32> {
+    if settings::test_indy_mode_enabled() {
+        return Ok((SCHEMA_ID.to_string(), Some(PaymentTxn::from_parts(r#""[""pay:null:9UFgyjuJxi1i1HD""]""#,r#""[{""amount"":4,""extra"":null,""recipient"":""pay:null:xkIsxem0YNtHrRO""}]""#,1, false).unwrap(), )));
+    }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    let (id, create_schema) = libindy_issuer_create_schema(&submitter_did, name, version, data)?;
+
+    let request = libindy_build_schema_request(&submitter_did, &create_schema)?;
+
+    let (payment, response) = pay_for_txn(&request, SCHEMA_TXN_TYPE)?;
+
+    _check_create_schema_response(&response)?;
+
+    Ok((id, payment))
+}
+
+fn _check_create_schema_response(response: &str) -> Result<(), u32> {
+    let response: Value = serde_json::from_str(response).or(Err(error::INVALID_JSON.code_num))?;
+
+    if let Some(_) = response.get(""result"") { return Ok(()) };
+
+    warn!(""No result found in ledger txn. Must be Rejected"");
+
+    if response[""op""] == json!(""REJECT"") {
+        match response.get(""reason"") {
+            Some(r) => return Err(error::DUPLICATE_SCHEMA.code_num),
+            None => return Err(error::UNKNOWN_SCHEMA_REJECTION.code_num),
+        }
+    }
+
+    Err(error::UNKNOWN_SCHEMA_REJECTION.code_num)
+}
+
+pub fn get_schema_json(schema_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((SCHEMA_ID.to_string(), SCHEMA_JSON.to_string()))}
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+    libindy_build_get_schema_request(&submitter_did, schema_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_schema_response(&response))
+}
+
+pub fn create_cred_def(issuer_did: &str,
+                       schema_json: &str,
+                       tag: &str,
+                       sig_type: Option<&str>,
+                       support_revocation: Option<bool>) -> Result<(String, Option<PaymentTxn>), u32> {
+    if settings::test_indy_mode_enabled() {
+        return Ok((CRED_DEF_ID.to_string(), Some(PaymentTxn::from_parts(r#""[""pay:null:9UFgyjuJxi1i1HD""]""#,r#""[{""amount"":4,""extra"":null,""recipient"":""pay:null:xkIsxem0YNtHrRO""}]""#,1, false).unwrap())));
+    }
+
+    let config_json = json!({""support_revocation"": support_revocation.unwrap_or(false)}).to_string();
+
+    let (id, cred_def_json) = libindy_create_and_store_credential_def(issuer_did,
+                                                                      schema_json,
+                                                                      tag,
+                                                                      sig_type,
+                                                                      &config_json)?;
+
+    let cred_def_req = libindy_build_create_credential_def_txn(issuer_did, &cred_def_json)?;
+
+    let (payment, response) = pay_for_txn(&cred_def_req, CRED_DEF_TXN_TYPE)?;
+
+    Ok((id, payment))
+}
+
+pub fn get_cred_def_json(cred_def_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((CRED_DEF_ID.to_string(), CRED_DEF_JSON.to_string())); }
+
+    libindy_build_get_credential_def_txn(cred_def_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_cred_def_response(&response))
+}
+
+pub fn create_rev_reg_def(issuer_did: &str, cred_def_id: &str, tails_file: &str, max_creds: u32)
+    -> Result<(String, String, String, Option<PaymentTxn>), u32> {
+    debug!(""creating revocation registry definition with issuer_did: {}, cred_def_id: {}, tails_file_path: {}, max_creds: {}"",
+           issuer_did, cred_def_id, tails_file, max_creds);
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_DEF_JSON.to_string(), """".to_string(), None)); }
+
+    let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) = libindy_create_and_store_revoc_reg(
+        issuer_did,
+        cred_def_id,
+        tails_file,
+        max_creds
+    )?;
+
+    let rev_reg_def_req = libindy_build_revoc_reg_def_request(issuer_did, &rev_reg_def_json)?;
+
+    let (payment, _) = pay_for_txn(&rev_reg_def_req, REV_REG_DEF_TXN_TYPE)?;
+
+    Ok((rev_reg_id, rev_reg_def_json, rev_reg_entry_json, payment))
+}
+
+pub fn get_rev_reg_def_json(rev_reg_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_DEF_JSON.to_string())); }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    libindy_build_get_revoc_reg_def_request(&submitter_did, rev_reg_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_def_response(&response))
+}
+
+pub fn post_rev_reg_delta(issuer_did: &str, rev_reg_id: &str, rev_reg_entry_json: &str)
+                          -> Result<(Option<PaymentTxn>, String), u32> {
+    libindy_build_revoc_reg_entry_request(issuer_did, rev_reg_id, REVOC_REG_TYPE, rev_reg_entry_json)
+        .and_then(|req| pay_for_txn(&req, REV_REG_DELTA_TXN_TYPE))
+}
+
+pub fn get_rev_reg_delta_json(rev_reg_id: &str, from: Option<u64>, to: Option<u64>)
+    -> Result<(String, String, u64), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_REG_DELTA_JSON.to_string(), 1)); }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+    let from: i64 = if let Some(_from) = from { _from as i64 } else { -1 };
+    let to = if let Some(_to) = to { _to as i64 } else { time::get_time().sec };
+
+    libindy_build_get_revoc_reg_delta_request(&submitter_did, rev_reg_id, from, to)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_delta_response(&response))
+}
+
+pub fn get_rev_reg(rev_reg_id: &str, timestamp: u64) -> Result<(String, String, u64), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_REG_JSON.to_string(), 1)); }
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    libindy_build_get_revoc_reg_request(&submitter_did, rev_reg_id, timestamp)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_response(&response))
+}
+
+pub fn revoke_credential(tails_file: &str, rev_reg_id: &str, cred_rev_id: &str)",,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/240166329,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r240166329,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,@dkulic could you create a ticket for this technical debt and add TODO and comment into code?,846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-10 11:05:38,240168193,"@@ -75,35 +74,191 @@ pub struct RequestedCreds {
 
 #[derive(Debug, Deserialize, Serialize, PartialEq)]
 pub struct CredInfo {
+    pub requested_attr: String,
     pub referent: String,
     pub schema_id: String,
     pub cred_def_id: String,
+    pub rev_reg_id: Option<String>,
+    pub cred_rev_id: Option<String>,
+    pub revocation_interval: Option<NonRevokedInterval>,
+    pub tails_file: Option<String>,
+    pub timestamp: Option<u64>
 }
 
-fn credential_def_identifiers(credentials: &str) -> Result<Vec<(String, String, String, String)>, ProofError> {
+fn credential_def_identifiers(credentials: &str, proof_req: &ProofRequestData)
+    -> Result<Vec<CredInfo>, ProofError> {
+
     let mut rtn = Vec::new();
 
     let credentials: Value = serde_json::from_str(credentials)
-        .or(Err(ProofError::CommonError(error::INVALID_JSON.code_num)))?;
+        .or(Err(ProofError::InvalidJson()))?;
 
     if let Value::Object(ref attrs) = credentials[""attrs""] {
         for (requested_attr, value) in attrs {
-            if let Some(ref attr_obj) = value.get(""cred_info"") {
-                rtn.push((
-                    requested_attr.to_string(),
-                    serde_utils::get_value_to_string(""referent"", attr_obj)
-                        .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""schema_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""cred_def_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?
-                 ));
-            }
+            if let (Some(referent), Some(schema_id), Some(cred_def_id)) =
+            (value[""credential""][""cred_info""][""referent""].as_str(),
+             value[""credential""][""cred_info""][""schema_id""].as_str(),
+             value[""credential""][""cred_info""][""cred_def_id""].as_str()) {
+
+                let rev_reg_id = value[""credential""][""cred_info""][""rev_reg_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let cred_rev_id = value[""credential""][""cred_info""][""cred_rev_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let tails_file = value[""tails_file""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                rtn.push(
+                    CredInfo {
+                        requested_attr: requested_attr.to_string(),
+                        referent: referent.to_string(),
+                        schema_id: schema_id.to_string(),
+                        cred_def_id: cred_def_id.to_string(),
+                        revocation_interval: _get_revocation_interval(&requested_attr, &proof_req)?,
+                        timestamp: None,
+                        rev_reg_id,
+                        cred_rev_id,
+                        tails_file,
+                    }
+                );
+            } else { return Err(ProofError::InvalidCredData()) }
         }
     }
+
     Ok(rtn)
 }
 
+fn _get_revocation_interval(attr_name: &str, proof_req: &ProofRequestData)
+    -> Result<Option<NonRevokedInterval>, ProofError> {
+
+    if let Some(ref attr) = proof_req.requested_attributes.get(attr_name) {
+
+        if let Some(ref interval) = attr.non_revoked {
+            return Ok(Some(NonRevokedInterval {from: interval.from, to: interval.to}))
+        }
+        else if let Some(ref interval) = proof_req.non_revoked {
+            return Ok(Some(NonRevokedInterval { from: interval.from, to: interval.to }))
+        }
+
+        return Ok(None)
+    }
+    // Todo: Handle case for predicates
+
+    Err(ProofError::InvalidCredData())
+}
+
+// Also updates timestamp in credentials_identifiers
+fn build_rev_states_json(credentials_identifiers: &mut Vec<CredInfo>) -> Result<String, ProofError> {
+    let mut rtn: Value = json!({});
+    let mut timestamps: HashMap<String, u64> = HashMap::new();
+
+    for cred_info in credentials_identifiers.iter_mut() {
+        if let (Some(rev_reg_id), Some(cred_rev_id), Some(tails_file)) =
+        (&cred_info.rev_reg_id, &cred_info.cred_rev_id, &cred_info.tails_file) {
+
+            if rtn.get(&rev_reg_id).is_none() {
+                let (from, to) = if let Some(ref interval) = cred_info.revocation_interval
+                    { (interval.from, interval.to) }
+                else { (None, None )};
+
+//                let from = from.unwrap_or(0);
+//                let to = to.unwrap_or(time::get_time().sec as u64);
+                let cache = get_rev_reg_cache(&rev_reg_id);
+
+                let (rev_state_json, timestamp) = if let Some(cached_rev_state) = cache.rev_state {
+                    if cached_rev_state.timestamp >= from.unwrap_or(0)
+                        && cached_rev_state.timestamp <= to.unwrap_or(time::get_time().sec as u64) {
+                        (cached_rev_state.value, cached_rev_state.timestamp)
+                    } else {
+                        let from = match from {
+                            Some(from) if from >= cached_rev_state.timestamp => {
+                                Some(cached_rev_state.timestamp)
+                            },
+                            _ => None
+                        };
+
+                        let (_, rev_reg_def_json) = get_rev_reg_def_json(&rev_reg_id)
+                            .map_err(|e| ProofError::CommonError(e))?;
+
+                        let (rev_reg_id, rev_reg_delta_json, timestamp) = get_rev_reg_delta_json(
+                            &rev_reg_id,
+                            from,
+                            to
+                        ).map_err(|e| ProofError::CommonError(e))?;
+
+                        let rev_state_json = anoncreds::libindy_prover_update_revocation_state(
+                            &rev_reg_def_json,
+                            &cached_rev_state.value,
+                            &rev_reg_delta_json,
+                            &cred_rev_id,
+                            &tails_file
+                        ).map_err(|e| ProofError::CommonError(e))?;
+
+                        if timestamp > cached_rev_state.timestamp {
+                            let new_cache = RevRegCache {
+                                rev_state: Some(RevState {
+                                    timestamp: timestamp,
+                                    value: rev_state_json.clone()
+                                })
+                            };
+                            set_rev_reg_cache(&rev_reg_id, &new_cache);
+                        }
+
+                        (rev_state_json, timestamp)
+                    }
+                } else {
+                    let (_, rev_reg_def_json) = get_rev_reg_def_json(&rev_reg_id)
+                        .map_err(|e| ProofError::CommonError(e))?;
+
+                    let (rev_reg_id, rev_reg_delta_json, timestamp) = get_rev_reg_delta_json(
+                        &rev_reg_id,
+                        None,
+                        to
+                    ).map_err(|e| ProofError::CommonError(e))?;
+
+                    let rev_state_json = anoncreds::libindy_prover_create_revocation_state(
+                        &rev_reg_def_json,
+                        &rev_reg_delta_json,
+                        &cred_rev_id,
+                        &tails_file
+                    ).map_err(|e| ProofError::CommonError(e))?;
+
+                    let new_cache = RevRegCache {
+                        rev_state: Some(RevState {
+                            timestamp: timestamp,
+                            value: rev_state_json.clone()
+                        })
+                    };
+                    set_rev_reg_cache(&rev_reg_id, &new_cache);
+
+                    (rev_state_json, timestamp)
+                };
+
+                let rev_state_json: Value = serde_json::from_str(&rev_state_json)
+                    .or(Err(ProofError::InvalidJson()))?;
+
+                rtn[rev_reg_id.to_string()] = json!({timestamp.to_string(): rev_state_json});",211,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/240168193,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r240168193,jovfer
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,"Sure.
",846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-10 11:13:32,240170476,"@@ -75,35 +74,191 @@ pub struct RequestedCreds {
 
 #[derive(Debug, Deserialize, Serialize, PartialEq)]
 pub struct CredInfo {
+    pub requested_attr: String,
     pub referent: String,
     pub schema_id: String,
     pub cred_def_id: String,
+    pub rev_reg_id: Option<String>,
+    pub cred_rev_id: Option<String>,
+    pub revocation_interval: Option<NonRevokedInterval>,
+    pub tails_file: Option<String>,
+    pub timestamp: Option<u64>
 }
 
-fn credential_def_identifiers(credentials: &str) -> Result<Vec<(String, String, String, String)>, ProofError> {
+fn credential_def_identifiers(credentials: &str, proof_req: &ProofRequestData)
+    -> Result<Vec<CredInfo>, ProofError> {
+
     let mut rtn = Vec::new();
 
     let credentials: Value = serde_json::from_str(credentials)
-        .or(Err(ProofError::CommonError(error::INVALID_JSON.code_num)))?;
+        .or(Err(ProofError::InvalidJson()))?;
 
     if let Value::Object(ref attrs) = credentials[""attrs""] {
         for (requested_attr, value) in attrs {
-            if let Some(ref attr_obj) = value.get(""cred_info"") {
-                rtn.push((
-                    requested_attr.to_string(),
-                    serde_utils::get_value_to_string(""referent"", attr_obj)
-                        .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""schema_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?,
-                    serde_utils::get_value_to_string(""cred_def_id"", attr_obj)
-                             .map_err(|e| ProofError::CommonError(e))?
-                 ));
-            }
+            if let (Some(referent), Some(schema_id), Some(cred_def_id)) =
+            (value[""credential""][""cred_info""][""referent""].as_str(),
+             value[""credential""][""cred_info""][""schema_id""].as_str(),
+             value[""credential""][""cred_info""][""cred_def_id""].as_str()) {
+
+                let rev_reg_id = value[""credential""][""cred_info""][""rev_reg_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let cred_rev_id = value[""credential""][""cred_info""][""cred_rev_id""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                let tails_file = value[""tails_file""]
+                    .as_str()
+                    .map(|x| x.to_string());
+
+                rtn.push(
+                    CredInfo {
+                        requested_attr: requested_attr.to_string(),
+                        referent: referent.to_string(),
+                        schema_id: schema_id.to_string(),
+                        cred_def_id: cred_def_id.to_string(),
+                        revocation_interval: _get_revocation_interval(&requested_attr, &proof_req)?,
+                        timestamp: None,
+                        rev_reg_id,
+                        cred_rev_id,
+                        tails_file,
+                    }
+                );
+            } else { return Err(ProofError::InvalidCredData()) }
         }
     }
+
     Ok(rtn)
 }
 
+fn _get_revocation_interval(attr_name: &str, proof_req: &ProofRequestData)
+    -> Result<Option<NonRevokedInterval>, ProofError> {
+
+    if let Some(ref attr) = proof_req.requested_attributes.get(attr_name) {
+
+        if let Some(ref interval) = attr.non_revoked {
+            return Ok(Some(NonRevokedInterval {from: interval.from, to: interval.to}))
+        }
+        else if let Some(ref interval) = proof_req.non_revoked {
+            return Ok(Some(NonRevokedInterval { from: interval.from, to: interval.to }))
+        }
+
+        return Ok(None)
+    }
+    // Todo: Handle case for predicates
+
+    Err(ProofError::InvalidCredData())
+}
+
+// Also updates timestamp in credentials_identifiers
+fn build_rev_states_json(credentials_identifiers: &mut Vec<CredInfo>) -> Result<String, ProofError> {
+    let mut rtn: Value = json!({});
+    let mut timestamps: HashMap<String, u64> = HashMap::new();
+
+    for cred_info in credentials_identifiers.iter_mut() {
+        if let (Some(rev_reg_id), Some(cred_rev_id), Some(tails_file)) =
+        (&cred_info.rev_reg_id, &cred_info.cred_rev_id, &cred_info.tails_file) {
+
+            if rtn.get(&rev_reg_id).is_none() {
+                let (from, to) = if let Some(ref interval) = cred_info.revocation_interval
+                    { (interval.from, interval.to) }
+                else { (None, None )};
+
+//                let from = from.unwrap_or(0);
+//                let to = to.unwrap_or(time::get_time().sec as u64);
+                let cache = get_rev_reg_cache(&rev_reg_id);
+
+                let (rev_state_json, timestamp) = if let Some(cached_rev_state) = cache.rev_state {
+                    if cached_rev_state.timestamp >= from.unwrap_or(0)
+                        && cached_rev_state.timestamp <= to.unwrap_or(time::get_time().sec as u64) {
+                        (cached_rev_state.value, cached_rev_state.timestamp)
+                    } else {
+                        let from = match from {
+                            Some(from) if from >= cached_rev_state.timestamp => {
+                                Some(cached_rev_state.timestamp)
+                            },
+                            _ => None
+                        };
+
+                        let (_, rev_reg_def_json) = get_rev_reg_def_json(&rev_reg_id)
+                            .map_err(|e| ProofError::CommonError(e))?;
+
+                        let (rev_reg_id, rev_reg_delta_json, timestamp) = get_rev_reg_delta_json(
+                            &rev_reg_id,
+                            from,
+                            to
+                        ).map_err(|e| ProofError::CommonError(e))?;
+
+                        let rev_state_json = anoncreds::libindy_prover_update_revocation_state(
+                            &rev_reg_def_json,
+                            &cached_rev_state.value,
+                            &rev_reg_delta_json,
+                            &cred_rev_id,
+                            &tails_file
+                        ).map_err(|e| ProofError::CommonError(e))?;
+
+                        if timestamp > cached_rev_state.timestamp {
+                            let new_cache = RevRegCache {
+                                rev_state: Some(RevState {
+                                    timestamp: timestamp,
+                                    value: rev_state_json.clone()
+                                })
+                            };
+                            set_rev_reg_cache(&rev_reg_id, &new_cache);
+                        }
+
+                        (rev_state_json, timestamp)
+                    }
+                } else {
+                    let (_, rev_reg_def_json) = get_rev_reg_def_json(&rev_reg_id)
+                        .map_err(|e| ProofError::CommonError(e))?;
+
+                    let (rev_reg_id, rev_reg_delta_json, timestamp) = get_rev_reg_delta_json(
+                        &rev_reg_id,
+                        None,
+                        to
+                    ).map_err(|e| ProofError::CommonError(e))?;
+
+                    let rev_state_json = anoncreds::libindy_prover_create_revocation_state(
+                        &rev_reg_def_json,
+                        &rev_reg_delta_json,
+                        &cred_rev_id,
+                        &tails_file
+                    ).map_err(|e| ProofError::CommonError(e))?;
+
+                    let new_cache = RevRegCache {
+                        rev_state: Some(RevState {
+                            timestamp: timestamp,
+                            value: rev_state_json.clone()
+                        })
+                    };
+                    set_rev_reg_cache(&rev_reg_id, &new_cache);
+
+                    (rev_state_json, timestamp)
+                };
+
+                let rev_state_json: Value = serde_json::from_str(&rev_state_json)
+                    .or(Err(ProofError::InvalidJson()))?;
+
+                rtn[rev_reg_id.to_string()] = json!({timestamp.to_string(): rev_state_json});",211,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/240170476,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r240170476,dkulic
https://github.com/hyperledger/indy-sdk/pull/1267,https://github.com/hyperledger/indy-sdk/pull/1267,"@ryMarsh44 @glowkey I am not sure I understand fully how this should be reorganized, may you help me with that?",846d5170ae380a08b152dcb1f64e5b8f2570db85,2018-12-10 11:19:17,240172077,"@@ -84,3 +90,359 @@ pub fn libindy_build_create_credential_def_txn(submitter_did: &str,
         .wait()
         .map_err(map_rust_indy_sdk_error_code)
 }
+
+pub fn libindy_build_revoc_reg_def_request(submitter_did: &str,
+                                           rev_reg_def_json: &str) -> Result<String, u32> {
+    ledger::build_revoc_reg_def_request(submitter_did, rev_reg_def_json)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+
+pub fn libindy_build_revoc_reg_entry_request(submitter_did: &str,
+                                             rev_reg_id: &str,
+                                             rev_def_type: &str,
+                                             value: &str) -> Result<String, u32> {
+    ledger::build_revoc_reg_entry_request(submitter_did, rev_reg_id, rev_def_type, value)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_build_get_revoc_reg_def_request(submitter_did: &str, rev_reg_id: &str) -> Result<String, u32> {
+    ledger::build_get_revoc_reg_def_request(Some(submitter_did), rev_reg_id)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_parse_get_revoc_reg_def_response(rev_reg_def_json: &str) -> Result<(String, String), u32> {
+    ledger::parse_get_revoc_reg_def_response(rev_reg_def_json)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_build_get_revoc_reg_delta_request(submitter_did: &str,
+                                                 rev_reg_id: &str,
+                                                 from: i64,
+                                                 to: i64) -> Result<String, u32> {
+    ledger::build_get_revoc_reg_delta_request(Some(submitter_did),
+                                              rev_reg_id,
+                                              from,
+                                              to)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+fn libindy_build_get_revoc_reg_request(submitter_did: &str, rev_reg_id: &str, timestamp: u64)
+    -> Result<String, u32> {
+    ledger::build_get_revoc_reg_request(Some(submitter_did),
+                                        rev_reg_id,
+                                        timestamp as i64)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+fn libindy_parse_get_revoc_reg_response(get_rev_reg_resp: &str) -> Result<(String, String, u64), u32> {
+    ledger::parse_get_revoc_reg_response(get_rev_reg_resp)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn libindy_parse_get_revoc_reg_delta_response(get_rev_reg_delta_response: &str)
+    -> Result<(String, String, u64), u32> {
+    ledger::parse_get_revoc_reg_delta_response(get_rev_reg_delta_response)
+        .wait()
+        .map_err(map_rust_indy_sdk_error_code)
+}
+
+pub fn create_schema(name: &str, version: &str, data: &str) -> Result<(String, Option<PaymentTxn>), u32> {
+    if settings::test_indy_mode_enabled() {
+        return Ok((SCHEMA_ID.to_string(), Some(PaymentTxn::from_parts(r#""[""pay:null:9UFgyjuJxi1i1HD""]""#,r#""[{""amount"":4,""extra"":null,""recipient"":""pay:null:xkIsxem0YNtHrRO""}]""#,1, false).unwrap(), )));
+    }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    let (id, create_schema) = libindy_issuer_create_schema(&submitter_did, name, version, data)?;
+
+    let request = libindy_build_schema_request(&submitter_did, &create_schema)?;
+
+    let (payment, response) = pay_for_txn(&request, SCHEMA_TXN_TYPE)?;
+
+    _check_create_schema_response(&response)?;
+
+    Ok((id, payment))
+}
+
+fn _check_create_schema_response(response: &str) -> Result<(), u32> {
+    let response: Value = serde_json::from_str(response).or(Err(error::INVALID_JSON.code_num))?;
+
+    if let Some(_) = response.get(""result"") { return Ok(()) };
+
+    warn!(""No result found in ledger txn. Must be Rejected"");
+
+    if response[""op""] == json!(""REJECT"") {
+        match response.get(""reason"") {
+            Some(r) => return Err(error::DUPLICATE_SCHEMA.code_num),
+            None => return Err(error::UNKNOWN_SCHEMA_REJECTION.code_num),
+        }
+    }
+
+    Err(error::UNKNOWN_SCHEMA_REJECTION.code_num)
+}
+
+pub fn get_schema_json(schema_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((SCHEMA_ID.to_string(), SCHEMA_JSON.to_string()))}
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+    libindy_build_get_schema_request(&submitter_did, schema_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_schema_response(&response))
+}
+
+pub fn create_cred_def(issuer_did: &str,
+                       schema_json: &str,
+                       tag: &str,
+                       sig_type: Option<&str>,
+                       support_revocation: Option<bool>) -> Result<(String, Option<PaymentTxn>), u32> {
+    if settings::test_indy_mode_enabled() {
+        return Ok((CRED_DEF_ID.to_string(), Some(PaymentTxn::from_parts(r#""[""pay:null:9UFgyjuJxi1i1HD""]""#,r#""[{""amount"":4,""extra"":null,""recipient"":""pay:null:xkIsxem0YNtHrRO""}]""#,1, false).unwrap())));
+    }
+
+    let config_json = json!({""support_revocation"": support_revocation.unwrap_or(false)}).to_string();
+
+    let (id, cred_def_json) = libindy_create_and_store_credential_def(issuer_did,
+                                                                      schema_json,
+                                                                      tag,
+                                                                      sig_type,
+                                                                      &config_json)?;
+
+    let cred_def_req = libindy_build_create_credential_def_txn(issuer_did, &cred_def_json)?;
+
+    let (payment, response) = pay_for_txn(&cred_def_req, CRED_DEF_TXN_TYPE)?;
+
+    Ok((id, payment))
+}
+
+pub fn get_cred_def_json(cred_def_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((CRED_DEF_ID.to_string(), CRED_DEF_JSON.to_string())); }
+
+    libindy_build_get_credential_def_txn(cred_def_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_cred_def_response(&response))
+}
+
+pub fn create_rev_reg_def(issuer_did: &str, cred_def_id: &str, tails_file: &str, max_creds: u32)
+    -> Result<(String, String, String, Option<PaymentTxn>), u32> {
+    debug!(""creating revocation registry definition with issuer_did: {}, cred_def_id: {}, tails_file_path: {}, max_creds: {}"",
+           issuer_did, cred_def_id, tails_file, max_creds);
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_DEF_JSON.to_string(), """".to_string(), None)); }
+
+    let (rev_reg_id, rev_reg_def_json, rev_reg_entry_json) = libindy_create_and_store_revoc_reg(
+        issuer_did,
+        cred_def_id,
+        tails_file,
+        max_creds
+    )?;
+
+    let rev_reg_def_req = libindy_build_revoc_reg_def_request(issuer_did, &rev_reg_def_json)?;
+
+    let (payment, _) = pay_for_txn(&rev_reg_def_req, REV_REG_DEF_TXN_TYPE)?;
+
+    Ok((rev_reg_id, rev_reg_def_json, rev_reg_entry_json, payment))
+}
+
+pub fn get_rev_reg_def_json(rev_reg_id: &str) -> Result<(String, String), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_DEF_JSON.to_string())); }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    libindy_build_get_revoc_reg_def_request(&submitter_did, rev_reg_id)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_def_response(&response))
+}
+
+pub fn post_rev_reg_delta(issuer_did: &str, rev_reg_id: &str, rev_reg_entry_json: &str)
+                          -> Result<(Option<PaymentTxn>, String), u32> {
+    libindy_build_revoc_reg_entry_request(issuer_did, rev_reg_id, REVOC_REG_TYPE, rev_reg_entry_json)
+        .and_then(|req| pay_for_txn(&req, REV_REG_DELTA_TXN_TYPE))
+}
+
+pub fn get_rev_reg_delta_json(rev_reg_id: &str, from: Option<u64>, to: Option<u64>)
+    -> Result<(String, String, u64), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_REG_DELTA_JSON.to_string(), 1)); }
+
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+    let from: i64 = if let Some(_from) = from { _from as i64 } else { -1 };
+    let to = if let Some(_to) = to { _to as i64 } else { time::get_time().sec };
+
+    libindy_build_get_revoc_reg_delta_request(&submitter_did, rev_reg_id, from, to)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_delta_response(&response))
+}
+
+pub fn get_rev_reg(rev_reg_id: &str, timestamp: u64) -> Result<(String, String, u64), u32> {
+    if settings::test_indy_mode_enabled() { return Ok((REV_REG_ID.to_string(), REV_REG_JSON.to_string(), 1)); }
+    let submitter_did = settings::get_config_value(settings::CONFIG_INSTITUTION_DID)?;
+
+    libindy_build_get_revoc_reg_request(&submitter_did, rev_reg_id, timestamp)
+        .and_then(|req| libindy_submit_request(&req))
+        .and_then(|response| libindy_parse_get_revoc_reg_response(&response))
+}
+
+pub fn revoke_credential(tails_file: &str, rev_reg_id: &str, cred_rev_id: &str)",,2018-12-17 16:47:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/240172077,https://github.com/hyperledger/indy-sdk/pull/1267#discussion_r240172077,dkulic
https://github.com/hyperledger/indy-sdk/pull/1261,https://github.com/hyperledger/indy-sdk/pull/1261,I think this сan only be applicable for master version and shouldn't get to stable.,9e59f397b5e08ef79de84ec0b5f1a74eea0832cb,2018-11-09 11:23:15,232221978,"@@ -42,7 +42,7 @@ rmp-serde = ""0.13.7""
 base64 = ""0.8.0""
 openssl = ""0.10""
 num-traits = ""0.2.0""
-indy = ""1.6.7""
+indy = { version = ""1.6.7"", path = ""../../wrappers/rust/"" }",5,2018-11-09 12:34:08,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/232221978,https://github.com/hyperledger/indy-sdk/pull/1261#discussion_r232221978,KitHat
https://github.com/hyperledger/indy-sdk/pull/1260,https://github.com/hyperledger/indy-sdk/pull/1260,"`ConfigOption` is Vec key:value. Why can't we keep it as HashMap and avoid mapping?
`configs: HashMap<String, String>`",10e9acb2b304d4eb3196affc6c04ecfd9eb4e4d0,2018-11-06 06:54:06,231013439,"@@ -23,6 +24,7 @@ pub struct Agent {
     verkey: String,
     forward_agent_detail: ForwardAgentDetail,
     router: Addr<Router>,
+    configs: HashMap<String, ConfigOption>",,2018-11-06 11:01:17,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/231013439,https://github.com/hyperledger/indy-sdk/pull/1260#discussion_r231013439,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1260,https://github.com/hyperledger/indy-sdk/pull/1260,"It is better to serialize and to store self.config as HashMap
`let configs: HashMap<String, String> = serde_json::from_str(&metadata).unwrap(); //FIX UNWRAP`",10e9acb2b304d4eb3196affc6c04ecfd9eb4e4d0,2018-11-06 06:55:16,231013628,"@@ -136,6 +139,19 @@ impl Agent {
                     .map(move |_| (wallet_handle, did, verkey, owner_did, owner_verkey, forward_agent_detail, router))
             })
             .and_then(move |(wallet_handle, did, verkey, owner_did, owner_verkey, forward_agent_detail, router)| {
+                did::get_did_metadata(wallet_handle, &did)
+                    .map(move |metadata| (wallet_handle, did, verkey, metadata, owner_did, owner_verkey, forward_agent_detail, router))
+                    .map_err(|err| err.context(""Can't get Agent DID Metadata."").into())
+            })
+            .and_then(move |(wallet_handle, did, verkey, metadata, owner_did, owner_verkey, forward_agent_detail, router)| {
+
+                let mut configs: HashMap<String, ConfigOption> = HashMap::new();
+                let metadata: Vec<ConfigOption> = serde_json::from_str(&metadata).unwrap();
+
+                for config_option in metadata {
+                    configs.insert(config_option.name.clone(), config_option);
+                }",,2018-11-06 11:01:17,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/231013628,https://github.com/hyperledger/indy-sdk/pull/1260#discussion_r231013628,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1260,https://github.com/hyperledger/indy-sdk/pull/1260,"It looks redundant mapping here. much easier to seriaise and store like a map.
we can move this like oitside and_then and replace like
`let config_metadata = ftry_act!(self, serde_json::to_string(&self.configs));`
",10e9acb2b304d4eb3196affc6c04ecfd9eb4e4d0,2018-11-06 06:56:26,231013802,"@@ -423,6 +449,61 @@ impl Agent {
             .into_box()
     }
 
+    fn handle_update_configs(&mut self, msg: UpdateConfigs) -> ResponseActFuture<Self, Vec<A2AMessage>, Error> {
+
+        for config_option in msg.configs {
+            match config_option.name.as_str() {
+                ""name"" | ""logo_url"" => { *self.configs.entry(config_option.name.clone()).or_insert(config_option) = config_option.clone(); },
+                _ => continue
+            }
+        }
+
+        future::ok(())
+            .into_actor(self)
+            .and_then( |_, slf, _| {
+
+                let config_metadata: serde_json::Value = slf.configs.iter().map( |(_, v)| serde_json::to_value(v).unwrap() ).collect();",,2018-11-06 11:01:17,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/231013802,https://github.com/hyperledger/indy-sdk/pull/1260#discussion_r231013802,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1260,https://github.com/hyperledger/indy-sdk/pull/1260,"we can use just `insert` here
`self.configs.insert(config_option.name, config_option.value);`",10e9acb2b304d4eb3196affc6c04ecfd9eb4e4d0,2018-11-06 06:57:01,231013893,"@@ -423,6 +449,61 @@ impl Agent {
             .into_box()
     }
 
+    fn handle_update_configs(&mut self, msg: UpdateConfigs) -> ResponseActFuture<Self, Vec<A2AMessage>, Error> {
+
+        for config_option in msg.configs {
+            match config_option.name.as_str() {
+                ""name"" | ""logo_url"" => { *self.configs.entry(config_option.name.clone()).or_insert(config_option) = config_option.clone(); },",,2018-11-06 11:01:17,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/231013893,https://github.com/hyperledger/indy-sdk/pull/1260#discussion_r231013893,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1260,https://github.com/hyperledger/indy-sdk/pull/1260,"move outside and avoid mapping
`let config_metadata = ftry_act!(self, serde_json::to_string(&self.configs));`
",10e9acb2b304d4eb3196affc6c04ecfd9eb4e4d0,2018-11-06 07:01:01,231014474,"@@ -423,6 +449,61 @@ impl Agent {
             .into_box()
     }
 
+    fn handle_update_configs(&mut self, msg: UpdateConfigs) -> ResponseActFuture<Self, Vec<A2AMessage>, Error> {
+
+        for config_option in msg.configs {
+            match config_option.name.as_str() {
+                ""name"" | ""logo_url"" => { *self.configs.entry(config_option.name.clone()).or_insert(config_option) = config_option.clone(); },
+                _ => continue
+            }
+        }
+
+        future::ok(())
+            .into_actor(self)
+            .and_then( |_, slf, _| {
+
+                let config_metadata: serde_json::Value = slf.configs.iter().map( |(_, v)| serde_json::to_value(v).unwrap() ).collect();
+
+                did::set_did_metadata(slf.wallet_handle, &slf.did, config_metadata.to_string().as_str())
+                    .map_err(|err| err.context(""Can't store config data as DID metadata."").into())
+                    .into_actor(slf)
+            })
+            .map( |_, _, _| {
+                vec![A2AMessage::ConfigsUpdated( ConfigsUpdated {} )]
+            })
+            .into_box()
+    }
+
+    fn handle_get_configs(&mut self, msg: GetConfigs) -> ResponseActFuture<Self, Vec<A2AMessage>, Error> {
+
+        let configs: Vec<ConfigOption> = self.configs.iter().filter( |(k, _)| msg.configs.contains(k) ).map( |(_, v)| v.clone() ).collect();
+
+        future::ok(())
+            .into_actor(self)
+            .map( |_, _, _| { vec![A2AMessage::Configs( Configs { configs } )] })
+            .into_box()
+    }
+
+    fn handle_remove_configs(&mut self, msg: RemoveConfigs) -> ResponseActFuture<Self, Vec<A2AMessage>, Error> {
+
+        self.configs.retain( |k, _| !msg.configs.contains(k) );
+
+        future::ok(())
+            .into_actor(self)
+            .and_then( |_, slf, _| {
+
+                let config_metadata: serde_json::Value = slf.configs.iter().map( |(_, v)| serde_json::to_value(v).unwrap() ).collect();
+",,2018-11-06 11:01:17,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/231014474,https://github.com/hyperledger/indy-sdk/pull/1260#discussion_r231014474,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1243,https://github.com/hyperledger/indy-sdk/pull/1243,Please remove temporary line,0272dcf58a1dd22d8b39013c43ca80a30c22badc,2018-10-26 07:48:33,228433503,"@@ -39,6 +39,7 @@ impl Did {
     }
 
     pub fn replace_keys_apply(wallet_handle: i32, did: &str) -> Result<(), ErrorCode> {
+        println!(""replace_keys_apply({}, {})"", wallet_handle, did);",,2018-10-26 12:28:13,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/228433503,https://github.com/hyperledger/indy-sdk/pull/1243#discussion_r228433503,jovfer
https://github.com/hyperledger/indy-sdk/pull/1243,https://github.com/hyperledger/indy-sdk/pull/1243,If MY2 group is no longer required please remove it.,0272dcf58a1dd22d8b39013c43ca80a30c22badc,2018-10-26 08:31:47,228445097,"@@ -326,9 +394,9 @@ pub mod tests {
     pub const DID_MY1: &'static str = ""VsKV7grR1BUE29mG2Fm2kX"";
     pub const VERKEY_MY1: &'static str = ""GjZWsBLgZCR18aL468JAT7w9CZRiBnpxUPPgyQxh4voa"";
 
-    pub const SEED_MY2: &'static str = ""00000000000000000000000000000My2"";
-    pub const DID_MY2: &'static str = ""2PRyVHmkXQnQzJQKxHxnXC"";
-    pub const VERKEY_MY2: &'static str = ""kqa2HyagzfMAq42H5f9u3UMwnSBPQx2QfrSyXbUPxMn"";
+//    pub const SEED_MY2: &'static str = ""00000000000000000000000000000My2"";",,2018-10-26 12:28:13,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/228445097,https://github.com/hyperledger/indy-sdk/pull/1243#discussion_r228445097,jovfer
https://github.com/hyperledger/indy-sdk/pull/1243,https://github.com/hyperledger/indy-sdk/pull/1243,"I left it because of order (now we have 1, 3, 4..), so later may be reused. :)",0272dcf58a1dd22d8b39013c43ca80a30c22badc,2018-10-26 09:18:40,228458812,"@@ -326,9 +394,9 @@ pub mod tests {
     pub const DID_MY1: &'static str = ""VsKV7grR1BUE29mG2Fm2kX"";
     pub const VERKEY_MY1: &'static str = ""GjZWsBLgZCR18aL468JAT7w9CZRiBnpxUPPgyQxh4voa"";
 
-    pub const SEED_MY2: &'static str = ""00000000000000000000000000000My2"";
-    pub const DID_MY2: &'static str = ""2PRyVHmkXQnQzJQKxHxnXC"";
-    pub const VERKEY_MY2: &'static str = ""kqa2HyagzfMAq42H5f9u3UMwnSBPQx2QfrSyXbUPxMn"";
+//    pub const SEED_MY2: &'static str = ""00000000000000000000000000000My2"";",,2018-10-26 12:28:13,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/228458812,https://github.com/hyperledger/indy-sdk/pull/1243#discussion_r228458812,dkulic
https://github.com/hyperledger/indy-sdk/pull/1242,https://github.com/hyperledger/indy-sdk/pull/1242,@jovfer DO we need some guidance for exact linit value?,558e127d6c231a5df963d3b945cc7161f76f1f10,2018-10-24 09:54:38,227721010,"@@ -43,3 +43,13 @@
 
 In order to run local nodes on MacOS, it may be necessary to set up port mapping between the Docker container
 and local host. Follow the instructions in [Indy SDK README](https://github.com/hyperledger/indy-sdk#how-to-start-local-nodes-pool-with-docker)
+
+# IOError while running of whole set of tests on MacOS
+
+There is a possible case when some tests are failed if whole set of tests is run (`cargo test`).
+But failed tests will be successful in case of separate runs.
+If an error message like `IOError` `Too many open files` is present in logs when fails can be fixed by changing default limit.
+
+`ulimit -n <new limit value>`",11,2018-10-24 09:54:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/227721010,https://github.com/hyperledger/indy-sdk/pull/1242#discussion_r227721010,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1242,https://github.com/hyperledger/indy-sdk/pull/1242,"@vimmerru It may depends on different params and it's a subject to change in the future as we can reorganize tests.
So we can estimate some very rough top limit, but I don't like this option",558e127d6c231a5df963d3b945cc7161f76f1f10,2018-10-24 09:57:51,227722196,"@@ -43,3 +43,13 @@
 
 In order to run local nodes on MacOS, it may be necessary to set up port mapping between the Docker container
 and local host. Follow the instructions in [Indy SDK README](https://github.com/hyperledger/indy-sdk#how-to-start-local-nodes-pool-with-docker)
+
+# IOError while running of whole set of tests on MacOS
+
+There is a possible case when some tests are failed if whole set of tests is run (`cargo test`).
+But failed tests will be successful in case of separate runs.
+If an error message like `IOError` `Too many open files` is present in logs when fails can be fixed by changing default limit.
+
+`ulimit -n <new limit value>`",11,2018-10-24 09:58:05,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/227722196,https://github.com/hyperledger/indy-sdk/pull/1242#discussion_r227722196,jovfer
https://github.com/hyperledger/indy-sdk/pull/1225,https://github.com/hyperledger/indy-sdk/pull/1225,I suggest moving this validation to handle_message,6307f0bd75d56f28e40f0f8c1ebd032dfa1e4326,2018-10-16 08:58:11,225453118,"@@ -0,0 +1,133 @@
+use actix::prelude::{Actor, Addr, Context, Handler, Message as ActorMessage, ResponseFuture};
+use domain::messages::*;
+use domain::config::CloudAgentConfig;
+use failure::*;
+use futures::*;
+use indy::{did, wallet};
+use utils::futures::*;
+use utils::messages::*;
+
+pub struct CloudAgent {
+    wallet_handle: i32,
+    owner_did: String,
+    did: String,
+    verkey: String,
+}
+
+impl CloudAgent {
+    pub fn start(config: CloudAgentConfig) -> ResponseFuture<Addr<CloudAgent>, Error> {
+        Self::new(config)
+            .map(|cloud_agent| cloud_agent.start())
+            .into_box()
+    }
+
+    pub fn new(config: CloudAgentConfig) -> ResponseFuture<CloudAgent, Error> {
+        let wallet_config = json!({
+            ""id"": config.wallet_id,
+            ""storage_type"": config.wallet_storage_type,
+            ""storage_config"": config.wallet_storage_config,
+         })
+            .to_string();
+
+        let wallet_credentials = json!({
+            ""key"": config.wallet_passphrase,
+            ""storage_credentials"": config.wallet_storage_credentials,
+        })
+            .to_string();
+
+        future::ok(())
+            .and_then(move |_| {
+                wallet::open_wallet(wallet_config.as_ref(), wallet_credentials.as_ref())
+                    .map_err(|err| err.context(""Can't open Cloud Agent wallet.`"").into())
+            })
+            .and_then(move |wallet_handle| {
+                did::key_for_local_did(wallet_handle,
+                                       config.did.as_ref())
+                    .map(move |verkey| (wallet_handle, verkey, config))
+                    .map_err(|err| err.context(""Can't get Cloud Agent did key"").into())
+            })
+            .map(move |(wallet_handle, verkey, config)| {
+                CloudAgent {
+                    wallet_handle,
+                    verkey,
+                    did: config.did,
+                    owner_did: config.owner_did,
+                }
+            })
+            .into_box()
+    }
+
+    pub fn handle_message(&mut self, msg: Vec<u8>) -> ResponseFuture<Vec<u8>, Error> {
+        trace!(""CloudAgent::handle_message >> msg: {:?}"", msg);
+
+        let wallet_handle = self.wallet_handle.clone();
+        let owner_did = self.owner_did.clone();
+        let cloud_agent_vk = self.verkey.clone();
+
+        unbundle_authcrypted(wallet_handle, &cloud_agent_vk, &msg)
+            .and_then(move |(sender_vk, msg)| {
+                match msg {
+                    Message::CreateKey(msg) => {
+                        Self::_handle_create_key(wallet_handle, owner_did, cloud_agent_vk, sender_vk, msg)
+                    }
+                    _ => future::err(err_msg(""Unsupported message"")).into_box()
+                }
+            })
+            .into_box()
+    }
+
+    fn _handle_create_key(wallet_handle: i32,
+                          owner_did: String,
+                          cloud_agent_vk: String,
+                          sender_vk: String,
+                          msg: CreateKey) -> ResponseFuture<Vec<u8>, Error> {
+        trace!(""CloudAgent::_handle_create_key >> {:?}, {:?}, {:?}, {:?}, {:?}"",
+               wallet_handle, owner_did, cloud_agent_vk, sender_vk, msg);
+
+        if msg.from_did != owner_did {",87,2018-10-16 08:58:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225453118,https://github.com/hyperledger/indy-sdk/pull/1225#discussion_r225453118,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,"As far as I  understand VCX should be able to work without any payment plugins. So, `CONFIG_PAYMENT_METHOD` should be an optional field. And it's better to move it validation to `settings/validate_config` function.",a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 06:37:45,225412930,"@@ -76,10 +76,14 @@ pub extern fn vcx_init (command_handle: u32,
         } else {
             match settings::process_config_file(&config_path) {
                 Err(e) => {
-                    println!(""Invalid configuration specified: {}"", e);
                     return error::INVALID_CONFIGURATION.code_num;
                 },
-                Ok(_) => (),
+                Ok(_) => {
+                    match settings::validate_payment_method() {",9,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225412930,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225412930,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,"> And it's better to move it validation to `settings/validate`_config function.

@Artemkaaas The problem there is that there is another init function that calls `validate _config` which does only wallet export/import logic and does not require a plugin to be loaded for it to function. This one on the other hand is called on App load so it made sense to check it only here -- I tried with validation in `validate_config` and it broke half of the tests. It was either that or creating another validation function.

Per my conversation with Douglas the other one will be removed soon so the all validation can be moved in the `setting/validate_config`.",a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 07:59:30,225433677,"@@ -76,10 +76,14 @@ pub extern fn vcx_init (command_handle: u32,
         } else {
             match settings::process_config_file(&config_path) {
                 Err(e) => {
-                    println!(""Invalid configuration specified: {}"", e);
                     return error::INVALID_CONFIGURATION.code_num;
                 },
-                Ok(_) => (),
+                Ok(_) => {
+                    match settings::validate_payment_method() {",9,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225433677,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225433677,donqui
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,It seems that the payment plugin is not being initialized anywhere.  In testing it gets initialized inside ::utils::devsetup::tests::init_plugin() but that function is for testing only.  How is the payment plugin initialized outside of testing?,a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 14:43:25,225571035,"@@ -95,11 +99,6 @@ fn _finish_init(command_handle: u32, cb: extern fn(xcommand_handle: u32, err: u3
 
     ::utils::threadpool::init();
 
-    match ::utils::libindy::payments::init_payments() {",21,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225571035,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225571035,glowkey
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,"If somebody wanted to initialize the ""libsovtoken"" payment plugin would all three have to be configured?  Are there configuration options for all three different values?",a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 14:44:42,225571720,"@@ -55,6 +56,10 @@ pub static DEFAULT_WALLET_KEY: &str = ""foobar1234"";
 pub static DEFAULT_THREADPOOL_SIZE: usize = 8;
 pub static MASK_VALUE: &str = ""********"";
 pub static DEFAULT_WALLET_KEY_DERIVATION: &str = ""ARGON2I_INT"";
+pub static DEFAULT_PAYMENT_PLUGIN: &str = ""libnullpay.so"";
+pub static DEFAULT_PAYMENT_INIT_FUNCTION: &str = ""nullpay_init"";
+pub static DEFAULT_PAYMENT_METHOD: &str = ""null"";",14,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225571720,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225571720,glowkey
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,"It seems this function should try to load the payment plugin to test if it is valid, not just if it is present.",a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 14:45:36,225572141,"@@ -245,6 +250,23 @@ pub fn get_wallet_credentials() -> String {
     credentials.to_string()
 }
 
+pub fn validate_payment_method() -> Result<(), u32> {
+    let config = SETTINGS.read().unwrap();
+    if let Some(method) = config.get(CONFIG_PAYMENT_METHOD) {
+        if !method.to_string().is_empty() {
+            return Ok(());
+        }
+    }
+    return Err(error::MISSING_PAYMENT_METHOD.code_num);
+}",47,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225572141,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225572141,glowkey
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,"If the plugin is loaded by the user and can be custom, how should we validate? Three char string?",a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 14:49:01,225573707,"@@ -245,6 +250,23 @@ pub fn get_wallet_credentials() -> String {
     credentials.to_string()
 }
 
+pub fn validate_payment_method() -> Result<(), u32> {
+    let config = SETTINGS.read().unwrap();
+    if let Some(method) = config.get(CONFIG_PAYMENT_METHOD) {
+        if !method.to_string().is_empty() {
+            return Ok(());
+        }
+    }
+    return Err(error::MISSING_PAYMENT_METHOD.code_num);
+}",47,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225573707,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225573707,donqui
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,Application using libvcx needs to load the plugin beforehand and call init on the plugin for it to bind with libindy.,a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 14:49:56,225574127,"@@ -95,11 +99,6 @@ fn _finish_init(command_handle: u32, cb: extern fn(xcommand_handle: u32, err: u3
 
     ::utils::threadpool::init();
 
-    match ::utils::libindy::payments::init_payments() {",21,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225574127,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225574127,donqui
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,I think we should try to initialize the plugin using the init function.  If that fails then the plugin is invalid.,a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 14:50:07,225574202,"@@ -245,6 +250,23 @@ pub fn get_wallet_credentials() -> String {
     credentials.to_string()
 }
 
+pub fn validate_payment_method() -> Result<(), u32> {
+    let config = SETTINGS.read().unwrap();
+    if let Some(method) = config.get(CONFIG_PAYMENT_METHOD) {
+        if !method.to_string().is_empty() {
+            return Ok(());
+        }
+    }
+    return Err(error::MISSING_PAYMENT_METHOD.code_num);
+}",47,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225574202,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225574202,glowkey
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,"Yes, if libsovtoken is to be used these should be changed.

Config options are not available because only method is something that needs to be configured for libvcx, these DEFAULTS_* are just for testing purposes.

I did not find a way to provide a global test config from which these could be loaded.",a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 14:52:27,225575292,"@@ -55,6 +56,10 @@ pub static DEFAULT_WALLET_KEY: &str = ""foobar1234"";
 pub static DEFAULT_THREADPOOL_SIZE: usize = 8;
 pub static MASK_VALUE: &str = ""********"";
 pub static DEFAULT_WALLET_KEY_DERIVATION: &str = ""ARGON2I_INT"";
+pub static DEFAULT_PAYMENT_PLUGIN: &str = ""libnullpay.so"";
+pub static DEFAULT_PAYMENT_INIT_FUNCTION: &str = ""nullpay_init"";
+pub static DEFAULT_PAYMENT_METHOD: &str = ""null"";",14,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225575292,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225575292,donqui
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,"Ticked I was working on states that initialization of the plugin is the responsibility of the user application not libvcx:  https://jira.hyperledger.org/browse/IS-934

@vimmerru ^^",a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 14:55:20,225576722,"@@ -245,6 +250,23 @@ pub fn get_wallet_credentials() -> String {
     credentials.to_string()
 }
 
+pub fn validate_payment_method() -> Result<(), u32> {
+    let config = SETTINGS.read().unwrap();
+    if let Some(method) = config.get(CONFIG_PAYMENT_METHOD) {
+        if !method.to_string().is_empty() {
+            return Ok(());
+        }
+    }
+    return Err(error::MISSING_PAYMENT_METHOD.code_num);
+}",47,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225576722,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225576722,donqui
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,"@glowkey @e-nem-y 

> It seems this function should try to load the payment plugin to test if it is valid, not just if it is present.

Loading can't be responsibility of vcx as it is impossible on the most of platforms. If it is possible we still don't know plugin placement and dll name. 

Initialization can be responsibility of vcx, but in this case we need to provide the name of init method. It looks very unsafe and unnatural. I am not sure that it is possible to call static linked function by name. For loaded plugins it is possible, but on Android and iOS we link statically.",a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 15:04:59,225581149,"@@ -245,6 +250,23 @@ pub fn get_wallet_credentials() -> String {
     credentials.to_string()
 }
 
+pub fn validate_payment_method() -> Result<(), u32> {
+    let config = SETTINGS.read().unwrap();
+    if let Some(method) = config.get(CONFIG_PAYMENT_METHOD) {
+        if !method.to_string().is_empty() {
+            return Ok(());
+        }
+    }
+    return Err(error::MISSING_PAYMENT_METHOD.code_num);
+}",47,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225581149,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225581149,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,"One correction. It is possible to call only function by name when we load dll/so from our program, dynamic linking that loads so on program start doesn't allow us it too.",a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 15:10:00,225583352,"@@ -245,6 +250,23 @@ pub fn get_wallet_credentials() -> String {
     credentials.to_string()
 }
 
+pub fn validate_payment_method() -> Result<(), u32> {
+    let config = SETTINGS.read().unwrap();
+    if let Some(method) = config.get(CONFIG_PAYMENT_METHOD) {
+        if !method.to_string().is_empty() {
+            return Ok(());
+        }
+    }
+    return Err(error::MISSING_PAYMENT_METHOD.code_num);
+}",47,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225583352,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225583352,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,"If this is the case, that application needs to load plugin itself, then libnullpay (and libsovtoken) will need to create wrappers for the one ""init"" function.  Correct?",a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 15:18:06,225587027,"@@ -245,6 +250,23 @@ pub fn get_wallet_credentials() -> String {
     credentials.to_string()
 }
 
+pub fn validate_payment_method() -> Result<(), u32> {
+    let config = SETTINGS.read().unwrap();
+    if let Some(method) = config.get(CONFIG_PAYMENT_METHOD) {
+        if !method.to_string().is_empty() {
+            return Ok(());
+        }
+    }
+    return Err(error::MISSING_PAYMENT_METHOD.code_num);
+}",47,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225587027,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225587027,glowkey
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,"In my vision working workflow is the following:

- application links with a plugin or loads it
- application calls init function
- application provides the name of payment method to vcx config",a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 15:20:20,225587970,"@@ -245,6 +250,23 @@ pub fn get_wallet_credentials() -> String {
     credentials.to_string()
 }
 
+pub fn validate_payment_method() -> Result<(), u32> {
+    let config = SETTINGS.read().unwrap();
+    if let Some(method) = config.get(CONFIG_PAYMENT_METHOD) {
+        if !method.to_string().is_empty() {
+            return Ok(());
+        }
+    }
+    return Err(error::MISSING_PAYMENT_METHOD.code_num);
+}",47,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225587970,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225587970,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,Does libnullpay have wrappers?,a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 15:25:53,225590433,"@@ -245,6 +250,23 @@ pub fn get_wallet_credentials() -> String {
     credentials.to_string()
 }
 
+pub fn validate_payment_method() -> Result<(), u32> {
+    let config = SETTINGS.read().unwrap();
+    if let Some(method) = config.get(CONFIG_PAYMENT_METHOD) {
+        if !method.to_string().is_empty() {
+            return Ok(());
+        }
+    }
+    return Err(error::MISSING_PAYMENT_METHOD.code_num);
+}",47,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225590433,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225590433,glowkey
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,"No, but for dynamic languages we can provide generic API like:

```
- init_plugin(init_function_name)
- load_plugin(dll path)
```",a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 15:31:41,225593099,"@@ -245,6 +250,23 @@ pub fn get_wallet_credentials() -> String {
     credentials.to_string()
 }
 
+pub fn validate_payment_method() -> Result<(), u32> {
+    let config = SETTINGS.read().unwrap();
+    if let Some(method) = config.get(CONFIG_PAYMENT_METHOD) {
+        if !method.to_string().is_empty() {
+            return Ok(());
+        }
+    }
+    return Err(error::MISSING_PAYMENT_METHOD.code_num);
+}",47,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225593099,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225593099,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,Should that wrapper work be done as part of this PR?,a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 15:33:11,225593740,"@@ -245,6 +250,23 @@ pub fn get_wallet_credentials() -> String {
     credentials.to_string()
 }
 
+pub fn validate_payment_method() -> Result<(), u32> {
+    let config = SETTINGS.read().unwrap();
+    if let Some(method) = config.get(CONFIG_PAYMENT_METHOD) {
+        if !method.to_string().is_empty() {
+            return Ok(());
+        }
+    }
+    return Err(error::MISSING_PAYMENT_METHOD.code_num);
+}",47,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225593740,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225593740,glowkey
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,"I believe it is unnecessary. For example, loading plugin from python or Java is a trivial task (few lines of code). As a result we already can get valuable demo.",a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 15:41:14,225597152,"@@ -245,6 +250,23 @@ pub fn get_wallet_credentials() -> String {
     credentials.to_string()
 }
 
+pub fn validate_payment_method() -> Result<(), u32> {
+    let config = SETTINGS.read().unwrap();
+    if let Some(method) = config.get(CONFIG_PAYMENT_METHOD) {
+        if !method.to_string().is_empty() {
+            return Ok(());
+        }
+    }
+    return Err(error::MISSING_PAYMENT_METHOD.code_num);
+}",47,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225597152,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225597152,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1223,https://github.com/hyperledger/indy-sdk/pull/1223,My main concern is about ConnectMe.,a0e1ab02760d1635bb485d852a3b081950e2a45d,2018-10-16 15:42:04,225597459,"@@ -245,6 +250,23 @@ pub fn get_wallet_credentials() -> String {
     credentials.to_string()
 }
 
+pub fn validate_payment_method() -> Result<(), u32> {
+    let config = SETTINGS.read().unwrap();
+    if let Some(method) = config.get(CONFIG_PAYMENT_METHOD) {
+        if !method.to_string().is_empty() {
+            return Ok(());
+        }
+    }
+    return Err(error::MISSING_PAYMENT_METHOD.code_num);
+}",47,2018-10-26 13:38:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225597459,https://github.com/hyperledger/indy-sdk/pull/1223#discussion_r225597459,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1222,https://github.com/hyperledger/indy-sdk/pull/1222,This comment and test makes me a bit crazy. @glowkey Could you look?,9e68ad5575374839bbca6223c3a71646ef3f1fa3,2018-10-18 09:23:05,226231888,"@@ -18,12 +18,15 @@
     assert error_message(ErrorCode.NotReady) == 'Object not ready for specified action'
 
 @pytest.mark.asyncio
-@pytest.mark.usefixtures('vcx_init_test_mode')
-async def test_shutdown_works():
+async def test_shutdown_works(vcx_init_test_mode):
     with pytest.raises(VcxError) as e:
         connection = await Connection.create('123')
         assert connection.handle > 0
         shutdown(True)
         await connection.serialize()
-    assert ErrorCode.InvalidConnectionHandle == e.value.error_code
+    # If vcx_init_test_mode was called on a previous test, then",,2018-10-29 14:21:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/226231888,https://github.com/hyperledger/indy-sdk/pull/1222#discussion_r226231888,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1222,https://github.com/hyperledger/indy-sdk/pull/1222,I would like to get rid of the test completely rather than try to fix it. It shows a lack if understanding of how the python tests work.,9e68ad5575374839bbca6223c3a71646ef3f1fa3,2018-10-18 15:58:09,226365835,"@@ -18,12 +18,15 @@
     assert error_message(ErrorCode.NotReady) == 'Object not ready for specified action'
 
 @pytest.mark.asyncio
-@pytest.mark.usefixtures('vcx_init_test_mode')
-async def test_shutdown_works():
+async def test_shutdown_works(vcx_init_test_mode):
     with pytest.raises(VcxError) as e:
         connection = await Connection.create('123')
         assert connection.handle > 0
         shutdown(True)
         await connection.serialize()
-    assert ErrorCode.InvalidConnectionHandle == e.value.error_code
+    # If vcx_init_test_mode was called on a previous test, then",,2018-10-29 14:21:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/226365835,https://github.com/hyperledger/indy-sdk/pull/1222#discussion_r226365835,glowkey
https://github.com/hyperledger/indy-sdk/pull/1217,https://github.com/hyperledger/indy-sdk/pull/1217,"@srottem is this file redundant?
If yes - please remove it from history (rm, amend commit + force push)",5c217044721a037440f70d205e8be1135216c6c6,2018-10-15 10:53:11,225120675,"@@ -0,0 +1,15302 @@
+From 4c71e13695a1b18cd76de6f340ca023ea5ca4399 Mon Sep 17 00:00:00 2001",,2018-10-15 13:25:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225120675,https://github.com/hyperledger/indy-sdk/pull/1217#discussion_r225120675,jovfer
https://github.com/hyperledger/indy-sdk/pull/1217,https://github.com/hyperledger/indy-sdk/pull/1217,Removed - apologies.,5c217044721a037440f70d205e8be1135216c6c6,2018-10-15 11:04:22,225123677,"@@ -0,0 +1,15302 @@
+From 4c71e13695a1b18cd76de6f340ca023ea5ca4399 Mon Sep 17 00:00:00 2001",,2018-10-15 13:25:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225123677,https://github.com/hyperledger/indy-sdk/pull/1217#discussion_r225123677,srottem
https://github.com/hyperledger/indy-sdk/pull/1217,https://github.com/hyperledger/indy-sdk/pull/1217,thanks,5c217044721a037440f70d205e8be1135216c6c6,2018-10-15 12:12:37,225141253,"@@ -0,0 +1,15302 @@
+From 4c71e13695a1b18cd76de6f340ca023ea5ca4399 Mon Sep 17 00:00:00 2001",,2018-10-15 13:25:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/225141253,https://github.com/hyperledger/indy-sdk/pull/1217#discussion_r225141253,jovfer
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,"This through line 631 doesn't seem like it would fit in the crypto_service now, but I'm not exactly sure where the best place to put them would be. for the recipient focused functions, I plan to move those into the command layer which shouldn't be a problem. For the other two symmetrical crypto encrypt/decrypt functions though these don't feel like they fit, but I don't know a better place to put them. Any suggestions? @jovfer @vimmerru ",194a4ee20d72c07457cd46364e6fa468a7c2c504,2018-11-29 12:15:42,237463234,"@@ -425,6 +452,183 @@ impl CryptoService {
 
         Ok(res)
     }
+",137,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/237463234,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r237463234,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,"If `key` is a private key, it needs to be cleared after sign.",194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-09 21:36:40,246554858,"@@ -116,29 +140,46 @@ impl CryptoCommandExecutor {
                 info!(""AnonymousDecrypt command received"");
                 cb(self.anonymous_decrypt(wallet_handle, &my_vk, &encrypted_msg));
             }
+            CryptoCommand::PackMessage(message, receivers, sender_vk, wallet_handle, cb) => {
+                info!(""PackMessage command received"");
+                cb(self.pack_msg(message, &receivers, &sender_vk, wallet_handle));
+            }
+            CryptoCommand::UnpackMessage(jwe_json, wallet_handle, cb) => {
+                info!(""UnpackMessage command received"");
+                cb(self.unpack_msg(jwe_json, wallet_handle));
+            }
         };
     }
 
     fn create_key(&self, wallet_handle: i32, key_info: &KeyInfo) -> Result<String> {
-        debug!(""create_key >>> wallet_handle: {:?}, key_info: {:?}"", wallet_handle, secret!(key_info));
+        debug!(
+            ""create_key >>> wallet_handle: {:?}, key_info: {:?}"",
+            wallet_handle,
+            secret!(key_info)
+        );
 
         let key = self.crypto_service.create_key(key_info)?;
-        self.wallet_service.add_indy_object(wallet_handle, &key.verkey, &key, &HashMap::new())?;
+        self.wallet_service
+            .add_indy_object(wallet_handle, &key.verkey, &key, &HashMap::new())?;
 
         let res = key.verkey;
         debug!(""create_key <<< res: {:?}"", res);
         Ok(res)
     }
 
-    fn crypto_sign(&self,
-                   wallet_handle: i32,
-                   my_vk: &str,
-                   msg: &[u8]) -> Result<Vec<u8>> {
-        debug!(""crypto_sign >>> wallet_handle: {:?}, sender_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, msg);
+    fn crypto_sign(&self, wallet_handle: i32, my_vk: &str, msg: &[u8]) -> Result<Vec<u8>> {
+        debug!(
+            ""crypto_sign >>> wallet_handle: {:?}, sender_vk: {:?}, msg: {:?}"",
+            wallet_handle, my_vk, msg
+        );
 
         self.crypto_service.validate_key(my_vk)?;
 
-        let key: Key = self.wallet_service.get_indy_object(wallet_handle, &my_vk, &RecordOptions::id_value())?;
+        let key: Key = self.wallet_service.get_indy_object(
+            wallet_handle,
+            &my_vk,
+            &RecordOptions::id_value(),
+        )?;
 
         let res = self.crypto_service.sign(&key, msg)?;
 ",178,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/246554858,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r246554858,mikelodder7
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,"If `key` is a private key, it needs to be cleared here.",194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-09 21:37:18,246555095,"@@ -162,118 +203,400 @@ impl CryptoCommandExecutor {
         Ok(res)
     }
 
-    fn authenticated_encrypt(&self,
-                             wallet_handle: i32,
-                             my_vk: &str,
-                             their_vk: &str,
-                             msg: &[u8]) -> Result<Vec<u8>> {
-        debug!(""authenticated_encrypt >>> wallet_handle: {:?}, my_vk: {:?}, their_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, their_vk, msg);
+    fn authenticated_encrypt(
+        &self,
+        wallet_handle: i32,
+        my_vk: &str,
+        their_vk: &str,
+        msg: &[u8],
+    ) -> Result<Vec<u8>> {
+        debug!(
+            ""authenticated_encrypt >>> wallet_handle: {:?}, my_vk: {:?}, their_vk: {:?}, msg: {:?}"",
+            wallet_handle, my_vk, their_vk, msg
+        );
 
         self.crypto_service.validate_key(my_vk)?;
         self.crypto_service.validate_key(their_vk)?;
 
-        let my_key: Key = self.wallet_service.get_indy_object(wallet_handle, my_vk, &RecordOptions::id_value())?;
-
-        let msg = self.crypto_service.create_combo_box(&my_key, &their_vk, msg)?;
-
-        let msg = msg.to_msg_pack()
-            .map_err(|e| CommonError::InvalidState(format!(""Can't serialize ComboBox: {:?}"", e)))?;
+        let my_key: Key = self.wallet_service.get_indy_object(
+            wallet_handle,
+            my_vk,
+            &RecordOptions::id_value(),
+        )?;
 
-        let res = self.crypto_service.encrypt_sealed(&their_vk, &msg)?;
+        let res = self
+            .crypto_service
+            .authenticated_encrypt(&my_key, their_vk, msg)?;
 ",227,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/246555095,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r246555095,mikelodder7
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,"If `key` is a private key, it needs to be cleared.",194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-09 21:37:55,246555284,"@@ -162,118 +203,400 @@ impl CryptoCommandExecutor {
         Ok(res)
     }
 
-    fn authenticated_encrypt(&self,
-                             wallet_handle: i32,
-                             my_vk: &str,
-                             their_vk: &str,
-                             msg: &[u8]) -> Result<Vec<u8>> {
-        debug!(""authenticated_encrypt >>> wallet_handle: {:?}, my_vk: {:?}, their_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, their_vk, msg);
+    fn authenticated_encrypt(
+        &self,
+        wallet_handle: i32,
+        my_vk: &str,
+        their_vk: &str,
+        msg: &[u8],
+    ) -> Result<Vec<u8>> {
+        debug!(
+            ""authenticated_encrypt >>> wallet_handle: {:?}, my_vk: {:?}, their_vk: {:?}, msg: {:?}"",
+            wallet_handle, my_vk, their_vk, msg
+        );
 
         self.crypto_service.validate_key(my_vk)?;
         self.crypto_service.validate_key(their_vk)?;
 
-        let my_key: Key = self.wallet_service.get_indy_object(wallet_handle, my_vk, &RecordOptions::id_value())?;
-
-        let msg = self.crypto_service.create_combo_box(&my_key, &their_vk, msg)?;
-
-        let msg = msg.to_msg_pack()
-            .map_err(|e| CommonError::InvalidState(format!(""Can't serialize ComboBox: {:?}"", e)))?;
+        let my_key: Key = self.wallet_service.get_indy_object(
+            wallet_handle,
+            my_vk,
+            &RecordOptions::id_value(),
+        )?;
 
-        let res = self.crypto_service.encrypt_sealed(&their_vk, &msg)?;
+        let res = self
+            .crypto_service
+            .authenticated_encrypt(&my_key, their_vk, msg)?;
 
         debug!(""authenticated_encrypt <<< res: {:?}"", res);
 
         Ok(res)
     }
 
-    fn authenticated_decrypt(&self,
-                             wallet_handle: i32,
-                             my_vk: &str,
-                             msg: &[u8]) -> Result<(String, Vec<u8>)> {
-        debug!(""authenticated_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, msg);
+    fn authenticated_decrypt(
+        &self,
+        wallet_handle: i32,
+        my_vk: &str,
+        msg: &[u8],
+    ) -> Result<(String, Vec<u8>)> {
+        debug!(
+            ""authenticated_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, msg: {:?}"",
+            wallet_handle, my_vk, msg
+        );
 
         self.crypto_service.validate_key(my_vk)?;
 
-        let my_key: Key = self.wallet_service.get_indy_object(wallet_handle, my_vk, &RecordOptions::id_value())?;
+        let my_key: Key = self.wallet_service.get_indy_object(
+            wallet_handle,
+            my_vk,
+            &RecordOptions::id_value(),
+        )?;
 
-        let decrypted_msg = self.crypto_service.decrypt_sealed(&my_key, &msg)?;
-
-        let parsed_msg = ComboBox::from_msg_pack(decrypted_msg.as_slice())
-            .map_err(|err| CommonError::InvalidStructure(format!(""Can't deserialize ComboBox: {:?}"", err)))?;
-
-        let doc: Vec<u8> = base64::decode(&parsed_msg.msg)
-            .map_err(|err| CommonError::InvalidStructure(format!(""Can't decode internal msg filed from base64 {}"", err)))?;
-
-        let nonce: Vec<u8> = base64::decode(&parsed_msg.nonce)
-            .map_err(|err| CommonError::InvalidStructure(format!(""Can't decode nonce from base64 {}"", err)))?;
-
-        let decrypted_msg = self.crypto_service.decrypt(&my_key, &parsed_msg.sender, &doc, &nonce)?;
-
-        let res = (parsed_msg.sender, decrypted_msg);
+        let res = self.crypto_service.authenticated_decrypt(&my_key, &msg)?;
 ",270,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/246555284,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r246555284,mikelodder7
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,"If `my_key` is a private key, it needs to be cleared.",194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-09 21:38:39,246555557,"@@ -162,118 +203,400 @@ impl CryptoCommandExecutor {
         Ok(res)
     }
 
-    fn authenticated_encrypt(&self,
-                             wallet_handle: i32,
-                             my_vk: &str,
-                             their_vk: &str,
-                             msg: &[u8]) -> Result<Vec<u8>> {
-        debug!(""authenticated_encrypt >>> wallet_handle: {:?}, my_vk: {:?}, their_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, their_vk, msg);
+    fn authenticated_encrypt(
+        &self,
+        wallet_handle: i32,
+        my_vk: &str,
+        their_vk: &str,
+        msg: &[u8],
+    ) -> Result<Vec<u8>> {
+        debug!(
+            ""authenticated_encrypt >>> wallet_handle: {:?}, my_vk: {:?}, their_vk: {:?}, msg: {:?}"",
+            wallet_handle, my_vk, their_vk, msg
+        );
 
         self.crypto_service.validate_key(my_vk)?;
         self.crypto_service.validate_key(their_vk)?;
 
-        let my_key: Key = self.wallet_service.get_indy_object(wallet_handle, my_vk, &RecordOptions::id_value())?;
-
-        let msg = self.crypto_service.create_combo_box(&my_key, &their_vk, msg)?;
-
-        let msg = msg.to_msg_pack()
-            .map_err(|e| CommonError::InvalidState(format!(""Can't serialize ComboBox: {:?}"", e)))?;
+        let my_key: Key = self.wallet_service.get_indy_object(
+            wallet_handle,
+            my_vk,
+            &RecordOptions::id_value(),
+        )?;
 
-        let res = self.crypto_service.encrypt_sealed(&their_vk, &msg)?;
+        let res = self
+            .crypto_service
+            .authenticated_encrypt(&my_key, their_vk, msg)?;
 
         debug!(""authenticated_encrypt <<< res: {:?}"", res);
 
         Ok(res)
     }
 
-    fn authenticated_decrypt(&self,
-                             wallet_handle: i32,
-                             my_vk: &str,
-                             msg: &[u8]) -> Result<(String, Vec<u8>)> {
-        debug!(""authenticated_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, msg);
+    fn authenticated_decrypt(
+        &self,
+        wallet_handle: i32,
+        my_vk: &str,
+        msg: &[u8],
+    ) -> Result<(String, Vec<u8>)> {
+        debug!(
+            ""authenticated_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, msg: {:?}"",
+            wallet_handle, my_vk, msg
+        );
 
         self.crypto_service.validate_key(my_vk)?;
 
-        let my_key: Key = self.wallet_service.get_indy_object(wallet_handle, my_vk, &RecordOptions::id_value())?;
+        let my_key: Key = self.wallet_service.get_indy_object(
+            wallet_handle,
+            my_vk,
+            &RecordOptions::id_value(),
+        )?;
 
-        let decrypted_msg = self.crypto_service.decrypt_sealed(&my_key, &msg)?;
-
-        let parsed_msg = ComboBox::from_msg_pack(decrypted_msg.as_slice())
-            .map_err(|err| CommonError::InvalidStructure(format!(""Can't deserialize ComboBox: {:?}"", err)))?;
-
-        let doc: Vec<u8> = base64::decode(&parsed_msg.msg)
-            .map_err(|err| CommonError::InvalidStructure(format!(""Can't decode internal msg filed from base64 {}"", err)))?;
-
-        let nonce: Vec<u8> = base64::decode(&parsed_msg.nonce)
-            .map_err(|err| CommonError::InvalidStructure(format!(""Can't decode nonce from base64 {}"", err)))?;
-
-        let decrypted_msg = self.crypto_service.decrypt(&my_key, &parsed_msg.sender, &doc, &nonce)?;
-
-        let res = (parsed_msg.sender, decrypted_msg);
+        let res = self.crypto_service.authenticated_decrypt(&my_key, &msg)?;
 
         debug!(""authenticated_decrypt <<< res: {:?}"", res);
 
         Ok(res)
     }
 
-    fn anonymous_encrypt(&self,
-                         their_vk: &str,
-                         msg: &[u8]) -> Result<Vec<u8>> {
-        debug!(""anonymous_encrypt >>> their_vk: {:?}, msg: {:?}"", their_vk, msg);
+    fn anonymous_encrypt(&self, their_vk: &str, msg: &[u8]) -> Result<Vec<u8>> {
+        debug!(
+            ""anonymous_encrypt >>> their_vk: {:?}, msg: {:?}"",
+            their_vk, msg
+        );
 
         self.crypto_service.validate_key(their_vk)?;
 
-        let res = self.crypto_service.encrypt_sealed(their_vk, &msg)?;
+        let res = self.crypto_service.crypto_box_seal(their_vk, &msg)?;
 
         debug!(""anonymous_encrypt <<< res: {:?}"", res);
 
         Ok(res)
     }
 
-    fn anonymous_decrypt(&self,
-                         wallet_handle: i32,
-                         my_vk: &str,
-                         encrypted_msg: &[u8]) -> Result<Vec<u8>> {
-        debug!(""anonymous_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, encrypted_msg: {:?}"", wallet_handle, my_vk, encrypted_msg);
+    fn anonymous_decrypt(
+        &self,
+        wallet_handle: i32,
+        my_vk: &str,
+        encrypted_msg: &[u8],
+    ) -> Result<Vec<u8>> {
+        debug!(
+            ""anonymous_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, encrypted_msg: {:?}"",
+            wallet_handle, my_vk, encrypted_msg
+        );
 
         self.crypto_service.validate_key(&my_vk)?;
 
-        let my_key: Key = self.wallet_service.get_indy_object(wallet_handle, &my_vk, &RecordOptions::id_value())?;
+        let my_key: Key = self.wallet_service.get_indy_object(
+            wallet_handle,
+            &my_vk,
+            &RecordOptions::id_value(),
+        )?;
 
-        let res = self.crypto_service.decrypt_sealed(&my_key, &encrypted_msg)?;
+        let res = self
+            .crypto_service
+            .crypto_box_seal_open(&my_key, &encrypted_msg)?;
 ",310,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/246555557,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r246555557,mikelodder7
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,"We have to keep some backward compatibility so I suggest to follow the plan in https://github.com/hyperledger/indy-sdk/pull/1210#issuecomment-453529654
1) for old calls use msgpack
2) for new - approach from HIPEs
3) mark old API as deprecated",194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-14 14:34:28,247513402,"@@ -1,18 +1,6 @@
-extern crate rmp_serde;
-
 #[derive(Serialize, Deserialize, Debug)]
 pub struct ComboBox {
     pub msg: String,
     pub sender: String,
     pub nonce: String
 }
-
-impl ComboBox {",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/247513402,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r247513402,jovfer
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,Probably for this particular structure we can add 2 new methods: `to/from_json_b64` and use them or existing ones from `authenticated_encrypt` depending on some parameter in internal calls...,194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-14 14:37:32,247514508,"@@ -1,18 +1,6 @@
-extern crate rmp_serde;
-
 #[derive(Serialize, Deserialize, Debug)]
 pub struct ComboBox {
     pub msg: String,
     pub sender: String,
     pub nonce: String
 }
-
-impl ComboBox {
-    pub fn to_msg_pack(&self) -> Result<Vec<u8>, rmp_serde::encode::Error> {
-        rmp_serde::encode::to_vec_named(self)
-    }
-
-    pub fn from_msg_pack(bytes: &[u8]) -> Result<ComboBox, rmp_serde::decode::Error> {
-        rmp_serde::decode::from_slice(bytes)
-    }",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/247514508,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r247514508,jovfer
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,"I brought back the old structure where this is handled in the command layer for the old APIs. I left the authenticated_encrypt in the service layer for the new pack/unpack APIs. Primary reason for this was to keep the size of the command functions smaller and more readable. Also, can you double check that when I pushed the new changes that it didn't rebrake the commit tree? I checked and didn't see any of the microledger related commits.",194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-15 00:19:13,247720279,"@@ -1,18 +1,6 @@
-extern crate rmp_serde;
-
 #[derive(Serialize, Deserialize, Debug)]
 pub struct ComboBox {
     pub msg: String,
     pub sender: String,
     pub nonce: String
 }
-
-impl ComboBox {
-    pub fn to_msg_pack(&self) -> Result<Vec<u8>, rmp_serde::encode::Error> {
-        rmp_serde::encode::to_vec_named(self)
-    }
-
-    pub fn from_msg_pack(bytes: &[u8]) -> Result<ComboBox, rmp_serde::decode::Error> {
-        rmp_serde::decode::from_slice(bytes)
-    }",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/247720279,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r247720279,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,There are some general concerns from Slava about DIDDoc and key referencing. These facts may affects pack/unpack API too. So I suggest to mark new calls as experimental at least for the next release.,194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 11:52:55,249748836,"@@ -557,4 +561,190 @@ pub  extern fn indy_crypto_anon_decrypt(command_handle: IndyHandle,
     trace!(""indy_crypto_anon_decrypt: <<< res: {:?}"", res);
 
     res
-}
\ No newline at end of file
+}
+
+/// Packs a message",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249748836,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249748836,jovfer
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,There are some general concerns from Slava about DIDDoc and key referencing. These facts may affects pack/unpack API too. So I suggest to mark new calls as experimental at least for the next release.,194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 11:53:08,249748902,"@@ -557,4 +561,190 @@ pub  extern fn indy_crypto_anon_decrypt(command_handle: IndyHandle,
     trace!(""indy_crypto_anon_decrypt: <<< res: {:?}"", res);
 
     res
-}
\ No newline at end of file
+}
+
+/// Packs a message
+///
+/// Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
+/// for specific DID.
+///
+/// #Params
+/// command_handle: command handle to map callback to user context.
+/// message: a pointer to the first byte of the message to be packed
+/// message_len: the length of the message
+/// receivers: a string in the format of a json list which will contain the list of receiver's keys
+///                the message is being encrypted for.
+///                Example:
+///                ""[<receiver edge_agent_1 verkey>, <receiver edge_agent_2 verkey>]""
+/// sender: the sender's verkey as a string When """" is used in this parameter, anoncrypt is used
+/// cb: Callback that takes command result as parameter.
+///
+/// #Returns
+/// a JWE using authcrypt alg is defined below:
+/// {
+///    ""protected"": ""b64URLencoded({
+///        ""enc"": ""xsalsa20poly1305"",
+///        ""typ"": ""JWM/1.0"",
+///        ""alg"": ""authcrypt"",
+///        ""recipients"": [
+///            {
+///                ""encrypted_key"": anoncrypt(encrypted_cek|sender_vk|nonce)
+///                ""header"": {
+///                    ""kid"": ""b64URLencode(ver_key)""
+///                }
+///            },
+///        ],
+///    })""
+///    ""iv"": <b64URLencode()>,
+///    ""ciphertext"": <b64URLencode(encrypt({'@type'...}, cek)>,
+///    ""tag"": <b64URLencode()>
+/// }
+///
+/// Alternative example in using anoncrypt alg is defined below:
+/// {
+///    ""protected"": ""b64URLencode({
+///        ""enc"": ""xsalsa20poly1305"",
+///        ""typ"": ""JWM/1.0"",
+///        ""alg"": ""anoncrypt"",
+///        ""recipients"": [
+///            {
+///                ""encrypted_key"": <b64URLencode(anoncrypt(cek))>,
+///                ""header"": {
+///                    ""kid"": ""b64URLencode(ver_key)""
+///                }
+///            },
+///        ],
+///    })""
+///    ""iv"": <b64URLencode(iv)>,
+///    ""ciphertext"": <b64URLencode(encrypt({'@type'...}, cek)>,
+///    ""tag"": <b64URLencode(authentication tag)>
+/// }
+///
+///
+/// #Errors
+/// Common*
+/// Wallet*
+/// Ledger*
+/// Crypto*
+#[no_mangle]
+pub extern fn indy_pack_message(
+    command_handle: IndyHandle,
+    wallet_handle: IndyHandle,
+    message: *const u8,
+    message_len: u32,
+    receiver_keys: *const c_char,
+    sender: *const c_char,
+    cb: Option<extern ""C"" fn(xcommand_handle: i32, err: ErrorCode, jwe_data: *const u8, jwe_len: u32)>,
+) -> ErrorCode {
+    trace!(""indy_pack_message: >>> wallet_handle: {:?}, message: {:?}, message_len {:?},\
+            receiver_keys: {:?}, sender: {:?}"", wallet_handle, message, message_len, receiver_keys, sender);
+
+    check_useful_c_byte_array!(message, message_len, ErrorCode::CommonInvalidParam2, ErrorCode::CommonInvalidParam3);
+    check_useful_c_str!(receiver_keys, ErrorCode::CommonInvalidParam4);
+    check_useful_c_str_empty_accepted!(sender, ErrorCode::CommonInvalidParam5);
+    check_useful_c_callback!(cb, ErrorCode::CommonInvalidParam6);
+
+    trace!(""indy_pack_message: entities >>> wallet_handle: {:?}, message: {:?}, message_len {:?},\
+            receiver_keys: {:?}, sender: {:?}"", wallet_handle, message, message_len, receiver_keys, sender);
+
+    let result = CommandExecutor::instance().send(Command::Crypto(CryptoCommand::PackMessage(
+        message,
+        receiver_keys,
+        sender,
+        wallet_handle,
+        Box::new(move |result| {
+            let (err, jwe) = result_to_err_code_1!(result, Vec::new());
+            trace!(""indy_auth_pack_message: jwe: {:?}"", jwe);
+            let (jwe_data, jwe_len) = ctypes::vec_to_pointer(&jwe);
+            cb(command_handle, err, jwe_data, jwe_len)
+        }),
+    )));
+
+    let res = result_to_err_code!(result);
+
+    trace!(""indy_auth_pack_message: <<< res: {:?}"", res);
+
+    res
+}
+
+
+/// Unpacks a message packed using indy_pack_message which follows the wire message format",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249748902,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249748902,jovfer
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,As far as I know this `URL_SAFE` alphabet is different for base64 against default one. In this case we must not to change this utility function behavior as it widely used in codebase,194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 12:04:45,249752266,"@@ -3,11 +3,11 @@ extern crate base64;
 use errors::common::CommonError;
 
 pub fn encode(doc: &[u8]) -> String {
-    base64::encode(doc)
+    base64::encode_config(doc, base64::URL_SAFE)",5,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249752266,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249752266,jovfer
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,"This trait was eliminated some times ago as useless, do we have some new reasons to restore it?",194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 12:07:03,249753041,"@@ -0,0 +1,19 @@
+extern crate serde;
+extern crate serde_json;
+
+use self::serde::{Serialize, Deserialize};
+use self::serde_json::Error;
+use std::string::String;
+
+
+pub trait JsonEncodable: Serialize + Sized {",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249753041,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249753041,jovfer
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,I suggest to replace this `match` by `if`,194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 12:10:29,249753987,"@@ -209,50 +288,368 @@ impl CryptoCommandExecutor {
         Ok(res)
     }
 
-    fn anonymous_decrypt(&self,
-                         wallet_handle: i32,
-                         my_vk: &str,
-                         encrypted_msg: &[u8]) -> Result<Vec<u8>> {
-        debug!(""anonymous_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, encrypted_msg: {:?}"", wallet_handle, my_vk, encrypted_msg);
+    fn anonymous_decrypt(
+        &self,
+        wallet_handle: i32,
+        my_vk: &str,
+        encrypted_msg: &[u8],
+    ) -> Result<Vec<u8>> {
+        debug!(
+            ""anonymous_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, encrypted_msg: {:?}"",
+            wallet_handle, my_vk, encrypted_msg
+        );
 
         self.crypto_service.validate_key(&my_vk)?;
 
-        let my_key: Key = self.wallet_service.get_indy_object(wallet_handle, &my_vk, &RecordOptions::id_value())?;
+        let my_key: Key = self.wallet_service.get_indy_object(
+            wallet_handle,
+            &my_vk,
+            &RecordOptions::id_value(),
+        )?;
 
-        let res = self.crypto_service.crypto_box_seal_open(&my_key, &encrypted_msg)?;
+        let res = self
+            .crypto_service
+            .crypto_box_seal_open(&my_key, &encrypted_msg)?;
 
         debug!(""anonymous_decrypt <<< res: {:?}"", res);
 
         Ok(res)
     }
 
     fn set_key_metadata(&self, wallet_handle: i32, verkey: &str, metadata: &str) -> Result<()> {
-        debug!(""set_key_metadata >>> wallet_handle: {:?}, verkey: {:?}, metadata: {:?}"", wallet_handle, verkey, metadata);
+        debug!(
+            ""set_key_metadata >>> wallet_handle: {:?}, verkey: {:?}, metadata: {:?}"",
+            wallet_handle, verkey, metadata
+        );
 
         self.crypto_service.validate_key(verkey)?;
 
-        let metadata = KeyMetadata {value: metadata.to_string()};
+        let metadata = KeyMetadata {
+            value: metadata.to_string(),
+        };
 
-        self.wallet_service.upsert_indy_object(wallet_handle, &verkey, &metadata)?;
+        self.wallet_service
+            .upsert_indy_object(wallet_handle, &verkey, &metadata)?;
 
         debug!(""set_key_metadata <<<"");
 
         Ok(())
     }
 
-    fn get_key_metadata(&self,
-                        wallet_handle: i32,
-                        verkey: &str) -> Result<String> {
-        debug!(""get_key_metadata >>> wallet_handle: {:?}, verkey: {:?}"", wallet_handle, verkey);
+    fn get_key_metadata(&self, wallet_handle: i32, verkey: &str) -> Result<String> {
+        debug!(
+            ""get_key_metadata >>> wallet_handle: {:?}, verkey: {:?}"",
+            wallet_handle, verkey
+        );
 
         self.crypto_service.validate_key(verkey)?;
 
-        let metadata = self.wallet_service.get_indy_object::<KeyMetadata>(wallet_handle, &verkey, &RecordOptions::id_value())?;
+        let metadata = self.wallet_service.get_indy_object::<KeyMetadata>(
+            wallet_handle,
+            &verkey,
+            &RecordOptions::id_value(),
+        )?;
 
         let res = metadata.value;
 
         debug!(""get_key_metadata <<< res: {:?}"", res);
 
         Ok(res)
     }
+
+    //TODO: Refactor pack to be more modular to version changes or crypto_scheme changes
+    //this match statement is super messy, but the easiest way to comply with current architecture
+    pub fn pack_msg(
+        &self,
+        message: Vec<u8>,
+        receivers: &str,
+        sender_vk: &str,
+        wallet_handle: i32,
+    ) -> Result<Vec<u8>> {
+
+        //parse receivers to structs
+        let receiver_list: Vec<String> = serde_json::from_str(receivers).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to deserialize receiver list of keys {}"",
+                err
+            )))
+        })?;
+
+        //break early and error out if no receivers keys are provided
+        if receiver_list.is_empty() {
+            return Err(IndyError::CommonError(CommonError::InvalidParam4(format!(
+                ""No receiver keys found""
+            ))));
+        }
+        
+        match sender_vk.is_empty() {",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249753987,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249753987,jovfer
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,I suggest to replace `match` by `if` here,194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 12:11:37,249754315,"@@ -209,50 +288,368 @@ impl CryptoCommandExecutor {
         Ok(res)
     }
 
-    fn anonymous_decrypt(&self,
-                         wallet_handle: i32,
-                         my_vk: &str,
-                         encrypted_msg: &[u8]) -> Result<Vec<u8>> {
-        debug!(""anonymous_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, encrypted_msg: {:?}"", wallet_handle, my_vk, encrypted_msg);
+    fn anonymous_decrypt(
+        &self,
+        wallet_handle: i32,
+        my_vk: &str,
+        encrypted_msg: &[u8],
+    ) -> Result<Vec<u8>> {
+        debug!(
+            ""anonymous_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, encrypted_msg: {:?}"",
+            wallet_handle, my_vk, encrypted_msg
+        );
 
         self.crypto_service.validate_key(&my_vk)?;
 
-        let my_key: Key = self.wallet_service.get_indy_object(wallet_handle, &my_vk, &RecordOptions::id_value())?;
+        let my_key: Key = self.wallet_service.get_indy_object(
+            wallet_handle,
+            &my_vk,
+            &RecordOptions::id_value(),
+        )?;
 
-        let res = self.crypto_service.crypto_box_seal_open(&my_key, &encrypted_msg)?;
+        let res = self
+            .crypto_service
+            .crypto_box_seal_open(&my_key, &encrypted_msg)?;
 
         debug!(""anonymous_decrypt <<< res: {:?}"", res);
 
         Ok(res)
     }
 
     fn set_key_metadata(&self, wallet_handle: i32, verkey: &str, metadata: &str) -> Result<()> {
-        debug!(""set_key_metadata >>> wallet_handle: {:?}, verkey: {:?}, metadata: {:?}"", wallet_handle, verkey, metadata);
+        debug!(
+            ""set_key_metadata >>> wallet_handle: {:?}, verkey: {:?}, metadata: {:?}"",
+            wallet_handle, verkey, metadata
+        );
 
         self.crypto_service.validate_key(verkey)?;
 
-        let metadata = KeyMetadata {value: metadata.to_string()};
+        let metadata = KeyMetadata {
+            value: metadata.to_string(),
+        };
 
-        self.wallet_service.upsert_indy_object(wallet_handle, &verkey, &metadata)?;
+        self.wallet_service
+            .upsert_indy_object(wallet_handle, &verkey, &metadata)?;
 
         debug!(""set_key_metadata <<<"");
 
         Ok(())
     }
 
-    fn get_key_metadata(&self,
-                        wallet_handle: i32,
-                        verkey: &str) -> Result<String> {
-        debug!(""get_key_metadata >>> wallet_handle: {:?}, verkey: {:?}"", wallet_handle, verkey);
+    fn get_key_metadata(&self, wallet_handle: i32, verkey: &str) -> Result<String> {
+        debug!(
+            ""get_key_metadata >>> wallet_handle: {:?}, verkey: {:?}"",
+            wallet_handle, verkey
+        );
 
         self.crypto_service.validate_key(verkey)?;
 
-        let metadata = self.wallet_service.get_indy_object::<KeyMetadata>(wallet_handle, &verkey, &RecordOptions::id_value())?;
+        let metadata = self.wallet_service.get_indy_object::<KeyMetadata>(
+            wallet_handle,
+            &verkey,
+            &RecordOptions::id_value(),
+        )?;
 
         let res = metadata.value;
 
         debug!(""get_key_metadata <<< res: {:?}"", res);
 
         Ok(res)
     }
+
+    //TODO: Refactor pack to be more modular to version changes or crypto_scheme changes
+    //this match statement is super messy, but the easiest way to comply with current architecture
+    pub fn pack_msg(
+        &self,
+        message: Vec<u8>,
+        receivers: &str,
+        sender_vk: &str,
+        wallet_handle: i32,
+    ) -> Result<Vec<u8>> {
+
+        //parse receivers to structs
+        let receiver_list: Vec<String> = serde_json::from_str(receivers).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to deserialize receiver list of keys {}"",
+                err
+            )))
+        })?;
+
+        //break early and error out if no receivers keys are provided
+        if receiver_list.is_empty() {
+            return Err(IndyError::CommonError(CommonError::InvalidParam4(format!(
+                ""No receiver keys found""
+            ))));
+        }
+        
+        match sender_vk.is_empty() {
+            true => {
+                //returns anoncrypted pack_message format. See Wire message format HIPE for details
+                self._pack_anoncrypt(message, receiver_list)
+            }
+            false => {
+                //returns authcrypted pack_message format. See Wire message format HIPE for details
+                self._pack_authcrypt(message, receiver_list, sender_vk, wallet_handle)
+            }
+        }
+    }
+
+    fn _pack_anoncrypt(&self, message: Vec<u8>, receiver_list: Vec<String>) -> Result<Vec<u8>> {
+        let mut encrypted_recipients_struct : Vec<Recipient> = vec![];
+
+        let cek = chacha20poly1305_ietf::gen_key();
+
+        for their_vk in receiver_list {
+            //encrypt sender verkey
+            let enc_cek = self.crypto_service.crypto_box_seal(&their_vk, &cek[..])?;
+
+            //create recipient struct and push to encrypted list
+            encrypted_recipients_struct.push(Recipient {
+                encrypted_key: base64::encode(enc_cek.as_slice()),
+                header: Header {
+                    kid: their_vk,
+                    sender: None,
+                    iv: None
+                },
+            });
+        } // end for-loop
+        let base64_protected = self._base64_encode_protected(encrypted_recipients_struct, false)?;
+
+        // encrypt ciphertext and integrity protect ""protected"" field
+        let (ciphertext, iv, tag) =
+            self.crypto_service
+                .encrypt_plaintext(message, &base64_protected, &cek);
+
+
+        self._format_pack_message(&base64_protected, &ciphertext, &iv, &tag)
+    }
+
+    fn _pack_authcrypt(&self, message: Vec<u8>, receiver_list: Vec<String>, sender_vk: &str, wallet_handle: i32) -> Result<Vec<u8>> {
+        let mut encrypted_recipients_struct : Vec<Recipient> = vec![];
+
+        //get my_key from my wallet
+        let my_key = self.wallet_service.get_indy_object(
+            wallet_handle,
+            sender_vk,
+            &RecordOptions::id_value()
+        )?;
+
+        //generate cek
+        let cek = chacha20poly1305_ietf::gen_key();
+
+        //encrypt cek for recipient
+        for their_vk in receiver_list {
+            let (enc_cek, iv) = self.crypto_service.crypto_box(&my_key, &their_vk, &cek[..])?;
+
+            let enc_sender = self.crypto_service.crypto_box_seal(&their_vk, sender_vk.as_bytes())?;
+
+            //create recipient struct and push to encrypted list
+            encrypted_recipients_struct.push(Recipient {
+                encrypted_key: base64::encode(enc_cek.as_slice()),
+                header: Header {
+                    kid: their_vk,
+                    sender: Some(base64::encode(enc_sender.as_slice())),
+                    iv: Some(base64::encode(iv.as_slice()))
+                },
+            });
+        } // end for-loop
+
+        let base64_protected = self._base64_encode_protected(encrypted_recipients_struct, true)?;
+
+        // encrypt ciphertext and integrity protect ""protected"" field
+        let (ciphertext, iv, tag) =
+            self.crypto_service
+                .encrypt_plaintext(message, &base64_protected, &cek);
+
+
+        self._format_pack_message(&base64_protected, &ciphertext, &iv, &tag)
+    }
+
+    fn _base64_encode_protected(&self, encrypted_recipients_struct: Vec<Recipient>, alg_is_authcrypt: bool) -> Result<String> {
+        let alg_val= match alg_is_authcrypt {",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249754315,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249754315,jovfer
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,I suggest to replace this `match` by `if`,194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 12:12:58,249754730,"@@ -209,50 +288,368 @@ impl CryptoCommandExecutor {
         Ok(res)
     }
 
-    fn anonymous_decrypt(&self,
-                         wallet_handle: i32,
-                         my_vk: &str,
-                         encrypted_msg: &[u8]) -> Result<Vec<u8>> {
-        debug!(""anonymous_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, encrypted_msg: {:?}"", wallet_handle, my_vk, encrypted_msg);
+    fn anonymous_decrypt(
+        &self,
+        wallet_handle: i32,
+        my_vk: &str,
+        encrypted_msg: &[u8],
+    ) -> Result<Vec<u8>> {
+        debug!(
+            ""anonymous_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, encrypted_msg: {:?}"",
+            wallet_handle, my_vk, encrypted_msg
+        );
 
         self.crypto_service.validate_key(&my_vk)?;
 
-        let my_key: Key = self.wallet_service.get_indy_object(wallet_handle, &my_vk, &RecordOptions::id_value())?;
+        let my_key: Key = self.wallet_service.get_indy_object(
+            wallet_handle,
+            &my_vk,
+            &RecordOptions::id_value(),
+        )?;
 
-        let res = self.crypto_service.crypto_box_seal_open(&my_key, &encrypted_msg)?;
+        let res = self
+            .crypto_service
+            .crypto_box_seal_open(&my_key, &encrypted_msg)?;
 
         debug!(""anonymous_decrypt <<< res: {:?}"", res);
 
         Ok(res)
     }
 
     fn set_key_metadata(&self, wallet_handle: i32, verkey: &str, metadata: &str) -> Result<()> {
-        debug!(""set_key_metadata >>> wallet_handle: {:?}, verkey: {:?}, metadata: {:?}"", wallet_handle, verkey, metadata);
+        debug!(
+            ""set_key_metadata >>> wallet_handle: {:?}, verkey: {:?}, metadata: {:?}"",
+            wallet_handle, verkey, metadata
+        );
 
         self.crypto_service.validate_key(verkey)?;
 
-        let metadata = KeyMetadata {value: metadata.to_string()};
+        let metadata = KeyMetadata {
+            value: metadata.to_string(),
+        };
 
-        self.wallet_service.upsert_indy_object(wallet_handle, &verkey, &metadata)?;
+        self.wallet_service
+            .upsert_indy_object(wallet_handle, &verkey, &metadata)?;
 
         debug!(""set_key_metadata <<<"");
 
         Ok(())
     }
 
-    fn get_key_metadata(&self,
-                        wallet_handle: i32,
-                        verkey: &str) -> Result<String> {
-        debug!(""get_key_metadata >>> wallet_handle: {:?}, verkey: {:?}"", wallet_handle, verkey);
+    fn get_key_metadata(&self, wallet_handle: i32, verkey: &str) -> Result<String> {
+        debug!(
+            ""get_key_metadata >>> wallet_handle: {:?}, verkey: {:?}"",
+            wallet_handle, verkey
+        );
 
         self.crypto_service.validate_key(verkey)?;
 
-        let metadata = self.wallet_service.get_indy_object::<KeyMetadata>(wallet_handle, &verkey, &RecordOptions::id_value())?;
+        let metadata = self.wallet_service.get_indy_object::<KeyMetadata>(
+            wallet_handle,
+            &verkey,
+            &RecordOptions::id_value(),
+        )?;
 
         let res = metadata.value;
 
         debug!(""get_key_metadata <<< res: {:?}"", res);
 
         Ok(res)
     }
+
+    //TODO: Refactor pack to be more modular to version changes or crypto_scheme changes
+    //this match statement is super messy, but the easiest way to comply with current architecture
+    pub fn pack_msg(
+        &self,
+        message: Vec<u8>,
+        receivers: &str,
+        sender_vk: &str,
+        wallet_handle: i32,
+    ) -> Result<Vec<u8>> {
+
+        //parse receivers to structs
+        let receiver_list: Vec<String> = serde_json::from_str(receivers).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to deserialize receiver list of keys {}"",
+                err
+            )))
+        })?;
+
+        //break early and error out if no receivers keys are provided
+        if receiver_list.is_empty() {
+            return Err(IndyError::CommonError(CommonError::InvalidParam4(format!(
+                ""No receiver keys found""
+            ))));
+        }
+        
+        match sender_vk.is_empty() {
+            true => {
+                //returns anoncrypted pack_message format. See Wire message format HIPE for details
+                self._pack_anoncrypt(message, receiver_list)
+            }
+            false => {
+                //returns authcrypted pack_message format. See Wire message format HIPE for details
+                self._pack_authcrypt(message, receiver_list, sender_vk, wallet_handle)
+            }
+        }
+    }
+
+    fn _pack_anoncrypt(&self, message: Vec<u8>, receiver_list: Vec<String>) -> Result<Vec<u8>> {
+        let mut encrypted_recipients_struct : Vec<Recipient> = vec![];
+
+        let cek = chacha20poly1305_ietf::gen_key();
+
+        for their_vk in receiver_list {
+            //encrypt sender verkey
+            let enc_cek = self.crypto_service.crypto_box_seal(&their_vk, &cek[..])?;
+
+            //create recipient struct and push to encrypted list
+            encrypted_recipients_struct.push(Recipient {
+                encrypted_key: base64::encode(enc_cek.as_slice()),
+                header: Header {
+                    kid: their_vk,
+                    sender: None,
+                    iv: None
+                },
+            });
+        } // end for-loop
+        let base64_protected = self._base64_encode_protected(encrypted_recipients_struct, false)?;
+
+        // encrypt ciphertext and integrity protect ""protected"" field
+        let (ciphertext, iv, tag) =
+            self.crypto_service
+                .encrypt_plaintext(message, &base64_protected, &cek);
+
+
+        self._format_pack_message(&base64_protected, &ciphertext, &iv, &tag)
+    }
+
+    fn _pack_authcrypt(&self, message: Vec<u8>, receiver_list: Vec<String>, sender_vk: &str, wallet_handle: i32) -> Result<Vec<u8>> {
+        let mut encrypted_recipients_struct : Vec<Recipient> = vec![];
+
+        //get my_key from my wallet
+        let my_key = self.wallet_service.get_indy_object(
+            wallet_handle,
+            sender_vk,
+            &RecordOptions::id_value()
+        )?;
+
+        //generate cek
+        let cek = chacha20poly1305_ietf::gen_key();
+
+        //encrypt cek for recipient
+        for their_vk in receiver_list {
+            let (enc_cek, iv) = self.crypto_service.crypto_box(&my_key, &their_vk, &cek[..])?;
+
+            let enc_sender = self.crypto_service.crypto_box_seal(&their_vk, sender_vk.as_bytes())?;
+
+            //create recipient struct and push to encrypted list
+            encrypted_recipients_struct.push(Recipient {
+                encrypted_key: base64::encode(enc_cek.as_slice()),
+                header: Header {
+                    kid: their_vk,
+                    sender: Some(base64::encode(enc_sender.as_slice())),
+                    iv: Some(base64::encode(iv.as_slice()))
+                },
+            });
+        } // end for-loop
+
+        let base64_protected = self._base64_encode_protected(encrypted_recipients_struct, true)?;
+
+        // encrypt ciphertext and integrity protect ""protected"" field
+        let (ciphertext, iv, tag) =
+            self.crypto_service
+                .encrypt_plaintext(message, &base64_protected, &cek);
+
+
+        self._format_pack_message(&base64_protected, &ciphertext, &iv, &tag)
+    }
+
+    fn _base64_encode_protected(&self, encrypted_recipients_struct: Vec<Recipient>, alg_is_authcrypt: bool) -> Result<String> {
+        let alg_val= match alg_is_authcrypt {
+            true => String::from(""Authcrypt""),
+            false => String::from(""Anoncrypt"")
+        };
+
+        //structure protected and base64URL encode it
+        let protected_struct = Protected {
+            enc: ""xchacha20poly1305_ietf"".to_string(),
+            typ: ""JWM/1.0"".to_string(),
+            alg: alg_val,
+            recipients: encrypted_recipients_struct,
+        };
+        let protected_encoded = serde_json::to_string(&protected_struct).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to serialize protected field {}"",
+                err
+            )))
+        })?;
+
+        Ok(base64::encode(protected_encoded.as_bytes()))
+    }
+
+    fn _format_pack_message(
+        &self,
+        base64_protected: &str,
+        ciphertext: &str,
+        iv: &str,
+        tag: &str
+    ) -> Result<Vec<u8>> {
+
+        //serialize pack message and return as vector of bytes
+        let jwe_struct = JWE {
+            protected: base64_protected.to_string(),
+            iv: iv.to_string(),
+            ciphertext: ciphertext.to_string(),
+            tag: tag.to_string()
+        };
+
+        serde_json::to_vec(&jwe_struct).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to serialize JWE {}"",
+                err
+            )))
+        })
+    }
+
+    pub fn unpack_msg(&self, jwe_json: Vec<u8>, wallet_handle: i32) -> Result<Vec<u8>> {
+        //serialize JWE to struct
+        let jwe_struct: JWE = serde_json::from_slice(jwe_json.as_slice()).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to deserialize JWE {}"",
+                err
+            )))
+        })?;
+        //decode protected data
+        let protected_decoded_vec = base64::decode(&jwe_struct.protected)?;
+        let protected_decoded_str = String::from_utf8(protected_decoded_vec).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to utf8 encode data {}"",
+                err
+            )))
+        })?;
+        //convert protected_data_str to struct
+        let protected_struct: Protected = serde_json::from_str(&protected_decoded_str).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to deserialize protected data {}"",
+                err
+            )))
+        })?;
+
+        //extract recipient that matches a key in the wallet
+        let (recipient, is_auth_recipient) = self._find_correct_recipient(protected_struct, wallet_handle)?;
+
+        //get cek and sender data
+        let (sender_verkey_option, cek) =
+            match is_auth_recipient {",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249754730,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249754730,jovfer
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,"I suggest to replace this `match` by something like
`Ok((recipient, recipient.header.sender.is_some()))`",194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 12:14:09,249755103,"@@ -209,50 +288,368 @@ impl CryptoCommandExecutor {
         Ok(res)
     }
 
-    fn anonymous_decrypt(&self,
-                         wallet_handle: i32,
-                         my_vk: &str,
-                         encrypted_msg: &[u8]) -> Result<Vec<u8>> {
-        debug!(""anonymous_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, encrypted_msg: {:?}"", wallet_handle, my_vk, encrypted_msg);
+    fn anonymous_decrypt(
+        &self,
+        wallet_handle: i32,
+        my_vk: &str,
+        encrypted_msg: &[u8],
+    ) -> Result<Vec<u8>> {
+        debug!(
+            ""anonymous_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, encrypted_msg: {:?}"",
+            wallet_handle, my_vk, encrypted_msg
+        );
 
         self.crypto_service.validate_key(&my_vk)?;
 
-        let my_key: Key = self.wallet_service.get_indy_object(wallet_handle, &my_vk, &RecordOptions::id_value())?;
+        let my_key: Key = self.wallet_service.get_indy_object(
+            wallet_handle,
+            &my_vk,
+            &RecordOptions::id_value(),
+        )?;
 
-        let res = self.crypto_service.crypto_box_seal_open(&my_key, &encrypted_msg)?;
+        let res = self
+            .crypto_service
+            .crypto_box_seal_open(&my_key, &encrypted_msg)?;
 
         debug!(""anonymous_decrypt <<< res: {:?}"", res);
 
         Ok(res)
     }
 
     fn set_key_metadata(&self, wallet_handle: i32, verkey: &str, metadata: &str) -> Result<()> {
-        debug!(""set_key_metadata >>> wallet_handle: {:?}, verkey: {:?}, metadata: {:?}"", wallet_handle, verkey, metadata);
+        debug!(
+            ""set_key_metadata >>> wallet_handle: {:?}, verkey: {:?}, metadata: {:?}"",
+            wallet_handle, verkey, metadata
+        );
 
         self.crypto_service.validate_key(verkey)?;
 
-        let metadata = KeyMetadata {value: metadata.to_string()};
+        let metadata = KeyMetadata {
+            value: metadata.to_string(),
+        };
 
-        self.wallet_service.upsert_indy_object(wallet_handle, &verkey, &metadata)?;
+        self.wallet_service
+            .upsert_indy_object(wallet_handle, &verkey, &metadata)?;
 
         debug!(""set_key_metadata <<<"");
 
         Ok(())
     }
 
-    fn get_key_metadata(&self,
-                        wallet_handle: i32,
-                        verkey: &str) -> Result<String> {
-        debug!(""get_key_metadata >>> wallet_handle: {:?}, verkey: {:?}"", wallet_handle, verkey);
+    fn get_key_metadata(&self, wallet_handle: i32, verkey: &str) -> Result<String> {
+        debug!(
+            ""get_key_metadata >>> wallet_handle: {:?}, verkey: {:?}"",
+            wallet_handle, verkey
+        );
 
         self.crypto_service.validate_key(verkey)?;
 
-        let metadata = self.wallet_service.get_indy_object::<KeyMetadata>(wallet_handle, &verkey, &RecordOptions::id_value())?;
+        let metadata = self.wallet_service.get_indy_object::<KeyMetadata>(
+            wallet_handle,
+            &verkey,
+            &RecordOptions::id_value(),
+        )?;
 
         let res = metadata.value;
 
         debug!(""get_key_metadata <<< res: {:?}"", res);
 
         Ok(res)
     }
+
+    //TODO: Refactor pack to be more modular to version changes or crypto_scheme changes
+    //this match statement is super messy, but the easiest way to comply with current architecture
+    pub fn pack_msg(
+        &self,
+        message: Vec<u8>,
+        receivers: &str,
+        sender_vk: &str,
+        wallet_handle: i32,
+    ) -> Result<Vec<u8>> {
+
+        //parse receivers to structs
+        let receiver_list: Vec<String> = serde_json::from_str(receivers).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to deserialize receiver list of keys {}"",
+                err
+            )))
+        })?;
+
+        //break early and error out if no receivers keys are provided
+        if receiver_list.is_empty() {
+            return Err(IndyError::CommonError(CommonError::InvalidParam4(format!(
+                ""No receiver keys found""
+            ))));
+        }
+        
+        match sender_vk.is_empty() {
+            true => {
+                //returns anoncrypted pack_message format. See Wire message format HIPE for details
+                self._pack_anoncrypt(message, receiver_list)
+            }
+            false => {
+                //returns authcrypted pack_message format. See Wire message format HIPE for details
+                self._pack_authcrypt(message, receiver_list, sender_vk, wallet_handle)
+            }
+        }
+    }
+
+    fn _pack_anoncrypt(&self, message: Vec<u8>, receiver_list: Vec<String>) -> Result<Vec<u8>> {
+        let mut encrypted_recipients_struct : Vec<Recipient> = vec![];
+
+        let cek = chacha20poly1305_ietf::gen_key();
+
+        for their_vk in receiver_list {
+            //encrypt sender verkey
+            let enc_cek = self.crypto_service.crypto_box_seal(&their_vk, &cek[..])?;
+
+            //create recipient struct and push to encrypted list
+            encrypted_recipients_struct.push(Recipient {
+                encrypted_key: base64::encode(enc_cek.as_slice()),
+                header: Header {
+                    kid: their_vk,
+                    sender: None,
+                    iv: None
+                },
+            });
+        } // end for-loop
+        let base64_protected = self._base64_encode_protected(encrypted_recipients_struct, false)?;
+
+        // encrypt ciphertext and integrity protect ""protected"" field
+        let (ciphertext, iv, tag) =
+            self.crypto_service
+                .encrypt_plaintext(message, &base64_protected, &cek);
+
+
+        self._format_pack_message(&base64_protected, &ciphertext, &iv, &tag)
+    }
+
+    fn _pack_authcrypt(&self, message: Vec<u8>, receiver_list: Vec<String>, sender_vk: &str, wallet_handle: i32) -> Result<Vec<u8>> {
+        let mut encrypted_recipients_struct : Vec<Recipient> = vec![];
+
+        //get my_key from my wallet
+        let my_key = self.wallet_service.get_indy_object(
+            wallet_handle,
+            sender_vk,
+            &RecordOptions::id_value()
+        )?;
+
+        //generate cek
+        let cek = chacha20poly1305_ietf::gen_key();
+
+        //encrypt cek for recipient
+        for their_vk in receiver_list {
+            let (enc_cek, iv) = self.crypto_service.crypto_box(&my_key, &their_vk, &cek[..])?;
+
+            let enc_sender = self.crypto_service.crypto_box_seal(&their_vk, sender_vk.as_bytes())?;
+
+            //create recipient struct and push to encrypted list
+            encrypted_recipients_struct.push(Recipient {
+                encrypted_key: base64::encode(enc_cek.as_slice()),
+                header: Header {
+                    kid: their_vk,
+                    sender: Some(base64::encode(enc_sender.as_slice())),
+                    iv: Some(base64::encode(iv.as_slice()))
+                },
+            });
+        } // end for-loop
+
+        let base64_protected = self._base64_encode_protected(encrypted_recipients_struct, true)?;
+
+        // encrypt ciphertext and integrity protect ""protected"" field
+        let (ciphertext, iv, tag) =
+            self.crypto_service
+                .encrypt_plaintext(message, &base64_protected, &cek);
+
+
+        self._format_pack_message(&base64_protected, &ciphertext, &iv, &tag)
+    }
+
+    fn _base64_encode_protected(&self, encrypted_recipients_struct: Vec<Recipient>, alg_is_authcrypt: bool) -> Result<String> {
+        let alg_val= match alg_is_authcrypt {
+            true => String::from(""Authcrypt""),
+            false => String::from(""Anoncrypt"")
+        };
+
+        //structure protected and base64URL encode it
+        let protected_struct = Protected {
+            enc: ""xchacha20poly1305_ietf"".to_string(),
+            typ: ""JWM/1.0"".to_string(),
+            alg: alg_val,
+            recipients: encrypted_recipients_struct,
+        };
+        let protected_encoded = serde_json::to_string(&protected_struct).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to serialize protected field {}"",
+                err
+            )))
+        })?;
+
+        Ok(base64::encode(protected_encoded.as_bytes()))
+    }
+
+    fn _format_pack_message(
+        &self,
+        base64_protected: &str,
+        ciphertext: &str,
+        iv: &str,
+        tag: &str
+    ) -> Result<Vec<u8>> {
+
+        //serialize pack message and return as vector of bytes
+        let jwe_struct = JWE {
+            protected: base64_protected.to_string(),
+            iv: iv.to_string(),
+            ciphertext: ciphertext.to_string(),
+            tag: tag.to_string()
+        };
+
+        serde_json::to_vec(&jwe_struct).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to serialize JWE {}"",
+                err
+            )))
+        })
+    }
+
+    pub fn unpack_msg(&self, jwe_json: Vec<u8>, wallet_handle: i32) -> Result<Vec<u8>> {
+        //serialize JWE to struct
+        let jwe_struct: JWE = serde_json::from_slice(jwe_json.as_slice()).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to deserialize JWE {}"",
+                err
+            )))
+        })?;
+        //decode protected data
+        let protected_decoded_vec = base64::decode(&jwe_struct.protected)?;
+        let protected_decoded_str = String::from_utf8(protected_decoded_vec).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to utf8 encode data {}"",
+                err
+            )))
+        })?;
+        //convert protected_data_str to struct
+        let protected_struct: Protected = serde_json::from_str(&protected_decoded_str).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to deserialize protected data {}"",
+                err
+            )))
+        })?;
+
+        //extract recipient that matches a key in the wallet
+        let (recipient, is_auth_recipient) = self._find_correct_recipient(protected_struct, wallet_handle)?;
+
+        //get cek and sender data
+        let (sender_verkey_option, cek) =
+            match is_auth_recipient {
+                true => self._unpack_cek_authcrypt(recipient, wallet_handle),
+                false => self._unpack_cek_anoncrypt(recipient, wallet_handle),
+            }?; //close cek and sender_data match statement
+
+        //decrypt message
+        let message = self.crypto_service.decrypt_ciphertext(
+            &jwe_struct.ciphertext,
+            &jwe_struct.protected,
+            &jwe_struct.iv,
+            &jwe_struct.tag,
+            &cek,
+        )?;
+
+        //serialize and return decrypted message
+        let res = UnpackMessage {
+            message,
+            sender_verkey: sender_verkey_option,
+        };
+
+        return serde_json::to_vec(&res).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to serialize message {}"",
+                err
+            )))
+        });
+    }
+
+    fn _find_correct_recipient(&self, protected_struct: Protected, wallet_handle: i32) -> Result<(Recipient, bool)>{
+        for recipient in protected_struct.recipients {
+            let my_key_res : Result<Key> = self.wallet_service.get_indy_object(
+                wallet_handle,
+                &recipient.header.kid,
+                &RecordOptions::id_value()
+            ).map_err(|err| IndyError::WalletError(err));
+
+
+            if my_key_res.is_ok() {
+                match recipient.header.sender {",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249755103,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249755103,jovfer
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,I suggest to use `null` instead of empty string to switch between modes. ,194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 13:13:40,249773083,"@@ -317,6 +317,123 @@ extern ""C"" {
                                                                       indy_u32_t        decrypted_msg_len)
                                                  );
 
+
+    /// Packs a message
+    ///
+    /// Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
+    /// for specific DID.
+    ///
+    /// #Params
+    /// command_handle: command handle to map callback to user context.
+    /// message: a pointer to the first byte of the message to be packed
+    /// message_len: the length of the message
+    /// receivers: a string in the format of a json list which will contain the list of receiver's keys
+    ///                the message is being encrypted for.
+    ///                Example:
+    ///                ""[<receiver edge_agent_1 verkey>, <receiver edge_agent_2 verkey>]""
+    /// sender: the sender's verkey as a string When """" is used in this parameter, anoncrypt is used",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249773083,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249773083,jovfer
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,"There is another option to split into 2 separate methods but I prefer current approach (determine type by parameter value) instead of old one (`anon/auth_crypt`)

@vimmerru any thoughts? ",194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 13:13:45,249773108,"@@ -317,6 +317,123 @@ extern ""C"" {
                                                                       indy_u32_t        decrypted_msg_len)
                                                  );
 
+
+    /// Packs a message
+    ///
+    /// Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
+    /// for specific DID.
+    ///
+    /// #Params
+    /// command_handle: command handle to map callback to user context.
+    /// message: a pointer to the first byte of the message to be packed
+    /// message_len: the length of the message
+    /// receivers: a string in the format of a json list which will contain the list of receiver's keys
+    ///                the message is being encrypted for.
+    ///                Example:
+    ///                ""[<receiver edge_agent_1 verkey>, <receiver edge_agent_2 verkey>]""
+    /// sender: the sender's verkey as a string When """" is used in this parameter, anoncrypt is used",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249773108,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249773108,jovfer
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,"The consumers of this API (particularly the agent community) do not want a separate API.This is why it's been combined. In the case of using a null pointer rather than an empty string, I don't understand how to implent this.",194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 13:44:15,249783455,"@@ -317,6 +317,123 @@ extern ""C"" {
                                                                       indy_u32_t        decrypted_msg_len)
                                                  );
 
+
+    /// Packs a message
+    ///
+    /// Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
+    /// for specific DID.
+    ///
+    /// #Params
+    /// command_handle: command handle to map callback to user context.
+    /// message: a pointer to the first byte of the message to be packed
+    /// message_len: the length of the message
+    /// receivers: a string in the format of a json list which will contain the list of receiver's keys
+    ///                the message is being encrypted for.
+    ///                Example:
+    ///                ""[<receiver edge_agent_1 verkey>, <receiver edge_agent_2 verkey>]""
+    /// sender: the sender's verkey as a string When """" is used in this parameter, anoncrypt is used",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249783455,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249783455,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,"As far as I know, the only reason this still exists is because this PR is so old that most the changes you've made since I started working on this haven't been brought in.",194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 13:46:22,249784206,"@@ -0,0 +1,19 @@
+extern crate serde;
+extern crate serde_json;
+
+use self::serde::{Serialize, Deserialize};
+use self::serde_json::Error;
+use std::string::String;
+
+
+pub trait JsonEncodable: Serialize + Sized {",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249784206,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249784206,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,"hm, we have some merge into this PR, may be this deletion is missed. Lets come back to this question after final merging latest master to the PR",194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 14:36:35,249804168,"@@ -0,0 +1,19 @@
+extern crate serde;
+extern crate serde_json;
+
+use self::serde::{Serialize, Deserialize};
+use self::serde_json::Error;
+use std::string::String;
+
+
+pub trait JsonEncodable: Serialize + Sized {",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249804168,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249804168,jovfer
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,"Fixed this, need to test this works with wrappers, but given we're doing it in other modules I assume it should be fine.",194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 17:11:27,249877026,"@@ -317,6 +317,123 @@ extern ""C"" {
                                                                       indy_u32_t        decrypted_msg_len)
                                                  );
 
+
+    /// Packs a message
+    ///
+    /// Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
+    /// for specific DID.
+    ///
+    /// #Params
+    /// command_handle: command handle to map callback to user context.
+    /// message: a pointer to the first byte of the message to be packed
+    /// message_len: the length of the message
+    /// receivers: a string in the format of a json list which will contain the list of receiver's keys
+    ///                the message is being encrypted for.
+    ///                Example:
+    ///                ""[<receiver edge_agent_1 verkey>, <receiver edge_agent_2 verkey>]""
+    /// sender: the sender's verkey as a string When """" is used in this parameter, anoncrypt is used",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249877026,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249877026,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,added this suggestion,194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 17:13:35,249877867,"@@ -209,50 +288,368 @@ impl CryptoCommandExecutor {
         Ok(res)
     }
 
-    fn anonymous_decrypt(&self,
-                         wallet_handle: i32,
-                         my_vk: &str,
-                         encrypted_msg: &[u8]) -> Result<Vec<u8>> {
-        debug!(""anonymous_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, encrypted_msg: {:?}"", wallet_handle, my_vk, encrypted_msg);
+    fn anonymous_decrypt(
+        &self,
+        wallet_handle: i32,
+        my_vk: &str,
+        encrypted_msg: &[u8],
+    ) -> Result<Vec<u8>> {
+        debug!(
+            ""anonymous_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, encrypted_msg: {:?}"",
+            wallet_handle, my_vk, encrypted_msg
+        );
 
         self.crypto_service.validate_key(&my_vk)?;
 
-        let my_key: Key = self.wallet_service.get_indy_object(wallet_handle, &my_vk, &RecordOptions::id_value())?;
+        let my_key: Key = self.wallet_service.get_indy_object(
+            wallet_handle,
+            &my_vk,
+            &RecordOptions::id_value(),
+        )?;
 
-        let res = self.crypto_service.crypto_box_seal_open(&my_key, &encrypted_msg)?;
+        let res = self
+            .crypto_service
+            .crypto_box_seal_open(&my_key, &encrypted_msg)?;
 
         debug!(""anonymous_decrypt <<< res: {:?}"", res);
 
         Ok(res)
     }
 
     fn set_key_metadata(&self, wallet_handle: i32, verkey: &str, metadata: &str) -> Result<()> {
-        debug!(""set_key_metadata >>> wallet_handle: {:?}, verkey: {:?}, metadata: {:?}"", wallet_handle, verkey, metadata);
+        debug!(
+            ""set_key_metadata >>> wallet_handle: {:?}, verkey: {:?}, metadata: {:?}"",
+            wallet_handle, verkey, metadata
+        );
 
         self.crypto_service.validate_key(verkey)?;
 
-        let metadata = KeyMetadata {value: metadata.to_string()};
+        let metadata = KeyMetadata {
+            value: metadata.to_string(),
+        };
 
-        self.wallet_service.upsert_indy_object(wallet_handle, &verkey, &metadata)?;
+        self.wallet_service
+            .upsert_indy_object(wallet_handle, &verkey, &metadata)?;
 
         debug!(""set_key_metadata <<<"");
 
         Ok(())
     }
 
-    fn get_key_metadata(&self,
-                        wallet_handle: i32,
-                        verkey: &str) -> Result<String> {
-        debug!(""get_key_metadata >>> wallet_handle: {:?}, verkey: {:?}"", wallet_handle, verkey);
+    fn get_key_metadata(&self, wallet_handle: i32, verkey: &str) -> Result<String> {
+        debug!(
+            ""get_key_metadata >>> wallet_handle: {:?}, verkey: {:?}"",
+            wallet_handle, verkey
+        );
 
         self.crypto_service.validate_key(verkey)?;
 
-        let metadata = self.wallet_service.get_indy_object::<KeyMetadata>(wallet_handle, &verkey, &RecordOptions::id_value())?;
+        let metadata = self.wallet_service.get_indy_object::<KeyMetadata>(
+            wallet_handle,
+            &verkey,
+            &RecordOptions::id_value(),
+        )?;
 
         let res = metadata.value;
 
         debug!(""get_key_metadata <<< res: {:?}"", res);
 
         Ok(res)
     }
+
+    //TODO: Refactor pack to be more modular to version changes or crypto_scheme changes
+    //this match statement is super messy, but the easiest way to comply with current architecture
+    pub fn pack_msg(
+        &self,
+        message: Vec<u8>,
+        receivers: &str,
+        sender_vk: &str,
+        wallet_handle: i32,
+    ) -> Result<Vec<u8>> {
+
+        //parse receivers to structs
+        let receiver_list: Vec<String> = serde_json::from_str(receivers).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to deserialize receiver list of keys {}"",
+                err
+            )))
+        })?;
+
+        //break early and error out if no receivers keys are provided
+        if receiver_list.is_empty() {
+            return Err(IndyError::CommonError(CommonError::InvalidParam4(format!(
+                ""No receiver keys found""
+            ))));
+        }
+        
+        match sender_vk.is_empty() {
+            true => {
+                //returns anoncrypted pack_message format. See Wire message format HIPE for details
+                self._pack_anoncrypt(message, receiver_list)
+            }
+            false => {
+                //returns authcrypted pack_message format. See Wire message format HIPE for details
+                self._pack_authcrypt(message, receiver_list, sender_vk, wallet_handle)
+            }
+        }
+    }
+
+    fn _pack_anoncrypt(&self, message: Vec<u8>, receiver_list: Vec<String>) -> Result<Vec<u8>> {
+        let mut encrypted_recipients_struct : Vec<Recipient> = vec![];
+
+        let cek = chacha20poly1305_ietf::gen_key();
+
+        for their_vk in receiver_list {
+            //encrypt sender verkey
+            let enc_cek = self.crypto_service.crypto_box_seal(&their_vk, &cek[..])?;
+
+            //create recipient struct and push to encrypted list
+            encrypted_recipients_struct.push(Recipient {
+                encrypted_key: base64::encode(enc_cek.as_slice()),
+                header: Header {
+                    kid: their_vk,
+                    sender: None,
+                    iv: None
+                },
+            });
+        } // end for-loop
+        let base64_protected = self._base64_encode_protected(encrypted_recipients_struct, false)?;
+
+        // encrypt ciphertext and integrity protect ""protected"" field
+        let (ciphertext, iv, tag) =
+            self.crypto_service
+                .encrypt_plaintext(message, &base64_protected, &cek);
+
+
+        self._format_pack_message(&base64_protected, &ciphertext, &iv, &tag)
+    }
+
+    fn _pack_authcrypt(&self, message: Vec<u8>, receiver_list: Vec<String>, sender_vk: &str, wallet_handle: i32) -> Result<Vec<u8>> {
+        let mut encrypted_recipients_struct : Vec<Recipient> = vec![];
+
+        //get my_key from my wallet
+        let my_key = self.wallet_service.get_indy_object(
+            wallet_handle,
+            sender_vk,
+            &RecordOptions::id_value()
+        )?;
+
+        //generate cek
+        let cek = chacha20poly1305_ietf::gen_key();
+
+        //encrypt cek for recipient
+        for their_vk in receiver_list {
+            let (enc_cek, iv) = self.crypto_service.crypto_box(&my_key, &their_vk, &cek[..])?;
+
+            let enc_sender = self.crypto_service.crypto_box_seal(&their_vk, sender_vk.as_bytes())?;
+
+            //create recipient struct and push to encrypted list
+            encrypted_recipients_struct.push(Recipient {
+                encrypted_key: base64::encode(enc_cek.as_slice()),
+                header: Header {
+                    kid: their_vk,
+                    sender: Some(base64::encode(enc_sender.as_slice())),
+                    iv: Some(base64::encode(iv.as_slice()))
+                },
+            });
+        } // end for-loop
+
+        let base64_protected = self._base64_encode_protected(encrypted_recipients_struct, true)?;
+
+        // encrypt ciphertext and integrity protect ""protected"" field
+        let (ciphertext, iv, tag) =
+            self.crypto_service
+                .encrypt_plaintext(message, &base64_protected, &cek);
+
+
+        self._format_pack_message(&base64_protected, &ciphertext, &iv, &tag)
+    }
+
+    fn _base64_encode_protected(&self, encrypted_recipients_struct: Vec<Recipient>, alg_is_authcrypt: bool) -> Result<String> {
+        let alg_val= match alg_is_authcrypt {
+            true => String::from(""Authcrypt""),
+            false => String::from(""Anoncrypt"")
+        };
+
+        //structure protected and base64URL encode it
+        let protected_struct = Protected {
+            enc: ""xchacha20poly1305_ietf"".to_string(),
+            typ: ""JWM/1.0"".to_string(),
+            alg: alg_val,
+            recipients: encrypted_recipients_struct,
+        };
+        let protected_encoded = serde_json::to_string(&protected_struct).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to serialize protected field {}"",
+                err
+            )))
+        })?;
+
+        Ok(base64::encode(protected_encoded.as_bytes()))
+    }
+
+    fn _format_pack_message(
+        &self,
+        base64_protected: &str,
+        ciphertext: &str,
+        iv: &str,
+        tag: &str
+    ) -> Result<Vec<u8>> {
+
+        //serialize pack message and return as vector of bytes
+        let jwe_struct = JWE {
+            protected: base64_protected.to_string(),
+            iv: iv.to_string(),
+            ciphertext: ciphertext.to_string(),
+            tag: tag.to_string()
+        };
+
+        serde_json::to_vec(&jwe_struct).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to serialize JWE {}"",
+                err
+            )))
+        })
+    }
+
+    pub fn unpack_msg(&self, jwe_json: Vec<u8>, wallet_handle: i32) -> Result<Vec<u8>> {
+        //serialize JWE to struct
+        let jwe_struct: JWE = serde_json::from_slice(jwe_json.as_slice()).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to deserialize JWE {}"",
+                err
+            )))
+        })?;
+        //decode protected data
+        let protected_decoded_vec = base64::decode(&jwe_struct.protected)?;
+        let protected_decoded_str = String::from_utf8(protected_decoded_vec).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to utf8 encode data {}"",
+                err
+            )))
+        })?;
+        //convert protected_data_str to struct
+        let protected_struct: Protected = serde_json::from_str(&protected_decoded_str).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to deserialize protected data {}"",
+                err
+            )))
+        })?;
+
+        //extract recipient that matches a key in the wallet
+        let (recipient, is_auth_recipient) = self._find_correct_recipient(protected_struct, wallet_handle)?;
+
+        //get cek and sender data
+        let (sender_verkey_option, cek) =
+            match is_auth_recipient {
+                true => self._unpack_cek_authcrypt(recipient, wallet_handle),
+                false => self._unpack_cek_anoncrypt(recipient, wallet_handle),
+            }?; //close cek and sender_data match statement
+
+        //decrypt message
+        let message = self.crypto_service.decrypt_ciphertext(
+            &jwe_struct.ciphertext,
+            &jwe_struct.protected,
+            &jwe_struct.iv,
+            &jwe_struct.tag,
+            &cek,
+        )?;
+
+        //serialize and return decrypted message
+        let res = UnpackMessage {
+            message,
+            sender_verkey: sender_verkey_option,
+        };
+
+        return serde_json::to_vec(&res).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to serialize message {}"",
+                err
+            )))
+        });
+    }
+
+    fn _find_correct_recipient(&self, protected_struct: Protected, wallet_handle: i32) -> Result<(Recipient, bool)>{
+        for recipient in protected_struct.recipients {
+            let my_key_res : Result<Key> = self.wallet_service.get_indy_object(
+                wallet_handle,
+                &recipient.header.kid,
+                &RecordOptions::id_value()
+            ).map_err(|err| IndyError::WalletError(err));
+
+
+            if my_key_res.is_ok() {
+                match recipient.header.sender {",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249877867,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249877867,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,Kept this as a match because the api now uses opt_c_str!() macro,194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 17:15:43,249878694,"@@ -209,50 +288,368 @@ impl CryptoCommandExecutor {
         Ok(res)
     }
 
-    fn anonymous_decrypt(&self,
-                         wallet_handle: i32,
-                         my_vk: &str,
-                         encrypted_msg: &[u8]) -> Result<Vec<u8>> {
-        debug!(""anonymous_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, encrypted_msg: {:?}"", wallet_handle, my_vk, encrypted_msg);
+    fn anonymous_decrypt(
+        &self,
+        wallet_handle: i32,
+        my_vk: &str,
+        encrypted_msg: &[u8],
+    ) -> Result<Vec<u8>> {
+        debug!(
+            ""anonymous_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, encrypted_msg: {:?}"",
+            wallet_handle, my_vk, encrypted_msg
+        );
 
         self.crypto_service.validate_key(&my_vk)?;
 
-        let my_key: Key = self.wallet_service.get_indy_object(wallet_handle, &my_vk, &RecordOptions::id_value())?;
+        let my_key: Key = self.wallet_service.get_indy_object(
+            wallet_handle,
+            &my_vk,
+            &RecordOptions::id_value(),
+        )?;
 
-        let res = self.crypto_service.crypto_box_seal_open(&my_key, &encrypted_msg)?;
+        let res = self
+            .crypto_service
+            .crypto_box_seal_open(&my_key, &encrypted_msg)?;
 
         debug!(""anonymous_decrypt <<< res: {:?}"", res);
 
         Ok(res)
     }
 
     fn set_key_metadata(&self, wallet_handle: i32, verkey: &str, metadata: &str) -> Result<()> {
-        debug!(""set_key_metadata >>> wallet_handle: {:?}, verkey: {:?}, metadata: {:?}"", wallet_handle, verkey, metadata);
+        debug!(
+            ""set_key_metadata >>> wallet_handle: {:?}, verkey: {:?}, metadata: {:?}"",
+            wallet_handle, verkey, metadata
+        );
 
         self.crypto_service.validate_key(verkey)?;
 
-        let metadata = KeyMetadata {value: metadata.to_string()};
+        let metadata = KeyMetadata {
+            value: metadata.to_string(),
+        };
 
-        self.wallet_service.upsert_indy_object(wallet_handle, &verkey, &metadata)?;
+        self.wallet_service
+            .upsert_indy_object(wallet_handle, &verkey, &metadata)?;
 
         debug!(""set_key_metadata <<<"");
 
         Ok(())
     }
 
-    fn get_key_metadata(&self,
-                        wallet_handle: i32,
-                        verkey: &str) -> Result<String> {
-        debug!(""get_key_metadata >>> wallet_handle: {:?}, verkey: {:?}"", wallet_handle, verkey);
+    fn get_key_metadata(&self, wallet_handle: i32, verkey: &str) -> Result<String> {
+        debug!(
+            ""get_key_metadata >>> wallet_handle: {:?}, verkey: {:?}"",
+            wallet_handle, verkey
+        );
 
         self.crypto_service.validate_key(verkey)?;
 
-        let metadata = self.wallet_service.get_indy_object::<KeyMetadata>(wallet_handle, &verkey, &RecordOptions::id_value())?;
+        let metadata = self.wallet_service.get_indy_object::<KeyMetadata>(
+            wallet_handle,
+            &verkey,
+            &RecordOptions::id_value(),
+        )?;
 
         let res = metadata.value;
 
         debug!(""get_key_metadata <<< res: {:?}"", res);
 
         Ok(res)
     }
+
+    //TODO: Refactor pack to be more modular to version changes or crypto_scheme changes
+    //this match statement is super messy, but the easiest way to comply with current architecture
+    pub fn pack_msg(
+        &self,
+        message: Vec<u8>,
+        receivers: &str,
+        sender_vk: &str,
+        wallet_handle: i32,
+    ) -> Result<Vec<u8>> {
+
+        //parse receivers to structs
+        let receiver_list: Vec<String> = serde_json::from_str(receivers).map_err(|err| {
+            IndyError::CommonError(CommonError::InvalidStructure(format!(
+                ""Failed to deserialize receiver list of keys {}"",
+                err
+            )))
+        })?;
+
+        //break early and error out if no receivers keys are provided
+        if receiver_list.is_empty() {
+            return Err(IndyError::CommonError(CommonError::InvalidParam4(format!(
+                ""No receiver keys found""
+            ))));
+        }
+        
+        match sender_vk.is_empty() {",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249878694,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249878694,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,fixed this by adding `encode_urlsafe()` and `decode_urlsafe()` functions and bringing the old implementations back.,194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 17:19:41,249880170,"@@ -3,11 +3,11 @@ extern crate base64;
 use errors::common::CommonError;
 
 pub fn encode(doc: &[u8]) -> String {
-    base64::encode(doc)
+    base64::encode_config(doc, base64::URL_SAFE)",5,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249880170,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249880170,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,"I've added experimental to this so that consumers know that it's experimental. From our discussion earlier though because this is only using keys and key referencing is being handled at a different layer, I don't think this will cause problems.",194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 17:32:23,249885017,"@@ -557,4 +561,190 @@ pub  extern fn indy_crypto_anon_decrypt(command_handle: IndyHandle,
     trace!(""indy_crypto_anon_decrypt: <<< res: {:?}"", res);
 
     res
-}
\ No newline at end of file
+}
+
+/// Packs a message
+///
+/// Note to use DID keys with this function you can call indy_key_for_did to get key id (verkey)
+/// for specific DID.
+///
+/// #Params
+/// command_handle: command handle to map callback to user context.
+/// message: a pointer to the first byte of the message to be packed
+/// message_len: the length of the message
+/// receivers: a string in the format of a json list which will contain the list of receiver's keys
+///                the message is being encrypted for.
+///                Example:
+///                ""[<receiver edge_agent_1 verkey>, <receiver edge_agent_2 verkey>]""
+/// sender: the sender's verkey as a string When """" is used in this parameter, anoncrypt is used
+/// cb: Callback that takes command result as parameter.
+///
+/// #Returns
+/// a JWE using authcrypt alg is defined below:
+/// {
+///    ""protected"": ""b64URLencoded({
+///        ""enc"": ""xsalsa20poly1305"",
+///        ""typ"": ""JWM/1.0"",
+///        ""alg"": ""authcrypt"",
+///        ""recipients"": [
+///            {
+///                ""encrypted_key"": anoncrypt(encrypted_cek|sender_vk|nonce)
+///                ""header"": {
+///                    ""kid"": ""b64URLencode(ver_key)""
+///                }
+///            },
+///        ],
+///    })""
+///    ""iv"": <b64URLencode()>,
+///    ""ciphertext"": <b64URLencode(encrypt({'@type'...}, cek)>,
+///    ""tag"": <b64URLencode()>
+/// }
+///
+/// Alternative example in using anoncrypt alg is defined below:
+/// {
+///    ""protected"": ""b64URLencode({
+///        ""enc"": ""xsalsa20poly1305"",
+///        ""typ"": ""JWM/1.0"",
+///        ""alg"": ""anoncrypt"",
+///        ""recipients"": [
+///            {
+///                ""encrypted_key"": <b64URLencode(anoncrypt(cek))>,
+///                ""header"": {
+///                    ""kid"": ""b64URLencode(ver_key)""
+///                }
+///            },
+///        ],
+///    })""
+///    ""iv"": <b64URLencode(iv)>,
+///    ""ciphertext"": <b64URLencode(encrypt({'@type'...}, cek)>,
+///    ""tag"": <b64URLencode(authentication tag)>
+/// }
+///
+///
+/// #Errors
+/// Common*
+/// Wallet*
+/// Ledger*
+/// Crypto*
+#[no_mangle]
+pub extern fn indy_pack_message(
+    command_handle: IndyHandle,
+    wallet_handle: IndyHandle,
+    message: *const u8,
+    message_len: u32,
+    receiver_keys: *const c_char,
+    sender: *const c_char,
+    cb: Option<extern ""C"" fn(xcommand_handle: i32, err: ErrorCode, jwe_data: *const u8, jwe_len: u32)>,
+) -> ErrorCode {
+    trace!(""indy_pack_message: >>> wallet_handle: {:?}, message: {:?}, message_len {:?},\
+            receiver_keys: {:?}, sender: {:?}"", wallet_handle, message, message_len, receiver_keys, sender);
+
+    check_useful_c_byte_array!(message, message_len, ErrorCode::CommonInvalidParam2, ErrorCode::CommonInvalidParam3);
+    check_useful_c_str!(receiver_keys, ErrorCode::CommonInvalidParam4);
+    check_useful_c_str_empty_accepted!(sender, ErrorCode::CommonInvalidParam5);
+    check_useful_c_callback!(cb, ErrorCode::CommonInvalidParam6);
+
+    trace!(""indy_pack_message: entities >>> wallet_handle: {:?}, message: {:?}, message_len {:?},\
+            receiver_keys: {:?}, sender: {:?}"", wallet_handle, message, message_len, receiver_keys, sender);
+
+    let result = CommandExecutor::instance().send(Command::Crypto(CryptoCommand::PackMessage(
+        message,
+        receiver_keys,
+        sender,
+        wallet_handle,
+        Box::new(move |result| {
+            let (err, jwe) = result_to_err_code_1!(result, Vec::new());
+            trace!(""indy_auth_pack_message: jwe: {:?}"", jwe);
+            let (jwe_data, jwe_len) = ctypes::vec_to_pointer(&jwe);
+            cb(command_handle, err, jwe_data, jwe_len)
+        }),
+    )));
+
+    let res = result_to_err_code!(result);
+
+    trace!(""indy_auth_pack_message: <<< res: {:?}"", res);
+
+    res
+}
+
+
+/// Unpacks a message packed using indy_pack_message which follows the wire message format",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249885017,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249885017,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1210,https://github.com/hyperledger/indy-sdk/pull/1210,I was able to remove this without any problems. All my tests are still passing and I haven't seen any new ones fail either.,194a4ee20d72c07457cd46364e6fa468a7c2c504,2019-01-22 17:33:11,249885329,"@@ -0,0 +1,19 @@
+extern crate serde;
+extern crate serde_json;
+
+use self::serde::{Serialize, Deserialize};
+use self::serde_json::Error;
+use std::string::String;
+
+
+pub trait JsonEncodable: Serialize + Sized {",,2019-01-24 15:16:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/249885329,https://github.com/hyperledger/indy-sdk/pull/1210#discussion_r249885329,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1208,https://github.com/hyperledger/indy-sdk/pull/1208,@dkulic please add new error code to `libindy/includes/`,162f21e8efa1d6d9b2781994bb3b34b4568386f1,2018-10-11 11:12:56,224407568,"@@ -185,6 +185,9 @@ pub enum ErrorCode
     // Call pool.indy_set_protocol_version to set correct Protocol version.
     PoolIncompatibleProtocolVersion = 308,
 
+    // Item not found on ledger.",4,2018-10-19 11:52:02,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/224407568,https://github.com/hyperledger/indy-sdk/pull/1208#discussion_r224407568,jovfer
https://github.com/hyperledger/indy-sdk/pull/1208,https://github.com/hyperledger/indy-sdk/pull/1208,Will do.,162f21e8efa1d6d9b2781994bb3b34b4568386f1,2018-10-11 11:46:26,224416005,"@@ -185,6 +185,9 @@ pub enum ErrorCode
     // Call pool.indy_set_protocol_version to set correct Protocol version.
     PoolIncompatibleProtocolVersion = 308,
 
+    // Item not found on ledger.",4,2018-10-19 11:52:02,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/224416005,https://github.com/hyperledger/indy-sdk/pull/1208#discussion_r224416005,dkulic
https://github.com/hyperledger/indy-sdk/pull/1208,https://github.com/hyperledger/indy-sdk/pull/1208,@dkulic at least this line can not be compiled,162f21e8efa1d6d9b2781994bb3b34b4568386f1,2018-10-19 11:36:50,226616668,"@@ -1891,6 +1891,35 @@ mod medium_cases {
             let get_schema_response = ledger::submit_request(pool_handle, &get_schema_request).unwrap();
 
             let res = ledger::parse_get_schema_response(&get_schema_response);
+            assert_eq!(res.unwrap_err(), ErrorCode::LedgerNotFound);
+
+            utils::tear_down_with_wallet_and_pool(wallet_handle, pool_handle);
+        }
+
+        #[test]
+        #[cfg(feature = ""local_nodes_pool"")]
+        fn indy_get_parse_returns_error_for_wrong_type() {
+            let (wallet_handle, pool_handle) = utils::setup_with_wallet_and_pool();
+
+            let (schema_id, _, _) = ledger::post_entities();
+
+            let get_schema_request = ledger::build_get_schema_request(Some(DID_MY1), &schema_id).unwrap();
+            let get_schema_response = ledger::submit_request(pool_handle, &get_schema_request).unwrap();
+
+            let res = ledger::parse_get_cred_def_response(&get_schema_response);
+            assert_eq!(res.unwrap_err(), ErrorCode::LedgerInvalidTransaction);
+
+            utils::tear_down_with_wallet_and_pool(wallet_handle, pool_handle);
+        }
+
+        #[test]
+        #[cfg(feature = ""local_nodes_pool"")]
+        fn indy_get_parse_returns_error_for_wrong_type_and_unknown_schema() {
+            let (wallet_handle, pool_handle) = utils::setup_with_wallet_and_pool();
+
+git c            let get_schema_response = ledger::submit_request(pool_handle, &get_schema_request).unwrap();",,2018-10-19 11:52:02,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/226616668,https://github.com/hyperledger/indy-sdk/pull/1208#discussion_r226616668,jovfer
https://github.com/hyperledger/indy-sdk/pull/1201,https://github.com/hyperledger/indy-sdk/pull/1201,Should it be `com.evernym.vcx*` ?,57566c826ae8a383d95b574a2adb32dde203cc52,2018-10-11 16:20:02,224514031,"@@ -1,17 +1,18 @@
 #!/usr/bin/env bash
 
 set -e
-JAR_FOLDER=vcx/wrappers/java/artifacts/jar
-JAR_VERSION=$(find ${JAR_FOLDER} -type f -name 'com.evernym-vcx_*.jar'| perl -nle 'print $& if m{(?<=vcx_)(.*)(?=.jar)}' | head -1 | awk '{print $1}')
+JAR_FOLDER=artifacts/jar
+JAR_VERSION=$(find ${JAR_FOLDER} -type f -name 'com.evernym-vcx-*.jar'| perl -nle 'print $& if m{(?<=vcx-)(.*)(?=.jar)}' | head -1 | awk '{print $1}')",7,2018-11-07 11:05:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/224514031,https://github.com/hyperledger/indy-sdk/pull/1201#discussion_r224514031,jovfer
https://github.com/hyperledger/indy-sdk/pull/1201,https://github.com/hyperledger/indy-sdk/pull/1201,I decided to leave the same package name,57566c826ae8a383d95b574a2adb32dde203cc52,2018-10-12 05:04:07,224671468,"@@ -1,17 +1,18 @@
 #!/usr/bin/env bash
 
 set -e
-JAR_FOLDER=vcx/wrappers/java/artifacts/jar
-JAR_VERSION=$(find ${JAR_FOLDER} -type f -name 'com.evernym-vcx_*.jar'| perl -nle 'print $& if m{(?<=vcx_)(.*)(?=.jar)}' | head -1 | awk '{print $1}')
+JAR_FOLDER=artifacts/jar
+JAR_VERSION=$(find ${JAR_FOLDER} -type f -name 'com.evernym-vcx-*.jar'| perl -nle 'print $& if m{(?<=vcx-)(.*)(?=.jar)}' | head -1 | awk '{print $1}')",7,2018-11-07 11:05:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/224671468,https://github.com/hyperledger/indy-sdk/pull/1201#discussion_r224671468,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1201,https://github.com/hyperledger/indy-sdk/pull/1201,for RedHat case: will this stash be dropped automatically at the end of the whole job?,57566c826ae8a383d95b574a2adb32dde203cc52,2018-11-07 13:27:43,231502314,"@@ -285,6 +292,7 @@ def linuxLibindyBuild(file, env_name, network_name, stashBuildResults) {
         stash includes: 'cli/libnullpay.so', name: ""LibnullpayCliSO${env_name}""
         stash includes: 'vcx/libvcx/libindy.so,vcx/libvcx/libnullpay.so', name: ""VCXLibindyAndLibnullpaySO${env_name}""
         stash includes: 'vcx/wrappers/node/libindy.so,vcx/wrappers/node/libnullpay.so', name: ""VcxNodeLibindyAndLibnullpaySO${env_name}""
+        stash includes: 'vcx/wrappers/java/libindy.so,vcx/wrappers/java/libnullpay.so', name: ""VcxJavaLibindyAndLibnullpaySO${env_name}""",32,2018-11-07 13:27:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/231502314,https://github.com/hyperledger/indy-sdk/pull/1201#discussion_r231502314,jovfer
https://github.com/hyperledger/indy-sdk/pull/1200,https://github.com/hyperledger/indy-sdk/pull/1200,"please try ""debug"" level and return back backtrace",3a0d2ada40ac1319ccf95fef98dd30797465cddf,2018-11-07 09:32:30,231434245,"@@ -37,7 +37,7 @@
         ""compile"": ""./node_modules/.bin/tsc -p ./tsconfig.json"",
         ""lint"": ""./node_modules/.bin/tslint --type-check -c ./tslint.json -p ./tsconfig.json && ./node_modules/.bin/tslint --type-check -c ./test/tslint.json -p ./test/tsconfig.json"",
         ""doc-gen"": ""./node_modules/.bin/typedoc --out doc --excludePrivate --excludeProtected --ignoreCompilerErrors src"",
-        ""test"": ""export TS_NODE_PROJECT=\""./test/tsconfig.json\"" export NODE_ENV='test' && export RUST_LOG=\""trace\"" && export RUST_BACKTRACE=full && ./node_modules/.bin/mocha --timeout 10000 -gc --expose-gc --exit --recursive --use_strict --require ts-node/register ./test/suite1/**/*.test.ts && ./node_modules/.bin/mocha --timeout 10000 -gc --expose-gc --exit --recursive --use_strict --require ts-node/register ./test/suite2/**/*.test.ts""
+        ""test"": ""export TS_NODE_PROJECT=\""./test/tsconfig.json\"" export NODE_ENV='test' && export && ./node_modules/.bin/mocha --timeout 10000 -gc --expose-gc --exit --recursive --use_strict --require ts-node/register ./test/suite1/**/*.test.ts && ./node_modules/.bin/mocha --timeout 10000 -gc --expose-gc --exit --recursive --use_strict --require ts-node/register ./test/suite2/**/*.test.ts""",,2018-11-07 09:34:30,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/231434245,https://github.com/hyperledger/indy-sdk/pull/1200#discussion_r231434245,jovfer
https://github.com/hyperledger/indy-sdk/pull/1182,https://github.com/hyperledger/indy-sdk/pull/1182,"* Add notes about experimental status of rust wrapper here
* look at original readme of rust wrapper to find more details and include it here",aa63d8b46afbc7e569e92c6ed4dbb6ea4813f702,2018-10-04 17:17:33,222756322,"@@ -0,0 +1,32 @@
+# indy",1,2018-10-05 13:19:55,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/222756322,https://github.com/hyperledger/indy-sdk/pull/1182#discussion_r222756322,jovfer
https://github.com/hyperledger/indy-sdk/pull/1181,https://github.com/hyperledger/indy-sdk/pull/1181,In my understanding at this moment `Copy` will occurs for `hasher`. As result code in current PR is equivalent to original.,c12de73de23a1f6785cece39caf5a1f176fffd91,2018-10-04 11:23:24,222629245,"@@ -77,10 +77,10 @@ pub fn store_tails_from_generator(service: Rc<BlobStorageService>,
                                   rtg: &mut RevocationTailsGenerator) -> Result<(String, String), CommonError> {
     debug!(""store_tails_from_generator >>> writer_handle: {:?}"",writer_handle);
 
-    let blob_handle = service.create_blob(writer_handle)?;
-
     let mut hasher = sha2::Sha256::default();
 
+    let blob_handle = service.create_blob(writer_handle, hasher)?;",,2018-10-04 13:11:46,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/222629245,https://github.com/hyperledger/indy-sdk/pull/1181#discussion_r222629245,jovfer
https://github.com/hyperledger/indy-sdk/pull/1181,https://github.com/hyperledger/indy-sdk/pull/1181,"it turns out that the hasher in tails.rs is superfluous and just a waste of time. 
New PR to follow soon",c12de73de23a1f6785cece39caf5a1f176fffd91,2018-10-04 11:49:02,222635559,"@@ -77,10 +77,10 @@ pub fn store_tails_from_generator(service: Rc<BlobStorageService>,
                                   rtg: &mut RevocationTailsGenerator) -> Result<(String, String), CommonError> {
     debug!(""store_tails_from_generator >>> writer_handle: {:?}"",writer_handle);
 
-    let blob_handle = service.create_blob(writer_handle)?;
-
     let mut hasher = sha2::Sha256::default();
 
+    let blob_handle = service.create_blob(writer_handle, hasher)?;",,2018-10-04 13:11:46,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/222635559,https://github.com/hyperledger/indy-sdk/pull/1181#discussion_r222635559,AxelNennker
https://github.com/hyperledger/indy-sdk/pull/1179,https://github.com/hyperledger/indy-sdk/pull/1179,"It should be 

```
if seed.as_bytes().len() == ed25519_sign::SEEDBYTES * 2
```",84e6db8520fc8ca2b864a7978a69d1d9aea3a657,2018-10-04 12:57:06,222656832,"@@ -348,22 +351,33 @@ impl CryptoService {
     pub fn convert_seed(&self, seed: Option<&str>) -> Result<Option<ed25519_sign::Seed>, CryptoError> {
         trace!(""convert_seed >>> seed: {:?}"", seed);
 
-        let res = match seed {
-            Some(ref seed) => {
-                let seed = if seed.ends_with('=') {
-                    base64::decode(&seed)
-                        .map_err(|err| CommonError::InvalidStructure(format!(""Can't deserialize Seed from Base64 string: {:?}"", err)))?
-                } else {
-                    seed.as_bytes().to_vec()
-                };
-                Some(ed25519_sign::Seed::from_slice(&seed)?)
-            }
-            None => None
+        if seed.is_none() {
+            trace!(""convert_seed <<< res: None"");
+            return Ok(None);
+        }
+
+        let seed = seed.unwrap();
+
+        let bytes = if seed.as_bytes().len() == ed25519_sign::SEEDBYTES {
+            // is acceptable seed length
+            seed.as_bytes().to_vec()
+        } else if seed.ends_with('=') {
+            // is base64 string
+            base64::decode(&seed)
+                .map_err(|err| CommonError::InvalidStructure(format!(""Can't deserialize Seed from Base64 string: {:?}"", err)))?
+        } else if seed.as_bytes().len() / 2 == ed25519_sign::SEEDBYTES {",,2018-10-04 13:52:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/222656832,https://github.com/hyperledger/indy-sdk/pull/1179#discussion_r222656832,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1178,https://github.com/hyperledger/indy-sdk/pull/1178,Could we change `agency` to `agent` ?,93075f319d97b39d6a7b96d0adefff89ce2a0727,2018-10-05 14:29:46,223026775,"@@ -0,0 +1,17 @@
+{
+  ""agent"": {
+    ""wallet_id"": ""agency_wallet_id"",",,2018-10-11 08:14:24,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/223026775,https://github.com/hyperledger/indy-sdk/pull/1178#discussion_r223026775,donqui
https://github.com/hyperledger/indy-sdk/pull/1170,https://github.com/hyperledger/indy-sdk/pull/1170,"This approach definitely works (awesome job, btw, really looking forward to having this) but I think that separating out auth and anon pack out into separate functions may improve overall understandability of this method. Is there a compelling reason to mix both into the one function?",e6eddb8b30595d2f322aba1c12d4e690aaad8619,2018-10-04 18:42:06,222784693,"@@ -0,0 +1,523 @@
+use domain::route::*;
+use domain::crypto::key::Key;
+use domain::crypto::combo_box::ComboBox;
+use errors::route::RouteError;
+use errors::common::CommonError;
+use services::crypto::CryptoService;
+use services::wallet::{WalletService, RecordOptions};
+use utils::crypto::base64::{decode, encode};
+use utils::crypto::xsalsa20::{encrypt_payload, decrypt_payload};
+use utils::serialization::jwm::*;
+use std::rc::Rc;
+
+pub struct RouteService { }
+
+impl RouteService {
+    pub fn new() -> RouteService {
+        RouteService {}
+    }
+
+    pub fn pack_msg(&self, plaintext: &str, recv_keys: &Vec<String>, my_vk: Option<&str>, is_authcrypt: bool,",,2018-10-09 21:30:15,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/222784693,https://github.com/hyperledger/indy-sdk/pull/1170#discussion_r222784693,dbluhm
https://github.com/hyperledger/indy-sdk/pull/1170,https://github.com/hyperledger/indy-sdk/pull/1170,when I originally designed it I thought it would be easiest to combine it. This was quite confusing after all. With this new iteration I've been rewriting they are now separate making for much cleaner code to read.,e6eddb8b30595d2f322aba1c12d4e690aaad8619,2018-10-04 22:14:53,222843958,"@@ -0,0 +1,523 @@
+use domain::route::*;
+use domain::crypto::key::Key;
+use domain::crypto::combo_box::ComboBox;
+use errors::route::RouteError;
+use errors::common::CommonError;
+use services::crypto::CryptoService;
+use services::wallet::{WalletService, RecordOptions};
+use utils::crypto::base64::{decode, encode};
+use utils::crypto::xsalsa20::{encrypt_payload, decrypt_payload};
+use utils::serialization::jwm::*;
+use std::rc::Rc;
+
+pub struct RouteService { }
+
+impl RouteService {
+    pub fn new() -> RouteService {
+        RouteService {}
+    }
+
+    pub fn pack_msg(&self, plaintext: &str, recv_keys: &Vec<String>, my_vk: Option<&str>, is_authcrypt: bool,",,2018-10-09 21:30:15,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/222843958,https://github.com/hyperledger/indy-sdk/pull/1170#discussion_r222843958,kdenhartog
https://github.com/hyperledger/indy-sdk/pull/1166,https://github.com/hyperledger/indy-sdk/pull/1166,I believe it should be named indy,d32e08223b8a42c6525c2ed787b1f4e3ad002de5,2018-09-28 15:11:45,221287323,"@@ -0,0 +1,38 @@
+[package]
+name = ""rust-libindy-wrapper""",,2018-10-03 19:47:37,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/221287323,https://github.com/hyperledger/indy-sdk/pull/1166#discussion_r221287323,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1160,https://github.com/hyperledger/indy-sdk/pull/1160,please change to `revealed_attrs`,558490f4163dcd6f32c16220769e78ff35e58440,2018-10-04 12:07:42,222640721,"@@ -481,27 +481,29 @@ await proof.generate_proof(credentials, {})
 await proof.send_proof(connection_to_thrift)
 ```
 
-When **Thrift** inspects the received Proof he will see following structure:
+When **Thrift** inspects the received Proof he will see the following structure:
 ```
 # Thrift Agent
 {
     'requested_proof': {
-	'revealed_attributess': {
-	    'attr1_referent': {'sub_proof_index': 0, 'raw':'Permanent', 'encoded':'2143135425425143112321314321'},
-	},
-	'self_attested_attrs': {},
-	'unrevealed_attrs': {},
-	'predicates': {
-	    'predicate1_referent': {'sub_proof_index': 0},
-	    'predicate2_referent': {'sub_proof_index': 0}
-	}
+        'revealed_attributes': {",,2018-10-04 17:09:18,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/222640721,https://github.com/hyperledger/indy-sdk/pull/1160#discussion_r222640721,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1138,https://github.com/hyperledger/indy-sdk/pull/1138,@phillipgibb is any reason to limit possible protocol version by default one?,5d1a6f679b9a947c259dda2f05aac14c4d9f4c97,2018-10-05 12:19:45,222985537,"@@ -181,6 +184,18 @@ pub fn process_config_file(path: &str) -> Result<u32, u32> {
     }
 }
 
+pub fn get_protocol_version() -> usize {
+    let protocol_version = match get_config_value(CONFIG_PROTOCOL_VERSION) {
+        Ok(x) => x.parse::<usize>().unwrap_or(DEFAULT_PROTOCOL_VERSION),
+        Err(x) => DEFAULT_PROTOCOL_VERSION,
+    };
+    if protocol_version > DEFAULT_PROTOCOL_VERSION {",,2018-10-12 07:52:53,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/222985537,https://github.com/hyperledger/indy-sdk/pull/1138#discussion_r222985537,jovfer
https://github.com/hyperledger/indy-sdk/pull/1138,https://github.com/hyperledger/indy-sdk/pull/1138,"not really, only because the STN was version 1, should be 2 now, but could be different in future.",5d1a6f679b9a947c259dda2f05aac14c4d9f4c97,2018-10-05 12:37:27,222990564,"@@ -181,6 +184,18 @@ pub fn process_config_file(path: &str) -> Result<u32, u32> {
     }
 }
 
+pub fn get_protocol_version() -> usize {
+    let protocol_version = match get_config_value(CONFIG_PROTOCOL_VERSION) {
+        Ok(x) => x.parse::<usize>().unwrap_or(DEFAULT_PROTOCOL_VERSION),
+        Err(x) => DEFAULT_PROTOCOL_VERSION,
+    };
+    if protocol_version > DEFAULT_PROTOCOL_VERSION {",,2018-10-12 07:52:53,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/222990564,https://github.com/hyperledger/indy-sdk/pull/1138#discussion_r222990564,phillipgibb
https://github.com/hyperledger/indy-sdk/pull/1138,https://github.com/hyperledger/indy-sdk/pull/1138,"@phillipgibb  But this code **limits** result of the function to default version. In my understanding it's OK to have default one not the latest one, but vcx should allow to set newer one. ",5d1a6f679b9a947c259dda2f05aac14c4d9f4c97,2018-10-08 13:57:26,223372862,"@@ -181,6 +184,18 @@ pub fn process_config_file(path: &str) -> Result<u32, u32> {
     }
 }
 
+pub fn get_protocol_version() -> usize {
+    let protocol_version = match get_config_value(CONFIG_PROTOCOL_VERSION) {
+        Ok(x) => x.parse::<usize>().unwrap_or(DEFAULT_PROTOCOL_VERSION),
+        Err(x) => DEFAULT_PROTOCOL_VERSION,
+    };
+    if protocol_version > DEFAULT_PROTOCOL_VERSION {",,2018-10-12 07:52:53,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/223372862,https://github.com/hyperledger/indy-sdk/pull/1138#discussion_r223372862,jovfer
https://github.com/hyperledger/indy-sdk/pull/1138,https://github.com/hyperledger/indy-sdk/pull/1138,"I agree, but I had to do the code change locally so I could set the version to 1 for STN. I guess it has no point now because STN is going version 2 and I don't know when/if ever there will be a version 3. So maybe reject the pull request",5d1a6f679b9a947c259dda2f05aac14c4d9f4c97,2018-10-08 19:12:05,223469703,"@@ -181,6 +184,18 @@ pub fn process_config_file(path: &str) -> Result<u32, u32> {
     }
 }
 
+pub fn get_protocol_version() -> usize {
+    let protocol_version = match get_config_value(CONFIG_PROTOCOL_VERSION) {
+        Ok(x) => x.parse::<usize>().unwrap_or(DEFAULT_PROTOCOL_VERSION),
+        Err(x) => DEFAULT_PROTOCOL_VERSION,
+    };
+    if protocol_version > DEFAULT_PROTOCOL_VERSION {",,2018-10-12 07:52:53,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/223469703,https://github.com/hyperledger/indy-sdk/pull/1138#discussion_r223469703,phillipgibb
https://github.com/hyperledger/indy-sdk/pull/1138,https://github.com/hyperledger/indy-sdk/pull/1138,"I suggest to just drop this particular if/else. So vcx will use 1 by default (or may be 2 as STN already have v2)
+= there will be ability to set any new version via vcx config file",5d1a6f679b9a947c259dda2f05aac14c4d9f4c97,2018-10-10 10:49:39,224026554,"@@ -181,6 +184,18 @@ pub fn process_config_file(path: &str) -> Result<u32, u32> {
     }
 }
 
+pub fn get_protocol_version() -> usize {
+    let protocol_version = match get_config_value(CONFIG_PROTOCOL_VERSION) {
+        Ok(x) => x.parse::<usize>().unwrap_or(DEFAULT_PROTOCOL_VERSION),
+        Err(x) => DEFAULT_PROTOCOL_VERSION,
+    };
+    if protocol_version > DEFAULT_PROTOCOL_VERSION {",,2018-10-12 07:52:53,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/224026554,https://github.com/hyperledger/indy-sdk/pull/1138#discussion_r224026554,jovfer
https://github.com/hyperledger/indy-sdk/pull/1138,https://github.com/hyperledger/indy-sdk/pull/1138,May be we should have one more constant - something like `MAX_SUPPORTED_PROTOCOL_VERSION`,5d1a6f679b9a947c259dda2f05aac14c4d9f4c97,2018-10-10 10:51:22,224027060,"@@ -181,6 +184,18 @@ pub fn process_config_file(path: &str) -> Result<u32, u32> {
     }
 }
 
+pub fn get_protocol_version() -> usize {
+    let protocol_version = match get_config_value(CONFIG_PROTOCOL_VERSION) {
+        Ok(x) => x.parse::<usize>().unwrap_or(DEFAULT_PROTOCOL_VERSION),
+        Err(x) => DEFAULT_PROTOCOL_VERSION,
+    };
+    if protocol_version > DEFAULT_PROTOCOL_VERSION {",,2018-10-12 07:52:53,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/224027060,https://github.com/hyperledger/indy-sdk/pull/1138#discussion_r224027060,jovfer
https://github.com/hyperledger/indy-sdk/pull/1138,https://github.com/hyperledger/indy-sdk/pull/1138,"yes, great idea. Yet it will need to be updated whenever the protocol version of the ledger updates - guessing not anytime soon",5d1a6f679b9a947c259dda2f05aac14c4d9f4c97,2018-10-10 10:57:32,224028807,"@@ -181,6 +184,18 @@ pub fn process_config_file(path: &str) -> Result<u32, u32> {
     }
 }
 
+pub fn get_protocol_version() -> usize {
+    let protocol_version = match get_config_value(CONFIG_PROTOCOL_VERSION) {
+        Ok(x) => x.parse::<usize>().unwrap_or(DEFAULT_PROTOCOL_VERSION),
+        Err(x) => DEFAULT_PROTOCOL_VERSION,
+    };
+    if protocol_version > DEFAULT_PROTOCOL_VERSION {",,2018-10-12 07:52:53,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/224028807,https://github.com/hyperledger/indy-sdk/pull/1138#discussion_r224028807,phillipgibb
https://github.com/hyperledger/indy-sdk/pull/1138,https://github.com/hyperledger/indy-sdk/pull/1138,"Like
```
    let protocol_version = match get_config_value(CONFIG_PROTOCOL_VERSION) {
        Ok(x) => x.parse::<usize>().unwrap_or(DEFAULT_PROTOCOL_VERSION),
        Err(x) => ??? DEFAULT_PROTOCOL_VERSION ????,
    };
    if protocol_version > MAX_SUPPORTED_PROTOCOL_VERSION {
        err_trace and return default or max ? return critical error?
    } else {
        protocol_version
    }
```",5d1a6f679b9a947c259dda2f05aac14c4d9f4c97,2018-10-10 11:06:45,224031338,"@@ -181,6 +184,18 @@ pub fn process_config_file(path: &str) -> Result<u32, u32> {
     }
 }
 
+pub fn get_protocol_version() -> usize {
+    let protocol_version = match get_config_value(CONFIG_PROTOCOL_VERSION) {
+        Ok(x) => x.parse::<usize>().unwrap_or(DEFAULT_PROTOCOL_VERSION),
+        Err(x) => DEFAULT_PROTOCOL_VERSION,
+    };
+    if protocol_version > DEFAULT_PROTOCOL_VERSION {",,2018-10-12 07:52:53,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/224031338,https://github.com/hyperledger/indy-sdk/pull/1138#discussion_r224031338,jovfer
https://github.com/hyperledger/indy-sdk/pull/1138,https://github.com/hyperledger/indy-sdk/pull/1138,"or may be
```
   let protocol_version = match get_config_value(CONFIG_PROTOCOL_VERSION) {
        Ok(x) if x <= MAX_SUPPORTED_PROTOCOL_VERSION => x.parse::<usize>().unwrap_or(DEFAULT_PROTOCOL_VERSION),
        Err(x) => ??? critical error ????,
    };
```
not sure about `get_config_value` behavior ",5d1a6f679b9a947c259dda2f05aac14c4d9f4c97,2018-10-10 11:10:50,224032380,"@@ -181,6 +184,18 @@ pub fn process_config_file(path: &str) -> Result<u32, u32> {
     }
 }
 
+pub fn get_protocol_version() -> usize {
+    let protocol_version = match get_config_value(CONFIG_PROTOCOL_VERSION) {
+        Ok(x) => x.parse::<usize>().unwrap_or(DEFAULT_PROTOCOL_VERSION),
+        Err(x) => DEFAULT_PROTOCOL_VERSION,
+    };
+    if protocol_version > DEFAULT_PROTOCOL_VERSION {",,2018-10-12 07:52:53,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/224032380,https://github.com/hyperledger/indy-sdk/pull/1138#discussion_r224032380,jovfer
https://github.com/hyperledger/indy-sdk/pull/1138,https://github.com/hyperledger/indy-sdk/pull/1138,"I can't contribute anymore to this pull request, my mastering of rust doesn't warrant too much messing around. 
But I think that  there should be an error, or at least a warning to inform the 'user' that the version is not supported (and may default to the max version?)",5d1a6f679b9a947c259dda2f05aac14c4d9f4c97,2018-10-10 12:41:25,224058433,"@@ -181,6 +184,18 @@ pub fn process_config_file(path: &str) -> Result<u32, u32> {
     }
 }
 
+pub fn get_protocol_version() -> usize {
+    let protocol_version = match get_config_value(CONFIG_PROTOCOL_VERSION) {
+        Ok(x) => x.parse::<usize>().unwrap_or(DEFAULT_PROTOCOL_VERSION),
+        Err(x) => DEFAULT_PROTOCOL_VERSION,
+    };
+    if protocol_version > DEFAULT_PROTOCOL_VERSION {",,2018-10-12 07:52:53,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/224058433,https://github.com/hyperledger/indy-sdk/pull/1138#discussion_r224058433,phillipgibb
https://github.com/hyperledger/indy-sdk/pull/1136,https://github.com/hyperledger/indy-sdk/pull/1136,I believe we should change the title to reference VCX,f414506d4f70dd941b31c601319226021362067f,2018-09-12 14:49:06,217063615,"@@ -0,0 +1,646 @@
+﻿# Getting Started with Libindy",,2018-09-24 14:35:03,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/217063615,https://github.com/hyperledger/indy-sdk/pull/1136#discussion_r217063615,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1136,https://github.com/hyperledger/indy-sdk/pull/1136,"> What Indy and Libindy are and Why They Matter

Can we re-name it to What Indy, Libindy, Libvcx are and Why They Matter",f414506d4f70dd941b31c601319226021362067f,2018-09-12 14:50:42,217064242,"@@ -0,0 +1,646 @@
+﻿# Getting Started with Libindy
+
+## A Developer Guide for Building Indy Clients Using Libindy
+
+![logo](https://raw.githubusercontent.com/hyperledger/indy-node/master/collateral/logos/indy-logo.png)
+
+* [Getting Started with Libvcx](#getting-started-with-libvcx)
+  * [What Indy and Libindy are and Why They Matter](#what-indy-and-libindy-are-and-why-they-matter)",,2018-09-24 14:35:03,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/217064242,https://github.com/hyperledger/indy-sdk/pull/1136#discussion_r217064242,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1136,https://github.com/hyperledger/indy-sdk/pull/1136,"We can add sentence that libindy is a low level library that provides fine configuration, but vcx is more high-level library concentrated on hiding low-level details and increasing of application development efficiency.",f414506d4f70dd941b31c601319226021362067f,2018-09-12 14:54:21,217065777,"@@ -0,0 +1,646 @@
+﻿# Getting Started with Libindy
+
+## A Developer Guide for Building Indy Clients Using Libindy
+
+![logo](https://raw.githubusercontent.com/hyperledger/indy-node/master/collateral/logos/indy-logo.png)
+
+* [Getting Started with Libvcx](#getting-started-with-libvcx)
+  * [What Indy and Libindy are and Why They Matter](#what-indy-and-libindy-are-and-why-they-matter)
+  * [What We'll Cover](#what-well-cover)
+  * [About Alice](#about-alice)
+  * [Infrastructure Preparation](#infrastructure-preparation)
+      * [Step 1: Getting Trust Anchor Credentials for Faber, Acme, Thrift and Government](#step-1-getting-trust-anchor-credentials-for-faber-acme-thrift-and-government)
+      * [Step 2: Connecting to the Indy Nodes Pool](#step-2-connecting-to-the-indy-nodes-pool)
+      * [Step 3: Getting the Ownership for Stewards's Verinym](#step-3-getting-the-ownership-for-stewardss-verinym)
+      * [Step 4: Onboarding Faber, Acme, Thrift and Government by the Steward](#step-4-onboarding-faber-acme-thrift-and-government-by-steward)
+        * [Connecting the Establishment](#connecting-the-establishment)
+        * [Getting the Verinym](#getting-verinym)
+      * [Step 5: Credential Schemas Setup](#step-5-credential-schemas-setup)
+      * [Step 6: Credential Definition Setup](#step-6-credential-definition-setup)
+  * [Alice Gets a Transcript](#alice-gets-a-transcript)
+  * [Apply for a Job](#apply-for-a-job)
+  * [Apply for a Loan](#apply-for-a-loan)
+  * [Explore the Code](#explore-the-code)
+
+## What Indy, Libindy and Libvcx are and Why They Matter
+
+Indy provides a software ecosystem for private, secure, and powerful identity, and libindy enables clients for it. Indy puts people — not the organizations that traditionally centralize identity — in charge of decisions about their own privacy and disclosure. Libvcx is library on top of libindy which simplifies credential exchange. This enables all kinds of rich innovation: connection contracts, revocation, novel payment workflows, asset and document management features, creative forms of escrow, curated reputation, integrations with other cool technologies, and so on.",,2018-09-24 14:35:03,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/217065777,https://github.com/hyperledger/indy-sdk/pull/1136#discussion_r217065777,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1136,https://github.com/hyperledger/indy-sdk/pull/1136,Yes :),f414506d4f70dd941b31c601319226021362067f,2018-09-17 11:00:41,218026892,"@@ -0,0 +1,646 @@
+﻿# Getting Started with Libindy",,2018-09-24 14:35:03,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/218026892,https://github.com/hyperledger/indy-sdk/pull/1136#discussion_r218026892,dkulic
https://github.com/hyperledger/indy-sdk/pull/1136,https://github.com/hyperledger/indy-sdk/pull/1136,"Sure, missed this.",f414506d4f70dd941b31c601319226021362067f,2018-09-17 11:00:58,218026956,"@@ -0,0 +1,646 @@
+﻿# Getting Started with Libindy
+
+## A Developer Guide for Building Indy Clients Using Libindy
+
+![logo](https://raw.githubusercontent.com/hyperledger/indy-node/master/collateral/logos/indy-logo.png)
+
+* [Getting Started with Libvcx](#getting-started-with-libvcx)
+  * [What Indy and Libindy are and Why They Matter](#what-indy-and-libindy-are-and-why-they-matter)",,2018-09-24 14:35:03,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/218026956,https://github.com/hyperledger/indy-sdk/pull/1136#discussion_r218026956,dkulic
https://github.com/hyperledger/indy-sdk/pull/1136,https://github.com/hyperledger/indy-sdk/pull/1136,Done,f414506d4f70dd941b31c601319226021362067f,2018-09-17 11:01:03,218026984,"@@ -0,0 +1,646 @@
+﻿# Getting Started with Libindy
+
+## A Developer Guide for Building Indy Clients Using Libindy
+
+![logo](https://raw.githubusercontent.com/hyperledger/indy-node/master/collateral/logos/indy-logo.png)
+
+* [Getting Started with Libvcx](#getting-started-with-libvcx)
+  * [What Indy and Libindy are and Why They Matter](#what-indy-and-libindy-are-and-why-they-matter)
+  * [What We'll Cover](#what-well-cover)
+  * [About Alice](#about-alice)
+  * [Infrastructure Preparation](#infrastructure-preparation)
+      * [Step 1: Getting Trust Anchor Credentials for Faber, Acme, Thrift and Government](#step-1-getting-trust-anchor-credentials-for-faber-acme-thrift-and-government)
+      * [Step 2: Connecting to the Indy Nodes Pool](#step-2-connecting-to-the-indy-nodes-pool)
+      * [Step 3: Getting the Ownership for Stewards's Verinym](#step-3-getting-the-ownership-for-stewardss-verinym)
+      * [Step 4: Onboarding Faber, Acme, Thrift and Government by the Steward](#step-4-onboarding-faber-acme-thrift-and-government-by-steward)
+        * [Connecting the Establishment](#connecting-the-establishment)
+        * [Getting the Verinym](#getting-verinym)
+      * [Step 5: Credential Schemas Setup](#step-5-credential-schemas-setup)
+      * [Step 6: Credential Definition Setup](#step-6-credential-definition-setup)
+  * [Alice Gets a Transcript](#alice-gets-a-transcript)
+  * [Apply for a Job](#apply-for-a-job)
+  * [Apply for a Loan](#apply-for-a-loan)
+  * [Explore the Code](#explore-the-code)
+
+## What Indy, Libindy and Libvcx are and Why They Matter
+
+Indy provides a software ecosystem for private, secure, and powerful identity, and libindy enables clients for it. Indy puts people — not the organizations that traditionally centralize identity — in charge of decisions about their own privacy and disclosure. Libvcx is library on top of libindy which simplifies credential exchange. This enables all kinds of rich innovation: connection contracts, revocation, novel payment workflows, asset and document management features, creative forms of escrow, curated reputation, integrations with other cool technologies, and so on.",,2018-09-24 14:35:03,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/218026984,https://github.com/hyperledger/indy-sdk/pull/1136#discussion_r218026984,dkulic
https://github.com/hyperledger/indy-sdk/pull/1133,https://github.com/hyperledger/indy-sdk/pull/1133,I believe it should be called indy_init() and require a json with crypto_thread_pool_size fields as an input. ,b7327ae8545494bbe806c8ea621bc2c8ef7cbf04,2018-10-11 08:19:46,224355881,"@@ -225,3 +225,16 @@ pub enum ErrorCode
     // Extra funds on inputs
     PaymentExtraFundsError = 705
 }
+
+#[no_mangle]
+pub extern fn indy_set_crypto_thread_pool_size(size: usize) -> ErrorCode {",,2018-10-11 10:29:03,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/224355881,https://github.com/hyperledger/indy-sdk/pull/1133#discussion_r224355881,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1133,https://github.com/hyperledger/indy-sdk/pull/1133,"Also we need documentation for this function before merge. It can be ""Can be optionally called on the beginning to change default libindy runtime configuration""
",b7327ae8545494bbe806c8ea621bc2c8ef7cbf04,2018-10-11 08:21:25,224356361,"@@ -225,3 +225,16 @@ pub enum ErrorCode
     // Extra funds on inputs
     PaymentExtraFundsError = 705
 }
+
+#[no_mangle]
+pub extern fn indy_set_crypto_thread_pool_size(size: usize) -> ErrorCode {",,2018-10-11 10:29:03,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/224356361,https://github.com/hyperledger/indy-sdk/pull/1133#discussion_r224356361,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1132,https://github.com/hyperledger/indy-sdk/pull/1132,"@AxelNennker Can it be just `let endpoint = Endpoint::new(address, Some(transport_key));` ?",fd9bce252de48dd5d5f3075c36309d20d4c0b5f4,2018-10-08 08:03:48,223276139,"@@ -416,12 +417,13 @@ pub extern fn indy_set_endpoint_for_did(command_handle: i32,
     trace!(""indy_set_endpoint_for_did: entities >>> wallet_handle: {:?}, did: {:?}, address: {:?}, transport_key: {:?}"",
            wallet_handle, did, address, transport_key);
 
+    let endpoint = Endpoint::new(address.to_string(), Some(transport_key.to_string()));",,2018-10-08 13:52:32,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/223276139,https://github.com/hyperledger/indy-sdk/pull/1132#discussion_r223276139,jovfer
https://github.com/hyperledger/indy-sdk/pull/1121,https://github.com/hyperledger/indy-sdk/pull/1121,We shouldn't hardcore error code here CommonInvalidParam4,4dbdaff9b1643182c97bdad4cf71fe1587fc2339,2018-10-19 12:30:40,226629417,"@@ -58,6 +58,27 @@ macro_rules! check_useful_opt_json {
     }
 }
 
+macro_rules! check_request {
+    ($x:ident) => {
+        let $x: Value = match serde_json::from_str(&$x) {
+            Ok(Some(val)) => val,
+            _ => {
+                trace!(""indy_sign_and_submit_request: could not parse request as valid json: {:?}"", $x);
+                return ErrorCode::CommonInvalidParam4;",10,2018-10-19 12:30:40,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/226629417,https://github.com/hyperledger/indy-sdk/pull/1121#discussion_r226629417,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1105,https://github.com/hyperledger/indy-sdk/pull/1105,Is it possible to change order of validations instead of this hack?,0cd55608b371e54a2bce6cf68a68bbcbb9b7843f,2018-08-30 12:04:37,214003838,"@@ -1282,12 +1282,13 @@ fn parse_payment_outputs(outputs: &Vec<String>) -> Result<String, ()> {
 
 fn parse_response_with_fees(response: &str, payment_method: Option<String>) -> Result<Option<Vec<serde_json::Value>>, ()> {
     let receipts = if let Some(method) = payment_method {
-        Some(Payment::parse_response_with_fees(&method, &response)
-            .map_err(|err| handle_payment_error(err, Some(&method)))
-            .and_then(|fees| serde_json::from_str::<Vec<serde_json::Value>>(&fees)
-                .map_err(|err| println_err!(""Invalid data has been received: {:?}"", err)))?)
+        match Payment::parse_response_with_fees(&method, &response) {
+            Ok(fees) => Some(serde_json::from_str::<Vec<serde_json::Value>>(&fees)
+                .map_err(|err| println_err!(""Invalid data has been received: {:?}"", err))?),
+            Err(ErrorCode::CommonInvalidStructure) => None, // can't parse response because occurred error related to Node validation",,2018-08-31 12:17:00,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/214003838,https://github.com/hyperledger/indy-sdk/pull/1105#discussion_r214003838,jovfer
https://github.com/hyperledger/indy-sdk/pull/1096,https://github.com/hyperledger/indy-sdk/pull/1096,It is better to use domain type for tags instead of HashMap. In the future we can introduce static validation and validation can be different for different for different domain types.,495d1a31a9f34847378f1045aceb4a4929b7c009,2018-08-28 12:12:41,213287598,"@@ -41,7 +45,7 @@ pub extern fn indy_add_wallet_record(command_handle: i32,
     check_useful_c_str!(type_, ErrorCode::CommonInvalidParam3);
     check_useful_c_str!(id, ErrorCode::CommonInvalidParam4);
     check_useful_c_str!(value, ErrorCode::CommonInvalidParam5);
-    check_useful_opt_c_str!(tags_json, ErrorCode::CommonInvalidParam6);
+    check_useful_opt_json!(tags_json, ErrorCode::CommonInvalidParam6, HashMap<String, String>);",,2018-08-29 10:33:36,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/213287598,https://github.com/hyperledger/indy-sdk/pull/1096#discussion_r213287598,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1088,https://github.com/hyperledger/indy-sdk/pull/1088,Please add similar for `indy_prover_get_credentials`.,780668e8a5b74266512c94d1d02ed5cfc2898a69,2018-08-23 12:36:43,212291364,"@@ -1154,6 +1154,7 @@ pub  extern fn indy_prover_close_credentials_search(command_handle: i32,
 /// Annoncreds*
 /// Common*
 /// Wallet*
+#[deprecated(since=""1.6.1"", note=""Please use indy_prover_search_credentials_for_proof_req instead!"")]",12,2018-08-31 12:34:08,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/212291364,https://github.com/hyperledger/indy-sdk/pull/1088#discussion_r212291364,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/1088,https://github.com/hyperledger/indy-sdk/pull/1088,please review.,780668e8a5b74266512c94d1d02ed5cfc2898a69,2018-08-23 12:56:56,212297808,"@@ -1154,6 +1154,7 @@ pub  extern fn indy_prover_close_credentials_search(command_handle: i32,
 /// Annoncreds*
 /// Common*
 /// Wallet*
+#[deprecated(since=""1.6.1"", note=""Please use indy_prover_search_credentials_for_proof_req instead!"")]",12,2018-08-31 12:34:08,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/212297808,https://github.com/hyperledger/indy-sdk/pull/1088#discussion_r212297808,AxelNennker
https://github.com/hyperledger/indy-sdk/pull/1086,https://github.com/hyperledger/indy-sdk/pull/1086,Help me understand why raw keys for export and import are not allowed. Why would we only support key derivation?,d4f5fd9476f48dfedf024fc14e9c59d620fe6d07,2018-08-22 15:09:05,211992524,"@@ -33,7 +33,8 @@ pub(super) fn export(wallet: &Wallet, writer: &mut Write, passphrase: &str, vers
             salt: salt[..].to_vec(),
             nonce: nonce[..].to_vec(),
             chunk_size,
-        }
+        },
+        KeyDerivationMethod::RAW => return Err(WalletError::CommonError(CommonError::InvalidStructure(""RAW key derivation method is not acceptable"".to_string())))",,2018-08-25 10:22:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211992524,https://github.com/hyperledger/indy-sdk/pull/1086#discussion_r211992524,mikelodder7
https://github.com/hyperledger/indy-sdk/pull/1086,https://github.com/hyperledger/indy-sdk/pull/1086,"I believe there is no reason except that we don't have use cases for this. 

@Artemkaaas @mikelodder7 I though a bit more. I believe it is better to keep all possible options for export too to keep API consistent.",d4f5fd9476f48dfedf024fc14e9c59d620fe6d07,2018-08-22 15:25:56,211999023,"@@ -33,7 +33,8 @@ pub(super) fn export(wallet: &Wallet, writer: &mut Write, passphrase: &str, vers
             salt: salt[..].to_vec(),
             nonce: nonce[..].to_vec(),
             chunk_size,
-        }
+        },
+        KeyDerivationMethod::RAW => return Err(WalletError::CommonError(CommonError::InvalidStructure(""RAW key derivation method is not acceptable"".to_string())))",,2018-08-25 10:22:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211999023,https://github.com/hyperledger/indy-sdk/pull/1086#discussion_r211999023,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1086,https://github.com/hyperledger/indy-sdk/pull/1086,I suggest to rename key_type to key_derivation_method,d4f5fd9476f48dfedf024fc14e9c59d620fe6d07,2018-08-23 13:12:06,212302714,"@@ -127,14 +127,14 @@ indy> wallet <command>
 #### Wallet create
 Create new wallet with specified name:
 ```
-indy> wallet create <wallet name> key [storage_type=<storage_type>] [storage_config={config json}]
+indy> wallet create <wallet name> key [key_type=<key_type>] [storage_type=<storage_type>] [storage_config={config json}]",,2018-08-25 10:22:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/212302714,https://github.com/hyperledger/indy-sdk/pull/1086#discussion_r212302714,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1086,https://github.com/hyperledger/indy-sdk/pull/1086,I suggest to rename key_type  to key_derivation_method ,d4f5fd9476f48dfedf024fc14e9c59d620fe6d07,2018-08-23 13:12:57,212302992,"@@ -26,6 +26,10 @@ pub mod create_command {
     command!(CommandMetadata::build(""create"", ""Create new wallet with specified name"")
                 .add_main_param(""name"", ""Identifier of the wallet"")
                 .add_required_deferred_param(""key"", ""Auth key for the wallet"")
+                .add_optional_param(""key_type"", ""Type of auth key. One of:",,2018-08-25 10:22:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/212302992,https://github.com/hyperledger/indy-sdk/pull/1086#discussion_r212302992,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1086,https://github.com/hyperledger/indy-sdk/pull/1086,Can we use update_json_map_opt_key for this?,d4f5fd9476f48dfedf024fc14e9c59d620fe6d07,2018-08-23 13:20:12,212305393,"@@ -95,9 +110,14 @@ pub mod open_command {
             let mut json = JSONMap::new();
 
             json.insert(""key"".to_string(), serde_json::Value::String(key.to_string()));
+            json.insert(""key_derivation_method"".to_string(), serde_json::Value::String(map_key_type(key_type)?.to_string()));
 
             update_json_map_opt_key!(json, ""rekey"", rekey);
 
+            if rekey.is_some(){",,2018-08-25 10:22:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/212305393,https://github.com/hyperledger/indy-sdk/pull/1086#discussion_r212305393,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1086,https://github.com/hyperledger/indy-sdk/pull/1086,I suggest to rename key_type to key_derivation_method,d4f5fd9476f48dfedf024fc14e9c59d620fe6d07,2018-08-23 13:20:44,212305617,"@@ -221,6 +241,10 @@ pub mod delete_command {
     command!(CommandMetadata::build(""delete"", ""Delete wallet with specified name"")
                 .add_main_param(""name"", ""The name of deleted wallet"")
                 .add_required_deferred_param(""key"", ""Auth key for the wallet"")
+                .add_optional_param(""key_type"", ""Type of auth key. One of:",,2018-08-25 10:22:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/212305617,https://github.com/hyperledger/indy-sdk/pull/1086#discussion_r212305617,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1086,https://github.com/hyperledger/indy-sdk/pull/1086,I suggest to rename key_type to key_derivation_method,d4f5fd9476f48dfedf024fc14e9c59d620fe6d07,2018-08-23 13:20:49,212305642,"@@ -230,11 +254,12 @@ pub mod delete_command {
 
         let id = get_str_param(""name"", params).map_err(error_err!())?;
         let key = get_str_param(""key"", params).map_err(error_err!())?;
+        let key_type = get_opt_str_param(""key_type"", params).map_err(error_err!())?;",,2018-08-25 10:22:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/212305642,https://github.com/hyperledger/indy-sdk/pull/1086#discussion_r212305642,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1086,https://github.com/hyperledger/indy-sdk/pull/1086,I suggest to rename key_type to key_derivation_method,d4f5fd9476f48dfedf024fc14e9c59d620fe6d07,2018-08-23 13:21:16,212305773,"@@ -415,6 +450,16 @@ fn _list_wallets() -> Vec<serde_json::Value> {
     configs
 }
 
+fn map_key_type(key: Option<&str>) -> Result<&'static str, ()> {",,2018-08-25 10:22:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/212305773,https://github.com/hyperledger/indy-sdk/pull/1086#discussion_r212305773,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1086,https://github.com/hyperledger/indy-sdk/pull/1086,"> Auth key for the wallet

Rename it to

> Key or passphrase used for wallet key derivation. Look to key_derivation_method param for information about supported key derivation methods.",d4f5fd9476f48dfedf024fc14e9c59d620fe6d07,2018-08-23 13:23:10,212306468,"@@ -165,13 +165,14 @@ extern ""C"" {
     /// }
     /// credentials: Wallet credentials json
     /// {
-    ///   ""key"": string, Passphrase used to derive wallet master key
+    ///   ""key"": string, Auth key for the wallet",,2018-08-25 10:22:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/212306468,https://github.com/hyperledger/indy-sdk/pull/1086#discussion_r212306468,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1086,https://github.com/hyperledger/indy-sdk/pull/1086,The same explanation i suggest to add to CLI help,d4f5fd9476f48dfedf024fc14e9c59d620fe6d07,2018-08-23 13:23:36,212306605,"@@ -165,13 +165,14 @@ extern ""C"" {
     /// }
     /// credentials: Wallet credentials json
     /// {
-    ///   ""key"": string, Passphrase used to derive wallet master key
+    ///   ""key"": string, Auth key for the wallet",,2018-08-25 10:22:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/212306605,https://github.com/hyperledger/indy-sdk/pull/1086#discussion_r212306605,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1086,https://github.com/hyperledger/indy-sdk/pull/1086,"Update description:

Generate wallet master key. Returned key is compatible with ""RAW"" key derivation method. It allows to avoid expensive key derivation for use cases when wallet keys can be stored in a secure enclave.",d4f5fd9476f48dfedf024fc14e9c59d620fe6d07,2018-08-23 13:35:10,212310706,"@@ -519,6 +524,50 @@ pub extern fn indy_delete_wallet(command_handle: i32,
     res
 }
 
+/// Generate wallet master key.",123,2018-08-25 10:22:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/212310706,https://github.com/hyperledger/indy-sdk/pull/1086#discussion_r212310706,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1086,https://github.com/hyperledger/indy-sdk/pull/1086,"Update description:

raw wallet key master provided (skip derivation). RAW keys can be generated with indy_generate_wallet_key call",d4f5fd9476f48dfedf024fc14e9c59d620fe6d07,2018-08-23 13:49:44,212316040,"@@ -473,13 +477,14 @@ pub extern fn indy_close_wallet(command_handle: i32,
 /// }
 /// credentials: Wallet credentials json
 /// {
-///   ""key"": string, Passphrase used to derive wallet master key
+///   ""key"": string, Auth key for the wallet
 ///   ""storage_credentials"": optional<object> Credentials for wallet storage. Storage type defines set of supported keys.
 ///                          Can be optional if storage supports default configuration.
 ///                          For 'default' storage type should be empty.
-///   ""key_derivation_method"": optional<string> algorithm to use for master key derivation:
-///                            ARAGON2I_MOD (used by default)
-///                            ARAGON2I_INT - less secured but faster
+///   ""key_derivation_method"": optional<string> Type of wallet auth key:
+///                             ARAGON2I_MOD - derive secured wallet master key (used by default)
+///                             ARAGON2I_INT - derive secured wallet master key (less secured but faster)
+///                             RAW - raw wallet key master provided (skip derivation)",,2018-08-25 10:22:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/212316040,https://github.com/hyperledger/indy-sdk/pull/1086#discussion_r212316040,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1086,https://github.com/hyperledger/indy-sdk/pull/1086,Use domain object instead ,d4f5fd9476f48dfedf024fc14e9c59d620fe6d07,2018-08-23 16:30:38,212375432,"@@ -220,4 +229,22 @@ impl WalletCommandExecutor {
         trace!(""_import <<< res: {:?}"", res);
         Ok(res)
     }
+
+    fn _generate_key(&self,
+                     config: Option<&str>) -> Result<String> {
+        trace!(""_generate_key >>>config: {:?}"", secret!(config));
+
+        let config = serde_json::from_str::<serde_json::Value>(config.unwrap_or(""{}""))",,2018-08-25 10:22:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/212375432,https://github.com/hyperledger/indy-sdk/pull/1086#discussion_r212375432,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1086,https://github.com/hyperledger/indy-sdk/pull/1086,Can we make metadata enum based in key deriviation method in a backward compatible way?,d4f5fd9476f48dfedf024fc14e9c59d620fe6d07,2018-08-23 16:45:29,212379904,"@@ -534,6 +500,43 @@ impl WalletService {
         res
     }
 
+    fn _prepare_metadata(&self, key: &str, key_derivation_method: &KeyDerivationMethod, keys: &Keys) -> Result<Vec<u8>, WalletError> {
+        let (master_key_salt, master_key) = match key_derivation_method {
+            KeyDerivationMethod::RAW =>
+                (None, encryption::raw_master_key(key)?),
+            KeyDerivationMethod::ARAGON2I_INT | KeyDerivationMethod::ARAGON2I_MOD => {
+                let master_key_salt = encryption::gen_master_key_salt()?;
+                let master_key = encryption::derive_master_key(key, &master_key_salt, key_derivation_method)?;
+                (Some(master_key_salt[..].to_vec()), master_key)
+            }
+        };
+
+        let metadata = Metadata {",,2018-08-25 10:22:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/212379904,https://github.com/hyperledger/indy-sdk/pull/1086#discussion_r212379904,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1086,https://github.com/hyperledger/indy-sdk/pull/1086,Seems we need to make metadata enum as content is different for different methods ,d4f5fd9476f48dfedf024fc14e9c59d620fe6d07,2018-08-23 16:47:23,212380445,"@@ -42,5 +43,5 @@ pub struct ExportConfig {
 #[derive(Debug, Serialize, Deserialize)]
 pub struct Metadata {",,2018-08-25 10:22:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/212380445,https://github.com/hyperledger/indy-sdk/pull/1086#discussion_r212380445,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1079,https://github.com/hyperledger/indy-sdk/pull/1079,"I suggest to define new macro check_useful_json! that will deserialize json to the variable with the same name. It will allow to remove a lot of boilerplate. Usage will be the following:

```
check_useful_json!(did_info, ErrorCode::CommonInvalidParam3, MyDidInfo);
```",073bfc46cdde5e7e6db3b61bcbb73724f93494aa,2018-08-20 10:02:28,211206423,"@@ -47,29 +51,39 @@ use std::ptr;
 #[no_mangle]
 pub  extern fn indy_create_and_store_my_did(command_handle: i32,
                                             wallet_handle: i32,
-                                            did_json: *const c_char,
+                                            did_info_json: *const c_char,
                                             cb: Option<extern fn(xcommand_handle: i32,
                                                                  err: ErrorCode,
                                                                  did: *const c_char,
                                                                  verkey: *const c_char)>) -> ErrorCode {
-    trace!(""indy_create_and_store_my_did: >>> wallet_handle: {:?}, did_json: {:?}"", wallet_handle, did_json);
+    trace!(""indy_create_and_store_my_did: >>> wallet_handle: {:?}, did_json: {:?}"", wallet_handle, did_info_json);
 
-    check_useful_c_str!(did_json, ErrorCode::CommonInvalidParam3);
+    check_useful_c_str!(did_info_json, ErrorCode::CommonInvalidParam3);",,2018-08-28 12:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211206423,https://github.com/hyperledger/indy-sdk/pull/1079#discussion_r211206423,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1079,https://github.com/hyperledger/indy-sdk/pull/1079,"I wanted to change the code as little as possible. Yes, I'll give it a go.",073bfc46cdde5e7e6db3b61bcbb73724f93494aa,2018-08-20 10:05:04,211207171,"@@ -47,29 +51,39 @@ use std::ptr;
 #[no_mangle]
 pub  extern fn indy_create_and_store_my_did(command_handle: i32,
                                             wallet_handle: i32,
-                                            did_json: *const c_char,
+                                            did_info_json: *const c_char,
                                             cb: Option<extern fn(xcommand_handle: i32,
                                                                  err: ErrorCode,
                                                                  did: *const c_char,
                                                                  verkey: *const c_char)>) -> ErrorCode {
-    trace!(""indy_create_and_store_my_did: >>> wallet_handle: {:?}, did_json: {:?}"", wallet_handle, did_json);
+    trace!(""indy_create_and_store_my_did: >>> wallet_handle: {:?}, did_json: {:?}"", wallet_handle, did_info_json);
 
-    check_useful_c_str!(did_json, ErrorCode::CommonInvalidParam3);
+    check_useful_c_str!(did_info_json, ErrorCode::CommonInvalidParam3);",,2018-08-28 12:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211207171,https://github.com/hyperledger/indy-sdk/pull/1079#discussion_r211207171,AxelNennker
https://github.com/hyperledger/indy-sdk/pull/1079,https://github.com/hyperledger/indy-sdk/pull/1079,done,073bfc46cdde5e7e6db3b61bcbb73724f93494aa,2018-08-20 12:23:46,211242074,"@@ -47,29 +51,39 @@ use std::ptr;
 #[no_mangle]
 pub  extern fn indy_create_and_store_my_did(command_handle: i32,
                                             wallet_handle: i32,
-                                            did_json: *const c_char,
+                                            did_info_json: *const c_char,
                                             cb: Option<extern fn(xcommand_handle: i32,
                                                                  err: ErrorCode,
                                                                  did: *const c_char,
                                                                  verkey: *const c_char)>) -> ErrorCode {
-    trace!(""indy_create_and_store_my_did: >>> wallet_handle: {:?}, did_json: {:?}"", wallet_handle, did_json);
+    trace!(""indy_create_and_store_my_did: >>> wallet_handle: {:?}, did_json: {:?}"", wallet_handle, did_info_json);
 
-    check_useful_c_str!(did_json, ErrorCode::CommonInvalidParam3);
+    check_useful_c_str!(did_info_json, ErrorCode::CommonInvalidParam3);",,2018-08-28 12:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211242074,https://github.com/hyperledger/indy-sdk/pull/1079#discussion_r211242074,AxelNennker
https://github.com/hyperledger/indy-sdk/pull/1079,https://github.com/hyperledger/indy-sdk/pull/1079,Rust allows re-definition of local variable. So we can use only ```did_info``` name and reassign it to struct after macros call. ,073bfc46cdde5e7e6db3b61bcbb73724f93494aa,2018-08-20 14:29:27,211282788,"@@ -47,29 +51,29 @@ use std::ptr;
 #[no_mangle]
 pub  extern fn indy_create_and_store_my_did(command_handle: i32,
                                             wallet_handle: i32,
-                                            did_json: *const c_char,
+                                            did_info_json: *const c_char,
                                             cb: Option<extern fn(xcommand_handle: i32,
                                                                  err: ErrorCode,
                                                                  did: *const c_char,
                                                                  verkey: *const c_char)>) -> ErrorCode {
-    trace!(""indy_create_and_store_my_did: >>> wallet_handle: {:?}, did_json: {:?}"", wallet_handle, did_json);
+    trace!(""indy_create_and_store_my_did: >>> wallet_handle: {:?}, did_json: {:?}"", wallet_handle, did_info_json);
 
-    check_useful_c_str!(did_json, ErrorCode::CommonInvalidParam3);
+    check_useful_json!(did_info_json, ErrorCode::CommonInvalidParam3, my_did_info, MyDidInfo);",,2018-08-28 12:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211282788,https://github.com/hyperledger/indy-sdk/pull/1079#discussion_r211282788,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1079,https://github.com/hyperledger/indy-sdk/pull/1079,"True, that is what is done in check_useful_c_str as it re-defines $x from `*const c_char` to `String`. So there the name still makes sense but when converting from a json string to type X is makes sense to let the dev choose and not keep the name because the type now is neither json nor string. IMHO
",073bfc46cdde5e7e6db3b61bcbb73724f93494aa,2018-08-20 15:24:21,211302989,"@@ -47,29 +51,29 @@ use std::ptr;
 #[no_mangle]
 pub  extern fn indy_create_and_store_my_did(command_handle: i32,
                                             wallet_handle: i32,
-                                            did_json: *const c_char,
+                                            did_info_json: *const c_char,
                                             cb: Option<extern fn(xcommand_handle: i32,
                                                                  err: ErrorCode,
                                                                  did: *const c_char,
                                                                  verkey: *const c_char)>) -> ErrorCode {
-    trace!(""indy_create_and_store_my_did: >>> wallet_handle: {:?}, did_json: {:?}"", wallet_handle, did_json);
+    trace!(""indy_create_and_store_my_did: >>> wallet_handle: {:?}, did_json: {:?}"", wallet_handle, did_info_json);
 
-    check_useful_c_str!(did_json, ErrorCode::CommonInvalidParam3);
+    check_useful_json!(did_info_json, ErrorCode::CommonInvalidParam3, my_did_info, MyDidInfo);",,2018-08-28 12:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211302989,https://github.com/hyperledger/indy-sdk/pull/1079#discussion_r211302989,AxelNennker
https://github.com/hyperledger/indy-sdk/pull/1079,https://github.com/hyperledger/indy-sdk/pull/1079,"I'm agree with @AxelNennker that we should drop `_json` suffix here.

If we will use re-definition we should rename origin variables before. Right now only in API  but may be we will use this macro for other places?
@vimmerru do you suggest to rename API parameters to use re-definition?
If we wouldn't like to change API parameters names current solution seems like most correct.",073bfc46cdde5e7e6db3b61bcbb73724f93494aa,2018-08-21 07:50:35,211509013,"@@ -47,29 +51,29 @@ use std::ptr;
 #[no_mangle]
 pub  extern fn indy_create_and_store_my_did(command_handle: i32,
                                             wallet_handle: i32,
-                                            did_json: *const c_char,
+                                            did_info_json: *const c_char,
                                             cb: Option<extern fn(xcommand_handle: i32,
                                                                  err: ErrorCode,
                                                                  did: *const c_char,
                                                                  verkey: *const c_char)>) -> ErrorCode {
-    trace!(""indy_create_and_store_my_did: >>> wallet_handle: {:?}, did_json: {:?}"", wallet_handle, did_json);
+    trace!(""indy_create_and_store_my_did: >>> wallet_handle: {:?}, did_json: {:?}"", wallet_handle, did_info_json);
 
-    check_useful_c_str!(did_json, ErrorCode::CommonInvalidParam3);
+    check_useful_json!(did_info_json, ErrorCode::CommonInvalidParam3, my_did_info, MyDidInfo);",,2018-08-28 12:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211509013,https://github.com/hyperledger/indy-sdk/pull/1079#discussion_r211509013,jovfer
https://github.com/hyperledger/indy-sdk/pull/1079,https://github.com/hyperledger/indy-sdk/pull/1079,"I suggest to remove ""json"" suffix as it looks redundant for me. We have part of cases with suffix and part without suffix and i more like to drop it in all cases as it doesn't provide real benefits. 

In current code we are following approach to avoid creation of new variables in entities conversion chains and it looks more consistent to me. If in the future we will get the case when 2 variables will be needed we can just add optional parameter to the macro.",073bfc46cdde5e7e6db3b61bcbb73724f93494aa,2018-08-21 10:34:35,211557005,"@@ -47,29 +51,29 @@ use std::ptr;
 #[no_mangle]
 pub  extern fn indy_create_and_store_my_did(command_handle: i32,
                                             wallet_handle: i32,
-                                            did_json: *const c_char,
+                                            did_info_json: *const c_char,
                                             cb: Option<extern fn(xcommand_handle: i32,
                                                                  err: ErrorCode,
                                                                  did: *const c_char,
                                                                  verkey: *const c_char)>) -> ErrorCode {
-    trace!(""indy_create_and_store_my_did: >>> wallet_handle: {:?}, did_json: {:?}"", wallet_handle, did_json);
+    trace!(""indy_create_and_store_my_did: >>> wallet_handle: {:?}, did_json: {:?}"", wallet_handle, did_info_json);
 
-    check_useful_c_str!(did_json, ErrorCode::CommonInvalidParam3);
+    check_useful_json!(did_info_json, ErrorCode::CommonInvalidParam3, my_did_info, MyDidInfo);",,2018-08-28 12:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211557005,https://github.com/hyperledger/indy-sdk/pull/1079#discussion_r211557005,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1079,https://github.com/hyperledger/indy-sdk/pull/1079,@AxelNennker I suggest to stop this PR on conversion of jsons to domain types. This early validation is a big question and will make this PR hard to merge. ,073bfc46cdde5e7e6db3b61bcbb73724f93494aa,2018-08-21 13:57:52,211615330,"@@ -55,6 +57,21 @@ pub extern fn indy_issuer_create_schema(command_handle: i32,
 
     trace!(""indy_issuer_create_schema: entity >>> issuer_did: {:?}, name: {:?}, version: {:?}, attrs: {:?}"", issuer_did, name, version, attrs);
 
+    let attrs: HashSet<String> = match serde_json::from_str(&attrs)",18,2018-08-28 12:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211615330,https://github.com/hyperledger/indy-sdk/pull/1079#discussion_r211615330,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1079,https://github.com/hyperledger/indy-sdk/pull/1079,ok,073bfc46cdde5e7e6db3b61bcbb73724f93494aa,2018-08-21 14:40:02,211631766,"@@ -55,6 +57,21 @@ pub extern fn indy_issuer_create_schema(command_handle: i32,
 
     trace!(""indy_issuer_create_schema: entity >>> issuer_did: {:?}, name: {:?}, version: {:?}, attrs: {:?}"", issuer_did, name, version, attrs);
 
+    let attrs: HashSet<String> = match serde_json::from_str(&attrs)",18,2018-08-28 12:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211631766,https://github.com/hyperledger/indy-sdk/pull/1079#discussion_r211631766,AxelNennker
https://github.com/hyperledger/indy-sdk/pull/1079,https://github.com/hyperledger/indy-sdk/pull/1079,"Any estimate one when there will be a decision on the big question?

As I said in the description the PR I think that this greatly improves understanding for developers using the API.",073bfc46cdde5e7e6db3b61bcbb73724f93494aa,2018-08-22 14:11:51,211969220,"@@ -55,6 +57,21 @@ pub extern fn indy_issuer_create_schema(command_handle: i32,
 
     trace!(""indy_issuer_create_schema: entity >>> issuer_did: {:?}, name: {:?}, version: {:?}, attrs: {:?}"", issuer_did, name, version, attrs);
 
+    let attrs: HashSet<String> = match serde_json::from_str(&attrs)",18,2018-08-28 12:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211969220,https://github.com/hyperledger/indy-sdk/pull/1079#discussion_r211969220,AxelNennker
https://github.com/hyperledger/indy-sdk/pull/1079,https://github.com/hyperledger/indy-sdk/pull/1079,"In my vision we can call STATIC-only validation in API layer, but this validation must be defined in domain layer. I suggest the following:

- We can can define trait Validatable with one method validate() -> Result<(), Error> in utils/validation
- For each domain struct that requires static validation we can implement this trait
- We can define additional macro check_usefull_valid_json! that will also call validate method on domain struct

@jovfer @AxelNennker What do you think?

One addition that i suggest is to return position error instead of CommonInvalidStructure here, but we need consensus here as it is breaking change.",073bfc46cdde5e7e6db3b61bcbb73724f93494aa,2018-08-22 14:31:35,211976969,"@@ -55,6 +57,21 @@ pub extern fn indy_issuer_create_schema(command_handle: i32,
 
     trace!(""indy_issuer_create_schema: entity >>> issuer_did: {:?}, name: {:?}, version: {:?}, attrs: {:?}"", issuer_did, name, version, attrs);
 
+    let attrs: HashSet<String> = match serde_json::from_str(&attrs)",18,2018-08-28 12:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211976969,https://github.com/hyperledger/indy-sdk/pull/1079#discussion_r211976969,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1079,https://github.com/hyperledger/indy-sdk/pull/1079,Also we need consider to remove static validation from command and service layers in this case,073bfc46cdde5e7e6db3b61bcbb73724f93494aa,2018-08-22 14:33:00,211977524,"@@ -55,6 +57,21 @@ pub extern fn indy_issuer_create_schema(command_handle: i32,
 
     trace!(""indy_issuer_create_schema: entity >>> issuer_did: {:?}, name: {:?}, version: {:?}, attrs: {:?}"", issuer_did, name, version, attrs);
 
+    let attrs: HashSet<String> = match serde_json::from_str(&attrs)",18,2018-08-28 12:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211977524,https://github.com/hyperledger/indy-sdk/pull/1079#discussion_r211977524,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1079,https://github.com/hyperledger/indy-sdk/pull/1079,"I would do this step by step.

Before this PR the API checked for valid cstr which this PR keeps and should keep.
What this PR adds is adding `check_useful_json!` which uses `serde_json::from_str::<$t>(&$x)` to parse the json string $x to the domain type $t.

I think this validation is enough for this step.

Not sure about a new trait. I haven'd tried it but serde_json might be all we need already and then implement from_str for the domain type... which can do additional validation steps on the instance variable.

// What is position error? The api only returns error code and the callback too.",073bfc46cdde5e7e6db3b61bcbb73724f93494aa,2018-08-22 15:44:46,212006447,"@@ -55,6 +57,21 @@ pub extern fn indy_issuer_create_schema(command_handle: i32,
 
     trace!(""indy_issuer_create_schema: entity >>> issuer_did: {:?}, name: {:?}, version: {:?}, attrs: {:?}"", issuer_did, name, version, attrs);
 
+    let attrs: HashSet<String> = match serde_json::from_str(&attrs)",18,2018-08-28 12:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/212006447,https://github.com/hyperledger/indy-sdk/pull/1079#discussion_r212006447,AxelNennker
https://github.com/hyperledger/indy-sdk/pull/1069,https://github.com/hyperledger/indy-sdk/pull/1069,Better explanation of parameters is needed,fae602b1cc6ee3b95e02d522610603f7b03f6634,2018-08-20 12:22:38,211241793,"@@ -0,0 +1,95 @@
+extern crate libc;
+
+use self::libc::{c_void, c_char};
+
+use api::ErrorCode;
+
+extern crate time;
+extern crate log;
+
+use utils::logger::{EnabledCB, LogCB, FlushCB, init_indy_logger, init_default_logger, get_indy_logger};
+use utils::cstring::CStringUtils;
+
+/// Set custom logger implementation.
+///
+/// Allows library user to provide custom logger implementation as set of handlers.
+///
+/// #Params
+/// context: logger context",,2018-08-30 14:13:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211241793,https://github.com/hyperledger/indy-sdk/pull/1069#discussion_r211241793,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1069,https://github.com/hyperledger/indy-sdk/pull/1069,Why init_indy_logger returns non-Indy error code?,fae602b1cc6ee3b95e02d522610603f7b03f6634,2018-08-20 12:23:02,211241902,"@@ -0,0 +1,95 @@
+extern crate libc;
+
+use self::libc::{c_void, c_char};
+
+use api::ErrorCode;
+
+extern crate time;
+extern crate log;
+
+use utils::logger::{EnabledCB, LogCB, FlushCB, init_indy_logger, init_default_logger, get_indy_logger};
+use utils::cstring::CStringUtils;
+
+/// Set custom logger implementation.
+///
+/// Allows library user to provide custom logger implementation as set of handlers.
+///
+/// #Params
+/// context: logger context
+/// enabled: ""enabled"" operation handler (false positive if not specified)
+/// log: ""log"" operation handler
+/// flush: ""flush"" operation handler
+///
+/// #Returns
+/// Error code
+#[no_mangle]
+pub extern fn indy_set_logger(context: *const c_void,
+                              enabled: Option<EnabledCB>,
+                              log: Option<LogCB>,
+                              flush: Option<FlushCB>) -> ErrorCode {
+    trace!(""indy_set_logger >>> context: {:?}, enabled: {:?}, log: {:?}, flush: {:?}"", context, enabled, log, flush);
+
+    check_useful_c_callback!(log, ErrorCode::CommonInvalidParam3);
+
+    let res = match init_indy_logger(context, enabled, log, flush) {",,2018-08-30 14:13:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211241902,https://github.com/hyperledger/indy-sdk/pull/1069#discussion_r211241902,vimmerru
https://github.com/hyperledger/indy-sdk/pull/1069,https://github.com/hyperledger/indy-sdk/pull/1069,rename to smth like `filter` and describe the format,fae602b1cc6ee3b95e02d522610603f7b03f6634,2018-08-21 09:56:21,211547088,"@@ -0,0 +1,110 @@
+extern crate libc;
+extern crate time;
+extern crate log;
+
+use self::libc::{c_void, c_char};
+
+use api::ErrorCode;
+use errors::ToErrorCode;
+
+use utils::logger;
+use utils::logger::{EnabledCB, LogCB, FlushCB, IndyLogger, IndyDefaultLogger};
+use utils::cstring::CStringUtils;
+
+/// Set custom logger implementation.
+///
+/// Allows library user to provide custom logger implementation as set of handlers.
+///
+/// #Params
+/// context: logger context
+/// enabled: ""enabled"" operation handler (false positive if not specified)
+/// log: ""log"" operation handler
+/// flush: ""flush"" operation handler
+///
+/// #Returns
+/// Error code
+#[no_mangle]
+pub extern fn indy_set_logger(context: *const c_void,
+                              enabled: Option<EnabledCB>,
+                              log: Option<LogCB>,
+                              flush: Option<FlushCB>) -> ErrorCode {
+    trace!(""indy_set_logger >>> context: {:?}, enabled: {:?}, log: {:?}, flush: {:?}"", context, enabled, log, flush);
+
+    check_useful_c_callback!(log, ErrorCode::CommonInvalidParam3);
+
+    let result = IndyLogger::init(context, enabled, log, flush);
+
+    let res = result_to_err_code!(result);
+
+    trace!(""indy_set_logger: <<< res: {:?}"", res);
+
+    res
+}
+
+/// Set default logger implementation.
+///
+/// Allows library user use default ""environment"" logger implementation.
+///
+/// #Params
+/// level: min level of message to log",,2018-08-30 14:13:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211547088,https://github.com/hyperledger/indy-sdk/pull/1069#discussion_r211547088,jovfer
https://github.com/hyperledger/indy-sdk/pull/1069,https://github.com/hyperledger/indy-sdk/pull/1069,Import with renaming (mention of env_log crate),fae602b1cc6ee3b95e02d522610603f7b03f6634,2018-08-21 10:06:10,211549759,"@@ -3,46 +3,216 @@ extern crate log_panics;
 extern crate log;
 #[cfg(target_os = ""android"")]
 extern crate android_logger;
+extern crate libc;
 
 use self::env_logger::Builder;
-use self::log::LevelFilter;
+use self::log::{LevelFilter, Level};
 use std::env;
 use std::io::Write;
 #[cfg(target_os = ""android"")]
 use self::android_logger::Filter;
+use log::{Record, Metadata};
 
-pub struct LoggerUtils {}
+use self::libc::{c_void, c_char};
+use std::ffi::CString;
+use std::ptr;
+
+use errors::common::CommonError;
+use utils::cstring::CStringUtils;
+
+pub static mut LOGGER_STATE: LoggerState = LoggerState::Default;
+
+pub enum LoggerState {
+    Default,
+    Custom
+}
+
+pub type EnabledCB = extern fn(context: *const c_void,
+                               level: u32,
+                               target: *const c_char) -> bool;
+
+pub type LogCB = extern fn(context: *const c_void,
+                           level: u32,
+                           target: *const c_char,
+                           message: *const c_char,
+                           module_path: *const c_char,
+                           file: *const c_char,
+                           line: u32);
+
+pub type FlushCB = extern fn(context: *const c_void);
+
+pub static mut CONTEXT: *const c_void = ptr::null();
+pub static mut ENABLED_CB: Option<EnabledCB> = None;
+pub static mut LOG_CB: Option<LogCB> = None;
+pub static mut FLUSH_CB: Option<FlushCB> = None;
+
+pub struct IndyLogger {
+    context: *const c_void,
+    enabled: Option<EnabledCB>,
+    log: LogCB,
+    flush: Option<FlushCB>,
+}
+
+impl IndyLogger {
+    fn new(context: *const c_void, enabled: Option<EnabledCB>, log: LogCB, flush: Option<FlushCB>) -> Self {
+        IndyLogger { context, enabled, log, flush }
+    }
+}
+
+impl log::Log for IndyLogger {
+    fn enabled(&self, metadata: &Metadata) -> bool {
+        if let Some(enabled_cb) = self.enabled {
+            let level = metadata.level() as u32;
+            let target = CString::new(metadata.target()).unwrap();
+
+            enabled_cb(self.context,
+                       level,
+                       target.as_ptr(),
+            )
+        } else { true }
+    }
+
+    fn log(&self, record: &Record) {
+        let log_cb = self.log;
+
+        let level = record.level() as u32;
+        let target = CString::new(record.target()).unwrap();
+        let message = CString::new(record.args().to_string()).unwrap();
+
+        let module_path = record.module_path().map(|a| CString::new(a).unwrap());
+        let file = record.file().map(|a| CString::new(a).unwrap());
+        let line = record.line().unwrap_or(0);
+
+        log_cb(self.context,
+               level,
+               target.as_ptr(),
+               message.as_ptr(),
+               module_path.as_ref().map(|p| p.as_ptr()).unwrap_or(ptr::null()),
+               file.as_ref().map(|p| p.as_ptr()).unwrap_or(ptr::null()),
+               line,
+        )
+    }
+
+    fn flush(&self) {
+        if let Some(flush_cb) = self.flush {
+            flush_cb(self.context)
+        }
+    }
+}
+
+unsafe impl Sync for IndyLogger {}
+
+unsafe impl Send for IndyLogger {}
+
+impl IndyLogger {
+    pub fn init(context: *const c_void, enabled: Option<EnabledCB>, log: LogCB, flush: Option<FlushCB>) -> Result<(), CommonError> {
+        let logger = IndyLogger::new(context, enabled, log, flush);
+
+        log::set_boxed_logger(Box::new(logger))?;
+        log::set_max_level(LevelFilter::Trace);
+
+        unsafe {
+            LOGGER_STATE = LoggerState::Custom;
+            CONTEXT = context;
+            ENABLED_CB = enabled;
+            LOG_CB = Some(log);
+            FLUSH_CB = flush
+        };
+
+        Ok(())
+    }
+}
+
+pub struct IndyDefaultLogger;
+
+impl IndyDefaultLogger {
+    pub fn init(level: Option<String>) -> Result<(), CommonError> {
+        let level = level.or(env::var(""RUST_LOG"").ok());
 
-impl LoggerUtils {
-    pub fn init() {
         log_panics::init(); //Logging of panics is essential for android. As android does not log to stdout for native code
 
         if cfg!(target_os = ""android"") {
             #[cfg(target_os = ""android"")]
-            let log_filter = match env::var(""RUST_LOG"") {
-                Ok(val) => match val.to_lowercase().as_ref(){
+            let log_filter = match level {
+                Some(val) => match val.to_lowercase().as_ref() {
                     ""error"" => Filter::default().with_min_level(log::Level::Error),
                     ""warn"" => Filter::default().with_min_level(log::Level::Warn),
                     ""info"" => Filter::default().with_min_level(log::Level::Info),
                     ""debug"" => Filter::default().with_min_level(log::Level::Debug),
                     ""trace"" => Filter::default().with_min_level(log::Level::Trace),
                     _ => Filter::default().with_min_level(log::Level::Error),
                 },
-                Err(..) => Filter::default().with_min_level(log::Level::Error)
+                None => Filter::default().with_min_level(log::Level::Error)
             };
 
             //Set logging to off when deploying production android app.
             #[cfg(target_os = ""android"")]
-                android_logger::init_once(log_filter);
+            android_logger::init_once(log_filter);
             info!(""Logging for Android"");
         } else {
             Builder::new()",,2018-08-30 14:13:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211549759,https://github.com/hyperledger/indy-sdk/pull/1069#discussion_r211549759,jovfer
https://github.com/hyperledger/indy-sdk/pull/1069,https://github.com/hyperledger/indy-sdk/pull/1069,check with static linking,fae602b1cc6ee3b95e02d522610603f7b03f6634,2018-08-21 10:10:18,211550828,"@@ -1,50 +1,100 @@
-extern crate env_logger;
 extern crate log;
-extern crate log_panics;
-#[cfg(target_os = ""android"")]
-extern crate android_logger;
 
-use self::env_logger::Builder;
 use self::log::LevelFilter;
-use std::env;
-use std::io::Write;
-#[cfg(target_os = ""android"")]
-use self::android_logger::Filter;
-
-pub struct LoggerUtils {}
-
-impl LoggerUtils {
-    pub fn init() {
-        log_panics::init(); //Logging of panics is essential for android. As android does not log to stdout for native code
-        if cfg!(target_os = ""android"") {
-            #[cfg(target_os = ""android"")]
-            let log_filter = match env::var(""RUST_LOG"") {
-                Ok(val) => match val.to_lowercase().as_ref(){
-                    ""error"" => Filter::default().with_min_level(log::Level::Error),
-                    ""warn"" => Filter::default().with_min_level(log::Level::Warn),
-                    ""info"" => Filter::default().with_min_level(log::Level::Info),
-                    ""debug"" => Filter::default().with_min_level(log::Level::Debug),
-                    ""trace"" => Filter::default().with_min_level(log::Level::Trace),
-                    _ => Filter::default().with_min_level(log::Level::Error),
-                },
-                Err(..) => Filter::default().with_min_level(log::Level::Error)
-            };
-
-            //Set logging to off when deploying production android app.
-            #[cfg(target_os = ""android"")]
-                android_logger::init_once(log_filter);
-            info!(""Logging for Android"");
-        } else {
-            Builder::new()
-                .format(|buf, record| writeln!(buf, ""{:>5}|{:<30}|{:>35}:{:<4}| {}"", record.level(), record.target(), record.file().get_or_insert(""""), record.line().get_or_insert(0), record.args()))
-                .filter(None, LevelFilter::Off)
-                .parse(env::var(""RUST_LOG"").as_ref().map(String::as_str).unwrap_or(""""))
-                .try_init()
-                .ok();
+use libindy;
+use std::ffi::CString;
+use std::ptr;
+use log::{Record, Metadata};
+use libc::{c_void, c_char};
+use ErrorCode;
+
+pub type EnabledCB = extern fn(context: *const c_void,
+                               level: u32,
+                               target: *const c_char) -> bool;
+
+pub type LogCB = extern fn(context: *const c_void,
+                           level: u32,
+                           target: *const c_char,
+                           message: *const c_char,
+                           module_path: *const c_char,
+                           file: *const c_char,
+                           line: u32);
+
+pub type FlushCB = extern fn(context: *const c_void);
+
+pub struct IndyLogger {
+    context: *const c_void,
+    enabled: Option<EnabledCB>,
+    log: LogCB,
+    flush: Option<FlushCB>,
+}
+
+impl IndyLogger {
+    fn new(context: *const c_void, enabled: Option<EnabledCB>, log: LogCB, flush: Option<FlushCB>) -> Self {
+        IndyLogger { context, enabled, log, flush }
+    }
+
+    pub fn init() -> Result<(), ErrorCode> {
+        let (context, enabled, log, flush) = libindy::logger::get_indy_logger()?;
+
+        let log = match log {
+            Some(log) => log,
+            None => return Err(ErrorCode::CommonInvalidState)
+        };
+
+        let logger = IndyLogger::new(context, enabled, log, flush);
+
+        log::set_boxed_logger(Box::new(logger)).map_err(|_| ErrorCode::CommonInvalidState)?;",,2018-08-30 14:13:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211550828,https://github.com/hyperledger/indy-sdk/pull/1069#discussion_r211550828,jovfer
https://github.com/hyperledger/indy-sdk/pull/1069,https://github.com/hyperledger/indy-sdk/pull/1069,double-check,fae602b1cc6ee3b95e02d522610603f7b03f6634,2018-08-21 10:18:35,211553001,"@@ -73,12 +123,30 @@ macro_rules! _map_err {
 
 #[macro_export]
 macro_rules! map_err_err {
-    () => ( _map_err!(::log::LogLevel::Error) );
-    ($($arg:tt)*) => ( _map_err!(::log::LogLevel::Error, $($arg)*) )
+    () => ( _map_err!(::log::Level::Error) );",,2018-08-30 14:13:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/211553001,https://github.com/hyperledger/indy-sdk/pull/1069#discussion_r211553001,jovfer
https://github.com/hyperledger/indy-sdk/pull/1064,https://github.com/hyperledger/indy-sdk/pull/1064,May be it's better to use separate constant here? like for private keys.,bf12b0d6de8f4f9835eab41256b97174f5b3fd46,2018-08-15 08:47:17,210206390,"@@ -5,38 +5,40 @@ use errors::crypto::CryptoError;
 
 use self::libc::c_int;
 use self::sodiumoxide::crypto::sign;
+use self::sodiumoxide::crypto::box_;
 
 use utils::crypto::ed25519_box;
 use utils::crypto::randombytes::randombytes;
 
 pub const SEEDBYTES: usize = sign::SEEDBYTES;
 pub const PUBLICKEYBYTES: usize = sign::PUBLICKEYBYTES;
-pub const SECRETKEYBYTES: usize = sign::SECRETKEYBYTES;
+pub const SIG_SECRETKEYBYTES: usize = sign::SECRETKEYBYTES;
+pub const ENC_SECRETKEYBYTES: usize = box_::SECRETKEYBYTES;
 pub const SIGNATUREBYTES: usize = sign::SIGNATUREBYTES;
 
 sodium_type!(Seed, sign::Seed, SEEDBYTES);
 sodium_type!(PublicKey, sign::PublicKey, PUBLICKEYBYTES);
-sodium_type!(SecretKey, sign::SecretKey, SECRETKEYBYTES);
+sodium_type!(SecretKey, sign::SecretKey, SIG_SECRETKEYBYTES);
 sodium_type!(Signature, sign::Signature, SIGNATUREBYTES);
 
 extern {
     // TODO: fix hack:
     // this functions isn't included to sodiumoxide rust wrappers,
     // temporary local binding is used to call libsodium-sys function
     pub fn crypto_sign_ed25519_pk_to_curve25519(
-        curve25519_pk: *mut [u8; 32],
-        ed25519_pk: *const [u8; 32]) -> c_int;
+        curve25519_pk: *mut [u8; PUBLICKEYBYTES],
+        ed25519_pk: *const [u8; PUBLICKEYBYTES]) -> c_int;",,2018-08-15 09:22:15,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/210206390,https://github.com/hyperledger/indy-sdk/pull/1064#discussion_r210206390,jovfer
https://github.com/hyperledger/indy-sdk/pull/1064,https://github.com/hyperledger/indy-sdk/pull/1064,Changed,bf12b0d6de8f4f9835eab41256b97174f5b3fd46,2018-08-15 09:20:26,210214216,"@@ -5,38 +5,40 @@ use errors::crypto::CryptoError;
 
 use self::libc::c_int;
 use self::sodiumoxide::crypto::sign;
+use self::sodiumoxide::crypto::box_;
 
 use utils::crypto::ed25519_box;
 use utils::crypto::randombytes::randombytes;
 
 pub const SEEDBYTES: usize = sign::SEEDBYTES;
 pub const PUBLICKEYBYTES: usize = sign::PUBLICKEYBYTES;
-pub const SECRETKEYBYTES: usize = sign::SECRETKEYBYTES;
+pub const SIG_SECRETKEYBYTES: usize = sign::SECRETKEYBYTES;
+pub const ENC_SECRETKEYBYTES: usize = box_::SECRETKEYBYTES;
 pub const SIGNATUREBYTES: usize = sign::SIGNATUREBYTES;
 
 sodium_type!(Seed, sign::Seed, SEEDBYTES);
 sodium_type!(PublicKey, sign::PublicKey, PUBLICKEYBYTES);
-sodium_type!(SecretKey, sign::SecretKey, SECRETKEYBYTES);
+sodium_type!(SecretKey, sign::SecretKey, SIG_SECRETKEYBYTES);
 sodium_type!(Signature, sign::Signature, SIGNATUREBYTES);
 
 extern {
     // TODO: fix hack:
     // this functions isn't included to sodiumoxide rust wrappers,
     // temporary local binding is used to call libsodium-sys function
     pub fn crypto_sign_ed25519_pk_to_curve25519(
-        curve25519_pk: *mut [u8; 32],
-        ed25519_pk: *const [u8; 32]) -> c_int;
+        curve25519_pk: *mut [u8; PUBLICKEYBYTES],
+        ed25519_pk: *const [u8; PUBLICKEYBYTES]) -> c_int;",,2018-08-15 09:22:15,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/210214216,https://github.com/hyperledger/indy-sdk/pull/1064#discussion_r210214216,lovesh
https://github.com/hyperledger/indy-sdk/pull/1059,https://github.com/hyperledger/indy-sdk/pull/1059,false is default for boolean,3647740238ddf17dbf1104df26f547977ce3244f,2018-08-09 14:04:35,208941603,"@@ -14,16 +14,25 @@ pub struct Credentials {
     pub key: String,
     pub rekey: Option<String>,
     pub storage_credentials: Option<Value>,
+    #[serde(default = ""default_false"")]
+    pub simplified_security: bool,
+    #[serde(default = ""default_false"")]
+    pub rekey_simplified_security: bool
 }
 
 #[derive(Debug, Serialize, Deserialize)]
 pub struct ExportConfig {
     pub key: String,
     pub path: String,
+    #[serde(default = ""default_false"")]
+    pub simplified_security: bool
 }
 
 #[derive(Debug, Serialize, Deserialize)]
 pub struct Metadata {
     pub keys: Vec<u8>,
     pub master_key_salt: Vec<u8>,
-}
\ No newline at end of file
+}
+
+fn default_false() -> bool { false }",,2018-08-13 09:36:00,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/208941603,https://github.com/hyperledger/indy-sdk/pull/1059#discussion_r208941603,jovfer
https://github.com/hyperledger/indy-sdk/pull/1059,https://github.com/hyperledger/indy-sdk/pull/1059,typo,3647740238ddf17dbf1104df26f547977ce3244f,2018-08-09 14:04:46,208941665,"@@ -71,7 +80,7 @@ pub(super) fn export(wallet: &Wallet, writer: &mut Write, passphrase: &str, vers
     Ok(())
 }
 
-pub(super) fn import(wallet: &Wallet, reader: &mut Read, passphrase: &str) -> Result<(), WalletError> {
+pub(super) fn import(wallet: &Wallet, reader: &mut Read, passhrase: &str) -> Result<(), WalletError> {",,2018-08-13 09:36:00,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/208941665,https://github.com/hyperledger/indy-sdk/pull/1059#discussion_r208941665,jovfer
https://github.com/hyperledger/indy-sdk/pull/1059,https://github.com/hyperledger/indy-sdk/pull/1059,fix autoformat,3647740238ddf17dbf1104df26f547977ce3244f,2018-08-09 14:07:46,208942830,"@@ -33,8 +56,12 @@ pub struct Header {
 #[derive(Debug, Serialize, Deserialize)]
 pub struct Record {
     #[serde(rename = ""type"")]
-    pub type_: String, // Wallet record type
-    pub id: String, // Wallet record id
-    pub value: String, // Wallet record value
-    pub tags: HashMap<String, String>, // Wallet record tags
+    pub type_: String,
+    // Wallet record type",,2018-08-13 09:36:00,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/208942830,https://github.com/hyperledger/indy-sdk/pull/1059#discussion_r208942830,jovfer
https://github.com/hyperledger/indy-sdk/pull/1050,https://github.com/hyperledger/indy-sdk/pull/1050,Is it possible to use SerdeValue::Number here and call smth like `is_positive` for it?,03c27a56f69edcfa3e10de22324062ab2331ffd3,2018-08-08 13:39:15,208583761,"@@ -1301,7 +1301,7 @@ fn print_response_receipts(receipts: Option<Vec<serde_json::Value>>) -> Result<(
 }
 
 fn parse_payment_fees(fees: &Vec<&str>) -> Result<String, ()> {
-    let mut fees_map: HashMap<String, i32> = HashMap::new();
+    let mut fees_map: HashMap<String, u64> = HashMap::new();",14,2018-08-09 06:58:15,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/208583761,https://github.com/hyperledger/indy-sdk/pull/1050#discussion_r208583761,jovfer
https://github.com/hyperledger/indy-sdk/pull/1040,https://github.com/hyperledger/indy-sdk/pull/1040,invalid state can be handled below instead of this if,ec1229f20598316efd27647855e9aac30b5d2e9b,2018-08-07 13:31:11,208230252,"@@ -240,7 +240,6 @@ pub mod delete_command {
         let credentials: String = json!({ ""key"": key }).to_string();
 
         if let Some((_, opened_wallet_id)) = get_opened_wallet(&ctx) {
-            // TODO: Indy-Sdk allows delete opened wallet
             if id == opened_wallet_id {",,2018-08-08 12:20:51,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/208230252,https://github.com/hyperledger/indy-sdk/pull/1040#discussion_r208230252,jovfer
https://github.com/hyperledger/indy-sdk/pull/1040,https://github.com/hyperledger/indy-sdk/pull/1040,"re-check this, please",ec1229f20598316efd27647855e9aac30b5d2e9b,2018-08-07 13:33:54,208231263,"@@ -367,11 +367,6 @@ impl WalletService {
         }
     }
 
-    pub fn update_indy_record_tags<T>(&self, wallet_handle: i32, name: &str, tags: &HashMap<String, String>)",4,2018-08-08 12:20:51,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/208231263,https://github.com/hyperledger/indy-sdk/pull/1040#discussion_r208231263,jovfer
https://github.com/hyperledger/indy-sdk/pull/1040,https://github.com/hyperledger/indy-sdk/pull/1040,add `FIXME`,ec1229f20598316efd27647855e9aac30b5d2e9b,2018-08-07 13:35:32,208231819,"@@ -430,22 +425,15 @@ impl WalletService {
         self.search_records(wallet_handle, &self.add_prefix(T::short_type_name()), query_json, options_json)
     }
 
-    pub fn search_all_records(&self, wallet_handle: i32) -> Result<WalletSearch, WalletError> {
+    #[allow(dead_code)]",,2018-08-08 12:20:51,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/208231819,https://github.com/hyperledger/indy-sdk/pull/1040#discussion_r208231819,jovfer
https://github.com/hyperledger/indy-sdk/pull/1040,https://github.com/hyperledger/indy-sdk/pull/1040,move into mod,ec1229f20598316efd27647855e9aac30b5d2e9b,2018-08-07 13:39:52,208233482,"@@ -2,6 +2,7 @@ extern crate owning_ref;
 extern crate sodiumoxide;
 
 mod query;
+#[allow(dead_code)] // TODO: FIXME",,2018-08-08 12:20:51,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/208233482,https://github.com/hyperledger/indy-sdk/pull/1040#discussion_r208233482,jovfer
https://github.com/hyperledger/indy-sdk/pull/1028,https://github.com/hyperledger/indy-sdk/pull/1028,Right now it's main and recommended way to obtain local development pool. Why do you like to mark it as invalid?,14799f45c3aa4a683fdd30c0ebc289422166cbe0,2018-08-03 07:44:42,207465531,"@@ -164,6 +164,7 @@ It's good for development, but this build can be in 100+ times slower for some m
 If you would like to analyse CPU performance of libindy for your use case, you have to use release artifacts (`cargo build --release`). 
 
 ## How to start local nodes pool with docker
+THESE INSTRUCTIONS ARE NO LONGER VALID",,2018-08-09 08:15:53,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/207465531,https://github.com/hyperledger/indy-sdk/pull/1028#discussion_r207465531,jovfer
https://github.com/hyperledger/indy-sdk/pull/1028,https://github.com/hyperledger/indy-sdk/pull/1028,"It's better to put the link to this section ( 
https://github.com/hyperledger/indy-sdk/blob/master/README.md#how-to-start-local-nodes-pool-with-docker ) in other places (e.g. RHEL readme https://github.com/hyperledger/indy-sdk/blob/master/doc/rhel-build.md#starting-up )",14799f45c3aa4a683fdd30c0ebc289422166cbe0,2018-08-03 09:16:11,207487695,"@@ -164,6 +164,7 @@ It's good for development, but this build can be in 100+ times slower for some m
 If you would like to analyse CPU performance of libindy for your use case, you have to use release artifacts (`cargo build --release`). 
 
 ## How to start local nodes pool with docker
+THESE INSTRUCTIONS ARE NO LONGER VALID",,2018-08-09 08:15:53,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/207487695,https://github.com/hyperledger/indy-sdk/pull/1028#discussion_r207487695,jovfer
https://github.com/hyperledger/indy-sdk/pull/1010,https://github.com/hyperledger/indy-sdk/pull/1010,"@AxelNennker Please check it. Seems we need to manually add quotes.
For me, WALLET_CONFIG is `{ ""id"":Wallet1, ""storage_type"":default}`.",b4a82ad1e4c145c952cf9238bc18488773817567,2018-08-01 08:17:02,206791264,"@@ -56,28 +56,20 @@
 	protected String XYZ_SCHEMA_ATTRIBUTES = ""[\""status\"", \""period\""]"";
 	protected String REVOC_REG_TYPE = ""CL_ACCUM"";
 	protected String SIGNATURE_TYPE = ""CL"";
-	protected String TAILS_WRITER_CONFIG = new JSONObject(String.format(""{\""base_dir\"":\""%s\"", \""uri_pattern\"":\""\""}"", getIndyHomePath(""tails"")).replace('\\', '/')).toString();
+	protected String TAILS_WRITER_CONFIG =
+			""{ \""base_dir\"":"" +  getIndyHomePath(""tails"").replace('\\', '/') + "", \""uri_pattern\"":\""\""}"";
 	protected String REV_CRED_DEF_CONFIG = ""{\""support_revocation\"":true}"";
 	protected String GVT_CRED_VALUES = ""{\n"" +
 			""        \""sex\"": {\""raw\"": \""male\"", \""encoded\"": \""5944657099558967239210949258394887428692050081607692519917050\""},\n"" +
 			""        \""name\"": {\""raw\"": \""Alex\"", \""encoded\"": \""1139481716457488690172217916278103335\""},\n"" +
 			""        \""height\"": {\""raw\"": \""175\"", \""encoded\"": \""175\""},\n"" +
 			""        \""age\"": {\""raw\"": \""28\"", \""encoded\"": \""28\""}\n"" +
 			""    }"";
-	protected static final String WALLET_CONFIG =
-			new JSONObject()
-					.put(""id"", WALLET)
-					.put(""storage_type"", TYPE)
-					.toString();
-	protected static final String WALLET_CREDENTIALS =
-			new JSONObject()
-					.put(""key"", ""key"")
-					.toString();
-	protected static final String PLUGGED_WALLET_CONFIG =
-			new JSONObject()
-					.put(""id"", WALLET)
-					.put(""storage_type"", ""unknown_type"")
-					.toString();
+	protected static final String WALLET_CONFIG = ""{ \""id\"":"" + WALLET + "", \""storage_type\"":"" + TYPE + '}';",,2018-08-03 07:35:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/206791264,https://github.com/hyperledger/indy-sdk/pull/1010#discussion_r206791264,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/994,https://github.com/hyperledger/indy-sdk/pull/994,Please add more context,f879023317e0c4f0a76c6b6f31919ba7cc08ec8e,2018-10-08 08:59:40,223292000,"@@ -49,6 +49,10 @@ By default, this file creates in current folder and has the following name:
 2. [Install Indy-Cli](#binaries)
 3. Import generated file into libindy wallet by using Indy CLI
     * Run Indy CLI
+    * Recreate pool in Indy CLI",4,2018-10-08 08:59:45,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/223292000,https://github.com/hyperledger/indy-sdk/pull/994#discussion_r223292000,jovfer
https://github.com/hyperledger/indy-sdk/pull/988,https://github.com/hyperledger/indy-sdk/pull/988,Could you wrap randombytes to corresponded crypto utils module?,cef8cf465ea5df65e5e4e63b253004caef3b34a1,2018-07-26 11:59:29,205428788,"@@ -2,156 +2,69 @@ extern crate sodiumoxide;
 extern crate libc;
 
 use errors::common::CommonError;
+use errors::crypto::CryptoError;
 
-use self::libc::c_int;
 use self::sodiumoxide::crypto::box_;
-use self::sodiumoxide::crypto::sign;
-use self::sodiumoxide::randombytes;
-use utils::byte_array::_clone_into_array;
-
-extern {
-    // TODO: fix hack:
-    // this functions isn't included to sodiumoxide rust wrappers,
-    // temporary local binding is used to call libsodium-sys function
-    pub fn crypto_sign_ed25519_pk_to_curve25519(
-        curve25519_pk: *mut [u8; 32],
-        ed25519_pk: *const [u8; 32]) -> c_int;
-    pub fn crypto_sign_ed25519_sk_to_curve25519(
-        curve25519_sk: *mut [u8; 32],
-        ed25519_sk: *const [u8; 64]) -> c_int;
-}
+
+
+pub const NONCEBYTES: usize = box_::curve25519xsalsa20poly1305::NONCEBYTES;
+pub const PUBLICKEYBYTES: usize = box_::curve25519xsalsa20poly1305::PUBLICKEYBYTES;
+pub const SECRETKEYBYTES: usize = box_::curve25519xsalsa20poly1305::SECRETKEYBYTES;
+
+sodium_type!(Nonce, box_::Nonce, NONCEBYTES);
+sodium_type!(PublicKey, box_::PublicKey, PUBLICKEYBYTES);
+sodium_type!(SecretKey, box_::SecretKey, SECRETKEYBYTES);
 
 pub struct CryptoBox {}
 
 impl CryptoBox {
-    pub fn encrypt(private_key: &[u8], public_key: &[u8], doc: &[u8], nonce: &[u8]) -> Result<Vec<u8>, CommonError> {
-        if nonce.len() != 24 {
-            return Err(CommonError::InvalidStructure(""Invalid nonce"".to_string()))
-        }
-
+    pub fn encrypt(secret_key: &SecretKey, public_key: &PublicKey, doc: &[u8], nonce: &Nonce) -> Result<Vec<u8>, CryptoError> {
         Ok(box_::seal(
             doc,
-            &box_::Nonce(_clone_into_array(nonce)),
-            &box_::PublicKey(_clone_into_array(public_key)),
-            &box_::SecretKey(_clone_into_array(private_key))
+            &nonce.0,
+            &public_key.0,
+            &secret_key.0
         ))
     }
 
-    pub fn decrypt(private_key: &[u8], public_key: &[u8], doc: &[u8], nonce: &[u8]) -> Result<Vec<u8>, CommonError> {
-        if nonce.len() != 24 {
-            return Err(CommonError::InvalidStructure(""Invalid nonce"".to_string()))
-        }
-
+    pub fn decrypt(secret_key: &SecretKey, public_key: &PublicKey, doc: &[u8], nonce: &Nonce) -> Result<Vec<u8>, CryptoError> {
         box_::open(
             doc,
-            &box_::Nonce(_clone_into_array(nonce)),
-            &box_::PublicKey(_clone_into_array(public_key)),
-            &box_::SecretKey(_clone_into_array(private_key))
+            &nonce.0,
+            &public_key.0,
+            &secret_key.0
         )
-            .map_err(|err| CommonError::InvalidStructure(format!(""Unable to decrypt data: {:?}"", err)))
-    }
-
-    pub fn gen_nonce() -> Vec<u8> {
-        box_::gen_nonce()[..].to_vec()
-    }
-
-    pub fn create_key_pair_for_signature(seed: Option<&[u8]>) -> Result<(Vec<u8>, Vec<u8>), CommonError> {
-        if seed.is_some() && seed.unwrap().len() != 32 {
-            return Err(CommonError::InvalidStructure(""Invalid seed"".to_string()));
-        }
-
-        let (public_key, private_key) =
-            sign::keypair_from_seed(
-                &sign::Seed(
-                    _clone_into_array(
-                        seed.unwrap_or(&randombytes::randombytes(32)[..])
-                    )
-                )
-            );
-
-        Ok((public_key[..].to_vec(), private_key[..].to_vec()))
-    }
-
-    pub fn sign(private_key: &[u8], doc: &[u8]) -> Result<Vec<u8>, CommonError> {
-        if private_key.len() != 64 {
-            return Err(CommonError::InvalidStructure(""Invalid sign key"".to_string()));
-        }
-
-        let mut pr_key: [u8; 64] = [0; 64];
-        pr_key.clone_from_slice(private_key);
-
-        Ok(sign::sign_detached(
-            doc,
-            &sign::SecretKey(pr_key)
-        )[..].to_vec())
-    }
-
-    pub fn verify(public_key: &[u8], doc: &[u8], sign: &[u8]) -> Result<bool, CommonError> {
-        if sign.len() != 64 {
-            return Err(CommonError::InvalidStructure(""Invalid signature"".to_string()));
-        }
-
-        if public_key.len() != 32 {
-            return Err(CommonError::InvalidStructure(""Invalid verkey"".to_string()));
-        }
-
-        let mut signature: [u8; 64] = [0; 64];
-        signature.clone_from_slice(sign);
-
-        Ok(sign::verify_detached(
-            &sign::Signature(signature),
-            doc,
-            &sign::PublicKey(_clone_into_array(public_key))
-        ))
+            .map_err(|err|
+                CryptoError::CommonError(
+                    CommonError::InvalidStructure(format!(""Unable to decrypt data: {:?}"", err))))
     }
 
-    pub fn sk_to_curve25519(sk: &[u8]) -> Result<Vec<u8>, CommonError> {
-        if sk.len() != 64 {
-            return Err(CommonError::InvalidStructure(""Invalid signkey"".to_string()));
-        }
-
-        let mut from: [u8; 64] = [0; 64];
-        from.clone_from_slice(sk);
-        let mut to: [u8; 32] = [0; 32];
-        unsafe {
-            crypto_sign_ed25519_sk_to_curve25519(&mut to, &from);
-        }
-        Ok(to.iter().cloned().collect())
-    }
-
-    pub fn vk_to_curve25519(pk: &[u8]) -> Result<Vec<u8>, CommonError> {
-        if pk.len() != 32 {
-            return Err(CommonError::InvalidStructure(""Invalid verkey"".to_string()));
-        }
-
-        let mut from: [u8; 32] = [0; 32];
-        from.clone_from_slice(pk);
-        let mut to: [u8; 32] = [0; 32];
-        unsafe {
-            crypto_sign_ed25519_pk_to_curve25519(&mut to, &from);
-        }
-        Ok(to.iter().cloned().collect())
+    pub fn gen_nonce() -> Nonce {
+        Nonce(box_::gen_nonce())
     }
 }
 
 
 #[cfg(test)]
 mod tests {
     use super::*;
+    use self::sodiumoxide::randombytes;",,2018-07-30 12:34:08,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/205428788,https://github.com/hyperledger/indy-sdk/pull/988#discussion_r205428788,vimmerru
https://github.com/hyperledger/indy-sdk/pull/988,https://github.com/hyperledger/indy-sdk/pull/988,It seems like redundant struct. ,cef8cf465ea5df65e5e4e63b253004caef3b34a1,2018-07-26 12:01:14,205429220,"@@ -0,0 +1,118 @@
+extern crate sodiumoxide;
+extern crate libc;
+
+use errors::crypto::CryptoError;
+
+use self::libc::c_int;
+use self::sodiumoxide::crypto::sign;
+use self::sodiumoxide::randombytes;
+
+use utils::crypto::box_;
+
+pub const SEEDBYTES: usize = sign::SEEDBYTES;
+pub const PUBLICKEYBYTES: usize = sign::PUBLICKEYBYTES;
+pub const SECRETKEYBYTES: usize = sign::SECRETKEYBYTES;
+pub const SIGNATUREBYTES: usize = sign::SIGNATUREBYTES;
+
+sodium_type!(Seed, sign::Seed, SEEDBYTES);
+sodium_type!(PublicKey, sign::PublicKey, PUBLICKEYBYTES);
+sodium_type!(SecretKey, sign::SecretKey, SECRETKEYBYTES);
+sodium_type!(Signature, sign::Signature, SIGNATUREBYTES);
+
+extern {
+    // TODO: fix hack:
+    // this functions isn't included to sodiumoxide rust wrappers,
+    // temporary local binding is used to call libsodium-sys function
+    pub fn crypto_sign_ed25519_pk_to_curve25519(
+        curve25519_pk: *mut [u8; 32],
+        ed25519_pk: *const [u8; 32]) -> c_int;
+    pub fn crypto_sign_ed25519_sk_to_curve25519(
+        curve25519_sk: *mut [u8; 32],
+        ed25519_sk: *const [u8; 64]) -> c_int;
+}
+
+pub struct CryptoSign {}",,2018-07-30 12:34:08,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/205429220,https://github.com/hyperledger/indy-sdk/pull/988#discussion_r205429220,vimmerru
https://github.com/hyperledger/indy-sdk/pull/988,https://github.com/hyperledger/indy-sdk/pull/988,"This module should be called ed25519, but not sign. It is better to include other ed25519 related operations to this module.",cef8cf465ea5df65e5e4e63b253004caef3b34a1,2018-07-26 12:01:54,205429380,"@@ -0,0 +1,118 @@
+extern crate sodiumoxide;",,2018-07-30 12:34:08,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/205429380,https://github.com/hyperledger/indy-sdk/pull/988#discussion_r205429380,vimmerru
https://github.com/hyperledger/indy-sdk/pull/988,https://github.com/hyperledger/indy-sdk/pull/988,seems like out-date TODO,cef8cf465ea5df65e5e4e63b253004caef3b34a1,2018-07-31 09:52:20,206464360,"@@ -624,7 +628,8 @@ fn _get_nodes_and_remotes(merkle: &MerkleTree) -> Result<(HashMap<String, Option
 
         let remote = RemoteNode {
             name: node_alias.clone(),
-            public_key: CryptoBox::vk_to_curve25519(&node_verkey)?,
+            public_key: node_verkey[..].to_vec(),
+            // TODO:FIXME",37,2018-07-31 09:54:06,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/206464360,https://github.com/hyperledger/indy-sdk/pull/988#discussion_r206464360,jovfer
https://github.com/hyperledger/indy-sdk/pull/972,https://github.com/hyperledger/indy-sdk/pull/972,It is better to have in domain as changes can count backward compatibility problems,29ef340900db9de422058b586104533eea5669a5,2018-07-20 13:51:42,204051004,"@@ -465,6 +465,27 @@ impl PoolConfig {
     }
 }
 
+#[derive(Clone, Debug, Serialize, Deserialize)]
+pub struct PoolOpenConfig {",,2018-07-22 21:40:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/204051004,https://github.com/hyperledger/indy-sdk/pull/972#discussion_r204051004,vimmerru
https://github.com/hyperledger/indy-sdk/pull/972,https://github.com/hyperledger/indy-sdk/pull/972,As we decided to remove JsonEncodable it can be better to switch for plain serde call,29ef340900db9de422058b586104533eea5669a5,2018-07-20 13:53:22,204051557,"@@ -465,6 +465,27 @@ impl PoolConfig {
     }
 }
 
+#[derive(Clone, Debug, Serialize, Deserialize)]
+pub struct PoolOpenConfig {
+    #[serde(default)]
+    pub timeout: i64,
+    #[serde(default)]
+    pub extended_timeout: i64,
+}
+
+impl Default for PoolOpenConfig {
+    fn default() -> Self {
+        PoolOpenConfig {
+            timeout: super::networker::POOL_ACK_TIMEOUT,
+            extended_timeout: super::networker::POOL_REPLY_TIMEOUT,
+        }
+    }
+}
+
+impl JsonEncodable for PoolOpenConfig {}",,2018-07-22 21:40:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/204051557,https://github.com/hyperledger/indy-sdk/pull/972#discussion_r204051557,vimmerru
https://github.com/hyperledger/indy-sdk/pull/972,https://github.com/hyperledger/indy-sdk/pull/972,@vimmerru @dsurnin @ashcherbakov do you have more suggestions about items to configure?,29ef340900db9de422058b586104533eea5669a5,2018-07-20 14:17:19,204059152,"@@ -465,6 +465,30 @@ impl PoolConfig {
     }
 }
 
+#[derive(Clone, Debug, Serialize, Deserialize)]
+pub struct PoolOpenConfig {",,2018-07-22 21:40:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/204059152,https://github.com/hyperledger/indy-sdk/pull/972#discussion_r204059152,jovfer
https://github.com/hyperledger/indy-sdk/pull/972,https://github.com/hyperledger/indy-sdk/pull/972,"I suggest to avoid mixed state in master (partial removed `JsonEncodable`). If we decide to do something else with JsonEncodable against ""just remove"" it will be easy to replace all JsonEncodable at once.",29ef340900db9de422058b586104533eea5669a5,2018-07-22 20:55:49,204254677,"@@ -465,6 +465,27 @@ impl PoolConfig {
     }
 }
 
+#[derive(Clone, Debug, Serialize, Deserialize)]
+pub struct PoolOpenConfig {
+    #[serde(default)]
+    pub timeout: i64,
+    #[serde(default)]
+    pub extended_timeout: i64,
+}
+
+impl Default for PoolOpenConfig {
+    fn default() -> Self {
+        PoolOpenConfig {
+            timeout: super::networker::POOL_ACK_TIMEOUT,
+            extended_timeout: super::networker::POOL_REPLY_TIMEOUT,
+        }
+    }
+}
+
+impl JsonEncodable for PoolOpenConfig {}",,2018-07-22 21:40:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/204254677,https://github.com/hyperledger/indy-sdk/pull/972#discussion_r204254677,jovfer
https://github.com/hyperledger/indy-sdk/pull/968,https://github.com/hyperledger/indy-sdk/pull/968,this hash seems redundant as we use ChaCha20Poly1305IETF,d6d3fc0c0641ef1466a42d37730bb6a2b347b586,2018-07-19 15:17:43,203767659,"@@ -90,34 +90,64 @@ For deriving keys from passphrase **Argon2** memory-hard function is used with r
 
 ## File format
 
-File contains encrypted header and encrypted list of records using **ChaCha20-Poly1305-IETF** cypher in blocks per 1024 bytes (to allow streaming).
-This is similar encyption as recomended in libsodium secretstream but secretstream was not available in Rust wrapper.
-
-#### Header
-Header contains version of file format, time of creation, encryption method, nonce and salt used for encryption.
-
- * `header_length`: 2B unsigned big endian integer (length of encrypted header)
- * `version`: 4B unsigned big endian integer
- * `time`: 8B unsigned big endian integer
- * `encryption_method_length`: 2B unsigned big endian integer
- * `encryption_method`: UTF-8 string of `encryption_method_length` length
- * `nonce_length`: 2B unsigned big endian integer
- * `nonce`: bytes of length `nonce_length`, containing nonce for encryption of body. Nonce is then incremented for every block.
- * `salt_length`: 2B unsigned big endian integer
- * `salt`: bytes of length `salt_length`, containing salt used for deriving export key
- * `header_hash`: 32B **SHA-256** hash of the header.
-
-#### Body
-
-Body format is list of records in falowing format:
-
- * `record_length`: 4B unsigned big endian integer
- * `type_length`: 4B unsigned big endian integer
- * `type`: UTF-8 string of `type_length` bytes
- * `name_length`: 4B unsigned big endian integer
- * `name`: UTF-8 string of `name_length` bytes
- * `value_length`: 4B unsigned big endian integer
- * `value`: UTF-8 string of `value_length` bytes
- * `tags_json_length`: 4B unsigned big endian integer
- * `tags_json`: UTF-8 string of `tags_json_length` bytes
- 
\ No newline at end of file
+--- plain stream ---
+
+* `header_length`: length of the serialized header as 4b unsigned little endian integer
+* `header`: MessagePack serialized header entity
+* `header_hash`: 32B **SHA-256** hash of the header.
+
+--- encrypted stream ---
+
+* `record1_length`: length the serialized record as 4b unsigned little endian integer
+* `record1`: MessagePack serialized record entity
+* `record1_hash`: 32B **SHA-256** hash of the serialized record.",,2018-07-20 09:52:35,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/203767659,https://github.com/hyperledger/indy-sdk/pull/968#discussion_r203767659,jovfer
https://github.com/hyperledger/indy-sdk/pull/962,https://github.com/hyperledger/indy-sdk/pull/962,@Artemkaaas @vimmerru Is comment here correct?,723b0e10d98b4977c95923c68ba129ba80dafd9b,2018-07-18 14:24:18,203398956,"@@ -169,29 +170,29 @@ pub type BuildPaymentReqCB = extern fn(command_handle: i32,
 ///   Note: this param will be used to determine payment_method
 ///
 /// #Returns
-/// utxo_json - parsed (payment method and node version agnostic) utxo info as json:
+/// receipts_json - parsed (payment method and node version agnostic) receipts info as json:
 ///   [{
-///      txo: <str>, // UTXO input
-///      paymentAddress: <str>, //payment address for this UTXO
-///      amount: <int>, // amount of tokens in this input
+///      receipt: <str>, // source input",,2018-07-23 12:18:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/203398956,https://github.com/hyperledger/indy-sdk/pull/962#discussion_r203398956,jovfer
https://github.com/hyperledger/indy-sdk/pull/962,https://github.com/hyperledger/indy-sdk/pull/962,@Artemkaaas @vimmerru are we actually would like to remove the note about way to determine payment method?,723b0e10d98b4977c95923c68ba129ba80dafd9b,2018-07-18 14:27:16,203400149,"@@ -454,34 +455,31 @@ pub extern fn indy_list_payment_addresses(command_handle: i32,
 }
 
 /// Modifies Indy request by adding information how to pay fees for this transaction
-/// according to selected payment method.
-///
-/// Payment selection is performed by looking to o
+/// according to this payment method.
 ///
-/// This method consumes set of UTXO inputs and outputs. The difference between inputs balance
+/// This method consumes set of inputs and outputs. The difference between inputs balance
 /// and outputs balance is the fee for this transaction.
 ///
 /// Not that this method also produces correct fee signatures.
 ///
 /// Format of inputs is specific for payment method. Usually it should reference payment transaction
 /// with at least one output that corresponds to payment address that user owns.
 ///
+///
 /// Note this endpoint is EXPERIMENTAL. Function signature and behaviour may change
 /// in the future releases.
 ///
 /// #Params
 /// wallet_handle: wallet handle
 /// submitter_did : DID of request sender
 /// req_json: initial transaction request as json
-/// inputs_json: The list of UTXO inputs as json array:
-///   [""input1"", ...]
-///   Notes:
-///     - each input should reference paymentAddress
-///     - this param will be used to determine payment_method",,2018-07-23 12:18:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/203400149,https://github.com/hyperledger/indy-sdk/pull/962#discussion_r203400149,jovfer
https://github.com/hyperledger/indy-sdk/pull/962,https://github.com/hyperledger/indy-sdk/pull/962,@Artemkaaas @vimmerru Is comment here correct?,723b0e10d98b4977c95923c68ba129ba80dafd9b,2018-07-18 14:29:02,203400842,"@@ -770,11 +771,11 @@ pub extern fn indy_build_payment_req(command_handle: i32,
 ///   Note: this param will be used to determine payment_method
 ///
 /// #Returns
-/// utxo_json - parsed (payment method and node version agnostic) utxo info as json:
+/// receipts_json - parsed (payment method and node version agnostic) receipts info as json:
 ///   [{
-///      txo: <str>, // UTXO input
-///      paymentAddress: <str>, //payment address for this UTXO
-///      amount: <int>, // amount of tokens in this input
+///      receipt: <str>, // source input",,2018-07-23 12:18:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/203400842,https://github.com/hyperledger/indy-sdk/pull/962#discussion_r203400842,jovfer
https://github.com/hyperledger/indy-sdk/pull/962,https://github.com/hyperledger/indy-sdk/pull/962,"Should be

```
receipt: <str>, // receipt that can be used for payment referencing and verification
```",723b0e10d98b4977c95923c68ba129ba80dafd9b,2018-07-18 15:47:36,203431718,"@@ -169,29 +170,29 @@ pub type BuildPaymentReqCB = extern fn(command_handle: i32,
 ///   Note: this param will be used to determine payment_method
 ///
 /// #Returns
-/// utxo_json - parsed (payment method and node version agnostic) utxo info as json:
+/// receipts_json - parsed (payment method and node version agnostic) receipts info as json:
 ///   [{
-///      txo: <str>, // UTXO input
-///      paymentAddress: <str>, //payment address for this UTXO
-///      amount: <int>, // amount of tokens in this input
+///      receipt: <str>, // source input",,2018-07-23 12:18:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/203431718,https://github.com/hyperledger/indy-sdk/pull/962#discussion_r203431718,vimmerru
https://github.com/hyperledger/indy-sdk/pull/962,https://github.com/hyperledger/indy-sdk/pull/962,I suggest to keep it,723b0e10d98b4977c95923c68ba129ba80dafd9b,2018-07-18 15:47:53,203431831,"@@ -454,34 +455,31 @@ pub extern fn indy_list_payment_addresses(command_handle: i32,
 }
 
 /// Modifies Indy request by adding information how to pay fees for this transaction
-/// according to selected payment method.
-///
-/// Payment selection is performed by looking to o
+/// according to this payment method.
 ///
-/// This method consumes set of UTXO inputs and outputs. The difference between inputs balance
+/// This method consumes set of inputs and outputs. The difference between inputs balance
 /// and outputs balance is the fee for this transaction.
 ///
 /// Not that this method also produces correct fee signatures.
 ///
 /// Format of inputs is specific for payment method. Usually it should reference payment transaction
 /// with at least one output that corresponds to payment address that user owns.
 ///
+///
 /// Note this endpoint is EXPERIMENTAL. Function signature and behaviour may change
 /// in the future releases.
 ///
 /// #Params
 /// wallet_handle: wallet handle
 /// submitter_did : DID of request sender
 /// req_json: initial transaction request as json
-/// inputs_json: The list of UTXO inputs as json array:
-///   [""input1"", ...]
-///   Notes:
-///     - each input should reference paymentAddress
-///     - this param will be used to determine payment_method",,2018-07-23 12:18:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/203431831,https://github.com/hyperledger/indy-sdk/pull/962#discussion_r203431831,vimmerru
https://github.com/hyperledger/indy-sdk/pull/962,https://github.com/hyperledger/indy-sdk/pull/962,"receipt: <str>, // receipt that can be used for payment referencing and verification",723b0e10d98b4977c95923c68ba129ba80dafd9b,2018-07-18 15:48:01,203431882,"@@ -770,11 +771,11 @@ pub extern fn indy_build_payment_req(command_handle: i32,
 ///   Note: this param will be used to determine payment_method
 ///
 /// #Returns
-/// utxo_json - parsed (payment method and node version agnostic) utxo info as json:
+/// receipts_json - parsed (payment method and node version agnostic) receipts info as json:
 ///   [{
-///      txo: <str>, // UTXO input
-///      paymentAddress: <str>, //payment address for this UTXO
-///      amount: <int>, // amount of tokens in this input
+///      receipt: <str>, // source input",,2018-07-23 12:18:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/203431882,https://github.com/hyperledger/indy-sdk/pull/962#discussion_r203431882,vimmerru
https://github.com/hyperledger/indy-sdk/pull/962,https://github.com/hyperledger/indy-sdk/pull/962,"> amount of tokens

should be changed to just amount. Make sure that there is no ""token"" word at all.",723b0e10d98b4977c95923c68ba129ba80dafd9b,2018-07-18 15:51:38,203433072,"@@ -49,13 +49,13 @@ pub type CreatePaymentAddressCB = extern fn(command_handle: i32,
 /// wallet_handle: wallet handle
 /// submitter_did : DID of request sender
 /// req_json: initial transaction request as json
-/// inputs_json: The list of UTXO inputs as json array:
-///   [""input1"", ...]
-///   Note that each input should reference paymentAddress
-/// outputs_json: The list of UTXO outputs as json array:
+/// inputs_json: The list of payment sources as json array:
+///   [""source1"", ...]
+///   Note that each source should reference payment address
+/// outputs_json: The list of outputs as json array:
 ///   [{
-///     paymentAddress: <str>, // payment address used as output
-///     amount: <int>, // amount of tokens to transfer to this payment address
+///     recipient: <str>, // payment address of recipient
+///     amount: <int>, // amount of tokens to transfer to this recipient",,2018-07-23 12:18:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/203433072,https://github.com/hyperledger/indy-sdk/pull/962#discussion_r203433072,vimmerru
https://github.com/hyperledger/indy-sdk/pull/962,https://github.com/hyperledger/indy-sdk/pull/962,"receipt: <str>, // receipt that can be used for payment referencing and verification",723b0e10d98b4977c95923c68ba129ba80dafd9b,2018-07-18 15:53:05,203433574,"@@ -544,12 +542,15 @@ pub extern fn indy_add_request_fees(command_handle: i32,
 /// resp_json: response for Indy request with fees
 ///   Note: this param will be used to determine payment_method
 ///
+/// Note this endpoint is EXPERIMENTAL. Function signature and behaviour may change
+/// in the future releases.
+///
 /// #Returns
-/// utxo_json - parsed (payment method and node version agnostic) utxo info as json:
+/// receipts_json - parsed (payment method and node version agnostic) receipts info as json:
 ///   [{
-///      txo: <str>, // UTXO input
-///      paymentAddress: <str>, //payment address for this UTXO
-///      amount: <int>, // amount of tokens in this input
+///      receipt: <str>, // receipt",,2018-07-23 12:18:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/203433574,https://github.com/hyperledger/indy-sdk/pull/962#discussion_r203433574,vimmerru
https://github.com/hyperledger/indy-sdk/pull/962,https://github.com/hyperledger/indy-sdk/pull/962,We need to switch to libnullpay usage in samples instead of libsovplugin ,723b0e10d98b4977c95923c68ba129ba80dafd9b,2018-07-19 12:47:57,203712190,"@@ -94,7 +94,7 @@ pub mod load_plugin_command {
     command!(CommandMetadata::build(""load-plugin"", ""Load plugin in Libindy"")
                             .add_required_param(""library"", ""Name of plugin (can be absolute or relative path)"")
                             .add_required_param(""initializer"", ""Name of plugin init function"")
-                            .add_example(""load-plugin library=libsovtoken initializer=sovtoken_init"")
+                            .add_example(""load-plugin library=libsovplugin initializer=sovplugin_init"")",,2018-07-23 12:18:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/203712190,https://github.com/hyperledger/indy-sdk/pull/962#discussion_r203712190,vimmerru
https://github.com/hyperledger/indy-sdk/pull/959,https://github.com/hyperledger/indy-sdk/pull/959,What status of this TODO? Do we plan to merge it?,b624bc41c8b392ee8a2625bd74ab353773ad982b,2018-07-23 11:38:29,204369404,"@@ -383,6 +384,48 @@ def ubuntuTesting() {
     }
 }
 
+def androidTesting() {
+    def libindyVersion
+
+    node('ubuntu'){
+        stage('Android test'){
+            try{
+                echo 'Building android binaries. This will act as a minimal test for android'
+                checkout scm
+
+                libindyVersion = getSrcVersion(""libindy"")
+                def libnullpayVersion = getSrcVersion(""libnullpay"")
+                echo 'Building android binaries: Building docker image'
+                buildEnv = dockerHelpers.build('indy-sdk', 'libindy/ci/ubuntu.dockerfile libindy/ci')
+                sh 'chmod -R 777 libindy/'
+                sh 'chmod -R 777 libindy/ci/'
+
+                //TODO: Enable emulator test when the unit test start passing on android device",,2018-07-25 11:52:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/204369404,https://github.com/hyperledger/indy-sdk/pull/959#discussion_r204369404,jovfer
https://github.com/hyperledger/indy-sdk/pull/959,https://github.com/hyperledger/indy-sdk/pull/959,"Should we switch default log level for android from `Trace` to `Info` or `Off` below?
https://github.com/hyperledger/indy-sdk/pull/959/files#diff-5d11eb6aa67bd3369d836a1a7f0ca492R23
",b624bc41c8b392ee8a2625bd74ab353773ad982b,2018-07-23 11:54:58,204373448,"@@ -5,7 +5,7 @@ extern crate log;
 extern crate android_logger;
 
 use self::env_logger::Builder;
-use self::log::LevelFilter;
+use self::log::{Record, LevelFilter, Level};",,2018-07-25 11:52:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/204373448,https://github.com/hyperledger/indy-sdk/pull/959#discussion_r204373448,jovfer
https://github.com/hyperledger/indy-sdk/pull/959,https://github.com/hyperledger/indy-sdk/pull/959,"Several unit tests of libindy are failing on Android. I suspect these are failing mostly because of the unavailability of the internet permissions to binary. My effort was mainly focused on executing the tests on Android regardless of the outcome of the tests.
Because of the failing unit tests, I think these tests should not run on CD pipeline without fixing them. 
Also, I noticed it is taking more than an hour to execute tests on the emulator. I have tried with increased Ram on the emulator but it does not have much effect on the time to execute tests.",b624bc41c8b392ee8a2625bd74ab353773ad982b,2018-07-23 12:23:52,204380784,"@@ -383,6 +384,48 @@ def ubuntuTesting() {
     }
 }
 
+def androidTesting() {
+    def libindyVersion
+
+    node('ubuntu'){
+        stage('Android test'){
+            try{
+                echo 'Building android binaries. This will act as a minimal test for android'
+                checkout scm
+
+                libindyVersion = getSrcVersion(""libindy"")
+                def libnullpayVersion = getSrcVersion(""libnullpay"")
+                echo 'Building android binaries: Building docker image'
+                buildEnv = dockerHelpers.build('indy-sdk', 'libindy/ci/ubuntu.dockerfile libindy/ci')
+                sh 'chmod -R 777 libindy/'
+                sh 'chmod -R 777 libindy/ci/'
+
+                //TODO: Enable emulator test when the unit test start passing on android device",,2018-07-25 11:52:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/204380784,https://github.com/hyperledger/indy-sdk/pull/959#discussion_r204380784,faisal00813
https://github.com/hyperledger/indy-sdk/pull/959,https://github.com/hyperledger/indy-sdk/pull/959,We see significant degradation on iOS emulator with a large amount of logging. And there is a trace level in current android config. May be it's a similar issue?,b624bc41c8b392ee8a2625bd74ab353773ad982b,2018-07-23 12:41:44,204385471,"@@ -383,6 +384,48 @@ def ubuntuTesting() {
     }
 }
 
+def androidTesting() {
+    def libindyVersion
+
+    node('ubuntu'){
+        stage('Android test'){
+            try{
+                echo 'Building android binaries. This will act as a minimal test for android'
+                checkout scm
+
+                libindyVersion = getSrcVersion(""libindy"")
+                def libnullpayVersion = getSrcVersion(""libnullpay"")
+                echo 'Building android binaries: Building docker image'
+                buildEnv = dockerHelpers.build('indy-sdk', 'libindy/ci/ubuntu.dockerfile libindy/ci')
+                sh 'chmod -R 777 libindy/'
+                sh 'chmod -R 777 libindy/ci/'
+
+                //TODO: Enable emulator test when the unit test start passing on android device",,2018-07-25 11:52:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/204385471,https://github.com/hyperledger/indy-sdk/pull/959#discussion_r204385471,jovfer
https://github.com/hyperledger/indy-sdk/pull/959,https://github.com/hyperledger/indy-sdk/pull/959,Can we run some set of test (only `--lib` for example?) to be sure about this part of CI is working well,b624bc41c8b392ee8a2625bd74ab353773ad982b,2018-07-23 12:42:18,204385635,"@@ -383,6 +384,48 @@ def ubuntuTesting() {
     }
 }
 
+def androidTesting() {
+    def libindyVersion
+
+    node('ubuntu'){
+        stage('Android test'){
+            try{
+                echo 'Building android binaries. This will act as a minimal test for android'
+                checkout scm
+
+                libindyVersion = getSrcVersion(""libindy"")
+                def libnullpayVersion = getSrcVersion(""libnullpay"")
+                echo 'Building android binaries: Building docker image'
+                buildEnv = dockerHelpers.build('indy-sdk', 'libindy/ci/ubuntu.dockerfile libindy/ci')
+                sh 'chmod -R 777 libindy/'
+                sh 'chmod -R 777 libindy/ci/'
+
+                //TODO: Enable emulator test when the unit test start passing on android device",,2018-07-25 11:52:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/204385635,https://github.com/hyperledger/indy-sdk/pull/959#discussion_r204385635,jovfer
https://github.com/hyperledger/indy-sdk/pull/959,https://github.com/hyperledger/indy-sdk/pull/959,"BTW if you suspect, that the reason of failed tests is invalid permission in CI environment, the fix of this is must have part of creating the CI pipeline",b624bc41c8b392ee8a2625bd74ab353773ad982b,2018-07-23 12:48:39,204387365,"@@ -383,6 +384,48 @@ def ubuntuTesting() {
     }
 }
 
+def androidTesting() {
+    def libindyVersion
+
+    node('ubuntu'){
+        stage('Android test'){
+            try{
+                echo 'Building android binaries. This will act as a minimal test for android'
+                checkout scm
+
+                libindyVersion = getSrcVersion(""libindy"")
+                def libnullpayVersion = getSrcVersion(""libnullpay"")
+                echo 'Building android binaries: Building docker image'
+                buildEnv = dockerHelpers.build('indy-sdk', 'libindy/ci/ubuntu.dockerfile libindy/ci')
+                sh 'chmod -R 777 libindy/'
+                sh 'chmod -R 777 libindy/ci/'
+
+                //TODO: Enable emulator test when the unit test start passing on android device",,2018-07-25 11:52:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/204387365,https://github.com/hyperledger/indy-sdk/pull/959#discussion_r204387365,jovfer
https://github.com/hyperledger/indy-sdk/pull/959,https://github.com/hyperledger/indy-sdk/pull/959,If the reason is something else than it's may be critical blocker for publishing any artifacts for android.,b624bc41c8b392ee8a2625bd74ab353773ad982b,2018-07-23 12:50:13,204387828,"@@ -383,6 +384,48 @@ def ubuntuTesting() {
     }
 }
 
+def androidTesting() {
+    def libindyVersion
+
+    node('ubuntu'){
+        stage('Android test'){
+            try{
+                echo 'Building android binaries. This will act as a minimal test for android'
+                checkout scm
+
+                libindyVersion = getSrcVersion(""libindy"")
+                def libnullpayVersion = getSrcVersion(""libnullpay"")
+                echo 'Building android binaries: Building docker image'
+                buildEnv = dockerHelpers.build('indy-sdk', 'libindy/ci/ubuntu.dockerfile libindy/ci')
+                sh 'chmod -R 777 libindy/'
+                sh 'chmod -R 777 libindy/ci/'
+
+                //TODO: Enable emulator test when the unit test start passing on android device",,2018-07-25 11:52:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/204387828,https://github.com/hyperledger/indy-sdk/pull/959#discussion_r204387828,jovfer
https://github.com/hyperledger/indy-sdk/pull/959,https://github.com/hyperledger/indy-sdk/pull/959,@vimmerru FYI,b624bc41c8b392ee8a2625bd74ab353773ad982b,2018-07-23 12:51:04,204388045,"@@ -383,6 +384,48 @@ def ubuntuTesting() {
     }
 }
 
+def androidTesting() {
+    def libindyVersion
+
+    node('ubuntu'){
+        stage('Android test'){
+            try{
+                echo 'Building android binaries. This will act as a minimal test for android'
+                checkout scm
+
+                libindyVersion = getSrcVersion(""libindy"")
+                def libnullpayVersion = getSrcVersion(""libnullpay"")
+                echo 'Building android binaries: Building docker image'
+                buildEnv = dockerHelpers.build('indy-sdk', 'libindy/ci/ubuntu.dockerfile libindy/ci')
+                sh 'chmod -R 777 libindy/'
+                sh 'chmod -R 777 libindy/ci/'
+
+                //TODO: Enable emulator test when the unit test start passing on android device",,2018-07-25 11:52:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/204388045,https://github.com/hyperledger/indy-sdk/pull/959#discussion_r204388045,jovfer
https://github.com/hyperledger/indy-sdk/pull/959,https://github.com/hyperledger/indy-sdk/pull/959,@faisal00813 We need to understand why tests fail. Do you have logs?,b624bc41c8b392ee8a2625bd74ab353773ad982b,2018-07-23 13:05:38,204392592,"@@ -383,6 +384,48 @@ def ubuntuTesting() {
     }
 }
 
+def androidTesting() {
+    def libindyVersion
+
+    node('ubuntu'){
+        stage('Android test'){
+            try{
+                echo 'Building android binaries. This will act as a minimal test for android'
+                checkout scm
+
+                libindyVersion = getSrcVersion(""libindy"")
+                def libnullpayVersion = getSrcVersion(""libnullpay"")
+                echo 'Building android binaries: Building docker image'
+                buildEnv = dockerHelpers.build('indy-sdk', 'libindy/ci/ubuntu.dockerfile libindy/ci')
+                sh 'chmod -R 777 libindy/'
+                sh 'chmod -R 777 libindy/ci/'
+
+                //TODO: Enable emulator test when the unit test start passing on android device",,2018-07-25 11:52:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/204392592,https://github.com/hyperledger/indy-sdk/pull/959#discussion_r204392592,vimmerru
https://github.com/hyperledger/indy-sdk/pull/959,https://github.com/hyperledger/indy-sdk/pull/959,"After additional discussion I can suggest the next steps:
1) specify appropriate ticket in this comment, not just 
`//TODO ...` but `//TODO IS-XXX: ...`
2) consider this PR as minimal solution for Android CD - add appropriate comment in Jira (with the link to additional ticket)
3) Mark status of android builds as experimental until we have clear vision about the root of the problem",b624bc41c8b392ee8a2625bd74ab353773ad982b,2018-07-23 16:12:21,204464989,"@@ -383,6 +384,48 @@ def ubuntuTesting() {
     }
 }
 
+def androidTesting() {
+    def libindyVersion
+
+    node('ubuntu'){
+        stage('Android test'){
+            try{
+                echo 'Building android binaries. This will act as a minimal test for android'
+                checkout scm
+
+                libindyVersion = getSrcVersion(""libindy"")
+                def libnullpayVersion = getSrcVersion(""libnullpay"")
+                echo 'Building android binaries: Building docker image'
+                buildEnv = dockerHelpers.build('indy-sdk', 'libindy/ci/ubuntu.dockerfile libindy/ci')
+                sh 'chmod -R 777 libindy/'
+                sh 'chmod -R 777 libindy/ci/'
+
+                //TODO: Enable emulator test when the unit test start passing on android device",,2018-07-25 11:52:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/204464989,https://github.com/hyperledger/indy-sdk/pull/959#discussion_r204464989,jovfer
https://github.com/hyperledger/indy-sdk/pull/959,https://github.com/hyperledger/indy-sdk/pull/959,`$branchName` isn't required here,b624bc41c8b392ee8a2625bd74ab353773ad982b,2018-07-24 07:56:57,204657471,"@@ -0,0 +1,42 @@
+#!/bin/bash
+
+if [ ""$1"" = ""--help"" ] ; then
+  echo ""Usage: <architecture> <version> <key> <branchName> <number> <artifact_name> <is_stable>""
+  return
+fi
+
+arch=""$1""
+version=""$2""
+key=""$3""
+branchName=""$4""
+buildNumber=""$5""
+artifact=""$6""
+is_stable=""$7""
+
+[ -z $arch ] && exit 1
+[ -z $version ] && exit 2
+[ -z $key ] && exit 3
+[ -z $branchName ] && exit 4
+[ -z $buildNumber ] && exit 5
+[ -z $artifact ] && exit 6
+[ -z $is_stable ] && exit 7
+
+if [ ""${is_stable}"" == ""1"" ]; then
+    ssh -v -oStrictHostKeyChecking=no -i $key repo@192.168.11.115 mkdir -p /var/repository/repos/android/${artifact}/stable/${branchName}/${version}
+
+cat <<EOF | sftp -v -oStrictHostKeyChecking=no -i $key repo@192.168.11.115
+cd /var/repository/repos/android/${artifact}/stable/$branchName/$version",,2018-07-25 11:52:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/204657471,https://github.com/hyperledger/indy-sdk/pull/959#discussion_r204657471,jovfer
https://github.com/hyperledger/indy-sdk/pull/959,https://github.com/hyperledger/indy-sdk/pull/959,"please simplify this `if`
e.g.
```
if [ ""${is_stable}"" == ""1"" ]; then
 target_dir=...path1...
else
 target_dir=...path2...
fi
...
```",b624bc41c8b392ee8a2625bd74ab353773ad982b,2018-07-24 08:10:49,204661191,"@@ -0,0 +1,42 @@
+#!/bin/bash
+
+if [ ""$1"" = ""--help"" ] ; then
+  echo ""Usage: <architecture> <version> <key> <branchName> <number> <artifact_name> <is_stable>""
+  return
+fi
+
+arch=""$1""
+version=""$2""
+key=""$3""
+branchName=""$4""
+buildNumber=""$5""
+artifact=""$6""
+is_stable=""$7""
+
+[ -z $arch ] && exit 1
+[ -z $version ] && exit 2
+[ -z $key ] && exit 3
+[ -z $branchName ] && exit 4
+[ -z $buildNumber ] && exit 5
+[ -z $artifact ] && exit 6
+[ -z $is_stable ] && exit 7
+
+if [ ""${is_stable}"" == ""1"" ]; then",24,2018-07-25 11:52:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/204661191,https://github.com/hyperledger/indy-sdk/pull/959#discussion_r204661191,jovfer
https://github.com/hyperledger/indy-sdk/pull/959,https://github.com/hyperledger/indy-sdk/pull/959,"this call will results in full rebuild android artifacts from scratch. If I understand build script correctly, we can just use RC archive, rename it and publish to stable directory",b624bc41c8b392ee8a2625bd74ab353773ad982b,2018-07-24 09:36:31,204687772,"@@ -636,6 +761,9 @@ def publishingRCtoStable() {
                 echo 'Moving Ubuntu RC artifacts to Stable: libnullpay'
                 publishLibnullpayDebRCtoStable(testEnv)
 
+                echo 'Moving Android RC artifacts to Stable: libindy'
+                androidPublishing(""1"")",89,2018-07-25 11:52:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/204687772,https://github.com/hyperledger/indy-sdk/pull/959#discussion_r204687772,jovfer
https://github.com/hyperledger/indy-sdk/pull/959,https://github.com/hyperledger/indy-sdk/pull/959,Fixed!,b624bc41c8b392ee8a2625bd74ab353773ad982b,2018-07-25 08:11:52,205018397,"@@ -636,6 +761,9 @@ def publishingRCtoStable() {
                 echo 'Moving Ubuntu RC artifacts to Stable: libnullpay'
                 publishLibnullpayDebRCtoStable(testEnv)
 
+                echo 'Moving Android RC artifacts to Stable: libindy'
+                androidPublishing(""1"")",89,2018-07-25 11:52:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/205018397,https://github.com/hyperledger/indy-sdk/pull/959#discussion_r205018397,faisal00813
https://github.com/hyperledger/indy-sdk/pull/955,https://github.com/hyperledger/indy-sdk/pull/955,@JanLin @vimmerru I have some doubts: should it be separate file or a section in https://github.com/hyperledger/indy-sdk/blob/master/doc/getting-started/run-getting-started.md ?,a920d5f707c7a670d553d4f91c9d06d11d013855,2018-07-17 15:28:35,203068926,"@@ -0,0 +1,47 @@
+# TROUBLE SHOOTING Getting - Started Guide (GSG)",1,2018-07-18 16:19:35,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/203068926,https://github.com/hyperledger/indy-sdk/pull/955#discussion_r203068926,jovfer
https://github.com/hyperledger/indy-sdk/pull/955,https://github.com/hyperledger/indy-sdk/pull/955,"If we decide to keep this as separate file, I suggest to add links to it from
https://github.com/hyperledger/indy-sdk/blob/master/doc/getting-started/run-getting-started.md
and https://github.com/hyperledger/indy-sdk/blob/master/doc/getting-started/getting-started.md#explore-the-code",a920d5f707c7a670d553d4f91c9d06d11d013855,2018-07-17 15:32:19,203070353,"@@ -0,0 +1,47 @@
+# TROUBLE SHOOTING Getting - Started Guide (GSG)",1,2018-07-18 16:19:35,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/203070353,https://github.com/hyperledger/indy-sdk/pull/955#discussion_r203070353,jovfer
https://github.com/hyperledger/indy-sdk/pull/955,https://github.com/hyperledger/indy-sdk/pull/955,Good suggestion. I will add a links.,a920d5f707c7a670d553d4f91c9d06d11d013855,2018-07-17 15:36:30,203071999,"@@ -0,0 +1,47 @@
+# TROUBLE SHOOTING Getting - Started Guide (GSG)",1,2018-07-18 16:19:35,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/203071999,https://github.com/hyperledger/indy-sdk/pull/955#discussion_r203071999,JanLin
https://github.com/hyperledger/indy-sdk/pull/955,https://github.com/hyperledger/indy-sdk/pull/955,I have now made changes to the 2 files with new links.,a920d5f707c7a670d553d4f91c9d06d11d013855,2018-07-17 15:54:19,203078932,"@@ -0,0 +1,47 @@
+# TROUBLE SHOOTING Getting - Started Guide (GSG)",1,2018-07-18 16:19:35,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/203078932,https://github.com/hyperledger/indy-sdk/pull/955#discussion_r203078932,JanLin
https://github.com/hyperledger/indy-sdk/pull/940,https://github.com/hyperledger/indy-sdk/pull/940,We don't have filter now,125884fac45b24a16bb710c2cd59a95e98415731,2018-07-17 10:57:39,202978454,"@@ -446,33 +446,61 @@ pub extern fn indy_prover_store_credential(command_handle: i32,
 ```
 
 ```Rust
-/// Gets human readable credentials according to the filter.
-/// If filter is NULL, then all credentials are returned.
-/// Credentials can be filtered by Issuer, credential_def and/or Schema.
+/// Gets human readable credential by the given id.
 ///
 /// #Params
 /// wallet_handle: wallet handler (created by open_wallet).
-/// filter_json: filter for credentials
-///        {
-///            ""schema_id"": string, (Optional)
-///            ""schema_issuer_did"": string, (Optional)
-///            ""schema_name"": string, (Optional)
-///            ""schema_version"": string, (Optional)
-///            ""issuer_did"": string, (Optional)
-///            ""cred_def_id"": string, (Optional)
-///        }
+/// cred_id: Identifier by which requested credential is stored in the wallet
 /// cb: Callback that takes command result as parameter.
 ///
 /// #Returns
-/// credentials json
-///     [{
+/// credential json:
+///     {
 ///         ""referent"": string, // cred_id in the wallet
-///         ""values"": <see cred_values_json above>,
+///         ""attrs"": {""key1"":""raw_value1"", ""key2"":""raw_value2""},
 ///         ""schema_id"": string,
 ///         ""cred_def_id"": string,
 ///         ""rev_reg_id"": Optional<string>,
 ///         ""cred_rev_id"": Optional<string>
-///     }]
+///     }
+///
+/// #Errors
+/// Annoncreds*
+/// Common*
+/// Wallet*
+#[no_mangle]
+pub extern fn indy_prover_get_credential(command_handle: i32,
+                                         wallet_handle: i32,
+                                         cred_id: *const c_char,
+                                         cb: Option<extern fn(
+                                             xcommand_handle: i32, err: ErrorCode,
+                                             credential_json: *const c_char)>) -> ErrorCode
+```
+
+```Rust
+/// Gets human readable credentials according to the filter.
+/// If filter is NULL, then all credentials are returned.",,2018-07-17 12:23:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/202978454,https://github.com/hyperledger/indy-sdk/pull/940#discussion_r202978454,vimmerru
https://github.com/hyperledger/indy-sdk/pull/940,https://github.com/hyperledger/indy-sdk/pull/940,I believe it is important to add the note about encrypted and un-encrypted tags,125884fac45b24a16bb710c2cd59a95e98415731,2018-07-17 10:59:06,202978801,"@@ -0,0 +1,18 @@
+## Wallet Query Language
+
+This language will be used to define queries in Non-secrets, Anoncreds search APIs.",3,2018-07-17 12:23:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/202978801,https://github.com/hyperledger/indy-sdk/pull/940#discussion_r202978801,vimmerru
https://github.com/hyperledger/indy-sdk/pull/940,https://github.com/hyperledger/indy-sdk/pull/940,Do we need to remove filter_json here to keep backward compatibility?,125884fac45b24a16bb710c2cd59a95e98415731,2018-07-17 11:00:17,202979089,"@@ -795,133 +795,137 @@ pub extern fn indy_prover_store_credential(command_handle: i32,
     res
 }
 
-/// Gets human readable credentials according to the filter.
-/// If filter is NULL, then all credentials are returned.
-/// Credentials can be filtered by Issuer, credential_def and/or Schema.
-///
-/// NOTE: This method is deprecated. Use <indy_prover_open_credentials_search> instead.
+/// Gets human readable credential by the given id.
 ///
 /// #Params
 /// wallet_handle: wallet handler (created by open_wallet).
-/// filter_json: Wql style filter for credentials searching based on tags created during the saving of credential
+/// cred_id: Identifier by which requested credential is stored in the wallet
 /// cb: Callback that takes command result as parameter.
 ///
 /// #Returns
-/// credentials json
-///     [{
+/// credential json:
+///     {
 ///         ""referent"": string, // cred_id in the wallet
 ///         ""attrs"": {""key1"":""raw_value1"", ""key2"":""raw_value2""},
 ///         ""schema_id"": string,
 ///         ""cred_def_id"": string,
 ///         ""rev_reg_id"": Optional<string>,
 ///         ""cred_rev_id"": Optional<string>
-///     }]
+///     }
 ///
 /// #Errors
 /// Annoncreds*
 /// Common*
 /// Wallet*
 #[no_mangle]
-pub extern fn indy_prover_get_credentials(command_handle: i32,
-                                          wallet_handle: i32,
-                                          filter_json: *const c_char,
-                                          cb: Option<extern fn(
-                                              xcommand_handle: i32, err: ErrorCode,
-                                              matched_credentials_json: *const c_char)>) -> ErrorCode {
-    trace!(""indy_prover_get_credentials: >>> wallet_handle: {:?}, filter_json: {:?}"", wallet_handle, filter_json);
+pub extern fn indy_prover_get_credential(command_handle: i32,
+                                         wallet_handle: i32,
+                                         cred_id: *const c_char,
+                                         cb: Option<extern fn(
+                                             xcommand_handle: i32, err: ErrorCode,
+                                             credential_json: *const c_char)>) -> ErrorCode {
+    trace!(""indy_prover_get_credential: >>> wallet_handle: {:?}, cred_id: {:?}"", wallet_handle, cred_id);
 
-    check_useful_opt_c_str!(filter_json, ErrorCode::CommonInvalidParam3);
+    check_useful_c_str!(cred_id, ErrorCode::CommonInvalidParam3);
     check_useful_c_callback!(cb, ErrorCode::CommonInvalidParam4);
 
-    trace!(""indy_prover_get_credentials: entities >>> wallet_handle: {:?}, filter_json: {:?}"", wallet_handle, filter_json);
+    trace!(""indy_prover_get_credential: entities >>> wallet_handle: {:?}, cred_id: {:?}"", cred_id, cred_id);
 
     let result = CommandExecutor::instance()
         .send(Command::Anoncreds(
             AnoncredsCommand::Prover(
-                ProverCommand::GetCredentials(
+                ProverCommand::GetCredential(
                     wallet_handle,
-                    filter_json,
+                    cred_id,
                     Box::new(move |result| {
-                        let (err, matched_credentials_json) = result_to_err_code_1!(result, String::new());
-                        trace!(""indy_prover_get_credentials: matched_credentials_json: {:?}"", matched_credentials_json);
-                        let matched_credentials_json = CStringUtils::string_to_cstring(matched_credentials_json);
-                        cb(command_handle, err, matched_credentials_json.as_ptr())
+                        let (err, credential_json) = result_to_err_code_1!(result, String::new());
+                        trace!(""indy_prover_get_credential: credential_json: {:?}"", credential_json);
+                        let credential_json = CStringUtils::string_to_cstring(credential_json);
+                        cb(command_handle, err, credential_json.as_ptr())
                     })
                 ))));
 
     let res = result_to_err_code!(result);
 
-    trace!(""indy_prover_get_credentials: <<< res: {:?}"", res);
+    trace!(""indy_prover_get_credential: <<< res: {:?}"", res);
 
     res
 }
 
-/// Gets human readable credential by the given id.
+/// Gets human readable credentials according to the filter.
+/// If filter is NULL, then all credentials are returned.
+/// Credentials can be filtered by tags created during saving of credential.
+///
+/// NOTE: This method is deprecated because immediately returns all fetched credentials.
+/// Use <indy_prover_search_credentials> to fetch records by small batches.
 ///
 /// #Params
 /// wallet_handle: wallet handler (created by open_wallet).
-/// cred_id: Identifier by which requested credential is stored in the wallet
+/// filter_json: Wql style query for credentials searching based on tags.
+/// where query: indy-sdk/doc/design/011-wallet-query-language/README.md
 /// cb: Callback that takes command result as parameter.
 ///
 /// #Returns
-/// credential json
-///     {
+/// credentials json
+///     [{
 ///         ""referent"": string, // cred_id in the wallet
 ///         ""attrs"": {""key1"":""raw_value1"", ""key2"":""raw_value2""},
 ///         ""schema_id"": string,
 ///         ""cred_def_id"": string,
 ///         ""rev_reg_id"": Optional<string>,
 ///         ""cred_rev_id"": Optional<string>
-///     }
+///     }]
 ///
 /// #Errors
 /// Annoncreds*
 /// Common*
 /// Wallet*
 #[no_mangle]
-pub extern fn indy_prover_get_credential(command_handle: i32,
-                                         wallet_handle: i32,
-                                         cred_id: *const c_char,
-                                         cb: Option<extern fn(
-                                             xcommand_handle: i32, err: ErrorCode,
-                                             credential_json: *const c_char)>) -> ErrorCode {
-    trace!(""indy_prover_get_credential: >>> wallet_handle: {:?}, cred_id: {:?}"", wallet_handle, cred_id);
+pub extern fn indy_prover_get_credentials(command_handle: i32,
+                                          wallet_handle: i32,
+                                          filter_json: *const c_char,",,2018-07-17 12:23:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/202979089,https://github.com/hyperledger/indy-sdk/pull/940#discussion_r202979089,vimmerru
https://github.com/hyperledger/indy-sdk/pull/925,https://github.com/hyperledger/indy-sdk/pull/925,"You have two `n` characters. `<strinng>` instead of `<string>
`",1a45379230a9ae98618d51b19a73e36ac4dc6c0b,2018-07-05 13:05:24,200343788,"@@ -317,10 +286,10 @@ pub extern fn indy_list_wallets(command_handle: i32,
 ///
 /// #Params:
 /// wallet_handle: wallet handle returned by indy_open_wallet
-/// export_config_json: JSON containing settings for input operation.
+/// export_config: JSON containing settings for input operation.
 ///   {
-///     ""path"": path of the file that contains exported wallet content
-///     ""key"": passphrase used to derive export key
+///     ""path"": <strinng>, Path of the file that contains exported wallet content",334,2018-07-05 15:10:15,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/200343788,https://github.com/hyperledger/indy-sdk/pull/925#discussion_r200343788,donqui
https://github.com/hyperledger/indy-sdk/pull/925,https://github.com/hyperledger/indy-sdk/pull/925,"Thanks, will fix in the next PR",1a45379230a9ae98618d51b19a73e36ac4dc6c0b,2018-07-05 13:20:42,200348677,"@@ -317,10 +286,10 @@ pub extern fn indy_list_wallets(command_handle: i32,
 ///
 /// #Params:
 /// wallet_handle: wallet handle returned by indy_open_wallet
-/// export_config_json: JSON containing settings for input operation.
+/// export_config: JSON containing settings for input operation.
 ///   {
-///     ""path"": path of the file that contains exported wallet content
-///     ""key"": passphrase used to derive export key
+///     ""path"": <strinng>, Path of the file that contains exported wallet content",334,2018-07-05 15:10:15,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/200348677,https://github.com/hyperledger/indy-sdk/pull/925#discussion_r200348677,vimmerru
https://github.com/hyperledger/indy-sdk/pull/919,https://github.com/hyperledger/indy-sdk/pull/919,I suggest to move these lines into ci/android-zip-and-upload.sh script.,516ae1ee063082c641d96b0ccf711a04f35cc81b,2018-07-05 12:39:24,200336012,"@@ -558,6 +582,46 @@ def debPublishing(testEnv, directory, packageName, version, inStashName, outStas
     }
 }
 
+def buildAndroid(buildEnv,libIndyVersion) {
+
+    sh 'chmod -R 777 libindy/ci/'
+    ANDROID_SCRIPT_PATH = 'libindy/ci/buildAndroid.sh'
+    echo 'Building Libindy android files for arm'
+    buildEnv.inside {
+        sh ""./${ANDROID_SCRIPT_PATH} arm""
+    }
+    echo 'Publish Libindy android files for arm'
+    androidPublishArtifacts(buildEnv, libIndyVersion,""arm"" )
+
+    echo 'Building Libindy android files for x86'
+    buildEnv.inside {
+        sh ""./${ANDROID_SCRIPT_PATH} x86""
+    }
+    echo 'Publish Libindy android files for x86'
+    androidPublishArtifacts(buildEnv, libIndyVersion,""x86"" )
+
+    echo 'Building Libindy android files for arm64'
+    buildEnv.inside {
+        sh ""./${ANDROID_SCRIPT_PATH} arm64""
+    }
+    echo 'Publish Libindy android files for arm64'
+    androidPublishArtifacts(buildEnv, libIndyVersion,""arm64"" )
+
+}
+
+
+def androidPublishArtifacts(buildEnv, packageVersion,arch) {
+    buildEnv.inside {
+        sh 'chmod -R 777 ci'
+
+        withCredentials([file(credentialsId: 'SovrinRepoSSHKey', variable: 'repo_key')]) {
+//            Creating directory using SFTP is not working. Hence creating directory using ssh and files are uploaded using SFTP in ci/android-zip-and-upload.sh
+            sh ""ssh -v -oStrictHostKeyChecking=no -i '$repo_key' repo@192.168.11.115 mkdir -p /var/repository/repos/android/libindy/$env.BRANCH_NAME/$packageVersion-$env.BUILD_NUMBER""",,2018-07-18 13:24:46,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/200336012,https://github.com/hyperledger/indy-sdk/pull/919#discussion_r200336012,jovfer
https://github.com/hyperledger/indy-sdk/pull/887,https://github.com/hyperledger/indy-sdk/pull/887,"this is actually export-import test, so the other (export) test class is redundant
also, we should add a cleanup for created file(s)",f8528fed4af0bb94b8f5433a1058eb86bd7d88b9,2018-06-20 12:03:30,196747614,"@@ -0,0 +1,44 @@
+package org.hyperledger.indy.sdk.wallet;
+
+import org.hyperledger.indy.sdk.IOException;
+import org.hyperledger.indy.sdk.IndyIntegrationTestWithSingleWallet;
+import org.hyperledger.indy.sdk.did.Did;
+import org.junit.Test;
+
+import java.util.concurrent.ExecutionException;
+
+import static org.hamcrest.CoreMatchers.isA;
+import static org.junit.Assert.assertEquals;
+
+
+public class ImportWalletTest extends IndyIntegrationTestWithSingleWallet {",14,2018-06-20 12:04:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/196747614,https://github.com/hyperledger/indy-sdk/pull/887#discussion_r196747614,nveskovic
https://github.com/hyperledger/indy-sdk/pull/887,https://github.com/hyperledger/indy-sdk/pull/887,we should add a cleanup for created file(s),f8528fed4af0bb94b8f5433a1058eb86bd7d88b9,2018-06-20 12:04:04,196747759,"@@ -0,0 +1,35 @@
+package org.hyperledger.indy.sdk.wallet;
+
+import org.hyperledger.indy.sdk.IOException;
+import org.hyperledger.indy.sdk.IndyIntegrationTestWithSingleWallet;
+import org.hyperledger.indy.sdk.did.Did;
+import org.junit.Test;
+
+import java.io.File;
+import java.util.concurrent.ExecutionException;
+
+import static org.hamcrest.CoreMatchers.isA;
+import static org.junit.Assert.assertTrue;
+
+
+public class ExportWalletTest extends IndyIntegrationTestWithSingleWallet {",15,2018-06-20 12:04:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/196747759,https://github.com/hyperledger/indy-sdk/pull/887#discussion_r196747759,nveskovic
https://github.com/hyperledger/indy-sdk/pull/887,https://github.com/hyperledger/indy-sdk/pull/887,"maybe to add different types of records, not only dids, so we can make sure export/import works for diff record types",f8528fed4af0bb94b8f5433a1058eb86bd7d88b9,2018-06-20 12:06:07,196748249,"@@ -0,0 +1,44 @@
+package org.hyperledger.indy.sdk.wallet;
+
+import org.hyperledger.indy.sdk.IOException;
+import org.hyperledger.indy.sdk.IndyIntegrationTestWithSingleWallet;
+import org.hyperledger.indy.sdk.did.Did;
+import org.junit.Test;
+
+import java.util.concurrent.ExecutionException;
+
+import static org.hamcrest.CoreMatchers.isA;
+import static org.junit.Assert.assertEquals;
+
+
+public class ImportWalletTest extends IndyIntegrationTestWithSingleWallet {
+
+	@Test
+	public void testImportWalletWorks() throws Exception {
+		String did = Did.createAndStoreMyDid(wallet, ""{}"").get().getDid();",18,2018-06-20 12:06:08,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/196748249,https://github.com/hyperledger/indy-sdk/pull/887#discussion_r196748249,nveskovic
https://github.com/hyperledger/indy-sdk/pull/887,https://github.com/hyperledger/indy-sdk/pull/887,"@nveskovic We use one module per each API endpoint. It can cause some code duplication, but it is a warranty of formal proof for each endpoint.",f8528fed4af0bb94b8f5433a1058eb86bd7d88b9,2018-06-20 12:07:42,196748644,"@@ -0,0 +1,44 @@
+package org.hyperledger.indy.sdk.wallet;
+
+import org.hyperledger.indy.sdk.IOException;
+import org.hyperledger.indy.sdk.IndyIntegrationTestWithSingleWallet;
+import org.hyperledger.indy.sdk.did.Did;
+import org.junit.Test;
+
+import java.util.concurrent.ExecutionException;
+
+import static org.hamcrest.CoreMatchers.isA;
+import static org.junit.Assert.assertEquals;
+
+
+public class ImportWalletTest extends IndyIntegrationTestWithSingleWallet {",14,2018-06-20 12:07:42,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/196748644,https://github.com/hyperledger/indy-sdk/pull/887#discussion_r196748644,vimmerru
https://github.com/hyperledger/indy-sdk/pull/887,https://github.com/hyperledger/indy-sdk/pull/887,It cleanups the whole storage,f8528fed4af0bb94b8f5433a1058eb86bd7d88b9,2018-06-20 12:08:05,196748733,"@@ -0,0 +1,35 @@
+package org.hyperledger.indy.sdk.wallet;
+
+import org.hyperledger.indy.sdk.IOException;
+import org.hyperledger.indy.sdk.IndyIntegrationTestWithSingleWallet;
+import org.hyperledger.indy.sdk.did.Did;
+import org.junit.Test;
+
+import java.io.File;
+import java.util.concurrent.ExecutionException;
+
+import static org.hamcrest.CoreMatchers.isA;
+import static org.junit.Assert.assertTrue;
+
+
+public class ExportWalletTest extends IndyIntegrationTestWithSingleWallet {",15,2018-06-20 12:08:05,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/196748733,https://github.com/hyperledger/indy-sdk/pull/887#discussion_r196748733,vimmerru
https://github.com/hyperledger/indy-sdk/pull/887,https://github.com/hyperledger/indy-sdk/pull/887,"Wrappers test tests only wrappers, not libindy. You can check your tests approach in https://github.com/hyperledger/indy-sdk/blob/master/doc/test-design.md",f8528fed4af0bb94b8f5433a1058eb86bd7d88b9,2018-06-20 12:09:48,196749176,"@@ -0,0 +1,44 @@
+package org.hyperledger.indy.sdk.wallet;
+
+import org.hyperledger.indy.sdk.IOException;
+import org.hyperledger.indy.sdk.IndyIntegrationTestWithSingleWallet;
+import org.hyperledger.indy.sdk.did.Did;
+import org.junit.Test;
+
+import java.util.concurrent.ExecutionException;
+
+import static org.hamcrest.CoreMatchers.isA;
+import static org.junit.Assert.assertEquals;
+
+
+public class ImportWalletTest extends IndyIntegrationTestWithSingleWallet {
+
+	@Test
+	public void testImportWalletWorks() throws Exception {
+		String did = Did.createAndStoreMyDid(wallet, ""{}"").get().getDid();",18,2018-06-20 12:09:50,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/196749176,https://github.com/hyperledger/indy-sdk/pull/887#discussion_r196749176,vimmerru
https://github.com/hyperledger/indy-sdk/pull/887,https://github.com/hyperledger/indy-sdk/pull/887,"~by storage you mean whole `tmp` folder ?~

ok, ignore this, I've found this line
```
StorageUtils.cleanDirectory(tmpDir);
```",f8528fed4af0bb94b8f5433a1058eb86bd7d88b9,2018-06-20 12:24:34,196754312,"@@ -0,0 +1,35 @@
+package org.hyperledger.indy.sdk.wallet;
+
+import org.hyperledger.indy.sdk.IOException;
+import org.hyperledger.indy.sdk.IndyIntegrationTestWithSingleWallet;
+import org.hyperledger.indy.sdk.did.Did;
+import org.junit.Test;
+
+import java.io.File;
+import java.util.concurrent.ExecutionException;
+
+import static org.hamcrest.CoreMatchers.isA;
+import static org.junit.Assert.assertTrue;
+
+
+public class ExportWalletTest extends IndyIntegrationTestWithSingleWallet {",15,2018-06-20 12:25:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/196754312,https://github.com/hyperledger/indy-sdk/pull/887#discussion_r196754312,nveskovic
https://github.com/hyperledger/indy-sdk/pull/884,https://github.com/hyperledger/indy-sdk/pull/884,Rename key param to export_key,ff3d2026e7bf426b82160364496e81966e00906d,2018-06-19 14:59:53,196460849,"@@ -247,15 +247,108 @@ pub mod delete_command {
     }
 }
 
+pub mod export_command {
+    use super::*;
+
+    command!(CommandMetadata::build(""export"", ""Export opened wallet to the file"")
+                .add_required_param(""path"", ""Path to the export file"")
+                .add_required_deferred_param(""key"", ""Passphrase used to export key"")
+                .add_example(""wallet export path=/home/indy/export_wallet key=key"")",,2018-06-20 09:19:10,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/196460849,https://github.com/hyperledger/indy-sdk/pull/884#discussion_r196460849,vimmerru
https://github.com/hyperledger/indy-sdk/pull/884,https://github.com/hyperledger/indy-sdk/pull/884,Rename path param to export_path,ff3d2026e7bf426b82160364496e81966e00906d,2018-06-19 15:01:25,196461588,"@@ -247,15 +247,108 @@ pub mod delete_command {
     }
 }
 
+pub mod export_command {
+    use super::*;
+
+    command!(CommandMetadata::build(""export"", ""Export opened wallet to the file"")
+                .add_required_param(""path"", ""Path to the export file"")",,2018-06-20 09:19:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/196461588,https://github.com/hyperledger/indy-sdk/pull/884#discussion_r196461588,vimmerru
https://github.com/hyperledger/indy-sdk/pull/884,https://github.com/hyperledger/indy-sdk/pull/884,Rename file param to export_path,ff3d2026e7bf426b82160364496e81966e00906d,2018-06-19 15:02:31,196461998,"@@ -247,15 +247,108 @@ pub mod delete_command {
     }
 }
 
+pub mod export_command {
+    use super::*;
+
+    command!(CommandMetadata::build(""export"", ""Export opened wallet to the file"")
+                .add_required_param(""path"", ""Path to the export file"")
+                .add_required_deferred_param(""key"", ""Passphrase used to export key"")
+                .add_example(""wallet export path=/home/indy/export_wallet key=key"")
+                .finalize()
+    );
+
+    fn execute(ctx: &CommandContext, params: &CommandParams) -> Result<(), ()> {
+        trace!(""execute >> ctx {:?} params {:?}"", ctx, params);
+
+        let (wallet_handle, wallet_name) = ensure_opened_wallet(&ctx)?;
+
+        let path = get_str_param(""path"", params).map_err(error_err!())?;
+        let key = get_str_param(""key"", params).map_err(error_err!())?;
+
+        let export_config: String = json!({ ""path"": path.clone(), ""key"": key.clone() }).to_string();
+
+        trace!(""Wallet::export_wallet try: wallet_name {}, path {}, key {}"", wallet_name, path, key);
+
+        let res = Wallet::export_wallet(wallet_handle,
+                                        export_config.as_str());
+
+        trace!(""Wallet::export_wallet return: {:?}"", res);
+
+        let res = match res {
+            Ok(()) => Ok(println_succ!(""Wallet \""{}\"" has been exported to the file \""{}\"""", wallet_name, path)),
+            Err(ErrorCode::CommonIOError) => Err(println_err!(""Can not export Wallet: Path \""{}\"" is invalid or file already exists"", path)),
+            Err(err) => return Err(println_err!(""Indy SDK error occurred {:?}"", err)),
+        };
+
+        trace!(""execute << {:?}"", res);
+        res
+    }
+}
+
+
+pub mod import_command {
+    use super::*;
+
+    command!(CommandMetadata::build(""import"", ""Create new wallet and then import content from the specified file"")
+                .add_main_param(""name"", ""The name of new wallet"")
+                .add_required_param(""pool_name"", ""The name of associated Indy pool"")
+                .add_required_deferred_param(""key"", ""Auth key for the wallet"")
+                .add_required_param(""file"", ""Path to the file that contains exported wallet content"")",,2018-06-20 09:19:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/196461998,https://github.com/hyperledger/indy-sdk/pull/884#discussion_r196461998,vimmerru
https://github.com/hyperledger/indy-sdk/pull/884,https://github.com/hyperledger/indy-sdk/pull/884,Rename import_key to export_key,ff3d2026e7bf426b82160364496e81966e00906d,2018-06-19 15:02:58,196462195,"@@ -247,15 +247,108 @@ pub mod delete_command {
     }
 }
 
+pub mod export_command {
+    use super::*;
+
+    command!(CommandMetadata::build(""export"", ""Export opened wallet to the file"")
+                .add_required_param(""path"", ""Path to the export file"")
+                .add_required_deferred_param(""key"", ""Passphrase used to export key"")
+                .add_example(""wallet export path=/home/indy/export_wallet key=key"")
+                .finalize()
+    );
+
+    fn execute(ctx: &CommandContext, params: &CommandParams) -> Result<(), ()> {
+        trace!(""execute >> ctx {:?} params {:?}"", ctx, params);
+
+        let (wallet_handle, wallet_name) = ensure_opened_wallet(&ctx)?;
+
+        let path = get_str_param(""path"", params).map_err(error_err!())?;
+        let key = get_str_param(""key"", params).map_err(error_err!())?;
+
+        let export_config: String = json!({ ""path"": path.clone(), ""key"": key.clone() }).to_string();
+
+        trace!(""Wallet::export_wallet try: wallet_name {}, path {}, key {}"", wallet_name, path, key);
+
+        let res = Wallet::export_wallet(wallet_handle,
+                                        export_config.as_str());
+
+        trace!(""Wallet::export_wallet return: {:?}"", res);
+
+        let res = match res {
+            Ok(()) => Ok(println_succ!(""Wallet \""{}\"" has been exported to the file \""{}\"""", wallet_name, path)),
+            Err(ErrorCode::CommonIOError) => Err(println_err!(""Can not export Wallet: Path \""{}\"" is invalid or file already exists"", path)),
+            Err(err) => return Err(println_err!(""Indy SDK error occurred {:?}"", err)),
+        };
+
+        trace!(""execute << {:?}"", res);
+        res
+    }
+}
+
+
+pub mod import_command {
+    use super::*;
+
+    command!(CommandMetadata::build(""import"", ""Create new wallet and then import content from the specified file"")
+                .add_main_param(""name"", ""The name of new wallet"")
+                .add_required_param(""pool_name"", ""The name of associated Indy pool"")
+                .add_required_deferred_param(""key"", ""Auth key for the wallet"")
+                .add_required_param(""file"", ""Path to the file that contains exported wallet content"")
+                .add_required_deferred_param(""import_key"", ""Passphrase used to export key"")",,2018-06-20 09:19:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/196462195,https://github.com/hyperledger/indy-sdk/pull/884#discussion_r196462195,vimmerru
https://github.com/hyperledger/indy-sdk/pull/884,https://github.com/hyperledger/indy-sdk/pull/884,I am not sure if it is good idea to log export key?,ff3d2026e7bf426b82160364496e81966e00906d,2018-06-20 08:36:52,196691076,"@@ -247,15 +247,108 @@ pub mod delete_command {
     }
 }
 
+pub mod export_command {
+    use super::*;
+
+    command!(CommandMetadata::build(""export"", ""Export opened wallet to the file"")
+                .add_required_param(""export_path"", ""Path to the export file"")
+                .add_required_deferred_param(""export_key"", ""Passphrase used to derive export key"")
+                .add_example(""wallet export export_path=/home/indy/export_wallet export_key=key"")
+                .finalize()
+    );
+
+    fn execute(ctx: &CommandContext, params: &CommandParams) -> Result<(), ()> {
+        trace!(""execute >> ctx {:?} params {:?}"", ctx, params);
+
+        let (wallet_handle, wallet_name) = ensure_opened_wallet(&ctx)?;
+
+        let export_path = get_str_param(""export_path"", params).map_err(error_err!())?;
+        let export_key = get_str_param(""export_key"", params).map_err(error_err!())?;
+
+        let export_config: String = json!({ ""path"": export_path.clone(), ""key"": export_key.clone() }).to_string();
+
+        trace!(""Wallet::export_wallet try: wallet_name {}, export_path {}, export_key {}"", wallet_name, export_path, export_key);",,2018-06-20 09:19:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/196691076,https://github.com/hyperledger/indy-sdk/pull/884#discussion_r196691076,dkulic
https://github.com/hyperledger/indy-sdk/pull/884,https://github.com/hyperledger/indy-sdk/pull/884,Yeah it is a bad idea. I believe we have this logging problem not only in this place. ,ff3d2026e7bf426b82160364496e81966e00906d,2018-06-20 08:54:57,196696688,"@@ -247,15 +247,108 @@ pub mod delete_command {
     }
 }
 
+pub mod export_command {
+    use super::*;
+
+    command!(CommandMetadata::build(""export"", ""Export opened wallet to the file"")
+                .add_required_param(""export_path"", ""Path to the export file"")
+                .add_required_deferred_param(""export_key"", ""Passphrase used to derive export key"")
+                .add_example(""wallet export export_path=/home/indy/export_wallet export_key=key"")
+                .finalize()
+    );
+
+    fn execute(ctx: &CommandContext, params: &CommandParams) -> Result<(), ()> {
+        trace!(""execute >> ctx {:?} params {:?}"", ctx, params);
+
+        let (wallet_handle, wallet_name) = ensure_opened_wallet(&ctx)?;
+
+        let export_path = get_str_param(""export_path"", params).map_err(error_err!())?;
+        let export_key = get_str_param(""export_key"", params).map_err(error_err!())?;
+
+        let export_config: String = json!({ ""path"": export_path.clone(), ""key"": export_key.clone() }).to_string();
+
+        trace!(""Wallet::export_wallet try: wallet_name {}, export_path {}, export_key {}"", wallet_name, export_path, export_key);",,2018-06-20 09:19:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/196696688,https://github.com/hyperledger/indy-sdk/pull/884#discussion_r196696688,vimmerru
https://github.com/hyperledger/indy-sdk/pull/881,https://github.com/hyperledger/indy-sdk/pull/881,please restore this TODO comment (first part),30e7171c8d8c4ea7dee139b6518049be90d34211,2018-06-25 11:16:18,197759919,"@@ -583,7 +583,7 @@ impl WalletService {
         match self.open_wallet(name, None, credentials) {
             Err(err) => {
                 // Ignores the error, since there is nothing that can be done
-                self.delete_wallet(name, credentials).ok(); // TODO: why do we ignore thr result here?  ok is used to avoid warning
+                let _ = self.delete_wallet(name, credentials);",,2018-06-27 10:33:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/197759919,https://github.com/hyperledger/indy-sdk/pull/881#discussion_r197759919,jovfer
https://github.com/hyperledger/indy-sdk/pull/881,https://github.com/hyperledger/indy-sdk/pull/881,please restore this TODO comment (first part),30e7171c8d8c4ea7dee139b6518049be90d34211,2018-06-25 11:16:26,197759968,"@@ -593,7 +593,7 @@ impl WalletService {
                         match import(wallet, reader, &import_config.key) {
                             Ok(_) => Ok(()),
                             err @ Err(_) => {
-                                self.delete_wallet(name, credentials).ok();  // TODO: why do we ignore thr result here?  ok is used to avoid warning
+                                let _ = self.delete_wallet(name, credentials);",,2018-06-27 10:33:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/197759968,https://github.com/hyperledger/indy-sdk/pull/881#discussion_r197759968,jovfer
https://github.com/hyperledger/indy-sdk/pull/868,https://github.com/hyperledger/indy-sdk/pull/868,Do we use it in `LedgerStatus` as well?,72ee154ebba7d9ed69f2f34ee7463ee49dc36b7f,2018-06-13 08:44:43,195000052,"@@ -6,6 +6,8 @@ extern crate time;
 use self::indy_crypto::utils::json::JsonEncodable;
 
 
+const PROTOCOL_VERSION: u64 = 2;",,2018-06-17 06:30:59,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195000052,https://github.com/hyperledger/indy-sdk/pull/868#discussion_r195000052,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/868,https://github.com/hyperledger/indy-sdk/pull/868,No. I'll add,72ee154ebba7d9ed69f2f34ee7463ee49dc36b7f,2018-06-13 08:55:48,195003254,"@@ -6,6 +6,8 @@ extern crate time;
 use self::indy_crypto::utils::json::JsonEncodable;
 
 
+const PROTOCOL_VERSION: u64 = 2;",,2018-06-17 06:30:59,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195003254,https://github.com/hyperledger/indy-sdk/pull/868#discussion_r195003254,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/868,https://github.com/hyperledger/indy-sdk/pull/868,I believe we need better description,72ee154ebba7d9ed69f2f34ee7463ee49dc36b7f,2018-06-13 14:02:53,195094094,"@@ -27,6 +28,7 @@ impl fmt::Display for PoolError {
             PoolError::Terminate => write!(f, ""Pool work terminated""),
             PoolError::Timeout => write!(f, ""Timeout""),
             PoolError::AlreadyExists(ref description) => write!(f, ""Pool ledger config already exists {}"", description),
+            PoolError::Outdated => write!(f, ""Outdated""),",,2018-06-17 06:30:59,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195094094,https://github.com/hyperledger/indy-sdk/pull/868#discussion_r195094094,vimmerru
https://github.com/hyperledger/indy-sdk/pull/868,https://github.com/hyperledger/indy-sdk/pull/868,I believe create_pool_ledger_config should rise an error,72ee154ebba7d9ed69f2f34ee7463ee49dc36b7f,2018-06-13 14:06:17,195095471,"@@ -415,6 +415,25 @@ mod medium_cases {
 
             TestUtils::cleanup_storage();
         }
+
+        #[test]
+        fn create_pool_ledger_config_works_for_outdated_genesis_transactions() {
+            TestUtils::cleanup_storage();
+
+            let txn_file_data = r#""
+                {""data"":{""alias"":""Node1"",""client_ip"":""192.168.1.35"",""client_port"":9702,""node_ip"":""192.168.1.35"",""node_port"":9701,""services"":[""VALIDATOR""]},""dest"":""Gw6pDLhcBcoQesN72qfotTgFa7cbuqZpkX3Xo6pLhPhv"",""identifier"":""FYmoFw55GeQH7SRFa37dkx1d2dZ3zUF8ckg7wmL7ofN4"",""txnId"":""fea82e10e894419fe2bea7d96296a6d46f50f93f9eeda954ec461b2ed2950b62"",""type"":""0""}
+                {""data"":{""alias"":""Node2"",""client_ip"":""192.168.1.35"",""client_port"":9704,""node_ip"":""192.168.1.35"",""node_port"":9703,""services"":[""VALIDATOR""]},""dest"":""8ECVSk179mjsjKRLWiQtssMLgp6EPhWXtaYyStWPSGAb"",""identifier"":""8QhFxKxyaFsJy4CyxeYX34dFH8oWqyBv1P4HLQCsoeLy"",""txnId"":""1ac8aece2a18ced660fef8694b61aac3af08ba875ce3026a160acbc3a3af35fc"",""type"":""0""}""#;
+
+            let pool_name = ""create_pool_ledger_config_works_for_outdated_genesis_transactions"";
+            let txn_file_path = PoolUtils::create_genesis_txn_file(pool_name, &txn_file_data, None);
+            let pool_config = PoolUtils::pool_config_json(txn_file_path.as_path());
+            PoolUtils::create_pool_ledger_config(pool_name, Some(pool_config.as_str())).unwrap();",,2018-06-17 06:30:59,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195095471,https://github.com/hyperledger/indy-sdk/pull/868#discussion_r195095471,vimmerru
https://github.com/hyperledger/indy-sdk/pull/850,https://github.com/hyperledger/indy-sdk/pull/850,I really don't understand how adding version to output param of public API can help in backward compatibility? Could you provide an example? ,dc1583f6fa47a540fbfc257619a61ad65d59a0b2,2018-06-07 14:41:31,193772038,"@@ -441,11 +441,16 @@ pub extern fn indy_add_request_fees(command_handle: i32,
 ///
 /// #Returns
 /// utxo_json - parsed (payment method and node version agnostic) utxo info as json:
-///   [{
-///      input: <str>, // UTXO input
-///      amount: <int>, // amount of tokens in this input
-///      extra: <str>, // optional data from payment transaction
-///   }]
+/// {
+///     ""ver"": <int>,                    // this field is included to allow for future backward compatability",10,2018-06-07 14:41:32,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193772038,https://github.com/hyperledger/indy-sdk/pull/850#discussion_r193772038,vimmerru
https://github.com/hyperledger/indy-sdk/pull/850,https://github.com/hyperledger/indy-sdk/pull/850,"If for some reason the format of the txo string must change, the version would allow us to be compatible with old format. Same reason as adding version to ledger transaction.",dc1583f6fa47a540fbfc257619a61ad65d59a0b2,2018-06-07 15:14:06,193784683,"@@ -441,11 +441,16 @@ pub extern fn indy_add_request_fees(command_handle: i32,
 ///
 /// #Returns
 /// utxo_json - parsed (payment method and node version agnostic) utxo info as json:
-///   [{
-///      input: <str>, // UTXO input
-///      amount: <int>, // amount of tokens in this input
-///      extra: <str>, // optional data from payment transaction
-///   }]
+/// {
+///     ""ver"": <int>,                    // this field is included to allow for future backward compatability",10,2018-06-07 15:14:06,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193784683,https://github.com/hyperledger/indy-sdk/pull/850#discussion_r193784683,brentzundel
https://github.com/hyperledger/indy-sdk/pull/850,https://github.com/hyperledger/indy-sdk/pull/850,Consumer of this API is 3d party application. What application will do with this version?,dc1583f6fa47a540fbfc257619a61ad65d59a0b2,2018-06-07 15:16:14,193785479,"@@ -441,11 +441,16 @@ pub extern fn indy_add_request_fees(command_handle: i32,
 ///
 /// #Returns
 /// utxo_json - parsed (payment method and node version agnostic) utxo info as json:
-///   [{
-///      input: <str>, // UTXO input
-///      amount: <int>, // amount of tokens in this input
-///      extra: <str>, // optional data from payment transaction
-///   }]
+/// {
+///     ""ver"": <int>,                    // this field is included to allow for future backward compatability",10,2018-06-07 15:16:15,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193785479,https://github.com/hyperledger/indy-sdk/pull/850#discussion_r193785479,vimmerru
https://github.com/hyperledger/indy-sdk/pull/850,https://github.com/hyperledger/indy-sdk/pull/850,Do you expect that application should have the code that will work with different versions?,dc1583f6fa47a540fbfc257619a61ad65d59a0b2,2018-06-07 15:17:25,193785945,"@@ -441,11 +441,16 @@ pub extern fn indy_add_request_fees(command_handle: i32,
 ///
 /// #Returns
 /// utxo_json - parsed (payment method and node version agnostic) utxo info as json:
-///   [{
-///      input: <str>, // UTXO input
-///      amount: <int>, // amount of tokens in this input
-///      extra: <str>, // optional data from payment transaction
-///   }]
+/// {
+///     ""ver"": <int>,                    // this field is included to allow for future backward compatability",10,2018-06-07 15:17:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193785945,https://github.com/hyperledger/indy-sdk/pull/850#discussion_r193785945,vimmerru
https://github.com/hyperledger/indy-sdk/pull/850,https://github.com/hyperledger/indy-sdk/pull/850,"Also what app should do with unknown version (it supports v1 and v2, but received v3 after libindy update)? Crash? ",dc1583f6fa47a540fbfc257619a61ad65d59a0b2,2018-06-07 15:46:41,193796927,"@@ -441,11 +441,16 @@ pub extern fn indy_add_request_fees(command_handle: i32,
 ///
 /// #Returns
 /// utxo_json - parsed (payment method and node version agnostic) utxo info as json:
-///   [{
-///      input: <str>, // UTXO input
-///      amount: <int>, // amount of tokens in this input
-///      extra: <str>, // optional data from payment transaction
-///   }]
+/// {
+///     ""ver"": <int>,                    // this field is included to allow for future backward compatability",10,2018-06-07 15:46:42,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193796927,https://github.com/hyperledger/indy-sdk/pull/850#discussion_r193796927,vimmerru
https://github.com/hyperledger/indy-sdk/pull/850,https://github.com/hyperledger/indy-sdk/pull/850,"Our thinking is that the version number allows LibSovToken to make non-breaking changes. Updates to libindy should not affect version number, only updates to libsovtoken.
The version number allows the 3rd party app to use saved txo strings from previous versions of libsovtoken in a non-breaking way.
Is there is a better way to do this? Or do you think this does not need to be done?",dc1583f6fa47a540fbfc257619a61ad65d59a0b2,2018-06-07 15:58:35,193801646,"@@ -441,11 +441,16 @@ pub extern fn indy_add_request_fees(command_handle: i32,
 ///
 /// #Returns
 /// utxo_json - parsed (payment method and node version agnostic) utxo info as json:
-///   [{
-///      input: <str>, // UTXO input
-///      amount: <int>, // amount of tokens in this input
-///      extra: <str>, // optional data from payment transaction
-///   }]
+/// {
+///     ""ver"": <int>,                    // this field is included to allow for future backward compatability",10,2018-06-07 15:58:35,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193801646,https://github.com/hyperledger/indy-sdk/pull/850#discussion_r193801646,brentzundel
https://github.com/hyperledger/indy-sdk/pull/850,https://github.com/hyperledger/indy-sdk/pull/850,"If you want ""txo strings"" to be compatible than you need to add version to ""txo string"". How adding the version to utxo_json can help with this? 

Also you don't need the version  in ""txo string"" right now, as absence of version means version 0. 

For example:

```
txo:sov:asdasdasd@1 - version 0
txo:sov:asdasdasd@1_v1 - version 1
```",dc1583f6fa47a540fbfc257619a61ad65d59a0b2,2018-06-07 16:05:27,193804184,"@@ -441,11 +441,16 @@ pub extern fn indy_add_request_fees(command_handle: i32,
 ///
 /// #Returns
 /// utxo_json - parsed (payment method and node version agnostic) utxo info as json:
-///   [{
-///      input: <str>, // UTXO input
-///      amount: <int>, // amount of tokens in this input
-///      extra: <str>, // optional data from payment transaction
-///   }]
+/// {
+///     ""ver"": <int>,                    // this field is included to allow for future backward compatability",10,2018-06-07 16:05:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193804184,https://github.com/hyperledger/indy-sdk/pull/850#discussion_r193804184,vimmerru
https://github.com/hyperledger/indy-sdk/pull/850,https://github.com/hyperledger/indy-sdk/pull/850,Format of utxo_json also isn't under libsovtoken control at all. All you can control is format of txo strings,dc1583f6fa47a540fbfc257619a61ad65d59a0b2,2018-06-07 16:06:31,193804536,"@@ -441,11 +441,16 @@ pub extern fn indy_add_request_fees(command_handle: i32,
 ///
 /// #Returns
 /// utxo_json - parsed (payment method and node version agnostic) utxo info as json:
-///   [{
-///      input: <str>, // UTXO input
-///      amount: <int>, // amount of tokens in this input
-///      extra: <str>, // optional data from payment transaction
-///   }]
+/// {
+///     ""ver"": <int>,                    // this field is included to allow for future backward compatability",10,2018-06-07 16:06:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193804536,https://github.com/hyperledger/indy-sdk/pull/850#discussion_r193804536,vimmerru
https://github.com/hyperledger/indy-sdk/pull/850,https://github.com/hyperledger/indy-sdk/pull/850,"That is a good point. If we want to version the txo strings, we should do so inside of them. I agree that version should not be a part of utxo_json for libsovtoken.
Do you think that there may be a need for version number as part of utxo_json for libindy? what if structure of uxto_json changes in breaking way?",dc1583f6fa47a540fbfc257619a61ad65d59a0b2,2018-06-07 16:20:25,193808857,"@@ -441,11 +441,16 @@ pub extern fn indy_add_request_fees(command_handle: i32,
 ///
 /// #Returns
 /// utxo_json - parsed (payment method and node version agnostic) utxo info as json:
-///   [{
-///      input: <str>, // UTXO input
-///      amount: <int>, // amount of tokens in this input
-///      extra: <str>, // optional data from payment transaction
-///   }]
+/// {
+///     ""ver"": <int>,                    // this field is included to allow for future backward compatability",10,2018-06-07 16:20:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193808857,https://github.com/hyperledger/indy-sdk/pull/850#discussion_r193808857,brentzundel
https://github.com/hyperledger/indy-sdk/pull/850,https://github.com/hyperledger/indy-sdk/pull/850,"To be backward compatible libindy should be backward compatible in out params. It means that utxo_json can only be changed by adding new fields or by providing new similar method, but with extended behavior. Adding version to utxo_json doesn't help. So i suggest to don't add the version here.

We can think about adding some versioning in interface between libsovtoken and libindy only,",dc1583f6fa47a540fbfc257619a61ad65d59a0b2,2018-06-08 07:50:36,193978377,"@@ -441,11 +441,16 @@ pub extern fn indy_add_request_fees(command_handle: i32,
 ///
 /// #Returns
 /// utxo_json - parsed (payment method and node version agnostic) utxo info as json:
-///   [{
-///      input: <str>, // UTXO input
-///      amount: <int>, // amount of tokens in this input
-///      extra: <str>, // optional data from payment transaction
-///   }]
+/// {
+///     ""ver"": <int>,                    // this field is included to allow for future backward compatability",10,2018-06-08 07:50:37,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193978377,https://github.com/hyperledger/indy-sdk/pull/850#discussion_r193978377,vimmerru
https://github.com/hyperledger/indy-sdk/pull/846,https://github.com/hyperledger/indy-sdk/pull/846,Could we just change the error to CommonInvalidState? It will correspond to behavior with deletion of pool and we will not need to update all wrappers and cli,0d00c761ab8906c6e81df5e1339db67f58ae2da9,2018-06-14 11:16:18,195385003,"@@ -116,6 +116,9 @@ pub enum ErrorCode
     // Returned if provided wallet query is invalid
     WalletQueryError = 214,
 
+    // Returned if wallet it not closed, which is required for the operation (currently for deletion)
+    WalletNotClosed = 215,",,2018-06-15 13:42:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195385003,https://github.com/hyperledger/indy-sdk/pull/846#discussion_r195385003,vimmerru
https://github.com/hyperledger/indy-sdk/pull/846,https://github.com/hyperledger/indy-sdk/pull/846,Sure no problem,0d00c761ab8906c6e81df5e1339db67f58ae2da9,2018-06-14 11:18:06,195385390,"@@ -116,6 +116,9 @@ pub enum ErrorCode
     // Returned if provided wallet query is invalid
     WalletQueryError = 214,
 
+    // Returned if wallet it not closed, which is required for the operation (currently for deletion)
+    WalletNotClosed = 215,",,2018-06-15 13:42:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195385390,https://github.com/hyperledger/indy-sdk/pull/846#discussion_r195385390,keichiri
https://github.com/hyperledger/indy-sdk/pull/846,https://github.com/hyperledger/indy-sdk/pull/846,"I suggest to remove WalletError::NotClosed at all, not just use different error code mapping. Mapping of errors should be one to one.",0d00c761ab8906c6e81df5e1339db67f58ae2da9,2018-06-14 14:28:47,195445434,"@@ -134,7 +134,7 @@ impl ToErrorCode for WalletError {
             WalletError::ItemNotFound => ErrorCode::WalletItemNotFound,
             WalletError::ItemAlreadyExists => ErrorCode::WalletItemAlreadyExists,
             WalletError::QueryError(_) => ErrorCode::WalletQueryError,
-            WalletError::NotClosed => ErrorCode::WalletNotClosed,
+            WalletError::NotClosed => ErrorCode::CommonInvalidState,",,2018-06-15 13:42:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195445434,https://github.com/hyperledger/indy-sdk/pull/846#discussion_r195445434,vimmerru
https://github.com/hyperledger/indy-sdk/pull/838,https://github.com/hyperledger/indy-sdk/pull/838,"It needs to be active not only based on timeout, but timeout AND a max number of sent requests ",e26d335b07d8d5208e1c73de0d8c6c843a4f5569,2018-06-05 14:37:05,193097023,"@@ -0,0 +1,44 @@
+# Connections optimization design
+
+## Summary
+
+This design proposes enhancements of pool connection logic in libindy for
+reducing of pool load and better pool DDoS protection.
+
+## Motivation
+
+For current moment ```indy_pool_open``` endpoint performs CatchUp process and after this
+creates zmq sockets for each pool node and keep sockets connected until calling
+of ```indy_pool_close``` endpoint.
+
+This behavior causes the most of clients connected for the most of the time. As result
+we have obvious problem as each node can open only limited amount of sockets for
+the same time. Only first n clients can connect because n+1 connection will just
+cause error about limit of opened file descriptors.
+
+Additionally it makes easy to perform DDoS attack by justs calling ```indy_pool_open```
+in a cycle.
+
+Note that problem is complex and requires corresponded solution in Node codebase and
+pool network infrastructure, but this proposal is focused on libindy (client) side.
+
+## Proposed changes
+
+The main idea of proposal is force libindy to close sockets as soon as possible, but
+still provide very limited keep-alive ability to avoid unnecessary CurveCP and TCP
+handshakes:
+
+1. Change ```indy_pool_open``` endpoint behavior. Instead keep sockets connected it will only perform CatchUp
+   and keep only information about nodes of this pool. Sockets creation will be performed when application
+   sends request with some limitations and optimizations (see details below).
+1. Introduce internal ""pool connection"" entity. Each ""pool connection"" is intended to be used with a specific pool only.
+1. ""Pool connection"" owns sockets and can be used to execute one or multiple requests.
+1. After creation ""pool connection"" becomes ""active"" for some pre-defined timeout (5 sec). ""Active"" means that context can be used to start execution of     new requests to pool.",,2018-06-15 13:09:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193097023,https://github.com/hyperledger/indy-sdk/pull/838#discussion_r193097023,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/838,https://github.com/hyperledger/indy-sdk/pull/838,"Also the results of catch-up need to be persisted, so we don't do catch-up from scratch on every `indy_pool_open`",e26d335b07d8d5208e1c73de0d8c6c843a4f5569,2018-06-05 14:37:47,193097310,"@@ -0,0 +1,44 @@
+# Connections optimization design
+
+## Summary
+
+This design proposes enhancements of pool connection logic in libindy for
+reducing of pool load and better pool DDoS protection.
+
+## Motivation
+
+For current moment ```indy_pool_open``` endpoint performs CatchUp process and after this
+creates zmq sockets for each pool node and keep sockets connected until calling
+of ```indy_pool_close``` endpoint.
+
+This behavior causes the most of clients connected for the most of the time. As result
+we have obvious problem as each node can open only limited amount of sockets for
+the same time. Only first n clients can connect because n+1 connection will just
+cause error about limit of opened file descriptors.
+
+Additionally it makes easy to perform DDoS attack by justs calling ```indy_pool_open```
+in a cycle.
+
+Note that problem is complex and requires corresponded solution in Node codebase and
+pool network infrastructure, but this proposal is focused on libindy (client) side.
+
+## Proposed changes
+
+The main idea of proposal is force libindy to close sockets as soon as possible, but
+still provide very limited keep-alive ability to avoid unnecessary CurveCP and TCP
+handshakes:
+
+1. Change ```indy_pool_open``` endpoint behavior. Instead keep sockets connected it will only perform CatchUp",31,2018-06-15 13:09:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193097310,https://github.com/hyperledger/indy-sdk/pull/838#discussion_r193097310,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/838,https://github.com/hyperledger/indy-sdk/pull/838,"Please mention that it waits for responses for some timeout, not infinitely. So the sockets will always be closed eventually.",e26d335b07d8d5208e1c73de0d8c6c843a4f5569,2018-06-05 14:39:01,193097780,"@@ -0,0 +1,44 @@
+# Connections optimization design
+
+## Summary
+
+This design proposes enhancements of pool connection logic in libindy for
+reducing of pool load and better pool DDoS protection.
+
+## Motivation
+
+For current moment ```indy_pool_open``` endpoint performs CatchUp process and after this
+creates zmq sockets for each pool node and keep sockets connected until calling
+of ```indy_pool_close``` endpoint.
+
+This behavior causes the most of clients connected for the most of the time. As result
+we have obvious problem as each node can open only limited amount of sockets for
+the same time. Only first n clients can connect because n+1 connection will just
+cause error about limit of opened file descriptors.
+
+Additionally it makes easy to perform DDoS attack by justs calling ```indy_pool_open```
+in a cycle.
+
+Note that problem is complex and requires corresponded solution in Node codebase and
+pool network infrastructure, but this proposal is focused on libindy (client) side.
+
+## Proposed changes
+
+The main idea of proposal is force libindy to close sockets as soon as possible, but
+still provide very limited keep-alive ability to avoid unnecessary CurveCP and TCP
+handshakes:
+
+1. Change ```indy_pool_open``` endpoint behavior. Instead keep sockets connected it will only perform CatchUp
+   and keep only information about nodes of this pool. Sockets creation will be performed when application
+   sends request with some limitations and optimizations (see details below).
+1. Introduce internal ""pool connection"" entity. Each ""pool connection"" is intended to be used with a specific pool only.
+1. ""Pool connection"" owns sockets and can be used to execute one or multiple requests.
+1. After creation ""pool connection"" becomes ""active"" for some pre-defined timeout (5 sec). ""Active"" means that context can be used to start execution of     new requests to pool.
+1. When application tries to send request to pool libindy checks for already exists ""pool connection"" for target pool in ""active"" state.
+1. If there is no active ""pool connection"" then libindy creates a new one and uses it for sending request.
+1. If there is active ""pool connection"" then libindy re-uses it for sending request.
+1. ""pool connection"" opens sockets only ""by request"". if requests execution requires connection to only one node than only one socket will be created.
+1. ""pool connection"" determines node to perform new connection with round robin. If connection is already established than sockets will be re-used.
+1. libindy keep opened sockets connected until ""pool connection"" is active (5s from ""pool connection"" creation) or there is request that waits for
+   response on this socket. As soon as ""pool connection"" is switched from active state and sockets isn't needed for request it will be ",,2018-06-15 13:09:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193097780,https://github.com/hyperledger/indy-sdk/pull/838#discussion_r193097780,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/838,https://github.com/hyperledger/indy-sdk/pull/838,I added this info,e26d335b07d8d5208e1c73de0d8c6c843a4f5569,2018-06-05 15:02:14,193107142,"@@ -0,0 +1,44 @@
+# Connections optimization design
+
+## Summary
+
+This design proposes enhancements of pool connection logic in libindy for
+reducing of pool load and better pool DDoS protection.
+
+## Motivation
+
+For current moment ```indy_pool_open``` endpoint performs CatchUp process and after this
+creates zmq sockets for each pool node and keep sockets connected until calling
+of ```indy_pool_close``` endpoint.
+
+This behavior causes the most of clients connected for the most of the time. As result
+we have obvious problem as each node can open only limited amount of sockets for
+the same time. Only first n clients can connect because n+1 connection will just
+cause error about limit of opened file descriptors.
+
+Additionally it makes easy to perform DDoS attack by justs calling ```indy_pool_open```
+in a cycle.
+
+Note that problem is complex and requires corresponded solution in Node codebase and
+pool network infrastructure, but this proposal is focused on libindy (client) side.
+
+## Proposed changes
+
+The main idea of proposal is force libindy to close sockets as soon as possible, but
+still provide very limited keep-alive ability to avoid unnecessary CurveCP and TCP
+handshakes:
+
+1. Change ```indy_pool_open``` endpoint behavior. Instead keep sockets connected it will only perform CatchUp",31,2018-06-15 13:09:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193107142,https://github.com/hyperledger/indy-sdk/pull/838#discussion_r193107142,vimmerru
https://github.com/hyperledger/indy-sdk/pull/838,https://github.com/hyperledger/indy-sdk/pull/838,"""requires connection to only one node"", you mean only read request expecting state proof. Also currently libindy tries to connect to all known nodes but we need to talk to only `>f` nodes? Would that be changed too? 
",e26d335b07d8d5208e1c73de0d8c6c843a4f5569,2018-06-05 16:10:05,193132572,"@@ -0,0 +1,49 @@
+# Connections optimization design
+
+## Summary
+
+This design proposes enhancements of pool connection logic in libindy for
+reducing of pool load and better pool DDoS protection.
+
+## Motivation
+
+For current moment ```indy_pool_open``` endpoint performs CatchUp process and after this
+creates zmq sockets for each pool node and keep sockets connected until calling
+of ```indy_pool_close``` endpoint.
+
+This behavior causes the most of clients connected for the most of the time. As result
+we have obvious problem as each node can open only limited amount of sockets for
+the same time. Only first n clients can connect because n+1 connection will just
+cause error about limit of opened file descriptors.
+
+Additionally it makes easy to perform DDoS attack by justs calling ```indy_pool_open```
+in a cycle.
+
+Note that problem is complex and requires corresponded solution in Node codebase and
+pool network infrastructure, but this proposal is focused on libindy (client) side.
+
+## Proposed changes
+
+The main idea of proposal is force libindy to close sockets as soon as possible, but
+still provide very limited keep-alive ability to avoid unnecessary CurveCP and TCP
+handshakes:
+
+1. Change ```indy_pool_open``` endpoint behavior. Instead keep sockets connected it will only perform CatchUp
+   and keep only information about nodes of this pool. Sockets creation will be performed when application
+   sends request with some limitations and optimizations (see details below).
+1. Persist ```indy_pool_open``` CatchUp results to start from updated pool ledger next time.
+1. Introduce internal ""pool connection"" entity. Each ""pool connection"" is intended to be used with a specific pool only.
+1. ""Pool connection"" owns sockets and can be used to execute one or multiple requests.
+1. After creation ""pool connection"" becomes ""active"" for some pre-defined timeout (5 sec) or until some pre-defined amount
+   of requests (5) were started through this ""pool connection"".
+1. ""Active"" means that context can be used to start execution of     new requests to pool.
+1. When application tries to send request to pool libindy checks for already exists ""pool connection"" for target pool in ""active"" state.
+1. If there is no active ""pool connection"" then libindy creates a new one and uses it for sending request.
+1. If there is active ""pool connection"" then libindy re-uses it for sending request.
+1. ""pool connection"" opens sockets only ""by request"". if requests execution requires connection to only one node than only one socket will be created.",43,2018-06-15 13:09:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193132572,https://github.com/hyperledger/indy-sdk/pull/838#discussion_r193132572,lovesh
https://github.com/hyperledger/indy-sdk/pull/838,https://github.com/hyperledger/indy-sdk/pull/838,"As I understand yes. If this is a get request, then a connection to one node only will be established.",e26d335b07d8d5208e1c73de0d8c6c843a4f5569,2018-06-05 16:37:51,193141420,"@@ -0,0 +1,49 @@
+# Connections optimization design
+
+## Summary
+
+This design proposes enhancements of pool connection logic in libindy for
+reducing of pool load and better pool DDoS protection.
+
+## Motivation
+
+For current moment ```indy_pool_open``` endpoint performs CatchUp process and after this
+creates zmq sockets for each pool node and keep sockets connected until calling
+of ```indy_pool_close``` endpoint.
+
+This behavior causes the most of clients connected for the most of the time. As result
+we have obvious problem as each node can open only limited amount of sockets for
+the same time. Only first n clients can connect because n+1 connection will just
+cause error about limit of opened file descriptors.
+
+Additionally it makes easy to perform DDoS attack by justs calling ```indy_pool_open```
+in a cycle.
+
+Note that problem is complex and requires corresponded solution in Node codebase and
+pool network infrastructure, but this proposal is focused on libindy (client) side.
+
+## Proposed changes
+
+The main idea of proposal is force libindy to close sockets as soon as possible, but
+still provide very limited keep-alive ability to avoid unnecessary CurveCP and TCP
+handshakes:
+
+1. Change ```indy_pool_open``` endpoint behavior. Instead keep sockets connected it will only perform CatchUp
+   and keep only information about nodes of this pool. Sockets creation will be performed when application
+   sends request with some limitations and optimizations (see details below).
+1. Persist ```indy_pool_open``` CatchUp results to start from updated pool ledger next time.
+1. Introduce internal ""pool connection"" entity. Each ""pool connection"" is intended to be used with a specific pool only.
+1. ""Pool connection"" owns sockets and can be used to execute one or multiple requests.
+1. After creation ""pool connection"" becomes ""active"" for some pre-defined timeout (5 sec) or until some pre-defined amount
+   of requests (5) were started through this ""pool connection"".
+1. ""Active"" means that context can be used to start execution of     new requests to pool.
+1. When application tries to send request to pool libindy checks for already exists ""pool connection"" for target pool in ""active"" state.
+1. If there is no active ""pool connection"" then libindy creates a new one and uses it for sending request.
+1. If there is active ""pool connection"" then libindy re-uses it for sending request.
+1. ""pool connection"" opens sockets only ""by request"". if requests execution requires connection to only one node than only one socket will be created.",43,2018-06-15 13:09:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193141420,https://github.com/hyperledger/indy-sdk/pull/838#discussion_r193141420,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,We need to have documentation for each method/type,96a3293bff94d1a972f9832760935c749b705433,2018-06-04 10:14:10,192691518,"@@ -1616,4 +1616,45 @@ pub extern fn indy_parse_get_revoc_reg_delta_response(command_handle: i32,
     trace!(""indy_parse_get_revoc_reg_delta_response: <<< res: {:?}"", res);
 
     res
-}
\ No newline at end of file
+}
+
+pub type CustomTransactionParser = extern fn(reply_from_node: *const c_char, parsed_sp: *mut *const c_char) -> ErrorCode;
+pub type CustomFree = extern fn(data: *const c_char) -> ErrorCode;
+
+#[no_mangle]
+pub extern fn indy_register_transaction_parser_for_sp(command_handle: i32,",,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192691518,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r192691518,vimmerru
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,I am not sure that we need pool_handle here. Let's discuss.,96a3293bff94d1a972f9832760935c749b705433,2018-06-04 10:15:04,192691740,"@@ -1616,4 +1616,45 @@ pub extern fn indy_parse_get_revoc_reg_delta_response(command_handle: i32,
     trace!(""indy_parse_get_revoc_reg_delta_response: <<< res: {:?}"", res);
 
     res
-}
\ No newline at end of file
+}
+
+pub type CustomTransactionParser = extern fn(reply_from_node: *const c_char, parsed_sp: *mut *const c_char) -> ErrorCode;
+pub type CustomFree = extern fn(data: *const c_char) -> ErrorCode;
+
+#[no_mangle]
+pub extern fn indy_register_transaction_parser_for_sp(command_handle: i32,
+                                                      pool_handle: i32,",,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192691740,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r192691740,vimmerru
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,I prefer to have Option inside of type definition. Otherwise user can get a feeling that this parameter is optional,96a3293bff94d1a972f9832760935c749b705433,2018-06-04 10:16:24,192692066,"@@ -1616,4 +1616,45 @@ pub extern fn indy_parse_get_revoc_reg_delta_response(command_handle: i32,
     trace!(""indy_parse_get_revoc_reg_delta_response: <<< res: {:?}"", res);
 
     res
-}
\ No newline at end of file
+}
+
+pub type CustomTransactionParser = extern fn(reply_from_node: *const c_char, parsed_sp: *mut *const c_char) -> ErrorCode;
+pub type CustomFree = extern fn(data: *const c_char) -> ErrorCode;
+
+#[no_mangle]
+pub extern fn indy_register_transaction_parser_for_sp(command_handle: i32,
+                                                      pool_handle: i32,
+                                                      txn_type: *const c_char,
+                                                      parser: Option<CustomTransactionParser>,",,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192692066,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r192692066,vimmerru
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,Do we need to call it register_parser_for_sp instead of register_parser ???,96a3293bff94d1a972f9832760935c749b705433,2018-06-04 10:17:53,192692414,"@@ -212,6 +225,16 @@ impl LedgerCommandExecutor {
                     .expect(""Expect callback to process ack command"")
                     (result.map_err(IndyError::from));
             }
+            LedgerCommand::RegisterParserSP(pool_handle, txn_type, parser, free, cb) => {
+                info!(target: ""ledger_command_executor"", ""RegisterParserSP command received"");
+                self.register_parser(pool_handle, &txn_type, parser, free, cb);",,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192692414,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r192692414,vimmerru
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,"I suggest to rename ""register"" to something more obvious",96a3293bff94d1a972f9832760935c749b705433,2018-06-04 10:19:05,192692680,"@@ -335,6 +358,19 @@ impl LedgerCommandExecutor {
         };
     }
 
+    fn register_parser(&self, pool_handle: i32, txn_type: &str,
+                       parser: CustomTransactionParser, free: CustomFree,
+                       cb: Box<Fn(Result<(), IndyError>) + Send>) {
+        debug!(""register_parser >>> pool_handle: {:?}, txn_type: {:?}, parser: {:?}, free: {:?}"",
+               pool_handle, txn_type, parser, free);
+
+        let x: Result<i32, PoolError> = self.pool_service.register(pool_handle, txn_type, parser, free);",,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192692680,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r192692680,vimmerru
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,"""register_callbacks"" seems non-obvious name. ",96a3293bff94d1a972f9832760935c749b705433,2018-06-04 10:20:01,192692902,"@@ -335,6 +358,19 @@ impl LedgerCommandExecutor {
         };
     }
 
+    fn register_parser(&self, pool_handle: i32, txn_type: &str,
+                       parser: CustomTransactionParser, free: CustomFree,
+                       cb: Box<Fn(Result<(), IndyError>) + Send>) {
+        debug!(""register_parser >>> pool_handle: {:?}, txn_type: {:?}, parser: {:?}, free: {:?}"",
+               pool_handle, txn_type, parser, free);
+
+        let x: Result<i32, PoolError> = self.pool_service.register(pool_handle, txn_type, parser, free);
+        match x {
+            Ok(cmd_id) => { self.register_callbacks.borrow_mut().insert(cmd_id, cb); }",,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192692902,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r192692902,vimmerru
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,"We need to store ""parser_sps"" on a service layer. All opened pools must handle this transaction type. ",96a3293bff94d1a972f9832760935c749b705433,2018-06-04 10:22:45,192693582,"@@ -277,7 +278,21 @@ impl PoolWorker {
                             })
                     })?;
                 }
-                &ZMQLoopAction::Timeout => {
+                ZMQLoopAction::Register(cmd_id, txn_type, parser, free) => {
+                    match self.handler {
+                        PoolWorkerHandler::TransactionHandler(ref mut th) => {
+                            th.parser_sps.insert(txn_type,",,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192693582,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r192693582,vimmerru
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,"""register"" should be renamed to something more obvious",96a3293bff94d1a972f9832760935c749b705433,2018-06-04 10:23:31,192693798,"@@ -318,6 +333,23 @@ impl PoolWorker {
                 actions.push(ZMQLoopAction::Terminate(id));
             } else if ""refresh"".eq(cmd_s.as_str()) {
                 actions.push(ZMQLoopAction::Refresh(id));
+            } else if ""register"".eq(cmd_s.as_str()) {",,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192693798,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r192693798,vimmerru
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,"> TransactionHandler::parse_reply_for_builtin_sp(json_msg, type_)

I don't like this approach. I prefer to have n dedicated functions that will be called for each transaction type without any distinction between ""embedded"" and ""external"" sp parser.",96a3293bff94d1a972f9832760935c749b705433,2018-06-04 10:27:27,192694740,"@@ -288,37 +271,67 @@ impl TransactionHandler {
         }
     }
 
-    fn parse_reply_for_proof_checking(json_msg: &SJsonValue)
-                                      -> Option<(&str, &str, Vec<u8>, Option<String>)> {
-        trace!(""TransactionHandler::parse_reply_for_proof_checking: >>> json_msg: {:?}"", json_msg);
-
-        let xtype = if let Some(xtype) = json_msg[""type""].as_str() {
-            trace!(""TransactionHandler::parse_reply_for_proof_checking: xtype: {:?}"", xtype);
-            xtype
+    fn parse_generic_reply_for_proof_checking(&self, json_msg: &SJsonValue, raw_msg: &str) -> Option<Vec<ParsedSP>> {
+        let type_ = if let Some(type_) = json_msg[""type""].as_str() {
+            trace!(""TransactionHandler::parse_generic_reply_for_proof_checking: type_: {:?}"", type_);
+            type_
         } else {
-            trace!(""TransactionHandler::parse_reply_for_proof_checking: <<< No type field"");
+            debug!(""TransactionHandler::parse_generic_reply_for_proof_checking: <<< No type field"");
             return None;
         };
 
-        if !REQUESTS_FOR_STATE_PROOFS.contains(&xtype) {
-            //TODO GET_DDO, GET_TXN
-            trace!(""TransactionHandler::parse_reply_for_proof_checking: <<< type not supported"");
-            return None;
+        if REQUESTS_FOR_STATE_PROOFS.contains(&type_) {
+            trace!(""TransactionHandler::parse_generic_reply_for_proof_checking: built-in"");
+            TransactionHandler::parse_reply_for_builtin_sp(json_msg, type_)",102,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192694740,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r192694740,vimmerru
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,"We always use Option around custom callback type. We can change our approach, but I don't like to mix different in codebase. So after additional discussion we can raise separate PR for API changes (this, payments, wallet, etc)",96a3293bff94d1a972f9832760935c749b705433,2018-06-04 10:45:55,192698866,"@@ -1616,4 +1616,45 @@ pub extern fn indy_parse_get_revoc_reg_delta_response(command_handle: i32,
     trace!(""indy_parse_get_revoc_reg_delta_response: <<< res: {:?}"", res);
 
     res
-}
\ No newline at end of file
+}
+
+pub type CustomTransactionParser = extern fn(reply_from_node: *const c_char, parsed_sp: *mut *const c_char) -> ErrorCode;
+pub type CustomFree = extern fn(data: *const c_char) -> ErrorCode;
+
+#[no_mangle]
+pub extern fn indy_register_transaction_parser_for_sp(command_handle: i32,
+                                                      pool_handle: i32,
+                                                      txn_type: *const c_char,
+                                                      parser: Option<CustomTransactionParser>,",,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192698866,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r192698866,jovfer
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,I prefer to do it in separate PR...,96a3293bff94d1a972f9832760935c749b705433,2018-06-04 10:48:19,192699456,"@@ -288,37 +271,67 @@ impl TransactionHandler {
         }
     }
 
-    fn parse_reply_for_proof_checking(json_msg: &SJsonValue)
-                                      -> Option<(&str, &str, Vec<u8>, Option<String>)> {
-        trace!(""TransactionHandler::parse_reply_for_proof_checking: >>> json_msg: {:?}"", json_msg);
-
-        let xtype = if let Some(xtype) = json_msg[""type""].as_str() {
-            trace!(""TransactionHandler::parse_reply_for_proof_checking: xtype: {:?}"", xtype);
-            xtype
+    fn parse_generic_reply_for_proof_checking(&self, json_msg: &SJsonValue, raw_msg: &str) -> Option<Vec<ParsedSP>> {
+        let type_ = if let Some(type_) = json_msg[""type""].as_str() {
+            trace!(""TransactionHandler::parse_generic_reply_for_proof_checking: type_: {:?}"", type_);
+            type_
         } else {
-            trace!(""TransactionHandler::parse_reply_for_proof_checking: <<< No type field"");
+            debug!(""TransactionHandler::parse_generic_reply_for_proof_checking: <<< No type field"");
             return None;
         };
 
-        if !REQUESTS_FOR_STATE_PROOFS.contains(&xtype) {
-            //TODO GET_DDO, GET_TXN
-            trace!(""TransactionHandler::parse_reply_for_proof_checking: <<< type not supported"");
-            return None;
+        if REQUESTS_FOR_STATE_PROOFS.contains(&type_) {
+            trace!(""TransactionHandler::parse_generic_reply_for_proof_checking: built-in"");
+            TransactionHandler::parse_reply_for_builtin_sp(json_msg, type_)",102,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192699456,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r192699456,jovfer
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,"Related to https://github.com/hyperledger/indy-sdk/pull/832#discussion_r192691740
I prefer to have more flexibility here.
The case when application use more then 1 pool is something unusual and required by complex logic. For complex cases it's better to have flexible approach",96a3293bff94d1a972f9832760935c749b705433,2018-06-04 11:10:28,192704404,"@@ -277,7 +278,21 @@ impl PoolWorker {
                             })
                     })?;
                 }
-                &ZMQLoopAction::Timeout => {
+                ZMQLoopAction::Register(cmd_id, txn_type, parser, free) => {
+                    match self.handler {
+                        PoolWorkerHandler::TransactionHandler(ref mut th) => {
+                            th.parser_sps.insert(txn_type,",,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192704404,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r192704404,jovfer
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r192704404,96a3293bff94d1a972f9832760935c749b705433,2018-06-04 11:10:42,192704463,"@@ -1616,4 +1616,45 @@ pub extern fn indy_parse_get_revoc_reg_delta_response(command_handle: i32,
     trace!(""indy_parse_get_revoc_reg_delta_response: <<< res: {:?}"", res);
 
     res
-}
\ No newline at end of file
+}
+
+pub type CustomTransactionParser = extern fn(reply_from_node: *const c_char, parsed_sp: *mut *const c_char) -> ErrorCode;
+pub type CustomFree = extern fn(data: *const c_char) -> ErrorCode;
+
+#[no_mangle]
+pub extern fn indy_register_transaction_parser_for_sp(command_handle: i32,
+                                                      pool_handle: i32,",,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192704463,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r192704463,jovfer
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,"Just for safety, we should check that a parser is already registered or not for a txn type and act appropriately. There are 2 ways to deal with this
1. provide an override flag (defaults to false) in the function args
2. Or check result of `get_sp_parser` before calling `register_sp_parser`",96a3293bff94d1a972f9832760935c749b705433,2018-06-05 17:02:55,193149170,"@@ -783,6 +789,22 @@ impl PoolService {
         Ok(cmd_id)
     }
 
+    pub fn register_sp_parser(txn_type: &str,
+                              parser: CustomTransactionParser, free: CustomFree) -> Result<(), PoolError> {
+        REGISTERED_SP_PARSERS.lock()
+            .map(|mut map| {",,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193149170,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r193149170,lovesh
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,Can you avoid creating `parsed_str` by not freeing `parsed_c_str` before the JSON is created and they freeing `parsed_c_str` ,96a3293bff94d1a972f9832760935c749b705433,2018-06-05 17:11:42,193151690,"@@ -288,37 +271,67 @@ impl TransactionHandler {
         }
     }
 
-    fn parse_reply_for_proof_checking(json_msg: &SJsonValue)
-                                      -> Option<(&str, &str, Vec<u8>, Option<String>)> {
-        trace!(""TransactionHandler::parse_reply_for_proof_checking: >>> json_msg: {:?}"", json_msg);
-
-        let xtype = if let Some(xtype) = json_msg[""type""].as_str() {
-            trace!(""TransactionHandler::parse_reply_for_proof_checking: xtype: {:?}"", xtype);
-            xtype
+    fn parse_generic_reply_for_proof_checking(&self, json_msg: &SJsonValue, raw_msg: &str) -> Option<Vec<ParsedSP>> {
+        let type_ = if let Some(type_) = json_msg[""type""].as_str() {
+            trace!(""TransactionHandler::parse_generic_reply_for_proof_checking: type_: {:?}"", type_);
+            type_
         } else {
-            trace!(""TransactionHandler::parse_reply_for_proof_checking: <<< No type field"");
+            debug!(""TransactionHandler::parse_generic_reply_for_proof_checking: <<< No type field"");
             return None;
         };
 
-        if !REQUESTS_FOR_STATE_PROOFS.contains(&xtype) {
-            //TODO GET_DDO, GET_TXN
-            trace!(""TransactionHandler::parse_reply_for_proof_checking: <<< type not supported"");
-            return None;
+        if REQUESTS_FOR_STATE_PROOFS.contains(&type_) {
+            trace!(""TransactionHandler::parse_generic_reply_for_proof_checking: built-in"");
+            TransactionHandler::parse_reply_for_builtin_sp(json_msg, type_)
+        } else if let Some((parser, free)) = PoolService::get_sp_parser(type_) {
+            trace!(""TransactionHandler::parse_generic_reply_for_proof_checking: plugged: parser {:?}, free {:?}"",
+                   parser, free);
+
+            let msg = CString::new(raw_msg).ok()?;
+            let mut parsed_c_str = ::std::ptr::null();
+            let err = parser(msg.as_ptr(), &mut parsed_c_str);
+            if err != ErrorCode::Success {
+                debug!(""TransactionHandler::parse_generic_reply_for_proof_checking: <<< plugin return err {:?}"", err);
+                return None;
+            }
+            let parsed_str = CStringUtils::c_str_to_string(parsed_c_str).ok()??;
+
+            let err = free(parsed_c_str);
+            trace!(""TransactionHandler::parse_generic_reply_for_proof_checking: plugin free res {:?}"", err);
+
+            let parsed_sp = match serde_json::from_str::<Vec<ParsedSP>>(&parsed_str) {",,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193151690,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r193151690,lovesh
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,"`verify_proof` will build a new `TrieDB` and populate it each time, but you dont need to. `proof_nodes` comprise of the proof for all keys in `kvs.kvs`. Its better to have a function that build a `TrieDB` once and uses it to query each key. Have a look at this in [indy-plenum](https://github.com/hyperledger/indy-plenum/blob/master/state/trie/pruning_trie.py#L1118)",96a3293bff94d1a972f9832760935c749b705433,2018-06-05 18:01:49,193167119,"@@ -539,10 +559,54 @@ impl TransactionHandler {
         }
     }
 
+    fn verify_parsed_sp(&self, parsed_sps: Vec<ParsedSP>) -> bool {
+        for parsed_sp in parsed_sps {
+            if parsed_sp.multi_signature[""value""][""state_root_hash""].as_str().ne(
+                &Some(&parsed_sp.root_hash)) {
+                return false
+            }
+
+            let data_to_check_proof_signature =
+                TransactionHandler::parse_reply_for_proof_signature_checking(
+                    &parsed_sp.multi_signature);
+            let (signature, participants, value) = unwrap_opt_or_return!(data_to_check_proof_signature, false);
+            if !state_proof::verify_proof_signature(signature,
+                                                    participants.as_slice(),
+                                                    &value,
+                                                    self.nodes.as_slice(), self.f, &self.gen)
+                .map_err(|err| warn!(""{:?}"", err)).unwrap_or(false) {
+                return false;
+            }
+
+            let proof_nodes = unwrap_or_return!(base64::decode(&parsed_sp.proof_nodes), false);
+            let root_hash = unwrap_or_return!(parsed_sp.root_hash.from_base58(), false);
+            match parsed_sp.kvs_to_verify {
+                KeyValuesInSP::Simple(kvs) => {
+                    for (k, v) in kvs.kvs {
+                        let key = unwrap_or_return!(base64::decode(&k), false);
+                        if !state_proof::verify_proof(proof_nodes.as_slice(),",374,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193167119,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r193167119,lovesh
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,"+1
but again (https://github.com/hyperledger/indy-sdk/pull/832#discussion_r192699456) I would like to merge minimal PR to master and make API available for usage in plugin. ",96a3293bff94d1a972f9832760935c749b705433,2018-06-05 22:31:03,193242278,"@@ -539,10 +559,54 @@ impl TransactionHandler {
         }
     }
 
+    fn verify_parsed_sp(&self, parsed_sps: Vec<ParsedSP>) -> bool {
+        for parsed_sp in parsed_sps {
+            if parsed_sp.multi_signature[""value""][""state_root_hash""].as_str().ne(
+                &Some(&parsed_sp.root_hash)) {
+                return false
+            }
+
+            let data_to_check_proof_signature =
+                TransactionHandler::parse_reply_for_proof_signature_checking(
+                    &parsed_sp.multi_signature);
+            let (signature, participants, value) = unwrap_opt_or_return!(data_to_check_proof_signature, false);
+            if !state_proof::verify_proof_signature(signature,
+                                                    participants.as_slice(),
+                                                    &value,
+                                                    self.nodes.as_slice(), self.f, &self.gen)
+                .map_err(|err| warn!(""{:?}"", err)).unwrap_or(false) {
+                return false;
+            }
+
+            let proof_nodes = unwrap_or_return!(base64::decode(&parsed_sp.proof_nodes), false);
+            let root_hash = unwrap_or_return!(parsed_sp.root_hash.from_base58(), false);
+            match parsed_sp.kvs_to_verify {
+                KeyValuesInSP::Simple(kvs) => {
+                    for (k, v) in kvs.kvs {
+                        let key = unwrap_or_return!(base64::decode(&k), false);
+                        if !state_proof::verify_proof(proof_nodes.as_slice(),",374,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193242278,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r193242278,jovfer
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,"I think it also point to discuss on libindy API level. Should libindy override already registered txn types or not?
@vimmerru @lovesh ",96a3293bff94d1a972f9832760935c749b705433,2018-06-05 22:35:54,193243198,"@@ -783,6 +789,22 @@ impl PoolService {
         Ok(cmd_id)
     }
 
+    pub fn register_sp_parser(txn_type: &str,
+                              parser: CustomTransactionParser, free: CustomFree) -> Result<(), PoolError> {
+        REGISTERED_SP_PARSERS.lock()
+            .map(|mut map| {",,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193243198,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r193243198,jovfer
https://github.com/hyperledger/indy-sdk/pull/832,https://github.com/hyperledger/indy-sdk/pull/832,After discussion with @vimmerru I've added check to doesn't allow overriding parser for default txn types and allow silent overriding previously registered custom type from API level.,96a3293bff94d1a972f9832760935c749b705433,2018-06-06 08:35:18,193333390,"@@ -783,6 +789,22 @@ impl PoolService {
         Ok(cmd_id)
     }
 
+    pub fn register_sp_parser(txn_type: &str,
+                              parser: CustomTransactionParser, free: CustomFree) -> Result<(), PoolError> {
+        REGISTERED_SP_PARSERS.lock()
+            .map(|mut map| {",,2018-06-07 10:21:58,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193333390,https://github.com/hyperledger/indy-sdk/pull/832#discussion_r193333390,jovfer
https://github.com/hyperledger/indy-sdk/pull/812,https://github.com/hyperledger/indy-sdk/pull/812,I think this command should be either absolute replacement for **all** entries of `cargo build` or removed. If we are mixing `buildCommand` and plain cargo build it may results in partial changes in the future. Someone may just update this command and forget to search plain cargo build,6ddde6e05ddcbe2c361ffef18a98c211f266cbf7,2018-05-30 07:58:52,191673884,"@@ -1,5 +1,8 @@
 #!groovy
 
+def features = ""--features fatal_warnings""
+def buildCommand = ""cargo build ${features}""",,2018-06-29 08:16:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191673884,https://github.com/hyperledger/indy-sdk/pull/812#discussion_r191673884,jovfer
https://github.com/hyperledger/indy-sdk/pull/812,https://github.com/hyperledger/indy-sdk/pull/812,"I'm not sure, what this line is the best place for this comment. May be we should move it to `Cargo.toml` file?
@vimmerru ^",6ddde6e05ddcbe2c361ffef18a98c211f266cbf7,2018-05-30 08:06:01,191675929,"@@ -1,3 +1,6 @@
+// If compiling with feature ""fatal_warnings"", the build will fail on all warnings",,2018-06-29 08:16:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191675929,https://github.com/hyperledger/indy-sdk/pull/812#discussion_r191675929,jovfer
https://github.com/hyperledger/indy-sdk/pull/812,https://github.com/hyperledger/indy-sdk/pull/812,"`buildCommand` was initially a replacement for all entries, but when I pulled master, I had to change it up a little bit in order to get it to work with 
```groovy
def libindyFeatures = ""--features sodium_static""
//...
sh ""cargo build $libindyFeatures""
```

I guess I'm not sure how to reconcile the specific needs of this specific build case and still abstract out our build command. Should I just remove the variable entirely, or is there a better way to do this?",6ddde6e05ddcbe2c361ffef18a98c211f266cbf7,2018-05-30 19:53:46,191901658,"@@ -1,5 +1,8 @@
 #!groovy
 
+def features = ""--features fatal_warnings""
+def buildCommand = ""cargo build ${features}""",,2018-06-29 08:16:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191901658,https://github.com/hyperledger/indy-sdk/pull/812#discussion_r191901658,stevengubler
https://github.com/hyperledger/indy-sdk/pull/812,https://github.com/hyperledger/indy-sdk/pull/812,I like that idea. Makes a lot more sense. Should I make the change or wait for @vimmerru's input?,6ddde6e05ddcbe2c361ffef18a98c211f266cbf7,2018-05-30 19:55:21,191902119,"@@ -1,3 +1,6 @@
+// If compiling with feature ""fatal_warnings"", the build will fail on all warnings",,2018-06-29 08:16:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191902119,https://github.com/hyperledger/indy-sdk/pull/812#discussion_r191902119,stevengubler
https://github.com/hyperledger/indy-sdk/pull/811,https://github.com/hyperledger/indy-sdk/pull/811,"`new_keys` is misleading here, please rename it. Actually keys are not changed, only encrypted representation is changed.",0ff83420582fc97e5be8c27602bb81438b9bb89e,2018-05-30 08:44:43,191687153,"@@ -239,6 +252,12 @@ impl Wallet {
         Ok(())
     }
 
+    pub(super) fn rotate_key(&self, new_master_key: &[u8]) -> Result<(), WalletError> {
+        let new_keys = self.keys.encrypt(new_master_key);",,2018-05-30 12:53:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191687153,https://github.com/hyperledger/indy-sdk/pull/811#discussion_r191687153,jovfer
https://github.com/hyperledger/indy-sdk/pull/811,https://github.com/hyperledger/indy-sdk/pull/811,I think it's better to fetch something and check that after key rotation fetched value is the same,0ff83420582fc97e5be8c27602bb81438b9bb89e,2018-05-30 08:46:21,191687642,"@@ -1511,4 +1542,39 @@ mod tests {
         let get_pool_name_res = wallet_service.get_pool_name(1);
         assert_match!(Err(WalletError::InvalidHandle(_)), get_pool_name_res);
     }
+
+    /**
+        Key rotation test
+    */
+    #[test]
+    fn wallet_service_key_rotation() {
+        _cleanup();
+
+        let wallet_service = WalletService::new();
+        wallet_service.create_wallet(""pool1"", ""test_wallet"", None, None, &_credentials()).unwrap();
+        let wallet_handle = wallet_service.open_wallet(""test_wallet"", None, &_credentials()).unwrap();
+
+        wallet_service.add_record(wallet_handle, ""type"", ""key1"", ""value1"", ""{}"").unwrap();
+        let record = wallet_service.get_record(wallet_handle, ""type"", ""key1"", &_fetch_options(false, false, false)).unwrap();",,2018-05-30 12:53:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191687642,https://github.com/hyperledger/indy-sdk/pull/811#discussion_r191687642,jovfer
https://github.com/hyperledger/indy-sdk/pull/811,https://github.com/hyperledger/indy-sdk/pull/811,Is boxing really required here?,0ff83420582fc97e5be8c27602bb81438b9bb89e,2018-05-30 08:48:49,191688387,"@@ -63,22 +64,30 @@ impl<'a> JsonDecodable<'a> for WalletConfig {}
 #[derive(Debug)]
 pub struct WalletCredentials {
     master_key: [u8; 32],
+    rekey: Option<Box<[u8; 32]>>,",,2018-05-30 12:53:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191688387,https://github.com/hyperledger/indy-sdk/pull/811#discussion_r191688387,jovfer
https://github.com/hyperledger/indy-sdk/pull/811,https://github.com/hyperledger/indy-sdk/pull/811,I dont want to increase the size of WalletCredentials by 32 bytes since 99% of the time it will be empty,0ff83420582fc97e5be8c27602bb81438b9bb89e,2018-05-30 09:00:51,191691949,"@@ -63,22 +64,30 @@ impl<'a> JsonDecodable<'a> for WalletConfig {}
 #[derive(Debug)]
 pub struct WalletCredentials {
     master_key: [u8; 32],
+    rekey: Option<Box<[u8; 32]>>,",,2018-05-30 12:53:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191691949,https://github.com/hyperledger/indy-sdk/pull/811#discussion_r191691949,keichiri
https://github.com/hyperledger/indy-sdk/pull/811,https://github.com/hyperledger/indy-sdk/pull/811,"yes, that is what asserts below do.",0ff83420582fc97e5be8c27602bb81438b9bb89e,2018-05-30 09:01:47,191692216,"@@ -1511,4 +1542,39 @@ mod tests {
         let get_pool_name_res = wallet_service.get_pool_name(1);
         assert_match!(Err(WalletError::InvalidHandle(_)), get_pool_name_res);
     }
+
+    /**
+        Key rotation test
+    */
+    #[test]
+    fn wallet_service_key_rotation() {
+        _cleanup();
+
+        let wallet_service = WalletService::new();
+        wallet_service.create_wallet(""pool1"", ""test_wallet"", None, None, &_credentials()).unwrap();
+        let wallet_handle = wallet_service.open_wallet(""test_wallet"", None, &_credentials()).unwrap();
+
+        wallet_service.add_record(wallet_handle, ""type"", ""key1"", ""value1"", ""{}"").unwrap();
+        let record = wallet_service.get_record(wallet_handle, ""type"", ""key1"", &_fetch_options(false, false, false)).unwrap();",,2018-05-30 12:53:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191692216,https://github.com/hyperledger/indy-sdk/pull/811#discussion_r191692216,keichiri
https://github.com/hyperledger/indy-sdk/pull/811,https://github.com/hyperledger/indy-sdk/pull/811,"yes, new_keys might be misleading. I agree",0ff83420582fc97e5be8c27602bb81438b9bb89e,2018-05-30 09:07:11,191693755,"@@ -239,6 +252,12 @@ impl Wallet {
         Ok(())
     }
 
+    pub(super) fn rotate_key(&self, new_master_key: &[u8]) -> Result<(), WalletError> {
+        let new_keys = self.keys.encrypt(new_master_key);",,2018-05-30 12:53:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191693755,https://github.com/hyperledger/indy-sdk/pull/811#discussion_r191693755,keichiri
https://github.com/hyperledger/indy-sdk/pull/811,https://github.com/hyperledger/indy-sdk/pull/811,"I see only asserts like `record.get_value().is_none()`
It's better to have something like
```
...
wallet.add_record(..., value1_const, ...)
...
assert_eq!(fetched_value, Some(value1_const));
...
rotate_keys();
...
assert_eq!(fetched_value, Some(value1_const));
```",0ff83420582fc97e5be8c27602bb81438b9bb89e,2018-05-30 09:48:07,191706234,"@@ -1511,4 +1542,39 @@ mod tests {
         let get_pool_name_res = wallet_service.get_pool_name(1);
         assert_match!(Err(WalletError::InvalidHandle(_)), get_pool_name_res);
     }
+
+    /**
+        Key rotation test
+    */
+    #[test]
+    fn wallet_service_key_rotation() {
+        _cleanup();
+
+        let wallet_service = WalletService::new();
+        wallet_service.create_wallet(""pool1"", ""test_wallet"", None, None, &_credentials()).unwrap();
+        let wallet_handle = wallet_service.open_wallet(""test_wallet"", None, &_credentials()).unwrap();
+
+        wallet_service.add_record(wallet_handle, ""type"", ""key1"", ""value1"", ""{}"").unwrap();
+        let record = wallet_service.get_record(wallet_handle, ""type"", ""key1"", &_fetch_options(false, false, false)).unwrap();",,2018-05-30 12:53:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191706234,https://github.com/hyperledger/indy-sdk/pull/811#discussion_r191706234,jovfer
https://github.com/hyperledger/indy-sdk/pull/811,https://github.com/hyperledger/indy-sdk/pull/811,"@jovfer 
@keichiri 

I see the following problems here:

- 32 is a magic number
- Memory allocated for Keys should be zeroed after usage. See any sodiumoxide Key type
- Box here looks like non-obvious micro-optimization.",0ff83420582fc97e5be8c27602bb81438b9bb89e,2018-05-30 10:00:15,191709761,"@@ -63,22 +64,30 @@ impl<'a> JsonDecodable<'a> for WalletConfig {}
 #[derive(Debug)]
 pub struct WalletCredentials {
     master_key: [u8; 32],
+    rekey: Option<Box<[u8; 32]>>,",,2018-05-30 12:53:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191709761,https://github.com/hyperledger/indy-sdk/pull/811#discussion_r191709761,vimmerru
https://github.com/hyperledger/indy-sdk/pull/811,https://github.com/hyperledger/indy-sdk/pull/811,oh yes you are right. I brainfarted and reused wrong test. I will change.My bad,0ff83420582fc97e5be8c27602bb81438b9bb89e,2018-05-30 12:06:52,191740442,"@@ -1511,4 +1542,39 @@ mod tests {
         let get_pool_name_res = wallet_service.get_pool_name(1);
         assert_match!(Err(WalletError::InvalidHandle(_)), get_pool_name_res);
     }
+
+    /**
+        Key rotation test
+    */
+    #[test]
+    fn wallet_service_key_rotation() {
+        _cleanup();
+
+        let wallet_service = WalletService::new();
+        wallet_service.create_wallet(""pool1"", ""test_wallet"", None, None, &_credentials()).unwrap();
+        let wallet_handle = wallet_service.open_wallet(""test_wallet"", None, &_credentials()).unwrap();
+
+        wallet_service.add_record(wallet_handle, ""type"", ""key1"", ""value1"", ""{}"").unwrap();
+        let record = wallet_service.get_record(wallet_handle, ""type"", ""key1"", &_fetch_options(false, false, false)).unwrap();",,2018-05-30 12:53:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191740442,https://github.com/hyperledger/indy-sdk/pull/811#discussion_r191740442,keichiri
https://github.com/hyperledger/indy-sdk/pull/811,https://github.com/hyperledger/indy-sdk/pull/811,"This (except the Box) is the same approach used for master key in credentials. 
So I think if it is an issue now, it must have been before, since it was implemented.

About Box, why is it nonobvious? It is totally normal practice to use memory smartly?

Ok, i will change all of this as soon as possible",0ff83420582fc97e5be8c27602bb81438b9bb89e,2018-05-30 12:14:35,191742430,"@@ -63,22 +64,30 @@ impl<'a> JsonDecodable<'a> for WalletConfig {}
 #[derive(Debug)]
 pub struct WalletCredentials {
     master_key: [u8; 32],
+    rekey: Option<Box<[u8; 32]>>,",,2018-05-30 12:53:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191742430,https://github.com/hyperledger/indy-sdk/pull/811#discussion_r191742430,keichiri
https://github.com/hyperledger/indy-sdk/pull/811,https://github.com/hyperledger/indy-sdk/pull/811,"agree with Janko about the 2nd point from Slava's review. It's something like out of scope of this PR. This issue was introduced in first implementation of encrypted wallet and wasn't fixed while latest large refactoring from Wallet to Wallet+Storage.
As for Box, this is really micro-optimization. WalletCredential used as single object. 24 bytes vs minor improvement of readability - I prefer doesn't think why Box is needed here, but don't used for the first filed of the structure",0ff83420582fc97e5be8c27602bb81438b9bb89e,2018-05-30 12:34:11,191748346,"@@ -63,22 +64,30 @@ impl<'a> JsonDecodable<'a> for WalletConfig {}
 #[derive(Debug)]
 pub struct WalletCredentials {
     master_key: [u8; 32],
+    rekey: Option<Box<[u8; 32]>>,",,2018-05-30 12:53:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191748346,https://github.com/hyperledger/indy-sdk/pull/811#discussion_r191748346,jovfer
https://github.com/hyperledger/indy-sdk/pull/811,https://github.com/hyperledger/indy-sdk/pull/811,"I removed Box. IT was not used for first field since it is mandatory, always present.

But I agree its not necessary so I removed it.

Anyway, about 2nd point. I agree that it is very needed, and I will open an additional PR soon for it.

I will push the change now",0ff83420582fc97e5be8c27602bb81438b9bb89e,2018-05-30 12:44:07,191751488,"@@ -63,22 +64,30 @@ impl<'a> JsonDecodable<'a> for WalletConfig {}
 #[derive(Debug)]
 pub struct WalletCredentials {
     master_key: [u8; 32],
+    rekey: Option<Box<[u8; 32]>>,",,2018-05-30 12:53:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191751488,https://github.com/hyperledger/indy-sdk/pull/811#discussion_r191751488,keichiri
https://github.com/hyperledger/indy-sdk/pull/810,https://github.com/hyperledger/indy-sdk/pull/810,"I suggest to rename `most_popular_vote` to something like `confirmed_vote_for_ledger_status`. Not sure about exact name, but here it's not just most popular, now it's confirmed by consensus.",774624a971ebd0795ca58f710f0b75c21c84a15c,2018-05-30 07:18:49,191663627,"@@ -115,40 +118,67 @@ impl CatchupHandler {
         if self.pending_catchup.is_some() {
             return Ok(CatchupProgress::InProgress);
         }
-        let mut votes: HashMap<(String, usize), usize> = HashMap::new();
-        for node_vote in &self.nodes_votes {
-            if let &Some(ref node_vote) = node_vote {
-                let cnt = *votes.get(&node_vote).unwrap_or(&0) + 1;
-                votes.insert((node_vote.0.clone(), node_vote.1), cnt);
-            }
-        }
+
+        let votes: HashMap<(String, usize, Option<Vec<String>>), usize> = self.nodes_votes.iter().cloned()
+            .filter_map(|e| e)
+            .fold(HashMap::new(), |mut acc, vote| {
+                let cnt = acc.get(&vote).unwrap_or(&0) + 1;
+                acc.insert(vote, cnt);
+                acc
+            });
+
         if let Some((most_popular_vote, votes_cnt)) = votes.iter().max_by_key(|entry| entry.1) {
             if *votes_cnt == self.nodes.len() - self.f {
-                let &(ref target_mt_root, target_mt_size) = most_popular_vote;
-                let cur_mt_size = self.merkle_tree.count();
-                let cur_mt_hash = self.merkle_tree.root_hash().to_base58();
-                if target_mt_size == cur_mt_size {
-                    if cur_mt_hash.eq(target_mt_root) {
-                        return Ok(CatchupProgress::NotNeeded);
-                    } else {
-                        return Err(PoolError::CommonError(CommonError::InvalidState(
-                            ""Ledger merkle tree doesn't acceptable for current tree."".to_string())));
+                return match self._try_to_catch_up(most_popular_vote) {
+                    //WARNING: If we receive invalid cache then it means that cache was cleared. We need to rebuild merkle tree and try to catch up once again
+                    Err(PoolError::InvalidCacheCleared) => {
+                        self.merkle_tree = PoolWorker::restore_merkle_tree_from_pool_name(&self.pool_name)?;
+                        self._try_to_catch_up(most_popular_vote)
                     }
-                } else if target_mt_size > cur_mt_size {
-                    self.target_mt_size = target_mt_size;
-                    self.target_mt_root = target_mt_root.from_base58().map_err(|_|
-                        CommonError::InvalidStructure(
-                            ""Can't parse target MerkleTree hash from nodes responses"".to_string()))?;
-                    return Ok(CatchupProgress::ShouldBeStarted);
-                } else {
-                    return Err(PoolError::CommonError(CommonError::InvalidState(
-                        ""Local merkle tree greater than mt from ledger"".to_string())));
+                    a => a
                 }
             }
         }
         Ok(CatchupProgress::InProgress)
     }
 
+    fn _try_to_catch_up(&mut self, most_popular_vote: &(String, usize, Option<Vec<String>>)) -> Result<CatchupProgress, PoolError> {",,2018-06-04 11:57:52,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191663627,https://github.com/hyperledger/indy-sdk/pull/810#discussion_r191663627,jovfer
https://github.com/hyperledger/indy-sdk/pull/810,https://github.com/hyperledger/indy-sdk/pull/810,"missed consistency proof is something like protocol error. My personal vote to throw error for whole catchup process here
@vimmerru do you have another vision?",774624a971ebd0795ca58f710f0b75c21c84a15c,2018-05-30 07:21:19,191664170,"@@ -115,40 +118,67 @@ impl CatchupHandler {
         if self.pending_catchup.is_some() {
             return Ok(CatchupProgress::InProgress);
         }
-        let mut votes: HashMap<(String, usize), usize> = HashMap::new();
-        for node_vote in &self.nodes_votes {
-            if let &Some(ref node_vote) = node_vote {
-                let cnt = *votes.get(&node_vote).unwrap_or(&0) + 1;
-                votes.insert((node_vote.0.clone(), node_vote.1), cnt);
-            }
-        }
+
+        let votes: HashMap<(String, usize, Option<Vec<String>>), usize> = self.nodes_votes.iter().cloned()
+            .filter_map(|e| e)
+            .fold(HashMap::new(), |mut acc, vote| {
+                let cnt = acc.get(&vote).unwrap_or(&0) + 1;
+                acc.insert(vote, cnt);
+                acc
+            });
+
         if let Some((most_popular_vote, votes_cnt)) = votes.iter().max_by_key(|entry| entry.1) {
             if *votes_cnt == self.nodes.len() - self.f {
-                let &(ref target_mt_root, target_mt_size) = most_popular_vote;
-                let cur_mt_size = self.merkle_tree.count();
-                let cur_mt_hash = self.merkle_tree.root_hash().to_base58();
-                if target_mt_size == cur_mt_size {
-                    if cur_mt_hash.eq(target_mt_root) {
-                        return Ok(CatchupProgress::NotNeeded);
-                    } else {
-                        return Err(PoolError::CommonError(CommonError::InvalidState(
-                            ""Ledger merkle tree doesn't acceptable for current tree."".to_string())));
+                return match self._try_to_catch_up(most_popular_vote) {
+                    //WARNING: If we receive invalid cache then it means that cache was cleared. We need to rebuild merkle tree and try to catch up once again
+                    Err(PoolError::InvalidCacheCleared) => {
+                        self.merkle_tree = PoolWorker::restore_merkle_tree_from_pool_name(&self.pool_name)?;
+                        self._try_to_catch_up(most_popular_vote)
                     }
-                } else if target_mt_size > cur_mt_size {
-                    self.target_mt_size = target_mt_size;
-                    self.target_mt_root = target_mt_root.from_base58().map_err(|_|
-                        CommonError::InvalidStructure(
-                            ""Can't parse target MerkleTree hash from nodes responses"".to_string()))?;
-                    return Ok(CatchupProgress::ShouldBeStarted);
-                } else {
-                    return Err(PoolError::CommonError(CommonError::InvalidState(
-                        ""Local merkle tree greater than mt from ledger"".to_string())));
+                    a => a
                 }
             }
         }
         Ok(CatchupProgress::InProgress)
     }
 
+    fn _try_to_catch_up(&mut self, most_popular_vote: &(String, usize, Option<Vec<String>>)) -> Result<CatchupProgress, PoolError> {
+        let &(ref target_mt_root, target_mt_size, ref hashes) = most_popular_vote;
+        let cur_mt_size = self.merkle_tree.count();
+        let cur_mt_hash = self.merkle_tree.root_hash().to_base58();
+        if target_mt_size == cur_mt_size {
+            if cur_mt_hash.eq(target_mt_root) {
+                return Ok(CatchupProgress::NotNeeded);
+            } else {
+                PoolWorker::drop_saved_txns(&self.pool_name)?;
+                return Err(PoolError::CommonError(CommonError::InvalidState(
+                    ""Ledger merkle tree doesn't acceptable for current tree."".to_string())));
+            }
+        } else if target_mt_size > cur_mt_size {
+            self.target_mt_size = target_mt_size;
+            self.target_mt_root = target_mt_root.from_base58().map_err(|_|
+                CommonError::InvalidStructure(
+                    ""Can't parse target MerkleTree hash from nodes responses"".to_string()))?;
+            match hashes {
+                &None => (),",,2018-06-04 11:57:52,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191664170,https://github.com/hyperledger/indy-sdk/pull/810#discussion_r191664170,jovfer
https://github.com/hyperledger/indy-sdk/pull/810,https://github.com/hyperledger/indy-sdk/pull/810,`\n` should not be used as delimiter if we are working with binary data,774624a971ebd0795ca58f710f0b75c21c84a15c,2018-05-30 07:26:11,191665342,"@@ -357,38 +359,141 @@ impl PoolWorker {
 
 
     fn _restore_merkle_tree_from_file(txn_file: &str) -> Result<MerkleTree, PoolError> {
-        PoolWorker::_restore_merkle_tree(&PathBuf::from(txn_file))
+        PoolWorker::_restore_merkle_tree(&PathBuf::from(txn_file), Box::new(PoolWorker::_parse_txn_from_json))
     }
 
-    fn _restore_merkle_tree_from_pool_name(pool_name: &str) -> Result<MerkleTree, PoolError> {
+    fn _restore_merkle_tree(file_name: &PathBuf, mapper: Box<Fn(&[u8]) -> Result<Vec<u8>, CommonError>>) -> Result<MerkleTree, PoolError> {
+        let mut mt = MerkleTree::from_vec(Vec::new()).map_err(map_err_trace!())?;
+
+        let mut f = fs::File::open(file_name).map_err(map_err_trace!())?;
+
+        let mut txns: Vec<u8> = vec![];
+        f.read_to_end(&mut txns).map_err(map_err_trace!())?;
+        let vec = txns.split(|num| (*num as char) == '\n').collect::<Vec<&[u8]>>();
+        for line in vec {
+            let bytes = mapper(line)?;
+            if line.is_empty() { continue };
+            mt.append(bytes).map_err(map_err_trace!())?;
+        }
+        Ok(mt)
+    }
+
+    pub fn restore_merkle_tree_from_pool_name(pool_name: &str) -> Result<MerkleTree, PoolError> {
+        let mut p = EnvironmentUtils::pool_path(pool_name);
+
+        let mut p_stored = p.clone();
+        p_stored.push(""stored"");
+        p_stored.set_extension(""btxn"");
+
+        if !p_stored.exists() {
+            p.push(pool_name);
+            p.set_extension(""txn"");
+
+            if !p.exists() {
+                return Err(PoolError::NotCreated(format!(""Pool is not created for name: {:?}"", pool_name)));
+            }
+
+            PoolWorker::_restore_merkle_tree(&p, Box::new(PoolWorker::_parse_txn_from_json))
+        } else {
+            PoolWorker::_restore_merkle_tree(&p_stored, Box::new(|u| Ok(u.to_vec())))
+        }
+    }
+
+    fn _parse_txn_from_json(txn: &[u8]) -> Result<Vec<u8>, CommonError> {
+        let txn_str = from_utf8(txn).map_err(|_| CommonError::InvalidStructure(format!(""Can't parse valid UTF-8 string from this array: {:?}"", txn)))?;
+
+        if txn_str.trim().is_empty() {
+            return Ok(vec![]);
+        }
+
+        let genesis_txn: SJsonValue = serde_json::from_str(txn_str.trim())
+            .map_err(|err| CommonError::InvalidStructure(format!(""Can't deserialize Genesis Transaction file: {:?}"", err)))?;
+        rmp_serde::encode::to_vec_named(&genesis_txn)
+            .map_err(|err| CommonError::InvalidStructure(format!(""Can't deserialize Genesis Transaction file: {:?}"", err)))
+    }
+
+    pub fn dump_new_txns(pool_name: &str, txns: &Vec<Vec<u8>>) -> Result<(), PoolError>{
         let mut p = EnvironmentUtils::pool_path(pool_name);
-        //TODO firstly try to deserialize merkle tree
-        p.push(pool_name);
-        p.set_extension(""txn"");
 
+        p.push(""stored"");
+        p.set_extension(""btxn"");
         if !p.exists() {
-            return Err(PoolError::NotCreated(format!(""Pool is not created for name: {:?}"", pool_name)));
+            PoolWorker::_dump_genesis_to_stored(&p, pool_name)?;
         }
 
-        PoolWorker::_restore_merkle_tree(&p)
+        let mut file = fs::File::create(p)
+            .map_err(|e| CommonError::IOError(e))
+            .map_err(map_err_err!())?;
+
+        PoolWorker::_dump_vec_to_file(txns, &mut file)
     }
 
-    fn _restore_merkle_tree(file_mame: &PathBuf) -> Result<MerkleTree, PoolError> {
-        let mut mt = MerkleTree::from_vec(Vec::new()).map_err(map_err_trace!())?;
+    fn _dump_genesis_to_stored(p: &PathBuf, pool_name: &str) -> Result<(), PoolError> {
+        let mut file = fs::File::create(p)
+            .map_err(|e| CommonError::IOError(e))
+            .map_err(map_err_err!())?;
+
+        let mut p_genesis = EnvironmentUtils::pool_path(pool_name);
+        p_genesis.push(pool_name);
+        p_genesis.set_extension(""txn"");
+
+        if !p_genesis.exists() {
+            return Err(PoolError::NotCreated(format!(""Pool is not created for name: {:?}"", pool_name)));
+        }
+        
+        let genesis_vec = PoolWorker::_genesis_to_binary(&p_genesis)?;
+
+        PoolWorker::_dump_vec_to_file(&genesis_vec, &mut file)
+    }
 
-        let f = fs::File::open(file_mame).map_err(map_err_trace!())?;
+    fn _dump_vec_to_file(v: &Vec<Vec<u8>>, file : &mut fs::File) -> Result<(), PoolError> {
+        v.into_iter().map(|vec| {
+            file.write_all(vec).map_err(map_err_trace!())?;
+            file.write_all(""\n"".as_bytes()).map_err(map_err_trace!())",,2018-06-04 11:57:52,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191665342,https://github.com/hyperledger/indy-sdk/pull/810#discussion_r191665342,jovfer
https://github.com/hyperledger/indy-sdk/pull/810,https://github.com/hyperledger/indy-sdk/pull/810,"1. Inconsistent description
1. Should be added to all libindy consumers: wrappers, plugin, cli",774624a971ebd0795ca58f710f0b75c21c84a15c,2018-05-30 07:28:22,191665931,"@@ -141,6 +141,9 @@ pub enum ErrorCode
     // Timeout for action
     PoolLedgerTimeout = 307,
 
+    // Timeout for action",,2018-06-04 11:57:52,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191665931,https://github.com/hyperledger/indy-sdk/pull/810#discussion_r191665931,jovfer
https://github.com/hyperledger/indy-sdk/pull/810,https://github.com/hyperledger/indy-sdk/pull/810,"I suggest to try to pop cache cleaning to this method. like
```
self._try_to_catch_up().or_else(|err| {
  drop_cache() // here or inside next if
  if err == InvalidCache { try_again() } else { err } 
})
```
It may be more clear and don't require WARNING comment",774624a971ebd0795ca58f710f0b75c21c84a15c,2018-05-30 07:38:28,191668454,"@@ -115,40 +118,67 @@ impl CatchupHandler {
         if self.pending_catchup.is_some() {
             return Ok(CatchupProgress::InProgress);
         }
-        let mut votes: HashMap<(String, usize), usize> = HashMap::new();
-        for node_vote in &self.nodes_votes {
-            if let &Some(ref node_vote) = node_vote {
-                let cnt = *votes.get(&node_vote).unwrap_or(&0) + 1;
-                votes.insert((node_vote.0.clone(), node_vote.1), cnt);
-            }
-        }
+
+        let votes: HashMap<(String, usize, Option<Vec<String>>), usize> = self.nodes_votes.iter().cloned()
+            .filter_map(|e| e)
+            .fold(HashMap::new(), |mut acc, vote| {
+                let cnt = acc.get(&vote).unwrap_or(&0) + 1;
+                acc.insert(vote, cnt);
+                acc
+            });
+
         if let Some((most_popular_vote, votes_cnt)) = votes.iter().max_by_key(|entry| entry.1) {
             if *votes_cnt == self.nodes.len() - self.f {
-                let &(ref target_mt_root, target_mt_size) = most_popular_vote;
-                let cur_mt_size = self.merkle_tree.count();
-                let cur_mt_hash = self.merkle_tree.root_hash().to_base58();
-                if target_mt_size == cur_mt_size {
-                    if cur_mt_hash.eq(target_mt_root) {
-                        return Ok(CatchupProgress::NotNeeded);
-                    } else {
-                        return Err(PoolError::CommonError(CommonError::InvalidState(
-                            ""Ledger merkle tree doesn't acceptable for current tree."".to_string())));
+                return match self._try_to_catch_up(most_popular_vote) {
+                    //WARNING: If we receive invalid cache then it means that cache was cleared. We need to rebuild merkle tree and try to catch up once again",,2018-06-04 11:57:52,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191668454,https://github.com/hyperledger/indy-sdk/pull/810#discussion_r191668454,jovfer
https://github.com/hyperledger/indy-sdk/pull/810,https://github.com/hyperledger/indy-sdk/pull/810,Right now all branches of the function's code return Err. May be we should return `Ok(())` in this case as actually cache dropping is successful? ,774624a971ebd0795ca58f710f0b75c21c84a15c,2018-05-30 12:39:15,191749997,"@@ -391,6 +380,136 @@ impl PoolWorker {
         Ok(mt)
     }
 
+    fn _restore_merkle_tree_from_cache(file_name: &PathBuf) -> Result<MerkleTree, PoolError> {
+        let mut mt = MerkleTree::from_vec(Vec::new()).map_err(map_err_trace!())?;
+
+        let mut f = fs::File::open(file_name).map_err(map_err_trace!())?;
+
+        while let Ok(bytes) = f.read_u64::<LittleEndian>().map_err(CommonError::IOError).map_err(PoolError::from) {
+            let mut buf = vec![0; bytes as usize];
+            f.read(buf.as_mut()).map_err(map_err_trace!())?;
+            mt.append(buf.to_vec()).map_err(map_err_trace!())?;
+        }
+        Ok(mt)
+    }
+
+    pub fn restore_merkle_tree_from_pool_name(pool_name: &str) -> Result<MerkleTree, PoolError> {
+        let mut p = EnvironmentUtils::pool_path(pool_name);
+
+        let mut p_stored = p.clone();
+        p_stored.push(""stored"");
+        p_stored.set_extension(""btxn"");
+
+        if !p_stored.exists() {
+            p.push(pool_name);
+            p.set_extension(""txn"");
+
+            if !p.exists() {
+                return Err(PoolError::NotCreated(format!(""Pool is not created for name: {:?}"", pool_name)));
+            }
+
+            PoolWorker::_restore_merkle_tree_from_genesis(&p)
+        } else {
+            PoolWorker::_restore_merkle_tree_from_cache(&p_stored)
+        }
+    }
+
+    fn _parse_txn_from_json(txn: &[u8]) -> Result<Vec<u8>, CommonError> {
+        let txn_str = from_utf8(txn).map_err(|_| CommonError::InvalidStructure(format!(""Can't parse valid UTF-8 string from this array: {:?}"", txn)))?;
+
+        if txn_str.trim().is_empty() {
+            return Ok(vec![]);
+        }
+
+        let genesis_txn: SJsonValue = serde_json::from_str(txn_str.trim())
+            .map_err(|err| CommonError::InvalidStructure(format!(""Can't deserialize Genesis Transaction file: {:?}"", err)))?;
+        rmp_serde::encode::to_vec_named(&genesis_txn)
+            .map_err(|err| CommonError::InvalidStructure(format!(""Can't deserialize Genesis Transaction file: {:?}"", err)))
+    }
+
+    pub fn dump_new_txns(pool_name: &str, txns: &Vec<Vec<u8>>) -> Result<(), PoolError>{
+        let mut p = EnvironmentUtils::pool_path(pool_name);
+
+        p.push(""stored"");
+        p.set_extension(""btxn"");
+        if !p.exists() {
+            PoolWorker::_dump_genesis_to_stored(&p, pool_name)?;
+        }
+
+        let mut file = fs::OpenOptions::new().append(true).open(p)
+            .map_err(|e| CommonError::IOError(e))
+            .map_err(map_err_err!())?;
+
+        PoolWorker::_dump_vec_to_file(txns, &mut file)
+    }
+
+    fn _dump_genesis_to_stored(p: &PathBuf, pool_name: &str) -> Result<(), PoolError> {
+        let mut file = fs::File::create(p)
+            .map_err(|e| CommonError::IOError(e))
+            .map_err(map_err_err!())?;
+
+        let mut p_genesis = EnvironmentUtils::pool_path(pool_name);
+        p_genesis.push(pool_name);
+        p_genesis.set_extension(""txn"");
+
+        if !p_genesis.exists() {
+            return Err(PoolError::NotCreated(format!(""Pool is not created for name: {:?}"", pool_name)));
+        }
+        
+        let genesis_vec = PoolWorker::_genesis_to_binary(&p_genesis)?;
+        PoolWorker::_dump_vec_to_file(&genesis_vec, &mut file)
+    }
+
+    fn _dump_vec_to_file(v: &Vec<Vec<u8>>, file : &mut fs::File) -> Result<(), PoolError> {
+        v.into_iter().map(|vec| {
+            file.write_u64::<LittleEndian>(vec.len() as u64).map_err(map_err_trace!())?;
+            file.write_all(vec).map_err(map_err_trace!())
+        }).fold(Ok(()), |acc, next| {
+            match (acc, next) {
+                (Err(e), _) => Err(e),
+                (_, Err(e)) => Err(PoolError::CommonError(CommonError::IOError(e))),
+                _ => Ok(()),
+            }
+        })
+    }
+
+    fn _genesis_to_binary(p: &PathBuf) -> Result<Vec<Vec<u8>>, PoolError> {
+        let f = fs::File::open(p).map_err(map_err_trace!())?;
+        let reader = io::BufReader::new(&f);
+        reader
+            .lines()
+            .into_iter()
+            .map(|res| {
+                let line = res.map_err(map_err_trace!())?;
+                PoolWorker::_parse_txn_from_json(line.trim().as_bytes()).map_err(PoolError::from).map_err(map_err_err!())
+            })
+            .fold(Ok(Vec::new()), |acc, next| {
+                match (acc, next) {
+                    (Err(e), _) | (_, Err(e)) => Err(e),
+                    (Ok(mut acc), Ok(res)) => {
+                        let mut vec = vec![];
+                        vec.append(&mut acc);
+                        vec.push(res);
+                        Ok(vec)
+                    }
+                }
+            })
+    }
+
+    pub fn drop_saved_txns(pool_name: &str) -> Result<(), PoolError> {
+        warn!(""Cache is invalid -- dropping it!"");
+        let mut p = EnvironmentUtils::pool_path(pool_name);
+
+        p.push(""stored"");
+        p.set_extension(""btxn"");
+        if p.exists() {
+            fs::remove_file(p).map_err(CommonError::IOError).map_err(PoolError::from)?;
+            Err(PoolError::InvalidCacheCleared)",,2018-06-04 11:57:52,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191749997,https://github.com/hyperledger/indy-sdk/pull/810#discussion_r191749997,jovfer
https://github.com/hyperledger/indy-sdk/pull/810,https://github.com/hyperledger/indy-sdk/pull/810,"If it's internal error, may be we should not pass it into API.
@vimmerru sounds like we have first case when some error is actually internal. May be we can map this case to CommonInvalidState or even to `unreachable` macros",774624a971ebd0795ca58f710f0b75c21c84a15c,2018-05-30 12:44:36,191751632,"@@ -81,6 +85,7 @@ impl ToErrorCode for PoolError {
             PoolError::Terminate => ErrorCode::PoolLedgerTerminated,
             PoolError::Timeout => ErrorCode::PoolLedgerTimeout,
             PoolError::AlreadyExists(_) => ErrorCode::PoolLedgerConfigAlreadyExistsError,
+            PoolError::InvalidCacheCleared => ErrorCode::PoolLedgerInvalidCache,",,2018-06-04 11:57:52,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191751632,https://github.com/hyperledger/indy-sdk/pull/810#discussion_r191751632,jovfer
https://github.com/hyperledger/indy-sdk/pull/810,https://github.com/hyperledger/indy-sdk/pull/810,please remove it,774624a971ebd0795ca58f710f0b75c21c84a15c,2018-06-04 11:55:48,192715137,"@@ -0,0 +1,111 @@
+Pre-trans",,2018-06-04 11:57:52,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192715137,https://github.com/hyperledger/indy-sdk/pull/810#discussion_r192715137,jovfer
https://github.com/hyperledger/indy-sdk/pull/807,https://github.com/hyperledger/indy-sdk/pull/807,"> Libindy allows to create and send custom transaction via plugged interface.

Not sure that it is 100% correct. More correct version:
1. Indy Node allows to extend supported requests with pluggins
2. libindy allows to send any request to node (we don't need plugins here), but some requests can be significantly optimized with signed state proofs. ",335db59ec8bac5c2bb481f1f87063942b815a725,2018-05-29 14:03:25,191436002,"@@ -0,0 +1,127 @@
+## Legend
+There are some types of requests to Nodes in the Pool allowing to use StateProof optimization in Client-Node communication.
+Instead of sending requests to all nodes in the Pool, a client can send a request to a single Node and expect StateProof signed by BLS multi-signature.
+
+BLS multi-signature (BLS MS) guaranties that there was a consensus of Nodes which signed some State identified by State RootHash.
+StateProof (SP) is small amount of data which allows to verify particular values against RootHash.
+Combination of BLS MS and SP allows clients to be sure about response of single node is a part of State signed by enough Nodes. 
+
+## Goals
+Libindy allows to create and send custom transaction via plugged interface.",,2018-06-04 07:24:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191436002,https://github.com/hyperledger/indy-sdk/pull/807#discussion_r191436002,vimmerru
https://github.com/hyperledger/indy-sdk/pull/807,https://github.com/hyperledger/indy-sdk/pull/807,Which data is supposed to free? In `parsed_sp`?,335db59ec8bac5c2bb481f1f87063942b815a725,2018-05-30 06:21:48,191653058,"@@ -0,0 +1,127 @@
+## Legend
+There are some types of requests to Nodes in the Pool allowing to use StateProof optimization in Client-Node communication.
+Instead of sending requests to all nodes in the Pool, a client can send a request to a single Node and expect StateProof signed by BLS multi-signature.
+
+BLS multi-signature (BLS MS) guaranties that there was a consensus of Nodes which signed some State identified by State RootHash.
+StateProof (SP) is small amount of data which allows to verify particular values against RootHash.
+Combination of BLS MS and SP allows clients to be sure about response of single node is a part of State signed by enough Nodes. 
+
+## Goals
+Libindy allows to create and send custom transaction via plugged interface.
+It is nice to have a way to support BLS MS and SP verification for these plugged transactions.
+
+Implementation of math for SP verification is a bit complicate for plugin logic.
+Therefore libindy should perform all math calculation inside.
+A plugin should provide handler to parse custom reply to fixed data structure.
+
+## API
+The signature of the handler is described below together with custom `free` call to deallocate result data.
+
+```rust
+extern fn custom_transaction_parser(reply_from_node: *const c_char, parsed_sp: *mut *const c_char) -> ErrCode;
+extern fn custom_free(data: *mut c_char) -> ErrCode;",,2018-06-04 07:24:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191653058,https://github.com/hyperledger/indy-sdk/pull/807#discussion_r191653058,lovesh
https://github.com/hyperledger/indy-sdk/pull/807,https://github.com/hyperledger/indy-sdk/pull/807,"Plugin supplies `cb` and is called with the result of the SP verification so like a true/false or maybe some more elaborate `false`, right? Wouldn't the plugin want access to `reply_from_node` in `cb`",335db59ec8bac5c2bb481f1f87063942b815a725,2018-05-30 06:24:25,191653476,"@@ -0,0 +1,127 @@
+## Legend
+There are some types of requests to Nodes in the Pool allowing to use StateProof optimization in Client-Node communication.
+Instead of sending requests to all nodes in the Pool, a client can send a request to a single Node and expect StateProof signed by BLS multi-signature.
+
+BLS multi-signature (BLS MS) guaranties that there was a consensus of Nodes which signed some State identified by State RootHash.
+StateProof (SP) is small amount of data which allows to verify particular values against RootHash.
+Combination of BLS MS and SP allows clients to be sure about response of single node is a part of State signed by enough Nodes. 
+
+## Goals
+Libindy allows to create and send custom transaction via plugged interface.
+It is nice to have a way to support BLS MS and SP verification for these plugged transactions.
+
+Implementation of math for SP verification is a bit complicate for plugin logic.
+Therefore libindy should perform all math calculation inside.
+A plugin should provide handler to parse custom reply to fixed data structure.
+
+## API
+The signature of the handler is described below together with custom `free` call to deallocate result data.
+
+```rust
+extern fn custom_transaction_parser(reply_from_node: *const c_char, parsed_sp: *mut *const c_char) -> ErrCode;
+extern fn custom_free(data: *mut c_char) -> ErrCode;
+``` 
+
+Libindy API will contain call to register handler for specific transaction type:
+```rust
+extern fn indy_register_transaction_parser_for_sp(command_handle: i32,
+                                                  txn_type: *const c_char,
+                                                  parser: custom_transaction_parser,
+                                                  free: custom_free,
+                                                  cb: extern fn(command_handle_: i32, err: ErrCode)) -> ErrCode;",,2018-06-04 07:24:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191653476,https://github.com/hyperledger/indy-sdk/pull/807#discussion_r191653476,lovesh
https://github.com/hyperledger/indy-sdk/pull/807,https://github.com/hyperledger/indy-sdk/pull/807,Why does it care that there is a prefix? The node returns the full keys as of now. It does not mention the prefix? Are you thinking of the optimisation that we planned for later?,335db59ec8bac5c2bb481f1f87063942b815a725,2018-05-30 06:31:55,191654741,"@@ -0,0 +1,127 @@
+## Legend
+There are some types of requests to Nodes in the Pool allowing to use StateProof optimization in Client-Node communication.
+Instead of sending requests to all nodes in the Pool, a client can send a request to a single Node and expect StateProof signed by BLS multi-signature.
+
+BLS multi-signature (BLS MS) guaranties that there was a consensus of Nodes which signed some State identified by State RootHash.
+StateProof (SP) is small amount of data which allows to verify particular values against RootHash.
+Combination of BLS MS and SP allows clients to be sure about response of single node is a part of State signed by enough Nodes. 
+
+## Goals
+Libindy allows to create and send custom transaction via plugged interface.
+It is nice to have a way to support BLS MS and SP verification for these plugged transactions.
+
+Implementation of math for SP verification is a bit complicate for plugin logic.
+Therefore libindy should perform all math calculation inside.
+A plugin should provide handler to parse custom reply to fixed data structure.
+
+## API
+The signature of the handler is described below together with custom `free` call to deallocate result data.
+
+```rust
+extern fn custom_transaction_parser(reply_from_node: *const c_char, parsed_sp: *mut *const c_char) -> ErrCode;
+extern fn custom_free(data: *mut c_char) -> ErrCode;
+``` 
+
+Libindy API will contain call to register handler for specific transaction type:
+```rust
+extern fn indy_register_transaction_parser_for_sp(command_handle: i32,
+                                                  txn_type: *const c_char,
+                                                  parser: custom_transaction_parser,
+                                                  free: custom_free,
+                                                  cb: extern fn(command_handle_: i32, err: ErrCode)) -> ErrCode;
+```
+
+### Parsed Data structure
+
+A plugin should parse `reply_from_node` and return back to libindy parsed data as JSON string.
+Actually this data is array of entities each of them is describe SP Trie and set of key-value pairs to verify against this trie.
+It can be represented as `Vec<ParsedSP>` serialized to JSON.
+
+
+```rust
+/** 
+ Single item to verification:
+ - SP Trie with RootHash
+ - BLS MS 
+ - set of key-value to verify
+*/ 
+struct ParsedSP {
+    proof_nodes: String, /// encoded SP Trie transferred from Node to Client
+    root_hash: String, /// RootHash of the Trie, start point for verification. Should be same with appropriate filed in BLS MS data 
+    kvs_to_verify: KeyValuesInSP, /// entities to verification against current SP Trie
+    multi_signature: JsonObject, /// BLS MS data for verification
+}
+
+/**
+ Variants of representation for items to verify against SP Trie
+ Right now 2 options are specified:
+ - simple array of key-value pair
+ - whole subtrie
+*/
+enum KeyValuesInSP {
+    Simple(KeyValueSimpleData),
+    SubTrie(KeyValuesSubTrieData),
+}
+
+/**
+ Simple variant of `KeyValuesInSP`.
+ 
+ All required data already present in parent SP Trie (built from `proof_nodes`).
+ `kvs` can be verified directly in parent trie 
+*/
+struct KeyValueSimpleData {
+    kvs: Vec<(String /* key */, String /* val */)>
+}
+
+/**
+ Subtrie variant of `KeyValuesInSP`.
+ 
+ In this case Client (libindy) should construct subtrie and append it into trie based on `proof_nodes`.
+ After this preparation each kv pair can be checked.
+*/
+struct KeyValuesSubTrieData {
+    sub_trie_prefix: Option<String>, /// common prefix of each pair in `kvs`. Should be used to correct merging initial trie and subtrie",,2018-06-04 07:24:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191654741,https://github.com/hyperledger/indy-sdk/pull/807#discussion_r191654741,lovesh
https://github.com/hyperledger/indy-sdk/pull/807,https://github.com/hyperledger/indy-sdk/pull/807,"```custom_transaction_parser```

This handler returns a null terminated string with result of request parsing by writing string pointer to memory located by ``````parsed_sp```` pointer.

Memory to store null terminated string will be allocated by plugin, so plugin should provide also handler for de-allocation of this memory.",335db59ec8bac5c2bb481f1f87063942b815a725,2018-05-30 06:38:56,191655901,"@@ -0,0 +1,127 @@
+## Legend
+There are some types of requests to Nodes in the Pool allowing to use StateProof optimization in Client-Node communication.
+Instead of sending requests to all nodes in the Pool, a client can send a request to a single Node and expect StateProof signed by BLS multi-signature.
+
+BLS multi-signature (BLS MS) guaranties that there was a consensus of Nodes which signed some State identified by State RootHash.
+StateProof (SP) is small amount of data which allows to verify particular values against RootHash.
+Combination of BLS MS and SP allows clients to be sure about response of single node is a part of State signed by enough Nodes. 
+
+## Goals
+Libindy allows to create and send custom transaction via plugged interface.
+It is nice to have a way to support BLS MS and SP verification for these plugged transactions.
+
+Implementation of math for SP verification is a bit complicate for plugin logic.
+Therefore libindy should perform all math calculation inside.
+A plugin should provide handler to parse custom reply to fixed data structure.
+
+## API
+The signature of the handler is described below together with custom `free` call to deallocate result data.
+
+```rust
+extern fn custom_transaction_parser(reply_from_node: *const c_char, parsed_sp: *mut *const c_char) -> ErrCode;
+extern fn custom_free(data: *mut c_char) -> ErrCode;",,2018-06-04 07:24:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191655901,https://github.com/hyperledger/indy-sdk/pull/807#discussion_r191655901,vimmerru
https://github.com/hyperledger/indy-sdk/pull/807,https://github.com/hyperledger/indy-sdk/pull/807,"```cb``` is called after libindy finished registration of this plugin. This operation is asynchronous and we need this ```cb``` to return result of registration operation. 

```parser: custom_transaction_parser,```` is the handler that plugin registers. You can find type ```custom_transaction_parser```  definition in previous lines. This handler consumes ```reply_from_node```",335db59ec8bac5c2bb481f1f87063942b815a725,2018-05-30 06:42:56,191656622,"@@ -0,0 +1,127 @@
+## Legend
+There are some types of requests to Nodes in the Pool allowing to use StateProof optimization in Client-Node communication.
+Instead of sending requests to all nodes in the Pool, a client can send a request to a single Node and expect StateProof signed by BLS multi-signature.
+
+BLS multi-signature (BLS MS) guaranties that there was a consensus of Nodes which signed some State identified by State RootHash.
+StateProof (SP) is small amount of data which allows to verify particular values against RootHash.
+Combination of BLS MS and SP allows clients to be sure about response of single node is a part of State signed by enough Nodes. 
+
+## Goals
+Libindy allows to create and send custom transaction via plugged interface.
+It is nice to have a way to support BLS MS and SP verification for these plugged transactions.
+
+Implementation of math for SP verification is a bit complicate for plugin logic.
+Therefore libindy should perform all math calculation inside.
+A plugin should provide handler to parse custom reply to fixed data structure.
+
+## API
+The signature of the handler is described below together with custom `free` call to deallocate result data.
+
+```rust
+extern fn custom_transaction_parser(reply_from_node: *const c_char, parsed_sp: *mut *const c_char) -> ErrCode;
+extern fn custom_free(data: *mut c_char) -> ErrCode;
+``` 
+
+Libindy API will contain call to register handler for specific transaction type:
+```rust
+extern fn indy_register_transaction_parser_for_sp(command_handle: i32,
+                                                  txn_type: *const c_char,
+                                                  parser: custom_transaction_parser,
+                                                  free: custom_free,
+                                                  cb: extern fn(command_handle_: i32, err: ErrCode)) -> ErrCode;",,2018-06-04 07:24:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191656622,https://github.com/hyperledger/indy-sdk/pull/807#discussion_r191656622,vimmerru
https://github.com/hyperledger/indy-sdk/pull/807,https://github.com/hyperledger/indy-sdk/pull/807,"yes, SubTrie option is just reserve for future optimization. In the fist iteration all components (Node, libindy, plugins) will not support this variant.",335db59ec8bac5c2bb481f1f87063942b815a725,2018-05-30 07:05:44,191660819,"@@ -0,0 +1,127 @@
+## Legend
+There are some types of requests to Nodes in the Pool allowing to use StateProof optimization in Client-Node communication.
+Instead of sending requests to all nodes in the Pool, a client can send a request to a single Node and expect StateProof signed by BLS multi-signature.
+
+BLS multi-signature (BLS MS) guaranties that there was a consensus of Nodes which signed some State identified by State RootHash.
+StateProof (SP) is small amount of data which allows to verify particular values against RootHash.
+Combination of BLS MS and SP allows clients to be sure about response of single node is a part of State signed by enough Nodes. 
+
+## Goals
+Libindy allows to create and send custom transaction via plugged interface.
+It is nice to have a way to support BLS MS and SP verification for these plugged transactions.
+
+Implementation of math for SP verification is a bit complicate for plugin logic.
+Therefore libindy should perform all math calculation inside.
+A plugin should provide handler to parse custom reply to fixed data structure.
+
+## API
+The signature of the handler is described below together with custom `free` call to deallocate result data.
+
+```rust
+extern fn custom_transaction_parser(reply_from_node: *const c_char, parsed_sp: *mut *const c_char) -> ErrCode;
+extern fn custom_free(data: *mut c_char) -> ErrCode;
+``` 
+
+Libindy API will contain call to register handler for specific transaction type:
+```rust
+extern fn indy_register_transaction_parser_for_sp(command_handle: i32,
+                                                  txn_type: *const c_char,
+                                                  parser: custom_transaction_parser,
+                                                  free: custom_free,
+                                                  cb: extern fn(command_handle_: i32, err: ErrCode)) -> ErrCode;
+```
+
+### Parsed Data structure
+
+A plugin should parse `reply_from_node` and return back to libindy parsed data as JSON string.
+Actually this data is array of entities each of them is describe SP Trie and set of key-value pairs to verify against this trie.
+It can be represented as `Vec<ParsedSP>` serialized to JSON.
+
+
+```rust
+/** 
+ Single item to verification:
+ - SP Trie with RootHash
+ - BLS MS 
+ - set of key-value to verify
+*/ 
+struct ParsedSP {
+    proof_nodes: String, /// encoded SP Trie transferred from Node to Client
+    root_hash: String, /// RootHash of the Trie, start point for verification. Should be same with appropriate filed in BLS MS data 
+    kvs_to_verify: KeyValuesInSP, /// entities to verification against current SP Trie
+    multi_signature: JsonObject, /// BLS MS data for verification
+}
+
+/**
+ Variants of representation for items to verify against SP Trie
+ Right now 2 options are specified:
+ - simple array of key-value pair
+ - whole subtrie
+*/
+enum KeyValuesInSP {
+    Simple(KeyValueSimpleData),
+    SubTrie(KeyValuesSubTrieData),
+}
+
+/**
+ Simple variant of `KeyValuesInSP`.
+ 
+ All required data already present in parent SP Trie (built from `proof_nodes`).
+ `kvs` can be verified directly in parent trie 
+*/
+struct KeyValueSimpleData {
+    kvs: Vec<(String /* key */, String /* val */)>
+}
+
+/**
+ Subtrie variant of `KeyValuesInSP`.
+ 
+ In this case Client (libindy) should construct subtrie and append it into trie based on `proof_nodes`.
+ After this preparation each kv pair can be checked.
+*/
+struct KeyValuesSubTrieData {
+    sub_trie_prefix: Option<String>, /// common prefix of each pair in `kvs`. Should be used to correct merging initial trie and subtrie",,2018-06-04 07:24:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191660819,https://github.com/hyperledger/indy-sdk/pull/807#discussion_r191660819,jovfer
https://github.com/hyperledger/indy-sdk/pull/807,https://github.com/hyperledger/indy-sdk/pull/807,"yes, `parsed_sp` is out parameter for parser and memory will be allocated by plugin for this pointer. `custom_free` will de-allocate this buffer",335db59ec8bac5c2bb481f1f87063942b815a725,2018-05-30 07:08:28,191661413,"@@ -0,0 +1,127 @@
+## Legend
+There are some types of requests to Nodes in the Pool allowing to use StateProof optimization in Client-Node communication.
+Instead of sending requests to all nodes in the Pool, a client can send a request to a single Node and expect StateProof signed by BLS multi-signature.
+
+BLS multi-signature (BLS MS) guaranties that there was a consensus of Nodes which signed some State identified by State RootHash.
+StateProof (SP) is small amount of data which allows to verify particular values against RootHash.
+Combination of BLS MS and SP allows clients to be sure about response of single node is a part of State signed by enough Nodes. 
+
+## Goals
+Libindy allows to create and send custom transaction via plugged interface.
+It is nice to have a way to support BLS MS and SP verification for these plugged transactions.
+
+Implementation of math for SP verification is a bit complicate for plugin logic.
+Therefore libindy should perform all math calculation inside.
+A plugin should provide handler to parse custom reply to fixed data structure.
+
+## API
+The signature of the handler is described below together with custom `free` call to deallocate result data.
+
+```rust
+extern fn custom_transaction_parser(reply_from_node: *const c_char, parsed_sp: *mut *const c_char) -> ErrCode;
+extern fn custom_free(data: *mut c_char) -> ErrCode;",,2018-06-04 07:24:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191661413,https://github.com/hyperledger/indy-sdk/pull/807#discussion_r191661413,jovfer
https://github.com/hyperledger/indy-sdk/pull/807,https://github.com/hyperledger/indy-sdk/pull/807,this call is just API for registration of plugin's handlers. As any other API call of libindy it contains `cb` as last parameter to retrieve result of operation,335db59ec8bac5c2bb481f1f87063942b815a725,2018-05-30 07:11:02,191661931,"@@ -0,0 +1,127 @@
+## Legend
+There are some types of requests to Nodes in the Pool allowing to use StateProof optimization in Client-Node communication.
+Instead of sending requests to all nodes in the Pool, a client can send a request to a single Node and expect StateProof signed by BLS multi-signature.
+
+BLS multi-signature (BLS MS) guaranties that there was a consensus of Nodes which signed some State identified by State RootHash.
+StateProof (SP) is small amount of data which allows to verify particular values against RootHash.
+Combination of BLS MS and SP allows clients to be sure about response of single node is a part of State signed by enough Nodes. 
+
+## Goals
+Libindy allows to create and send custom transaction via plugged interface.
+It is nice to have a way to support BLS MS and SP verification for these plugged transactions.
+
+Implementation of math for SP verification is a bit complicate for plugin logic.
+Therefore libindy should perform all math calculation inside.
+A plugin should provide handler to parse custom reply to fixed data structure.
+
+## API
+The signature of the handler is described below together with custom `free` call to deallocate result data.
+
+```rust
+extern fn custom_transaction_parser(reply_from_node: *const c_char, parsed_sp: *mut *const c_char) -> ErrCode;
+extern fn custom_free(data: *mut c_char) -> ErrCode;
+``` 
+
+Libindy API will contain call to register handler for specific transaction type:
+```rust
+extern fn indy_register_transaction_parser_for_sp(command_handle: i32,
+                                                  txn_type: *const c_char,
+                                                  parser: custom_transaction_parser,
+                                                  free: custom_free,
+                                                  cb: extern fn(command_handle_: i32, err: ErrCode)) -> ErrCode;",,2018-06-04 07:24:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191661931,https://github.com/hyperledger/indy-sdk/pull/807#discussion_r191661931,jovfer
https://github.com/hyperledger/indy-sdk/pull/807,https://github.com/hyperledger/indy-sdk/pull/807,"Ok, `err` in `cb` is the result of registration? How will the plugin know if `custom_transaction_parser` was able to verify the proof. So 
1. the plugin defines `custom_transaction_parser` that can extract SP from `reply_from_node` in `parsed_sp`.
2. indy-sdk verifies the SP, verification succeeds, then what does indy-sdk call? How will the plugin know if the verification was successful or indy-sdk is contacting another node for SP?",335db59ec8bac5c2bb481f1f87063942b815a725,2018-05-30 16:28:00,191835218,"@@ -0,0 +1,127 @@
+## Legend
+There are some types of requests to Nodes in the Pool allowing to use StateProof optimization in Client-Node communication.
+Instead of sending requests to all nodes in the Pool, a client can send a request to a single Node and expect StateProof signed by BLS multi-signature.
+
+BLS multi-signature (BLS MS) guaranties that there was a consensus of Nodes which signed some State identified by State RootHash.
+StateProof (SP) is small amount of data which allows to verify particular values against RootHash.
+Combination of BLS MS and SP allows clients to be sure about response of single node is a part of State signed by enough Nodes. 
+
+## Goals
+Libindy allows to create and send custom transaction via plugged interface.
+It is nice to have a way to support BLS MS and SP verification for these plugged transactions.
+
+Implementation of math for SP verification is a bit complicate for plugin logic.
+Therefore libindy should perform all math calculation inside.
+A plugin should provide handler to parse custom reply to fixed data structure.
+
+## API
+The signature of the handler is described below together with custom `free` call to deallocate result data.
+
+```rust
+extern fn custom_transaction_parser(reply_from_node: *const c_char, parsed_sp: *mut *const c_char) -> ErrCode;
+extern fn custom_free(data: *mut c_char) -> ErrCode;
+``` 
+
+Libindy API will contain call to register handler for specific transaction type:
+```rust
+extern fn indy_register_transaction_parser_for_sp(command_handle: i32,
+                                                  txn_type: *const c_char,
+                                                  parser: custom_transaction_parser,
+                                                  free: custom_free,
+                                                  cb: extern fn(command_handle_: i32, err: ErrCode)) -> ErrCode;",,2018-06-04 07:24:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191835218,https://github.com/hyperledger/indy-sdk/pull/807#discussion_r191835218,lovesh
https://github.com/hyperledger/indy-sdk/pull/807,https://github.com/hyperledger/indy-sdk/pull/807,Plugin don't need to know anything about result of verification. Libindy will use provided data to verify SP and make decision about handling based on this info. ,335db59ec8bac5c2bb481f1f87063942b815a725,2018-05-30 16:33:35,191836939,"@@ -0,0 +1,127 @@
+## Legend
+There are some types of requests to Nodes in the Pool allowing to use StateProof optimization in Client-Node communication.
+Instead of sending requests to all nodes in the Pool, a client can send a request to a single Node and expect StateProof signed by BLS multi-signature.
+
+BLS multi-signature (BLS MS) guaranties that there was a consensus of Nodes which signed some State identified by State RootHash.
+StateProof (SP) is small amount of data which allows to verify particular values against RootHash.
+Combination of BLS MS and SP allows clients to be sure about response of single node is a part of State signed by enough Nodes. 
+
+## Goals
+Libindy allows to create and send custom transaction via plugged interface.
+It is nice to have a way to support BLS MS and SP verification for these plugged transactions.
+
+Implementation of math for SP verification is a bit complicate for plugin logic.
+Therefore libindy should perform all math calculation inside.
+A plugin should provide handler to parse custom reply to fixed data structure.
+
+## API
+The signature of the handler is described below together with custom `free` call to deallocate result data.
+
+```rust
+extern fn custom_transaction_parser(reply_from_node: *const c_char, parsed_sp: *mut *const c_char) -> ErrCode;
+extern fn custom_free(data: *mut c_char) -> ErrCode;
+``` 
+
+Libindy API will contain call to register handler for specific transaction type:
+```rust
+extern fn indy_register_transaction_parser_for_sp(command_handle: i32,
+                                                  txn_type: *const c_char,
+                                                  parser: custom_transaction_parser,
+                                                  free: custom_free,
+                                                  cb: extern fn(command_handle_: i32, err: ErrCode)) -> ErrCode;",,2018-06-04 07:24:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191836939,https://github.com/hyperledger/indy-sdk/pull/807#discussion_r191836939,vimmerru
https://github.com/hyperledger/indy-sdk/pull/807,https://github.com/hyperledger/indy-sdk/pull/807,"Ok, so if the verification succeeds, sdk dispatches result to another plugin method?",335db59ec8bac5c2bb481f1f87063942b815a725,2018-05-30 16:44:13,191840406,"@@ -0,0 +1,127 @@
+## Legend
+There are some types of requests to Nodes in the Pool allowing to use StateProof optimization in Client-Node communication.
+Instead of sending requests to all nodes in the Pool, a client can send a request to a single Node and expect StateProof signed by BLS multi-signature.
+
+BLS multi-signature (BLS MS) guaranties that there was a consensus of Nodes which signed some State identified by State RootHash.
+StateProof (SP) is small amount of data which allows to verify particular values against RootHash.
+Combination of BLS MS and SP allows clients to be sure about response of single node is a part of State signed by enough Nodes. 
+
+## Goals
+Libindy allows to create and send custom transaction via plugged interface.
+It is nice to have a way to support BLS MS and SP verification for these plugged transactions.
+
+Implementation of math for SP verification is a bit complicate for plugin logic.
+Therefore libindy should perform all math calculation inside.
+A plugin should provide handler to parse custom reply to fixed data structure.
+
+## API
+The signature of the handler is described below together with custom `free` call to deallocate result data.
+
+```rust
+extern fn custom_transaction_parser(reply_from_node: *const c_char, parsed_sp: *mut *const c_char) -> ErrCode;
+extern fn custom_free(data: *mut c_char) -> ErrCode;
+``` 
+
+Libindy API will contain call to register handler for specific transaction type:
+```rust
+extern fn indy_register_transaction_parser_for_sp(command_handle: i32,
+                                                  txn_type: *const c_char,
+                                                  parser: custom_transaction_parser,
+                                                  free: custom_free,
+                                                  cb: extern fn(command_handle_: i32, err: ErrCode)) -> ErrCode;",,2018-06-04 07:24:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191840406,https://github.com/hyperledger/indy-sdk/pull/807#discussion_r191840406,lovesh
https://github.com/hyperledger/indy-sdk/pull/807,https://github.com/hyperledger/indy-sdk/pull/807,"No, we don't need plugin involvement anymore. The next logic is common for all requests. ",335db59ec8bac5c2bb481f1f87063942b815a725,2018-05-31 06:51:58,192003308,"@@ -0,0 +1,127 @@
+## Legend
+There are some types of requests to Nodes in the Pool allowing to use StateProof optimization in Client-Node communication.
+Instead of sending requests to all nodes in the Pool, a client can send a request to a single Node and expect StateProof signed by BLS multi-signature.
+
+BLS multi-signature (BLS MS) guaranties that there was a consensus of Nodes which signed some State identified by State RootHash.
+StateProof (SP) is small amount of data which allows to verify particular values against RootHash.
+Combination of BLS MS and SP allows clients to be sure about response of single node is a part of State signed by enough Nodes. 
+
+## Goals
+Libindy allows to create and send custom transaction via plugged interface.
+It is nice to have a way to support BLS MS and SP verification for these plugged transactions.
+
+Implementation of math for SP verification is a bit complicate for plugin logic.
+Therefore libindy should perform all math calculation inside.
+A plugin should provide handler to parse custom reply to fixed data structure.
+
+## API
+The signature of the handler is described below together with custom `free` call to deallocate result data.
+
+```rust
+extern fn custom_transaction_parser(reply_from_node: *const c_char, parsed_sp: *mut *const c_char) -> ErrCode;
+extern fn custom_free(data: *mut c_char) -> ErrCode;
+``` 
+
+Libindy API will contain call to register handler for specific transaction type:
+```rust
+extern fn indy_register_transaction_parser_for_sp(command_handle: i32,
+                                                  txn_type: *const c_char,
+                                                  parser: custom_transaction_parser,
+                                                  free: custom_free,
+                                                  cb: extern fn(command_handle_: i32, err: ErrCode)) -> ErrCode;",,2018-06-04 07:24:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192003308,https://github.com/hyperledger/indy-sdk/pull/807#discussion_r192003308,vimmerru
https://github.com/hyperledger/indy-sdk/pull/804,https://github.com/hyperledger/indy-sdk/pull/804,WalletQueryError::CommonError looks useless,5bddbad9216f66e02d8bae3aa058cb251dab035e,2018-05-28 13:36:30,191208555,"@@ -278,19 +294,22 @@ pub enum WalletQueryError {
     ParsingErr(String),
     StructureErr(String),
     ValueErr(String),
+    CommonError(CommonError),
 }",,2018-05-29 12:58:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191208555,https://github.com/hyperledger/indy-sdk/pull/804#discussion_r191208555,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/804,https://github.com/hyperledger/indy-sdk/pull/804,"Function transform above looks useless. 
We can delete it and rename transform_result into transform",5bddbad9216f66e02d8bae3aa058cb251dab035e,2018-05-28 14:01:20,191214420,"@@ -89,6 +89,35 @@ impl Operator {
         }",17,2018-05-29 12:58:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191214420,https://github.com/hyperledger/indy-sdk/pull/804#discussion_r191214420,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/804,https://github.com/hyperledger/indy-sdk/pull/804,I have compilation error here. It looks like you use another version of Rust,5bddbad9216f66e02d8bae3aa058cb251dab035e,2018-05-29 10:03:48,191369299,"@@ -176,7 +177,13 @@ impl StorageIterator for SQLiteStorageIterator {
                     None
                 };
                 let tags = if self.options.fetch_tags {
-                    Some(self.tag_retriever.as_mut().unwrap().retrieve(row.get(0))?)
+                    if let Some(ref mut tag_retriever) = &mut self.tag_retriever {",,2018-05-29 12:58:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191369299,https://github.com/hyperledger/indy-sdk/pull/804#discussion_r191369299,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/804,https://github.com/hyperledger/indy-sdk/pull/804,"Oh yes, I first used it but later changed approach and forgot to remove. You are right",5bddbad9216f66e02d8bae3aa058cb251dab035e,2018-05-29 10:13:00,191371615,"@@ -278,19 +294,22 @@ pub enum WalletQueryError {
     ParsingErr(String),
     StructureErr(String),
     ValueErr(String),
+    CommonError(CommonError),
 }",,2018-05-29 12:58:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191371615,https://github.com/hyperledger/indy-sdk/pull/804#discussion_r191371615,keichiri
https://github.com/hyperledger/indy-sdk/pull/804,https://github.com/hyperledger/indy-sdk/pull/804,yes its not necessary now you are correct,5bddbad9216f66e02d8bae3aa058cb251dab035e,2018-05-29 10:13:13,191371660,"@@ -89,6 +89,35 @@ impl Operator {
         }",17,2018-05-29 12:58:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191371660,https://github.com/hyperledger/indy-sdk/pull/804#discussion_r191371660,keichiri
https://github.com/hyperledger/indy-sdk/pull/804,https://github.com/hyperledger/indy-sdk/pull/804,"interesting. Yes, the syntax looks a bit strange, maybe it was not possible before. I use 1.26",5bddbad9216f66e02d8bae3aa058cb251dab035e,2018-05-29 10:16:35,191372469,"@@ -176,7 +177,13 @@ impl StorageIterator for SQLiteStorageIterator {
                     None
                 };
                 let tags = if self.options.fetch_tags {
-                    Some(self.tag_retriever.as_mut().unwrap().retrieve(row.get(0))?)
+                    if let Some(ref mut tag_retriever) = &mut self.tag_retriever {",,2018-05-29 12:58:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191372469,https://github.com/hyperledger/indy-sdk/pull/804#discussion_r191372469,keichiri
https://github.com/hyperledger/indy-sdk/pull/799,https://github.com/hyperledger/indy-sdk/pull/799,We need to create a bug,538ff4838404375a3ca8699dd49873cc2d44c00d,2018-05-25 13:38:44,190896245,"@@ -27,14 +27,18 @@
 
 
 @pytest.mark.asyncio
-async def test_open_wallet_works_for_encrypted_wallet_with_invalid_credentials(xwallet, wallet_name):
+async def test_open_wallet_works_for_missed_credentials(xwallet, wallet_name):
     with pytest.raises(IndyError) as e:
-        await wallet.open_wallet(wallet_name, None, '{""key"":""BBIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=""}')
-    assert ErrorCode.WalletAccessFailed == e.value.error_code
+        await wallet.open_wallet(wallet_name, None, None)
+    assert ErrorCode.CommonInvalidParam4 == e.value.error_code
 
 
 @pytest.mark.asyncio
+@pytest.mark.skip(reason=""TODO: FIXME: Create a bug!!!"")",14,2018-05-28 06:26:51,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/190896245,https://github.com/hyperledger/indy-sdk/pull/799#discussion_r190896245,vimmerru
https://github.com/hyperledger/indy-sdk/pull/787,https://github.com/hyperledger/indy-sdk/pull/787,Why this function borrows string? &str as input param seems better and allows to avoid unnecessary copying,c5abe05d8dd4dff511aaa9bf672957207666e579,2018-05-23 10:48:20,190202251,"@@ -8,16 +8,19 @@ lazy_static! {
 }
 
 pub fn add_response(request: String, response: String) -> Result<(), ErrorCode> {
-    let val = str_to_val(request.as_str())?;
-    let object = val_to_obj(&val)?;
-    let req_id = get_val_from_obj(object, ""reqId"")?;
-    let req_id = val_to_u64(req_id)?;
-
+    let req_id = parse_req_id_from_request(request)?;
     let mut responses = RESPONSES.lock().unwrap();
     responses.insert(req_id.to_string(), response);
     Ok(())
 }
 
+pub fn parse_req_id_from_request(request: String) -> Result<u64, ErrorCode> {",,2018-05-23 14:22:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/190202251,https://github.com/hyperledger/indy-sdk/pull/787#discussion_r190202251,vimmerru
https://github.com/hyperledger/indy-sdk/pull/787,https://github.com/hyperledger/indy-sdk/pull/787,Check also similar cases. It is more natural in Rust to provide slices instead of concrete container object or reference. ,c5abe05d8dd4dff511aaa9bf672957207666e579,2018-05-23 10:59:44,190205064,"@@ -8,16 +8,19 @@ lazy_static! {
 }
 
 pub fn add_response(request: String, response: String) -> Result<(), ErrorCode> {
-    let val = str_to_val(request.as_str())?;
-    let object = val_to_obj(&val)?;
-    let req_id = get_val_from_obj(object, ""reqId"")?;
-    let req_id = val_to_u64(req_id)?;
-
+    let req_id = parse_req_id_from_request(request)?;
     let mut responses = RESPONSES.lock().unwrap();
     responses.insert(req_id.to_string(), response);
     Ok(())
 }
 
+pub fn parse_req_id_from_request(request: String) -> Result<u64, ErrorCode> {",,2018-05-23 14:22:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/190205064,https://github.com/hyperledger/indy-sdk/pull/787#discussion_r190205064,vimmerru
https://github.com/hyperledger/indy-sdk/pull/779,https://github.com/hyperledger/indy-sdk/pull/779,"I know you did it because of lack of time, but I am thinking that maybe keys should be shared pointer (Rc)

Not to avoid unnecessary copying just, but also it might be safer to have keys at one place in memory, not all over the place possibly.

What do you think of this, for future improvement?",a33fc3471cb9eb01002d2d1fdf853fd7773bf5d7,2018-05-21 15:39:39,189627802,"@@ -9,17 +9,17 @@ use super::encryption::{decrypt_tags};
 use utils::crypto::chacha20poly1305_ietf::ChaCha20Poly1305IETF;
 
 
-pub(super) struct WalletIterator<'a> {
-    storage_iterator: Box<StorageIterator + 'a>,
-    keys: &'a Keys
+pub(super) struct WalletIterator {
+    storage_iterator: Box<StorageIterator>,
+    keys: Keys,
 }
 
 
-impl<'a> WalletIterator<'a> {
-    pub fn new(storage_iter: Box<StorageIterator + 'a>, keys: &'a Keys) -> Self {
+impl WalletIterator {
+    pub fn new(storage_iter: Box<StorageIterator>, keys: &Keys) -> Self {
         WalletIterator {
             storage_iterator: storage_iter,
-            keys: keys
+            keys: keys.clone(),",,2018-05-22 07:17:53,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/189627802,https://github.com/hyperledger/indy-sdk/pull/779#discussion_r189627802,keichiri
https://github.com/hyperledger/indy-sdk/pull/779,https://github.com/hyperledger/indy-sdk/pull/779,Exactly. In new one commit the one more same place with `TODO` marker is added. I will also put TODO here.,a33fc3471cb9eb01002d2d1fdf853fd7773bf5d7,2018-05-22 07:15:30,189797244,"@@ -9,17 +9,17 @@ use super::encryption::{decrypt_tags};
 use utils::crypto::chacha20poly1305_ietf::ChaCha20Poly1305IETF;
 
 
-pub(super) struct WalletIterator<'a> {
-    storage_iterator: Box<StorageIterator + 'a>,
-    keys: &'a Keys
+pub(super) struct WalletIterator {
+    storage_iterator: Box<StorageIterator>,
+    keys: Keys,
 }
 
 
-impl<'a> WalletIterator<'a> {
-    pub fn new(storage_iter: Box<StorageIterator + 'a>, keys: &'a Keys) -> Self {
+impl WalletIterator {
+    pub fn new(storage_iter: Box<StorageIterator>, keys: &Keys) -> Self {
         WalletIterator {
             storage_iterator: storage_iter,
-            keys: keys
+            keys: keys.clone(),",,2018-05-22 07:17:53,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/189797244,https://github.com/hyperledger/indy-sdk/pull/779#discussion_r189797244,jovfer
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,Can i build it on windows and MacOS?,17741224db2c7e882a2bed39b45028c130804b58,2018-06-05 08:55:49,192995639,"@@ -0,0 +1,37 @@
+# Building binaries of LibIndy for Android
+
+**Not ready for production use! Not fully tested.**
+
+## Prerequisites
+
+- Docker",7,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192995639,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r192995639,vimmerru
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,Is it updated intentionally?,17741224db2c7e882a2bed39b45028c130804b58,2018-06-05 08:58:28,192996499,"@@ -38,17 +38,17 @@ sodium_static = []
 indy-crypto = { version = ""=0.4.1"", optional = true }
 int_traits = { version = ""0.1.1"", optional = true }
 digest = ""0.6.2""
-env_logger = ""0.4.2""
+env_logger = ""0.5.10""",5,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192996499,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r192996499,vimmerru
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,Is it updated intentionally?,17741224db2c7e882a2bed39b45028c130804b58,2018-06-05 08:58:35,192996555,"@@ -38,17 +38,17 @@ sodium_static = []
 indy-crypto = { version = ""=0.4.1"", optional = true }
 int_traits = { version = ""0.1.1"", optional = true }
 digest = ""0.6.2""
-env_logger = ""0.4.2""
+env_logger = ""0.5.10""
 errno = ""0.2.3""
 etcommon-rlp = ""0.2.3""
 generic-array = ""0.8.3""
 hex = ""0.2.0""
 libc = ""0.2.21""
-log = ""0.3.7""
+log = ""0.4.1""",12,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192996555,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r192996555,vimmerru
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,As i understand now we start static linking with sqlite on all platforms. ,17741224db2c7e882a2bed39b45028c130804b58,2018-06-05 08:59:41,192996888,"@@ -38,17 +38,17 @@ sodium_static = []
 indy-crypto = { version = ""=0.4.1"", optional = true }
 int_traits = { version = ""0.1.1"", optional = true }
 digest = ""0.6.2""
-env_logger = ""0.4.2""
+env_logger = ""0.5.10""
 errno = ""0.2.3""
 etcommon-rlp = ""0.2.3""
 generic-array = ""0.8.3""
 hex = ""0.2.0""
 libc = ""0.2.21""
-log = ""0.3.7""
+log = ""0.4.1""
 openssl = { version = ""=0.9.24"", optional = true }
 owning_ref = ""0.3.3""
 rand = ""0.3""
-rusqlite = ""0.13.0""
+rusqlite = { version = ""0.13.0"", features=[""bundled""] }",,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192996888,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r192996888,vimmerru
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,No. We require 0.4.2 for android_logger,17741224db2c7e882a2bed39b45028c130804b58,2018-06-13 09:20:28,195011839,"@@ -38,17 +38,17 @@ sodium_static = []
 indy-crypto = { version = ""=0.4.1"", optional = true }
 int_traits = { version = ""0.1.1"", optional = true }
 digest = ""0.6.2""
-env_logger = ""0.4.2""
+env_logger = ""0.5.10""",5,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195011839,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195011839,faisal00813
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,Yes,17741224db2c7e882a2bed39b45028c130804b58,2018-06-13 09:20:46,195011921,"@@ -38,17 +38,17 @@ sodium_static = []
 indy-crypto = { version = ""=0.4.1"", optional = true }
 int_traits = { version = ""0.1.1"", optional = true }
 digest = ""0.6.2""
-env_logger = ""0.4.2""
+env_logger = ""0.5.10""
 errno = ""0.2.3""
 etcommon-rlp = ""0.2.3""
 generic-array = ""0.8.3""
 hex = ""0.2.0""
 libc = ""0.2.21""
-log = ""0.3.7""
+log = ""0.4.1""",12,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195011921,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195011921,faisal00813
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,"Can we just replace this complex if with just ""linux-android"" as it seems present in all arch strings?",17741224db2c7e882a2bed39b45028c130804b58,2018-06-13 09:21:40,195012205,"@@ -32,4 +32,40 @@ fn main() {
             }
         }
     }
+		match &target {
+		x if x.contains(""aarch64-linux-android"") || x.contains(""armv7-linux-androideabi"") ||",,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195012205,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195012205,vimmerru
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,"On Android, we don't have SQLite binaries which we provide while building. Also, I can't recall any flag which suggests that we are doing static linking with SQLite.",17741224db2c7e882a2bed39b45028c130804b58,2018-06-13 09:23:22,195012874,"@@ -38,17 +38,17 @@ sodium_static = []
 indy-crypto = { version = ""=0.4.1"", optional = true }
 int_traits = { version = ""0.1.1"", optional = true }
 digest = ""0.6.2""
-env_logger = ""0.4.2""
+env_logger = ""0.5.10""
 errno = ""0.2.3""
 etcommon-rlp = ""0.2.3""
 generic-array = ""0.8.3""
 hex = ""0.2.0""
 libc = ""0.2.21""
-log = ""0.3.7""
+log = ""0.4.1""
 openssl = { version = ""=0.9.24"", optional = true }
 owning_ref = ""0.3.3""
 rand = ""0.3""
-rusqlite = ""0.13.0""
+rusqlite = { version = ""0.13.0"", features=[""bundled""] }",,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195012874,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195012874,faisal00813
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,Only Linux is supported as of now.,17741224db2c7e882a2bed39b45028c130804b58,2018-06-13 10:11:42,195027198,"@@ -0,0 +1,37 @@
+# Building binaries of LibIndy for Android
+
+**Not ready for production use! Not fully tested.**
+
+## Prerequisites
+
+- Docker",7,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195027198,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195027198,faisal00813
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,The problem is that we don't want to force static linking on all platforms. Only for android and iOS,17741224db2c7e882a2bed39b45028c130804b58,2018-06-13 11:43:30,195050356,"@@ -38,17 +38,17 @@ sodium_static = []
 indy-crypto = { version = ""=0.4.1"", optional = true }
 int_traits = { version = ""0.1.1"", optional = true }
 digest = ""0.6.2""
-env_logger = ""0.4.2""
+env_logger = ""0.5.10""
 errno = ""0.2.3""
 etcommon-rlp = ""0.2.3""
 generic-array = ""0.8.3""
 hex = ""0.2.0""
 libc = ""0.2.21""
-log = ""0.3.7""
+log = ""0.4.1""
 openssl = { version = ""=0.9.24"", optional = true }
 owning_ref = ""0.3.3""
 rand = ""0.3""
-rusqlite = ""0.13.0""
+rusqlite = { version = ""0.13.0"", features=[""bundled""] }",,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195050356,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195050356,vimmerru
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,I believe we need to rename it to something more obvious like android-build-env.dockerfile,17741224db2c7e882a2bed39b45028c130804b58,2018-06-13 11:47:49,195051428,"@@ -0,0 +1,49 @@
+FROM ubuntu:16.04",,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195051428,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195051428,vimmerru
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,"> Run `build.dependencies.locally.sh`

Will it build dependencies for all supported architectures?",17741224db2c7e882a2bed39b45028c130804b58,2018-06-13 12:11:45,195057303,"@@ -0,0 +1,37 @@
+# Building binaries of LibIndy for Android
+
+**Not ready for production use! Not fully tested.**
+
+## Prerequisites
+
+- Docker
+
+## How to build.
+- Goto `indy-sdk/libindy/build_scripts/android` folder
+- Run `build.dependencies.locally.sh`",,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195057303,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195057303,vimmerru
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,Build must be repeatable. Se we can't use just master branch for dependencies. Use tag/release/commit,17741224db2c7e882a2bed39b45028c130804b58,2018-06-13 12:19:16,195059199,"@@ -0,0 +1,24 @@
+#!/usr/bin/env bash
+
+ARMV7_DIR=${PWD}/openssl_arm
+ARM64_DIR=${PWD}/openssl_arm64
+ARMx86_DIR=${PWD}/openssl_x86
+mkdir -p $ARM64_DIR
+mkdir -p $ARMV7_DIR
+mkdir -p $ARMx86_DIR
+
+git clone https://github.com/nsivraj/openssl_for_ios_and_android.git",,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195059199,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195059199,vimmerru
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,Master uses libsodium 1.0.14,17741224db2c7e882a2bed39b45028c130804b58,2018-06-13 12:23:46,195060410,"@@ -0,0 +1,46 @@
+#!/bin/bash
+
+TARGET_ARCH=$1
+TARGET_API=$2
+CROSS_COMPILE=$3
+
+if [ -z ""${TARGET_ARCH}"" ]; then
+    echo STDERR ""Missing TARGET_ARCH argument""
+    echo STDERR ""e.g. x86 or arm""
+    exit 1 
+fi
+
+if [ -z ""${TARGET_API}"" ]; then
+    echo STDERR ""Missing TARGET_API argument""
+    echo STDERR ""e.g. 21""
+    exit 1 
+fi
+
+if [ -z ""${CROSS_COMPILE}"" ]; then
+    echo STDERR ""Missing CROSS_COMPILE argument""
+    echo STDERR ""e.g. i686-linux-android""
+    exit 1 
+fi
+
+if [ ! -f ""android-ndk-r16b-linux-x86_64.zip"" ] ; then
+    echo ""Downloading android-ndk-r16b-linux-x86_64.zip""
+    wget -q https://dl.google.com/android/repository/android-ndk-r16b-linux-x86_64.zip 
+else
+    echo ""Skipping download android-ndk-r16b-linux-x86_64.zip""
+fi
+
+if [ ! -f ""libsodium-1.0.12.tar.gz"" ] ; then
+    echo ""Downloading libsodium-1.0.12.tar.gz""
+    wget -q wget https://github.com/jedisct1/libsodium/releases/download/1.0.12/libsodium-1.0.12.tar.gz",,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195060410,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195060410,vimmerru
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,"This code doesn't look correct for me.

- I see 2 unwraps. Will we crash if there is no EXTERNAL_STORAGE variable?
- Why we create directories here? It isn't responsibility of this function
- Flow also looks very non-obvious? Can you just use on match or if/if else/if else?",17741224db2c7e882a2bed39b45028c130804b58,2018-06-13 12:30:47,195062501,"@@ -1,13 +1,25 @@
 use std::env;
 use std::path::PathBuf;
+use std::fs;
 
 pub struct EnvironmentUtils {}
 
 impl EnvironmentUtils {
     pub fn indy_home_path() -> PathBuf {
         // TODO: FIXME: Provide better handling for the unknown home path case!!!
+",,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195062501,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195062501,vimmerru
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,Can you add this info to per-requirements? It is better to provide info about platform that we tested.,17741224db2c7e882a2bed39b45028c130804b58,2018-06-14 11:41:40,195390484,"@@ -0,0 +1,37 @@
+# Building binaries of LibIndy for Android
+
+**Not ready for production use! Not fully tested.**
+
+## Prerequisites
+
+- Docker",7,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195390484,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195390484,vimmerru
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,"ok, make sense",17741224db2c7e882a2bed39b45028c130804b58,2018-06-15 11:01:50,195700085,"@@ -38,17 +38,17 @@ sodium_static = []
 indy-crypto = { version = ""=0.4.1"", optional = true }
 int_traits = { version = ""0.1.1"", optional = true }
 digest = ""0.6.2""
-env_logger = ""0.4.2""
+env_logger = ""0.5.10""",5,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195700085,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195700085,vimmerru
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,"ok, make sense",17741224db2c7e882a2bed39b45028c130804b58,2018-06-15 11:01:56,195700106,"@@ -38,17 +38,17 @@ sodium_static = []
 indy-crypto = { version = ""=0.4.1"", optional = true }
 int_traits = { version = ""0.1.1"", optional = true }
 digest = ""0.6.2""
-env_logger = ""0.4.2""
+env_logger = ""0.5.10""
 errno = ""0.2.3""
 etcommon-rlp = ""0.2.3""
 generic-array = ""0.8.3""
 hex = ""0.2.0""
 libc = ""0.2.21""
-log = ""0.3.7""
+log = ""0.4.1""",12,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195700106,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195700106,vimmerru
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,That info is present in _Known Issues_ segment at the bottom of the document.,17741224db2c7e882a2bed39b45028c130804b58,2018-06-16 14:06:56,195903838,"@@ -0,0 +1,37 @@
+# Building binaries of LibIndy for Android
+
+**Not ready for production use! Not fully tested.**
+
+## Prerequisites
+
+- Docker",7,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195903838,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195903838,faisal00813
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,"Yes. The script will build for x86, arm and arm64 architectures.",17741224db2c7e882a2bed39b45028c130804b58,2018-06-16 14:12:12,195903931,"@@ -0,0 +1,37 @@
+# Building binaries of LibIndy for Android
+
+**Not ready for production use! Not fully tested.**
+
+## Prerequisites
+
+- Docker
+
+## How to build.
+- Goto `indy-sdk/libindy/build_scripts/android` folder
+- Run `build.dependencies.locally.sh`",,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195903931,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195903931,faisal00813
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,ok,17741224db2c7e882a2bed39b45028c130804b58,2018-06-18 08:33:15,195999730,"@@ -0,0 +1,37 @@
+# Building binaries of LibIndy for Android
+
+**Not ready for production use! Not fully tested.**
+
+## Prerequisites
+
+- Docker",7,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195999730,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195999730,vimmerru
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,Libindy will now panic! if it cannot find the EXTERNAL_STORAGE . ,17741224db2c7e882a2bed39b45028c130804b58,2018-06-26 13:46:45,198149067,"@@ -1,13 +1,25 @@
 use std::env;
 use std::path::PathBuf;
+use std::fs;
 
 pub struct EnvironmentUtils {}
 
 impl EnvironmentUtils {
     pub fn indy_home_path() -> PathBuf {
         // TODO: FIXME: Provide better handling for the unknown home path case!!!
+",,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/198149067,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r198149067,faisal00813
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,please clean-up code here. Seems like this section should be in `else if` for previous one (windows),17741224db2c7e882a2bed39b45028c130804b58,2018-06-27 11:07:48,198454243,"@@ -32,4 +32,38 @@ fn main() {
             }
         }
     }
+		match &target {",,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/198454243,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r198454243,jovfer
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,"Agree with @vimmerru. Please fix all 3 points
https://github.com/hyperledger/indy-sdk/pull/777#discussion_r195062501",17741224db2c7e882a2bed39b45028c130804b58,2018-06-27 11:10:36,198454905,"@@ -1,13 +1,25 @@
 use std::env;
 use std::path::PathBuf;
+use std::fs;
 
 pub struct EnvironmentUtils {}
 
 impl EnvironmentUtils {
     pub fn indy_home_path() -> PathBuf {
         // TODO: FIXME: Provide better handling for the unknown home path case!!!
+",,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/198454905,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r198454905,jovfer
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,seems like staticlib should be android-specific target,17741224db2c7e882a2bed39b45028c130804b58,2018-06-27 11:11:19,198455132,"@@ -6,7 +6,7 @@ build = ""build.rs""
 
 [lib]
 name = ""nullpay""
-crate-type = [""cdylib"", ""rlib""]
+crate-type = [""staticlib"",""cdylib"", ""rlib""]",5,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/198455132,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r198455132,jovfer
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,`match` construction is ugly here. please clean-up and use `if else`,17741224db2c7e882a2bed39b45028c130804b58,2018-06-27 11:12:31,198455423,"@@ -4,19 +4,29 @@ use std::path::Path;
 fn main() {
     let target = env::var(""TARGET"").unwrap();
     println!(""target={}"", target);
+    match &target {",,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/198455423,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r198455423,jovfer
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,please specify common and android rusqlite dependence as neighbors to avoid partial update in the future,17741224db2c7e882a2bed39b45028c130804b58,2018-06-27 11:15:24,198456036,"@@ -66,7 +66,13 @@ lazy_static = ""1.0""
 named_type = ""0.1.3""
 named_type_derive = ""0.1.3""
 byteorder = ""1.0.0""
+log-panics = ""2.0.0""
 [dependencies.uuid]
 version = ""0.5.0""
 default-features = false
-features = [""v4""]
\ No newline at end of file
+features = [""v4""]
+
+[target.'cfg(target_os = ""android"")'.dependencies]
+android_logger = ""0.5""
+[target.'cfg(any(target_os = ""android"", target_os = ""ios""))'.dependencies]
+rusqlite = { version = ""0.13.0"", features=[""bundled""] }",36,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/198456036,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r198456036,jovfer
https://github.com/hyperledger/indy-sdk/pull/777,https://github.com/hyperledger/indy-sdk/pull/777,"I don't know if rust supports the conditional crate-type declaration. Does it? 
There are two issues related to it though, https://github.com/rust-lang/cargo/pull/5367 and https://github.com/rust-lang/cargo/issues/4900 . ",17741224db2c7e882a2bed39b45028c130804b58,2018-06-27 13:22:31,198492460,"@@ -6,7 +6,7 @@ build = ""build.rs""
 
 [lib]
 name = ""nullpay""
-crate-type = [""cdylib"", ""rlib""]
+crate-type = [""staticlib"",""cdylib"", ""rlib""]",5,2018-06-28 11:37:29,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/198492460,https://github.com/hyperledger/indy-sdk/pull/777#discussion_r198492460,faisal00813
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,I don't like this error. It doesn't describe anything about the cause.,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-05-23 08:14:02,190158279,"@@ -116,6 +116,9 @@ pub enum ErrorCode
     // Returned if provided wallet query is invalid
     WalletQueryError = 214,
 
+    // Returned if wallet import has failed
+    WalletImportError = 215,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/190158279,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r190158279,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,"usize may be different length, we **must not** return 4 bytes from method consumed usize to transform.
https://doc.rust-lang.org/std/primitive.usize.html",0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-05-30 08:23:09,191680691,"@@ -516,36 +518,66 @@ impl WalletService {
         }
     }
 
+    pub fn export_wallet(&self, wallet_handle: i32, writer: Box<Write>, key: [u8; 32], version: u32) -> Result<(), WalletError> {
+        match self.wallets.borrow().get(&wallet_handle) {
+            Some(wallet) => export(wallet, writer, key, version),
+            None => Err(WalletError::InvalidHandle(wallet_handle.to_string()))
+        }
+    }
+
+    pub fn import_wallet(&self, wallet_handle: i32, reader: Box<Read>, key: [u8; 32]) -> Result<(), WalletError> {
+        match self.wallets.borrow_mut().get_mut(&wallet_handle) {
+            Some(wallet) => import(wallet, reader, key),
+            None => Err(WalletError::InvalidHandle(wallet_handle.to_string()))
+        }
+    }
+
     pub const PREFIX: &'static str = ""Indy::"";
 
     fn add_prefix(&self, type_: &str) -> String {
         format!(""{}{}"", WalletService::PREFIX, type_)
     }
 }
 
+fn length_to_bigend_bytes(length: usize) -> [u8; 4] {",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191680691,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r191680691,jovfer
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,"yes, I will change it to u32",0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-05-30 09:07:48,191693960,"@@ -516,36 +518,66 @@ impl WalletService {
         }
     }
 
+    pub fn export_wallet(&self, wallet_handle: i32, writer: Box<Write>, key: [u8; 32], version: u32) -> Result<(), WalletError> {
+        match self.wallets.borrow().get(&wallet_handle) {
+            Some(wallet) => export(wallet, writer, key, version),
+            None => Err(WalletError::InvalidHandle(wallet_handle.to_string()))
+        }
+    }
+
+    pub fn import_wallet(&self, wallet_handle: i32, reader: Box<Read>, key: [u8; 32]) -> Result<(), WalletError> {
+        match self.wallets.borrow_mut().get_mut(&wallet_handle) {
+            Some(wallet) => import(wallet, reader, key),
+            None => Err(WalletError::InvalidHandle(wallet_handle.to_string()))
+        }
+    }
+
     pub const PREFIX: &'static str = ""Indy::"";
 
     fn add_prefix(&self, type_: &str) -> String {
         format!(""{}{}"", WalletService::PREFIX, type_)
     }
 }
 
+fn length_to_bigend_bytes(length: usize) -> [u8; 4] {",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191693960,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r191693960,keichiri
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,"Actually, this was left from before. I just forgot to clean it up. I will remove it now

Not used anywhere. All conversions are in export_import.rs

fn u64_to_bytes(u: u64) -> [u8; 8] {
    let u = u.to_be();
    let res: [u8; 8] = unsafe { mem::transmute(u) };
    res
}

fn u32_to_bytes(u: u32) -> [u8; 4] {
    let u = u.to_be();
    let res: [u8; 4] = unsafe { mem::transmute(u) };
    res
}

fn u16_to_bytes(u: u16) -> [u8; 2] {
    let u = u.to_be();
    let res: [u8; 2] = unsafe { mem::transmute(u) };
    res
}",0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-05-30 16:09:11,191829362,"@@ -516,36 +518,66 @@ impl WalletService {
         }
     }
 
+    pub fn export_wallet(&self, wallet_handle: i32, writer: Box<Write>, key: [u8; 32], version: u32) -> Result<(), WalletError> {
+        match self.wallets.borrow().get(&wallet_handle) {
+            Some(wallet) => export(wallet, writer, key, version),
+            None => Err(WalletError::InvalidHandle(wallet_handle.to_string()))
+        }
+    }
+
+    pub fn import_wallet(&self, wallet_handle: i32, reader: Box<Read>, key: [u8; 32]) -> Result<(), WalletError> {
+        match self.wallets.borrow_mut().get_mut(&wallet_handle) {
+            Some(wallet) => import(wallet, reader, key),
+            None => Err(WalletError::InvalidHandle(wallet_handle.to_string()))
+        }
+    }
+
     pub const PREFIX: &'static str = ""Indy::"";
 
     fn add_prefix(&self, type_: &str) -> String {
         format!(""{}{}"", WalletService::PREFIX, type_)
     }
 }
 
+fn length_to_bigend_bytes(length: usize) -> [u8; 4] {",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/191829362,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r191829362,keichiri
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,We should use CommonIOError here,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-05-31 12:47:49,192086779,"@@ -116,6 +116,15 @@ pub enum ErrorCode
     // Returned if provided wallet query is invalid
     WalletQueryError = 214,
 
+    // Returned if I/O error occurred during wallet operation
+    WalletIOError = 215,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192086779,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r192086779,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,We should use CommonInvalidStructure here,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-05-31 12:48:03,192086838,"@@ -116,6 +116,15 @@ pub enum ErrorCode
     // Returned if provided wallet query is invalid
     WalletQueryError = 214,
 
+    // Returned if I/O error occurred during wallet operation
+    WalletIOError = 215,
+
+    // Returned if wallet input has invalid structure (currently used in wallet import)
+    WalletStructureError = 216,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192086838,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r192086838,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,There is CommonError enum in WalletError already,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-05-31 12:50:07,192087375,"@@ -37,6 +37,9 @@ pub enum WalletError {
     ItemNotFound,
     ItemAlreadyExists,
     QueryError(String),
+    IOError(io::Error),",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192087375,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r192087375,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,"I suggest to replace 

> export_path: *const c_char,
> export_key: *const c_char,

with export_config_json to allow extend export configuration in a backward compatible way",0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-06 10:19:39,193363106,"@@ -297,6 +297,53 @@ pub extern fn indy_list_wallets(command_handle: i32,
     res
 }
 
+/// Exports opened wallet
+///
+/// #Params:
+/// handle: wallet handle returned by indy_open_wallet
+/// export_path: file path where wallet should be exported to
+/// export_key: key from which export key will be derived
+///
+/// #Returns
+/// Error code
+///
+/// #Errors
+/// Common*
+/// Wallet*
+#[no_mangle]
+pub extern fn indy_export_wallet(command_handle: i32,
+                                 handle: i32,
+                                 export_path: *const c_char,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/193363106,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r193363106,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,"> handle 

it is better to rename to wallet_handle",0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-08 12:26:58,194040931,"@@ -216,6 +216,70 @@ extern ""C"" {
                                           void          (*fn)(indy_handle_t xcommand_handle, indy_error_t err, const char *const wallets)
                                           );
 
+    /// Exports opened wallet's content using key and path provided in export_config_json
+    ///
+    /// #Params
+    /// handle: wallet handle returned by indy_open_wallet.
+    /// export_config_json: JSON containing settings for input operation.
+    ///   {
+    ///     ""path"": path of the file that contains exported wallet content
+    ///     ""key"": passphrase used to export key
+    ///   }
+    ///
+    /// #Returns
+    /// Error code
+    ///
+    /// #Errors
+    /// Common*
+    /// Wallet*
+
+    extern indy_error_t indy_export_wallet(indy_handle_t  command_handle,
+                                           indy_handle_t  handle,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194040931,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194040931,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,"> passphrase used to export key

passphrase used to derive export key
",0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-08 12:27:40,194041115,"@@ -216,6 +216,70 @@ extern ""C"" {
                                           void          (*fn)(indy_handle_t xcommand_handle, indy_error_t err, const char *const wallets)
                                           );
 
+    /// Exports opened wallet's content using key and path provided in export_config_json
+    ///
+    /// #Params
+    /// handle: wallet handle returned by indy_open_wallet.
+    /// export_config_json: JSON containing settings for input operation.
+    ///   {
+    ///     ""path"": path of the file that contains exported wallet content
+    ///     ""key"": passphrase used to export key",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194041115,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194041115,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,">  ""rekey"": Optional<string>,

We don't need rekey here",0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-08 12:28:48,194041400,"@@ -216,6 +216,70 @@ extern ""C"" {
                                           void          (*fn)(indy_handle_t xcommand_handle, indy_error_t err, const char *const wallets)
                                           );
 
+    /// Exports opened wallet's content using key and path provided in export_config_json
+    ///
+    /// #Params
+    /// handle: wallet handle returned by indy_open_wallet.
+    /// export_config_json: JSON containing settings for input operation.
+    ///   {
+    ///     ""path"": path of the file that contains exported wallet content
+    ///     ""key"": passphrase used to export key
+    ///   }
+    ///
+    /// #Returns
+    /// Error code
+    ///
+    /// #Errors
+    /// Common*
+    /// Wallet*
+
+    extern indy_error_t indy_export_wallet(indy_handle_t  command_handle,
+                                           indy_handle_t  handle,
+                                           const char*    export_config_json,
+                                           void           (*fn)(indy_handle_t xcommand_handle, indy_error_t err)
+                                           );
+
+
+    /// Creates a new secure wallet with the given unique name and imports its content from
+    /// the file created using indy_export_wallet
+    ///
+    /// #Params
+    /// pool_name: Name of the pool that corresponds to this wallet.
+    /// name: Name of the wallet.
+    /// xtype(optional): Type of the wallet. Defaults to 'default'.
+    ///                  Custom types can be registered with indy_register_wallet_type call.
+    /// config(optional): Wallet configuration json. List of supported keys are defined by wallet type.
+    ///                    if NULL, then default config will be used.
+    /// credentials: Wallet credentials json
+    ///   {
+    ///       ""key"": string,
+    ///       ""rekey"": Optional<string>,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194041400,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194041400,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,"i used existing conventions, same as in close_wallet",0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-08 12:30:07,194041690,"@@ -216,6 +216,70 @@ extern ""C"" {
                                           void          (*fn)(indy_handle_t xcommand_handle, indy_error_t err, const char *const wallets)
                                           );
 
+    /// Exports opened wallet's content using key and path provided in export_config_json
+    ///
+    /// #Params
+    /// handle: wallet handle returned by indy_open_wallet.
+    /// export_config_json: JSON containing settings for input operation.
+    ///   {
+    ///     ""path"": path of the file that contains exported wallet content
+    ///     ""key"": passphrase used to export key
+    ///   }
+    ///
+    /// #Returns
+    /// Error code
+    ///
+    /// #Errors
+    /// Common*
+    /// Wallet*
+
+    extern indy_error_t indy_export_wallet(indy_handle_t  command_handle,
+                                           indy_handle_t  handle,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194041690,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194041690,keichiri
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,"> WalletEncryptionError 

I suggest to remove it in favor of:

- WalletAccessError if key provided by use is invalid
- ComminInvalidStructure if wallet export file has structure problems",0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-08 12:32:50,194042295,"@@ -105,7 +105,7 @@ pub enum ErrorCode
     WalletStorageError = 210,
 
     // Error during encryption-related operations
-    WalletEncryptonError = 211,
+    WalletEncryptionError = 211,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194042295,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194042295,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,Please replace it with ComminInvalidStructure ,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-08 12:33:03,194042365,"@@ -116,6 +116,18 @@ pub enum ErrorCode
     // Returned if provided wallet query is invalid
     WalletQueryError = 214,
 
+    // Returned if wallet input has invalid structure (currently used in wallet import)
+    WalletStructureError = 215,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194042365,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194042365,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,Seems we don't need it for now as always import to new wallet,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-08 12:33:29,194042470,"@@ -116,6 +116,18 @@ pub enum ErrorCode
     // Returned if provided wallet query is invalid
     WalletQueryError = 214,
 
+    // Returned if wallet input has invalid structure (currently used in wallet import)
+    WalletStructureError = 215,
+
+    // Returned if the wallet is not empty, but it is required (currently only when importing)
+    WalletNotEmpty = 216,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194042470,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194042470,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,I suggest to just raise CommonIOError here,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-08 12:34:07,194042611,"@@ -116,6 +116,18 @@ pub enum ErrorCode
     // Returned if provided wallet query is invalid
     WalletQueryError = 214,
 
+    // Returned if wallet input has invalid structure (currently used in wallet import)
+    WalletStructureError = 215,
+
+    // Returned if the wallet is not empty, but it is required (currently only when importing)
+    WalletNotEmpty = 216,
+
+    // Returned if path provided to wallet export already exists
+    WalletExportPathExists = 217,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194042611,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194042611,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,I suggest to just raise CommonIOError here,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-08 12:34:14,194042636,"@@ -116,6 +116,18 @@ pub enum ErrorCode
     // Returned if provided wallet query is invalid
     WalletQueryError = 214,
 
+    // Returned if wallet input has invalid structure (currently used in wallet import)
+    WalletStructureError = 215,
+
+    // Returned if the wallet is not empty, but it is required (currently only when importing)
+    WalletNotEmpty = 216,
+
+    // Returned if path provided to wallet export already exists
+    WalletExportPathExists = 217,
+
+    // Returned if path provided to wallet import does not exist
+    WalletImportPathDoesNotExist = 218,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194042636,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194042636,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,"> handle

Rename it to wallet_handle",0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-08 12:34:37,194042725,"@@ -308,6 +308,132 @@ pub extern fn indy_list_wallets(command_handle: i32,
     res
 }
 
+/// Exports opened wallet
+///
+/// #Params:
+/// handle: wallet handle returned by indy_open_wallet
+/// export_config_json: JSON containing settings for input operation.
+///   {
+///     ""path"": path of the file that contains exported wallet content
+///     ""key"": passphrase used to export key
+///   }
+///
+/// #Returns
+/// Error code
+///
+/// #Errors
+/// Common*
+/// Wallet*
+#[no_mangle]
+pub extern fn indy_export_wallet(command_handle: i32,
+                                 handle: i32,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194042725,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194042725,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,We don't need rekey here,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-08 12:35:34,194042922,"@@ -308,6 +308,132 @@ pub extern fn indy_list_wallets(command_handle: i32,
     res
 }
 
+/// Exports opened wallet
+///
+/// #Params:
+/// handle: wallet handle returned by indy_open_wallet
+/// export_config_json: JSON containing settings for input operation.
+///   {
+///     ""path"": path of the file that contains exported wallet content
+///     ""key"": passphrase used to export key
+///   }
+///
+/// #Returns
+/// Error code
+///
+/// #Errors
+/// Common*
+/// Wallet*
+#[no_mangle]
+pub extern fn indy_export_wallet(command_handle: i32,
+                                 handle: i32,
+                                 export_config_json: *const c_char,
+                                 cb: Option<extern fn(xcommand_handle: i32,
+                                                      err: ErrorCode)>) -> ErrorCode {
+    trace!(""indy_export_wallet: >>> handle: {:?}, export_config_json: {:?}"", handle, export_config_json);
+
+    check_useful_c_str!(export_config_json, ErrorCode::CommonInvalidParam3);
+    check_useful_c_callback!(cb, ErrorCode::CommonInvalidParam4);
+
+    trace!(""indy_export_wallet: entities >>> handle: {:?}, export_config_json: {:?}"", handle, export_config_json);
+
+    let result = CommandExecutor::instance()
+        .send(Command::Wallet(WalletCommand::Export(
+            handle,
+            export_config_json,
+            Box::new(move |result| {
+                let err = result_to_err_code!(result);
+                trace!(""indy_export_wallet: "");
+                cb(command_handle, err)
+            })
+        )));
+
+    let res = result_to_err_code!(result);
+
+    trace!(""indy_export_wallet: <<< res: {:?}"", res);
+
+    res
+}
+
+
+// Creates a new secure wallet with the given unique name and then imports its content
+// according to fields provided in import_config
+// This can be seen as an indy_create_wallet call with additional content import
+//
+// #Params
+// pool_name: Name of the pool that corresponds to this wallet
+// name: Name of the wallet
+// storage_type(optional): Type of the wallet storage. Defaults to 'default'.
+//                  Custom storage types can be registered with indy_register_wallet_storage_call
+/// config(optional): Wallet configuration json.
+///   {
+///       ""storage"": <object>  List of supported keys are defined by wallet type.
+///   }
+/// credentials: Wallet credentials json (if NULL, then default config will be used).
+///   {
+///       ""key"": string,
+///       ""rekey"": Optional<string>,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194042922,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194042922,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,"Its an old error, used throughout wallet, not added now",0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-08 12:36:40,194043162,"@@ -105,7 +105,7 @@ pub enum ErrorCode
     WalletStorageError = 210,
 
     // Error during encryption-related operations
-    WalletEncryptonError = 211,
+    WalletEncryptionError = 211,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194043162,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194043162,keichiri
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,Oh yes thats correct. Impossible to get now.,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-08 12:37:39,194043431,"@@ -116,6 +116,18 @@ pub enum ErrorCode
     // Returned if provided wallet query is invalid
     WalletQueryError = 214,
 
+    // Returned if wallet input has invalid structure (currently used in wallet import)
+    WalletStructureError = 215,
+
+    // Returned if the wallet is not empty, but it is required (currently only when importing)
+    WalletNotEmpty = 216,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194043431,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194043431,keichiri
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,i used existing conventions from close_wallet call,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-08 12:38:45,194043666,"@@ -308,6 +308,132 @@ pub extern fn indy_list_wallets(command_handle: i32,
     res
 }
 
+/// Exports opened wallet
+///
+/// #Params:
+/// handle: wallet handle returned by indy_open_wallet
+/// export_config_json: JSON containing settings for input operation.
+///   {
+///     ""path"": path of the file that contains exported wallet content
+///     ""key"": passphrase used to export key
+///   }
+///
+/// #Returns
+/// Error code
+///
+/// #Errors
+/// Common*
+/// Wallet*
+#[no_mangle]
+pub extern fn indy_export_wallet(command_handle: i32,
+                                 handle: i32,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194043666,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194043666,keichiri
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,I wouldnt say its IO error. It is more of an configuration error,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-08 12:39:16,194043779,"@@ -116,6 +116,18 @@ pub enum ErrorCode
     // Returned if provided wallet query is invalid
     WalletQueryError = 214,
 
+    // Returned if wallet input has invalid structure (currently used in wallet import)
+    WalletStructureError = 215,
+
+    // Returned if the wallet is not empty, but it is required (currently only when importing)
+    WalletNotEmpty = 216,
+
+    // Returned if path provided to wallet export already exists
+    WalletExportPathExists = 217,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194043779,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194043779,keichiri
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,I wouldnt say its IO error. It is more of an configuration error,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-08 12:40:11,194044017,"@@ -116,6 +116,18 @@ pub enum ErrorCode
     // Returned if provided wallet query is invalid
     WalletQueryError = 214,
 
+    // Returned if wallet input has invalid structure (currently used in wallet import)
+    WalletStructureError = 215,
+
+    // Returned if the wallet is not empty, but it is required (currently only when importing)
+    WalletNotEmpty = 216,
+
+    // Returned if path provided to wallet export already exists
+    WalletExportPathExists = 217,
+
+    // Returned if path provided to wallet import does not exist
+    WalletImportPathDoesNotExist = 218,",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194044017,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194044017,keichiri
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,We can create wallet significantly later after the most of validation is done.,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-08 14:47:00,194081462,"@@ -519,13 +532,76 @@ impl WalletService {
         }
     }
 
+    pub fn export_wallet(&self, wallet_handle: i32, export_config_json: &str, version: u32) -> Result<(), WalletError> {
+        match self.wallets.borrow().get(&wallet_handle) {
+            Some(wallet) => {
+                let export_config: WalletExportConfig = serde_json::from_str(export_config_json)?;
+                let export_path = Path::new(&export_config.path);
+                if export_path.exists() {
+                    return Err(WalletError::ExportPathExists);
+                }
+
+                let export_file = File::create(export_path)?;
+                let writer = Box::new(export_file);
+                export(wallet, writer, &export_config.key, version)
+            }
+            None => Err(WalletError::InvalidHandle(wallet_handle.to_string()))
+        }
+    }
+
+    pub fn import(&self,
+                  pool_name: &str,
+                  name: &str,
+                  storage_type: Option<&str>,
+                  storage_config: Option<&str>,
+                  credentials: &str,
+                  import_config_json: &str) -> Result<(), WalletError> {
+        // TODO - this can be refactor to skip the entire wallet_handle ceremony,
+        // but in order to do that a lot of WalletService needs to be refactored
+        self.create_wallet(pool_name, name, storage_type, storage_config, credentials)?;",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194081462,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194081462,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,Why do we need code above?,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 05:59:12,194297933,"@@ -712,8 +713,15 @@ impl DidCommandExecutor {
         self.wallet_service.get_indy_object(wallet_handle, &their_did, &RecordOptions::id_value(), &mut String::new())
     }
 
+//    fn _wallet_get_did_metadata(&self, wallet_handle: i32, did: &str) -> Option<String> {
+//        self.wallet_service.get_indy_record::<Did>(wallet_handle, &did, &RecordOptions::full()).ok()
+//            .and_then(|rec| rec.get_tags().map(String::from))
+//            .and_then(|tags_json| serde_json::from_str(&tags_json).ok())
+//            .and_then(|tags: serde_json::Value| tags[""metadata""].as_str().map(String::from))
+//    }
+",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194297933,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194297933,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,Do we really need two level match?,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:01:38,194298174,"@@ -129,7 +129,14 @@ impl NonSecretsCommandExecutor {
 
         self._check_type(type_)?;
 
-        let res = self.wallet_service.add_record(wallet_handle, type_, id, value, tags_json.unwrap_or(""{}""))?; //TODO: question
+        let tags = match tags_json {
+            None => HashMap::new(),
+            Some(tags_string) =>  match serde_json::from_str(tags_string) {
+                Ok(tag_names) => tag_names,
+                Err(serde_json_err) => return Err(IndyError::WalletError(WalletError::InputError(format!(""Invalid tags input: {}"", tags_string))))
+            }
+        };",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194298174,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194298174,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,we always return CommonInvalidStructure in case of failed parsing (on commands layer) of input json parameter.,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:05:04,194298549,"@@ -129,7 +129,14 @@ impl NonSecretsCommandExecutor {
 
         self._check_type(type_)?;
 
-        let res = self.wallet_service.add_record(wallet_handle, type_, id, value, tags_json.unwrap_or(""{}""))?; //TODO: question
+        let tags = match tags_json {
+            None => HashMap::new(),
+            Some(tags_string) =>  match serde_json::from_str(tags_string) {
+                Ok(tag_names) => tag_names,
+                Err(serde_json_err) => return Err(IndyError::WalletError(WalletError::InputError(format!(""Invalid tags input: {}"", tags_string))))
+            }
+        };",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194298549,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194298549,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,"match is not required here and several places below
let tags: <HashMap<String, String>> = serde_json::from_str(tags_json)
            .map_err(|err| CommonError::InvalidStructure(format!(""Cannot deserialize tags: {:?}"", err)))?;",0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:06:12,194298666,"@@ -161,7 +168,11 @@ impl NonSecretsCommandExecutor {
 
         self._check_type(type_)?;
 
-        let res = self.wallet_service.update_record_tags(wallet_handle, type_, id, tags_json)?;
+        let tags: HashMap<String, String> = match serde_json::from_str(tags_json) {
+            Ok(tag_names) => tag_names,
+            Err(serde_json_err) => return Err(IndyError::WalletError(WalletError::InputError(format!(""Invalid tags input: {}"", tags_json))))
+        };
+        let res = self.wallet_service.update_record_tags(wallet_handle, type_, id, &tags)?;",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194298666,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194298666,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,Why do we need this errors?,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:07:14,194298760,"@@ -37,6 +37,9 @@ pub enum WalletError {
     ItemNotFound,
     ItemAlreadyExists,
     QueryError(String),
+    StructureError(String),
+    ExportPathExists,
+    ImportPathDoesNotExist,
 }",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194298760,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194298760,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,Why did you revert these functions?,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:08:07,194298857,"@@ -7,51 +7,60 @@ use utils::crypto::chacha20poly1305_ietf::ChaCha20Poly1305IETF;
 
 use errors::common::CommonError;
 use errors::wallet::WalletError;
+use services::wallet::WalletRecord;
+
+use super::wallet::Keys;
+use super::storage::{Tag, TagName, StorageEntity};
+
+
+pub(super) fn encrypt_tag_names(tag_names: &[&str], tag_name_key: &[u8], tags_hmac_key: &[u8]) -> Vec<TagName> {
+    let mut encrypted_tag_names = Vec::new();
+
+    for tag_name in tag_names {
+        let tag_name_bytes = tag_name.as_bytes();
+        let tag_name = if tag_name_bytes.len() > 0 && tag_name_bytes[0] as char == '~' {
+            TagName::OfPlain(
+                encrypt_as_searchable(&tag_name_bytes[1..], tag_name_key, tags_hmac_key)
+            )
+        } else {
+            TagName::OfEncrypted(
+                encrypt_as_searchable(tag_name_bytes, tag_name_key, tags_hmac_key)
+            )
+        };
+        encrypted_tag_names.push(tag_name)
+    }
 
-use super::storage::{Tag, TagName};
-
-pub(super) fn encrypt_tag_names(tag_names: &str, tag_name_key: &[u8], tags_hmac_key: &[u8]) -> Result<Vec<TagName>, WalletError> {
-    let tag_names: Vec<String> = serde_json::from_str(tag_names)
-        .map_err(|err| CommonError::InvalidStructure(format!(""Cannot deserialize tag_names"")))?;
-
-    let etag_names = tag_names
-        .iter()
-        .map(|tag_name|
-            if tag_name.starts_with(""~"") {
-                TagName::OfPlain(encrypt_as_searchable(
-                    &tag_name.as_bytes()[1..], tag_name_key, tags_hmac_key))
-            } else {
-                TagName::OfEncrypted(encrypt_as_searchable(tag_name.as_bytes(), tag_name_key, tags_hmac_key))
-            })
-        .collect::<Vec<TagName>>();
-
-    Ok(etag_names)
+    encrypted_tag_names
 }",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194298857,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194298857,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,I suggest using the sequence of initialization string and then parsing to HashMap instead of building HashMap because it is much more readable and similar to actual usage,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:12:00,194299278,"@@ -114,22 +129,50 @@ pub(super) fn decrypt_tags(etags: &Option<Vec<Tag>>, tag_name_key: &[u8], tag_va
     }
 }
 
+pub(super) fn decrypt_storage_record(record: &StorageEntity, keys: &Keys) -> Result<WalletRecord, WalletError> {
+    let decrypted_name = decrypt_merged(&record.name, &keys.name_key)?;
+    let decrypted_name = String::from_utf8(decrypted_name)?;
+
+    let decrypted_value = match record.value {
+        Some(ref value) => {
+            let decrypted_value_key = decrypt_merged(&value.key, &keys.value_key)?;
+            let decrypted_value = decrypt_merged(&value.data, &decrypted_value_key)?;
+            Some(String::from_utf8(decrypted_value)?)
+        },
+        None => None
+    };
+
+    let decrypted_type = match record.type_ {
+        Some(ref type_) => {
+            let decrypted_type = decrypt_merged(type_, &keys.type_key)?;
+            Some(String::from_utf8(decrypted_type)?)
+        },
+        None => None,
+    };
+
+    let decrypted_tags = decrypt_tags(&record.tags, &keys.tag_name_key, &keys.tag_value_key)?;
+    Ok(WalletRecord::new(decrypted_name, decrypted_type, decrypted_value, decrypted_tags))
+}
+
 
 #[cfg(test)]
 mod tests {
     use super::*;
 
     #[test]
     fn test_encrypt_decrypt_tags() {
-        let tags = r#""{""tag1"":""value1"", ""tag2"":""value2"", ""~tag3"":""value3""}""#;
+        let mut tags = HashMap::new();
+        tags.insert(""tag1"".to_string(), ""value1"".to_string());
+        tags.insert(""tag2"".to_string(), ""value2"".to_string());
+        tags.insert(""~tag3"".to_string(), ""value3"".to_string());
 ",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194299278,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194299278,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,use https://doc.rust-lang.org/std/fs/struct.OpenOptions.html instead of manual checking,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:15:21,194299697,"@@ -519,13 +532,76 @@ impl WalletService {
         }
     }
 
+    pub fn export_wallet(&self, wallet_handle: i32, export_config_json: &str, version: u32) -> Result<(), WalletError> {
+        match self.wallets.borrow().get(&wallet_handle) {
+            Some(wallet) => {
+                let export_config: WalletExportConfig = serde_json::from_str(export_config_json)?;
+                let export_path = Path::new(&export_config.path);
+                if export_path.exists() {
+                    return Err(WalletError::ExportPathExists);
+                }
+
+                let export_file = File::create(export_path)?;",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194299697,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194299697,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,same: https://doc.rust-lang.org/std/fs/struct.OpenOptions.html,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:16:32,194299844,"@@ -519,13 +532,76 @@ impl WalletService {
         }
     }
 
+    pub fn export_wallet(&self, wallet_handle: i32, export_config_json: &str, version: u32) -> Result<(), WalletError> {
+        match self.wallets.borrow().get(&wallet_handle) {
+            Some(wallet) => {
+                let export_config: WalletExportConfig = serde_json::from_str(export_config_json)?;
+                let export_path = Path::new(&export_config.path);
+                if export_path.exists() {
+                    return Err(WalletError::ExportPathExists);
+                }
+
+                let export_file = File::create(export_path)?;
+                let writer = Box::new(export_file);
+                export(wallet, writer, &export_config.key, version)
+            }
+            None => Err(WalletError::InvalidHandle(wallet_handle.to_string()))
+        }
+    }
+
+    pub fn import(&self,
+                  pool_name: &str,
+                  name: &str,
+                  storage_type: Option<&str>,
+                  storage_config: Option<&str>,
+                  credentials: &str,
+                  import_config_json: &str) -> Result<(), WalletError> {
+        let import_config: WalletExportConfig = serde_json::from_str(import_config_json)?;
+        let import_path = Path::new(&import_config.path);
+        if !import_path.exists() {
+            return Err(WalletError::ImportPathDoesNotExist);
+        }
+",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194299844,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194299844,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,Why did you add tests that are commented?,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:17:46,194299992,"@@ -1434,26 +1561,125 @@ mod tests {
         let type_ = ""type"";
         let name = ""name"";
         let value = ""value"";
-        let new_value = ""new_value"";
-        let tags_json = r#""{""tag_name_1"":""tag_value_1"", ""tag_name_2"":""new_tag_value_2"", ""~tag_name_3"":""new_tag_value_3""}""#;
+        let wallet_service = WalletService::new();
+        let mut tags: Tags = HashMap::new();
+        let tag_name_1 = ""tag_name_1"";
+        let tag_value_1 = ""tag_value_1"";
+        let tag_name_2 = ""tag_name_2"";
+        let tag_value_2 = ""tag_value_2"";
+        let tag_name_3 = ""~tag_name_3"";
+        let tag_value_3 = ""tag_value_3"";
+        tags.insert(tag_name_1.to_string(), tag_value_1.to_string());
+        tags.insert(tag_name_2.to_string(), tag_value_2.to_string());
+        tags.insert(tag_name_3.to_string(), tag_value_3.to_string());
         let wallet_service = WalletService::new();
 
         _register_inmem_wallet(&wallet_service);
 
         wallet_service.create_wallet(""pool1"", ""wallet1"", Some(""inmem""), None, &_credentials()).unwrap();
         let wallet_handle = wallet_service.open_wallet(""wallet1"", None, &_credentials()).unwrap();
 
-        wallet_service.add_record(wallet_handle, type_, name, value, &tags_json).unwrap();
+        wallet_service.add_record(wallet_handle, type_, name, value, &tags).unwrap();
 
-        let tag_names = r#""[""tag_name_1"", ""~tag_name_3""]""#;
-        wallet_service.delete_record_tags(wallet_handle, type_, name, tag_names).unwrap();
+        let tag_names = vec![""tag_name_1"", ""~tag_name_3""];
+        wallet_service.delete_record_tags(wallet_handle, type_, name, &tag_names).unwrap();
 
         let item = wallet_service.get_record(wallet_handle, type_, name, &_fetch_options(true, true, true)).unwrap();
-
-        let expected_tags_json = r#""{""tag_name_2"":""new_tag_value_2""}""#;
+        let mut expected_tags = HashMap::new();
+        expected_tags.insert(tag_name_2.to_string(), tag_value_2.to_string());
         let retrieved_tags = item.tags.unwrap();
-        assert_eq!(serde_json::from_str::<Tags>(&expected_tags_json).unwrap(), retrieved_tags);
-    }
+        assert_eq!(expected_tags, retrieved_tags);
+    }
+
+",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194299992,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194299992,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,Do we need these function? I can find their usages ,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:19:25,194300186,"@@ -22,6 +23,14 @@ impl ChaCha20Poly1305IETF {
         chacha20poly1305_ietf::gen_nonce()[..].to_vec()
     }
 
+    pub fn increment_nonce(nonce: &mut [u8]) {
+        increment_le(nonce);
+    }
+
+    pub fn nonce_len() -> usize { chacha20poly1305_ietf::NONCEBYTES }
+
+    pub fn key_len() -> usize { chacha20poly1305_ietf::KEYBYTES }
+",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194300186,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194300186,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,why do you copy/past these functions 4 times?,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:20:55,194300377,"@@ -231,6 +232,85 @@ mod high_cases {
             InmemWallet::cleanup();
         }
     }
+
+    mod export_wallet {
+        use super::*;
+        use std::path::PathBuf;
+        use std::fs;
+
+
+        fn _prepare_export_wallet_path() -> PathBuf {
+            let export_dir = EnvironmentUtils::tmp_path();
+            if !export_dir.exists() {
+                fs::create_dir_all(export_dir).unwrap();
+            }
+
+            EnvironmentUtils::tmp_file_path(""export_file"")
+        }
+
+        fn _prepare_export_wallet_config(path: &str) -> String {
+            format!(r##""{{""key"": ""{}"", ""path"": ""{}""}}""##, ""test_key"", path)
+        }
+",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194300377,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194300377,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,this variable doesn't use,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:21:32,194300482,"@@ -231,6 +232,85 @@ mod high_cases {
             InmemWallet::cleanup();
         }
     }
+
+    mod export_wallet {
+        use super::*;
+        use std::path::PathBuf;
+        use std::fs;
+
+
+        fn _prepare_export_wallet_path() -> PathBuf {
+            let export_dir = EnvironmentUtils::tmp_path();
+            if !export_dir.exists() {
+                fs::create_dir_all(export_dir).unwrap();
+            }
+
+            EnvironmentUtils::tmp_file_path(""export_file"")
+        }
+
+        fn _prepare_export_wallet_config(path: &str) -> String {
+            format!(r##""{{""key"": ""{}"", ""path"": ""{}""}}""##, ""test_key"", path)
+        }
+
+        #[test]
+        fn indy_export_wallet_works() {
+            TestUtils::cleanup_storage();
+            let export_key = ""test_key"";",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194300482,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194300482,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,every test must close wallet after them,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:22:25,194300606,"@@ -231,6 +232,85 @@ mod high_cases {
             InmemWallet::cleanup();
         }
     }
+
+    mod export_wallet {
+        use super::*;
+        use std::path::PathBuf;
+        use std::fs;
+
+
+        fn _prepare_export_wallet_path() -> PathBuf {
+            let export_dir = EnvironmentUtils::tmp_path();
+            if !export_dir.exists() {
+                fs::create_dir_all(export_dir).unwrap();
+            }
+
+            EnvironmentUtils::tmp_file_path(""export_file"")
+        }
+
+        fn _prepare_export_wallet_config(path: &str) -> String {
+            format!(r##""{{""key"": ""{}"", ""path"": ""{}""}}""##, ""test_key"", path)
+        }
+
+        #[test]
+        fn indy_export_wallet_works() {
+            TestUtils::cleanup_storage();
+            let export_key = ""test_key"";
+            let path = _prepare_export_wallet_path();
+            let path_str = path.to_str().unwrap();
+            let config_json = _prepare_export_wallet_config(path_str);
+
+            let wallet_name = ""indy_export_wallet_works"";
+            WalletUtils::create_wallet(POOL, wallet_name, None, None, None).unwrap();
+            let wallet_handle = WalletUtils::open_wallet(wallet_name, None, None).unwrap();
+            WalletUtils::export_wallet(wallet_handle, &config_json).unwrap();
+
+            assert!(path.exists());
+            TestUtils::cleanup_storage();
+        }",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194300606,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194300606,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,these have already been declared above.,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:23:50,194300794,"@@ -231,6 +232,85 @@ mod high_cases {
             InmemWallet::cleanup();
         }
     }
+
+    mod export_wallet {
+        use super::*;
+        use std::path::PathBuf;
+        use std::fs;
+
+
+        fn _prepare_export_wallet_path() -> PathBuf {
+            let export_dir = EnvironmentUtils::tmp_path();
+            if !export_dir.exists() {
+                fs::create_dir_all(export_dir).unwrap();
+            }
+
+            EnvironmentUtils::tmp_file_path(""export_file"")
+        }
+
+        fn _prepare_export_wallet_config(path: &str) -> String {
+            format!(r##""{{""key"": ""{}"", ""path"": ""{}""}}""##, ""test_key"", path)
+        }
+
+        #[test]
+        fn indy_export_wallet_works() {
+            TestUtils::cleanup_storage();
+            let export_key = ""test_key"";
+            let path = _prepare_export_wallet_path();
+            let path_str = path.to_str().unwrap();
+            let config_json = _prepare_export_wallet_config(path_str);
+
+            let wallet_name = ""indy_export_wallet_works"";
+            WalletUtils::create_wallet(POOL, wallet_name, None, None, None).unwrap();
+            let wallet_handle = WalletUtils::open_wallet(wallet_name, None, None).unwrap();
+            WalletUtils::export_wallet(wallet_handle, &config_json).unwrap();
+
+            assert!(path.exists());
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod import_wallet {
+        use super::*;
+        use std::path::PathBuf;
+        use std::fs;
+
+
+        fn _prepare_export_wallet_path() -> PathBuf {
+            let export_dir = EnvironmentUtils::tmp_path();
+            if !export_dir.exists() {
+                fs::create_dir_all(export_dir).unwrap();
+            }
+
+            EnvironmentUtils::tmp_file_path(""export_file"")
+        }
+
+        fn _prepare_export_wallet_config(path: &str) -> String {
+            format!(r##""{{""key"": ""{}"", ""path"": ""{}""}}""##, ""test_key"", path)
+        }",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194300794,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194300794,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,we need the test that export/import not empty wallet and check compare contents,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:25:10,194300982,"@@ -231,6 +232,85 @@ mod high_cases {
             InmemWallet::cleanup();
         }
     }
+
+    mod export_wallet {
+        use super::*;
+        use std::path::PathBuf;
+        use std::fs;
+
+
+        fn _prepare_export_wallet_path() -> PathBuf {
+            let export_dir = EnvironmentUtils::tmp_path();
+            if !export_dir.exists() {
+                fs::create_dir_all(export_dir).unwrap();
+            }
+
+            EnvironmentUtils::tmp_file_path(""export_file"")
+        }
+
+        fn _prepare_export_wallet_config(path: &str) -> String {
+            format!(r##""{{""key"": ""{}"", ""path"": ""{}""}}""##, ""test_key"", path)
+        }
+
+        #[test]
+        fn indy_export_wallet_works() {
+            TestUtils::cleanup_storage();
+            let export_key = ""test_key"";
+            let path = _prepare_export_wallet_path();
+            let path_str = path.to_str().unwrap();
+            let config_json = _prepare_export_wallet_config(path_str);
+
+            let wallet_name = ""indy_export_wallet_works"";
+            WalletUtils::create_wallet(POOL, wallet_name, None, None, None).unwrap();
+            let wallet_handle = WalletUtils::open_wallet(wallet_name, None, None).unwrap();
+            WalletUtils::export_wallet(wallet_handle, &config_json).unwrap();
+
+            assert!(path.exists());
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod import_wallet {
+        use super::*;
+        use std::path::PathBuf;
+        use std::fs;
+
+
+        fn _prepare_export_wallet_path() -> PathBuf {
+            let export_dir = EnvironmentUtils::tmp_path();
+            if !export_dir.exists() {
+                fs::create_dir_all(export_dir).unwrap();
+            }
+
+            EnvironmentUtils::tmp_file_path(""export_file"")
+        }
+
+        fn _prepare_export_wallet_config(path: &str) -> String {
+            format!(r##""{{""key"": ""{}"", ""path"": ""{}""}}""##, ""test_key"", path)
+        }
+
+        #[test]
+        fn indy_import_wallet_works() {",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194300982,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194300982,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,Why we can't use helpers functions?,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:26:28,194301176,"@@ -460,4 +540,132 @@ mod medium_cases {
             TestUtils::cleanup_storage();
         }
     }
+
+    mod export_wallet {
+        use super::*;
+        use std::path::PathBuf;
+        use std::fs;
+
+
+        fn _prepare_export_wallet_path() -> PathBuf {
+            let export_dir = EnvironmentUtils::tmp_path();
+            if !export_dir.exists() {
+                fs::create_dir_all(export_dir).unwrap();
+            }
+
+            EnvironmentUtils::tmp_file_path(""export_file"")
+        }
+
+        fn _prepare_export_wallet_config(path: &str) -> String {
+            format!(r##""{{""key"": ""{}"", ""path"": ""{}""}}""##, ""test_key"", path)
+        }
+
+        #[test]
+        fn indy_export_wallet_returns_error_if_path_exists() {
+            TestUtils::cleanup_storage();
+            let export_key = ""test_key"";
+            let path = _prepare_export_wallet_path();
+            let path_str = path.to_str().unwrap();
+            fs::File::create(&path).unwrap();
+            let config_json = _prepare_export_wallet_config(path_str);
+",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194301176,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194301176,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,here must be CommonInvalidStructure,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:26:58,194301244,"@@ -460,4 +540,132 @@ mod medium_cases {
             TestUtils::cleanup_storage();
         }
     }
+
+    mod export_wallet {
+        use super::*;
+        use std::path::PathBuf;
+        use std::fs;
+
+
+        fn _prepare_export_wallet_path() -> PathBuf {
+            let export_dir = EnvironmentUtils::tmp_path();
+            if !export_dir.exists() {
+                fs::create_dir_all(export_dir).unwrap();
+            }
+
+            EnvironmentUtils::tmp_file_path(""export_file"")
+        }
+
+        fn _prepare_export_wallet_config(path: &str) -> String {
+            format!(r##""{{""key"": ""{}"", ""path"": ""{}""}}""##, ""test_key"", path)
+        }
+
+        #[test]
+        fn indy_export_wallet_returns_error_if_path_exists() {
+            TestUtils::cleanup_storage();
+            let export_key = ""test_key"";
+            let path = _prepare_export_wallet_path();
+            let path_str = path.to_str().unwrap();
+            fs::File::create(&path).unwrap();
+            let config_json = _prepare_export_wallet_config(path_str);
+
+            let wallet_name = ""indy_export_wallet_returns_error_if_path_exists"";
+            WalletUtils::create_wallet(POOL, wallet_name, None, None, None).unwrap();
+            let wallet_handle = WalletUtils::open_wallet(wallet_name, None, None).unwrap();
+            let res = WalletUtils::export_wallet(wallet_handle, &config_json);
+
+            assert_match!(Err(ErrorCode::CommonIOError), res);
+            assert!(path.exists());
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_export_wallet_returns_error_if_invalid_config() {
+            TestUtils::cleanup_storage();
+            let export_key = ""test_key"";
+            let path = _prepare_export_wallet_path();
+            let path_str = path.to_str().unwrap();
+            fs::File::create(&path).unwrap();
+
+            let wallet_name = ""indy_export_wallet_returns_error_if_invalid_config"";
+            WalletUtils::create_wallet(POOL, wallet_name, None, None, None).unwrap();
+            let wallet_handle = WalletUtils::open_wallet(wallet_name, None, None).unwrap();
+            let res = WalletUtils::export_wallet(wallet_handle, ""{}"");
+
+            // TODO - maybe introduce WalletConfigurationError
+            assert_match!(Err(ErrorCode::WalletDecodingError), res);",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194301244,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194301244,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,"please use assert_eq!(ErrorCode::CommonIOError, res.unwrap_err()); as other tests",0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 06:27:54,194301388,"@@ -460,4 +540,132 @@ mod medium_cases {
             TestUtils::cleanup_storage();
         }
     }
+
+    mod export_wallet {
+        use super::*;
+        use std::path::PathBuf;
+        use std::fs;
+
+
+        fn _prepare_export_wallet_path() -> PathBuf {
+            let export_dir = EnvironmentUtils::tmp_path();
+            if !export_dir.exists() {
+                fs::create_dir_all(export_dir).unwrap();
+            }
+
+            EnvironmentUtils::tmp_file_path(""export_file"")
+        }
+
+        fn _prepare_export_wallet_config(path: &str) -> String {
+            format!(r##""{{""key"": ""{}"", ""path"": ""{}""}}""##, ""test_key"", path)
+        }
+
+        #[test]
+        fn indy_export_wallet_returns_error_if_path_exists() {
+            TestUtils::cleanup_storage();
+            let export_key = ""test_key"";
+            let path = _prepare_export_wallet_path();
+            let path_str = path.to_str().unwrap();
+            fs::File::create(&path).unwrap();
+            let config_json = _prepare_export_wallet_config(path_str);
+
+            let wallet_name = ""indy_export_wallet_returns_error_if_path_exists"";
+            WalletUtils::create_wallet(POOL, wallet_name, None, None, None).unwrap();
+            let wallet_handle = WalletUtils::open_wallet(wallet_name, None, None).unwrap();
+            let res = WalletUtils::export_wallet(wallet_handle, &config_json);
+
+            assert_match!(Err(ErrorCode::CommonIOError), res);
+            assert!(path.exists());
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_export_wallet_returns_error_if_invalid_config() {
+            TestUtils::cleanup_storage();
+            let export_key = ""test_key"";
+            let path = _prepare_export_wallet_path();
+            let path_str = path.to_str().unwrap();
+            fs::File::create(&path).unwrap();
+
+            let wallet_name = ""indy_export_wallet_returns_error_if_invalid_config"";
+            WalletUtils::create_wallet(POOL, wallet_name, None, None, None).unwrap();
+            let wallet_handle = WalletUtils::open_wallet(wallet_name, None, None).unwrap();
+            let res = WalletUtils::export_wallet(wallet_handle, ""{}"");
+
+            // TODO - maybe introduce WalletConfigurationError
+            assert_match!(Err(ErrorCode::WalletDecodingError), res);
+            assert!(path.exists());
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_export_wallet_returns_error_if_invalid_handle() {
+            TestUtils::cleanup_storage();
+            let export_key = ""test_key"";
+            let path = _prepare_export_wallet_path();
+            let path_str = path.to_str().unwrap();
+            fs::File::create(&path).unwrap();
+            let config_json = _prepare_export_wallet_config(path_str);
+
+            let wallet_name = ""indy_export_wallet_returns_error_if_invalid_handle"";
+            WalletUtils::create_wallet(POOL, wallet_name, None, None, None).unwrap();
+            let wallet_handle = WalletUtils::open_wallet(wallet_name, None, None).unwrap();
+            let res = WalletUtils::export_wallet(wallet_handle + 1, &config_json);
+            assert_match!(Err(ErrorCode::WalletInvalidHandle), res);
+            assert!(path.exists());
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod import_wallet {
+        use super::*;
+        use std::path::PathBuf;
+        use std::fs;
+
+
+        fn _prepare_export_wallet_path() -> PathBuf {
+            let export_dir = EnvironmentUtils::tmp_path();
+            if !export_dir.exists() {
+                fs::create_dir_all(export_dir).unwrap();
+            }
+
+            EnvironmentUtils::tmp_file_path(""export_file"")
+        }
+
+        fn _prepare_export_wallet_config(path: &str) -> String {
+            format!(r##""{{""key"": ""{}"", ""path"": ""{}""}}""##, ""test_key"", path)
+        }
+
+        #[test]
+        fn indy_import_wallet_returns_error_if_path_doesnt_exist() {
+            TestUtils::cleanup_storage();
+            let export_key = ""test_key"";
+            let path = _prepare_export_wallet_path();
+            let path_str = path.to_str().unwrap();
+            let config_json = _prepare_export_wallet_config(path_str);
+
+            let wallet_name = ""indy_import_wallet_returns_error_if_path_doesnt_exist"";
+            let res = WalletUtils::import_wallet(POOL, wallet_name, None, None, None, &config_json);
+            assert_match!(Err(ErrorCode::CommonIOError), res);",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194301388,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194301388,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,you are correct. Your choice is more elegant. I switched to it (and in other places). Thank you,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 15:24:52,194445041,"@@ -129,7 +129,14 @@ impl NonSecretsCommandExecutor {
 
         self._check_type(type_)?;
 
-        let res = self.wallet_service.add_record(wallet_handle, type_, id, value, tags_json.unwrap_or(""{}""))?; //TODO: question
+        let tags = match tags_json {
+            None => HashMap::new(),
+            Some(tags_string) =>  match serde_json::from_str(tags_string) {
+                Ok(tag_names) => tag_names,
+                Err(serde_json_err) => return Err(IndyError::WalletError(WalletError::InputError(format!(""Invalid tags input: {}"", tags_string))))
+            }
+        };",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194445041,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194445041,keichiri
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,"Sorry, I didnt look at the content during the merge resolution. It slipped to me that you refactored them meanwhile. I thought it was outdated. I redid the merge, and your changes are active",0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-11 15:26:07,194445504,"@@ -7,51 +7,60 @@ use utils::crypto::chacha20poly1305_ietf::ChaCha20Poly1305IETF;
 
 use errors::common::CommonError;
 use errors::wallet::WalletError;
+use services::wallet::WalletRecord;
+
+use super::wallet::Keys;
+use super::storage::{Tag, TagName, StorageEntity};
+
+
+pub(super) fn encrypt_tag_names(tag_names: &[&str], tag_name_key: &[u8], tags_hmac_key: &[u8]) -> Vec<TagName> {
+    let mut encrypted_tag_names = Vec::new();
+
+    for tag_name in tag_names {
+        let tag_name_bytes = tag_name.as_bytes();
+        let tag_name = if tag_name_bytes.len() > 0 && tag_name_bytes[0] as char == '~' {
+            TagName::OfPlain(
+                encrypt_as_searchable(&tag_name_bytes[1..], tag_name_key, tags_hmac_key)
+            )
+        } else {
+            TagName::OfEncrypted(
+                encrypt_as_searchable(tag_name_bytes, tag_name_key, tags_hmac_key)
+            )
+        };
+        encrypted_tag_names.push(tag_name)
+    }
 
-use super::storage::{Tag, TagName};
-
-pub(super) fn encrypt_tag_names(tag_names: &str, tag_name_key: &[u8], tags_hmac_key: &[u8]) -> Result<Vec<TagName>, WalletError> {
-    let tag_names: Vec<String> = serde_json::from_str(tag_names)
-        .map_err(|err| CommonError::InvalidStructure(format!(""Cannot deserialize tag_names"")))?;
-
-    let etag_names = tag_names
-        .iter()
-        .map(|tag_name|
-            if tag_name.starts_with(""~"") {
-                TagName::OfPlain(encrypt_as_searchable(
-                    &tag_name.as_bytes()[1..], tag_name_key, tags_hmac_key))
-            } else {
-                TagName::OfEncrypted(encrypt_as_searchable(tag_name.as_bytes(), tag_name_key, tags_hmac_key))
-            })
-        .collect::<Vec<TagName>>();
-
-    Ok(etag_names)
+    encrypted_tag_names
 }",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194445504,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r194445504,keichiri
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,Will it work on windows and OSX? There is corresponded You can use EnvironmentUtils::tmp_path,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-13 09:02:03,195005545,"@@ -1576,4 +1686,169 @@ mod tests {
         assert_eq!(""type"", record.get_type().unwrap());
         assert_eq!(""value1"", record.get_value().unwrap());
     }
-}
+
+    /**
+        Export/Import tests
+    */
+    fn _get_export_dir_path() -> &'static str {
+         ""/tmp/indy_wallet_export_tests""",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195005545,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r195005545,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,Will TestUtils:: cleanup_storage or cleanup_temp work instead?,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-13 09:03:00,195005813,"@@ -1576,4 +1686,169 @@ mod tests {
         assert_eq!(""type"", record.get_type().unwrap());
         assert_eq!(""value1"", record.get_value().unwrap());
     }
-}
+
+    /**
+        Export/Import tests
+    */
+    fn _get_export_dir_path() -> &'static str {
+         ""/tmp/indy_wallet_export_tests""
+    }
+
+    fn _get_export_file_path() -> &'static str {
+        ""/tmp/indy_wallet_export_tests/export_file""
+    }
+
+    fn _get_export_config() -> String {
+        format!(r##""{{""path"": ""{}"", ""key"": ""{}""}}""##, _get_export_file_path(), ""export_key"")
+    }
+
+    fn _prepare_export_path() {
+        let export_directory_path = Path::new(_get_export_dir_path());
+        if export_directory_path.exists() {
+            std::fs::remove_dir_all(export_directory_path).unwrap();
+        }
+        std::fs::create_dir(export_directory_path).unwrap();
+    }
+
+    fn _remove_export_path() {
+        let export_directory_path = Path::new(_get_export_dir_path());",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195005813,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r195005813,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,Why don't use EnvironmentUitls ??? There is corresponded helper.,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-13 09:06:21,195007186,"@@ -0,0 +1,1108 @@
+use std::mem;
+use std::io::{Write, Read, BufWriter, BufReader};
+use std::time::{SystemTime, UNIX_EPOCH};
+use std::collections::HashMap;
+
+use serde_json;
+
+use utils::crypto::hash::Hash;
+use utils::crypto::chacha20poly1305_ietf::ChaCha20Poly1305IETF;
+use utils::crypto::pwhash_argon2i13::PwhashArgon2i13;
+use utils::byte_array::_clone_into_array;
+use services::wallet::encryption::{decrypt_merged, decrypt, encrypt_as_not_searchable};
+
+use errors::common::CommonError;
+
+use super::{WalletRecord, WalletError, Wallet};
+
+
+#[derive(Debug)]
+struct Header {
+    version: u32,
+    time: u64,
+    encryption_method: String,
+    nonce: Vec<u8>,
+    salt: [u8; PwhashArgon2i13::SALTBYTES],
+}
+
+
+impl Header {
+    fn new(version: u32, encryption_method: &str, nonce: &[u8], salt: [u8; PwhashArgon2i13::SALTBYTES]) -> Header {
+        let current_time = SystemTime::now();
+        let unix_time = current_time.duration_since(UNIX_EPOCH).unwrap();
+
+        Header {
+            version: version,
+            encryption_method: encryption_method.to_owned(),
+            nonce: nonce.to_owned(),
+            time: unix_time.as_secs(),
+            salt: salt,
+        }
+    }
+
+    fn deserialise(serialised: &[u8]) -> Result<Header, WalletError> {
+        let mut data_length: u16 = (serialised.len() - 52) as u16;
+        let version = bytes_to_u32(&serialised[2..6]);
+        let time = bytes_to_u64(&serialised[6..14]);
+
+        let method_length = bytes_to_u16(&serialised[14..16]);
+        if data_length < method_length {
+            return Err(WalletError::CommonError(CommonError::InvalidStructure(""Wallet header of insufficient size"".to_string())));
+        }
+        let method_start_index: usize = 16;
+        let method_end_index: usize = method_start_index + method_length as usize;
+        let method_data = &serialised[method_start_index..method_end_index];
+        let method = String::from_utf8(method_data.to_vec())?;
+        data_length -= method_length;
+
+        let nonce_length = bytes_to_u16(&serialised[method_end_index..method_end_index + 2]);
+        if nonce_length > data_length {
+            return Err(WalletError::CommonError(CommonError::InvalidStructure(""Specified nonce length too long"".to_string())));
+        }
+        let nonce_start_index = method_end_index + 2;
+        let nonce_end_index = nonce_start_index + nonce_length as usize;
+        let nonce_slice = &serialised[nonce_start_index..nonce_end_index];
+        let nonce = nonce_slice.to_vec();
+        data_length -= nonce_length;
+
+        let salt_length = bytes_to_u16(&serialised[nonce_end_index..nonce_end_index+2]);
+        if salt_length != data_length {
+            return Err(WalletError::CommonError(CommonError::InvalidStructure(""Wallet header lengths mismatch"".to_string())));
+        }
+        let salt_start_index = nonce_end_index + 2;
+        let salt_end_index = salt_start_index + salt_length as usize;
+        let salt_slice = &serialised[salt_start_index..salt_end_index];
+        let salt: [u8; PwhashArgon2i13::SALTBYTES] = _clone_into_array(salt_slice);
+
+        let actual_hash = sha256_hash(&serialised[..salt_end_index])?;
+        if actual_hash != &serialised[salt_end_index..salt_end_index+32] {
+            return Err(WalletError::CommonError(CommonError::InvalidStructure(""Wallet header hash mismatch"".to_string())));
+        }
+
+        Ok(Header {
+            version: version,
+            time: time,
+            encryption_method: method,
+            nonce: nonce,
+            salt: salt,
+        })
+    }
+
+    // Must return Result, since underlying hash library returns Result for some reason
+    fn serialise(&self) -> Result<Vec<u8>, WalletError> {
+        let mut v = Vec::new();
+        let header_length = (18 + self.encryption_method.len() + self.nonce.len() + self.salt.len() + 32) as u16;
+        v.extend(&u16_to_bytes(header_length));
+        let version_bytes = u32_to_bytes(self.version);
+        v.extend(&version_bytes);
+        let time_bytes = u64_to_bytes(self.time);
+        v.extend(&time_bytes);
+        let method_length_bytes = u16_to_bytes(self.encryption_method.len() as u16);
+        v.extend(&method_length_bytes);
+        v.extend(self.encryption_method.as_bytes());
+        let nonce_length_bytes = u16_to_bytes(self.nonce.len() as u16);
+        v.extend(&nonce_length_bytes);
+        v.extend(&self.nonce);
+        let salt_length_bytes = u16_to_bytes(self.salt.len() as u16);
+        v.extend(&salt_length_bytes);
+        v.extend(&self.salt);
+        let header_hash = sha256_hash(&v)?;
+        v.extend(&header_hash);
+        Ok(v)
+    }
+}
+
+
+pub (super) fn export(wallet: &Wallet, writer: Box<Write>, passphrase: &str, version: u32) -> Result<(), WalletError> {
+    let mut key: [u8; ChaCha20Poly1305IETF::KEYBYTES] = [0; ChaCha20Poly1305IETF::KEYBYTES];
+    let salt = PwhashArgon2i13::gen_salt();
+    PwhashArgon2i13::derive_key(&mut key, passphrase.as_bytes(), &salt)?;
+    let mut writer = BufWriter::new(writer);
+    let mut wallet_iterator = wallet.get_all()?;
+    let mut nonce = ChaCha20Poly1305IETF::gen_nonce();
+    let mut buffer = Vec::new();
+
+    let header = Header::new(version, ""ChaCha20Poly1305IETF"", &nonce, salt);
+    let serialised_header = header.serialise()?;
+    writer.write_all(&serialised_header)?;
+
+    while let Some(wallet_record) = wallet_iterator.next()? {
+        serialise_record(wallet_record, &mut buffer)?;
+        if buffer.len() < 1024 {
+            continue;
+        }
+
+        let mut decrypt_index = 0;
+        while decrypt_index + 1024 <= buffer.len() {
+            let chunk = &buffer[decrypt_index .. decrypt_index+1024];
+            let (encrypted_chunk, _) = ChaCha20Poly1305IETF::encrypt(chunk, &key, Some(&nonce));
+            ChaCha20Poly1305IETF::increment_nonce(&mut nonce);
+            writer.write_all(&encrypted_chunk)?;
+            decrypt_index += 1024;
+        }
+
+        let remaining = buffer.len() % 1024;
+        if remaining > 0 {
+            for i in 0 .. remaining {
+                buffer[i] = buffer[decrypt_index + i];
+            }
+        }
+        buffer.resize(remaining, 0);
+    }
+
+    if buffer.len() > 0 {
+        let (last_encrypted_chunk, _) = ChaCha20Poly1305IETF::encrypt(&buffer, &key, Some(&nonce));
+        writer.write_all(&last_encrypted_chunk)?;
+    }
+
+    writer.flush()?;
+
+    Ok(())
+}
+
+
+pub (super) fn import(wallet: &Wallet, reader: Box<Read>, passphrase: &str) -> Result<(), WalletError> {
+    let mut reader = BufReader::new(reader);
+
+    let mut header_length_bytes: [u8; 2] = [0; 2];
+    let read_count = reader.read(&mut header_length_bytes)?;
+    if read_count < 2 {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Failed to read import header bytes"".to_string())));
+    }
+    let header_length = bytes_to_u16(&header_length_bytes) as usize;
+    if header_length < 48 {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Wallet import header not of sufficient minimal length"".to_string())));
+    }
+
+    let mut header_data: Vec<u8> = vec![0; header_length + 2];
+    header_data[0] = header_length_bytes[0];
+    header_data[1] = header_length_bytes[1];
+
+    let mut header_read_count = 0;
+    while header_read_count < header_length {
+        let read_count = reader.read(&mut header_data[2 + header_read_count..])?;
+        if read_count == 0 {
+            return Err(WalletError::CommonError(CommonError::InvalidStructure(""Header body length less than specified"".to_string())));
+        } else {
+            header_read_count += read_count;
+        }
+    }
+
+    let header = Header::deserialise(&header_data)?;
+    let mut key: [u8; ChaCha20Poly1305IETF::KEYBYTES] = [0; ChaCha20Poly1305IETF::KEYBYTES];
+    PwhashArgon2i13::derive_key(&mut key, passphrase.as_bytes(), &header.salt)?;
+    let mut nonce = header.nonce;
+
+    let mut encrypted_chunk: [u8; 1040] = [0; 1040];
+    let mut decrypted_buffer = Vec::new();
+
+    let mut has_more = true;
+    while has_more {
+        let mut chunk_read_count = 0;
+        while chunk_read_count < 1040 {
+            let read_count = reader.read(&mut encrypted_chunk[chunk_read_count..])?;
+            if read_count == 0 {
+                has_more = false;
+                break;
+            }
+            chunk_read_count += read_count;
+        }
+
+        if chunk_read_count == 0 {
+            continue;
+        }
+
+        decrypted_buffer.extend(&decrypt(&encrypted_chunk[0..chunk_read_count], &key, &nonce)?);
+        ChaCha20Poly1305IETF::increment_nonce(&mut nonce);
+
+        add_records_from_buffer(wallet, &mut decrypted_buffer)?;
+    }
+
+    add_records_from_buffer(wallet, &mut decrypted_buffer)?;
+    if decrypted_buffer.len() != 0 {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Failed to import all content"".to_string())));
+    }
+
+    Ok(())
+}
+
+
+
+fn add_records_from_buffer(wallet: &Wallet, buff: &mut Vec<u8>) -> Result<(), WalletError> {
+    let mut index = 0;
+    while index + 4 < buff.len() {
+        let item_length = bytes_to_u32(&buff[index..index+4]);
+        let end_index = index + 4 + item_length as usize;
+        if end_index > buff.len() {
+            break;
+        }
+
+        let record = deserialise_record(&buff[index+4..end_index])?;
+        wallet.add(&record.type_.unwrap(), &record.name, &record.value.unwrap(), &record.tags.unwrap())?;
+        index = end_index;
+    }
+
+    let remaining = buff.len() - index;
+    for i in 0 .. remaining {
+        buff[i] = buff[index + i];
+    }
+    buff.resize(remaining, 0);
+
+    Ok(())
+}
+
+
+fn sha256_hash(input: &[u8]) -> Result<Vec<u8>, CommonError> {
+    let mut hasher = Hash::new_context()?;
+    hasher.update(input)?;
+    Ok(hasher.finish()?)
+}
+
+
+fn serialise_record(record: WalletRecord, buffer: &mut Vec<u8>) -> Result<(), WalletError> {
+    let record_type = record.type_.unwrap();
+    let record_name = record.name;
+    let record_value = record.value.unwrap();
+    let record_tags = record.tags.unwrap();
+    let record_tags_json = serde_json::to_string(&record_tags)?;
+    let record_length = record_type.len() + record_name.len() + record_value.len() + record_tags_json.len() + 16;
+
+    buffer.extend(&u32_to_bytes(record_length as u32));
+    buffer.extend(&u32_to_bytes(record_type.len() as u32));
+    buffer.extend(record_type.as_bytes());
+    buffer.extend(&u32_to_bytes(record_name.len() as u32));
+    buffer.extend(record_name.as_bytes());
+    buffer.extend(&u32_to_bytes(record_value.len() as u32));
+    buffer.extend(record_value.as_bytes());
+    buffer.extend(&u32_to_bytes(record_tags_json.len() as u32));
+    buffer.extend(record_tags_json.as_bytes());
+
+    Ok(())
+}
+
+
+fn deserialise_record(mut buffer: &[u8]) -> Result<WalletRecord, WalletError> {
+    let expected_total_length = buffer.len();
+    let type_length = bytes_to_u32(&buffer[..4]) as usize;
+    if type_length + 16 > buffer.len() {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Insufficient serialised data length"".to_string())));
+    }
+    let type_ = String::from_utf8(buffer[4..4+type_length].to_owned())?;
+    buffer = &buffer[4+type_length..];
+
+    let name_length = bytes_to_u32(&buffer[..4]) as usize;
+    if name_length + 12 > buffer.len() {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Insufficient serialised data length"".to_string())));
+    }
+    let name = String::from_utf8(buffer[4..4+name_length].to_owned())?;
+    buffer = &buffer[4+name_length..];
+
+    let value_length = bytes_to_u32(&buffer[..4]) as usize;
+    if value_length + 8 > buffer.len() {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Insufficient serialised data length"".to_string())));
+    }
+    let value = String::from_utf8(buffer[4..4+value_length].to_owned())?;
+    buffer = &buffer[4+value_length..];
+
+    let tags_json_length = bytes_to_u32(&buffer[..4]) as usize;
+    if tags_json_length > buffer.len() {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Insufficient serialised data length"".to_string())));
+    }
+
+    let total_length = type_length + name_length + value_length + tags_json_length + 16;
+    if total_length != expected_total_length {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Lengths mismatch during record deserialisation"".to_string())));
+    }
+
+    let tags_json = String::from_utf8(buffer[4..4+tags_json_length].to_owned())?;
+    let tags: HashMap<String, String> = serde_json::from_str(&tags_json)?;
+
+    let wallet_record = WalletRecord::new(name,Some(type_), Some(value),Some(tags));
+    Ok(wallet_record)
+}
+
+
+fn u64_to_bytes(u: u64) -> [u8; 8] {
+    let u = u.to_be();
+    let res: [u8; 8] = unsafe { mem::transmute(u) };
+    res
+}
+
+fn u32_to_bytes(u: u32) -> [u8; 4] {
+    let u = u.to_be();
+    let res: [u8; 4] = unsafe { mem::transmute(u) };
+    res
+}
+
+fn u16_to_bytes(u: u16) -> [u8; 2] {
+    let u = u.to_be();
+    let res: [u8; 2] = unsafe { mem::transmute(u) };
+    res
+}
+
+fn bytes_to_u64(b: &[u8]) -> u64 {
+    let mut byte_array: [u8; 8] = [0; 8];
+    byte_array.clone_from_slice(&b[0..8]);
+    let res: u64 = unsafe { mem::transmute(byte_array) };
+    u64::from_be(res)
+}
+
+fn bytes_to_u32(b: &[u8]) -> u32 {
+    let mut byte_array: [u8; 4] = [0; 4];
+    byte_array.clone_from_slice(&b[0..4]);
+    let res: u32 = unsafe { mem::transmute(byte_array) };
+    u32::from_be(res)
+}
+
+fn bytes_to_u16(b: &[u8]) -> u16 {
+    let mut byte_array: [u8; 2] = [0; 2];
+    byte_array.clone_from_slice(&b[0..2]);
+    let res: u16 = unsafe { mem::transmute(byte_array) };
+    u16::from_be(res)
+}
+
+
+#[cfg(test)]
+mod tests {
+    use std;
+    use std::io;
+    use std::io::{Read, BufReader};
+    use std::env;
+    use std::collections::HashMap;
+    extern crate rand;
+    use self::rand::*;
+    use serde_json;
+
+    use services::wallet::storage::WalletStorageType;
+    use services::wallet::storage::default::SQLiteStorageType;
+    use services::wallet::wallet::{Keys, Wallet};
+    use services::wallet::encryption::{decrypt_merged, decrypt, encrypt_as_not_searchable};
+    use super::*;
+
+
+    fn _wallet_path() -> std::path::PathBuf {",384,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195007186,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r195007186,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,Why don't use TestUtils ???,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-13 09:06:59,195007380,"@@ -0,0 +1,1108 @@
+use std::mem;
+use std::io::{Write, Read, BufWriter, BufReader};
+use std::time::{SystemTime, UNIX_EPOCH};
+use std::collections::HashMap;
+
+use serde_json;
+
+use utils::crypto::hash::Hash;
+use utils::crypto::chacha20poly1305_ietf::ChaCha20Poly1305IETF;
+use utils::crypto::pwhash_argon2i13::PwhashArgon2i13;
+use utils::byte_array::_clone_into_array;
+use services::wallet::encryption::{decrypt_merged, decrypt, encrypt_as_not_searchable};
+
+use errors::common::CommonError;
+
+use super::{WalletRecord, WalletError, Wallet};
+
+
+#[derive(Debug)]
+struct Header {
+    version: u32,
+    time: u64,
+    encryption_method: String,
+    nonce: Vec<u8>,
+    salt: [u8; PwhashArgon2i13::SALTBYTES],
+}
+
+
+impl Header {
+    fn new(version: u32, encryption_method: &str, nonce: &[u8], salt: [u8; PwhashArgon2i13::SALTBYTES]) -> Header {
+        let current_time = SystemTime::now();
+        let unix_time = current_time.duration_since(UNIX_EPOCH).unwrap();
+
+        Header {
+            version: version,
+            encryption_method: encryption_method.to_owned(),
+            nonce: nonce.to_owned(),
+            time: unix_time.as_secs(),
+            salt: salt,
+        }
+    }
+
+    fn deserialise(serialised: &[u8]) -> Result<Header, WalletError> {
+        let mut data_length: u16 = (serialised.len() - 52) as u16;
+        let version = bytes_to_u32(&serialised[2..6]);
+        let time = bytes_to_u64(&serialised[6..14]);
+
+        let method_length = bytes_to_u16(&serialised[14..16]);
+        if data_length < method_length {
+            return Err(WalletError::CommonError(CommonError::InvalidStructure(""Wallet header of insufficient size"".to_string())));
+        }
+        let method_start_index: usize = 16;
+        let method_end_index: usize = method_start_index + method_length as usize;
+        let method_data = &serialised[method_start_index..method_end_index];
+        let method = String::from_utf8(method_data.to_vec())?;
+        data_length -= method_length;
+
+        let nonce_length = bytes_to_u16(&serialised[method_end_index..method_end_index + 2]);
+        if nonce_length > data_length {
+            return Err(WalletError::CommonError(CommonError::InvalidStructure(""Specified nonce length too long"".to_string())));
+        }
+        let nonce_start_index = method_end_index + 2;
+        let nonce_end_index = nonce_start_index + nonce_length as usize;
+        let nonce_slice = &serialised[nonce_start_index..nonce_end_index];
+        let nonce = nonce_slice.to_vec();
+        data_length -= nonce_length;
+
+        let salt_length = bytes_to_u16(&serialised[nonce_end_index..nonce_end_index+2]);
+        if salt_length != data_length {
+            return Err(WalletError::CommonError(CommonError::InvalidStructure(""Wallet header lengths mismatch"".to_string())));
+        }
+        let salt_start_index = nonce_end_index + 2;
+        let salt_end_index = salt_start_index + salt_length as usize;
+        let salt_slice = &serialised[salt_start_index..salt_end_index];
+        let salt: [u8; PwhashArgon2i13::SALTBYTES] = _clone_into_array(salt_slice);
+
+        let actual_hash = sha256_hash(&serialised[..salt_end_index])?;
+        if actual_hash != &serialised[salt_end_index..salt_end_index+32] {
+            return Err(WalletError::CommonError(CommonError::InvalidStructure(""Wallet header hash mismatch"".to_string())));
+        }
+
+        Ok(Header {
+            version: version,
+            time: time,
+            encryption_method: method,
+            nonce: nonce,
+            salt: salt,
+        })
+    }
+
+    // Must return Result, since underlying hash library returns Result for some reason
+    fn serialise(&self) -> Result<Vec<u8>, WalletError> {
+        let mut v = Vec::new();
+        let header_length = (18 + self.encryption_method.len() + self.nonce.len() + self.salt.len() + 32) as u16;
+        v.extend(&u16_to_bytes(header_length));
+        let version_bytes = u32_to_bytes(self.version);
+        v.extend(&version_bytes);
+        let time_bytes = u64_to_bytes(self.time);
+        v.extend(&time_bytes);
+        let method_length_bytes = u16_to_bytes(self.encryption_method.len() as u16);
+        v.extend(&method_length_bytes);
+        v.extend(self.encryption_method.as_bytes());
+        let nonce_length_bytes = u16_to_bytes(self.nonce.len() as u16);
+        v.extend(&nonce_length_bytes);
+        v.extend(&self.nonce);
+        let salt_length_bytes = u16_to_bytes(self.salt.len() as u16);
+        v.extend(&salt_length_bytes);
+        v.extend(&self.salt);
+        let header_hash = sha256_hash(&v)?;
+        v.extend(&header_hash);
+        Ok(v)
+    }
+}
+
+
+pub (super) fn export(wallet: &Wallet, writer: Box<Write>, passphrase: &str, version: u32) -> Result<(), WalletError> {
+    let mut key: [u8; ChaCha20Poly1305IETF::KEYBYTES] = [0; ChaCha20Poly1305IETF::KEYBYTES];
+    let salt = PwhashArgon2i13::gen_salt();
+    PwhashArgon2i13::derive_key(&mut key, passphrase.as_bytes(), &salt)?;
+    let mut writer = BufWriter::new(writer);
+    let mut wallet_iterator = wallet.get_all()?;
+    let mut nonce = ChaCha20Poly1305IETF::gen_nonce();
+    let mut buffer = Vec::new();
+
+    let header = Header::new(version, ""ChaCha20Poly1305IETF"", &nonce, salt);
+    let serialised_header = header.serialise()?;
+    writer.write_all(&serialised_header)?;
+
+    while let Some(wallet_record) = wallet_iterator.next()? {
+        serialise_record(wallet_record, &mut buffer)?;
+        if buffer.len() < 1024 {
+            continue;
+        }
+
+        let mut decrypt_index = 0;
+        while decrypt_index + 1024 <= buffer.len() {
+            let chunk = &buffer[decrypt_index .. decrypt_index+1024];
+            let (encrypted_chunk, _) = ChaCha20Poly1305IETF::encrypt(chunk, &key, Some(&nonce));
+            ChaCha20Poly1305IETF::increment_nonce(&mut nonce);
+            writer.write_all(&encrypted_chunk)?;
+            decrypt_index += 1024;
+        }
+
+        let remaining = buffer.len() % 1024;
+        if remaining > 0 {
+            for i in 0 .. remaining {
+                buffer[i] = buffer[decrypt_index + i];
+            }
+        }
+        buffer.resize(remaining, 0);
+    }
+
+    if buffer.len() > 0 {
+        let (last_encrypted_chunk, _) = ChaCha20Poly1305IETF::encrypt(&buffer, &key, Some(&nonce));
+        writer.write_all(&last_encrypted_chunk)?;
+    }
+
+    writer.flush()?;
+
+    Ok(())
+}
+
+
+pub (super) fn import(wallet: &Wallet, reader: Box<Read>, passphrase: &str) -> Result<(), WalletError> {
+    let mut reader = BufReader::new(reader);
+
+    let mut header_length_bytes: [u8; 2] = [0; 2];
+    let read_count = reader.read(&mut header_length_bytes)?;
+    if read_count < 2 {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Failed to read import header bytes"".to_string())));
+    }
+    let header_length = bytes_to_u16(&header_length_bytes) as usize;
+    if header_length < 48 {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Wallet import header not of sufficient minimal length"".to_string())));
+    }
+
+    let mut header_data: Vec<u8> = vec![0; header_length + 2];
+    header_data[0] = header_length_bytes[0];
+    header_data[1] = header_length_bytes[1];
+
+    let mut header_read_count = 0;
+    while header_read_count < header_length {
+        let read_count = reader.read(&mut header_data[2 + header_read_count..])?;
+        if read_count == 0 {
+            return Err(WalletError::CommonError(CommonError::InvalidStructure(""Header body length less than specified"".to_string())));
+        } else {
+            header_read_count += read_count;
+        }
+    }
+
+    let header = Header::deserialise(&header_data)?;
+    let mut key: [u8; ChaCha20Poly1305IETF::KEYBYTES] = [0; ChaCha20Poly1305IETF::KEYBYTES];
+    PwhashArgon2i13::derive_key(&mut key, passphrase.as_bytes(), &header.salt)?;
+    let mut nonce = header.nonce;
+
+    let mut encrypted_chunk: [u8; 1040] = [0; 1040];
+    let mut decrypted_buffer = Vec::new();
+
+    let mut has_more = true;
+    while has_more {
+        let mut chunk_read_count = 0;
+        while chunk_read_count < 1040 {
+            let read_count = reader.read(&mut encrypted_chunk[chunk_read_count..])?;
+            if read_count == 0 {
+                has_more = false;
+                break;
+            }
+            chunk_read_count += read_count;
+        }
+
+        if chunk_read_count == 0 {
+            continue;
+        }
+
+        decrypted_buffer.extend(&decrypt(&encrypted_chunk[0..chunk_read_count], &key, &nonce)?);
+        ChaCha20Poly1305IETF::increment_nonce(&mut nonce);
+
+        add_records_from_buffer(wallet, &mut decrypted_buffer)?;
+    }
+
+    add_records_from_buffer(wallet, &mut decrypted_buffer)?;
+    if decrypted_buffer.len() != 0 {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Failed to import all content"".to_string())));
+    }
+
+    Ok(())
+}
+
+
+
+fn add_records_from_buffer(wallet: &Wallet, buff: &mut Vec<u8>) -> Result<(), WalletError> {
+    let mut index = 0;
+    while index + 4 < buff.len() {
+        let item_length = bytes_to_u32(&buff[index..index+4]);
+        let end_index = index + 4 + item_length as usize;
+        if end_index > buff.len() {
+            break;
+        }
+
+        let record = deserialise_record(&buff[index+4..end_index])?;
+        wallet.add(&record.type_.unwrap(), &record.name, &record.value.unwrap(), &record.tags.unwrap())?;
+        index = end_index;
+    }
+
+    let remaining = buff.len() - index;
+    for i in 0 .. remaining {
+        buff[i] = buff[index + i];
+    }
+    buff.resize(remaining, 0);
+
+    Ok(())
+}
+
+
+fn sha256_hash(input: &[u8]) -> Result<Vec<u8>, CommonError> {
+    let mut hasher = Hash::new_context()?;
+    hasher.update(input)?;
+    Ok(hasher.finish()?)
+}
+
+
+fn serialise_record(record: WalletRecord, buffer: &mut Vec<u8>) -> Result<(), WalletError> {
+    let record_type = record.type_.unwrap();
+    let record_name = record.name;
+    let record_value = record.value.unwrap();
+    let record_tags = record.tags.unwrap();
+    let record_tags_json = serde_json::to_string(&record_tags)?;
+    let record_length = record_type.len() + record_name.len() + record_value.len() + record_tags_json.len() + 16;
+
+    buffer.extend(&u32_to_bytes(record_length as u32));
+    buffer.extend(&u32_to_bytes(record_type.len() as u32));
+    buffer.extend(record_type.as_bytes());
+    buffer.extend(&u32_to_bytes(record_name.len() as u32));
+    buffer.extend(record_name.as_bytes());
+    buffer.extend(&u32_to_bytes(record_value.len() as u32));
+    buffer.extend(record_value.as_bytes());
+    buffer.extend(&u32_to_bytes(record_tags_json.len() as u32));
+    buffer.extend(record_tags_json.as_bytes());
+
+    Ok(())
+}
+
+
+fn deserialise_record(mut buffer: &[u8]) -> Result<WalletRecord, WalletError> {
+    let expected_total_length = buffer.len();
+    let type_length = bytes_to_u32(&buffer[..4]) as usize;
+    if type_length + 16 > buffer.len() {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Insufficient serialised data length"".to_string())));
+    }
+    let type_ = String::from_utf8(buffer[4..4+type_length].to_owned())?;
+    buffer = &buffer[4+type_length..];
+
+    let name_length = bytes_to_u32(&buffer[..4]) as usize;
+    if name_length + 12 > buffer.len() {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Insufficient serialised data length"".to_string())));
+    }
+    let name = String::from_utf8(buffer[4..4+name_length].to_owned())?;
+    buffer = &buffer[4+name_length..];
+
+    let value_length = bytes_to_u32(&buffer[..4]) as usize;
+    if value_length + 8 > buffer.len() {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Insufficient serialised data length"".to_string())));
+    }
+    let value = String::from_utf8(buffer[4..4+value_length].to_owned())?;
+    buffer = &buffer[4+value_length..];
+
+    let tags_json_length = bytes_to_u32(&buffer[..4]) as usize;
+    if tags_json_length > buffer.len() {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Insufficient serialised data length"".to_string())));
+    }
+
+    let total_length = type_length + name_length + value_length + tags_json_length + 16;
+    if total_length != expected_total_length {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Lengths mismatch during record deserialisation"".to_string())));
+    }
+
+    let tags_json = String::from_utf8(buffer[4..4+tags_json_length].to_owned())?;
+    let tags: HashMap<String, String> = serde_json::from_str(&tags_json)?;
+
+    let wallet_record = WalletRecord::new(name,Some(type_), Some(value),Some(tags));
+    Ok(wallet_record)
+}
+
+
+fn u64_to_bytes(u: u64) -> [u8; 8] {
+    let u = u.to_be();
+    let res: [u8; 8] = unsafe { mem::transmute(u) };
+    res
+}
+
+fn u32_to_bytes(u: u32) -> [u8; 4] {
+    let u = u.to_be();
+    let res: [u8; 4] = unsafe { mem::transmute(u) };
+    res
+}
+
+fn u16_to_bytes(u: u16) -> [u8; 2] {
+    let u = u.to_be();
+    let res: [u8; 2] = unsafe { mem::transmute(u) };
+    res
+}
+
+fn bytes_to_u64(b: &[u8]) -> u64 {
+    let mut byte_array: [u8; 8] = [0; 8];
+    byte_array.clone_from_slice(&b[0..8]);
+    let res: u64 = unsafe { mem::transmute(byte_array) };
+    u64::from_be(res)
+}
+
+fn bytes_to_u32(b: &[u8]) -> u32 {
+    let mut byte_array: [u8; 4] = [0; 4];
+    byte_array.clone_from_slice(&b[0..4]);
+    let res: u32 = unsafe { mem::transmute(byte_array) };
+    u32::from_be(res)
+}
+
+fn bytes_to_u16(b: &[u8]) -> u16 {
+    let mut byte_array: [u8; 2] = [0; 2];
+    byte_array.clone_from_slice(&b[0..2]);
+    let res: u16 = unsafe { mem::transmute(byte_array) };
+    u16::from_be(res)
+}
+
+
+#[cfg(test)]
+mod tests {
+    use std;
+    use std::io;
+    use std::io::{Read, BufReader};
+    use std::env;
+    use std::collections::HashMap;
+    extern crate rand;
+    use self::rand::*;
+    use serde_json;
+
+    use services::wallet::storage::WalletStorageType;
+    use services::wallet::storage::default::SQLiteStorageType;
+    use services::wallet::wallet::{Keys, Wallet};
+    use services::wallet::encryption::{decrypt_merged, decrypt, encrypt_as_not_searchable};
+    use super::*;
+
+
+    fn _wallet_path() -> std::path::PathBuf {
+        let mut path = env::home_dir().unwrap();
+        path.push("".indy_client"");
+        path.push(""wallet"");
+        path.push(""test_wallet"");
+        path
+    }
+
+    fn _cleanup() {",392,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195007380,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r195007380,vimmerru
https://github.com/hyperledger/indy-sdk/pull/775,https://github.com/hyperledger/indy-sdk/pull/775,Wll it work on windows and OSX? I suggest to use EnvrirnonmentUtils instead.,0ccf1d8910df829c3c1df58eb577e7e0858718fe,2018-06-13 09:07:57,195007670,"@@ -0,0 +1,1108 @@
+use std::mem;
+use std::io::{Write, Read, BufWriter, BufReader};
+use std::time::{SystemTime, UNIX_EPOCH};
+use std::collections::HashMap;
+
+use serde_json;
+
+use utils::crypto::hash::Hash;
+use utils::crypto::chacha20poly1305_ietf::ChaCha20Poly1305IETF;
+use utils::crypto::pwhash_argon2i13::PwhashArgon2i13;
+use utils::byte_array::_clone_into_array;
+use services::wallet::encryption::{decrypt_merged, decrypt, encrypt_as_not_searchable};
+
+use errors::common::CommonError;
+
+use super::{WalletRecord, WalletError, Wallet};
+
+
+#[derive(Debug)]
+struct Header {
+    version: u32,
+    time: u64,
+    encryption_method: String,
+    nonce: Vec<u8>,
+    salt: [u8; PwhashArgon2i13::SALTBYTES],
+}
+
+
+impl Header {
+    fn new(version: u32, encryption_method: &str, nonce: &[u8], salt: [u8; PwhashArgon2i13::SALTBYTES]) -> Header {
+        let current_time = SystemTime::now();
+        let unix_time = current_time.duration_since(UNIX_EPOCH).unwrap();
+
+        Header {
+            version: version,
+            encryption_method: encryption_method.to_owned(),
+            nonce: nonce.to_owned(),
+            time: unix_time.as_secs(),
+            salt: salt,
+        }
+    }
+
+    fn deserialise(serialised: &[u8]) -> Result<Header, WalletError> {
+        let mut data_length: u16 = (serialised.len() - 52) as u16;
+        let version = bytes_to_u32(&serialised[2..6]);
+        let time = bytes_to_u64(&serialised[6..14]);
+
+        let method_length = bytes_to_u16(&serialised[14..16]);
+        if data_length < method_length {
+            return Err(WalletError::CommonError(CommonError::InvalidStructure(""Wallet header of insufficient size"".to_string())));
+        }
+        let method_start_index: usize = 16;
+        let method_end_index: usize = method_start_index + method_length as usize;
+        let method_data = &serialised[method_start_index..method_end_index];
+        let method = String::from_utf8(method_data.to_vec())?;
+        data_length -= method_length;
+
+        let nonce_length = bytes_to_u16(&serialised[method_end_index..method_end_index + 2]);
+        if nonce_length > data_length {
+            return Err(WalletError::CommonError(CommonError::InvalidStructure(""Specified nonce length too long"".to_string())));
+        }
+        let nonce_start_index = method_end_index + 2;
+        let nonce_end_index = nonce_start_index + nonce_length as usize;
+        let nonce_slice = &serialised[nonce_start_index..nonce_end_index];
+        let nonce = nonce_slice.to_vec();
+        data_length -= nonce_length;
+
+        let salt_length = bytes_to_u16(&serialised[nonce_end_index..nonce_end_index+2]);
+        if salt_length != data_length {
+            return Err(WalletError::CommonError(CommonError::InvalidStructure(""Wallet header lengths mismatch"".to_string())));
+        }
+        let salt_start_index = nonce_end_index + 2;
+        let salt_end_index = salt_start_index + salt_length as usize;
+        let salt_slice = &serialised[salt_start_index..salt_end_index];
+        let salt: [u8; PwhashArgon2i13::SALTBYTES] = _clone_into_array(salt_slice);
+
+        let actual_hash = sha256_hash(&serialised[..salt_end_index])?;
+        if actual_hash != &serialised[salt_end_index..salt_end_index+32] {
+            return Err(WalletError::CommonError(CommonError::InvalidStructure(""Wallet header hash mismatch"".to_string())));
+        }
+
+        Ok(Header {
+            version: version,
+            time: time,
+            encryption_method: method,
+            nonce: nonce,
+            salt: salt,
+        })
+    }
+
+    // Must return Result, since underlying hash library returns Result for some reason
+    fn serialise(&self) -> Result<Vec<u8>, WalletError> {
+        let mut v = Vec::new();
+        let header_length = (18 + self.encryption_method.len() + self.nonce.len() + self.salt.len() + 32) as u16;
+        v.extend(&u16_to_bytes(header_length));
+        let version_bytes = u32_to_bytes(self.version);
+        v.extend(&version_bytes);
+        let time_bytes = u64_to_bytes(self.time);
+        v.extend(&time_bytes);
+        let method_length_bytes = u16_to_bytes(self.encryption_method.len() as u16);
+        v.extend(&method_length_bytes);
+        v.extend(self.encryption_method.as_bytes());
+        let nonce_length_bytes = u16_to_bytes(self.nonce.len() as u16);
+        v.extend(&nonce_length_bytes);
+        v.extend(&self.nonce);
+        let salt_length_bytes = u16_to_bytes(self.salt.len() as u16);
+        v.extend(&salt_length_bytes);
+        v.extend(&self.salt);
+        let header_hash = sha256_hash(&v)?;
+        v.extend(&header_hash);
+        Ok(v)
+    }
+}
+
+
+pub (super) fn export(wallet: &Wallet, writer: Box<Write>, passphrase: &str, version: u32) -> Result<(), WalletError> {
+    let mut key: [u8; ChaCha20Poly1305IETF::KEYBYTES] = [0; ChaCha20Poly1305IETF::KEYBYTES];
+    let salt = PwhashArgon2i13::gen_salt();
+    PwhashArgon2i13::derive_key(&mut key, passphrase.as_bytes(), &salt)?;
+    let mut writer = BufWriter::new(writer);
+    let mut wallet_iterator = wallet.get_all()?;
+    let mut nonce = ChaCha20Poly1305IETF::gen_nonce();
+    let mut buffer = Vec::new();
+
+    let header = Header::new(version, ""ChaCha20Poly1305IETF"", &nonce, salt);
+    let serialised_header = header.serialise()?;
+    writer.write_all(&serialised_header)?;
+
+    while let Some(wallet_record) = wallet_iterator.next()? {
+        serialise_record(wallet_record, &mut buffer)?;
+        if buffer.len() < 1024 {
+            continue;
+        }
+
+        let mut decrypt_index = 0;
+        while decrypt_index + 1024 <= buffer.len() {
+            let chunk = &buffer[decrypt_index .. decrypt_index+1024];
+            let (encrypted_chunk, _) = ChaCha20Poly1305IETF::encrypt(chunk, &key, Some(&nonce));
+            ChaCha20Poly1305IETF::increment_nonce(&mut nonce);
+            writer.write_all(&encrypted_chunk)?;
+            decrypt_index += 1024;
+        }
+
+        let remaining = buffer.len() % 1024;
+        if remaining > 0 {
+            for i in 0 .. remaining {
+                buffer[i] = buffer[decrypt_index + i];
+            }
+        }
+        buffer.resize(remaining, 0);
+    }
+
+    if buffer.len() > 0 {
+        let (last_encrypted_chunk, _) = ChaCha20Poly1305IETF::encrypt(&buffer, &key, Some(&nonce));
+        writer.write_all(&last_encrypted_chunk)?;
+    }
+
+    writer.flush()?;
+
+    Ok(())
+}
+
+
+pub (super) fn import(wallet: &Wallet, reader: Box<Read>, passphrase: &str) -> Result<(), WalletError> {
+    let mut reader = BufReader::new(reader);
+
+    let mut header_length_bytes: [u8; 2] = [0; 2];
+    let read_count = reader.read(&mut header_length_bytes)?;
+    if read_count < 2 {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Failed to read import header bytes"".to_string())));
+    }
+    let header_length = bytes_to_u16(&header_length_bytes) as usize;
+    if header_length < 48 {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Wallet import header not of sufficient minimal length"".to_string())));
+    }
+
+    let mut header_data: Vec<u8> = vec![0; header_length + 2];
+    header_data[0] = header_length_bytes[0];
+    header_data[1] = header_length_bytes[1];
+
+    let mut header_read_count = 0;
+    while header_read_count < header_length {
+        let read_count = reader.read(&mut header_data[2 + header_read_count..])?;
+        if read_count == 0 {
+            return Err(WalletError::CommonError(CommonError::InvalidStructure(""Header body length less than specified"".to_string())));
+        } else {
+            header_read_count += read_count;
+        }
+    }
+
+    let header = Header::deserialise(&header_data)?;
+    let mut key: [u8; ChaCha20Poly1305IETF::KEYBYTES] = [0; ChaCha20Poly1305IETF::KEYBYTES];
+    PwhashArgon2i13::derive_key(&mut key, passphrase.as_bytes(), &header.salt)?;
+    let mut nonce = header.nonce;
+
+    let mut encrypted_chunk: [u8; 1040] = [0; 1040];
+    let mut decrypted_buffer = Vec::new();
+
+    let mut has_more = true;
+    while has_more {
+        let mut chunk_read_count = 0;
+        while chunk_read_count < 1040 {
+            let read_count = reader.read(&mut encrypted_chunk[chunk_read_count..])?;
+            if read_count == 0 {
+                has_more = false;
+                break;
+            }
+            chunk_read_count += read_count;
+        }
+
+        if chunk_read_count == 0 {
+            continue;
+        }
+
+        decrypted_buffer.extend(&decrypt(&encrypted_chunk[0..chunk_read_count], &key, &nonce)?);
+        ChaCha20Poly1305IETF::increment_nonce(&mut nonce);
+
+        add_records_from_buffer(wallet, &mut decrypted_buffer)?;
+    }
+
+    add_records_from_buffer(wallet, &mut decrypted_buffer)?;
+    if decrypted_buffer.len() != 0 {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Failed to import all content"".to_string())));
+    }
+
+    Ok(())
+}
+
+
+
+fn add_records_from_buffer(wallet: &Wallet, buff: &mut Vec<u8>) -> Result<(), WalletError> {
+    let mut index = 0;
+    while index + 4 < buff.len() {
+        let item_length = bytes_to_u32(&buff[index..index+4]);
+        let end_index = index + 4 + item_length as usize;
+        if end_index > buff.len() {
+            break;
+        }
+
+        let record = deserialise_record(&buff[index+4..end_index])?;
+        wallet.add(&record.type_.unwrap(), &record.name, &record.value.unwrap(), &record.tags.unwrap())?;
+        index = end_index;
+    }
+
+    let remaining = buff.len() - index;
+    for i in 0 .. remaining {
+        buff[i] = buff[index + i];
+    }
+    buff.resize(remaining, 0);
+
+    Ok(())
+}
+
+
+fn sha256_hash(input: &[u8]) -> Result<Vec<u8>, CommonError> {
+    let mut hasher = Hash::new_context()?;
+    hasher.update(input)?;
+    Ok(hasher.finish()?)
+}
+
+
+fn serialise_record(record: WalletRecord, buffer: &mut Vec<u8>) -> Result<(), WalletError> {
+    let record_type = record.type_.unwrap();
+    let record_name = record.name;
+    let record_value = record.value.unwrap();
+    let record_tags = record.tags.unwrap();
+    let record_tags_json = serde_json::to_string(&record_tags)?;
+    let record_length = record_type.len() + record_name.len() + record_value.len() + record_tags_json.len() + 16;
+
+    buffer.extend(&u32_to_bytes(record_length as u32));
+    buffer.extend(&u32_to_bytes(record_type.len() as u32));
+    buffer.extend(record_type.as_bytes());
+    buffer.extend(&u32_to_bytes(record_name.len() as u32));
+    buffer.extend(record_name.as_bytes());
+    buffer.extend(&u32_to_bytes(record_value.len() as u32));
+    buffer.extend(record_value.as_bytes());
+    buffer.extend(&u32_to_bytes(record_tags_json.len() as u32));
+    buffer.extend(record_tags_json.as_bytes());
+
+    Ok(())
+}
+
+
+fn deserialise_record(mut buffer: &[u8]) -> Result<WalletRecord, WalletError> {
+    let expected_total_length = buffer.len();
+    let type_length = bytes_to_u32(&buffer[..4]) as usize;
+    if type_length + 16 > buffer.len() {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Insufficient serialised data length"".to_string())));
+    }
+    let type_ = String::from_utf8(buffer[4..4+type_length].to_owned())?;
+    buffer = &buffer[4+type_length..];
+
+    let name_length = bytes_to_u32(&buffer[..4]) as usize;
+    if name_length + 12 > buffer.len() {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Insufficient serialised data length"".to_string())));
+    }
+    let name = String::from_utf8(buffer[4..4+name_length].to_owned())?;
+    buffer = &buffer[4+name_length..];
+
+    let value_length = bytes_to_u32(&buffer[..4]) as usize;
+    if value_length + 8 > buffer.len() {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Insufficient serialised data length"".to_string())));
+    }
+    let value = String::from_utf8(buffer[4..4+value_length].to_owned())?;
+    buffer = &buffer[4+value_length..];
+
+    let tags_json_length = bytes_to_u32(&buffer[..4]) as usize;
+    if tags_json_length > buffer.len() {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Insufficient serialised data length"".to_string())));
+    }
+
+    let total_length = type_length + name_length + value_length + tags_json_length + 16;
+    if total_length != expected_total_length {
+        return Err(WalletError::CommonError(CommonError::InvalidStructure(""Lengths mismatch during record deserialisation"".to_string())));
+    }
+
+    let tags_json = String::from_utf8(buffer[4..4+tags_json_length].to_owned())?;
+    let tags: HashMap<String, String> = serde_json::from_str(&tags_json)?;
+
+    let wallet_record = WalletRecord::new(name,Some(type_), Some(value),Some(tags));
+    Ok(wallet_record)
+}
+
+
+fn u64_to_bytes(u: u64) -> [u8; 8] {
+    let u = u.to_be();
+    let res: [u8; 8] = unsafe { mem::transmute(u) };
+    res
+}
+
+fn u32_to_bytes(u: u32) -> [u8; 4] {
+    let u = u.to_be();
+    let res: [u8; 4] = unsafe { mem::transmute(u) };
+    res
+}
+
+fn u16_to_bytes(u: u16) -> [u8; 2] {
+    let u = u.to_be();
+    let res: [u8; 2] = unsafe { mem::transmute(u) };
+    res
+}
+
+fn bytes_to_u64(b: &[u8]) -> u64 {
+    let mut byte_array: [u8; 8] = [0; 8];
+    byte_array.clone_from_slice(&b[0..8]);
+    let res: u64 = unsafe { mem::transmute(byte_array) };
+    u64::from_be(res)
+}
+
+fn bytes_to_u32(b: &[u8]) -> u32 {
+    let mut byte_array: [u8; 4] = [0; 4];
+    byte_array.clone_from_slice(&b[0..4]);
+    let res: u32 = unsafe { mem::transmute(byte_array) };
+    u32::from_be(res)
+}
+
+fn bytes_to_u16(b: &[u8]) -> u16 {
+    let mut byte_array: [u8; 2] = [0; 2];
+    byte_array.clone_from_slice(&b[0..2]);
+    let res: u16 = unsafe { mem::transmute(byte_array) };
+    u16::from_be(res)
+}
+
+
+#[cfg(test)]
+mod tests {
+    use std;
+    use std::io;
+    use std::io::{Read, BufReader};
+    use std::env;
+    use std::collections::HashMap;
+    extern crate rand;
+    use self::rand::*;
+    use serde_json;
+
+    use services::wallet::storage::WalletStorageType;
+    use services::wallet::storage::default::SQLiteStorageType;
+    use services::wallet::wallet::{Keys, Wallet};
+    use services::wallet::encryption::{decrypt_merged, decrypt, encrypt_as_not_searchable};
+    use super::*;
+
+
+    fn _wallet_path() -> std::path::PathBuf {
+        let mut path = env::home_dir().unwrap();
+        path.push("".indy_client"");
+        path.push(""wallet"");
+        path.push(""test_wallet"");
+        path
+    }
+
+    fn _cleanup() {
+        if _wallet_path().exists() {
+            std::fs::remove_dir_all(_wallet_path()).unwrap();
+        }
+        std::fs::create_dir_all(_wallet_path()).unwrap();
+    }
+
+    fn _credentials() -> String {
+        r##""{""master_key"": ""AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=\n"", ""storage_credentials"": {}}}""##.to_string()
+    }
+
+    fn _create_wallet() -> Wallet {
+        let name = ""test_wallet"";
+        let pool_name = ""test_pool"";
+        let storage_type = SQLiteStorageType::new();
+        let master_key = _get_test_master_key();
+        storage_type.create_storage(""test_wallet"", None, """", &Keys::gen_keys(master_key)).unwrap();
+        let credentials = _credentials();
+        let storage = storage_type.open_storage(""test_wallet"", None, &credentials[..]).unwrap();
+
+        let keys = Keys::new(
+            decrypt_merged(
+                &storage.get_storage_metadata().unwrap(),
+                &master_key
+            ).unwrap()
+        ).unwrap();
+
+        Wallet::new(name, pool_name, storage, keys)
+    }
+
+    fn _get_test_master_key() -> [u8; 32] {
+        return [
+            1, 2, 3, 4, 5, 6, 7, 8,
+            1, 2, 3, 4, 5, 6, 7, 8,
+            1, 2, 3, 4, 5, 6, 7, 8,
+            1, 2, 3, 4, 5, 6, 7, 8
+        ];
+    }
+
+    fn _create_export_file() -> Box<io::Write> {
+        let path_str = ""/tmp/wallet/export_test"";",,2018-06-15 10:20:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/195007670,https://github.com/hyperledger/indy-sdk/pull/775#discussion_r195007670,vimmerru
https://github.com/hyperledger/indy-sdk/pull/768,https://github.com/hyperledger/indy-sdk/pull/768,We need to return InvalidState here. I suggest use similar macros like we use in api.rs of libindy,f4226c72e3e46380d06f90aa1ff7a769a9324c0d,2018-05-18 06:24:09,189172809,"@@ -1,227 +1,305 @@
 use libindy::ErrorCode;
 use libindy::ledger;
 use libindy::payments::IndyPaymentCallback;
+use services::*;
+use utils::types::*;
 use utils::rand;
+use utils::json_helper::{parse_operation_from_request, serialize_infos};
+use services::response_storage::*;
 
-use std::collections::VecDeque;
+use serde_json::{from_str, to_string};
+use std::collections::HashMap;
 use std::ffi::CStr;
 use std::ffi::CString;
 use std::os::raw::c_char;
-use std::sync::Mutex;
-
-#[macro_export]
-macro_rules! mocked_handler {
-    ($first_param_name: ident: $first_param_type: ty $(, $param_name: ident: $param_type: ty)*) => (
-        lazy_static! {
-          static ref INJECTIONS: Mutex<VecDeque<(ErrorCode, CString)>> = Default::default();
-        }
-
-        pub extern fn handle_mocked(cmd_handle: i32,
-                                    $first_param_name: $first_param_type,
-                                    $($param_name: $param_type,)*
-                                    cb: Option<IndyPaymentCallback>) -> ErrorCode {
-
-            let cb = cb.unwrap_or_else(|| {
-                panic!(""Null passed as callback!"")
-            });
-
-            if let Ok(mut injections) = INJECTIONS.lock() {
-                if let Some((err, res)) = injections.pop_front() {
-                    return (cb)(cmd_handle, err, res.as_ptr());
-                }
-            } else {
-                panic!(""Can't lock injections mutex"");
-            }
-
-            handle(cmd_handle, $first_param_name, $($param_name,)* cb)
-        }
-
-        pub fn inject_mock(err: ErrorCode, res: *const c_char) {
-            if let Ok(mut injections) = INJECTIONS.lock() {
-                injections.push_back((err, CString::from(unsafe { CStr::from_ptr(res) })))
-            } else {
-                panic!(""Can't lock injections mutex"");
-            }
-        }
-
-        pub fn clear_mocks() {
-            if let Ok(mut injections) = INJECTIONS.lock() {
-                injections.clear();
-            } else {
-                panic!(""Can't lock injections mutex"");
-            }
-        }
-    )
-}
 
 pub static PAYMENT_METHOD_NAME: &str = ""null"";
 
 pub mod create_payment_address {
     use super::*;
 
-    mocked_handler!(wallet_handle: i32, config: *const c_char);
-
-    fn handle(cmd_handle: i32, _wallet_handle: i32, _config: *const c_char, cb: IndyPaymentCallback) -> ErrorCode {
-        let res = CString::new(format!(""pay:null:{}"", rand::get_rand_string(15))).unwrap();
+    pub extern fn handle(cmd_handle: i32, _wallet_handle: i32, _config: *const c_char, cb: Option<IndyPaymentCallback>) -> ErrorCode {
+        let res = format!(""pay:null:{}"", rand::get_rand_string(15));
         let err = ErrorCode::Success;
-        (cb)(cmd_handle, err, res.as_ptr())
+        _process_callback(cmd_handle, err, res, cb)
     }
 }
 
 pub mod add_request_fees {
     use super::*;
 
-    mocked_handler!(wallet_handle: i32, submitter_did: *const c_char, req_json: *const c_char, inputs_json: *const c_char, outputs_json: *const c_char);
+    pub extern fn handle(cmd_handle: i32, _wallet_handle: i32, _submitter_did: *const c_char, req_json: *const c_char, inputs_json: *const c_char, outputs_json: *const c_char, cb: Option<IndyPaymentCallback>) -> ErrorCode {
+        let res = unsafe { CStr::from_ptr(req_json).to_str() }.unwrap();",,2018-05-22 10:23:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/189172809,https://github.com/hyperledger/indy-sdk/pull/768#discussion_r189172809,vimmerru
https://github.com/hyperledger/indy-sdk/pull/768,https://github.com/hyperledger/indy-sdk/pull/768,"Can we just use ""?"" operator? A lot of matches like this doesn't look really nice",f4226c72e3e46380d06f90aa1ff7a769a9324c0d,2018-05-18 06:26:17,189173080,"@@ -1,227 +1,305 @@
 use libindy::ErrorCode;
 use libindy::ledger;
 use libindy::payments::IndyPaymentCallback;
+use services::*;
+use utils::types::*;
 use utils::rand;
+use utils::json_helper::{parse_operation_from_request, serialize_infos};
+use services::response_storage::*;
 
-use std::collections::VecDeque;
+use serde_json::{from_str, to_string};
+use std::collections::HashMap;
 use std::ffi::CStr;
 use std::ffi::CString;
 use std::os::raw::c_char;
-use std::sync::Mutex;
-
-#[macro_export]
-macro_rules! mocked_handler {
-    ($first_param_name: ident: $first_param_type: ty $(, $param_name: ident: $param_type: ty)*) => (
-        lazy_static! {
-          static ref INJECTIONS: Mutex<VecDeque<(ErrorCode, CString)>> = Default::default();
-        }
-
-        pub extern fn handle_mocked(cmd_handle: i32,
-                                    $first_param_name: $first_param_type,
-                                    $($param_name: $param_type,)*
-                                    cb: Option<IndyPaymentCallback>) -> ErrorCode {
-
-            let cb = cb.unwrap_or_else(|| {
-                panic!(""Null passed as callback!"")
-            });
-
-            if let Ok(mut injections) = INJECTIONS.lock() {
-                if let Some((err, res)) = injections.pop_front() {
-                    return (cb)(cmd_handle, err, res.as_ptr());
-                }
-            } else {
-                panic!(""Can't lock injections mutex"");
-            }
-
-            handle(cmd_handle, $first_param_name, $($param_name,)* cb)
-        }
-
-        pub fn inject_mock(err: ErrorCode, res: *const c_char) {
-            if let Ok(mut injections) = INJECTIONS.lock() {
-                injections.push_back((err, CString::from(unsafe { CStr::from_ptr(res) })))
-            } else {
-                panic!(""Can't lock injections mutex"");
-            }
-        }
-
-        pub fn clear_mocks() {
-            if let Ok(mut injections) = INJECTIONS.lock() {
-                injections.clear();
-            } else {
-                panic!(""Can't lock injections mutex"");
-            }
-        }
-    )
-}
 
 pub static PAYMENT_METHOD_NAME: &str = ""null"";
 
 pub mod create_payment_address {
     use super::*;
 
-    mocked_handler!(wallet_handle: i32, config: *const c_char);
-
-    fn handle(cmd_handle: i32, _wallet_handle: i32, _config: *const c_char, cb: IndyPaymentCallback) -> ErrorCode {
-        let res = CString::new(format!(""pay:null:{}"", rand::get_rand_string(15))).unwrap();
+    pub extern fn handle(cmd_handle: i32, _wallet_handle: i32, _config: *const c_char, cb: Option<IndyPaymentCallback>) -> ErrorCode {
+        let res = format!(""pay:null:{}"", rand::get_rand_string(15));
         let err = ErrorCode::Success;
-        (cb)(cmd_handle, err, res.as_ptr())
+        _process_callback(cmd_handle, err, res, cb)
     }
 }
 
 pub mod add_request_fees {
     use super::*;
 
-    mocked_handler!(wallet_handle: i32, submitter_did: *const c_char, req_json: *const c_char, inputs_json: *const c_char, outputs_json: *const c_char);
+    pub extern fn handle(cmd_handle: i32, _wallet_handle: i32, _submitter_did: *const c_char, req_json: *const c_char, inputs_json: *const c_char, outputs_json: *const c_char, cb: Option<IndyPaymentCallback>) -> ErrorCode {
+        let res = unsafe { CStr::from_ptr(req_json).to_str() }.unwrap();
+        let inputs_json = unsafe { CStr::from_ptr(inputs_json).to_str() }.unwrap();
+        let outputs_json = unsafe { CStr::from_ptr(outputs_json).to_str() }.unwrap();
 
-    fn handle(cmd_handle: i32, _wallet_handle: i32, _submitter_did: *const c_char, req_json: *const c_char, _inputs_json: *const c_char, _outputs_json: *const c_char, cb: IndyPaymentCallback) -> ErrorCode {
-        let res = req_json;
-        let err = ErrorCode::Success;
-        (cb)(cmd_handle, err, res)
+        let inputs = from_str::<Vec<String>>(inputs_json);
+        let outputs = from_str::<Vec<UTXOOutput>>(outputs_json);
+
+        let (inputs, outputs) = match (inputs, outputs) {
+            (Ok(inputs), Ok(outputs)) => (inputs, outputs),
+            _ => { return ErrorCode::CommonInvalidStructure; }
+        };
+
+        let txn_type = match parse_operation_from_request(res) {",,2018-05-22 10:23:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/189173080,https://github.com/hyperledger/indy-sdk/pull/768#discussion_r189173080,vimmerru
https://github.com/hyperledger/indy-sdk/pull/768,https://github.com/hyperledger/indy-sdk/pull/768,It can be better to define domain entities and implement FromJson crate. Also it will cause simpler execution flow. Let's discuss a bit later.,f4226c72e3e46380d06f90aa1ff7a769a9324c0d,2018-05-18 06:27:49,189173308,"@@ -1,227 +1,305 @@
 use libindy::ErrorCode;
 use libindy::ledger;
 use libindy::payments::IndyPaymentCallback;
+use services::*;
+use utils::types::*;
 use utils::rand;
+use utils::json_helper::{parse_operation_from_request, serialize_infos};
+use services::response_storage::*;
 
-use std::collections::VecDeque;
+use serde_json::{from_str, to_string};
+use std::collections::HashMap;
 use std::ffi::CStr;
 use std::ffi::CString;
 use std::os::raw::c_char;
-use std::sync::Mutex;
-
-#[macro_export]
-macro_rules! mocked_handler {
-    ($first_param_name: ident: $first_param_type: ty $(, $param_name: ident: $param_type: ty)*) => (
-        lazy_static! {
-          static ref INJECTIONS: Mutex<VecDeque<(ErrorCode, CString)>> = Default::default();
-        }
-
-        pub extern fn handle_mocked(cmd_handle: i32,
-                                    $first_param_name: $first_param_type,
-                                    $($param_name: $param_type,)*
-                                    cb: Option<IndyPaymentCallback>) -> ErrorCode {
-
-            let cb = cb.unwrap_or_else(|| {
-                panic!(""Null passed as callback!"")
-            });
-
-            if let Ok(mut injections) = INJECTIONS.lock() {
-                if let Some((err, res)) = injections.pop_front() {
-                    return (cb)(cmd_handle, err, res.as_ptr());
-                }
-            } else {
-                panic!(""Can't lock injections mutex"");
-            }
-
-            handle(cmd_handle, $first_param_name, $($param_name,)* cb)
-        }
-
-        pub fn inject_mock(err: ErrorCode, res: *const c_char) {
-            if let Ok(mut injections) = INJECTIONS.lock() {
-                injections.push_back((err, CString::from(unsafe { CStr::from_ptr(res) })))
-            } else {
-                panic!(""Can't lock injections mutex"");
-            }
-        }
-
-        pub fn clear_mocks() {
-            if let Ok(mut injections) = INJECTIONS.lock() {
-                injections.clear();
-            } else {
-                panic!(""Can't lock injections mutex"");
-            }
-        }
-    )
-}
 
 pub static PAYMENT_METHOD_NAME: &str = ""null"";
 
 pub mod create_payment_address {
     use super::*;
 
-    mocked_handler!(wallet_handle: i32, config: *const c_char);
-
-    fn handle(cmd_handle: i32, _wallet_handle: i32, _config: *const c_char, cb: IndyPaymentCallback) -> ErrorCode {
-        let res = CString::new(format!(""pay:null:{}"", rand::get_rand_string(15))).unwrap();
+    pub extern fn handle(cmd_handle: i32, _wallet_handle: i32, _config: *const c_char, cb: Option<IndyPaymentCallback>) -> ErrorCode {
+        let res = format!(""pay:null:{}"", rand::get_rand_string(15));
         let err = ErrorCode::Success;
-        (cb)(cmd_handle, err, res.as_ptr())
+        _process_callback(cmd_handle, err, res, cb)
     }
 }
 
 pub mod add_request_fees {
     use super::*;
 
-    mocked_handler!(wallet_handle: i32, submitter_did: *const c_char, req_json: *const c_char, inputs_json: *const c_char, outputs_json: *const c_char);
+    pub extern fn handle(cmd_handle: i32, _wallet_handle: i32, _submitter_did: *const c_char, req_json: *const c_char, inputs_json: *const c_char, outputs_json: *const c_char, cb: Option<IndyPaymentCallback>) -> ErrorCode {
+        let res = unsafe { CStr::from_ptr(req_json).to_str() }.unwrap();
+        let inputs_json = unsafe { CStr::from_ptr(inputs_json).to_str() }.unwrap();
+        let outputs_json = unsafe { CStr::from_ptr(outputs_json).to_str() }.unwrap();
 
-    fn handle(cmd_handle: i32, _wallet_handle: i32, _submitter_did: *const c_char, req_json: *const c_char, _inputs_json: *const c_char, _outputs_json: *const c_char, cb: IndyPaymentCallback) -> ErrorCode {
-        let res = req_json;
-        let err = ErrorCode::Success;
-        (cb)(cmd_handle, err, res)
+        let inputs = from_str::<Vec<String>>(inputs_json);
+        let outputs = from_str::<Vec<UTXOOutput>>(outputs_json);",,2018-05-22 10:23:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/189173308,https://github.com/hyperledger/indy-sdk/pull/768#discussion_r189173308,vimmerru
https://github.com/hyperledger/indy-sdk/pull/766,https://github.com/hyperledger/indy-sdk/pull/766,What purpose of this file? Right now it seems like duplicate of `libindy/ci/ubuntu.dockerfile`,69ca3627c68fa5c210d020875c33ed9f5ccf7e78,2018-05-17 08:13:27,188872361,"@@ -0,0 +1,30 @@
+FROM ubuntu:16.04",,2018-07-05 16:28:10,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/188872361,https://github.com/hyperledger/indy-sdk/pull/766#discussion_r188872361,jovfer
https://github.com/hyperledger/indy-sdk/pull/766,https://github.com/hyperledger/indy-sdk/pull/766,I suggest to temporary change `indy-crypto` dependence below to your git branch. It will allow to run full CI process for all platforms.,69ca3627c68fa5c210d020875c33ed9f5ccf7e78,2018-05-17 08:15:48,188872940,"@@ -20,8 +20,7 @@ path = ""src/lib.rs""
 crate-type = [""staticlib"",""rlib"", ""dylib""]
 
 [features]
-default = [""bn_openssl"", ""box_sodium"", ""sealedbox_sodium"", ""base58_rust_base58"", ""xsalsa20_sodium"", ""pair_amcl"", ""hash_openssl"", ""local_nodes_pool"", ""revocation_tests""]
-bn_openssl = [""openssl"", ""int_traits""]
+default = [""box_sodium"", ""sealedbox_sodium"", ""base58_rust_base58"", ""xsalsa20_sodium"", ""pair_amcl"", ""hash_openssl"", ""local_nodes_pool"", ""revocation_tests""]",,2018-07-05 16:28:10,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/188872940,https://github.com/hyperledger/indy-sdk/pull/766#discussion_r188872940,jovfer
https://github.com/hyperledger/indy-sdk/pull/766,https://github.com/hyperledger/indy-sdk/pull/766,So you want me to point to my repo for this pull request then submit another PR that undoes it once the PR for Indy-crypto is pulled?,69ca3627c68fa5c210d020875c33ed9f5ccf7e78,2018-05-17 11:56:27,188931375,"@@ -20,8 +20,7 @@ path = ""src/lib.rs""
 crate-type = [""staticlib"",""rlib"", ""dylib""]
 
 [features]
-default = [""bn_openssl"", ""box_sodium"", ""sealedbox_sodium"", ""base58_rust_base58"", ""xsalsa20_sodium"", ""pair_amcl"", ""hash_openssl"", ""local_nodes_pool"", ""revocation_tests""]
-bn_openssl = [""openssl"", ""int_traits""]
+default = [""box_sodium"", ""sealedbox_sodium"", ""base58_rust_base58"", ""xsalsa20_sodium"", ""pair_amcl"", ""hash_openssl"", ""local_nodes_pool"", ""revocation_tests""]",,2018-07-05 16:28:10,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/188931375,https://github.com/hyperledger/indy-sdk/pull/766#discussion_r188931375,mikelodder7
https://github.com/hyperledger/indy-sdk/pull/766,https://github.com/hyperledger/indy-sdk/pull/766,"I suggest the next sequence:
1) temporary point your repo in this PR
2) finalize changes in sdk and crypto PRs
3) merge crypto
4) update this PR to new master (or even release?) version of crypto
5) merge this PR",69ca3627c68fa5c210d020875c33ed9f5ccf7e78,2018-05-17 12:07:30,188933756,"@@ -20,8 +20,7 @@ path = ""src/lib.rs""
 crate-type = [""staticlib"",""rlib"", ""dylib""]
 
 [features]
-default = [""bn_openssl"", ""box_sodium"", ""sealedbox_sodium"", ""base58_rust_base58"", ""xsalsa20_sodium"", ""pair_amcl"", ""hash_openssl"", ""local_nodes_pool"", ""revocation_tests""]
-bn_openssl = [""openssl"", ""int_traits""]
+default = [""box_sodium"", ""sealedbox_sodium"", ""base58_rust_base58"", ""xsalsa20_sodium"", ""pair_amcl"", ""hash_openssl"", ""local_nodes_pool"", ""revocation_tests""]",,2018-07-05 16:28:10,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/188933756,https://github.com/hyperledger/indy-sdk/pull/766#discussion_r188933756,jovfer
https://github.com/hyperledger/indy-sdk/pull/747,https://github.com/hyperledger/indy-sdk/pull/747,"@stevengubler @ashcherbakov is it script for running old, python-based Agent for getting started?",b5b9455006a58b29445be7f75b110e0746046e00,2018-06-04 07:18:20,192644835,"@@ -0,0 +1,29 @@
+#!/bin/bash
+LOGS_DIR=/home/indy/logs
+
+mkdir -p $LOGS_DIR
+
+startagent () {
+    local NAME=$1
+    local PORT=$2
+    echo Starting agent \""$NAME\"" on port $PORT
+    python3 ""/usr/local/lib/python3.5/dist-packages/indy_client/test/agent/$NAME.py"" --port $PORT > $LOG_DIR/$NAME.log",10,2018-06-04 07:18:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192644835,https://github.com/hyperledger/indy-sdk/pull/747#discussion_r192644835,jovfer
https://github.com/hyperledger/indy-sdk/pull/747,https://github.com/hyperledger/indy-sdk/pull/747,"Yes, this is old deprecated agents. 
And BTW a similar Docker images already exist: https://github.com/hyperledger/indy-node/blob/master/environment/docker/pool/StartIndyAgents.md",b5b9455006a58b29445be7f75b110e0746046e00,2018-06-04 07:24:24,192646137,"@@ -0,0 +1,29 @@
+#!/bin/bash
+LOGS_DIR=/home/indy/logs
+
+mkdir -p $LOGS_DIR
+
+startagent () {
+    local NAME=$1
+    local PORT=$2
+    echo Starting agent \""$NAME\"" on port $PORT
+    python3 ""/usr/local/lib/python3.5/dist-packages/indy_client/test/agent/$NAME.py"" --port $PORT > $LOG_DIR/$NAME.log",10,2018-06-04 07:24:24,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192646137,https://github.com/hyperledger/indy-sdk/pull/747#discussion_r192646137,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/745,https://github.com/hyperledger/indy-sdk/pull/745,"We plan to add the following new error codes related to payments:

```// Unknown payment method was given
PaymentUnknownMethodError = 700,

// No method were scraped from inputs/outputs or more than one were scraped
PaymentIncompatibleMethodsError = 701,

// Insufficient funds on inputs
PaymentInsufficientFundsError = 702,```

Note that for some situation existing codes can be used:

- For some bad structured jsons you can use ComminInvalidStructure
- If crypto key is not found in the wallet WalletNotFoundError",17bd59e714c58d446ff05f32f4e217aa95983848,2018-05-11 16:23:20,187664405,"@@ -149,4 +149,10 @@ pub enum ErrorCode
 
     //Information passed to libindy is incorrect
     IncorrectTransactionInformationError = 702,
+",,2018-05-14 07:15:46,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/187664405,https://github.com/hyperledger/indy-sdk/pull/745#discussion_r187664405,vimmerru
https://github.com/hyperledger/indy-sdk/pull/745,https://github.com/hyperledger/indy-sdk/pull/745,"We need ""Payment"" prefix for error names. Also add comment about errors group.",17bd59e714c58d446ff05f32f4e217aa95983848,2018-05-11 16:24:10,187664603,"@@ -149,4 +149,10 @@ pub enum ErrorCode
 
     //Information passed to libindy is incorrect
     IncorrectTransactionInformationError = 702,
+
+    //Insufficient funds on inputs
+    InsufficientFundsError = 703,
+
+    //No key for this payment address in wallet
+    NoPaymentAddressKeyError = 704,",,2018-05-14 07:15:46,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/187664603,https://github.com/hyperledger/indy-sdk/pull/745#discussion_r187664603,vimmerru
https://github.com/hyperledger/indy-sdk/pull/745,https://github.com/hyperledger/indy-sdk/pull/745,"//Insufficient funds on inputs

should be 

// Insufficient funds on inputs",17bd59e714c58d446ff05f32f4e217aa95983848,2018-05-11 16:24:26,187664672,"@@ -149,4 +149,10 @@ pub enum ErrorCode
 
     //Information passed to libindy is incorrect
     IncorrectTransactionInformationError = 702,
+
+    //Insufficient funds on inputs",,2018-05-14 07:15:46,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/187664672,https://github.com/hyperledger/indy-sdk/pull/745#discussion_r187664672,vimmerru
https://github.com/hyperledger/indy-sdk/pull/745,https://github.com/hyperledger/indy-sdk/pull/745,Seems we need to remove this?,17bd59e714c58d446ff05f32f4e217aa95983848,2018-05-11 17:54:26,187687378,"@@ -241,7 +241,17 @@
 	/**
 	 * Information passed to libindy is incorrect
 	 */",,2018-05-14 07:15:46,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/187687378,https://github.com/hyperledger/indy-sdk/pull/745#discussion_r187687378,vimmerru
https://github.com/hyperledger/indy-sdk/pull/745,https://github.com/hyperledger/indy-sdk/pull/745,Seems you need to update java wrapper too,17bd59e714c58d446ff05f32f4e217aa95983848,2018-05-11 17:55:05,187687610,"@@ -241,7 +241,17 @@
 	/**
 	 * Information passed to libindy is incorrect
 	 */
-	IncorrectTransactionInformationError(702)
+	IncorrectTransactionInformationError(702),
+
+	/**
+	 * Insufficient funds on inputs
+	 */
+	InsufficientFundsError(703),
+
+	/**
+	 * No key for this payment address in wallet
+	 */
+	NoPaymentAddressKeyError(704),",,2018-05-14 07:15:46,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/187687610,https://github.com/hyperledger/indy-sdk/pull/745#discussion_r187687610,vimmerru
https://github.com/hyperledger/indy-sdk/pull/736,https://github.com/hyperledger/indy-sdk/pull/736,In the next PR we should allow None outputs here.,abda89c0d6a3f657b2bdc835865662ede3e239ee,2018-05-10 10:19:18,187292975,"@@ -1058,24 +1054,46 @@ pub mod sign_multi_command {
     }
 }
 
+fn set_request_fees(request: &mut String, wallet_handle: i32, submitter_did: &str, fees_inputs: &Option<Vec<&str>>, fees_outputs: &Option<Vec<String>>) -> Result<(), ()> {
+    if let (&Some(ref inputs), &Some(ref outputs)) = (fees_inputs, fees_outputs) {",289,2018-05-10 10:19:19,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/187292975,https://github.com/hyperledger/indy-sdk/pull/736#discussion_r187292975,jovfer
https://github.com/hyperledger/indy-sdk/pull/729,https://github.com/hyperledger/indy-sdk/pull/729,Why we need absolute link here? I suggest to change it to relative. I plat to move designs to different folder soon. It will make this link invalid.,142d4c1799d39a1649ebc48eb604e57afb5b95ef,2018-05-08 08:23:46,186651004,"@@ -67,11 +67,11 @@ DKMS architecture and DPKI provides the following major benefits:
 
 As a general rule, DKMS requirements are a derivation of CKMS requirements, adjusted for the lack of centralized authorities or systems for key management operations. Evernym’s DKMS team and subcontractors performed an extensive analysis of the applicability of conventional CKMS requirements to DKMS using [NIST Special Publication 800-130: A Framework for Designing Cryptographic Key Management Systems](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-130.pdf). For a summary of the results, see:
 
-* [Evernym HSHQDC-17-C-00018 - DKMS Requirements Spreadsheet Based On NIST 800-130](https://github.com/hyperledger/indy-sdk/blob/master/doc/dkms/DKMS Requirements Spreadsheet Based On NIST 800-130.pdf)
+* [Evernym HSHQDC-17-C-00018 - DKMS Requirements Spreadsheet Based On NIST 800-130](https://github.com/hyperledger/indy-sdk/blob/master/doc/dkms/DKMS%20Requirements%20Spreadsheet%20Based%20On%20NIST%20800-130.pdf)",5,2018-05-08 08:23:46,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186651004,https://github.com/hyperledger/indy-sdk/pull/729#discussion_r186651004,vimmerru
https://github.com/hyperledger/indy-sdk/pull/729,https://github.com/hyperledger/indy-sdk/pull/729,Relative link can be better,142d4c1799d39a1649ebc48eb604e57afb5b95ef,2018-05-08 08:24:11,186651123,"@@ -67,11 +67,11 @@ DKMS architecture and DPKI provides the following major benefits:
 
 As a general rule, DKMS requirements are a derivation of CKMS requirements, adjusted for the lack of centralized authorities or systems for key management operations. Evernym’s DKMS team and subcontractors performed an extensive analysis of the applicability of conventional CKMS requirements to DKMS using [NIST Special Publication 800-130: A Framework for Designing Cryptographic Key Management Systems](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-130.pdf). For a summary of the results, see:
 
-* [Evernym HSHQDC-17-C-00018 - DKMS Requirements Spreadsheet Based On NIST 800-130](https://github.com/hyperledger/indy-sdk/blob/master/doc/dkms/DKMS Requirements Spreadsheet Based On NIST 800-130.pdf)
+* [Evernym HSHQDC-17-C-00018 - DKMS Requirements Spreadsheet Based On NIST 800-130](https://github.com/hyperledger/indy-sdk/blob/master/doc/dkms/DKMS%20Requirements%20Spreadsheet%20Based%20On%20NIST%20800-130.pdf)
 
-* [Evernym HSHQDC-17-C-00018 - DKMS Requirements Text Based on NIST 800-130](https://github.com/hyperledger/indy-sdk/blob/master/doc/dkms/DKMS Requirements Text Based on NIST 800-130.pdf)
+* [Evernym HSHQDC-17-C-00018 - DKMS Requirements Text Based on NIST 800-130](https://github.com/hyperledger/indy-sdk/blob/master/doc/dkms/DKMS%20Requirements%20Text%20Based%20on%20NIST%20800-130.pdf)",8,2018-05-08 08:24:12,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186651123,https://github.com/hyperledger/indy-sdk/pull/729#discussion_r186651123,vimmerru
https://github.com/hyperledger/indy-sdk/pull/729,https://github.com/hyperledger/indy-sdk/pull/729,Relative link can be better,142d4c1799d39a1649ebc48eb604e57afb5b95ef,2018-05-08 08:24:17,186651145,"@@ -67,11 +67,11 @@ DKMS architecture and DPKI provides the following major benefits:
 
 As a general rule, DKMS requirements are a derivation of CKMS requirements, adjusted for the lack of centralized authorities or systems for key management operations. Evernym’s DKMS team and subcontractors performed an extensive analysis of the applicability of conventional CKMS requirements to DKMS using [NIST Special Publication 800-130: A Framework for Designing Cryptographic Key Management Systems](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-130.pdf). For a summary of the results, see:
 
-* [Evernym HSHQDC-17-C-00018 - DKMS Requirements Spreadsheet Based On NIST 800-130](https://github.com/hyperledger/indy-sdk/blob/master/doc/dkms/DKMS Requirements Spreadsheet Based On NIST 800-130.pdf)
+* [Evernym HSHQDC-17-C-00018 - DKMS Requirements Spreadsheet Based On NIST 800-130](https://github.com/hyperledger/indy-sdk/blob/master/doc/dkms/DKMS%20Requirements%20Spreadsheet%20Based%20On%20NIST%20800-130.pdf)
 
-* [Evernym HSHQDC-17-C-00018 - DKMS Requirements Text Based on NIST 800-130](https://github.com/hyperledger/indy-sdk/blob/master/doc/dkms/DKMS Requirements Text Based on NIST 800-130.pdf)
+* [Evernym HSHQDC-17-C-00018 - DKMS Requirements Text Based on NIST 800-130](https://github.com/hyperledger/indy-sdk/blob/master/doc/dkms/DKMS%20Requirements%20Text%20Based%20on%20NIST%20800-130.pdf)
 
-* [Evernym HSHQDC-17-C-00018 - DKMS Requirements Report - 30 June 2017](https://github.com/hyperledger/indy-sdk/blob/master/doc/dkms/DKMS Requirements Report - 30 June 2017.pdf)
+* [Evernym HSHQDC-17-C-00018 - DKMS Requirements Report - 30 June 2017](https://github.com/hyperledger/indy-sdk/blob/master/doc/dkms/DKMS%20Requirements%20Report%20-%2030%20June%202017.pdf)",11,2018-05-08 08:24:17,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186651145,https://github.com/hyperledger/indy-sdk/pull/729#discussion_r186651145,vimmerru
https://github.com/hyperledger/indy-sdk/pull/729,https://github.com/hyperledger/indy-sdk/pull/729,Relative link can be better,142d4c1799d39a1649ebc48eb604e57afb5b95ef,2018-05-08 08:24:37,186651215,"@@ -33,5 +33,5 @@ These methods are not exclusive and should be combined with key rotation and rev
 
 1. [Design and architecture](DKMS%20Design%20and%20Architecture%20V3.md)
 2. **Public Registry for Agent Authorization Policy**. An identity owner create a policy on the ledger that defines its agents and their authorizations. 
-   Agents while acting on the behalf of the identity owner need to prove that they are authorised. [More details](https://github.com/hyperledger/indy-sdk/blob/master/doc/dkms/Agent Authorization Policy.pdf)  
+   Agents while acting on the behalf of the identity owner need to prove that they are authorised. [More details](https://github.com/hyperledger/indy-sdk/blob/master/doc/dkms/Agent%20Authorization%20Policy.pdf)  ",5,2018-05-08 08:24:37,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186651215,https://github.com/hyperledger/indy-sdk/pull/729#discussion_r186651215,vimmerru
https://github.com/hyperledger/indy-sdk/pull/726,https://github.com/hyperledger/indy-sdk/pull/726,I am not comfortable with implicit checking for item availability. ,f56eb333847708da45d7d0065fc779e9297e08c7,2018-05-08 14:30:40,186748071,"@@ -196,7 +197,10 @@ pub enum WalletStorageError {
 
 impl From<rusqlite::Error> for WalletStorageError {
     fn from(err: rusqlite::Error) -> WalletStorageError {
-        WalletStorageError::IOError(format!(""IO error during storage operation: {}"", err.description()))
+        match &err {",13,2018-05-08 14:30:50,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186748071,https://github.com/hyperledger/indy-sdk/pull/726#discussion_r186748071,vimmerru
https://github.com/hyperledger/indy-sdk/pull/719,https://github.com/hyperledger/indy-sdk/pull/719,Just one minor request. Struct names must be camel case without underscores. ,64ce0e39d23295d0054760add4e61e9abf7aa938,2018-05-04 15:41:50,186122322,"@@ -0,0 +1,105 @@
+extern crate sodiumoxide;
+
+use errors::common::CommonError;
+
+use self::sodiumoxide::crypto::aead::chacha20poly1305_ietf;
+use sodiumoxide::crypto::auth::hmacsha256;
+use utils::byte_array::_clone_into_array;
+
+pub struct ChaCha20_Poly1305_IETF {",,2018-05-07 12:15:34,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186122322,https://github.com/hyperledger/indy-sdk/pull/719#discussion_r186122322,vimmerru
https://github.com/hyperledger/indy-sdk/pull/719,https://github.com/hyperledger/indy-sdk/pull/719,Renamed.,64ce0e39d23295d0054760add4e61e9abf7aa938,2018-05-07 12:16:41,186405428,"@@ -0,0 +1,105 @@
+extern crate sodiumoxide;
+
+use errors::common::CommonError;
+
+use self::sodiumoxide::crypto::aead::chacha20poly1305_ietf;
+use sodiumoxide::crypto::auth::hmacsha256;
+use utils::byte_array::_clone_into_array;
+
+pub struct ChaCha20_Poly1305_IETF {",,2018-05-07 12:16:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186405428,https://github.com/hyperledger/indy-sdk/pull/719#discussion_r186405428,dkulic
https://github.com/hyperledger/indy-sdk/pull/718,https://github.com/hyperledger/indy-sdk/pull/718,rename this module to init,a40e75760d8c7a6392a91ea587d975236ca7537c,2018-05-04 14:03:39,186092036,"@@ -0,0 +1,179 @@
+extern crate libc;
+extern crate rand;
+
+#[macro_use]
+extern crate lazy_static;
+
+mod libindy;
+
+#[macro_use]
+mod payment_method;
+mod payment_register;
+mod utils;
+
+use libindy::ErrorCode;
+
+use std::os::raw::c_char;
+
+pub mod register_payment_method {",18,2018-05-04 14:03:40,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186092036,https://github.com/hyperledger/indy-sdk/pull/718#discussion_r186092036,vimmerru
https://github.com/hyperledger/indy-sdk/pull/718,https://github.com/hyperledger/indy-sdk/pull/718,Do we need to remove this TODO?,a40e75760d8c7a6392a91ea587d975236ca7537c,2018-05-04 14:06:10,186092787,"@@ -0,0 +1,60 @@
+use super::ErrorCode;
+use std::os::raw::c_char;
+
+extern {
+    #[no_mangle]
+    pub fn indy_register_payment_method(
+        command_handle: i32,
+        payment_method: *const c_char,
+//TODO: replace cb to IndyPaymentCallback",9,2018-05-04 14:06:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186092787,https://github.com/hyperledger/indy-sdk/pull/718#discussion_r186092787,vimmerru
https://github.com/hyperledger/indy-sdk/pull/717,https://github.com/hyperledger/indy-sdk/pull/717,We need to merge with the latest code changes,dd1e6647e6d5c7df0bf2fd73dcb17b29f85e97e3,2018-05-04 15:16:39,186115127,"@@ -98,4 +144,37 @@ pub mod exit_command {
         trace!(""execute << {:?}"", res);
         res
     }
+}
+
+#[cfg(test)]
+pub mod tests {
+    use super::*;
+
+    pub const NULL_PAYMENT_METHOD: &'static str = ""null_payment"";",,2018-05-07 13:04:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186115127,https://github.com/hyperledger/indy-sdk/pull/717#discussion_r186115127,vimmerru
https://github.com/hyperledger/indy-sdk/pull/714,https://github.com/hyperledger/indy-sdk/pull/714,"You also should update docker files ubuntu and amazon placed here libindy/ci. 
After that, on your local machine, you can check your steps inside docker.",9b5001fd71fd792a137fe4e69187d5f580818dc1,2018-06-01 13:36:55,192397990,"@@ -234,6 +234,7 @@ def linuxTesting(file, env_name, network_name) {
 
         sh ""cp libindy/target/debug/libindy.so wrappers/java/lib""",2,2018-06-01 18:29:49,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192397990,https://github.com/hyperledger/indy-sdk/pull/714#discussion_r192397990,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/714,https://github.com/hyperledger/indy-sdk/pull/714,"I added in ubuntu.dockerfile the following lines:
```
RUN curl -sL https://deb.nodesource.com/setup_8.x | bash -
RUN apt-get install -y nodejs
RUN npm install -g node-gyp
```
I am getting ```missing script: cp-include```  on executing this command ```npm run cp-include```",9b5001fd71fd792a137fe4e69187d5f580818dc1,2018-06-01 13:41:26,192399263,"@@ -338,6 +341,21 @@ def linuxPythonTesting(env_name, network_name, testEnv) {
     }
 }
 
+def linuxNodejsTesting(env_name, network_name, testEnv) {
+    unstash name: ""LibindyNodejsSO${env_name}""
+    dir('wrappers/nodejs') {
+        testEnv.inside(""--network=${network_name}"") {
+            echo ""${env_name} Libindy Test: Test nodejs wrapper""
+
+            sh '''
+                npm run cp-include",,2018-06-01 18:29:49,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/192399263,https://github.com/hyperledger/indy-sdk/pull/714#discussion_r192399263,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/706,https://github.com/hyperledger/indy-sdk/pull/706,I am not sure that commits signing is required for Hyperledger. ,17efba483e4f16c4e1391564b8104b3155513ed3,2018-05-07 15:13:44,186454312,"@@ -0,0 +1,61 @@
+# Signing commits",1,2018-07-18 15:18:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186454312,https://github.com/hyperledger/indy-sdk/pull/706#discussion_r186454312,vimmerru
https://github.com/hyperledger/indy-sdk/pull/706,https://github.com/hyperledger/indy-sdk/pull/706,Commit signing is required for Hyperledger `git commit -s`,17efba483e4f16c4e1391564b8104b3155513ed3,2018-05-07 22:45:03,186572637,"@@ -0,0 +1,61 @@
+# Signing commits",1,2018-07-18 15:18:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186572637,https://github.com/hyperledger/indy-sdk/pull/706#discussion_r186572637,tkuhrt
https://github.com/hyperledger/indy-sdk/pull/706,https://github.com/hyperledger/indy-sdk/pull/706,"Ah...I see, what you mean. I have never used the `-S` option on my commits",17efba483e4f16c4e1391564b8104b3155513ed3,2018-05-07 22:46:31,186572930,"@@ -0,0 +1,61 @@
+# Signing commits",1,2018-07-18 15:18:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186572930,https://github.com/hyperledger/indy-sdk/pull/706#discussion_r186572930,tkuhrt
https://github.com/hyperledger/indy-sdk/pull/706,https://github.com/hyperledger/indy-sdk/pull/706,"Yes, ```-s``` is required, but we don't need all of this GPG-related staff. So i suggest to remove it from instruction to don't scare possible contributors.",17efba483e4f16c4e1391564b8104b3155513ed3,2018-05-08 08:51:03,186658018,"@@ -0,0 +1,61 @@
+# Signing commits",1,2018-07-18 15:18:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186658018,https://github.com/hyperledger/indy-sdk/pull/706#discussion_r186658018,vimmerru
https://github.com/hyperledger/indy-sdk/pull/706,https://github.com/hyperledger/indy-sdk/pull/706,"I just removed everything related to GPG signatures. Thanks for the clarification, I had heard from a variety of different people different opinions on what was actually required. ",17efba483e4f16c4e1391564b8104b3155513ed3,2018-05-08 15:27:08,186768873,"@@ -0,0 +1,61 @@
+# Signing commits",1,2018-07-18 15:18:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186768873,https://github.com/hyperledger/indy-sdk/pull/706#discussion_r186768873,michaeldboyd
https://github.com/hyperledger/indy-sdk/pull/706,https://github.com/hyperledger/indy-sdk/pull/706,"Should this be `git log`? When I use `git-log`, I am told `command not found`",17efba483e4f16c4e1391564b8104b3155513ed3,2018-05-08 15:47:16,186775898,"@@ -0,0 +1,61 @@
+# Signing commits
+
+If you are here because you forgot to sign your commits, fear not. Check out [how to sign previous commits](#how-to-sign-previous-commits)
+
+We use developer certificate of origin (DCO) in all hyperledger repositories, so to get your pull requests accepted, you must certify your commits by signing off on each commit. Using a GPG signature is the best way to certify that your commits have come directly from you.
+
+Below we have made a simple walkthrough to do this, with the link to Github's documentation at the bottom.
+
+### Get a GPG key:
+
+1. Check to see if you already have a key: `$ gpg --list-secret-keys --keyid-format LONG`
+
+1. If no key is found, create a new one. If you already have a gpg key, skip to the next step.
+
+  - `$ gpg --gen-key`
+  - Follow the prompts, using the your email that is connected with Github. Using a key size of 4096 is recommended
+  - Once the key's been created, list the new key as in step one
+
+
+## Configure your key with Git:
+  -  The terminal should print something like this:
+
+
+    /Users/hubot/.gnupg/secring.gpg
+    ------------------------------------
+    sec   4096R/<<<<key-id>>>> 2016-03-10 [expires: 2017-03-10]
+    uid                          Hubot
+    ssb   4096R/42B317FD4BA89E7A 2016-03-10
+
+
+  - Export the key using the key-id above: `$ gpg --armor --export <key-id>`
+  - Copy the terminal output beginning with `-----BEGIN PGP PUBLIC KEY BLOCK-----` and ending with `-----END PGP PUBLIC KEY BLOCK-----`.
+  - Add the key to github by navigating to github.com -> settings -> ssh and gpg keys
+  - Add the key to your local installation of git: `git config --global user.signingkey <key-id>`
+  - To add your GPG key to your bash profile, paste the text below:
+      `echo 'export GPG_TTY=$(tty)' >> ~/.bashrc`
+  - [optional, but recommended] To configure your Git client to sign commits by default for  this local repository, run `git config commit.gpgsign true`. If you do this, you no longer need to add the `-S` flag to commits, but you will still need to add the `-s` flag to sign the commit body.
+  - [optional] you can also set up a GPG agent to manage your password so you don't need to enter it in after each commit.
+
+
+## Signing your current commit
+  - `$ git commit -S -s -m ""your commit message""`
+  - To see if your commits have been signed off, run `$ git log --show-signature`
+  - If you need to re-sign the most current commit, use `$ git commit --amend --no-edit -S -s`.
+
+The `-S` flag signs your commit with GPG. the `-s` flag signs the commit message with your name and email. Both are required for the DCO check to succeed.
+
+## How to Sign Previous Commits
+   1. Use `git-log --show-signature` to see which commits need to be signed.",,2018-07-18 15:18:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186775898,https://github.com/hyperledger/indy-sdk/pull/706#discussion_r186775898,tkuhrt
https://github.com/hyperledger/indy-sdk/pull/706,https://github.com/hyperledger/indy-sdk/pull/706,@tkuhrt that was a typo. Fixed,17efba483e4f16c4e1391564b8104b3155513ed3,2018-05-09 19:50:27,187155832,"@@ -0,0 +1,61 @@
+# Signing commits
+
+If you are here because you forgot to sign your commits, fear not. Check out [how to sign previous commits](#how-to-sign-previous-commits)
+
+We use developer certificate of origin (DCO) in all hyperledger repositories, so to get your pull requests accepted, you must certify your commits by signing off on each commit. Using a GPG signature is the best way to certify that your commits have come directly from you.
+
+Below we have made a simple walkthrough to do this, with the link to Github's documentation at the bottom.
+
+### Get a GPG key:
+
+1. Check to see if you already have a key: `$ gpg --list-secret-keys --keyid-format LONG`
+
+1. If no key is found, create a new one. If you already have a gpg key, skip to the next step.
+
+  - `$ gpg --gen-key`
+  - Follow the prompts, using the your email that is connected with Github. Using a key size of 4096 is recommended
+  - Once the key's been created, list the new key as in step one
+
+
+## Configure your key with Git:
+  -  The terminal should print something like this:
+
+
+    /Users/hubot/.gnupg/secring.gpg
+    ------------------------------------
+    sec   4096R/<<<<key-id>>>> 2016-03-10 [expires: 2017-03-10]
+    uid                          Hubot
+    ssb   4096R/42B317FD4BA89E7A 2016-03-10
+
+
+  - Export the key using the key-id above: `$ gpg --armor --export <key-id>`
+  - Copy the terminal output beginning with `-----BEGIN PGP PUBLIC KEY BLOCK-----` and ending with `-----END PGP PUBLIC KEY BLOCK-----`.
+  - Add the key to github by navigating to github.com -> settings -> ssh and gpg keys
+  - Add the key to your local installation of git: `git config --global user.signingkey <key-id>`
+  - To add your GPG key to your bash profile, paste the text below:
+      `echo 'export GPG_TTY=$(tty)' >> ~/.bashrc`
+  - [optional, but recommended] To configure your Git client to sign commits by default for  this local repository, run `git config commit.gpgsign true`. If you do this, you no longer need to add the `-S` flag to commits, but you will still need to add the `-s` flag to sign the commit body.
+  - [optional] you can also set up a GPG agent to manage your password so you don't need to enter it in after each commit.
+
+
+## Signing your current commit
+  - `$ git commit -S -s -m ""your commit message""`
+  - To see if your commits have been signed off, run `$ git log --show-signature`
+  - If you need to re-sign the most current commit, use `$ git commit --amend --no-edit -S -s`.
+
+The `-S` flag signs your commit with GPG. the `-s` flag signs the commit message with your name and email. Both are required for the DCO check to succeed.
+
+## How to Sign Previous Commits
+   1. Use `git-log --show-signature` to see which commits need to be signed.",,2018-07-18 15:18:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/187155832,https://github.com/hyperledger/indy-sdk/pull/706#discussion_r187155832,michaeldboyd
https://github.com/hyperledger/indy-sdk/pull/706,https://github.com/hyperledger/indy-sdk/pull/706,Could you remove this file? It blocks merging.,17efba483e4f16c4e1391564b8104b3155513ed3,2018-06-08 16:14:56,194108979,"@@ -30,4 +30,4 @@ RUN apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88 \
 ",1,2018-07-18 15:18:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194108979,https://github.com/hyperledger/indy-sdk/pull/706#discussion_r194108979,vimmerru
https://github.com/hyperledger/indy-sdk/pull/706,https://github.com/hyperledger/indy-sdk/pull/706,Could you remove this file from PR? It blocks merging.,17efba483e4f16c4e1391564b8104b3155513ed3,2018-06-08 16:15:11,194109048,"@@ -2,9 +2,44 @@
  ""cells"": [
   {",,2018-07-18 15:18:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/194109048,https://github.com/hyperledger/indy-sdk/pull/706#discussion_r194109048,vimmerru
https://github.com/hyperledger/indy-sdk/pull/706,https://github.com/hyperledger/indy-sdk/pull/706,"Yes, I will remove right now. ",17efba483e4f16c4e1391564b8104b3155513ed3,2018-06-20 03:40:24,196640204,"@@ -2,9 +2,44 @@
  ""cells"": [
   {",,2018-07-18 15:18:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/196640204,https://github.com/hyperledger/indy-sdk/pull/706#discussion_r196640204,michaeldboyd
https://github.com/hyperledger/indy-sdk/pull/701,https://github.com/hyperledger/indy-sdk/pull/701,Seems like misprint,2220d1faa5a5c6e1b65fcbdb963f6f240aab377f,2018-05-03 15:45:01,185847011,"@@ -1,4 +1,4 @@
-# Setup Indy SDK build environment for Ubuntu based distro (Ubuntu 16.04)
+etup Indy SDK build environment for Ubuntu based distro (Ubuntu 16.04)",,2018-05-04 07:21:05,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/185847011,https://github.com/hyperledger/indy-sdk/pull/701#discussion_r185847011,jovfer
https://github.com/hyperledger/indy-sdk/pull/701,https://github.com/hyperledger/indy-sdk/pull/701,I'll fix that now.,2220d1faa5a5c6e1b65fcbdb963f6f240aab377f,2018-05-03 16:16:10,185857469,"@@ -1,4 +1,4 @@
-# Setup Indy SDK build environment for Ubuntu based distro (Ubuntu 16.04)
+etup Indy SDK build environment for Ubuntu based distro (Ubuntu 16.04)",,2018-05-04 07:21:05,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/185857469,https://github.com/hyperledger/indy-sdk/pull/701#discussion_r185857469,michaeldboyd
https://github.com/hyperledger/indy-sdk/pull/699,https://github.com/hyperledger/indy-sdk/pull/699,"I like the idea of reducing boilerplate, but we need to follow some rules here:

1. Each function should have a single responsibility. 
2. Each function should have obvious responsibility and a good name
3. We shouldn't expose private functions
4. Private functions should have a name started with '_'",f4a8ec8849559103362c8a645c2c55539ce82442,2018-05-03 09:17:36,185738487,"@@ -43,22 +43,60 @@ impl CryptoService {
         }
     }
 
-    pub fn create_key(&self, key_info: &KeyInfo) -> Result<Key, CryptoError> {
-        let crypto_type_name = key_info.crypto_type
-            .as_ref()
-            .map(String::as_str)
-            .unwrap_or(DEFAULT_CRYPTO_TYPE);
+    pub fn get_crypto_type_name<'a>(crypto_type: &'a Option<String>) -> (&'a str) {",9,2018-05-03 13:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/185738487,https://github.com/hyperledger/indy-sdk/pull/699#discussion_r185738487,vimmerru
https://github.com/hyperledger/indy-sdk/pull/699,https://github.com/hyperledger/indy-sdk/pull/699,"> pub fn get_crypto_type_name<'a>(crypto_type: &'a Option<String>) -> (&'a str)

It seems like non-obvious function and i suggest to remove it",f4a8ec8849559103362c8a645c2c55539ce82442,2018-05-03 09:18:07,185738597,"@@ -43,22 +43,60 @@ impl CryptoService {
         }
     }
 
-    pub fn create_key(&self, key_info: &KeyInfo) -> Result<Key, CryptoError> {
-        let crypto_type_name = key_info.crypto_type
-            .as_ref()
-            .map(String::as_str)
-            .unwrap_or(DEFAULT_CRYPTO_TYPE);
+    pub fn get_crypto_type_name<'a>(crypto_type: &'a Option<String>) -> (&'a str) {",9,2018-05-03 13:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/185738597,https://github.com/hyperledger/indy-sdk/pull/699#discussion_r185738597,vimmerru
https://github.com/hyperledger/indy-sdk/pull/699,https://github.com/hyperledger/indy-sdk/pull/699,"> pub fn get_crypto_type_name_from_verkey<'a>(verkey: &'a String) -> (&'a str)
> pub fn get_verkey_and_crypto_type_name_from_verkey<'a>(verkey: &'a str) -> (&'a str, &'a str) {

1. It is really hard to understand what this public functions perform without context. In fact we perform parsing of verkey in fully qualified form to parts. So i suggest make one function (we can make it public if you want).

2. We don't need to expose String type here as we use only slice


```
pub fn parse_fully_qualified_verkey<'a>(verkey: &'a str) -> (&'a str, &'a str)
```

can be better, also we need to document result at least",f4a8ec8849559103362c8a645c2c55539ce82442,2018-05-03 09:24:18,185740127,"@@ -43,22 +43,60 @@ impl CryptoService {
         }
     }
 
-    pub fn create_key(&self, key_info: &KeyInfo) -> Result<Key, CryptoError> {
-        let crypto_type_name = key_info.crypto_type
-            .as_ref()
-            .map(String::as_str)
-            .unwrap_or(DEFAULT_CRYPTO_TYPE);
+    pub fn get_crypto_type_name<'a>(crypto_type: &'a Option<String>) -> (&'a str) {
+        crypto_type.as_ref().map(String::as_str).unwrap_or(DEFAULT_CRYPTO_TYPE)
+    }
+
+    pub fn get_crypto_type_name_from_verkey<'a>(verkey: &'a String) -> (&'a str) {",13,2018-05-03 13:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/185740127,https://github.com/hyperledger/indy-sdk/pull/699#discussion_r185740127,vimmerru
https://github.com/hyperledger/indy-sdk/pull/699,https://github.com/hyperledger/indy-sdk/pull/699,"> pub fn get_crypto_name_and_keypair<'a>(&self, crypto_type: &'a Option<String>,
>                                               seed: &'a Option<String>) -> Result<(&'a str, Vec<u8>, Vec<u8>), CryptoError>

This function mix a lot of responsibilities. So i suggest to remove this. but we can update ```get_crypto_type``` to cover the most of boilerplate without introducing single responsibility problems
",f4a8ec8849559103362c8a645c2c55539ce82442,2018-05-03 09:30:10,185741510,"@@ -43,22 +43,60 @@ impl CryptoService {
         }
     }
 
-    pub fn create_key(&self, key_info: &KeyInfo) -> Result<Key, CryptoError> {
-        let crypto_type_name = key_info.crypto_type
-            .as_ref()
-            .map(String::as_str)
-            .unwrap_or(DEFAULT_CRYPTO_TYPE);
+    pub fn get_crypto_type_name<'a>(crypto_type: &'a Option<String>) -> (&'a str) {
+        crypto_type.as_ref().map(String::as_str).unwrap_or(DEFAULT_CRYPTO_TYPE)
+    }
+
+    pub fn get_crypto_type_name_from_verkey<'a>(verkey: &'a String) -> (&'a str) {
+        if verkey.contains("":"") {
+            let splits: Vec<&str> = verkey.split("":"").collect();
+            splits[1]
+        } else {
+            DEFAULT_CRYPTO_TYPE
+        }
+    }
+
+    pub fn get_verkey_and_crypto_type_name_from_verkey<'a>(verkey: &'a str) -> (&'a str, &'a str) {
+        if verkey.contains("":"") {
+            let splits: Vec<&str> = verkey.split("":"").collect();
+            (splits[0], splits[1])
+        } else {
+            (verkey, DEFAULT_CRYPTO_TYPE)
+        }
+    }
+
+    pub fn is_crypto_type_supported(&self, crypto_type_name: &str) -> bool {
+        self.crypto_types.contains_key(crypto_type_name)
+    }
 
-        if !self.crypto_types.contains_key(crypto_type_name) {
+    fn get_crypto_type(&self, crypto_type_name: &str) -> &Box<CryptoType> {
+        self.crypto_types.get(crypto_type_name).unwrap()
+    }
+
+    pub fn get_crypto_name_and_keypair<'a>(&self, crypto_type: &'a Option<String>,",40,2018-05-03 13:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/185741510,https://github.com/hyperledger/indy-sdk/pull/699#discussion_r185741510,vimmerru
https://github.com/hyperledger/indy-sdk/pull/699,https://github.com/hyperledger/indy-sdk/pull/699,- All unwraps must be checked on the same function level,f4a8ec8849559103362c8a645c2c55539ce82442,2018-05-03 09:30:59,185741710,"@@ -43,22 +43,60 @@ impl CryptoService {
         }
     }
 
-    pub fn create_key(&self, key_info: &KeyInfo) -> Result<Key, CryptoError> {
-        let crypto_type_name = key_info.crypto_type
-            .as_ref()
-            .map(String::as_str)
-            .unwrap_or(DEFAULT_CRYPTO_TYPE);
+    pub fn get_crypto_type_name<'a>(crypto_type: &'a Option<String>) -> (&'a str) {
+        crypto_type.as_ref().map(String::as_str).unwrap_or(DEFAULT_CRYPTO_TYPE)
+    }
+
+    pub fn get_crypto_type_name_from_verkey<'a>(verkey: &'a String) -> (&'a str) {
+        if verkey.contains("":"") {
+            let splits: Vec<&str> = verkey.split("":"").collect();
+            splits[1]
+        } else {
+            DEFAULT_CRYPTO_TYPE
+        }
+    }
+
+    pub fn get_verkey_and_crypto_type_name_from_verkey<'a>(verkey: &'a str) -> (&'a str, &'a str) {
+        if verkey.contains("":"") {
+            let splits: Vec<&str> = verkey.split("":"").collect();
+            (splits[0], splits[1])
+        } else {
+            (verkey, DEFAULT_CRYPTO_TYPE)
+        }
+    }
+
+    pub fn is_crypto_type_supported(&self, crypto_type_name: &str) -> bool {
+        self.crypto_types.contains_key(crypto_type_name)
+    }
 
-        if !self.crypto_types.contains_key(crypto_type_name) {
+    fn get_crypto_type(&self, crypto_type_name: &str) -> &Box<CryptoType> {",36,2018-05-03 13:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/185741710,https://github.com/hyperledger/indy-sdk/pull/699#discussion_r185741710,vimmerru
https://github.com/hyperledger/indy-sdk/pull/699,https://github.com/hyperledger/indy-sdk/pull/699,It will be much better if this function will take responsibility of checking that crypto type is supported and return Result. It will allow to reduce boilerplate without introducing of functions like ```get_crypto_name_and_keypair```,f4a8ec8849559103362c8a645c2c55539ce82442,2018-05-03 09:36:41,185743068,"@@ -43,22 +43,60 @@ impl CryptoService {
         }
     }
 
-    pub fn create_key(&self, key_info: &KeyInfo) -> Result<Key, CryptoError> {
-        let crypto_type_name = key_info.crypto_type
-            .as_ref()
-            .map(String::as_str)
-            .unwrap_or(DEFAULT_CRYPTO_TYPE);
+    pub fn get_crypto_type_name<'a>(crypto_type: &'a Option<String>) -> (&'a str) {
+        crypto_type.as_ref().map(String::as_str).unwrap_or(DEFAULT_CRYPTO_TYPE)
+    }
+
+    pub fn get_crypto_type_name_from_verkey<'a>(verkey: &'a String) -> (&'a str) {
+        if verkey.contains("":"") {
+            let splits: Vec<&str> = verkey.split("":"").collect();
+            splits[1]
+        } else {
+            DEFAULT_CRYPTO_TYPE
+        }
+    }
+
+    pub fn get_verkey_and_crypto_type_name_from_verkey<'a>(verkey: &'a str) -> (&'a str, &'a str) {
+        if verkey.contains("":"") {
+            let splits: Vec<&str> = verkey.split("":"").collect();
+            (splits[0], splits[1])
+        } else {
+            (verkey, DEFAULT_CRYPTO_TYPE)
+        }
+    }
+
+    pub fn is_crypto_type_supported(&self, crypto_type_name: &str) -> bool {
+        self.crypto_types.contains_key(crypto_type_name)
+    }
 
-        if !self.crypto_types.contains_key(crypto_type_name) {
+    fn get_crypto_type(&self, crypto_type_name: &str) -> &Box<CryptoType> {",36,2018-05-03 13:54:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/185743068,https://github.com/hyperledger/indy-sdk/pull/699#discussion_r185743068,vimmerru
https://github.com/hyperledger/indy-sdk/pull/697,https://github.com/hyperledger/indy-sdk/pull/697,Should we specify a payment method in this command?,dde6101c295759094cd01b5b805ad3532be015fa,2018-05-07 08:46:16,186363229,"@@ -0,0 +1,141 @@
+# Payment Interface
+
+This design proposes the list of commands to Indy CLI to handle payments.
+
+## Goals and ideas
+
+* Indy CLI should provide ability to perform the main payments operations:
+  * Creation of payment address
+  * Listing of payment addresses
+  * Getting list of UTXO for payment address
+  * Sending payment transaction
+  * Adding fees to transactions
+  * Getting transactions fees amount
+* Abstraction level should correspond to Indy SDK. For example, don't hide UTXO abstraction. In the future we can add
+  new commands to increase abstractions level.
+
+## New CLI commands
+
+### Create payment address
+
+Create payment address for specific payment method in the wallet
+
+```indy-cli
+indy> payment-address create payment_method=<payment-method> seed=[<seed>]
+```
+
+Returns:
+
+* Success or error message
+
+### List payment addresses
+
+List payment addresses for specific payment method in the wallet
+
+```indy-cli
+indy> payment-address list",,2018-05-08 08:29:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186363229,https://github.com/hyperledger/indy-sdk/pull/697#discussion_r186363229,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/697,https://github.com/hyperledger/indy-sdk/pull/697,"No, This command returns addresses for all payment methods. Each address in fully qualified form and also table that will be printed will contain payment method column",dde6101c295759094cd01b5b805ad3532be015fa,2018-05-07 08:48:27,186363681,"@@ -0,0 +1,141 @@
+# Payment Interface
+
+This design proposes the list of commands to Indy CLI to handle payments.
+
+## Goals and ideas
+
+* Indy CLI should provide ability to perform the main payments operations:
+  * Creation of payment address
+  * Listing of payment addresses
+  * Getting list of UTXO for payment address
+  * Sending payment transaction
+  * Adding fees to transactions
+  * Getting transactions fees amount
+* Abstraction level should correspond to Indy SDK. For example, don't hide UTXO abstraction. In the future we can add
+  new commands to increase abstractions level.
+
+## New CLI commands
+
+### Create payment address
+
+Create payment address for specific payment method in the wallet
+
+```indy-cli
+indy> payment-address create payment_method=<payment-method> seed=[<seed>]
+```
+
+Returns:
+
+* Success or error message
+
+### List payment addresses
+
+List payment addresses for specific payment method in the wallet
+
+```indy-cli
+indy> payment-address list",,2018-05-08 08:29:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186363681,https://github.com/hyperledger/indy-sdk/pull/697#discussion_r186363681,vimmerru
https://github.com/hyperledger/indy-sdk/pull/697,https://github.com/hyperledger/indy-sdk/pull/697,Missing [,dde6101c295759094cd01b5b805ad3532be015fa,2018-05-07 08:48:38,186363717,"@@ -0,0 +1,141 @@
+# Payment Interface
+
+This design proposes the list of commands to Indy CLI to handle payments.
+
+## Goals and ideas
+
+* Indy CLI should provide ability to perform the main payments operations:
+  * Creation of payment address
+  * Listing of payment addresses
+  * Getting list of UTXO for payment address
+  * Sending payment transaction
+  * Adding fees to transactions
+  * Getting transactions fees amount
+* Abstraction level should correspond to Indy SDK. For example, don't hide UTXO abstraction. In the future we can add
+  new commands to increase abstractions level.
+
+## New CLI commands
+
+### Create payment address
+
+Create payment address for specific payment method in the wallet
+
+```indy-cli
+indy> payment-address create payment_method=<payment-method> seed=[<seed>]
+```
+
+Returns:
+
+* Success or error message
+
+### List payment addresses
+
+List payment addresses for specific payment method in the wallet
+
+```indy-cli
+indy> payment-address list
+```
+
+Returns:
+
+* Table with columns: Payment Address, Payment Method
+
+### Send GET_UTXO request
+
+Send request to get list of UTXO for specified payment addresses
+
+```indy-cli
+indy> ledger get-utxo payment_address=<payment-address>
+```
+
+Returns:
+
+* Table with columns: Input, Amount, Extra
+
+### Send PAYMENT transaction
+
+Send payment transaction
+
+```indy-cli
+indy> ledger payment inputs=<utxo-1>,..,<utxo-n>] outputs=<pay-addr-0>:<amount>:<extra>,..,<pay-addr-n>:<amount>:<extra>",,2018-05-08 08:29:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186363717,https://github.com/hyperledger/indy-sdk/pull/697#discussion_r186363717,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/697,https://github.com/hyperledger/indy-sdk/pull/697,Should we specify how utxos are referenced here?,dde6101c295759094cd01b5b805ad3532be015fa,2018-05-07 08:49:00,186363806,"@@ -0,0 +1,141 @@
+# Payment Interface
+
+This design proposes the list of commands to Indy CLI to handle payments.
+
+## Goals and ideas
+
+* Indy CLI should provide ability to perform the main payments operations:
+  * Creation of payment address
+  * Listing of payment addresses
+  * Getting list of UTXO for payment address
+  * Sending payment transaction
+  * Adding fees to transactions
+  * Getting transactions fees amount
+* Abstraction level should correspond to Indy SDK. For example, don't hide UTXO abstraction. In the future we can add
+  new commands to increase abstractions level.
+
+## New CLI commands
+
+### Create payment address
+
+Create payment address for specific payment method in the wallet
+
+```indy-cli
+indy> payment-address create payment_method=<payment-method> seed=[<seed>]
+```
+
+Returns:
+
+* Success or error message
+
+### List payment addresses
+
+List payment addresses for specific payment method in the wallet
+
+```indy-cli
+indy> payment-address list
+```
+
+Returns:
+
+* Table with columns: Payment Address, Payment Method
+
+### Send GET_UTXO request
+
+Send request to get list of UTXO for specified payment addresses
+
+```indy-cli
+indy> ledger get-utxo payment_address=<payment-address>
+```
+
+Returns:
+
+* Table with columns: Input, Amount, Extra
+
+### Send PAYMENT transaction
+
+Send payment transaction
+
+```indy-cli
+indy> ledger payment inputs=<utxo-1>,..,<utxo-n>] outputs=<pay-addr-0>:<amount>:<extra>,..,<pay-addr-n>:<amount>:<extra>",,2018-05-08 08:29:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186363806,https://github.com/hyperledger/indy-sdk/pull/697#discussion_r186363806,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/697,https://github.com/hyperledger/indy-sdk/pull/697,Why we need inputs and outputs here?,dde6101c295759094cd01b5b805ad3532be015fa,2018-05-07 08:49:53,186364014,"@@ -0,0 +1,141 @@
+# Payment Interface
+
+This design proposes the list of commands to Indy CLI to handle payments.
+
+## Goals and ideas
+
+* Indy CLI should provide ability to perform the main payments operations:
+  * Creation of payment address
+  * Listing of payment addresses
+  * Getting list of UTXO for payment address
+  * Sending payment transaction
+  * Adding fees to transactions
+  * Getting transactions fees amount
+* Abstraction level should correspond to Indy SDK. For example, don't hide UTXO abstraction. In the future we can add
+  new commands to increase abstractions level.
+
+## New CLI commands
+
+### Create payment address
+
+Create payment address for specific payment method in the wallet
+
+```indy-cli
+indy> payment-address create payment_method=<payment-method> seed=[<seed>]
+```
+
+Returns:
+
+* Success or error message
+
+### List payment addresses
+
+List payment addresses for specific payment method in the wallet
+
+```indy-cli
+indy> payment-address list
+```
+
+Returns:
+
+* Table with columns: Payment Address, Payment Method
+
+### Send GET_UTXO request
+
+Send request to get list of UTXO for specified payment addresses
+
+```indy-cli
+indy> ledger get-utxo payment_address=<payment-address>
+```
+
+Returns:
+
+* Table with columns: Input, Amount, Extra
+
+### Send PAYMENT transaction
+
+Send payment transaction
+
+```indy-cli
+indy> ledger payment inputs=<utxo-1>,..,<utxo-n>] outputs=<pay-addr-0>:<amount>:<extra>,..,<pay-addr-n>:<amount>:<extra>
+```
+
+Returns:
+
+* Success or error message
+
+### Send GET_FEES request
+
+Send request to get fees amount for ledger transactions
+
+```indy-cli
+indy> ledger payment inputs=<utxo-1>,..,<utxo-n>] outputs=<pay-addr-0>:<amount>:<extra>,..,<pay-addr-n>:<amount>:<extra>",,2018-05-08 08:29:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186364014,https://github.com/hyperledger/indy-sdk/pull/697#discussion_r186364014,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/697,https://github.com/hyperledger/indy-sdk/pull/697,Should we specify how utxos are referenced here?,dde6101c295759094cd01b5b805ad3532be015fa,2018-05-07 08:50:57,186364304,"@@ -0,0 +1,141 @@
+# Payment Interface
+
+This design proposes the list of commands to Indy CLI to handle payments.
+
+## Goals and ideas
+
+* Indy CLI should provide ability to perform the main payments operations:
+  * Creation of payment address
+  * Listing of payment addresses
+  * Getting list of UTXO for payment address
+  * Sending payment transaction
+  * Adding fees to transactions
+  * Getting transactions fees amount
+* Abstraction level should correspond to Indy SDK. For example, don't hide UTXO abstraction. In the future we can add
+  new commands to increase abstractions level.
+
+## New CLI commands
+
+### Create payment address
+
+Create payment address for specific payment method in the wallet
+
+```indy-cli
+indy> payment-address create payment_method=<payment-method> seed=[<seed>]
+```
+
+Returns:
+
+* Success or error message
+
+### List payment addresses
+
+List payment addresses for specific payment method in the wallet
+
+```indy-cli
+indy> payment-address list
+```
+
+Returns:
+
+* Table with columns: Payment Address, Payment Method
+
+### Send GET_UTXO request
+
+Send request to get list of UTXO for specified payment addresses
+
+```indy-cli
+indy> ledger get-utxo payment_address=<payment-address>
+```
+
+Returns:
+
+* Table with columns: Input, Amount, Extra
+
+### Send PAYMENT transaction
+
+Send payment transaction
+
+```indy-cli
+indy> ledger payment inputs=<utxo-1>,..,<utxo-n>] outputs=<pay-addr-0>:<amount>:<extra>,..,<pay-addr-n>:<amount>:<extra>
+```
+
+Returns:
+
+* Success or error message
+
+### Send GET_FEES request
+
+Send request to get fees amount for ledger transactions
+
+```indy-cli
+indy> ledger payment inputs=<utxo-1>,..,<utxo-n>] outputs=<pay-addr-0>:<amount>:<extra>,..,<pay-addr-n>:<amount>:<extra>
+```
+
+Returns:
+
+* Table with columns: Transaction, Amount
+
+### Prepare MINT transaction
+
+Prepare MINT transaction as json.
+
+```indy-cli
+indy> ledger mint-prepare outputs=<pay-addr-0>:<amount-0>:<extra-0>,..,<pay-addr-n>:<amount-n>:<extra-n>
+```
+
+Returns:
+
+* MINT transaction json
+
+Sending MINT process is the following:
+
+* Steward 1 calls ```ledger mint-prepare```
+* Signs it by calling ```ledger sign-multi```
+* Sends the request json to Steward 2 (now we have 1 signature)
+* Second Steward signs it by calling ```ledger sign-multi```
+* Sends the request json to Steward 3 (now we have 2 signature)
+* All Stewards sign the request
+* The latest Steward calls ```ledger send-custom``` to send request signed by all Stewards
+
+### Prepare SET_FEES transaction
+
+Prepare SET_FEES transaction as json.
+
+```indy-cli
+indy> ledger set-fees-prepare fees=<txn-type-1>:<amount-1>,...,<txn-type-n>:<amount-n>
+```
+
+Returns:
+
+* SET_FEES transaction json
+
+Sending SET_FEES process is the following:
+
+* Steward 1 calls ```ledger set-fees-prepare```
+* Signs it by calling ```ledger sign-multi```
+* Sends the request json to Steward 2 (now we have 1 signature)
+* Second Steward signs it by calling ```ledger sign-multi```
+* Sends the request json to Steward 3 (now we have 2 signature)
+* All Stewards sign the request
+* The latest Steward calls ```ledger send-custom``` to send request signed by all Stewards
+
+### Sign the transaction (for multi-sign case)
+
+Add signature (for multi-sign case) by current DID to transaction json.
+
+```indy-cli
+indy> ledger sign-multi txn=<txn-json>
+```
+
+Returns:
+
+* Transaction json with added signature
+
+## Existing commands update
+
+All commands to send domain transactions require new optional params to add transactions fees:
+
+```indy-cli
+[fees_inputs=<utxo-1>,..,<utxo-n>] [fees_outputs=<pay-addr-0>:<amount>:<extra>,..,<pay-addr-n>:<amount>:<extra>]",142,2018-05-08 08:29:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186364304,https://github.com/hyperledger/indy-sdk/pull/697#discussion_r186364304,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/697,https://github.com/hyperledger/indy-sdk/pull/697,"This seems unnecessarily clunky. Why not just have a 'plugins' directory? If the plugin has been put there, then run it at startup. Likewise the plugin init function could be standardized to ""plugin_init"" so that it doesn't have to be specified. This is a pain to type in and autocomplete isn't much help.",dde6101c295759094cd01b5b805ad3532be015fa,2018-05-07 12:55:52,186414290,"@@ -0,0 +1,42 @@
+# CLI plugins
+
+This design proposes the way to support plugins in Indy CLI.
+
+## Goals and ideas
+
+* Libindy now allows to plug 2 type of functionality for the moment:
+  * Custom wallet storage
+  * Custom payment methods
+* To register plugins libindy provides API calls that allows to register C-handlers for each type of plugged operation
+* In current vision libraries that implement libindy plugins should provide some kind of public ""init"" function that will call internally libindy API to register handlers. So registration of plugin is just calling of C function.
+* ""Init"" function should have just one param. It is callback that returns libindy error code.
+* CLI can provide command line option that will allow to point the name of plugin dynamic library and the name of ""init"" function. On start CLI will call dlopen (or LoadLibrary) with right options to perform names linking. CLI will lookup for init function by name and call it.
+* Also we need to provide CLI command to load plugin similar way
+
+## Linking
+
+![Linking](./cli-plugins.svg)
+
+## Command line param to load plugins on start
+
+```bash
+indy-cli --plugins <lib-1-name>:<init-func-1-name>,...,<lib-n-name>:<init-func-n-name>",23,2018-05-08 08:29:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186414290,https://github.com/hyperledger/indy-sdk/pull/697#discussion_r186414290,steptan
https://github.com/hyperledger/indy-sdk/pull/697,https://github.com/hyperledger/indy-sdk/pull/697,I added corresponded note,dde6101c295759094cd01b5b805ad3532be015fa,2018-05-08 08:06:46,186647118,"@@ -0,0 +1,141 @@
+# Payment Interface
+
+This design proposes the list of commands to Indy CLI to handle payments.
+
+## Goals and ideas
+
+* Indy CLI should provide ability to perform the main payments operations:
+  * Creation of payment address
+  * Listing of payment addresses
+  * Getting list of UTXO for payment address
+  * Sending payment transaction
+  * Adding fees to transactions
+  * Getting transactions fees amount
+* Abstraction level should correspond to Indy SDK. For example, don't hide UTXO abstraction. In the future we can add
+  new commands to increase abstractions level.
+
+## New CLI commands
+
+### Create payment address
+
+Create payment address for specific payment method in the wallet
+
+```indy-cli
+indy> payment-address create payment_method=<payment-method> seed=[<seed>]
+```
+
+Returns:
+
+* Success or error message
+
+### List payment addresses
+
+List payment addresses for specific payment method in the wallet
+
+```indy-cli
+indy> payment-address list
+```
+
+Returns:
+
+* Table with columns: Payment Address, Payment Method
+
+### Send GET_UTXO request
+
+Send request to get list of UTXO for specified payment addresses
+
+```indy-cli
+indy> ledger get-utxo payment_address=<payment-address>
+```
+
+Returns:
+
+* Table with columns: Input, Amount, Extra
+
+### Send PAYMENT transaction
+
+Send payment transaction
+
+```indy-cli
+indy> ledger payment inputs=<utxo-1>,..,<utxo-n>] outputs=<pay-addr-0>:<amount>:<extra>,..,<pay-addr-n>:<amount>:<extra>
+```
+
+Returns:
+
+* Success or error message
+
+### Send GET_FEES request
+
+Send request to get fees amount for ledger transactions
+
+```indy-cli
+indy> ledger payment inputs=<utxo-1>,..,<utxo-n>] outputs=<pay-addr-0>:<amount>:<extra>,..,<pay-addr-n>:<amount>:<extra>
+```
+
+Returns:
+
+* Table with columns: Transaction, Amount
+
+### Prepare MINT transaction
+
+Prepare MINT transaction as json.
+
+```indy-cli
+indy> ledger mint-prepare outputs=<pay-addr-0>:<amount-0>:<extra-0>,..,<pay-addr-n>:<amount-n>:<extra-n>
+```
+
+Returns:
+
+* MINT transaction json
+
+Sending MINT process is the following:
+
+* Steward 1 calls ```ledger mint-prepare```
+* Signs it by calling ```ledger sign-multi```
+* Sends the request json to Steward 2 (now we have 1 signature)
+* Second Steward signs it by calling ```ledger sign-multi```
+* Sends the request json to Steward 3 (now we have 2 signature)
+* All Stewards sign the request
+* The latest Steward calls ```ledger send-custom``` to send request signed by all Stewards
+
+### Prepare SET_FEES transaction
+
+Prepare SET_FEES transaction as json.
+
+```indy-cli
+indy> ledger set-fees-prepare fees=<txn-type-1>:<amount-1>,...,<txn-type-n>:<amount-n>
+```
+
+Returns:
+
+* SET_FEES transaction json
+
+Sending SET_FEES process is the following:
+
+* Steward 1 calls ```ledger set-fees-prepare```
+* Signs it by calling ```ledger sign-multi```
+* Sends the request json to Steward 2 (now we have 1 signature)
+* Second Steward signs it by calling ```ledger sign-multi```
+* Sends the request json to Steward 3 (now we have 2 signature)
+* All Stewards sign the request
+* The latest Steward calls ```ledger send-custom``` to send request signed by all Stewards
+
+### Sign the transaction (for multi-sign case)
+
+Add signature (for multi-sign case) by current DID to transaction json.
+
+```indy-cli
+indy> ledger sign-multi txn=<txn-json>
+```
+
+Returns:
+
+* Transaction json with added signature
+
+## Existing commands update
+
+All commands to send domain transactions require new optional params to add transactions fees:
+
+```indy-cli
+[fees_inputs=<utxo-1>,..,<utxo-n>] [fees_outputs=<pay-addr-0>:<amount>:<extra>,..,<pay-addr-n>:<amount>:<extra>]",142,2018-05-08 08:29:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186647118,https://github.com/hyperledger/indy-sdk/pull/697#discussion_r186647118,vimmerru
https://github.com/hyperledger/indy-sdk/pull/697,https://github.com/hyperledger/indy-sdk/pull/697,"I still prefer this explicit approach. The reasons:
- It is possible to implement this behavior by simple shell script
- indy-cli will be wrapped to sovrin-cli tool by shell script. So this complexity will be hidden
- 'plugins' directory opens a lot of cross-platform questions
- We don't see all use cases for now. So we can change it a bit later. ",dde6101c295759094cd01b5b805ad3532be015fa,2018-05-08 08:10:18,186647918,"@@ -0,0 +1,42 @@
+# CLI plugins
+
+This design proposes the way to support plugins in Indy CLI.
+
+## Goals and ideas
+
+* Libindy now allows to plug 2 type of functionality for the moment:
+  * Custom wallet storage
+  * Custom payment methods
+* To register plugins libindy provides API calls that allows to register C-handlers for each type of plugged operation
+* In current vision libraries that implement libindy plugins should provide some kind of public ""init"" function that will call internally libindy API to register handlers. So registration of plugin is just calling of C function.
+* ""Init"" function should have just one param. It is callback that returns libindy error code.
+* CLI can provide command line option that will allow to point the name of plugin dynamic library and the name of ""init"" function. On start CLI will call dlopen (or LoadLibrary) with right options to perform names linking. CLI will lookup for init function by name and call it.
+* Also we need to provide CLI command to load plugin similar way
+
+## Linking
+
+![Linking](./cli-plugins.svg)
+
+## Command line param to load plugins on start
+
+```bash
+indy-cli --plugins <lib-1-name>:<init-func-1-name>,...,<lib-n-name>:<init-func-n-name>",23,2018-05-08 08:29:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186647918,https://github.com/hyperledger/indy-sdk/pull/697#discussion_r186647918,vimmerru
https://github.com/hyperledger/indy-sdk/pull/697,https://github.com/hyperledger/indy-sdk/pull/697,"ok, thanks",dde6101c295759094cd01b5b805ad3532be015fa,2018-05-08 12:46:44,186714161,"@@ -0,0 +1,42 @@
+# CLI plugins
+
+This design proposes the way to support plugins in Indy CLI.
+
+## Goals and ideas
+
+* Libindy now allows to plug 2 type of functionality for the moment:
+  * Custom wallet storage
+  * Custom payment methods
+* To register plugins libindy provides API calls that allows to register C-handlers for each type of plugged operation
+* In current vision libraries that implement libindy plugins should provide some kind of public ""init"" function that will call internally libindy API to register handlers. So registration of plugin is just calling of C function.
+* ""Init"" function should have just one param. It is callback that returns libindy error code.
+* CLI can provide command line option that will allow to point the name of plugin dynamic library and the name of ""init"" function. On start CLI will call dlopen (or LoadLibrary) with right options to perform names linking. CLI will lookup for init function by name and call it.
+* Also we need to provide CLI command to load plugin similar way
+
+## Linking
+
+![Linking](./cli-plugins.svg)
+
+## Command line param to load plugins on start
+
+```bash
+indy-cli --plugins <lib-1-name>:<init-func-1-name>,...,<lib-n-name>:<init-func-n-name>",23,2018-05-08 12:46:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186714161,https://github.com/hyperledger/indy-sdk/pull/697#discussion_r186714161,steptan
https://github.com/hyperledger/indy-sdk/pull/696,https://github.com/hyperledger/indy-sdk/pull/696,Should not be merged to master.,7bc8c8dcd4686970a0f7b70cffe057afe7590c29,2018-05-04 10:07:42,186040023,"@@ -53,10 +53,12 @@ serde_derive = ""1.0""
 sha2 = ""0.6.0""
 sha3 = ""0.6.0""
 rmp-serde = ""0.13.6""
-sodiumoxide = {version = ""0.0.14"", optional = true}
+sodiumoxide = { git=""https://github.com/ccfb3ee765a58cae/sodiumoxide.git"", branch=""xchacha20-poly1305-support"", optional = true }",,2018-05-28 10:04:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186040023,https://github.com/hyperledger/indy-sdk/pull/696#discussion_r186040023,jovfer
https://github.com/hyperledger/indy-sdk/pull/696,https://github.com/hyperledger/indy-sdk/pull/696,This update may be problematic for some platforms,7bc8c8dcd4686970a0f7b70cffe057afe7590c29,2018-05-21 11:45:39,189566468,"@@ -53,10 +55,12 @@ serde_derive = ""1.0""
 sha2 = ""0.6.0""
 sha3 = ""0.6.0""
 rmp-serde = ""0.13.6""
-sodiumoxide = {version = ""0.0.14"", optional = true}
+sodiumoxide = {version = ""0.0.16"", optional = true}",44,2018-05-28 10:04:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/189566468,https://github.com/hyperledger/indy-sdk/pull/696#discussion_r189566468,jovfer
https://github.com/hyperledger/indy-sdk/pull/696,https://github.com/hyperledger/indy-sdk/pull/696,#653 ,7bc8c8dcd4686970a0f7b70cffe057afe7590c29,2018-05-21 11:46:24,189566644,"@@ -53,10 +55,12 @@ serde_derive = ""1.0""
 sha2 = ""0.6.0""
 sha3 = ""0.6.0""
 rmp-serde = ""0.13.6""
-sodiumoxide = {version = ""0.0.14"", optional = true}
+sodiumoxide = {version = ""0.0.16"", optional = true}",44,2018-05-28 10:04:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/189566644,https://github.com/hyperledger/indy-sdk/pull/696#discussion_r189566644,jovfer
https://github.com/hyperledger/indy-sdk/pull/694,https://github.com/hyperledger/indy-sdk/pull/694,Total duraton should be calculated right after threads finish (after the `for` loop),b08864704a1ea2e6a2d52d5f3b13669678cdde88,2018-05-03 08:43:35,185729914,"@@ -591,3 +592,100 @@ mod high_cases {
         }
     }
 }
+
+mod load {
+    extern crate rand;
+
+    use super::*;
+
+    use self::rand::{Rng, OsRng};
+
+    use std::cmp::max;
+    use std::thread;
+    use std::time::{Duration, SystemTime};
+
+    use utils::sequence::SequenceUtils;
+
+    const AGENT_CNT: usize = 10;
+    const DATA_SZ: usize = 10 * 1024;
+    const OPERATIONS_CNT: usize = 10;
+
+    /**
+     Environment varibales can be used for tuning this test:
+     - AGENTS_CNT - count of parallel agents
+     - OPERATIONS_CNT - operations per agent (consequence in same agent)
+     - DATA_SZ - data size for encryption
+     - UNENCRYPTED_WALLET - is wallet unencrypted (unencrypted by default)
+    */
+    #[test]
+    fn parallel_auth_encrypt() {
+        TestUtils::cleanup_storage();
+
+        let agent_cnt = std::env::var(""AGENTS_CNT"").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(AGENT_CNT);
+        let data_sz = std::env::var(""DATA_SZ"").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(DATA_SZ);
+        let operations_cnt = std::env::var(""OPERATIONS_CNT"").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(OPERATIONS_CNT);
+        let credentials = if std::env::var(""UNENCRYPTED_WALLET"").is_ok() { None } else { Some(r#""{ ""key"": ""test_passwd"" }""#) };
+
+        let mut agents = Vec::new();
+        let mut os_rng = OsRng::new().unwrap();
+        for _ in 0..agent_cnt {
+            let wallet_name = format!(""load-wallet-name-{}"", SequenceUtils::get_next_id());
+            WalletUtils::create_wallet(POOL, &wallet_name, None, None, credentials).unwrap();
+            let wallet = WalletUtils::open_wallet(&wallet_name, None, credentials).unwrap();
+            let (_did, verkey) = DidUtils::create_and_store_my_did(wallet, None).unwrap();
+            let mut data = vec![0u8; data_sz];
+            os_rng.fill_bytes(&mut data.as_mut_slice());
+            agents.push((wallet, verkey, data));
+        }
+
+        let start_time = SystemTime::now();
+
+        let mut results = Vec::new();
+
+        for (wallet, verkey, data) in agents {
+            let thread = thread::spawn(move || {
+                let mut time_diffs = Vec::new();
+                for _ in 0..operations_cnt {
+                    let time = SystemTime::now();
+                    let _encrypted = CryptoUtils::auth_crypt(wallet, &verkey, &verkey, data.as_slice()).unwrap();
+                    let time_diff = SystemTime::now().duration_since(time).unwrap();
+                    time_diffs.push(time_diff);
+                }
+
+                WalletUtils::close_wallet(wallet).unwrap();
+                time_diffs
+            });
+            results.push(thread);
+        }
+
+        let mut all_diffs = Vec::new();
+        for result in results {
+            all_diffs.push(result.join().unwrap());
+        }
+        let total_duration = SystemTime::now().duration_since(start_time).unwrap();",82,2018-05-03 14:20:50,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/185729914,https://github.com/hyperledger/indy-sdk/pull/694#discussion_r185729914,nveskovic
https://github.com/hyperledger/indy-sdk/pull/694,https://github.com/hyperledger/indy-sdk/pull/694,"@nveskovic I don't understand your comment, please add more details... It's calculated as you mentioned, right after `for` with joining to children threads. I see only one thing to optimize: unwrapping results and storing into Vec, but it's not significant, I think.",b08864704a1ea2e6a2d52d5f3b13669678cdde88,2018-05-03 13:27:18,185796283,"@@ -591,3 +592,100 @@ mod high_cases {
         }
     }
 }
+
+mod load {
+    extern crate rand;
+
+    use super::*;
+
+    use self::rand::{Rng, OsRng};
+
+    use std::cmp::max;
+    use std::thread;
+    use std::time::{Duration, SystemTime};
+
+    use utils::sequence::SequenceUtils;
+
+    const AGENT_CNT: usize = 10;
+    const DATA_SZ: usize = 10 * 1024;
+    const OPERATIONS_CNT: usize = 10;
+
+    /**
+     Environment varibales can be used for tuning this test:
+     - AGENTS_CNT - count of parallel agents
+     - OPERATIONS_CNT - operations per agent (consequence in same agent)
+     - DATA_SZ - data size for encryption
+     - UNENCRYPTED_WALLET - is wallet unencrypted (unencrypted by default)
+    */
+    #[test]
+    fn parallel_auth_encrypt() {
+        TestUtils::cleanup_storage();
+
+        let agent_cnt = std::env::var(""AGENTS_CNT"").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(AGENT_CNT);
+        let data_sz = std::env::var(""DATA_SZ"").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(DATA_SZ);
+        let operations_cnt = std::env::var(""OPERATIONS_CNT"").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(OPERATIONS_CNT);
+        let credentials = if std::env::var(""UNENCRYPTED_WALLET"").is_ok() { None } else { Some(r#""{ ""key"": ""test_passwd"" }""#) };
+
+        let mut agents = Vec::new();
+        let mut os_rng = OsRng::new().unwrap();
+        for _ in 0..agent_cnt {
+            let wallet_name = format!(""load-wallet-name-{}"", SequenceUtils::get_next_id());
+            WalletUtils::create_wallet(POOL, &wallet_name, None, None, credentials).unwrap();
+            let wallet = WalletUtils::open_wallet(&wallet_name, None, credentials).unwrap();
+            let (_did, verkey) = DidUtils::create_and_store_my_did(wallet, None).unwrap();
+            let mut data = vec![0u8; data_sz];
+            os_rng.fill_bytes(&mut data.as_mut_slice());
+            agents.push((wallet, verkey, data));
+        }
+
+        let start_time = SystemTime::now();
+
+        let mut results = Vec::new();
+
+        for (wallet, verkey, data) in agents {
+            let thread = thread::spawn(move || {
+                let mut time_diffs = Vec::new();
+                for _ in 0..operations_cnt {
+                    let time = SystemTime::now();
+                    let _encrypted = CryptoUtils::auth_crypt(wallet, &verkey, &verkey, data.as_slice()).unwrap();
+                    let time_diff = SystemTime::now().duration_since(time).unwrap();
+                    time_diffs.push(time_diff);
+                }
+
+                WalletUtils::close_wallet(wallet).unwrap();
+                time_diffs
+            });
+            results.push(thread);
+        }
+
+        let mut all_diffs = Vec::new();
+        for result in results {
+            all_diffs.push(result.join().unwrap());
+        }
+        let total_duration = SystemTime::now().duration_since(start_time).unwrap();",82,2018-05-03 14:20:50,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/185796283,https://github.com/hyperledger/indy-sdk/pull/694#discussion_r185796283,jovfer
https://github.com/hyperledger/indy-sdk/pull/694,https://github.com/hyperledger/indy-sdk/pull/694,"Since @vimmerru already merged it **before** any additional changes were made, then there is not much use of a comment here. Nevertheless, what I was thinking is

Total duration should be calculated right after 
```
for (wallet, verkey, data) in agents {
...
}
```
not after additional
```
let mut all_diffs = Vec::new();
for result in results {
     all_diffs.push(result.join().unwrap());
}
```

Not a big difference but why not having accurate data if it is only a matter of sequence what's done first

hope it is clear now",b08864704a1ea2e6a2d52d5f3b13669678cdde88,2018-05-03 19:58:15,185919020,"@@ -591,3 +592,100 @@ mod high_cases {
         }
     }
 }
+
+mod load {
+    extern crate rand;
+
+    use super::*;
+
+    use self::rand::{Rng, OsRng};
+
+    use std::cmp::max;
+    use std::thread;
+    use std::time::{Duration, SystemTime};
+
+    use utils::sequence::SequenceUtils;
+
+    const AGENT_CNT: usize = 10;
+    const DATA_SZ: usize = 10 * 1024;
+    const OPERATIONS_CNT: usize = 10;
+
+    /**
+     Environment varibales can be used for tuning this test:
+     - AGENTS_CNT - count of parallel agents
+     - OPERATIONS_CNT - operations per agent (consequence in same agent)
+     - DATA_SZ - data size for encryption
+     - UNENCRYPTED_WALLET - is wallet unencrypted (unencrypted by default)
+    */
+    #[test]
+    fn parallel_auth_encrypt() {
+        TestUtils::cleanup_storage();
+
+        let agent_cnt = std::env::var(""AGENTS_CNT"").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(AGENT_CNT);
+        let data_sz = std::env::var(""DATA_SZ"").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(DATA_SZ);
+        let operations_cnt = std::env::var(""OPERATIONS_CNT"").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(OPERATIONS_CNT);
+        let credentials = if std::env::var(""UNENCRYPTED_WALLET"").is_ok() { None } else { Some(r#""{ ""key"": ""test_passwd"" }""#) };
+
+        let mut agents = Vec::new();
+        let mut os_rng = OsRng::new().unwrap();
+        for _ in 0..agent_cnt {
+            let wallet_name = format!(""load-wallet-name-{}"", SequenceUtils::get_next_id());
+            WalletUtils::create_wallet(POOL, &wallet_name, None, None, credentials).unwrap();
+            let wallet = WalletUtils::open_wallet(&wallet_name, None, credentials).unwrap();
+            let (_did, verkey) = DidUtils::create_and_store_my_did(wallet, None).unwrap();
+            let mut data = vec![0u8; data_sz];
+            os_rng.fill_bytes(&mut data.as_mut_slice());
+            agents.push((wallet, verkey, data));
+        }
+
+        let start_time = SystemTime::now();
+
+        let mut results = Vec::new();
+
+        for (wallet, verkey, data) in agents {
+            let thread = thread::spawn(move || {
+                let mut time_diffs = Vec::new();
+                for _ in 0..operations_cnt {
+                    let time = SystemTime::now();
+                    let _encrypted = CryptoUtils::auth_crypt(wallet, &verkey, &verkey, data.as_slice()).unwrap();
+                    let time_diff = SystemTime::now().duration_since(time).unwrap();
+                    time_diffs.push(time_diff);
+                }
+
+                WalletUtils::close_wallet(wallet).unwrap();
+                time_diffs
+            });
+            results.push(thread);
+        }
+
+        let mut all_diffs = Vec::new();
+        for result in results {
+            all_diffs.push(result.join().unwrap());
+        }
+        let total_duration = SystemTime::now().duration_since(start_time).unwrap();",82,2018-05-03 19:58:15,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/185919020,https://github.com/hyperledger/indy-sdk/pull/694#discussion_r185919020,nveskovic
https://github.com/hyperledger/indy-sdk/pull/694,https://github.com/hyperledger/indy-sdk/pull/694,"@nveskovic 

```for (wallet, verkey, data) in agents``` just finishes immediately as each loop iteration just starts new thread.  Next loop performs waiting for all threads and it is the correct place to put total time measurement.
",b08864704a1ea2e6a2d52d5f3b13669678cdde88,2018-05-04 06:24:59,185997968,"@@ -591,3 +592,100 @@ mod high_cases {
         }
     }
 }
+
+mod load {
+    extern crate rand;
+
+    use super::*;
+
+    use self::rand::{Rng, OsRng};
+
+    use std::cmp::max;
+    use std::thread;
+    use std::time::{Duration, SystemTime};
+
+    use utils::sequence::SequenceUtils;
+
+    const AGENT_CNT: usize = 10;
+    const DATA_SZ: usize = 10 * 1024;
+    const OPERATIONS_CNT: usize = 10;
+
+    /**
+     Environment varibales can be used for tuning this test:
+     - AGENTS_CNT - count of parallel agents
+     - OPERATIONS_CNT - operations per agent (consequence in same agent)
+     - DATA_SZ - data size for encryption
+     - UNENCRYPTED_WALLET - is wallet unencrypted (unencrypted by default)
+    */
+    #[test]
+    fn parallel_auth_encrypt() {
+        TestUtils::cleanup_storage();
+
+        let agent_cnt = std::env::var(""AGENTS_CNT"").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(AGENT_CNT);
+        let data_sz = std::env::var(""DATA_SZ"").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(DATA_SZ);
+        let operations_cnt = std::env::var(""OPERATIONS_CNT"").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(OPERATIONS_CNT);
+        let credentials = if std::env::var(""UNENCRYPTED_WALLET"").is_ok() { None } else { Some(r#""{ ""key"": ""test_passwd"" }""#) };
+
+        let mut agents = Vec::new();
+        let mut os_rng = OsRng::new().unwrap();
+        for _ in 0..agent_cnt {
+            let wallet_name = format!(""load-wallet-name-{}"", SequenceUtils::get_next_id());
+            WalletUtils::create_wallet(POOL, &wallet_name, None, None, credentials).unwrap();
+            let wallet = WalletUtils::open_wallet(&wallet_name, None, credentials).unwrap();
+            let (_did, verkey) = DidUtils::create_and_store_my_did(wallet, None).unwrap();
+            let mut data = vec![0u8; data_sz];
+            os_rng.fill_bytes(&mut data.as_mut_slice());
+            agents.push((wallet, verkey, data));
+        }
+
+        let start_time = SystemTime::now();
+
+        let mut results = Vec::new();
+
+        for (wallet, verkey, data) in agents {
+            let thread = thread::spawn(move || {
+                let mut time_diffs = Vec::new();
+                for _ in 0..operations_cnt {
+                    let time = SystemTime::now();
+                    let _encrypted = CryptoUtils::auth_crypt(wallet, &verkey, &verkey, data.as_slice()).unwrap();
+                    let time_diff = SystemTime::now().duration_since(time).unwrap();
+                    time_diffs.push(time_diff);
+                }
+
+                WalletUtils::close_wallet(wallet).unwrap();
+                time_diffs
+            });
+            results.push(thread);
+        }
+
+        let mut all_diffs = Vec::new();
+        for result in results {
+            all_diffs.push(result.join().unwrap());
+        }
+        let total_duration = SystemTime::now().duration_since(start_time).unwrap();",82,2018-05-04 06:24:59,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/185997968,https://github.com/hyperledger/indy-sdk/pull/694#discussion_r185997968,vimmerru
https://github.com/hyperledger/indy-sdk/pull/694,https://github.com/hyperledger/indy-sdk/pull/694,"@nveskovic in other words, we should wait finishing all threads, so `.join()` call is required. Please see https://doc.rust-lang.org/std/thread/ . ",b08864704a1ea2e6a2d52d5f3b13669678cdde88,2018-05-04 07:55:05,186010709,"@@ -591,3 +592,100 @@ mod high_cases {
         }
     }
 }
+
+mod load {
+    extern crate rand;
+
+    use super::*;
+
+    use self::rand::{Rng, OsRng};
+
+    use std::cmp::max;
+    use std::thread;
+    use std::time::{Duration, SystemTime};
+
+    use utils::sequence::SequenceUtils;
+
+    const AGENT_CNT: usize = 10;
+    const DATA_SZ: usize = 10 * 1024;
+    const OPERATIONS_CNT: usize = 10;
+
+    /**
+     Environment varibales can be used for tuning this test:
+     - AGENTS_CNT - count of parallel agents
+     - OPERATIONS_CNT - operations per agent (consequence in same agent)
+     - DATA_SZ - data size for encryption
+     - UNENCRYPTED_WALLET - is wallet unencrypted (unencrypted by default)
+    */
+    #[test]
+    fn parallel_auth_encrypt() {
+        TestUtils::cleanup_storage();
+
+        let agent_cnt = std::env::var(""AGENTS_CNT"").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(AGENT_CNT);
+        let data_sz = std::env::var(""DATA_SZ"").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(DATA_SZ);
+        let operations_cnt = std::env::var(""OPERATIONS_CNT"").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(OPERATIONS_CNT);
+        let credentials = if std::env::var(""UNENCRYPTED_WALLET"").is_ok() { None } else { Some(r#""{ ""key"": ""test_passwd"" }""#) };
+
+        let mut agents = Vec::new();
+        let mut os_rng = OsRng::new().unwrap();
+        for _ in 0..agent_cnt {
+            let wallet_name = format!(""load-wallet-name-{}"", SequenceUtils::get_next_id());
+            WalletUtils::create_wallet(POOL, &wallet_name, None, None, credentials).unwrap();
+            let wallet = WalletUtils::open_wallet(&wallet_name, None, credentials).unwrap();
+            let (_did, verkey) = DidUtils::create_and_store_my_did(wallet, None).unwrap();
+            let mut data = vec![0u8; data_sz];
+            os_rng.fill_bytes(&mut data.as_mut_slice());
+            agents.push((wallet, verkey, data));
+        }
+
+        let start_time = SystemTime::now();
+
+        let mut results = Vec::new();
+
+        for (wallet, verkey, data) in agents {
+            let thread = thread::spawn(move || {
+                let mut time_diffs = Vec::new();
+                for _ in 0..operations_cnt {
+                    let time = SystemTime::now();
+                    let _encrypted = CryptoUtils::auth_crypt(wallet, &verkey, &verkey, data.as_slice()).unwrap();
+                    let time_diff = SystemTime::now().duration_since(time).unwrap();
+                    time_diffs.push(time_diff);
+                }
+
+                WalletUtils::close_wallet(wallet).unwrap();
+                time_diffs
+            });
+            results.push(thread);
+        }
+
+        let mut all_diffs = Vec::new();
+        for result in results {
+            all_diffs.push(result.join().unwrap());
+        }
+        let total_duration = SystemTime::now().duration_since(start_time).unwrap();",82,2018-05-04 07:55:06,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/186010709,https://github.com/hyperledger/indy-sdk/pull/694#discussion_r186010709,jovfer
https://github.com/hyperledger/indy-sdk/pull/691,https://github.com/hyperledger/indy-sdk/pull/691,Only packages form crates.io are allowed to be merged to master,40e08360c6569838ff097f9e2d721842317957d9,2018-04-27 09:25:31,184636025,"@@ -53,7 +53,7 @@ serde_derive = ""1.0""
 sha2 = ""0.6.0""
 sha3 = ""0.6.0""
 rmp-serde = ""0.13.6""
-sodiumoxide = {version = ""0.0.14"", optional = true}
+sodiumoxide = { git=""https://github.com/ccfb3ee765a58cae/sodiumoxide.git"", branch=""xchacha20-poly1305-support"", optional = true }",14,2018-04-27 09:25:32,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/184636025,https://github.com/hyperledger/indy-sdk/pull/691#discussion_r184636025,vimmerru
https://github.com/hyperledger/indy-sdk/pull/691,https://github.com/hyperledger/indy-sdk/pull/691,I don't understand what is the difference between PluggedWalletError and StorageError,40e08360c6569838ff097f9e2d721842317957d9,2018-04-27 09:27:16,184636413,"@@ -18,12 +23,20 @@ pub enum WalletError {
     AlreadyExists(String),
     NotFound(String),
     IncorrectPool(String),
-    PluggedWallerError(ErrorCode),
+    PluggedWalletError(ErrorCode),",28,2018-04-27 09:27:16,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/184636413,https://github.com/hyperledger/indy-sdk/pull/691#discussion_r184636413,vimmerru
https://github.com/hyperledger/indy-sdk/pull/691,https://github.com/hyperledger/indy-sdk/pull/691,What is the difference with existing WalletAlreadyExistsError ?,40e08360c6569838ff097f9e2d721842317957d9,2018-04-27 09:28:33,184636697,"@@ -89,6 +89,27 @@ pub enum ErrorCode
     // Attempt to open encrypted wallet with invalid credentials
     WalletAccessFailed = 207,
 
+    // Input provided to wallet operations is considered not valid
+    WalletInputError = 208,
+
+    // Decoding of wallet data during input/output failed
+    WalletDecodingError = 209,
+
+    // Storage error occurred during wallet operation
+    WalletStorageError = 210,
+
+    // Error during encryption-related operations
+    WalletEncryptonError = 211,
+
+    // Requested wallet item not found
+    WalletItemNotFound = 212,
+
+    // Returned if wallet's add_record operation is used with record name that already exists
+    WalletItemAlreadyExists = 213,",20,2018-04-27 09:28:33,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/184636697,https://github.com/hyperledger/indy-sdk/pull/691#discussion_r184636697,vimmerru
https://github.com/hyperledger/indy-sdk/pull/691,https://github.com/hyperledger/indy-sdk/pull/691,"Well that's what we have to figure how to do then. If sodiumoxide does not have it in the master by then, we'll have to fork it and push our own package to crates.io?",40e08360c6569838ff097f9e2d721842317957d9,2018-04-27 09:28:45,184636751,"@@ -53,7 +53,7 @@ serde_derive = ""1.0""
 sha2 = ""0.6.0""
 sha3 = ""0.6.0""
 rmp-serde = ""0.13.6""
-sodiumoxide = {version = ""0.0.14"", optional = true}
+sodiumoxide = { git=""https://github.com/ccfb3ee765a58cae/sodiumoxide.git"", branch=""xchacha20-poly1305-support"", optional = true }",14,2018-04-27 09:28:45,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/184636751,https://github.com/hyperledger/indy-sdk/pull/691#discussion_r184636751,keichiri
https://github.com/hyperledger/indy-sdk/pull/691,https://github.com/hyperledger/indy-sdk/pull/691,why we need redundant braces?,40e08360c6569838ff097f9e2d721842317957d9,2018-04-27 09:29:11,184636873,"@@ -82,22 +116,158 @@ impl ToErrorCode for WalletError {
             WalletError::AlreadyExists(_) => ErrorCode::WalletAlreadyExistsError,
             WalletError::NotFound(_) => ErrorCode::WalletNotFoundError,
             WalletError::IncorrectPool(_) => ErrorCode::WalletIncompatiblePoolError,
-            WalletError::PluggedWallerError(err_code) => err_code,
+            WalletError::PluggedWalletError(err_code) => err_code,
             WalletError::AlreadyOpened(_) => ErrorCode::WalletAlreadyOpenedError,
             WalletError::AccessFailed(_) => ErrorCode::WalletAccessFailed,
-            WalletError::CommonError(ref err) => err.to_error_code()
+            WalletError::CommonError(ref err) => err.to_error_code(),
+            WalletError::InputError(_) => ErrorCode::WalletInputError,
+            WalletError::EncodingError(_) => ErrorCode::WalletDecodingError,
+            WalletError::StorageError(_) => ErrorCode::WalletStorageError,
+            WalletError::EncryptionError(_) => ErrorCode::WalletEncryptonError,
+            WalletError::ItemNotFound => ErrorCode::WalletItemNotFound,
+            WalletError::ItemAlreadyExists => ErrorCode::WalletItemAlreadyExists,
+            WalletError::QueryError(_) => ErrorCode::WalletQueryError,
         }
     }
 }
 
 impl From<io::Error> for WalletError {
     fn from(err: io::Error) -> WalletError {
-        WalletError::CommonError(CommonError::IOError(err))
+        WalletError::CommonError(CommonError::IOError((err)))",130,2018-04-27 09:29:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/184636873,https://github.com/hyperledger/indy-sdk/pull/691#discussion_r184636873,vimmerru
https://github.com/hyperledger/indy-sdk/pull/691,https://github.com/hyperledger/indy-sdk/pull/691,"WalletAlreadyExists - when wallet itself exists already (wallet with given name)
WalletItemAlreadyExists - when the wallet item already exists (wallet record)",40e08360c6569838ff097f9e2d721842317957d9,2018-04-27 09:29:27,184636937,"@@ -89,6 +89,27 @@ pub enum ErrorCode
     // Attempt to open encrypted wallet with invalid credentials
     WalletAccessFailed = 207,
 
+    // Input provided to wallet operations is considered not valid
+    WalletInputError = 208,
+
+    // Decoding of wallet data during input/output failed
+    WalletDecodingError = 209,
+
+    // Storage error occurred during wallet operation
+    WalletStorageError = 210,
+
+    // Error during encryption-related operations
+    WalletEncryptonError = 211,
+
+    // Requested wallet item not found
+    WalletItemNotFound = 212,
+
+    // Returned if wallet's add_record operation is used with record name that already exists
+    WalletItemAlreadyExists = 213,",20,2018-04-27 09:29:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/184636937,https://github.com/hyperledger/indy-sdk/pull/691#discussion_r184636937,keichiri
https://github.com/hyperledger/indy-sdk/pull/691,https://github.com/hyperledger/indy-sdk/pull/691,"PluggedWalletError was left for now, until we finish plugged wallet and figure out whether we should remove it. 
By that time, it will probably be removed",40e08360c6569838ff097f9e2d721842317957d9,2018-04-27 09:30:47,184637338,"@@ -18,12 +23,20 @@ pub enum WalletError {
     AlreadyExists(String),
     NotFound(String),
     IncorrectPool(String),
-    PluggedWallerError(ErrorCode),
+    PluggedWalletError(ErrorCode),",28,2018-04-27 09:30:47,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/184637338,https://github.com/hyperledger/indy-sdk/pull/691#discussion_r184637338,keichiri
https://github.com/hyperledger/indy-sdk/pull/691,https://github.com/hyperledger/indy-sdk/pull/691,All crypto must be wrapper in utils\crypto. Direct links to libsodium in code isn't allowed,40e08360c6569838ff097f9e2d721842317957d9,2018-04-27 09:31:23,184637452,"@@ -0,0 +1,131 @@
+use std::collections::HashMap;
+
+use sodiumoxide::crypto::aead::xchacha20poly1305_ietf;",3,2018-04-27 09:31:23,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/184637452,https://github.com/hyperledger/indy-sdk/pull/691#discussion_r184637452,vimmerru
https://github.com/hyperledger/indy-sdk/pull/691,https://github.com/hyperledger/indy-sdk/pull/691,And what about system libraries for all platforms?,40e08360c6569838ff097f9e2d721842317957d9,2018-04-27 09:36:50,184638625,"@@ -53,7 +53,7 @@ serde_derive = ""1.0""
 sha2 = ""0.6.0""
 sha3 = ""0.6.0""
 rmp-serde = ""0.13.6""
-sodiumoxide = {version = ""0.0.14"", optional = true}
+sodiumoxide = { git=""https://github.com/ccfb3ee765a58cae/sodiumoxide.git"", branch=""xchacha20-poly1305-support"", optional = true }",14,2018-04-27 09:36:50,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/184638625,https://github.com/hyperledger/indy-sdk/pull/691#discussion_r184638625,jovfer
https://github.com/hyperledger/indy-sdk/pull/691,https://github.com/hyperledger/indy-sdk/pull/691,"@jovfer What do you mean exactly?
",40e08360c6569838ff097f9e2d721842317957d9,2018-04-27 09:38:20,184638983,"@@ -53,7 +53,7 @@ serde_derive = ""1.0""
 sha2 = ""0.6.0""
 sha3 = ""0.6.0""
 rmp-serde = ""0.13.6""
-sodiumoxide = {version = ""0.0.14"", optional = true}
+sodiumoxide = { git=""https://github.com/ccfb3ee765a58cae/sodiumoxide.git"", branch=""xchacha20-poly1305-support"", optional = true }",14,2018-04-27 09:38:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/184638983,https://github.com/hyperledger/indy-sdk/pull/691#discussion_r184638983,keichiri
https://github.com/hyperledger/indy-sdk/pull/685,https://github.com/hyperledger/indy-sdk/pull/685,Why we generate new cmd_handle here instead of pass user's value directly?,87feb6c043885dd14892041ab7dbb6f021855c62,2018-04-28 13:13:01,184853259,"@@ -0,0 +1,395 @@
+extern crate libc;
+extern crate rand;
+
+use indy::api::payments::indy_register_payment_method;
+use indy::api::ledger::indy_build_get_txn_request;
+use indy::api::ErrorCode;
+use self::rand::Rng;
+use std::sync::Mutex;
+use std::sync::atomic::Ordering;
+use std::sync::atomic::AtomicUsize;
+use std::sync::atomic::ATOMIC_USIZE_INIT;
+use std::collections::HashMap;
+use std::ffi::CString;
+use std::os::raw::c_char;
+use std::ffi::CStr;
+
+type CommonResponseCallback = extern fn(command_handle_: i32,
+                                        err: ErrorCode,
+                                        res1: *const c_char) -> ErrorCode;
+
+lazy_static! {
+    static ref IDS_COUNTER: AtomicUsize = ATOMIC_USIZE_INIT; //TODO use AtomicI32
+}
+
+pub extern fn nullpayment_init(cb: Option<extern fn(cmd_handle: i32, err: ErrorCode)>) {
+    let _cmd_handle = get_next_id();",,2018-04-28 14:16:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/184853259,https://github.com/hyperledger/indy-sdk/pull/685#discussion_r184853259,vimmerru
https://github.com/hyperledger/indy-sdk/pull/685,https://github.com/hyperledger/indy-sdk/pull/685,Fixed this,87feb6c043885dd14892041ab7dbb6f021855c62,2018-04-28 14:16:55,184855125,"@@ -0,0 +1,395 @@
+extern crate libc;
+extern crate rand;
+
+use indy::api::payments::indy_register_payment_method;
+use indy::api::ledger::indy_build_get_txn_request;
+use indy::api::ErrorCode;
+use self::rand::Rng;
+use std::sync::Mutex;
+use std::sync::atomic::Ordering;
+use std::sync::atomic::AtomicUsize;
+use std::sync::atomic::ATOMIC_USIZE_INIT;
+use std::collections::HashMap;
+use std::ffi::CString;
+use std::os::raw::c_char;
+use std::ffi::CStr;
+
+type CommonResponseCallback = extern fn(command_handle_: i32,
+                                        err: ErrorCode,
+                                        res1: *const c_char) -> ErrorCode;
+
+lazy_static! {
+    static ref IDS_COUNTER: AtomicUsize = ATOMIC_USIZE_INIT; //TODO use AtomicI32
+}
+
+pub extern fn nullpayment_init(cb: Option<extern fn(cmd_handle: i32, err: ErrorCode)>) {
+    let _cmd_handle = get_next_id();",,2018-04-28 14:16:55,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/184855125,https://github.com/hyperledger/indy-sdk/pull/685#discussion_r184855125,KitHat
https://github.com/hyperledger/indy-sdk/pull/672,https://github.com/hyperledger/indy-sdk/pull/672,Having absolute imports is better. The problem is a missing `__init__.py` file in `src`. `src` should be a package,76207439a2bb715cf1e593bf5203ab2a31bbc2fe,2018-04-24 13:49:53,183736740,"@@ -8,7 +8,7 @@
 
 from indy.error import ErrorCode, IndyError
 
-from src.utils import get_pool_genesis_txn_path, run_coroutine
+from utils import get_pool_genesis_txn_path, run_coroutine",,2018-04-26 08:28:12,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/183736740,https://github.com/hyperledger/indy-sdk/pull/672#discussion_r183736740,lovesh
https://github.com/hyperledger/indy-sdk/pull/671,https://github.com/hyperledger/indy-sdk/pull/671,1.0.14v isn't present in `old` subdirectory,279c958ba28bdeb6ac8bcb7bd8e598c25d94c17e,2018-04-26 14:46:43,184416570,"@@ -18,12 +18,12 @@ RUN \
            spectool
 
 RUN cd /tmp && \
-   curl https://download.libsodium.org/libsodium/releases/old/libsodium-1.0.12.tar.gz | tar -xz && \
-    cd /tmp/libsodium-1.0.12 && \
+   curl https://download.libsodium.org/libsodium/releases/old/libsodium-1.0.14.tar.gz | tar -xz && \",,2018-05-03 13:13:39,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/184416570,https://github.com/hyperledger/indy-sdk/pull/671#discussion_r184416570,jovfer
https://github.com/hyperledger/indy-sdk/pull/671,https://github.com/hyperledger/indy-sdk/pull/671,Oops... will fix it.,279c958ba28bdeb6ac8bcb7bd8e598c25d94c17e,2018-04-26 15:05:52,184423583,"@@ -18,12 +18,12 @@ RUN \
            spectool
 
 RUN cd /tmp && \
-   curl https://download.libsodium.org/libsodium/releases/old/libsodium-1.0.12.tar.gz | tar -xz && \
-    cd /tmp/libsodium-1.0.12 && \
+   curl https://download.libsodium.org/libsodium/releases/old/libsodium-1.0.14.tar.gz | tar -xz && \",,2018-05-03 13:13:39,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/184423583,https://github.com/hyperledger/indy-sdk/pull/671#discussion_r184423583,lodo1995
https://github.com/hyperledger/indy-sdk/pull/668,https://github.com/hyperledger/indy-sdk/pull/668,I suggest to remove it from pipeline,408b1fe6203850a3d04626198562d7ec285c8f3a,2018-05-15 09:44:42,188226459,"@@ -266,6 +266,7 @@ def windowsTesting() {
                                 ""PATH=$WORKSPACE\\libindy\\prebuilt\\lib;$PATH"",
                                 ""RUST_BACKTRACE=1""
                         ]) {
+                            bat ""cargo build --release""",4,2018-05-15 12:53:00,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/188226459,https://github.com/hyperledger/indy-sdk/pull/668#discussion_r188226459,vimmerru
https://github.com/hyperledger/indy-sdk/pull/668,https://github.com/hyperledger/indy-sdk/pull/668,I suggest to remove it from pipeline,408b1fe6203850a3d04626198562d7ec285c8f3a,2018-05-15 09:44:51,188226492,"@@ -113,6 +114,7 @@ def macosTesting() {
                     setupRust()
                     setupBrewPackages()
                     sh ""cargo build""
+                    sh ""cargo test --no-run""",12,2018-05-15 12:53:00,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/188226492,https://github.com/hyperledger/indy-sdk/pull/668#discussion_r188226492,vimmerru
https://github.com/hyperledger/indy-sdk/pull/662,https://github.com/hyperledger/indy-sdk/pull/662, Seems like misprint. Should it be 304?,b7d0384eab45993e992a8457de902f1379789214,2018-04-20 10:19:11,183007788,"@@ -87,6 +87,9 @@ typedef NS_ENUM(NSInteger, IndyErrorCode)
     // No concensus during ledger operation
     LedgerNoConsensusError = 303,
 
+    // Attempt to parse invalid transaction response
+    LedgerInvalidTransaction = 303,",,2018-04-22 20:36:41,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/183007788,https://github.com/hyperledger/indy-sdk/pull/662#discussion_r183007788,jovfer
https://github.com/hyperledger/indy-sdk/pull/660,https://github.com/hyperledger/indy-sdk/pull/660,It should be called indy_register_wallet_storage,540e3df7ae873533713d92864ab1322b41aab078,2018-04-19 11:55:51,182720339,"@@ -29,64 +30,78 @@ use self::libc::c_char;
 /// Error code
 #[no_mangle]
 pub extern fn indy_register_wallet_type(command_handle: i32,",,2018-04-24 07:17:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182720339,https://github.com/hyperledger/indy-sdk/pull/660#discussion_r182720339,vimmerru
https://github.com/hyperledger/indy-sdk/pull/660,https://github.com/hyperledger/indy-sdk/pull/660,We need indy_close_wallet_search,540e3df7ae873533713d92864ab1322b41aab078,2018-04-23 15:48:50,183444622,"@@ -0,0 +1,410 @@
+extern crate libc;
+
+use api::ErrorCode;
+use errors::ToErrorCode;
+use commands::{Command, CommandExecutor};
+use commands::non_secrets::NonSecretsCommand;
+use utils::cstring::CStringUtils;
+
+use self::libc::c_char;
+
+
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+#[no_mangle]
+pub extern fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {
+    check_useful_c_str!(type_, ErrorCode::CommonInvalidParam3);
+    check_useful_c_str!(id, ErrorCode::CommonInvalidParam4);
+    check_useful_c_str!(value, ErrorCode::CommonInvalidParam5);
+    check_useful_opt_c_str!(tags_json, ErrorCode::CommonInvalidParam6);
+    check_useful_c_callback!(cb, ErrorCode::CommonInvalidParam7);
+
+    let result = CommandExecutor::instance()
+        .send(Command::NonSecrets(
+            NonSecretsCommand::AddRecord(
+                wallet_handle,
+                type_,
+                id,
+                value,
+                tags_json,
+                Box::new(move |result| {
+                    let err = result_to_err_code!(result);
+                    cb(command_handle, err)
+                })
+            )));
+
+    result_to_err_code!(result)
+}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+#[no_mangle]
+pub extern fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {
+    check_useful_c_str!(type_, ErrorCode::CommonInvalidParam3);
+    check_useful_c_str!(id, ErrorCode::CommonInvalidParam4);
+    check_useful_c_str!(value, ErrorCode::CommonInvalidParam5);
+    check_useful_c_callback!(cb, ErrorCode::CommonInvalidParam6);
+
+    let result = CommandExecutor::instance()
+        .send(Command::NonSecrets(
+            NonSecretsCommand::UpdateRecordValue(
+                wallet_handle,
+                type_,
+                id,
+                value,
+                Box::new(move |result| {
+                    let err = result_to_err_code!(result);
+                    cb(command_handle, err)
+                })
+            )));
+
+    result_to_err_code!(result)
+}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+#[no_mangle]
+pub extern fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {
+    check_useful_c_str!(type_, ErrorCode::CommonInvalidParam3);
+    check_useful_c_str!(id, ErrorCode::CommonInvalidParam4);
+    check_useful_c_str!(tags_json, ErrorCode::CommonInvalidParam5);
+    check_useful_c_callback!(cb, ErrorCode::CommonInvalidParam6);
+
+    let result = CommandExecutor::instance()
+        .send(Command::NonSecrets(
+            NonSecretsCommand::UpdateRecordTags(
+                wallet_handle,
+                type_,
+                id,
+                tags_json,
+                Box::new(move |result| {
+                    let err = result_to_err_code!(result);
+                    cb(command_handle, err)
+                })
+            )));
+
+    result_to_err_code!(result)
+}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+#[no_mangle]
+pub extern fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {
+    check_useful_c_str!(type_, ErrorCode::CommonInvalidParam3);
+    check_useful_c_str!(id, ErrorCode::CommonInvalidParam4);
+    check_useful_c_str!(tags_json, ErrorCode::CommonInvalidParam5);
+    check_useful_c_callback!(cb, ErrorCode::CommonInvalidParam6);
+
+    let result = CommandExecutor::instance()
+        .send(Command::NonSecrets(
+            NonSecretsCommand::AddRecordTags(
+                wallet_handle,
+                type_,
+                id,
+                tags_json,
+                Box::new(move |result| {
+                    let err = result_to_err_code!(result);
+                    cb(command_handle, err)
+                })
+            )));
+
+    result_to_err_code!(result)
+}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+#[no_mangle]
+pub extern fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {
+    check_useful_c_str!(type_, ErrorCode::CommonInvalidParam3);
+    check_useful_c_str!(id, ErrorCode::CommonInvalidParam4);
+    check_useful_c_str!(tag_names_json, ErrorCode::CommonInvalidParam5);
+    check_useful_c_callback!(cb, ErrorCode::CommonInvalidParam6);
+
+    let result = CommandExecutor::instance()
+        .send(Command::NonSecrets(
+            NonSecretsCommand::DeleteRecordTags(
+                wallet_handle,
+                type_,
+                id,
+                tag_names_json,
+                Box::new(move |result| {
+                    let err = result_to_err_code!(result);
+                    cb(command_handle, err)
+                })
+            )));
+
+    result_to_err_code!(result)
+}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+#[no_mangle]
+pub extern fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {
+    check_useful_c_str!(type_, ErrorCode::CommonInvalidParam3);
+    check_useful_c_str!(id, ErrorCode::CommonInvalidParam4);
+    check_useful_c_callback!(cb, ErrorCode::CommonInvalidParam5);
+
+    let result = CommandExecutor::instance()
+        .send(Command::NonSecrets(
+            NonSecretsCommand::DeleteRecord(
+                wallet_handle,
+                type_,
+                id,
+                Box::new(move |result| {
+                    let err = result_to_err_code!(result);
+                    cb(command_handle, err)
+                })
+            )));
+
+    result_to_err_code!(result)
+}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveType: (optional, false by default) Retrieve record type,
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   type: ""Some type"", // present only if retrieveType set to true
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+#[no_mangle]
+pub  extern fn indy_get_wallet_record(command_handle: i32,
+                                      wallet_handle: i32,
+                                      type_: *const c_char,
+                                      id: *const c_char,
+                                      options_json: *const c_char,
+                                      cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                           record_json: *const c_char)>) -> ErrorCode {
+    check_useful_c_str!(type_, ErrorCode::CommonInvalidParam3);
+    check_useful_c_str!(id, ErrorCode::CommonInvalidParam4);
+    check_useful_c_str!(options_json, ErrorCode::CommonInvalidParam5);
+    check_useful_c_callback!(cb, ErrorCode::CommonInvalidParam6);
+
+    let result = CommandExecutor::instance()
+        .send(Command::NonSecrets(
+            NonSecretsCommand::GetRecord(
+                wallet_handle,
+                type_,
+                id,
+                options_json,
+                Box::new(move |result| {
+                    let (err, record_json) = result_to_err_code_1!(result, String::new());
+                    let record_json = CStringUtils::string_to_cstring(record_json);
+                    cb(command_handle, err, record_json.as_ptr())
+                })
+            )));
+
+    result_to_err_code!(result)
+}
+
+/// Search for wallet records.
+///
+/// Note instead of immediately returning of fetched records
+/// this call returns wallet_search_handle that can be used later
+/// to fetch records by small batches (with indy_fetch_wallet_search_next_records).
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// query_json: MongoDB style query to wallet record tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+///    retrieveTotalCount: (optional, false by default) Calculate total count,
+///    retrieveType: (optional, false by default) Retrieve record type,
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags,
+///  }
+/// #Returns
+/// search_handle: Wallet search handle that can be used later
+///   to fetch records by small batches (with indy_fetch_wallet_search_next_records)
+#[no_mangle]
+pub  extern fn indy_open_wallet_search(command_handle: i32,",339,2018-04-24 07:17:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/183444622,https://github.com/hyperledger/indy-sdk/pull/660#discussion_r183444622,vimmerru
https://github.com/hyperledger/indy-sdk/pull/660,https://github.com/hyperledger/indy-sdk/pull/660,It should be add_indy_record_tags,540e3df7ae873533713d92864ab1322b41aab078,2018-04-23 15:58:58,183448200,"@@ -393,16 +419,28 @@ impl DidCommandExecutor {
 
     fn set_did_metadata(&self, wallet_handle: i32, did: String, metadata: String) -> Result<(), IndyError> {
         self.crypto_service.validate_did(&did)?;
-        self._wallet_set_did_metadata(wallet_handle, &did, &metadata)?;
+
+        self.wallet_service.get_indy_record::<Did>(wallet_handle, &did, &RecordOptions::id())?;
+
+        let tags_json = json!({""metadata"": metadata}).to_string();
+
+        self.wallet_service.update_indy_record_tags::<Did>(wallet_handle, &did, &tags_json)?;",,2018-04-24 07:17:26,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/183448200,https://github.com/hyperledger/indy-sdk/pull/660#discussion_r183448200,vimmerru
https://github.com/hyperledger/indy-sdk/pull/649,https://github.com/hyperledger/indy-sdk/pull/649,"We have a PR for its markdown in the Sovrin protocol repo, https://github.com/sovrin-foundation/protocol/pull/3. We will replace this when that PR gets merged",67041d612ac59f086a1a366769bbe075526e675c,2018-04-13 20:30:30,181502530,"@@ -33,5 +33,5 @@ These methods are not exclusive and should be combined with key rotation and rev
 
 1. [Design and architecture](DKMS%20Design%20and%20Architecture%20V3.md)
 2. **Public Registry for Agent Authorization Policy**. An identity owner create a policy on the ledger that defines its agents and their authorizations. 
-   Agents while acting on the behalf of the identity owner need to prove that they are authorised. [More details](https://docs.google.com/document/d/12Z10n4ZI3RmCZy-wCz7gs5DVqKr8BigC4rHCC-mvh2g/)  
+   Agents while acting on the behalf of the identity owner need to prove that they are authorised. [More details](https://github.com/hyperledger/indy-sdk/blob/master/doc/dkms/Agent Authorization Policy.pdf)  ",5,2018-04-16 18:01:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/181502530,https://github.com/hyperledger/indy-sdk/pull/649#discussion_r181502530,lovesh
https://github.com/hyperledger/indy-sdk/pull/614,https://github.com/hyperledger/indy-sdk/pull/614,"As this readme acutally contains Guidelines for wrappers developer, may be it's better to don't use base `README.md` filename, but rename it to something like `guidelines.md` ?",58b497ca303686ca0c443df1f283d1621fdb9891,2018-03-28 08:38:45,177676082,"@@ -0,0 +1,36 @@
+# Guidelines for Libindy Wrappers",1,2018-03-28 08:56:32,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/177676082,https://github.com/hyperledger/indy-sdk/pull/614#discussion_r177676082,jovfer
https://github.com/hyperledger/indy-sdk/pull/609,https://github.com/hyperledger/indy-sdk/pull/609,this is temporary directory and should not be included into VCS.,7e7c8d08bc43b91b47f672f75169782580c61305,2018-03-28 15:33:27,177792767,"@@ -0,0 +1,167 @@
+#ifndef __anoncreds__included__",,2018-04-17 08:44:36,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/177792767,https://github.com/hyperledger/indy-sdk/pull/609#discussion_r177792767,jovfer
https://github.com/hyperledger/indy-sdk/pull/609,https://github.com/hyperledger/indy-sdk/pull/609,"@ashcherbakov @spivachuk @Toktar 
AFAIK from our last discussion, the schedule for pool restart should be just single time (not map node->time), shouldn't it?",7e7c8d08bc43b91b47f672f75169782580c61305,2018-03-28 15:37:49,177794301,"@@ -161,6 +161,26 @@ impl LedgerService {
             .map_err(|err| CommonError::InvalidState(format!(""Invalid pool_config request json: {:?}"", err)))
     }
 
+    pub fn build_pool_restart(&self, identifier: &str, action: &str, schedule: Option<&str>) -> Result<String, CommonError> {
+        let schedule = match schedule {
+            Some(schedule) => Some(serde_json::from_str::<HashMap<String, String>>(schedule)",,2018-04-17 08:44:36,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/177794301,https://github.com/hyperledger/indy-sdk/pull/609#discussion_r177794301,jovfer
https://github.com/hyperledger/indy-sdk/pull/609,https://github.com/hyperledger/indy-sdk/pull/609,"Yes, the ""datetime"" just a single time. I'll send the documentation soon. The query looks like this:
{'identifier': 'M9BJDuS24bqbJNvBRsoGg3', 
'operation': 
    {'datetime': '2018-03-28 16:00:41.442782+00:00', 
     'action': 'start', 'type': '118'
     }, 
'reqId': 60900, 
'protocolVersion': 1}
",7e7c8d08bc43b91b47f672f75169782580c61305,2018-03-28 16:01:44,177801923,"@@ -161,6 +161,26 @@ impl LedgerService {
             .map_err(|err| CommonError::InvalidState(format!(""Invalid pool_config request json: {:?}"", err)))
     }
 
+    pub fn build_pool_restart(&self, identifier: &str, action: &str, schedule: Option<&str>) -> Result<String, CommonError> {
+        let schedule = match schedule {
+            Some(schedule) => Some(serde_json::from_str::<HashMap<String, String>>(schedule)",,2018-04-17 08:44:36,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/177801923,https://github.com/hyperledger/indy-sdk/pull/609#discussion_r177801923,Toktar
https://github.com/hyperledger/indy-sdk/pull/609,https://github.com/hyperledger/indy-sdk/pull/609,@SergeyPalamarchuk please re-check and fix sdk code if needed.,7e7c8d08bc43b91b47f672f75169782580c61305,2018-03-28 16:03:13,177802440,"@@ -161,6 +161,26 @@ impl LedgerService {
             .map_err(|err| CommonError::InvalidState(format!(""Invalid pool_config request json: {:?}"", err)))
     }
 
+    pub fn build_pool_restart(&self, identifier: &str, action: &str, schedule: Option<&str>) -> Result<String, CommonError> {
+        let schedule = match schedule {
+            Some(schedule) => Some(serde_json::from_str::<HashMap<String, String>>(schedule)",,2018-04-17 08:44:36,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/177802440,https://github.com/hyperledger/indy-sdk/pull/609#discussion_r177802440,jovfer
https://github.com/hyperledger/indy-sdk/pull/609,https://github.com/hyperledger/indy-sdk/pull/609,"@jovfer , @SergeyPalamarchuk , field 'schedule' was renamed to 'datetime'",7e7c8d08bc43b91b47f672f75169782580c61305,2018-03-28 16:07:22,177803797,"@@ -161,6 +161,26 @@ impl LedgerService {
             .map_err(|err| CommonError::InvalidState(format!(""Invalid pool_config request json: {:?}"", err)))
     }
 
+    pub fn build_pool_restart(&self, identifier: &str, action: &str, schedule: Option<&str>) -> Result<String, CommonError> {
+        let schedule = match schedule {
+            Some(schedule) => Some(serde_json::from_str::<HashMap<String, String>>(schedule)",,2018-04-17 08:44:36,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/177803797,https://github.com/hyperledger/indy-sdk/pull/609#discussion_r177803797,Toktar
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,Please re-check this point: just for install libindy sdk-deps should not be required. As it should be fully included into libindy distribution package,3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-19 07:50:04,175350945,"@@ -14,18 +14,63 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+## How-to-install
+### Instal for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT (change stable to `master` or `rc` if needed):
+    
+    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88
+    sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial stable""
+    sudo apt-get update
+    sudo apt-get install -y libindy
+    
+### Instal for Windows
+1. follow to https://repo.sovrin.org/windows/libindy.
+2. download last version of libindy and indy-sdk-deps.",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175350945,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175350945,jovfer
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,"Please re-check name of the environment variable. Most probably it's better to use different against Windows ""PATH""",3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-19 07:51:54,175351209,"@@ -14,18 +14,63 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+## How-to-install
+### Instal for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT (change stable to `master` or `rc` if needed):
+    
+    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88
+    sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial stable""
+    sudo apt-get update
+    sudo apt-get install -y libindy
+    
+### Instal for Windows
+1. follow to https://repo.sovrin.org/windows/libindy.
+2. download last version of libindy and indy-sdk-deps.
+3. unzip archives to directories, where you want to save working libraries.
+4. add to PATH enviroment variable path to that directories.
+
+### Instal for MacOS        
+Now we haven't prebuild library in some shared place. You can build
+library yourself. Please refer to How-to-build section. 
+After build add to PATH enviroment variable path to builded library.",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175351209,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175351209,jovfer
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,"Please re-check name of the environment variable. Most probably it's better to use different against Windows ""PATH""",3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-19 07:52:07,175351247,"@@ -14,18 +14,63 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+## How-to-install
+### Instal for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT (change stable to `master` or `rc` if needed):
+    
+    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88
+    sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial stable""
+    sudo apt-get update
+    sudo apt-get install -y libindy
+    
+### Instal for Windows
+1. follow to https://repo.sovrin.org/windows/libindy.
+2. download last version of libindy and indy-sdk-deps.
+3. unzip archives to directories, where you want to save working libraries.
+4. add to PATH enviroment variable path to that directories.
+
+### Instal for MacOS        
+Now we haven't prebuild library in some shared place. You can build
+library yourself. Please refer to How-to-build section. 
+After build add to PATH enviroment variable path to builded library.
+            
+### Instal for RHEL based distro (Amazon Linux 2017.03)           
+Now we haven't prebuild library in some shared place. You can build
+library yourself. Please refer to How-to-build section.
+After build add to PATH enviroment variable path to builded library.",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175351247,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175351247,jovfer
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,Also it would be nice to provide exact name (or pattern) of artifact,3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-19 09:11:23,175366340,"@@ -14,18 +14,63 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+## How-to-install
+### Instal for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT (change stable to `master` or `rc` if needed):
+    
+    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88
+    sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial stable""
+    sudo apt-get update
+    sudo apt-get install -y libindy
+    
+### Instal for Windows
+1. follow to https://repo.sovrin.org/windows/libindy.
+2. download last version of libindy and indy-sdk-deps.",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175366340,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175366340,vimmerru
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,"We should describe the motivation. Something like:

add to PATH enviroment variable path to that directories. It will allow dynamic linker to find libindy dynamic library.",3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-19 09:20:43,175368650,"@@ -14,18 +14,63 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+## How-to-install
+### Instal for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT (change stable to `master` or `rc` if needed):
+    
+    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88
+    sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial stable""
+    sudo apt-get update
+    sudo apt-get install -y libindy
+    
+### Instal for Windows
+1. follow to https://repo.sovrin.org/windows/libindy.
+2. download last version of libindy and indy-sdk-deps.
+3. unzip archives to directories, where you want to save working libraries.
+4. add to PATH enviroment variable path to that directories.",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175368650,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175368650,vimmerru
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,LD_LIBRARY_PATH and DYLD_LIBRARY_PATH should be set. Also we need add note that it allows dymamic and static linker to find the libirary,3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-19 09:21:29,175368846,"@@ -14,18 +14,63 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+## How-to-install
+### Instal for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT (change stable to `master` or `rc` if needed):
+    
+    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88
+    sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial stable""
+    sudo apt-get update
+    sudo apt-get install -y libindy
+    
+### Instal for Windows
+1. follow to https://repo.sovrin.org/windows/libindy.
+2. download last version of libindy and indy-sdk-deps.
+3. unzip archives to directories, where you want to save working libraries.
+4. add to PATH enviroment variable path to that directories.
+
+### Instal for MacOS        
+Now we haven't prebuild library in some shared place. You can build
+library yourself. Please refer to How-to-build section. 
+After build add to PATH enviroment variable path to builded library.",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175368846,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175368846,vimmerru
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,LD_LIBRARY_PATH and DYLD_LIBRARY_PATH should be set. Also we need add note that it allows dymamic and static linker to find the libirary,3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-19 09:21:34,175368865,"@@ -14,18 +14,63 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+## How-to-install
+### Instal for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT (change stable to `master` or `rc` if needed):
+    
+    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88
+    sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial stable""
+    sudo apt-get update
+    sudo apt-get install -y libindy
+    
+### Instal for Windows
+1. follow to https://repo.sovrin.org/windows/libindy.
+2. download last version of libindy and indy-sdk-deps.
+3. unzip archives to directories, where you want to save working libraries.
+4. add to PATH enviroment variable path to that directories.
+
+### Instal for MacOS        
+Now we haven't prebuild library in some shared place. You can build
+library yourself. Please refer to How-to-build section. 
+After build add to PATH enviroment variable path to builded library.
+            
+### Instal for RHEL based distro (Amazon Linux 2017.03)           
+Now we haven't prebuild library in some shared place. You can build
+library yourself. Please refer to How-to-build section.
+After build add to PATH enviroment variable path to builded library.",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175368865,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175368865,vimmerru
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,"I believe port mapping will work also. Also creation of custom network works on all platforms, but if interface is placed inside of VM it can be hard to access pool by this interface. We need to describe this motivation in a more clean way,",3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-19 09:23:24,175369278,"@@ -14,18 +14,63 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+## How-to-install
+### Instal for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT (change stable to `master` or `rc` if needed):
+    
+    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88
+    sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial stable""
+    sudo apt-get update
+    sudo apt-get install -y libindy
+    
+### Instal for Windows
+1. follow to https://repo.sovrin.org/windows/libindy.
+2. download last version of libindy and indy-sdk-deps.
+3. unzip archives to directories, where you want to save working libraries.
+4. add to PATH enviroment variable path to that directories.
+
+### Instal for MacOS        
+Now we haven't prebuild library in some shared place. You can build
+library yourself. Please refer to How-to-build section. 
+After build add to PATH enviroment variable path to builded library.
+            
+### Instal for RHEL based distro (Amazon Linux 2017.03)           
+Now we haven't prebuild library in some shared place. You can build
+library yourself. Please refer to How-to-build section.
+After build add to PATH enviroment variable path to builded library.
+
+## How-to-build
 
 * [Ubuntu based distro (Ubuntu 16.04)](doc/ubuntu-build.md)
 * [RHEL based distro (Amazon Linux 2017.03)](doc/rhel-build.md)
 * [Windows](doc/windows-build.md)
 * [MacOS](doc/mac-build.md)
 
+## How to start local nodes pool with docker
+
+Start local nodes pool on `127.0.0.1:9701-9708` with Docker:
+     
+     ```     
+     docker build -f ci/indy-pool.dockerfile -t indy_pool .
+     docker run -itd -p 9701-9708:9701-9708 indy_pool
+     ```     
+     
+ Ubuntu and Amazon Linux have another approach. Dockerfile `ci/indy-pool.dockerfile` ",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175369278,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175369278,vimmerru
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,We need to add section that describes release channels,3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-19 09:26:43,175370068,"@@ -14,18 +14,63 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join",1,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175370068,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175370068,vimmerru
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,Add also link to release-workflow.md,3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-19 09:27:58,175370409,"@@ -14,18 +14,63 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join",1,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175370409,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175370409,vimmerru
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,"sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial {release-channel}""

{release-channel} can be:

master - for master release channel
rc - for rc release channel
stable - for stable release channel",3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-19 09:29:54,175370916,"@@ -14,18 +14,63 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+## How-to-install
+### Instal for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT (change stable to `master` or `rc` if needed):",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175370916,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175370916,vimmerru
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,"""Instal"" --> ""Install"" (2 Ls)",3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-19 15:23:51,175475095,"@@ -14,18 +14,63 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+## How-to-install
+### Instal for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT (change stable to `master` or `rc` if needed):
+    
+    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88
+    sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial stable""
+    sudo apt-get update
+    sudo apt-get install -y libindy
+    
+### Instal for Windows
+1. follow to https://repo.sovrin.org/windows/libindy.
+2. download last version of libindy and indy-sdk-deps.",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175475095,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175475095,dhh1128
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,"Please spell ""install"" with 2 Ls",3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-19 15:27:10,175476379,"@@ -14,18 +14,63 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+## How-to-install
+### Instal for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT (change stable to `master` or `rc` if needed):",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175476379,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175476379,dhh1128
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,"@vimmerru may be we can make ""release channels"" section common for all platforms?
pros:
+ do not duplicate info

cons:
- user may skip this section and start reading from platform specific

My personal vision is make this section common and make `{release channel}` as link to the section",3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-20 08:02:13,175678724,"@@ -14,18 +14,111 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+## How to install
+### Install for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT:
+    
+    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88
+    sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial {release channel}""
+    sudo apt-get update
+    sudo apt-get install -y libindy
+#### Release channels",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175678724,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175678724,jovfer
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,"I believe release channels must be common section. And there can be:

{release channels} pointed pointed here may be one of these values: 
    
* `master` - for master release channel artifacts.
* `rc` - for rc release channel artifacts.
* `stable` - for stable release channel artifacts.

See <release-channels> section for details.",3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-20 08:45:18,175687610,"@@ -14,18 +14,111 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+## How to install
+### Install for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT:
+    
+    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88
+    sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial {release channel}""
+    sudo apt-get update
+    sudo apt-get install -y libindy
+#### Release channels",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175687610,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175687610,vimmerru
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,Formatting is broken here. See rendered version.,3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-20 08:45:52,175687720,"@@ -14,18 +14,111 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+## How to install
+### Install for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT:
+    
+    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88
+    sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial {release channel}""
+    sudo apt-get update
+    sudo apt-get install -y libindy
+#### Release channels
+{release channels} pointed in previous section may be one of these values: 
+    
+* `master` - development builds for each push to master branch.
+* `rc` - release candidates.
+* `stable` - stable releases.
+
+Please refer to [release workflow](doc/release-workflow.md) for more details.  
+   
+### Install for Windows
+
+1. follow to https://repo.sovrin.org/windows/libindy/{release-channel}.
+2. download last version of libindy.
+3. unzip archives to directory, where you want to save working library.
+4. After unzip you will get next structure of files:
+
+    
+    -Your working directory",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175687720,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175687720,vimmerru
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,"In fact we have 2 pod specs. 

- libindy and ObjectiveC wrapper. Let's discuss how to handle this.",3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-20 08:46:44,175687972,"@@ -14,18 +14,111 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+## How to install
+### Install for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT:
+    
+    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88
+    sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial {release channel}""
+    sudo apt-get update
+    sudo apt-get install -y libindy
+#### Release channels
+{release channels} pointed in previous section may be one of these values: 
+    
+* `master` - development builds for each push to master branch.
+* `rc` - release candidates.
+* `stable` - stable releases.
+
+Please refer to [release workflow](doc/release-workflow.md) for more details.  
+   
+### Install for Windows
+
+1. follow to https://repo.sovrin.org/windows/libindy/{release-channel}.
+2. download last version of libindy.
+3. unzip archives to directory, where you want to save working library.
+4. After unzip you will get next structure of files:
+
+    
+    -Your working directory
+        -include
+            ...
+        -lib
+            -indy.dll
+            -libeay32md.dll
+            -libsodium.dll
+            -libzmq.dll
+            -ssleay32md.dll
+            
+`include` contains c-header files which contains all necessary declarations
+that may be need for your applications. 
+
+`lib` contains all necessary binaries which contains libindy and all it's dependencies.
+ `You must add to PATH environment variable path to lib`. It's necessary for dynamic linkage
+ your application with libindy.       
+
+#### Release channels
+{release channels} pointed in previous section may be one of these values: 
+    
+* `master` - development builds for each push to master branch.
+* `rc` - release candidates.
+* `stable` - stable releases.
+
+Please refer to [release workflow](doc/release-workflow.md) for more details.
+
+### Install for MacOS        
+Now we haven't prebuild library in some shared place. You can build
+library yourself. Please refer to How-to-build section. 
+
+After build add to LD_LIBRARY_PATH and to DYLD_LIBRARY_PATH 
+environment variables path to builded library. It's necessary 
+for dynamic linkage your application with libindy. At first dynamic linker
+browse library in LD_LIBRARY_PATH, if library in your application doesn't include directory names.
+If library in your application include any directory name, then dynamic linker will search library
+in DYLD_LIBRARY_PATH(not LD_LIBRARY_PATH). So for reliability we recommend you set both this variables.
+            
+### Install for RHEL based distro (Amazon Linux 2017.03)           
+Now we haven't prebuild library in some shared place. You can build
+library yourself. Please refer to How-to-build section.
+
+After build add to LD_LIBRARY_PATH environment variable path to builded library. 
+It's necessary for dynamic linkage your application with libindy.
+
+## How to build
 
 * [Ubuntu based distro (Ubuntu 16.04)](doc/ubuntu-build.md)
 * [RHEL based distro (Amazon Linux 2017.03)](doc/rhel-build.md)
 * [Windows](doc/windows-build.md)
 * [MacOS](doc/mac-build.md)
 
+## How to start local nodes pool with docker
+
+Start local nodes pool on `127.0.0.1:9701-9708` with Docker:
+     
+     ```     
+     docker build -f ci/indy-pool.dockerfile -t indy_pool .
+     docker run -itd -p 9701-9708:9701-9708 indy_pool
+     ```     
+     
+ Dockerfile `ci/indy-pool.dockerfile` supports optional pool_ip param that allows 
+ changing ip of pool nodes in generated pool configuration. The following commands 
+ allow to start local nodes pool in custom docker network and access this pool 
+ by custom ip in docker network:
+     
+     ```
+     docker network create --subnet 10.0.0.0/8 indy_pool_network
+     docker build --build-arg pool_ip=10.0.0.2 -f ci/indy-pool.dockerfile -t indy_pool .
+     docker run -d --ip=""10.0.0.2"" --net=indy_pool_network indy_pool
+     ``` 
+ Note that for Windows and MacOS this approach have some issues. Docker for these OS run in
+ their virtual environment. First command creates network for container and host can't
+ get access to that network because container placed on virtual machine. You must appropriate set up 
+ networking on your virtual environment.
+
 ## Wrappers documentation
 * [.Net](wrappers/dotnet/README.md)
 * [Java](wrappers/java/README.md)
 * [Python](wrappers/python/README.md)
-* [iOS](wrappers/ios/ios-build.md)
+* [iOS](wrappers/ios/README.md)",111,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175687972,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175687972,vimmerru
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,I believe we need additional section Hot to run samples,3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-20 08:47:43,175688186,"@@ -14,18 +14,111 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+## How to install
+### Install for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT:
+    
+    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88
+    sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial {release channel}""
+    sudo apt-get update
+    sudo apt-get install -y libindy
+#### Release channels
+{release channels} pointed in previous section may be one of these values: 
+    
+* `master` - development builds for each push to master branch.
+* `rc` - release candidates.
+* `stable` - stable releases.
+
+Please refer to [release workflow](doc/release-workflow.md) for more details.  
+   
+### Install for Windows
+
+1. follow to https://repo.sovrin.org/windows/libindy/{release-channel}.
+2. download last version of libindy.
+3. unzip archives to directory, where you want to save working library.
+4. After unzip you will get next structure of files:
+
+    
+    -Your working directory
+        -include
+            ...
+        -lib
+            -indy.dll
+            -libeay32md.dll
+            -libsodium.dll
+            -libzmq.dll
+            -ssleay32md.dll
+            
+`include` contains c-header files which contains all necessary declarations
+that may be need for your applications. 
+
+`lib` contains all necessary binaries which contains libindy and all it's dependencies.
+ `You must add to PATH environment variable path to lib`. It's necessary for dynamic linkage
+ your application with libindy.       
+
+#### Release channels
+{release channels} pointed in previous section may be one of these values: 
+    
+* `master` - development builds for each push to master branch.
+* `rc` - release candidates.
+* `stable` - stable releases.
+
+Please refer to [release workflow](doc/release-workflow.md) for more details.
+
+### Install for MacOS        
+Now we haven't prebuild library in some shared place. You can build
+library yourself. Please refer to How-to-build section. 
+
+After build add to LD_LIBRARY_PATH and to DYLD_LIBRARY_PATH 
+environment variables path to builded library. It's necessary 
+for dynamic linkage your application with libindy. At first dynamic linker
+browse library in LD_LIBRARY_PATH, if library in your application doesn't include directory names.
+If library in your application include any directory name, then dynamic linker will search library
+in DYLD_LIBRARY_PATH(not LD_LIBRARY_PATH). So for reliability we recommend you set both this variables.
+            
+### Install for RHEL based distro (Amazon Linux 2017.03)           
+Now we haven't prebuild library in some shared place. You can build
+library yourself. Please refer to How-to-build section.
+
+After build add to LD_LIBRARY_PATH environment variable path to builded library. 
+It's necessary for dynamic linkage your application with libindy.
+
+## How to build
 
 * [Ubuntu based distro (Ubuntu 16.04)](doc/ubuntu-build.md)
 * [RHEL based distro (Amazon Linux 2017.03)](doc/rhel-build.md)
 * [Windows](doc/windows-build.md)
 * [MacOS](doc/mac-build.md)
 
+## How to start local nodes pool with docker
+
+Start local nodes pool on `127.0.0.1:9701-9708` with Docker:
+     
+     ```     
+     docker build -f ci/indy-pool.dockerfile -t indy_pool .
+     docker run -itd -p 9701-9708:9701-9708 indy_pool
+     ```     
+     
+ Dockerfile `ci/indy-pool.dockerfile` supports optional pool_ip param that allows 
+ changing ip of pool nodes in generated pool configuration. The following commands 
+ allow to start local nodes pool in custom docker network and access this pool 
+ by custom ip in docker network:
+     
+     ```
+     docker network create --subnet 10.0.0.0/8 indy_pool_network
+     docker build --build-arg pool_ip=10.0.0.2 -f ci/indy-pool.dockerfile -t indy_pool .
+     docker run -d --ip=""10.0.0.2"" --net=indy_pool_network indy_pool
+     ``` 
+ Note that for Windows and MacOS this approach have some issues. Docker for these OS run in
+ their virtual environment. First command creates network for container and host can't
+ get access to that network because container placed on virtual machine. You must appropriate set up 
+ networking on your virtual environment.
+
 ## Wrappers documentation",106,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175688186,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175688186,vimmerru
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,invalid formatting,3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-20 14:48:51,175794145,"@@ -14,37 +14,113 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+
+## How to install
+### Release channels
+May be one of these values: 
+    
+* `master` - development builds for each push to master branch.
+* `rc` - release candidates.
+* `stable` - stable releases.
+
+Please refer to [release workflow](doc/release-workflow.md) for more details.
+### Install for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT:
+    
+    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88
+    sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial {release channel}""
+    sudo apt-get update
+    sudo apt-get install -y libindy
+
+See section ""Release channels"" for more details about {release channel}.  
+   
+### Install for Windows
+
+1. follow to https://repo.sovrin.org/windows/libindy/{release-channel}.
+2. download last version of libindy.
+3. unzip archives to directory, where you want to save working library.
+4. After unzip you will get next structure of files:
+
+    
+* `Your working directory`
+    * `include`
+        * `...`
+    * `lib`
+        * `indy.dll`
+        * `libeay32md.dll`
+        * `libsodium.dll`
+        * `libzmq.dll`
+        * `ssleay32md.dll`
+            
+`include` contains c-header files which contains all necessary declarations
+that may be need for your applications. 
+
+`lib` contains all necessary binaries which contains libindy and all it's dependencies.
+ `You must add to PATH environment variable path to lib`. It's necessary for dynamic linkage
+ your application with libindy.       
+
+See section ""Release channels"" for more details about {release channel}.
+### Install for iOS
+
+See [wrapper iOS install documentation](wrappers/ios/README.md ""How to install"").
+
+### Install for MacOS        
+Now we haven't prebuild library in some shared place. You can build
+library yourself. Please refer to How-to-build section. 
+
+After build add to LD_LIBRARY_PATH and to DYLD_LIBRARY_PATH 
+environment variables path to builded library. It's necessary 
+for dynamic linkage your application with libindy. At first dynamic linker
+browse library in LD_LIBRARY_PATH, if library in your application doesn't include directory names.
+If library in your application include any directory name, then dynamic linker will search library
+in DYLD_LIBRARY_PATH(not LD_LIBRARY_PATH). So for reliability we recommend you set both this variables.
+            
+### Install for RHEL based distro (Amazon Linux 2017.03)           
+Now we haven't prebuild library in some shared place. You can build
+library yourself. Please refer to How-to-build section.
+
+After build add to LD_LIBRARY_PATH environment variable path to builded library. 
+It's necessary for dynamic linkage your application with libindy.
+
+## How to build
 
 * [Ubuntu based distro (Ubuntu 16.04)](doc/ubuntu-build.md)
 * [RHEL based distro (Amazon Linux 2017.03)](doc/rhel-build.md)
 * [Windows](doc/windows-build.md)
 * [MacOS](doc/mac-build.md)
 
+## How to start local nodes pool with docker
+
+Start local nodes pool on `127.0.0.1:9701-9708` with Docker:
+     
+     ```     
+     docker build -f ci/indy-pool.dockerfile -t indy_pool .
+     docker run -itd -p 9701-9708:9701-9708 indy_pool
+     ```     
+     
+ Dockerfile `ci/indy-pool.dockerfile` supports optional pool_ip param that allows 
+ changing ip of pool nodes in generated pool configuration. The following commands 
+ allow to start local nodes pool in custom docker network and access this pool 
+ by custom ip in docker network:
+     
+     ```",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175794145,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175794145,jovfer
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,invalid formatting,3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-20 14:49:05,175794229,"@@ -14,37 +14,113 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+
+## How to install
+### Release channels
+May be one of these values: 
+    
+* `master` - development builds for each push to master branch.
+* `rc` - release candidates.
+* `stable` - stable releases.
+
+Please refer to [release workflow](doc/release-workflow.md) for more details.
+### Install for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT:
+    
+    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88
+    sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial {release channel}""
+    sudo apt-get update
+    sudo apt-get install -y libindy
+
+See section ""Release channels"" for more details about {release channel}.  
+   
+### Install for Windows
+
+1. follow to https://repo.sovrin.org/windows/libindy/{release-channel}.
+2. download last version of libindy.
+3. unzip archives to directory, where you want to save working library.
+4. After unzip you will get next structure of files:
+
+    
+* `Your working directory`
+    * `include`
+        * `...`
+    * `lib`
+        * `indy.dll`
+        * `libeay32md.dll`
+        * `libsodium.dll`
+        * `libzmq.dll`
+        * `ssleay32md.dll`
+            
+`include` contains c-header files which contains all necessary declarations
+that may be need for your applications. 
+
+`lib` contains all necessary binaries which contains libindy and all it's dependencies.
+ `You must add to PATH environment variable path to lib`. It's necessary for dynamic linkage
+ your application with libindy.       
+
+See section ""Release channels"" for more details about {release channel}.
+### Install for iOS
+
+See [wrapper iOS install documentation](wrappers/ios/README.md ""How to install"").
+
+### Install for MacOS        
+Now we haven't prebuild library in some shared place. You can build
+library yourself. Please refer to How-to-build section. 
+
+After build add to LD_LIBRARY_PATH and to DYLD_LIBRARY_PATH 
+environment variables path to builded library. It's necessary 
+for dynamic linkage your application with libindy. At first dynamic linker
+browse library in LD_LIBRARY_PATH, if library in your application doesn't include directory names.
+If library in your application include any directory name, then dynamic linker will search library
+in DYLD_LIBRARY_PATH(not LD_LIBRARY_PATH). So for reliability we recommend you set both this variables.
+            
+### Install for RHEL based distro (Amazon Linux 2017.03)           
+Now we haven't prebuild library in some shared place. You can build
+library yourself. Please refer to How-to-build section.
+
+After build add to LD_LIBRARY_PATH environment variable path to builded library. 
+It's necessary for dynamic linkage your application with libindy.
+
+## How to build
 
 * [Ubuntu based distro (Ubuntu 16.04)](doc/ubuntu-build.md)
 * [RHEL based distro (Amazon Linux 2017.03)](doc/rhel-build.md)
 * [Windows](doc/windows-build.md)
 * [MacOS](doc/mac-build.md)
 
+## How to start local nodes pool with docker
+
+Start local nodes pool on `127.0.0.1:9701-9708` with Docker:
+     
+     ```     ",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175794229,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175794229,jovfer
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,Please fix inconsistent phrase moved from other place,3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-20 14:50:21,175794704,"@@ -14,37 +14,113 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+
+## How to install
+### Release channels
+May be one of these values: ",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175794704,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175794704,jovfer
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,"We are talking here about release channels, not about values that will be used as patterns. ",3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-20 14:51:06,175794963,"@@ -14,37 +14,113 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+
+## How to install
+### Release channels
+May be one of these values: ",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175794963,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r175794963,vimmerru
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,"Still unclear. Just change to:

Indy SDK release process defines the following release channels:

    master - development builds for each push to master branch
    rc - release candidates
    stable - stable releases",3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-21 13:13:18,176075056,"@@ -14,37 +14,113 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+
+## How to install
+### Release channels
+There are three stable channels: ",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/176075056,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r176075056,vimmerru
https://github.com/hyperledger/indy-sdk/pull/572,https://github.com/hyperledger/indy-sdk/pull/572,"> See section ""Release channels"" for more details about {release channel}.  

Also unclear. Just write:

{release channel} must be replaced with master, rc or stable to define corresponded release channel. See link to release channels section",3fa8c4784c2d15294386ba399f9722d9b7ff0675,2018-03-21 13:14:50,176075527,"@@ -14,37 +14,113 @@ All bugs, stories, and backlog for this project are managed through [Hyperledger
 in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
 us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to discuss.
 
-## Building Indy SDK
+
+## How to install
+### Release channels
+There are three stable channels: 
+    
+* `master` - development builds for each push to master branch.
+* `rc` - release candidates.
+* `stable` - stable releases.
+
+Please refer to [release workflow](doc/release-workflow.md) for more details.
+### Install for Ubuntu based distro (Ubuntu 16.04)
+It is recommended to install packages with APT:
+    
+    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 68DB5E88
+    sudo add-apt-repository ""deb https://repo.sovrin.org/sdk/deb xenial {release channel}""
+    sudo apt-get update
+    sudo apt-get install -y libindy
+
+See section ""Release channels"" for more details about {release channel}.  ",,2018-03-21 22:31:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/176075527,https://github.com/hyperledger/indy-sdk/pull/572#discussion_r176075527,vimmerru
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,"What about what entities should be stored in wallet vs. multiple wallets vs. some storage?
Is it up to the app where to store, for example, claims?

I think there are 2 main options possible:
1) Only secrets (private, master secret) are stored in the wallet on libindy level. All other entities are assumed to be stored on app level.
2) Everything is stored in the wallet on libindy level. Here we assume that each libindy call works with **one** wallet only, so that by providing a proper wallet_handle, the app can decide what kind of wallet/implementation needs to be used. Here the wallet may mean something more general (like just a storage with optional security properties).
",9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-03-07 08:29:00,172768649,"@@ -0,0 +1,255 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/172768649,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r172768649,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,"What keys will be used for encryption? Where are they persisted? How libindy has access to them? Are there different keys, or one fey for the whole wallet?",9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-03-07 08:32:24,172769391,"@@ -0,0 +1,255 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation
+* Perform all encryption on libindy level:",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/172769391,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r172769391,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,"Do we consider that Wallet interface is public, so that the App can set/get/addTags to the wallet?",9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-03-07 08:33:09,172769537,"@@ -0,0 +1,255 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation
+* Perform all encryption on libindy level:
+  * Entity ids will be always encrypted
+  * Entity values will be always encrypted
+  * Entity metadata will be always encrypted
+  * Tag names will be always encrypted
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can be possible
+    to include some additional un-encrypted tags
+* Allow plugging of different storages",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/172769537,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r172769537,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,"I think we need to have a diagram/doc that lists all libindy calls and how they work with the Wallet.
I think it confuses community a lot, where some methods doesn't work with wallet at all, some work with them quite expectedly, and some may have access to the wallet implicitly and surprisingly (like caches, etc.).
I think it will not only provide a better documentation and help community to understand the API, but also can check whether we always work with just ONE wallet at a time (so, we can support Case 2 from the comment above).
",9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-03-07 08:38:34,172770666,"@@ -0,0 +1,255 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+## Goals and ideas",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/172770666,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r172770666,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,I think we should have one master-key per wallet (stored in some hardware storage if possible) and derive individual keys for individual records.,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-03-07 10:48:14,172803792,"@@ -0,0 +1,255 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation
+* Perform all encryption on libindy level:",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/172803792,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r172803792,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,I think get should be restricted to some extent.,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-03-07 10:50:03,172804254,"@@ -0,0 +1,255 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation
+* Perform all encryption on libindy level:
+  * Entity ids will be always encrypted
+  * Entity values will be always encrypted
+  * Entity metadata will be always encrypted
+  * Tag names will be always encrypted
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can be possible
+    to include some additional un-encrypted tags
+* Allow plugging of different storages",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/172804254,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r172804254,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,I would like not to have separate metadata but instead to include it in the value.,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-03-07 10:51:15,172804589,"@@ -0,0 +1,255 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation
+* Perform all encryption on libindy level:
+  * Entity ids will be always encrypted
+  * Entity values will be always encrypted
+  * Entity metadata will be always encrypted",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/172804589,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r172804589,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,How this optional feature would work? Per record?,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-03-07 10:51:59,172804817,"@@ -0,0 +1,255 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation
+* Perform all encryption on libindy level:
+  * Entity ids will be always encrypted
+  * Entity values will be always encrypted
+  * Entity metadata will be always encrypted
+  * Tag names will be always encrypted
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can be possible",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/172804817,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r172804817,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,I am not sure about credentials. Maybe they should be included into config?,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-03-07 10:52:54,172805035,"@@ -0,0 +1,255 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation
+* Perform all encryption on libindy level:
+  * Entity ids will be always encrypted
+  * Entity values will be always encrypted
+  * Entity metadata will be always encrypted
+  * Tag names will be always encrypted
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can be possible
+    to include some additional un-encrypted tags
+* Allow plugging of different storages
+* Allow efficient and flexible search for entities
+* Allow pagination
+* Native OpenSSL style object-oriented C interface
+* Try to avoid unnecessary json and re-allocation
+
+## Interface Entities
+
+<img src=""./wallet-storage.svg"">
+
+## C Interface
+
+To plug wallet storage user should implement and register the following C callbacks:
+
+### Wallet Storage Type API
+
+```Rust
+/// Create the wallet storage (For example, database creation)
+///
+/// name: wallet storage name (the same as wallet name)
+/// config: wallet storage config (For example, database config)
+/// credentials: wallet storage credentials (For example, database credentials)
+extern fn create_wallet_storage(name: *const c_char,
+                                config: *const c_char,
+                                credentials: *const c_char) -> ErrorCode",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/172805035,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r172805035,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,Regex search will limit our storage options a lot. :),9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-03-07 11:06:50,172808609,"@@ -0,0 +1,255 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation
+* Perform all encryption on libindy level:
+  * Entity ids will be always encrypted
+  * Entity values will be always encrypted
+  * Entity metadata will be always encrypted
+  * Tag names will be always encrypted
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can be possible
+    to include some additional un-encrypted tags
+* Allow plugging of different storages
+* Allow efficient and flexible search for entities
+* Allow pagination
+* Native OpenSSL style object-oriented C interface
+* Try to avoid unnecessary json and re-allocation
+
+## Interface Entities
+
+<img src=""./wallet-storage.svg"">
+
+## C Interface
+
+To plug wallet storage user should implement and register the following C callbacks:
+
+### Wallet Storage Type API
+
+```Rust
+/// Create the wallet storage (For example, database creation)
+///
+/// name: wallet storage name (the same as wallet name)
+/// config: wallet storage config (For example, database config)
+/// credentials: wallet storage credentials (For example, database credentials)
+extern fn create_wallet_storage(name: *const c_char,
+                                config: *const c_char,
+                                credentials: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Delete the wallet storage (For example, database deletion)
+///
+/// name: wallet storage name (the same as wallet name)
+/// config: wallet storage config (For example, database config)
+/// credentials: wallet storage credentials (For example, database credentials)
+extern fn delete_wallet_storage(name: *const c_char,
+                                config: *const c_char,
+                                credentials: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Open the wallet storage (For example, opening database connection)
+///
+/// name: wallet storage name (the same as wallet name)
+/// config: wallet storage config (For example, database config)
+/// runtime_config: wallet storage runtime config (For example, connection config)
+/// credentials: wallet storage credentials (For example, database credentials)
+/// storage_handle_p: pointer to store opened storage handle
+extern fn open_wallet_storage(name: *const c_char,
+                              config: *const c_char,
+                              runtime_config: *const c_char,
+                              credentials: *const c_char,
+                              storage_handle_p: *mut u32) -> ErrorCode
+```
+
+### Wallet Storage API
+
+```Rust
+/// Create a new entity in the wallet storage
+///
+/// storage_handle: opened storage handle (See open_wallet_storage)
+/// type_: allows to separate different entity types collections
+/// id: the id of entity
+/// value: the value of entity
+/// metadata: (optional) the entity metadata
+/// tags: (optional) the entity tags used for search as json:
+///  {
+///    ""tagName1"": ""tag value 1"", // string value
+///    ""tagName2"": 123, // numeric value
+///  }
+extern fn wallet_storage_create_wallet_entity(storage_handle: u32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              metadata: *const c_char,
+                                              tags: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Update an existing entity in the wallet storage
+///
+/// storage_handle: opened storage handle (See open_wallet_storage)
+/// type_: allows to separate different entity types collections
+/// id: the id of entity
+/// value: (optional) the new value of entity
+/// metadata: (optional) the new entity metadata
+/// tags: (optional) the new entity tags (see wallet_storage_create_wallet_entity)
+extern fn wallet_storage_update_wallet_entity(storage_handle: u32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              metadata: *const c_char,
+                                              tags: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Delete an existing entity in the wallet storage
+///
+/// storage_handle: opened storage handle (See open_wallet_storage)
+/// type_: allows to separate different entity types collections
+/// id: the id of entity
+extern fn wallet_storage_delete_wallet_entity(storage_handle: u32,
+                                              type_: *const c_char,
+                                              id: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Get an wallet entity by id
+///
+/// storage_handle: opened storage handle (See open_wallet_storage)
+/// type_: allows to separate different entity types collections
+/// id: the id of entity
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve entity value,
+///    retrieveMetadata: (optional, true by default) Retrieve entity metadata
+///  }
+/// entity_handle_p: pointer to store retrieved entity handle
+extern fn wallet_storage_get_wallet_entity(storage_handle: u32,
+                                           type_: *const c_char,
+                                           id: *const c_char,
+                                           options_json: *const c_char,
+                                           entity_handle_p: *mut u32) -> ErrorCode
+```
+
+```Rust
+/// Search for wallet entities
+///
+/// storage_handle: opened storage handle (See open_wallet_storage)
+/// type_: allows to separate different entity types collections
+/// id: the id of entity
+/// query_json: MongoDB style query to wallet entity tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/172808609,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r172808609,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,You are thinking that search could return such many values to justify complicating the interface?,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-03-07 11:07:31,172808760,"@@ -0,0 +1,255 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation
+* Perform all encryption on libindy level:
+  * Entity ids will be always encrypted
+  * Entity values will be always encrypted
+  * Entity metadata will be always encrypted
+  * Tag names will be always encrypted
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can be possible
+    to include some additional un-encrypted tags
+* Allow plugging of different storages
+* Allow efficient and flexible search for entities
+* Allow pagination
+* Native OpenSSL style object-oriented C interface
+* Try to avoid unnecessary json and re-allocation
+
+## Interface Entities
+
+<img src=""./wallet-storage.svg"">
+
+## C Interface
+
+To plug wallet storage user should implement and register the following C callbacks:
+
+### Wallet Storage Type API
+
+```Rust
+/// Create the wallet storage (For example, database creation)
+///
+/// name: wallet storage name (the same as wallet name)
+/// config: wallet storage config (For example, database config)
+/// credentials: wallet storage credentials (For example, database credentials)
+extern fn create_wallet_storage(name: *const c_char,
+                                config: *const c_char,
+                                credentials: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Delete the wallet storage (For example, database deletion)
+///
+/// name: wallet storage name (the same as wallet name)
+/// config: wallet storage config (For example, database config)
+/// credentials: wallet storage credentials (For example, database credentials)
+extern fn delete_wallet_storage(name: *const c_char,
+                                config: *const c_char,
+                                credentials: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Open the wallet storage (For example, opening database connection)
+///
+/// name: wallet storage name (the same as wallet name)
+/// config: wallet storage config (For example, database config)
+/// runtime_config: wallet storage runtime config (For example, connection config)
+/// credentials: wallet storage credentials (For example, database credentials)
+/// storage_handle_p: pointer to store opened storage handle
+extern fn open_wallet_storage(name: *const c_char,
+                              config: *const c_char,
+                              runtime_config: *const c_char,
+                              credentials: *const c_char,
+                              storage_handle_p: *mut u32) -> ErrorCode
+```
+
+### Wallet Storage API
+
+```Rust
+/// Create a new entity in the wallet storage
+///
+/// storage_handle: opened storage handle (See open_wallet_storage)
+/// type_: allows to separate different entity types collections
+/// id: the id of entity
+/// value: the value of entity
+/// metadata: (optional) the entity metadata
+/// tags: (optional) the entity tags used for search as json:
+///  {
+///    ""tagName1"": ""tag value 1"", // string value
+///    ""tagName2"": 123, // numeric value
+///  }
+extern fn wallet_storage_create_wallet_entity(storage_handle: u32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              metadata: *const c_char,
+                                              tags: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Update an existing entity in the wallet storage
+///
+/// storage_handle: opened storage handle (See open_wallet_storage)
+/// type_: allows to separate different entity types collections
+/// id: the id of entity
+/// value: (optional) the new value of entity
+/// metadata: (optional) the new entity metadata
+/// tags: (optional) the new entity tags (see wallet_storage_create_wallet_entity)
+extern fn wallet_storage_update_wallet_entity(storage_handle: u32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              metadata: *const c_char,
+                                              tags: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Delete an existing entity in the wallet storage
+///
+/// storage_handle: opened storage handle (See open_wallet_storage)
+/// type_: allows to separate different entity types collections
+/// id: the id of entity
+extern fn wallet_storage_delete_wallet_entity(storage_handle: u32,
+                                              type_: *const c_char,
+                                              id: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Get an wallet entity by id
+///
+/// storage_handle: opened storage handle (See open_wallet_storage)
+/// type_: allows to separate different entity types collections
+/// id: the id of entity
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve entity value,
+///    retrieveMetadata: (optional, true by default) Retrieve entity metadata
+///  }
+/// entity_handle_p: pointer to store retrieved entity handle
+extern fn wallet_storage_get_wallet_entity(storage_handle: u32,
+                                           type_: *const c_char,
+                                           id: *const c_char,
+                                           options_json: *const c_char,
+                                           entity_handle_p: *mut u32) -> ErrorCode
+```
+
+```Rust
+/// Search for wallet entities
+///
+/// storage_handle: opened storage handle (See open_wallet_storage)
+/// type_: allows to separate different entity types collections
+/// id: the id of entity
+/// query_json: MongoDB style query to wallet entity tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    skip: (optional, 0 by default) Skip first ""skip"" wallet entities,
+///    limit: (optional, 100 by default) limit amount of entities to retrieve,
+///    retrieveEntities: (optional, true by default) If false only ""counts"" will be calculated,
+///    retrieveValue: (optional, true by default) Retrieve entity value,
+///    retrieveMetadata: (optional, true by default) Retrieve entity metadata,
+///  }
+/// search_handle_p: pointer to store wallet search handle
+extern fn wallet_storage_search_entities(storage_handle: u32,",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/172808760,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r172808760,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,Please remove IDE settings from the repo,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-03-16 07:59:08,175017999,"@@ -0,0 +1,15 @@
+{",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175017999,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r175017999,jovfer
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,"Maybe it is better to have set() instead of create() and update(). Semantic is: set() would overwrite the item if present, and create one if not. So it would not be possible to update partial (only tags or similar) but I cannot figure out need for such use case. I guess for code using the wallet it would also be easier.",9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-03-16 14:47:02,175112762,"@@ -0,0 +1,284 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Entity ids will be always encrypted.
+  * Entity values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secret Entities API
+
+It is our existing endpoints for secrets creation and access like indy_create_and_store_did
+or indy_create_and_store_cred_def. Endpoints:
+
+1. Allow to create a secret into the wallet
+1. Return entity id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Generic Wallet API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+TODO: FIXME: Define it!!!
+
+## Storage Interface
+
+Interface entities are:
+
+![Storage Interface](./storage-interface.svg)
+
+To plug wallet storage user should implement and register the following C callbacks:
+
+```Rust
+/// Create the wallet storage (For example, database creation)
+///
+/// name: wallet storage name (the same as wallet name)
+/// config: wallet storage config (For example, database config)
+/// credentials: wallet storage credentials (For example, database credentials)
+extern fn create_wallet_storage(name: *const c_char,
+                                config: *const c_char,
+                                credentials: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Delete the wallet storage (For example, database deletion)
+///
+/// name: wallet storage name (the same as wallet name)
+/// config: wallet storage config (For example, database config)
+/// credentials: wallet storage credentials (For example, database credentials)
+extern fn delete_wallet_storage(name: *const c_char,
+                                config: *const c_char,
+                                credentials: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Open the wallet storage (For example, opening database connection)
+///
+/// name: wallet storage name (the same as wallet name)
+/// config: wallet storage config (For example, database config)
+/// runtime_config: wallet storage runtime config (For example, connection config)
+/// credentials: wallet storage credentials (For example, database credentials)
+/// storage_handle_p: pointer to store opened storage handle
+extern fn open_wallet_storage(name: *const c_char,
+                              config: *const c_char,
+                              runtime_config: *const c_char,
+                              credentials: *const c_char,
+                              storage_handle_p: *mut u32) -> ErrorCode
+```
+
+```Rust
+/// Create a new entity in the wallet storage
+///
+/// storage_handle: opened storage handle (See open_wallet_storage)
+/// type_: allows to separate different entity types collections
+/// id: the id of entity
+/// value: the value of entity
+/// tags: (optional) the entity tags used for search as json:
+///  {
+///    ""tagName1"": ""tag value 1"", // string value
+///    ""tagName2"": 123, // numeric value
+///  }
+extern fn wallet_storage_create_wallet_entity(storage_handle: u32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              tags: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Update an existing entity in the wallet storage
+///
+/// storage_handle: opened storage handle (See open_wallet_storage)
+/// type_: allows to separate different entity types collections
+/// id: the id of entity
+/// value: (optional) the new value of entity
+/// tags: (optional) the new entity tags (see wallet_storage_create_wallet_entity)
+extern fn wallet_storage_update_wallet_entity(storage_handle: u32,",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175112762,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r175112762,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,skip and limit have no point without order_by. Also I am not sure all database (no-sql?) have abilities for ordering the data.,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-03-19 11:20:07,175400783,"@@ -0,0 +1,284 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Entity ids will be always encrypted.
+  * Entity values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secret Entities API
+
+It is our existing endpoints for secrets creation and access like indy_create_and_store_did
+or indy_create_and_store_cred_def. Endpoints:
+
+1. Allow to create a secret into the wallet
+1. Return entity id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Generic Wallet API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+TODO: FIXME: Define it!!!
+
+## Storage Interface
+
+Interface entities are:
+
+![Storage Interface](./storage-interface.svg)
+
+To plug wallet storage user should implement and register the following C callbacks:
+
+```Rust
+/// Create the wallet storage (For example, database creation)
+///
+/// name: wallet storage name (the same as wallet name)
+/// config: wallet storage config (For example, database config)
+/// credentials: wallet storage credentials (For example, database credentials)
+extern fn create_wallet_storage(name: *const c_char,
+                                config: *const c_char,
+                                credentials: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Delete the wallet storage (For example, database deletion)
+///
+/// name: wallet storage name (the same as wallet name)
+/// config: wallet storage config (For example, database config)
+/// credentials: wallet storage credentials (For example, database credentials)
+extern fn delete_wallet_storage(name: *const c_char,
+                                config: *const c_char,
+                                credentials: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Open the wallet storage (For example, opening database connection)
+///
+/// name: wallet storage name (the same as wallet name)
+/// config: wallet storage config (For example, database config)
+/// runtime_config: wallet storage runtime config (For example, connection config)
+/// credentials: wallet storage credentials (For example, database credentials)
+/// storage_handle_p: pointer to store opened storage handle
+extern fn open_wallet_storage(name: *const c_char,
+                              config: *const c_char,
+                              runtime_config: *const c_char,
+                              credentials: *const c_char,
+                              storage_handle_p: *mut u32) -> ErrorCode
+```
+
+```Rust
+/// Create a new entity in the wallet storage
+///
+/// storage_handle: opened storage handle (See open_wallet_storage)
+/// type_: allows to separate different entity types collections
+/// id: the id of entity
+/// value: the value of entity
+/// tags: (optional) the entity tags used for search as json:
+///  {
+///    ""tagName1"": ""tag value 1"", // string value
+///    ""tagName2"": 123, // numeric value
+///  }
+extern fn wallet_storage_create_wallet_entity(storage_handle: u32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              tags: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Update an existing entity in the wallet storage
+///
+/// storage_handle: opened storage handle (See open_wallet_storage)
+/// type_: allows to separate different entity types collections
+/// id: the id of entity
+/// value: (optional) the new value of entity
+/// tags: (optional) the new entity tags (see wallet_storage_create_wallet_entity)
+extern fn wallet_storage_update_wallet_entity(storage_handle: u32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              tags: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Delete an existing entity in the wallet storage
+///
+/// storage_handle: opened storage handle (See open_wallet_storage)
+/// type_: allows to separate different entity types collections
+/// id: the id of entity
+extern fn wallet_storage_delete_wallet_entity(storage_handle: u32,
+                                              type_: *const c_char,
+                                              id: *const c_char) -> ErrorCode
+```
+
+```Rust
+/// Get an wallet entity by id
+///
+/// storage_handle: opened storage handle (See open_wallet_storage)
+/// type_: allows to separate different entity types collections
+/// id: the id of entity
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve entity value,
+///    retrieveTags: (optional, true by default) Retrieve entity tags
+///  }
+/// entity_handle_p: pointer to store retrieved entity handle
+extern fn wallet_storage_get_wallet_entity(storage_handle: u32,
+                                           type_: *const c_char,
+                                           id: *const c_char,
+                                           options_json: *const c_char,
+                                           entity_handle_p: *mut u32) -> ErrorCode
+```
+
+```Rust
+/// Search for wallet entities
+///
+/// storage_handle: opened storage handle (See open_wallet_storage)
+/// type_: allows to separate different entity types collections
+/// id: the id of entity
+/// query_json: MongoDB style query to wallet entity tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    skip: (optional, 0 by default) Skip first ""skip"" wallet entities,",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/175400783,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r175400783,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,"type_, id, value are encrypted and binary so they cannot be transfered as null terminated strings (they could contain null bytes inside of cypher text). We should either pass size with every parameter or convert them to base64 or similar. I do not like conversion because it adds unnecessary steps of encoding/decoding.",9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-10 08:47:48,180340221,"@@ -0,0 +1,724 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Record ids will be always encrypted.
+  * Record values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secrets API
+
+It is our existing endpoints for secrets creation and access like ```indy_create_and_store_did``` or ```indy_create_and_store_cred_def```:
+
+1. Allow to create a secret into the wallet
+1. Return record id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Non-secrets API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+```Rust
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": ""tag value 1"", // string value
+///     ""tagName2"": 123, // numeric value
+///   }
+///   Note that null means no tags
+extern pub fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+extern pub fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the new record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": ""tag value 1"", // string value
+///     ""tagName2"": 123, // numeric value
+///   }
+///   Note that null means no tags
+extern pub fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the additional record tags as json:
+///   {
+///     ""tagName1"": ""tag value 1"", // string value
+///     ""tagName2"": 123, // numeric value,
+///     ...
+///   }
+///   Note that null means no tags
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+extern pub fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+///   Note that null means no tag names
+extern pub fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+extern pub fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode> {}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+extern pub fn indy_get_wallet_record(command_handle: u32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     options_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                          record_json: *const c_char)>) -> ErrorCode {}
+
+/// Search for wallet records
+///
+/// #Params
+/// storage_handle: opened storage handle (See open handler)
+/// type_: allows to separate different record types collections
+/// query_json: MongoDB style query to wallet record tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    skip: (optional, 0 by default) Skip first ""skip"" wallet records,
+///    limit: (optional, 100 by default) limit amount of records to retrieve,
+///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+///    retrieveTotalCount: (optional, false by default) Calculate total count (without skip/limit apply),
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags,
+///  }
+/// #Returns
+/// wallet records json:
+/// {
+///   totalCount: <int>, // present only if retrieveTotalCount set to true
+///   records: [{ // present only if retrieveRecords set to true
+///       id: ""Some id"",
+///       value: ""Some value"", // present only if retrieveValue set to true
+///       tags: <tags json>, // present only if retrieveTags set to true
+///   }],
+/// }
+extern pub fn indy_search_wallet_records(command_handle: u32,
+                                         wallet_handle: i32,
+                                         type_: *const c_char,
+                                         query_json: *const c_char,
+                                         options_json: *const c_char,
+                                         cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                              records_json: *const c_char)>) -> ErrorCode {}
+
+```
+
+## Wallet API and Storage Interface
+
+Wallet API already exists and allows wallet management. It requires to be update to allow plugging different storages implementation to libindy. For example, to allow storing
+of wallet records in SQL database. To achieve this we will replace existing ```indy_register_wallet_type``` call with ```indy_register_wallet_storage``` call:
+
+```Rust
+/// Register custom wallet storage implementation.
+///
+/// It allows library user to provide custom wallet storage implementation as set of handlers.
+///
+/// #Params
+/// command_handle: Command handle to map callback to caller context.
+/// type_: Wallet storage name.
+/// create: Wallet storage ""create"" operation handler
+/// delete: Wallet storage ""delete"" operation handler
+/// open: Wallet storage ""open"" operation handler
+/// close: Wallet storage ""close"" operation handler
+/// add_record: Wallet storage ""add_record"" operation handler
+/// update_record_value: Wallet storage ""update_record_value"" operation handler
+/// update_record_tags: Wallet storage ""update_record_tags"" operation handler
+/// add_record_tags: Wallet storage ""add_record_tags"" operation handler
+/// delete_record_tags: Wallet storage ""delete_record_tags"" operation handler
+/// delete_record: Wallet storage ""delete_record"" operation handler
+/// get_record: Wallet storage ""get_record"" operation handler
+/// get_record_id: Wallet storage ""get_record_id"" operation handler
+/// get_record_value: Wallet storage ""get_record_value"" operation handler
+/// get_record_tags: Wallet storage ""get_record_tags"" operation handler
+/// free_record: Wallet storage ""free_record"" operation handler
+/// search_records: Wallet storage ""search_records"" operation handler
+/// get_search_total_count: Wallet storage ""get_search_total_count"" operation handler
+/// get_search_count: Wallet storage ""get_search_count"" operation handler
+/// get_search_next_record: Wallet storage ""get_search_next_record"" operation handler
+/// free_search: Wallet storage ""free_search"" operation handler
+///
+/// #Returns
+/// Error code
+#[no_mangle]
+pub extern fn indy_register_wallet_storage(command_handle: i32,
+                                           type_: *const c_char,
+
+                                           /// Create the wallet storage (For example, database creation)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           create: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Delete the wallet storage (For example, database deletion)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           delete: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Open the wallet storage (For example, opening database connection)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// runtime_config: wallet storage runtime config (For example, connection config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           /// storage_handle_p: pointer to store opened storage handle
+                                           open: Option<extern fn(name: *const c_char,
+                                                                  config: *const c_char,
+                                                                  runtime_config: *const c_char,
+                                                                  credentials: *const c_char,
+                                                                  storage_handle_p: *mut i32) -> ErrorCode>,
+
+                                           /// Close the opened walled storage (For example, closing database connection)
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           close: Option<extern fn(handle: i32) -> ErrorCode>,
+
+                                           /// Create a new record in the wallet storage
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// value: the value of record
+                                           /// tags_json: the record tags used for search and storing meta information as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           add_record: Option<extern fn(storage_handle: i32,",356,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/180340221,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r180340221,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,Counts can be expensive to get in some situations.,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-16 08:40:33,181660034,"@@ -0,0 +1,35 @@
+@startuml storage-interface
+
+interface WalletStorage {
+    + {static} create(name, config, cred)
+    + {static} delete(name, config, cred)
+    + {static} open(name, config, r_config, cred) -> WalletStorage
+    + add_record(type, id, value, tags)
+    + update_record_value(type, id, value)
+    + update_record_tags(type, id, tags)
+    + add_record_tags(type, id, tags)
+    + delete_record_tags(type, id, tag_names)
+    + delete_record(type, id)    
+    + get_record(type, id, options) -> Record
+    + search_records(type, query, options) -> Search
+    +close()
+}
+
+interface Search {
+    + get_total_count() -> u32",19,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/181660034,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r181660034,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,May we make this storage handle *mut c_void. I would like to give storage implementer ability to put there pointer to whatever object it is the best for his implementation (for eg. pointer to the storage object or struct holding the internal state).,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-16 08:46:57,181661891,"@@ -0,0 +1,724 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Record ids will be always encrypted.
+  * Record values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secrets API
+
+It is our existing endpoints for secrets creation and access like ```indy_create_and_store_did``` or ```indy_create_and_store_cred_def```:
+
+1. Allow to create a secret into the wallet
+1. Return record id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Non-secrets API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+```Rust
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": ""tag value 1"", // string value
+///     ""tagName2"": 123, // numeric value
+///   }
+///   Note that null means no tags
+extern pub fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+extern pub fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the new record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": ""tag value 1"", // string value
+///     ""tagName2"": 123, // numeric value
+///   }
+///   Note that null means no tags
+extern pub fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the additional record tags as json:
+///   {
+///     ""tagName1"": ""tag value 1"", // string value
+///     ""tagName2"": 123, // numeric value,
+///     ...
+///   }
+///   Note that null means no tags
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+extern pub fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+///   Note that null means no tag names
+extern pub fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+extern pub fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode> {}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+extern pub fn indy_get_wallet_record(command_handle: u32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     options_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                          record_json: *const c_char)>) -> ErrorCode {}
+
+/// Search for wallet records
+///
+/// #Params
+/// storage_handle: opened storage handle (See open handler)
+/// type_: allows to separate different record types collections
+/// query_json: MongoDB style query to wallet record tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    skip: (optional, 0 by default) Skip first ""skip"" wallet records,
+///    limit: (optional, 100 by default) limit amount of records to retrieve,
+///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+///    retrieveTotalCount: (optional, false by default) Calculate total count (without skip/limit apply),
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags,
+///  }
+/// #Returns
+/// wallet records json:
+/// {
+///   totalCount: <int>, // present only if retrieveTotalCount set to true
+///   records: [{ // present only if retrieveRecords set to true
+///       id: ""Some id"",
+///       value: ""Some value"", // present only if retrieveValue set to true
+///       tags: <tags json>, // present only if retrieveTags set to true
+///   }],
+/// }
+extern pub fn indy_search_wallet_records(command_handle: u32,
+                                         wallet_handle: i32,
+                                         type_: *const c_char,
+                                         query_json: *const c_char,
+                                         options_json: *const c_char,
+                                         cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                              records_json: *const c_char)>) -> ErrorCode {}
+
+```
+
+## Wallet API and Storage Interface
+
+Wallet API already exists and allows wallet management. It requires to be update to allow plugging different storages implementation to libindy. For example, to allow storing
+of wallet records in SQL database. To achieve this we will replace existing ```indy_register_wallet_type``` call with ```indy_register_wallet_storage``` call:
+
+```Rust
+/// Register custom wallet storage implementation.
+///
+/// It allows library user to provide custom wallet storage implementation as set of handlers.
+///
+/// #Params
+/// command_handle: Command handle to map callback to caller context.
+/// type_: Wallet storage name.
+/// create: Wallet storage ""create"" operation handler
+/// delete: Wallet storage ""delete"" operation handler
+/// open: Wallet storage ""open"" operation handler
+/// close: Wallet storage ""close"" operation handler
+/// add_record: Wallet storage ""add_record"" operation handler
+/// update_record_value: Wallet storage ""update_record_value"" operation handler
+/// update_record_tags: Wallet storage ""update_record_tags"" operation handler
+/// add_record_tags: Wallet storage ""add_record_tags"" operation handler
+/// delete_record_tags: Wallet storage ""delete_record_tags"" operation handler
+/// delete_record: Wallet storage ""delete_record"" operation handler
+/// get_record: Wallet storage ""get_record"" operation handler
+/// get_record_id: Wallet storage ""get_record_id"" operation handler
+/// get_record_value: Wallet storage ""get_record_value"" operation handler
+/// get_record_tags: Wallet storage ""get_record_tags"" operation handler
+/// free_record: Wallet storage ""free_record"" operation handler
+/// search_records: Wallet storage ""search_records"" operation handler
+/// get_search_total_count: Wallet storage ""get_search_total_count"" operation handler
+/// get_search_count: Wallet storage ""get_search_count"" operation handler
+/// get_search_next_record: Wallet storage ""get_search_next_record"" operation handler
+/// free_search: Wallet storage ""free_search"" operation handler
+///
+/// #Returns
+/// Error code
+#[no_mangle]
+pub extern fn indy_register_wallet_storage(command_handle: i32,
+                                           type_: *const c_char,
+
+                                           /// Create the wallet storage (For example, database creation)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           create: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Delete the wallet storage (For example, database deletion)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           delete: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Open the wallet storage (For example, opening database connection)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// runtime_config: wallet storage runtime config (For example, connection config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           /// storage_handle_p: pointer to store opened storage handle
+                                           open: Option<extern fn(name: *const c_char,
+                                                                  config: *const c_char,
+                                                                  runtime_config: *const c_char,
+                                                                  credentials: *const c_char,
+                                                                  storage_handle_p: *mut i32) -> ErrorCode>,",334,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/181661891,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r181661891,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,"maybe just a clarification: If tag name starts with ""~"" the tag **value** will be stored un-encrypted...",9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-17 12:56:44,182061305,"@@ -55,10 +55,15 @@ This API shouldn't have an access to secrets stored by Secret Entities API.
 /// value: the value of record
 /// tags_json: the record tags used for search and storing meta information as json:
 ///   {
-///     ""tagName1"": ""tag value 1"", // string value
-///     ""tagName2"": 123, // numeric value
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
 ///   }
 ///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182061305,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182061305,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,"For value, it is used sometimes *const u8 and sometimes *const c_char. I would guess both will work but we should chose some.",9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-17 13:02:25,182063250,"@@ -320,7 +356,8 @@ pub extern fn indy_register_wallet_storage(command_handle: i32,
                                            add_record: Option<extern fn(storage_handle: i32,
                                                                         type_: *const c_char,
                                                                         id: *const c_char,
-                                                                        value: *const c_char,
+                                                                        value: *const u8,",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182063250,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182063250,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,"I would like it more if id and type_ values are passed as pointer to buffer and len (not using base64 or similar). I agree there is small performance impact because these values are small enough (less than 100 bytes), but it still to me makes not a sense to do that.",9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-17 13:07:26,182064794,"@@ -320,7 +356,8 @@ pub extern fn indy_register_wallet_storage(command_handle: i32,
                                            add_record: Option<extern fn(storage_handle: i32,
                                                                         type_: *const c_char,
                                                                         id: *const c_char,",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182064794,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182064794,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,"We also need to transfer value_key (encrypted key which is used for encrypting the value). Every value have its own key.
It is the same for all functions transferring the value.",9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-17 13:19:08,182068535,"@@ -0,0 +1,762 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Record ids will be always encrypted.
+  * Record values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secrets API
+
+It is our existing endpoints for secrets creation and access like ```indy_create_and_store_did``` or ```indy_create_and_store_cred_def```:
+
+1. Allow to create a secret into the wallet
+1. Return record id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Non-secrets API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+```Rust
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+extern pub fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+extern pub fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+///   Note that null means no tag names
+extern pub fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+extern pub fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode> {}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+extern pub fn indy_get_wallet_record(command_handle: u32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     options_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                          record_json: *const c_char)>) -> ErrorCode {}
+
+/// Search for wallet records.
+///
+/// Note instead of immediately returning of fetched records
+/// this call returns wallet_search_handle that can be used later
+/// to fetch records by small batches (with indy_fetch_wallet_search_next_records).
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// query_json: MongoDB style query to wallet record tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+///    retrieveTotalCount: (optional, false by default) Calculate total count,
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags,
+///  }
+/// #Returns
+/// wallet_search_handle: Wallet search handle that can be used later
+///   to fetch records by small batches (with indy_fetch_wallet_search_next_records)
+extern pub fn indy_open_wallet_search(command_handle: u32,
+                                      wallet_handle: i32,
+                                      type_: *const c_char,
+                                      query_json: *const c_char,
+                                      options_json: *const c_char,
+                                      cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                           wallet_search_handle_p: *mut i32)>) -> ErrorCode {}
+
+
+/// Fetch next records for wallet search.
+///
+/// Not if there are no records this call returns WalletNoRecords error.
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// wallet_search_handle: wallet wallet handle (created by indy_open_wallet_search)
+/// count: Count of records to fetch
+///
+/// #Returns
+/// wallet records json:
+/// {
+///   totalCount: <int>, // present only if retrieveTotalCount set to true
+///   records: [{ // present only if retrieveRecords set to true
+///       id: ""Some id"",
+///       value: ""Some value"", // present only if retrieveValue set to true
+///       tags: <tags json>, // present only if retrieveTags set to true
+///   }],
+/// }
+extern pub fn indy_fetch_wallet_search_next_records(command_handle: u32,
+                                                    wallet_handle: i32,
+                                                    wallet_search_handle: i32,
+                                                    count: u32,
+                                                    cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                                         records_json: *const c_char)>) -> ErrorCode {}
+```
+
+## Wallet API and Storage Interface
+
+Wallet API already exists and allows wallet management. It requires to be update to allow plugging different storages implementation to libindy. For example, to allow storing
+of wallet records in SQL database. To achieve this we will replace existing ```indy_register_wallet_type``` call with ```indy_register_wallet_storage``` call:
+
+```Rust
+/// Register custom wallet storage implementation.
+///
+/// It allows library user to provide custom wallet storage implementation as set of handlers.
+///
+/// #Params
+/// command_handle: Command handle to map callback to caller context.
+/// type_: Wallet storage name.
+/// create: Wallet storage ""create"" operation handler
+/// delete: Wallet storage ""delete"" operation handler
+/// open: Wallet storage ""open"" operation handler
+/// close: Wallet storage ""close"" operation handler
+/// add_record: Wallet storage ""add_record"" operation handler
+/// update_record_value: Wallet storage ""update_record_value"" operation handler
+/// update_record_tags: Wallet storage ""update_record_tags"" operation handler
+/// add_record_tags: Wallet storage ""add_record_tags"" operation handler
+/// delete_record_tags: Wallet storage ""delete_record_tags"" operation handler
+/// delete_record: Wallet storage ""delete_record"" operation handler
+/// get_record: Wallet storage ""get_record"" operation handler
+/// get_record_id: Wallet storage ""get_record_id"" operation handler
+/// get_record_value: Wallet storage ""get_record_value"" operation handler
+/// get_record_tags: Wallet storage ""get_record_tags"" operation handler
+/// free_record: Wallet storage ""free_record"" operation handler
+/// search_records: Wallet storage ""search_records"" operation handler
+/// get_search_total_count: Wallet storage ""get_search_total_count"" operation handler
+/// get_search_count: Wallet storage ""get_search_count"" operation handler
+/// get_search_next_record: Wallet storage ""get_search_next_record"" operation handler
+/// free_search: Wallet storage ""free_search"" operation handler
+///
+/// #Returns
+/// Error code
+#[no_mangle]
+pub extern fn indy_register_wallet_storage(command_handle: i32,
+                                           type_: *const c_char,
+
+                                           /// Create the wallet storage (For example, database creation)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           create: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Delete the wallet storage (For example, database deletion)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           delete: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Open the wallet storage (For example, opening database connection)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// runtime_config: wallet storage runtime config (For example, connection config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           /// storage_handle_p: pointer to store opened storage handle
+                                           open: Option<extern fn(name: *const c_char,
+                                                                  config: *const c_char,
+                                                                  runtime_config: *const c_char,
+                                                                  credentials: *const c_char,
+                                                                  storage_handle_p: *mut i32) -> ErrorCode>,
+
+                                           /// Close the opened walled storage (For example, closing database connection)
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           close: Option<extern fn(handle: i32) -> ErrorCode>,
+
+                                           /// Create a new record in the wallet storage
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// value: the value of record (pointer to buffer)
+                                           /// value_len: the value of record (buffer size)
+                                           /// tags_json: the record tags used for search and storing meta information as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           add_record: Option<extern fn(storage_handle: i32,
+                                                                        type_: *const c_char,
+                                                                        id: *const c_char,
+                                                                        value: *const u8,
+                                                                        value_len: usize,
+                                                                        tags_json: *const c_char) -> ErrorCode>,",361,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182068535,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182068535,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,"I think we do not need functions with record_handle. In get_record we can return the data immediately (if requested) or set the returned pointer to NULL if not requested.
I had in mind function like this: 
```
get_record: Option<extern fn(handle: i32,
                                class_p: *const c_char,
                                class_len: c_int,
                                name_p: *const c_char,
                                name_len: c_int,
                                options: *const c_char,
                                value_p: *mut *const c_char,
                                value_len: *mut c_int,
                                value_key_p: *mut *const c_char,
                                value_key_len: *mut c_int,
                                tags_p: *mut *const c_char) -> ErrorCode>;
```

",9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-17 13:23:38,182070141,"@@ -0,0 +1,762 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Record ids will be always encrypted.
+  * Record values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secrets API
+
+It is our existing endpoints for secrets creation and access like ```indy_create_and_store_did``` or ```indy_create_and_store_cred_def```:
+
+1. Allow to create a secret into the wallet
+1. Return record id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Non-secrets API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+```Rust
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+extern pub fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+extern pub fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+///   Note that null means no tag names
+extern pub fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+extern pub fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode> {}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+extern pub fn indy_get_wallet_record(command_handle: u32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     options_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                          record_json: *const c_char)>) -> ErrorCode {}
+
+/// Search for wallet records.
+///
+/// Note instead of immediately returning of fetched records
+/// this call returns wallet_search_handle that can be used later
+/// to fetch records by small batches (with indy_fetch_wallet_search_next_records).
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// query_json: MongoDB style query to wallet record tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+///    retrieveTotalCount: (optional, false by default) Calculate total count,
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags,
+///  }
+/// #Returns
+/// wallet_search_handle: Wallet search handle that can be used later
+///   to fetch records by small batches (with indy_fetch_wallet_search_next_records)
+extern pub fn indy_open_wallet_search(command_handle: u32,
+                                      wallet_handle: i32,
+                                      type_: *const c_char,
+                                      query_json: *const c_char,
+                                      options_json: *const c_char,
+                                      cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                           wallet_search_handle_p: *mut i32)>) -> ErrorCode {}
+
+
+/// Fetch next records for wallet search.
+///
+/// Not if there are no records this call returns WalletNoRecords error.
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// wallet_search_handle: wallet wallet handle (created by indy_open_wallet_search)
+/// count: Count of records to fetch
+///
+/// #Returns
+/// wallet records json:
+/// {
+///   totalCount: <int>, // present only if retrieveTotalCount set to true
+///   records: [{ // present only if retrieveRecords set to true
+///       id: ""Some id"",
+///       value: ""Some value"", // present only if retrieveValue set to true
+///       tags: <tags json>, // present only if retrieveTags set to true
+///   }],
+/// }
+extern pub fn indy_fetch_wallet_search_next_records(command_handle: u32,
+                                                    wallet_handle: i32,
+                                                    wallet_search_handle: i32,
+                                                    count: u32,
+                                                    cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                                         records_json: *const c_char)>) -> ErrorCode {}
+```
+
+## Wallet API and Storage Interface
+
+Wallet API already exists and allows wallet management. It requires to be update to allow plugging different storages implementation to libindy. For example, to allow storing
+of wallet records in SQL database. To achieve this we will replace existing ```indy_register_wallet_type``` call with ```indy_register_wallet_storage``` call:
+
+```Rust
+/// Register custom wallet storage implementation.
+///
+/// It allows library user to provide custom wallet storage implementation as set of handlers.
+///
+/// #Params
+/// command_handle: Command handle to map callback to caller context.
+/// type_: Wallet storage name.
+/// create: Wallet storage ""create"" operation handler
+/// delete: Wallet storage ""delete"" operation handler
+/// open: Wallet storage ""open"" operation handler
+/// close: Wallet storage ""close"" operation handler
+/// add_record: Wallet storage ""add_record"" operation handler
+/// update_record_value: Wallet storage ""update_record_value"" operation handler
+/// update_record_tags: Wallet storage ""update_record_tags"" operation handler
+/// add_record_tags: Wallet storage ""add_record_tags"" operation handler
+/// delete_record_tags: Wallet storage ""delete_record_tags"" operation handler
+/// delete_record: Wallet storage ""delete_record"" operation handler
+/// get_record: Wallet storage ""get_record"" operation handler
+/// get_record_id: Wallet storage ""get_record_id"" operation handler
+/// get_record_value: Wallet storage ""get_record_value"" operation handler
+/// get_record_tags: Wallet storage ""get_record_tags"" operation handler
+/// free_record: Wallet storage ""free_record"" operation handler
+/// search_records: Wallet storage ""search_records"" operation handler
+/// get_search_total_count: Wallet storage ""get_search_total_count"" operation handler
+/// get_search_count: Wallet storage ""get_search_count"" operation handler
+/// get_search_next_record: Wallet storage ""get_search_next_record"" operation handler
+/// free_search: Wallet storage ""free_search"" operation handler
+///
+/// #Returns
+/// Error code
+#[no_mangle]
+pub extern fn indy_register_wallet_storage(command_handle: i32,
+                                           type_: *const c_char,
+
+                                           /// Create the wallet storage (For example, database creation)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           create: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Delete the wallet storage (For example, database deletion)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           delete: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Open the wallet storage (For example, opening database connection)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// runtime_config: wallet storage runtime config (For example, connection config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           /// storage_handle_p: pointer to store opened storage handle
+                                           open: Option<extern fn(name: *const c_char,
+                                                                  config: *const c_char,
+                                                                  runtime_config: *const c_char,
+                                                                  credentials: *const c_char,
+                                                                  storage_handle_p: *mut i32) -> ErrorCode>,
+
+                                           /// Close the opened walled storage (For example, closing database connection)
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           close: Option<extern fn(handle: i32) -> ErrorCode>,
+
+                                           /// Create a new record in the wallet storage
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// value: the value of record (pointer to buffer)
+                                           /// value_len: the value of record (buffer size)
+                                           /// tags_json: the record tags used for search and storing meta information as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           add_record: Option<extern fn(storage_handle: i32,
+                                                                        type_: *const c_char,
+                                                                        id: *const c_char,
+                                                                        value: *const u8,
+                                                                        value_len: usize,
+                                                                        tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Update a record value
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// value: the value of record (pointer to buffer)
+                                           /// value_len: the value of record (buffer size)
+                                           update_record_value: Option<extern fn(storage_handle: i32,
+                                                                                 type_: *const c_char,
+                                                                                 id: *const c_char,
+                                                                                 value: *const c_char,
+                                                                                 value_len: usize) -> ErrorCode>,
+
+                                           /// Update a record tags
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tags_json: the new record tags used for search and storing meta information as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           update_record_tags: Option<extern fn(storage_handle: i32,
+                                                                                type_: *const c_char,
+                                                                                id: *const c_char,
+                                                                                tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Add new tags to the record
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tags_json: the additional record tags as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value,
+                                           ///     ...
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           ///   Note if some from provided tags already assigned to the record than
+                                           ///     corresponding tags values will be replaced
+                                           add_record_tags: Option<extern fn(storage_handle: i32,
+                                                                             type_: *const c_char,
+                                                                             id: *const c_char,
+                                                                             tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Delete tags from the record
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tag_names_json: the list of tag names to remove from the record as json array:
+                                           ///   [""tagName1"", ""tagName2"", ...]
+                                           ///   Note that null means no tag names
+                                           delete_record_tags: Option<extern fn(storage_handle: i32,
+                                                                                type_: *const c_char,
+                                                                                id: *const c_char,
+                                                                                tag_names_json: *const c_char) -> ErrorCode>,
+
+                                           /// Delete an existing record in the wallet storage
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: record type
+                                           /// id: the id of record
+                                           delete_record: Option<extern fn(storage_handle: i32,
+                                                                           type_: *const c_char,
+                                                                           id: *const c_char) -> ErrorCode>,
+
+                                           /// Get an wallet storage record by id
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// options_json: //TODO: FIXME: Think about replacing by bitmaks
+                                           ///  {
+                                           ///    retrieveValue: (optional, true by default) Retrieve record value,
+                                           ///    retrieveTags: (optional, true by default) Retrieve record tags
+                                           ///  }
+                                           /// record_handle_p: pointer to store retrieved record handle
+                                           get_record: Option<extern fn(storage_handle: u32,",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182070141,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182070141,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,Here I would again avoid record handle and return the record immediately.,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-17 13:26:12,182070981,"@@ -0,0 +1,762 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Record ids will be always encrypted.
+  * Record values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secrets API
+
+It is our existing endpoints for secrets creation and access like ```indy_create_and_store_did``` or ```indy_create_and_store_cred_def```:
+
+1. Allow to create a secret into the wallet
+1. Return record id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Non-secrets API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+```Rust
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+extern pub fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+extern pub fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+///   Note that null means no tag names
+extern pub fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+extern pub fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode> {}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+extern pub fn indy_get_wallet_record(command_handle: u32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     options_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                          record_json: *const c_char)>) -> ErrorCode {}
+
+/// Search for wallet records.
+///
+/// Note instead of immediately returning of fetched records
+/// this call returns wallet_search_handle that can be used later
+/// to fetch records by small batches (with indy_fetch_wallet_search_next_records).
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// query_json: MongoDB style query to wallet record tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+///    retrieveTotalCount: (optional, false by default) Calculate total count,
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags,
+///  }
+/// #Returns
+/// wallet_search_handle: Wallet search handle that can be used later
+///   to fetch records by small batches (with indy_fetch_wallet_search_next_records)
+extern pub fn indy_open_wallet_search(command_handle: u32,
+                                      wallet_handle: i32,
+                                      type_: *const c_char,
+                                      query_json: *const c_char,
+                                      options_json: *const c_char,
+                                      cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                           wallet_search_handle_p: *mut i32)>) -> ErrorCode {}
+
+
+/// Fetch next records for wallet search.
+///
+/// Not if there are no records this call returns WalletNoRecords error.
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// wallet_search_handle: wallet wallet handle (created by indy_open_wallet_search)
+/// count: Count of records to fetch
+///
+/// #Returns
+/// wallet records json:
+/// {
+///   totalCount: <int>, // present only if retrieveTotalCount set to true
+///   records: [{ // present only if retrieveRecords set to true
+///       id: ""Some id"",
+///       value: ""Some value"", // present only if retrieveValue set to true
+///       tags: <tags json>, // present only if retrieveTags set to true
+///   }],
+/// }
+extern pub fn indy_fetch_wallet_search_next_records(command_handle: u32,
+                                                    wallet_handle: i32,
+                                                    wallet_search_handle: i32,
+                                                    count: u32,
+                                                    cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                                         records_json: *const c_char)>) -> ErrorCode {}
+```
+
+## Wallet API and Storage Interface
+
+Wallet API already exists and allows wallet management. It requires to be update to allow plugging different storages implementation to libindy. For example, to allow storing
+of wallet records in SQL database. To achieve this we will replace existing ```indy_register_wallet_type``` call with ```indy_register_wallet_storage``` call:
+
+```Rust
+/// Register custom wallet storage implementation.
+///
+/// It allows library user to provide custom wallet storage implementation as set of handlers.
+///
+/// #Params
+/// command_handle: Command handle to map callback to caller context.
+/// type_: Wallet storage name.
+/// create: Wallet storage ""create"" operation handler
+/// delete: Wallet storage ""delete"" operation handler
+/// open: Wallet storage ""open"" operation handler
+/// close: Wallet storage ""close"" operation handler
+/// add_record: Wallet storage ""add_record"" operation handler
+/// update_record_value: Wallet storage ""update_record_value"" operation handler
+/// update_record_tags: Wallet storage ""update_record_tags"" operation handler
+/// add_record_tags: Wallet storage ""add_record_tags"" operation handler
+/// delete_record_tags: Wallet storage ""delete_record_tags"" operation handler
+/// delete_record: Wallet storage ""delete_record"" operation handler
+/// get_record: Wallet storage ""get_record"" operation handler
+/// get_record_id: Wallet storage ""get_record_id"" operation handler
+/// get_record_value: Wallet storage ""get_record_value"" operation handler
+/// get_record_tags: Wallet storage ""get_record_tags"" operation handler
+/// free_record: Wallet storage ""free_record"" operation handler
+/// search_records: Wallet storage ""search_records"" operation handler
+/// get_search_total_count: Wallet storage ""get_search_total_count"" operation handler
+/// get_search_count: Wallet storage ""get_search_count"" operation handler
+/// get_search_next_record: Wallet storage ""get_search_next_record"" operation handler
+/// free_search: Wallet storage ""free_search"" operation handler
+///
+/// #Returns
+/// Error code
+#[no_mangle]
+pub extern fn indy_register_wallet_storage(command_handle: i32,
+                                           type_: *const c_char,
+
+                                           /// Create the wallet storage (For example, database creation)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           create: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Delete the wallet storage (For example, database deletion)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           delete: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Open the wallet storage (For example, opening database connection)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// runtime_config: wallet storage runtime config (For example, connection config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           /// storage_handle_p: pointer to store opened storage handle
+                                           open: Option<extern fn(name: *const c_char,
+                                                                  config: *const c_char,
+                                                                  runtime_config: *const c_char,
+                                                                  credentials: *const c_char,
+                                                                  storage_handle_p: *mut i32) -> ErrorCode>,
+
+                                           /// Close the opened walled storage (For example, closing database connection)
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           close: Option<extern fn(handle: i32) -> ErrorCode>,
+
+                                           /// Create a new record in the wallet storage
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// value: the value of record (pointer to buffer)
+                                           /// value_len: the value of record (buffer size)
+                                           /// tags_json: the record tags used for search and storing meta information as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           add_record: Option<extern fn(storage_handle: i32,
+                                                                        type_: *const c_char,
+                                                                        id: *const c_char,
+                                                                        value: *const u8,
+                                                                        value_len: usize,
+                                                                        tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Update a record value
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// value: the value of record (pointer to buffer)
+                                           /// value_len: the value of record (buffer size)
+                                           update_record_value: Option<extern fn(storage_handle: i32,
+                                                                                 type_: *const c_char,
+                                                                                 id: *const c_char,
+                                                                                 value: *const c_char,
+                                                                                 value_len: usize) -> ErrorCode>,
+
+                                           /// Update a record tags
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tags_json: the new record tags used for search and storing meta information as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           update_record_tags: Option<extern fn(storage_handle: i32,
+                                                                                type_: *const c_char,
+                                                                                id: *const c_char,
+                                                                                tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Add new tags to the record
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tags_json: the additional record tags as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value,
+                                           ///     ...
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           ///   Note if some from provided tags already assigned to the record than
+                                           ///     corresponding tags values will be replaced
+                                           add_record_tags: Option<extern fn(storage_handle: i32,
+                                                                             type_: *const c_char,
+                                                                             id: *const c_char,
+                                                                             tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Delete tags from the record
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tag_names_json: the list of tag names to remove from the record as json array:
+                                           ///   [""tagName1"", ""tagName2"", ...]
+                                           ///   Note that null means no tag names
+                                           delete_record_tags: Option<extern fn(storage_handle: i32,
+                                                                                type_: *const c_char,
+                                                                                id: *const c_char,
+                                                                                tag_names_json: *const c_char) -> ErrorCode>,
+
+                                           /// Delete an existing record in the wallet storage
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: record type
+                                           /// id: the id of record
+                                           delete_record: Option<extern fn(storage_handle: i32,
+                                                                           type_: *const c_char,
+                                                                           id: *const c_char) -> ErrorCode>,
+
+                                           /// Get an wallet storage record by id
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// options_json: //TODO: FIXME: Think about replacing by bitmaks
+                                           ///  {
+                                           ///    retrieveValue: (optional, true by default) Retrieve record value,
+                                           ///    retrieveTags: (optional, true by default) Retrieve record tags
+                                           ///  }
+                                           /// record_handle_p: pointer to store retrieved record handle
+                                           get_record: Option<extern fn(storage_handle: u32,
+                                                                        type_: *const c_char,
+                                                                        id: *const c_char,
+                                                                        options_json: *const c_char,
+                                                                        record_handle_p: *mut u32) -> ErrorCode>,
+
+                                          /// Get an id for retrieved wallet storage record
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// record_handle: retrieved record handle (See get_record handler)
+                                          ///
+                                          /// returns: record id
+                                          ///          Note that pointer lifetime the same as retrieved record lifetime
+                                          ///            (until record_free called)
+                                          get_record_id: Option<extern fn(storage_handle: u32,
+                                                                          record_handle: u32,
+                                                                          record_id_p: *mut *const c_char) -> ErrorCode>,
+
+                                          /// Get an value for retrieved wallet storage record
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// record_handle: retrieved record handle (See get_record handler)
+                                          ///
+                                          /// returns: record value
+                                          ///          Note that pointer lifetime the same as retrieved record lifetime
+                                          ///            (until record_free called)
+                                          ///          Note that null be returned if no value retrieved
+                                          get_record_value: Option<extern fn(storage_handle: u32,
+                                                                             record_handle: u32,
+                                                                             record_value_p: *mut *const u8,
+                                                                             record_value_len_p: *mut i32) -> ErrorCode>,
+
+                                          /// Get an tags for retrieved wallet record
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// record_handle: retrieved record handle (See get_record handler)
+                                          ///
+                                          /// returns: record tags as json
+                                          ///          Note that pointer lifetime the same as retrieved record lifetime
+                                          ///            (until record_free called)
+                                          ///          Note that null be returned if no tags retrieved
+                                          get_record_tags: Option<extern fn(storage_handle: u32,
+                                                                            record_handle: u32,
+                                                                            record_tags_p: *mut *const c_char) -> ErrorCode>,
+
+                                          /// Free retrieved wallet record (make retrieved record handle invalid)
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open_wallet_storage)
+                                          /// record_handle: retrieved record handle (See wallet_storage_get_wallet_record)
+                                          free_record: Option<extern fn(storage_handle: u32,
+                                                                        record_handle: u32) -> ErrorCode>,
+
+                                          /// Search for wallet storage records
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// type_: allows to separate different record types collections
+                                          /// query_json: MongoDB style query to wallet record tags:
+                                          ///  {
+                                          ///    ""tagName"": ""tagValue"",
+                                          ///    $or: {
+                                          ///      ""tagName2"": { $regex: 'pattern' },
+                                          ///      ""tagName3"": { $gte: 123 },
+                                          ///    },
+                                          ///  }
+                                          /// options_json: //TODO: FIXME: Think about replacing by bitmaks
+                                          ///  {
+                                          ///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+                                          ///    retrieveTotalCount: (optional, false by default) Calculate total count,
+                                          ///    retrieveValue: (optional, true by default) Retrieve record value,
+                                          ///    retrieveTags: (optional, true by default) Retrieve record tags,
+                                          ///  }
+                                          /// search_handle_p: pointer to store wallet search handle
+                                          search_records: Option<extern fn(storage_handle: u32,
+                                                                           type_: *const c_char,
+                                                                           query_json: *const c_char,
+                                                                           options_json: *const c_char,
+                                                                           search_handle_p: *mut u32) -> ErrorCode>,
+
+                                          /// Get total count of records that corresponds to wallet storage search query
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// search_handle: wallet search handle (See search_records handler)
+                                          ///
+                                          /// returns: total count of records that corresponds to wallet storage search query
+                                          ///          Note -1 will be returned if retrieveTotalCount set to false for search_records
+                                          get_search_total_count: Option<extern fn(storage_handle: u32,
+                                                                                   search_handle: u32,
+                                                                                   total_count_p: *mut u32) -> ErrorCode>,
+
+                                          /// Get the next wallet storage record handle retrieved by this wallet search.
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// search_handle: wallet search handle (See search_records handler)
+                                          ///
+                                          /// returns: record handle (the same as for get_record handler)
+                                          ///          Note if no more records WalletNoRecords error will be returned
+                                          fetch_search_next_record: Option<extern fn(storage_handle: u32,
+                                                                                     search_handle: u32,
+                                                                                     record_handle_p: *mut i32) -> ErrorCode>,",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182070981,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182070981,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,"As we discussed we will use record value as a byte array. type_, id, tags will be encoded as base64",9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-17 13:29:03,182071986,"@@ -0,0 +1,724 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Record ids will be always encrypted.
+  * Record values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secrets API
+
+It is our existing endpoints for secrets creation and access like ```indy_create_and_store_did``` or ```indy_create_and_store_cred_def```:
+
+1. Allow to create a secret into the wallet
+1. Return record id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Non-secrets API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+```Rust
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": ""tag value 1"", // string value
+///     ""tagName2"": 123, // numeric value
+///   }
+///   Note that null means no tags
+extern pub fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+extern pub fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the new record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": ""tag value 1"", // string value
+///     ""tagName2"": 123, // numeric value
+///   }
+///   Note that null means no tags
+extern pub fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the additional record tags as json:
+///   {
+///     ""tagName1"": ""tag value 1"", // string value
+///     ""tagName2"": 123, // numeric value,
+///     ...
+///   }
+///   Note that null means no tags
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+extern pub fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+///   Note that null means no tag names
+extern pub fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+extern pub fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode> {}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+extern pub fn indy_get_wallet_record(command_handle: u32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     options_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                          record_json: *const c_char)>) -> ErrorCode {}
+
+/// Search for wallet records
+///
+/// #Params
+/// storage_handle: opened storage handle (See open handler)
+/// type_: allows to separate different record types collections
+/// query_json: MongoDB style query to wallet record tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    skip: (optional, 0 by default) Skip first ""skip"" wallet records,
+///    limit: (optional, 100 by default) limit amount of records to retrieve,
+///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+///    retrieveTotalCount: (optional, false by default) Calculate total count (without skip/limit apply),
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags,
+///  }
+/// #Returns
+/// wallet records json:
+/// {
+///   totalCount: <int>, // present only if retrieveTotalCount set to true
+///   records: [{ // present only if retrieveRecords set to true
+///       id: ""Some id"",
+///       value: ""Some value"", // present only if retrieveValue set to true
+///       tags: <tags json>, // present only if retrieveTags set to true
+///   }],
+/// }
+extern pub fn indy_search_wallet_records(command_handle: u32,
+                                         wallet_handle: i32,
+                                         type_: *const c_char,
+                                         query_json: *const c_char,
+                                         options_json: *const c_char,
+                                         cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                              records_json: *const c_char)>) -> ErrorCode {}
+
+```
+
+## Wallet API and Storage Interface
+
+Wallet API already exists and allows wallet management. It requires to be update to allow plugging different storages implementation to libindy. For example, to allow storing
+of wallet records in SQL database. To achieve this we will replace existing ```indy_register_wallet_type``` call with ```indy_register_wallet_storage``` call:
+
+```Rust
+/// Register custom wallet storage implementation.
+///
+/// It allows library user to provide custom wallet storage implementation as set of handlers.
+///
+/// #Params
+/// command_handle: Command handle to map callback to caller context.
+/// type_: Wallet storage name.
+/// create: Wallet storage ""create"" operation handler
+/// delete: Wallet storage ""delete"" operation handler
+/// open: Wallet storage ""open"" operation handler
+/// close: Wallet storage ""close"" operation handler
+/// add_record: Wallet storage ""add_record"" operation handler
+/// update_record_value: Wallet storage ""update_record_value"" operation handler
+/// update_record_tags: Wallet storage ""update_record_tags"" operation handler
+/// add_record_tags: Wallet storage ""add_record_tags"" operation handler
+/// delete_record_tags: Wallet storage ""delete_record_tags"" operation handler
+/// delete_record: Wallet storage ""delete_record"" operation handler
+/// get_record: Wallet storage ""get_record"" operation handler
+/// get_record_id: Wallet storage ""get_record_id"" operation handler
+/// get_record_value: Wallet storage ""get_record_value"" operation handler
+/// get_record_tags: Wallet storage ""get_record_tags"" operation handler
+/// free_record: Wallet storage ""free_record"" operation handler
+/// search_records: Wallet storage ""search_records"" operation handler
+/// get_search_total_count: Wallet storage ""get_search_total_count"" operation handler
+/// get_search_count: Wallet storage ""get_search_count"" operation handler
+/// get_search_next_record: Wallet storage ""get_search_next_record"" operation handler
+/// free_search: Wallet storage ""free_search"" operation handler
+///
+/// #Returns
+/// Error code
+#[no_mangle]
+pub extern fn indy_register_wallet_storage(command_handle: i32,
+                                           type_: *const c_char,
+
+                                           /// Create the wallet storage (For example, database creation)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           create: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Delete the wallet storage (For example, database deletion)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           delete: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Open the wallet storage (For example, opening database connection)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// runtime_config: wallet storage runtime config (For example, connection config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           /// storage_handle_p: pointer to store opened storage handle
+                                           open: Option<extern fn(name: *const c_char,
+                                                                  config: *const c_char,
+                                                                  runtime_config: *const c_char,
+                                                                  credentials: *const c_char,
+                                                                  storage_handle_p: *mut i32) -> ErrorCode>,
+
+                                           /// Close the opened walled storage (For example, closing database connection)
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           close: Option<extern fn(handle: i32) -> ErrorCode>,
+
+                                           /// Create a new record in the wallet storage
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// value: the value of record
+                                           /// tags_json: the record tags used for search and storing meta information as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           add_record: Option<extern fn(storage_handle: i32,",356,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182071986,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182071986,vimmerru
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,I am not sure we should skip WalletStorageType struct :-/,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-17 13:29:22,182072097,"@@ -0,0 +1,35 @@
+@startuml storage-interface
+
+interface WalletStorage {
+    + {static} create(name, config, cred)",4,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182072097,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182072097,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,Count will be calculated optionally. It can be fast enough for a lot of use cases.,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-17 13:30:23,182072421,"@@ -0,0 +1,35 @@
+@startuml storage-interface
+
+interface WalletStorage {
+    + {static} create(name, config, cred)
+    + {static} delete(name, config, cred)
+    + {static} open(name, config, r_config, cred) -> WalletStorage
+    + add_record(type, id, value, tags)
+    + update_record_value(type, id, value)
+    + update_record_tags(type, id, tags)
+    + add_record_tags(type, id, tags)
+    + delete_record_tags(type, id, tag_names)
+    + delete_record(type, id)    
+    + get_record(type, id, options) -> Record
+    + search_records(type, query, options) -> Search
+    +close()
+}
+
+interface Search {
+    + get_total_count() -> u32",19,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182072421,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182072421,vimmerru
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,I have big concern about this proposal. When you provide the pointer you transfer memory ownership and should provide the way to free memory. We have mix of types here and will require a lot of handlers to free memory. Providing record_handle solve this problem. We have just one free_record function that consumes this handle.,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-17 13:37:54,182074923,"@@ -0,0 +1,762 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Record ids will be always encrypted.
+  * Record values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secrets API
+
+It is our existing endpoints for secrets creation and access like ```indy_create_and_store_did``` or ```indy_create_and_store_cred_def```:
+
+1. Allow to create a secret into the wallet
+1. Return record id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Non-secrets API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+```Rust
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+extern pub fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+extern pub fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+///   Note that null means no tag names
+extern pub fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+extern pub fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode> {}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+extern pub fn indy_get_wallet_record(command_handle: u32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     options_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                          record_json: *const c_char)>) -> ErrorCode {}
+
+/// Search for wallet records.
+///
+/// Note instead of immediately returning of fetched records
+/// this call returns wallet_search_handle that can be used later
+/// to fetch records by small batches (with indy_fetch_wallet_search_next_records).
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// query_json: MongoDB style query to wallet record tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+///    retrieveTotalCount: (optional, false by default) Calculate total count,
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags,
+///  }
+/// #Returns
+/// wallet_search_handle: Wallet search handle that can be used later
+///   to fetch records by small batches (with indy_fetch_wallet_search_next_records)
+extern pub fn indy_open_wallet_search(command_handle: u32,
+                                      wallet_handle: i32,
+                                      type_: *const c_char,
+                                      query_json: *const c_char,
+                                      options_json: *const c_char,
+                                      cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                           wallet_search_handle_p: *mut i32)>) -> ErrorCode {}
+
+
+/// Fetch next records for wallet search.
+///
+/// Not if there are no records this call returns WalletNoRecords error.
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// wallet_search_handle: wallet wallet handle (created by indy_open_wallet_search)
+/// count: Count of records to fetch
+///
+/// #Returns
+/// wallet records json:
+/// {
+///   totalCount: <int>, // present only if retrieveTotalCount set to true
+///   records: [{ // present only if retrieveRecords set to true
+///       id: ""Some id"",
+///       value: ""Some value"", // present only if retrieveValue set to true
+///       tags: <tags json>, // present only if retrieveTags set to true
+///   }],
+/// }
+extern pub fn indy_fetch_wallet_search_next_records(command_handle: u32,
+                                                    wallet_handle: i32,
+                                                    wallet_search_handle: i32,
+                                                    count: u32,
+                                                    cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                                         records_json: *const c_char)>) -> ErrorCode {}
+```
+
+## Wallet API and Storage Interface
+
+Wallet API already exists and allows wallet management. It requires to be update to allow plugging different storages implementation to libindy. For example, to allow storing
+of wallet records in SQL database. To achieve this we will replace existing ```indy_register_wallet_type``` call with ```indy_register_wallet_storage``` call:
+
+```Rust
+/// Register custom wallet storage implementation.
+///
+/// It allows library user to provide custom wallet storage implementation as set of handlers.
+///
+/// #Params
+/// command_handle: Command handle to map callback to caller context.
+/// type_: Wallet storage name.
+/// create: Wallet storage ""create"" operation handler
+/// delete: Wallet storage ""delete"" operation handler
+/// open: Wallet storage ""open"" operation handler
+/// close: Wallet storage ""close"" operation handler
+/// add_record: Wallet storage ""add_record"" operation handler
+/// update_record_value: Wallet storage ""update_record_value"" operation handler
+/// update_record_tags: Wallet storage ""update_record_tags"" operation handler
+/// add_record_tags: Wallet storage ""add_record_tags"" operation handler
+/// delete_record_tags: Wallet storage ""delete_record_tags"" operation handler
+/// delete_record: Wallet storage ""delete_record"" operation handler
+/// get_record: Wallet storage ""get_record"" operation handler
+/// get_record_id: Wallet storage ""get_record_id"" operation handler
+/// get_record_value: Wallet storage ""get_record_value"" operation handler
+/// get_record_tags: Wallet storage ""get_record_tags"" operation handler
+/// free_record: Wallet storage ""free_record"" operation handler
+/// search_records: Wallet storage ""search_records"" operation handler
+/// get_search_total_count: Wallet storage ""get_search_total_count"" operation handler
+/// get_search_count: Wallet storage ""get_search_count"" operation handler
+/// get_search_next_record: Wallet storage ""get_search_next_record"" operation handler
+/// free_search: Wallet storage ""free_search"" operation handler
+///
+/// #Returns
+/// Error code
+#[no_mangle]
+pub extern fn indy_register_wallet_storage(command_handle: i32,
+                                           type_: *const c_char,
+
+                                           /// Create the wallet storage (For example, database creation)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           create: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Delete the wallet storage (For example, database deletion)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           delete: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Open the wallet storage (For example, opening database connection)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// runtime_config: wallet storage runtime config (For example, connection config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           /// storage_handle_p: pointer to store opened storage handle
+                                           open: Option<extern fn(name: *const c_char,
+                                                                  config: *const c_char,
+                                                                  runtime_config: *const c_char,
+                                                                  credentials: *const c_char,
+                                                                  storage_handle_p: *mut i32) -> ErrorCode>,
+
+                                           /// Close the opened walled storage (For example, closing database connection)
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           close: Option<extern fn(handle: i32) -> ErrorCode>,
+
+                                           /// Create a new record in the wallet storage
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// value: the value of record (pointer to buffer)
+                                           /// value_len: the value of record (buffer size)
+                                           /// tags_json: the record tags used for search and storing meta information as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           add_record: Option<extern fn(storage_handle: i32,
+                                                                        type_: *const c_char,
+                                                                        id: *const c_char,
+                                                                        value: *const u8,
+                                                                        value_len: usize,
+                                                                        tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Update a record value
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// value: the value of record (pointer to buffer)
+                                           /// value_len: the value of record (buffer size)
+                                           update_record_value: Option<extern fn(storage_handle: i32,
+                                                                                 type_: *const c_char,
+                                                                                 id: *const c_char,
+                                                                                 value: *const c_char,
+                                                                                 value_len: usize) -> ErrorCode>,
+
+                                           /// Update a record tags
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tags_json: the new record tags used for search and storing meta information as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           update_record_tags: Option<extern fn(storage_handle: i32,
+                                                                                type_: *const c_char,
+                                                                                id: *const c_char,
+                                                                                tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Add new tags to the record
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tags_json: the additional record tags as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value,
+                                           ///     ...
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           ///   Note if some from provided tags already assigned to the record than
+                                           ///     corresponding tags values will be replaced
+                                           add_record_tags: Option<extern fn(storage_handle: i32,
+                                                                             type_: *const c_char,
+                                                                             id: *const c_char,
+                                                                             tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Delete tags from the record
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tag_names_json: the list of tag names to remove from the record as json array:
+                                           ///   [""tagName1"", ""tagName2"", ...]
+                                           ///   Note that null means no tag names
+                                           delete_record_tags: Option<extern fn(storage_handle: i32,
+                                                                                type_: *const c_char,
+                                                                                id: *const c_char,
+                                                                                tag_names_json: *const c_char) -> ErrorCode>,
+
+                                           /// Delete an existing record in the wallet storage
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: record type
+                                           /// id: the id of record
+                                           delete_record: Option<extern fn(storage_handle: i32,
+                                                                           type_: *const c_char,
+                                                                           id: *const c_char) -> ErrorCode>,
+
+                                           /// Get an wallet storage record by id
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// options_json: //TODO: FIXME: Think about replacing by bitmaks
+                                           ///  {
+                                           ///    retrieveValue: (optional, true by default) Retrieve record value,
+                                           ///    retrieveTags: (optional, true by default) Retrieve record tags
+                                           ///  }
+                                           /// record_handle_p: pointer to store retrieved record handle
+                                           get_record: Option<extern fn(storage_handle: u32,",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182074923,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182074923,vimmerru
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,missing value.,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-18 10:02:18,182374038,"@@ -0,0 +1,762 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Record ids will be always encrypted.
+  * Record values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secrets API
+
+It is our existing endpoints for secrets creation and access like ```indy_create_and_store_did``` or ```indy_create_and_store_cred_def```:
+
+1. Allow to create a secret into the wallet
+1. Return record id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Non-secrets API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+```Rust
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+extern pub fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+extern pub fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+///   Note that null means no tag names
+extern pub fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+extern pub fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode> {}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+extern pub fn indy_get_wallet_record(command_handle: u32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     options_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                          record_json: *const c_char)>) -> ErrorCode {}
+
+/// Search for wallet records.
+///
+/// Note instead of immediately returning of fetched records
+/// this call returns wallet_search_handle that can be used later
+/// to fetch records by small batches (with indy_fetch_wallet_search_next_records).
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// query_json: MongoDB style query to wallet record tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+///    retrieveTotalCount: (optional, false by default) Calculate total count,
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags,
+///  }
+/// #Returns
+/// wallet_search_handle: Wallet search handle that can be used later
+///   to fetch records by small batches (with indy_fetch_wallet_search_next_records)
+extern pub fn indy_open_wallet_search(command_handle: u32,
+                                      wallet_handle: i32,
+                                      type_: *const c_char,
+                                      query_json: *const c_char,
+                                      options_json: *const c_char,
+                                      cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                           wallet_search_handle_p: *mut i32)>) -> ErrorCode {}
+
+
+/// Fetch next records for wallet search.
+///
+/// Not if there are no records this call returns WalletNoRecords error.
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// wallet_search_handle: wallet wallet handle (created by indy_open_wallet_search)
+/// count: Count of records to fetch
+///
+/// #Returns
+/// wallet records json:
+/// {
+///   totalCount: <int>, // present only if retrieveTotalCount set to true
+///   records: [{ // present only if retrieveRecords set to true
+///       id: ""Some id"",
+///       value: ""Some value"", // present only if retrieveValue set to true
+///       tags: <tags json>, // present only if retrieveTags set to true
+///   }],
+/// }
+extern pub fn indy_fetch_wallet_search_next_records(command_handle: u32,
+                                                    wallet_handle: i32,
+                                                    wallet_search_handle: i32,
+                                                    count: u32,
+                                                    cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                                         records_json: *const c_char)>) -> ErrorCode {}
+```
+
+## Wallet API and Storage Interface
+
+Wallet API already exists and allows wallet management. It requires to be update to allow plugging different storages implementation to libindy. For example, to allow storing
+of wallet records in SQL database. To achieve this we will replace existing ```indy_register_wallet_type``` call with ```indy_register_wallet_storage``` call:
+
+```Rust
+/// Register custom wallet storage implementation.
+///
+/// It allows library user to provide custom wallet storage implementation as set of handlers.
+///
+/// #Params
+/// command_handle: Command handle to map callback to caller context.
+/// type_: Wallet storage name.
+/// create: Wallet storage ""create"" operation handler
+/// delete: Wallet storage ""delete"" operation handler
+/// open: Wallet storage ""open"" operation handler
+/// close: Wallet storage ""close"" operation handler
+/// add_record: Wallet storage ""add_record"" operation handler
+/// update_record_value: Wallet storage ""update_record_value"" operation handler
+/// update_record_tags: Wallet storage ""update_record_tags"" operation handler
+/// add_record_tags: Wallet storage ""add_record_tags"" operation handler
+/// delete_record_tags: Wallet storage ""delete_record_tags"" operation handler
+/// delete_record: Wallet storage ""delete_record"" operation handler
+/// get_record: Wallet storage ""get_record"" operation handler
+/// get_record_id: Wallet storage ""get_record_id"" operation handler
+/// get_record_value: Wallet storage ""get_record_value"" operation handler
+/// get_record_tags: Wallet storage ""get_record_tags"" operation handler
+/// free_record: Wallet storage ""free_record"" operation handler
+/// search_records: Wallet storage ""search_records"" operation handler
+/// get_search_total_count: Wallet storage ""get_search_total_count"" operation handler
+/// get_search_count: Wallet storage ""get_search_count"" operation handler
+/// get_search_next_record: Wallet storage ""get_search_next_record"" operation handler
+/// free_search: Wallet storage ""free_search"" operation handler
+///
+/// #Returns
+/// Error code
+#[no_mangle]
+pub extern fn indy_register_wallet_storage(command_handle: i32,
+                                           type_: *const c_char,
+
+                                           /// Create the wallet storage (For example, database creation)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           create: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Delete the wallet storage (For example, database deletion)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           delete: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Open the wallet storage (For example, opening database connection)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// runtime_config: wallet storage runtime config (For example, connection config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           /// storage_handle_p: pointer to store opened storage handle
+                                           open: Option<extern fn(name: *const c_char,
+                                                                  config: *const c_char,
+                                                                  runtime_config: *const c_char,
+                                                                  credentials: *const c_char,
+                                                                  storage_handle_p: *mut i32) -> ErrorCode>,
+
+                                           /// Close the opened walled storage (For example, closing database connection)
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           close: Option<extern fn(handle: i32) -> ErrorCode>,
+
+                                           /// Create a new record in the wallet storage
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// value: the value of record (pointer to buffer)
+                                           /// value_len: the value of record (buffer size)
+                                           /// tags_json: the record tags used for search and storing meta information as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           add_record: Option<extern fn(storage_handle: i32,
+                                                                        type_: *const c_char,
+                                                                        id: *const c_char,
+                                                                        value: *const u8,
+                                                                        value_len: usize,
+                                                                        tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Update a record value
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// value: the value of record (pointer to buffer)
+                                           /// value_len: the value of record (buffer size)
+                                           update_record_value: Option<extern fn(storage_handle: i32,
+                                                                                 type_: *const c_char,
+                                                                                 id: *const c_char,
+                                                                                 value: *const c_char,
+                                                                                 value_len: usize) -> ErrorCode>,
+
+                                           /// Update a record tags
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tags_json: the new record tags used for search and storing meta information as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           update_record_tags: Option<extern fn(storage_handle: i32,
+                                                                                type_: *const c_char,
+                                                                                id: *const c_char,
+                                                                                tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Add new tags to the record
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tags_json: the additional record tags as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value,
+                                           ///     ...
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           ///   Note if some from provided tags already assigned to the record than
+                                           ///     corresponding tags values will be replaced
+                                           add_record_tags: Option<extern fn(storage_handle: i32,
+                                                                             type_: *const c_char,
+                                                                             id: *const c_char,
+                                                                             tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Delete tags from the record
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tag_names_json: the list of tag names to remove from the record as json array:
+                                           ///   [""tagName1"", ""tagName2"", ...]
+                                           ///   Note that null means no tag names
+                                           delete_record_tags: Option<extern fn(storage_handle: i32,
+                                                                                type_: *const c_char,
+                                                                                id: *const c_char,
+                                                                                tag_names_json: *const c_char) -> ErrorCode>,
+
+                                           /// Delete an existing record in the wallet storage
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: record type
+                                           /// id: the id of record
+                                           delete_record: Option<extern fn(storage_handle: i32,
+                                                                           type_: *const c_char,
+                                                                           id: *const c_char) -> ErrorCode>,
+
+                                           /// Get an wallet storage record by id
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// options_json: //TODO: FIXME: Think about replacing by bitmaks
+                                           ///  {
+                                           ///    retrieveValue: (optional, true by default) Retrieve record value,
+                                           ///    retrieveTags: (optional, true by default) Retrieve record tags
+                                           ///  }
+                                           /// record_handle_p: pointer to store retrieved record handle
+                                           get_record: Option<extern fn(storage_handle: u32,
+                                                                        type_: *const c_char,
+                                                                        id: *const c_char,
+                                                                        options_json: *const c_char,
+                                                                        record_handle_p: *mut u32) -> ErrorCode>,
+
+                                          /// Get an id for retrieved wallet storage record
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// record_handle: retrieved record handle (See get_record handler)
+                                          ///
+                                          /// returns: record id
+                                          ///          Note that pointer lifetime the same as retrieved record lifetime
+                                          ///            (until record_free called)
+                                          get_record_id: Option<extern fn(storage_handle: u32,
+                                                                          record_handle: u32,
+                                                                          record_id_p: *mut *const c_char) -> ErrorCode>,
+
+                                          /// Get an value for retrieved wallet storage record
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// record_handle: retrieved record handle (See get_record handler)
+                                          ///
+                                          /// returns: record value
+                                          ///          Note that pointer lifetime the same as retrieved record lifetime
+                                          ///            (until record_free called)
+                                          ///          Note that null be returned if no value retrieved
+                                          get_record_value: Option<extern fn(storage_handle: u32,
+                                                                             record_handle: u32,
+                                                                             record_value_p: *mut *const u8,
+                                                                             record_value_len_p: *mut i32) -> ErrorCode>,
+
+                                          /// Get an tags for retrieved wallet record
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// record_handle: retrieved record handle (See get_record handler)
+                                          ///
+                                          /// returns: record tags as json
+                                          ///          Note that pointer lifetime the same as retrieved record lifetime
+                                          ///            (until record_free called)
+                                          ///          Note that null be returned if no tags retrieved
+                                          get_record_tags: Option<extern fn(storage_handle: u32,
+                                                                            record_handle: u32,
+                                                                            record_tags_p: *mut *const c_char) -> ErrorCode>,
+
+                                          /// Free retrieved wallet record (make retrieved record handle invalid)
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open_wallet_storage)
+                                          /// record_handle: retrieved record handle (See wallet_storage_get_wallet_record)
+                                          free_record: Option<extern fn(storage_handle: u32,
+                                                                        record_handle: u32) -> ErrorCode>,
+
+                                          /// Search for wallet storage records
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// type_: allows to separate different record types collections
+                                          /// query_json: MongoDB style query to wallet record tags:
+                                          ///  {
+                                          ///    ""tagName"": ""tagValue"",
+                                          ///    $or: {
+                                          ///      ""tagName2"": { $regex: 'pattern' },
+                                          ///      ""tagName3"": { $gte: 123 },
+                                          ///    },
+                                          ///  }
+                                          /// options_json: //TODO: FIXME: Think about replacing by bitmaks
+                                          ///  {
+                                          ///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+                                          ///    retrieveTotalCount: (optional, false by default) Calculate total count,
+                                          ///    retrieveValue: (optional, true by default) Retrieve record value,
+                                          ///    retrieveTags: (optional, true by default) Retrieve record tags,
+                                          ///  }
+                                          /// search_handle_p: pointer to store wallet search handle
+                                          search_records: Option<extern fn(storage_handle: u32,
+                                                                           type_: *const c_char,
+                                                                           query_json: *const c_char,
+                                                                           options_json: *const c_char,
+                                                                           search_handle_p: *mut u32) -> ErrorCode>,
+
+                                          /// Get total count of records that corresponds to wallet storage search query
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// search_handle: wallet search handle (See search_records handler)
+                                          ///
+                                          /// returns: total count of records that corresponds to wallet storage search query
+                                          ///          Note -1 will be returned if retrieveTotalCount set to false for search_records
+                                          get_search_total_count: Option<extern fn(storage_handle: u32,
+                                                                                   search_handle: u32,
+                                                                                   total_count_p: *mut u32) -> ErrorCode>,
+
+                                          /// Get the next wallet storage record handle retrieved by this wallet search.
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// search_handle: wallet search handle (See search_records handler)
+                                          ///
+                                          /// returns: record handle (the same as for get_record handler)
+                                          ///          Note if no more records WalletNoRecords error will be returned
+                                          fetch_search_next_record: Option<extern fn(storage_handle: u32,
+                                                                                     search_handle: u32,
+                                                                                     record_handle_p: *mut i32) -> ErrorCode>,
+
+                                          /// Free wallet search (make search handle invalid)
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// search_handle: wallet search handle (See search_records handler)
+                                          free_search: Option<extern fn(storage_handle: u32,
+                                                                        search_handle: u32) -> ErrorCode>,
+
+                                          cb: Option<extern fn(command_handle_: i32,
+                                                               err: ErrorCode)>) -> ErrorCode
+```
+
+Storage Interface entities are:
+
+![Storage Interface entities](./storage-interface.svg)
+
+## Wallet Service Interface
+
+```Rust
+
+impl WalletService {
+
+  pub fn new() -> WalletService {}
+
+  pub fn register_wallet_storage(&self,
+                                 type_: *const c_char,
+                                 create: extern fn(name: *const c_char,
+                                                   config: *const c_char)  -> ErrorCode,
+                                 delete: extern fn(name: *const c_char,
+                                                   config: *const c_char,
+                                                   credentials: *const c_char) -> ErrorCode,
+                                 open: extern fn(name: *const c_char,
+                                                 config: *const c_char,
+                                                 runtime_config: *const c_char,
+                                                 credentials: *const c_char,
+                                                 storage_handle_p: *mut i32) -> ErrorCode,
+                                 close: extern fn(handle: i32) -> ErrorCode,
+                                 add_record: extern fn(storage_handle: i32,
+                                                       type_: *const c_char,
+                                                       id: *const c_char,
+                                                       value: *const c_char,
+                                                       tags_json: *const c_char) -> ErrorCode,
+                                 update_record_value: extern fn(storage_handle: i32,
+                                                                type_: *const c_char,
+                                                                id: *const c_char,
+                                                                value: *const c_char) -> ErrorCode,
+                                 update_record_tags: extern fn(storage_handle: i32,
+                                                               type_: *const c_char,
+                                                               id: *const c_char,
+                                                               tags_json: *const c_char) -> ErrorCode,
+                                 add_record_tags: extern fn(storage_handle: i32,
+                                                            type_: *const c_char,
+                                                            id: *const c_char,
+                                                            tags_json: *const c_char) -> ErrorCode,
+                                 delete_record_tags: extern fn(storage_handle: i32,
+                                                               type_: *const c_char,
+                                                               id: *const c_char,
+                                                               tag_names_json: *const c_char) -> ErrorCode,
+                                 delete_record: extern fn(storage_handle: i32,
+                                                          type_: *const c_char,
+                                                          id: *const c_char) -> ErrorCode,
+                                 get_record: extern fn(storage_handle: u32,
+                                                       type_: *const c_char,
+                                                       id: *const c_char,
+                                                       options_json: *const c_char,
+                                                       record_handle_p: *mut u32) -> ErrorCode,
+                                 get_record_id: extern fn(storage_handle: u32,
+                                                          record_handle: u32,
+                                                          record_id_p: *mut *const c_char) -> ErrorCode,
+                                 get_record_value: extern fn(storage_handle: u32,
+                                                             record_handle: u32,
+                                                             record_value_p: *mut *const u8,
+                                                             record_value_len_p: *mut usize) -> ErrorCode,
+                                 get_record_tags: extern fn(storage_handle: u32,
+                                                            record_handle: u32,
+                                                            record_tags_p: *mut *const c_char) -> ErrorCode,
+                                 free_record: extern fn(storage_handle: u32,
+                                                        record_handle: u32) -> ErrorCode,
+                                 search_records: extern fn(storage_handle: u32,
+                                                           type_: *const c_char,
+                                                           query_json: *const c_char,
+                                                           options_json: *const c_char,
+                                                           search_handle_p: *mut u32) -> ErrorCode,
+                                 get_search_total_count: extern fn(storage_handle: u32,
+                                                                   search_handle: u32,
+                                                                   total_count_p: *mut u32) -> ErrorCode,
+                                 fetch_search_next_record: Option<extern fn(storage_handle: u32,
+                                                                            search_handle: u32,
+                                                                            record_handle_p: *mut i32) -> ErrorCode,
+                                 free_search: extern fn(storage_handle: u32,
+                                                        search_handle: u32) -> ErrorCode>) -> Result<(), WalletError> {}
+
+   pub fn create_wallet(&self,
+                        pool_name: &str,
+                        name: &str,
+                        storage_type: Option<&str>,
+                        storage_config: Option<&str>,
+                        credentials: &str) -> Result<(), WalletError> {}
+
+   pub fn delete_wallet(&self,
+                        name: &str,
+                        credentials: &str) -> Result<(), WalletError> {}
+
+   pub fn open_wallet(&self,
+                      name: &str,
+                      credentials: &str) -> Result<i32, WalletError> {}
+
+   pub fn close_wallet(&self,
+                       wallet_handle: i32) -> Result<(), WalletError> {}
+
+   pub fn list_wallets(&self) -> Result<Vec<WalletMetadata>, WalletError> {}
+
+   pub fn add_record(wallet_handle: i32,
+                     type_: &str,
+                     id: &str,",702,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182374038,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182374038,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,get_record_type would also be needed for export.,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-18 10:13:42,182376988,"@@ -0,0 +1,768 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Record ids will be always encrypted.
+  * Record values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secrets API
+
+It is our existing endpoints for secrets creation and access like ```indy_create_and_store_did``` or ```indy_create_and_store_cred_def```:
+
+1. Allow to create a secret into the wallet
+1. Return record id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Non-secrets API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+```Rust
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+extern pub fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+extern pub fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+///   Note that null means no tag names
+extern pub fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+extern pub fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode> {}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+extern pub fn indy_get_wallet_record(command_handle: u32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     options_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                          record_json: *const c_char)>) -> ErrorCode {}
+
+/// Search for wallet records.
+///
+/// Note instead of immediately returning of fetched records
+/// this call returns wallet_search_handle that can be used later
+/// to fetch records by small batches (with indy_fetch_wallet_search_next_records).
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// query_json: MongoDB style query to wallet record tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+///    retrieveTotalCount: (optional, false by default) Calculate total count,
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags,
+///  }
+/// #Returns
+/// wallet_search_handle: Wallet search handle that can be used later
+///   to fetch records by small batches (with indy_fetch_wallet_search_next_records)
+extern pub fn indy_open_wallet_search(command_handle: u32,
+                                      wallet_handle: i32,
+                                      type_: *const c_char,
+                                      query_json: *const c_char,
+                                      options_json: *const c_char,
+                                      cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                           wallet_search_handle_p: *mut i32)>) -> ErrorCode {}
+
+
+/// Fetch next records for wallet search.
+///
+/// Not if there are no records this call returns WalletNoRecords error.
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// wallet_search_handle: wallet wallet handle (created by indy_open_wallet_search)
+/// count: Count of records to fetch
+///
+/// #Returns
+/// wallet records json:
+/// {
+///   totalCount: <int>, // present only if retrieveTotalCount set to true
+///   records: [{ // present only if retrieveRecords set to true
+///       id: ""Some id"",
+///       value: ""Some value"", // present only if retrieveValue set to true
+///       tags: <tags json>, // present only if retrieveTags set to true
+///   }],
+/// }
+extern pub fn indy_fetch_wallet_search_next_records(command_handle: u32,
+                                                    wallet_handle: i32,
+                                                    wallet_search_handle: i32,
+                                                    count: u32,
+                                                    cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                                         records_json: *const c_char)>) -> ErrorCode {}
+```
+
+## Wallet API and Storage Interface
+
+Wallet API already exists and allows wallet management. It requires to be update to allow plugging different storages implementation to libindy. For example, to allow storing
+of wallet records in SQL database. To achieve this we will replace existing ```indy_register_wallet_type``` call with ```indy_register_wallet_storage``` call:
+
+```Rust
+/// Register custom wallet storage implementation.
+///
+/// It allows library user to provide custom wallet storage implementation as set of handlers.
+///
+/// #Params
+/// command_handle: Command handle to map callback to caller context.
+/// type_: Wallet storage name.
+/// create: Wallet storage ""create"" operation handler
+/// delete: Wallet storage ""delete"" operation handler
+/// open: Wallet storage ""open"" operation handler
+/// close: Wallet storage ""close"" operation handler
+/// add_record: Wallet storage ""add_record"" operation handler
+/// update_record_value: Wallet storage ""update_record_value"" operation handler
+/// update_record_tags: Wallet storage ""update_record_tags"" operation handler
+/// add_record_tags: Wallet storage ""add_record_tags"" operation handler
+/// delete_record_tags: Wallet storage ""delete_record_tags"" operation handler
+/// delete_record: Wallet storage ""delete_record"" operation handler
+/// get_record: Wallet storage ""get_record"" operation handler
+/// get_record_id: Wallet storage ""get_record_id"" operation handler",286,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182376988,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182376988,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,"handles are sometimes i32, sometimes u32, which one is correct?",9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-18 10:33:31,182381616,"@@ -0,0 +1,768 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Record ids will be always encrypted.
+  * Record values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secrets API
+
+It is our existing endpoints for secrets creation and access like ```indy_create_and_store_did``` or ```indy_create_and_store_cred_def```:
+
+1. Allow to create a secret into the wallet
+1. Return record id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Non-secrets API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+```Rust
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+extern pub fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+extern pub fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+///   Note that null means no tag names
+extern pub fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+extern pub fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode> {}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+extern pub fn indy_get_wallet_record(command_handle: u32,
+                                     wallet_handle: i32,",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182381616,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182381616,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,"OK, this is acceptable. ",9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-18 10:34:38,182381898,"@@ -0,0 +1,762 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Record ids will be always encrypted.
+  * Record values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secrets API
+
+It is our existing endpoints for secrets creation and access like ```indy_create_and_store_did``` or ```indy_create_and_store_cred_def```:
+
+1. Allow to create a secret into the wallet
+1. Return record id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Non-secrets API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+```Rust
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+extern pub fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+extern pub fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+///   Note that null means no tag names
+extern pub fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+extern pub fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode> {}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+extern pub fn indy_get_wallet_record(command_handle: u32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     options_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                          record_json: *const c_char)>) -> ErrorCode {}
+
+/// Search for wallet records.
+///
+/// Note instead of immediately returning of fetched records
+/// this call returns wallet_search_handle that can be used later
+/// to fetch records by small batches (with indy_fetch_wallet_search_next_records).
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// query_json: MongoDB style query to wallet record tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+///    retrieveTotalCount: (optional, false by default) Calculate total count,
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags,
+///  }
+/// #Returns
+/// wallet_search_handle: Wallet search handle that can be used later
+///   to fetch records by small batches (with indy_fetch_wallet_search_next_records)
+extern pub fn indy_open_wallet_search(command_handle: u32,
+                                      wallet_handle: i32,
+                                      type_: *const c_char,
+                                      query_json: *const c_char,
+                                      options_json: *const c_char,
+                                      cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                           wallet_search_handle_p: *mut i32)>) -> ErrorCode {}
+
+
+/// Fetch next records for wallet search.
+///
+/// Not if there are no records this call returns WalletNoRecords error.
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// wallet_search_handle: wallet wallet handle (created by indy_open_wallet_search)
+/// count: Count of records to fetch
+///
+/// #Returns
+/// wallet records json:
+/// {
+///   totalCount: <int>, // present only if retrieveTotalCount set to true
+///   records: [{ // present only if retrieveRecords set to true
+///       id: ""Some id"",
+///       value: ""Some value"", // present only if retrieveValue set to true
+///       tags: <tags json>, // present only if retrieveTags set to true
+///   }],
+/// }
+extern pub fn indy_fetch_wallet_search_next_records(command_handle: u32,
+                                                    wallet_handle: i32,
+                                                    wallet_search_handle: i32,
+                                                    count: u32,
+                                                    cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                                         records_json: *const c_char)>) -> ErrorCode {}
+```
+
+## Wallet API and Storage Interface
+
+Wallet API already exists and allows wallet management. It requires to be update to allow plugging different storages implementation to libindy. For example, to allow storing
+of wallet records in SQL database. To achieve this we will replace existing ```indy_register_wallet_type``` call with ```indy_register_wallet_storage``` call:
+
+```Rust
+/// Register custom wallet storage implementation.
+///
+/// It allows library user to provide custom wallet storage implementation as set of handlers.
+///
+/// #Params
+/// command_handle: Command handle to map callback to caller context.
+/// type_: Wallet storage name.
+/// create: Wallet storage ""create"" operation handler
+/// delete: Wallet storage ""delete"" operation handler
+/// open: Wallet storage ""open"" operation handler
+/// close: Wallet storage ""close"" operation handler
+/// add_record: Wallet storage ""add_record"" operation handler
+/// update_record_value: Wallet storage ""update_record_value"" operation handler
+/// update_record_tags: Wallet storage ""update_record_tags"" operation handler
+/// add_record_tags: Wallet storage ""add_record_tags"" operation handler
+/// delete_record_tags: Wallet storage ""delete_record_tags"" operation handler
+/// delete_record: Wallet storage ""delete_record"" operation handler
+/// get_record: Wallet storage ""get_record"" operation handler
+/// get_record_id: Wallet storage ""get_record_id"" operation handler
+/// get_record_value: Wallet storage ""get_record_value"" operation handler
+/// get_record_tags: Wallet storage ""get_record_tags"" operation handler
+/// free_record: Wallet storage ""free_record"" operation handler
+/// search_records: Wallet storage ""search_records"" operation handler
+/// get_search_total_count: Wallet storage ""get_search_total_count"" operation handler
+/// get_search_count: Wallet storage ""get_search_count"" operation handler
+/// get_search_next_record: Wallet storage ""get_search_next_record"" operation handler
+/// free_search: Wallet storage ""free_search"" operation handler
+///
+/// #Returns
+/// Error code
+#[no_mangle]
+pub extern fn indy_register_wallet_storage(command_handle: i32,
+                                           type_: *const c_char,
+
+                                           /// Create the wallet storage (For example, database creation)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           create: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Delete the wallet storage (For example, database deletion)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           delete: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Open the wallet storage (For example, opening database connection)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// runtime_config: wallet storage runtime config (For example, connection config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           /// storage_handle_p: pointer to store opened storage handle
+                                           open: Option<extern fn(name: *const c_char,
+                                                                  config: *const c_char,
+                                                                  runtime_config: *const c_char,
+                                                                  credentials: *const c_char,
+                                                                  storage_handle_p: *mut i32) -> ErrorCode>,
+
+                                           /// Close the opened walled storage (For example, closing database connection)
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           close: Option<extern fn(handle: i32) -> ErrorCode>,
+
+                                           /// Create a new record in the wallet storage
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// value: the value of record (pointer to buffer)
+                                           /// value_len: the value of record (buffer size)
+                                           /// tags_json: the record tags used for search and storing meta information as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           add_record: Option<extern fn(storage_handle: i32,
+                                                                        type_: *const c_char,
+                                                                        id: *const c_char,
+                                                                        value: *const u8,
+                                                                        value_len: usize,
+                                                                        tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Update a record value
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// value: the value of record (pointer to buffer)
+                                           /// value_len: the value of record (buffer size)
+                                           update_record_value: Option<extern fn(storage_handle: i32,
+                                                                                 type_: *const c_char,
+                                                                                 id: *const c_char,
+                                                                                 value: *const c_char,
+                                                                                 value_len: usize) -> ErrorCode>,
+
+                                           /// Update a record tags
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tags_json: the new record tags used for search and storing meta information as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           update_record_tags: Option<extern fn(storage_handle: i32,
+                                                                                type_: *const c_char,
+                                                                                id: *const c_char,
+                                                                                tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Add new tags to the record
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tags_json: the additional record tags as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value,
+                                           ///     ...
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           ///   Note if some from provided tags already assigned to the record than
+                                           ///     corresponding tags values will be replaced
+                                           add_record_tags: Option<extern fn(storage_handle: i32,
+                                                                             type_: *const c_char,
+                                                                             id: *const c_char,
+                                                                             tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Delete tags from the record
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tag_names_json: the list of tag names to remove from the record as json array:
+                                           ///   [""tagName1"", ""tagName2"", ...]
+                                           ///   Note that null means no tag names
+                                           delete_record_tags: Option<extern fn(storage_handle: i32,
+                                                                                type_: *const c_char,
+                                                                                id: *const c_char,
+                                                                                tag_names_json: *const c_char) -> ErrorCode>,
+
+                                           /// Delete an existing record in the wallet storage
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: record type
+                                           /// id: the id of record
+                                           delete_record: Option<extern fn(storage_handle: i32,
+                                                                           type_: *const c_char,
+                                                                           id: *const c_char) -> ErrorCode>,
+
+                                           /// Get an wallet storage record by id
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// options_json: //TODO: FIXME: Think about replacing by bitmaks
+                                           ///  {
+                                           ///    retrieveValue: (optional, true by default) Retrieve record value,
+                                           ///    retrieveTags: (optional, true by default) Retrieve record tags
+                                           ///  }
+                                           /// record_handle_p: pointer to store retrieved record handle
+                                           get_record: Option<extern fn(storage_handle: u32,",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182381898,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182381898,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,There is no use for ErrorCode in free functions. You cannot do anything in case of error. It is probably the best if those functions do not have return value.,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-18 12:41:31,182411030,"@@ -0,0 +1,768 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Record ids will be always encrypted.
+  * Record values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secrets API
+
+It is our existing endpoints for secrets creation and access like ```indy_create_and_store_did``` or ```indy_create_and_store_cred_def```:
+
+1. Allow to create a secret into the wallet
+1. Return record id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Non-secrets API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+```Rust
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+extern pub fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+extern pub fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+///   Note that null means no tag names
+extern pub fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+extern pub fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode> {}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+extern pub fn indy_get_wallet_record(command_handle: u32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     options_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                          record_json: *const c_char)>) -> ErrorCode {}
+
+/// Search for wallet records.
+///
+/// Note instead of immediately returning of fetched records
+/// this call returns wallet_search_handle that can be used later
+/// to fetch records by small batches (with indy_fetch_wallet_search_next_records).
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// query_json: MongoDB style query to wallet record tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+///    retrieveTotalCount: (optional, false by default) Calculate total count,
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags,
+///  }
+/// #Returns
+/// wallet_search_handle: Wallet search handle that can be used later
+///   to fetch records by small batches (with indy_fetch_wallet_search_next_records)
+extern pub fn indy_open_wallet_search(command_handle: u32,
+                                      wallet_handle: i32,
+                                      type_: *const c_char,
+                                      query_json: *const c_char,
+                                      options_json: *const c_char,
+                                      cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                           wallet_search_handle_p: *mut i32)>) -> ErrorCode {}
+
+
+/// Fetch next records for wallet search.
+///
+/// Not if there are no records this call returns WalletNoRecords error.
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// wallet_search_handle: wallet wallet handle (created by indy_open_wallet_search)
+/// count: Count of records to fetch
+///
+/// #Returns
+/// wallet records json:
+/// {
+///   totalCount: <int>, // present only if retrieveTotalCount set to true
+///   records: [{ // present only if retrieveRecords set to true
+///       id: ""Some id"",
+///       value: ""Some value"", // present only if retrieveValue set to true
+///       tags: <tags json>, // present only if retrieveTags set to true
+///   }],
+/// }
+extern pub fn indy_fetch_wallet_search_next_records(command_handle: u32,
+                                                    wallet_handle: i32,
+                                                    wallet_search_handle: i32,
+                                                    count: u32,
+                                                    cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                                         records_json: *const c_char)>) -> ErrorCode {}
+```
+
+## Wallet API and Storage Interface
+
+Wallet API already exists and allows wallet management. It requires to be update to allow plugging different storages implementation to libindy. For example, to allow storing
+of wallet records in SQL database. To achieve this we will replace existing ```indy_register_wallet_type``` call with ```indy_register_wallet_storage``` call:
+
+```Rust
+/// Register custom wallet storage implementation.
+///
+/// It allows library user to provide custom wallet storage implementation as set of handlers.
+///
+/// #Params
+/// command_handle: Command handle to map callback to caller context.
+/// type_: Wallet storage name.
+/// create: Wallet storage ""create"" operation handler
+/// delete: Wallet storage ""delete"" operation handler
+/// open: Wallet storage ""open"" operation handler
+/// close: Wallet storage ""close"" operation handler
+/// add_record: Wallet storage ""add_record"" operation handler
+/// update_record_value: Wallet storage ""update_record_value"" operation handler
+/// update_record_tags: Wallet storage ""update_record_tags"" operation handler
+/// add_record_tags: Wallet storage ""add_record_tags"" operation handler
+/// delete_record_tags: Wallet storage ""delete_record_tags"" operation handler
+/// delete_record: Wallet storage ""delete_record"" operation handler
+/// get_record: Wallet storage ""get_record"" operation handler
+/// get_record_id: Wallet storage ""get_record_id"" operation handler
+/// get_record_value: Wallet storage ""get_record_value"" operation handler
+/// get_record_tags: Wallet storage ""get_record_tags"" operation handler
+/// free_record: Wallet storage ""free_record"" operation handler
+/// search_records: Wallet storage ""search_records"" operation handler
+/// get_search_total_count: Wallet storage ""get_search_total_count"" operation handler
+/// get_search_count: Wallet storage ""get_search_count"" operation handler
+/// get_search_next_record: Wallet storage ""get_search_next_record"" operation handler
+/// free_search: Wallet storage ""free_search"" operation handler
+///
+/// #Returns
+/// Error code
+#[no_mangle]
+pub extern fn indy_register_wallet_storage(command_handle: i32,
+                                           type_: *const c_char,
+
+                                           /// Create the wallet storage (For example, database creation)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           create: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Delete the wallet storage (For example, database deletion)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           delete: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Open the wallet storage (For example, opening database connection)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// runtime_config: wallet storage runtime config (For example, connection config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           /// storage_handle_p: pointer to store opened storage handle
+                                           open: Option<extern fn(name: *const c_char,
+                                                                  config: *const c_char,
+                                                                  runtime_config: *const c_char,
+                                                                  credentials: *const c_char,
+                                                                  storage_handle_p: *mut i32) -> ErrorCode>,
+
+                                           /// Close the opened walled storage (For example, closing database connection)
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           close: Option<extern fn(handle: i32) -> ErrorCode>,
+
+                                           /// Create a new record in the wallet storage
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// value: the value of record (pointer to buffer)
+                                           /// value_len: the value of record (buffer size)
+                                           /// tags_json: the record tags used for search and storing meta information as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           add_record: Option<extern fn(storage_handle: i32,
+                                                                        type_: *const c_char,
+                                                                        id: *const c_char,
+                                                                        value: *const u8,
+                                                                        value_len: usize,
+                                                                        tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Update a record value
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// value: the value of record (pointer to buffer)
+                                           /// value_len: the value of record (buffer size)
+                                           update_record_value: Option<extern fn(storage_handle: i32,
+                                                                                 type_: *const c_char,
+                                                                                 id: *const c_char,
+                                                                                 value: *const c_char,
+                                                                                 value_len: usize) -> ErrorCode>,
+
+                                           /// Update a record tags
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tags_json: the new record tags used for search and storing meta information as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           update_record_tags: Option<extern fn(storage_handle: i32,
+                                                                                type_: *const c_char,
+                                                                                id: *const c_char,
+                                                                                tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Add new tags to the record
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tags_json: the additional record tags as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value,
+                                           ///     ...
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           ///   Note if some from provided tags already assigned to the record than
+                                           ///     corresponding tags values will be replaced
+                                           add_record_tags: Option<extern fn(storage_handle: i32,
+                                                                             type_: *const c_char,
+                                                                             id: *const c_char,
+                                                                             tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Delete tags from the record
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tag_names_json: the list of tag names to remove from the record as json array:
+                                           ///   [""tagName1"", ""tagName2"", ...]
+                                           ///   Note that null means no tag names
+                                           delete_record_tags: Option<extern fn(storage_handle: i32,
+                                                                                type_: *const c_char,
+                                                                                id: *const c_char,
+                                                                                tag_names_json: *const c_char) -> ErrorCode>,
+
+                                           /// Delete an existing record in the wallet storage
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: record type
+                                           /// id: the id of record
+                                           delete_record: Option<extern fn(storage_handle: i32,
+                                                                           type_: *const c_char,
+                                                                           id: *const c_char) -> ErrorCode>,
+
+                                           /// Get an wallet storage record by id
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// options_json: //TODO: FIXME: Think about replacing by bitmaks
+                                           ///  {
+                                           ///    retrieveValue: (optional, true by default) Retrieve record value,
+                                           ///    retrieveTags: (optional, true by default) Retrieve record tags
+                                           ///  }
+                                           /// record_handle_p: pointer to store retrieved record handle
+                                           get_record: Option<extern fn(storage_handle: u32,
+                                                                        type_: *const c_char,
+                                                                        id: *const c_char,
+                                                                        options_json: *const c_char,
+                                                                        record_handle_p: *mut u32) -> ErrorCode>,
+
+                                          /// Get an id for retrieved wallet storage record
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// record_handle: retrieved record handle (See get_record handler)
+                                          ///
+                                          /// returns: record id
+                                          ///          Note that pointer lifetime the same as retrieved record lifetime
+                                          ///            (until record_free called)
+                                          get_record_id: Option<extern fn(storage_handle: u32,
+                                                                          record_handle: u32,
+                                                                          record_id_p: *mut *const c_char) -> ErrorCode>,
+
+                                          /// Get an value for retrieved wallet storage record
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// record_handle: retrieved record handle (See get_record handler)
+                                          ///
+                                          /// returns: record value
+                                          ///          Note that pointer lifetime the same as retrieved record lifetime
+                                          ///            (until record_free called)
+                                          ///          Note that null be returned if no value retrieved
+                                          get_record_value: Option<extern fn(storage_handle: u32,
+                                                                             record_handle: u32,
+                                                                             record_value_p: *mut *const u8,
+                                                                             record_value_len_p: *mut i32) -> ErrorCode>,
+
+                                          /// Get an tags for retrieved wallet record
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// record_handle: retrieved record handle (See get_record handler)
+                                          ///
+                                          /// returns: record tags as json
+                                          ///          Note that pointer lifetime the same as retrieved record lifetime
+                                          ///            (until record_free called)
+                                          ///          Note that null be returned if no tags retrieved
+                                          get_record_tags: Option<extern fn(storage_handle: u32,
+                                                                            record_handle: u32,
+                                                                            record_tags_p: *mut *const c_char) -> ErrorCode>,
+
+                                          /// Free retrieved wallet record (make retrieved record handle invalid)
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open_wallet_storage)
+                                          /// record_handle: retrieved record handle (See wallet_storage_get_wallet_record)
+                                          free_record: Option<extern fn(storage_handle: u32,",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182411030,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182411030,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,Order of extern functions seams totally random. We should create some logical order.,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-18 13:02:13,182417137,"@@ -0,0 +1,768 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Record ids will be always encrypted.
+  * Record values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secrets API
+
+It is our existing endpoints for secrets creation and access like ```indy_create_and_store_did``` or ```indy_create_and_store_cred_def```:
+
+1. Allow to create a secret into the wallet
+1. Return record id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Non-secrets API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+```Rust
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+extern pub fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+extern pub fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+///   Note that null means no tag names
+extern pub fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+extern pub fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode> {}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+extern pub fn indy_get_wallet_record(command_handle: u32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     options_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                          record_json: *const c_char)>) -> ErrorCode {}
+
+/// Search for wallet records.
+///
+/// Note instead of immediately returning of fetched records
+/// this call returns wallet_search_handle that can be used later
+/// to fetch records by small batches (with indy_fetch_wallet_search_next_records).
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// query_json: MongoDB style query to wallet record tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+///    retrieveTotalCount: (optional, false by default) Calculate total count,
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags,
+///  }
+/// #Returns
+/// wallet_search_handle: Wallet search handle that can be used later
+///   to fetch records by small batches (with indy_fetch_wallet_search_next_records)
+extern pub fn indy_open_wallet_search(command_handle: u32,
+                                      wallet_handle: i32,
+                                      type_: *const c_char,
+                                      query_json: *const c_char,
+                                      options_json: *const c_char,
+                                      cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                           wallet_search_handle_p: *mut i32)>) -> ErrorCode {}
+
+
+/// Fetch next records for wallet search.
+///
+/// Not if there are no records this call returns WalletNoRecords error.
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// wallet_search_handle: wallet wallet handle (created by indy_open_wallet_search)
+/// count: Count of records to fetch
+///
+/// #Returns
+/// wallet records json:
+/// {
+///   totalCount: <int>, // present only if retrieveTotalCount set to true
+///   records: [{ // present only if retrieveRecords set to true
+///       id: ""Some id"",
+///       value: ""Some value"", // present only if retrieveValue set to true
+///       tags: <tags json>, // present only if retrieveTags set to true
+///   }],
+/// }
+extern pub fn indy_fetch_wallet_search_next_records(command_handle: u32,
+                                                    wallet_handle: i32,
+                                                    wallet_search_handle: i32,
+                                                    count: u32,
+                                                    cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                                         records_json: *const c_char)>) -> ErrorCode {}
+```
+
+## Wallet API and Storage Interface
+
+Wallet API already exists and allows wallet management. It requires to be update to allow plugging different storages implementation to libindy. For example, to allow storing
+of wallet records in SQL database. To achieve this we will replace existing ```indy_register_wallet_type``` call with ```indy_register_wallet_storage``` call:
+
+```Rust
+/// Register custom wallet storage implementation.
+///
+/// It allows library user to provide custom wallet storage implementation as set of handlers.
+///
+/// #Params
+/// command_handle: Command handle to map callback to caller context.
+/// type_: Wallet storage name.
+/// create: Wallet storage ""create"" operation handler
+/// delete: Wallet storage ""delete"" operation handler
+/// open: Wallet storage ""open"" operation handler
+/// close: Wallet storage ""close"" operation handler
+/// add_record: Wallet storage ""add_record"" operation handler
+/// update_record_value: Wallet storage ""update_record_value"" operation handler
+/// update_record_tags: Wallet storage ""update_record_tags"" operation handler
+/// add_record_tags: Wallet storage ""add_record_tags"" operation handler
+/// delete_record_tags: Wallet storage ""delete_record_tags"" operation handler
+/// delete_record: Wallet storage ""delete_record"" operation handler
+/// get_record: Wallet storage ""get_record"" operation handler
+/// get_record_id: Wallet storage ""get_record_id"" operation handler
+/// get_record_value: Wallet storage ""get_record_value"" operation handler
+/// get_record_tags: Wallet storage ""get_record_tags"" operation handler
+/// free_record: Wallet storage ""free_record"" operation handler
+/// search_records: Wallet storage ""search_records"" operation handler
+/// get_search_total_count: Wallet storage ""get_search_total_count"" operation handler
+/// get_search_count: Wallet storage ""get_search_count"" operation handler
+/// get_search_next_record: Wallet storage ""get_search_next_record"" operation handler
+/// free_search: Wallet storage ""free_search"" operation handler
+///
+/// #Returns
+/// Error code
+#[no_mangle]
+pub extern fn indy_register_wallet_storage(command_handle: i32,",299,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182417137,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182417137,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,"For export functionality it is needed some get_all or similar which will return search handle, so that wallet can retrieve all records from database.",9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-18 13:04:04,182417731,"@@ -0,0 +1,768 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Record ids will be always encrypted.
+  * Record values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secrets API
+
+It is our existing endpoints for secrets creation and access like ```indy_create_and_store_did``` or ```indy_create_and_store_cred_def```:
+
+1. Allow to create a secret into the wallet
+1. Return record id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Non-secrets API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+```Rust
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+extern pub fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+extern pub fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+///   Note that null means no tag names
+extern pub fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+extern pub fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode> {}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+extern pub fn indy_get_wallet_record(command_handle: u32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     options_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                          record_json: *const c_char)>) -> ErrorCode {}
+
+/// Search for wallet records.
+///
+/// Note instead of immediately returning of fetched records
+/// this call returns wallet_search_handle that can be used later
+/// to fetch records by small batches (with indy_fetch_wallet_search_next_records).
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// query_json: MongoDB style query to wallet record tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+///    retrieveTotalCount: (optional, false by default) Calculate total count,
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags,
+///  }
+/// #Returns
+/// wallet_search_handle: Wallet search handle that can be used later
+///   to fetch records by small batches (with indy_fetch_wallet_search_next_records)
+extern pub fn indy_open_wallet_search(command_handle: u32,
+                                      wallet_handle: i32,
+                                      type_: *const c_char,
+                                      query_json: *const c_char,
+                                      options_json: *const c_char,
+                                      cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                           wallet_search_handle_p: *mut i32)>) -> ErrorCode {}
+
+
+/// Fetch next records for wallet search.
+///
+/// Not if there are no records this call returns WalletNoRecords error.
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// wallet_search_handle: wallet wallet handle (created by indy_open_wallet_search)
+/// count: Count of records to fetch
+///
+/// #Returns
+/// wallet records json:
+/// {
+///   totalCount: <int>, // present only if retrieveTotalCount set to true
+///   records: [{ // present only if retrieveRecords set to true
+///       id: ""Some id"",
+///       value: ""Some value"", // present only if retrieveValue set to true
+///       tags: <tags json>, // present only if retrieveTags set to true
+///   }],
+/// }
+extern pub fn indy_fetch_wallet_search_next_records(command_handle: u32,
+                                                    wallet_handle: i32,
+                                                    wallet_search_handle: i32,
+                                                    count: u32,
+                                                    cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                                         records_json: *const c_char)>) -> ErrorCode {}
+```
+
+## Wallet API and Storage Interface
+
+Wallet API already exists and allows wallet management. It requires to be update to allow plugging different storages implementation to libindy. For example, to allow storing
+of wallet records in SQL database. To achieve this we will replace existing ```indy_register_wallet_type``` call with ```indy_register_wallet_storage``` call:
+
+```Rust
+/// Register custom wallet storage implementation.
+///
+/// It allows library user to provide custom wallet storage implementation as set of handlers.
+///
+/// #Params
+/// command_handle: Command handle to map callback to caller context.
+/// type_: Wallet storage name.
+/// create: Wallet storage ""create"" operation handler
+/// delete: Wallet storage ""delete"" operation handler
+/// open: Wallet storage ""open"" operation handler
+/// close: Wallet storage ""close"" operation handler
+/// add_record: Wallet storage ""add_record"" operation handler
+/// update_record_value: Wallet storage ""update_record_value"" operation handler
+/// update_record_tags: Wallet storage ""update_record_tags"" operation handler
+/// add_record_tags: Wallet storage ""add_record_tags"" operation handler
+/// delete_record_tags: Wallet storage ""delete_record_tags"" operation handler
+/// delete_record: Wallet storage ""delete_record"" operation handler
+/// get_record: Wallet storage ""get_record"" operation handler
+/// get_record_id: Wallet storage ""get_record_id"" operation handler
+/// get_record_value: Wallet storage ""get_record_value"" operation handler
+/// get_record_tags: Wallet storage ""get_record_tags"" operation handler
+/// free_record: Wallet storage ""free_record"" operation handler
+/// search_records: Wallet storage ""search_records"" operation handler
+/// get_search_total_count: Wallet storage ""get_search_total_count"" operation handler
+/// get_search_count: Wallet storage ""get_search_count"" operation handler
+/// get_search_next_record: Wallet storage ""get_search_next_record"" operation handler
+/// free_search: Wallet storage ""free_search"" operation handler",294,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182417731,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182417731,dkulic
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,I suggest to leve error code. It isn’t system free and allows internal handler and state validation. ,9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-18 16:52:37,182497053,"@@ -0,0 +1,768 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Record ids will be always encrypted.
+  * Record values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secrets API
+
+It is our existing endpoints for secrets creation and access like ```indy_create_and_store_did``` or ```indy_create_and_store_cred_def```:
+
+1. Allow to create a secret into the wallet
+1. Return record id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Non-secrets API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+```Rust
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+extern pub fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+extern pub fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+///   Note that null means no tag names
+extern pub fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+extern pub fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode> {}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+extern pub fn indy_get_wallet_record(command_handle: u32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     options_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                          record_json: *const c_char)>) -> ErrorCode {}
+
+/// Search for wallet records.
+///
+/// Note instead of immediately returning of fetched records
+/// this call returns wallet_search_handle that can be used later
+/// to fetch records by small batches (with indy_fetch_wallet_search_next_records).
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// query_json: MongoDB style query to wallet record tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+///    retrieveTotalCount: (optional, false by default) Calculate total count,
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags,
+///  }
+/// #Returns
+/// wallet_search_handle: Wallet search handle that can be used later
+///   to fetch records by small batches (with indy_fetch_wallet_search_next_records)
+extern pub fn indy_open_wallet_search(command_handle: u32,
+                                      wallet_handle: i32,
+                                      type_: *const c_char,
+                                      query_json: *const c_char,
+                                      options_json: *const c_char,
+                                      cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                           wallet_search_handle_p: *mut i32)>) -> ErrorCode {}
+
+
+/// Fetch next records for wallet search.
+///
+/// Not if there are no records this call returns WalletNoRecords error.
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// wallet_search_handle: wallet wallet handle (created by indy_open_wallet_search)
+/// count: Count of records to fetch
+///
+/// #Returns
+/// wallet records json:
+/// {
+///   totalCount: <int>, // present only if retrieveTotalCount set to true
+///   records: [{ // present only if retrieveRecords set to true
+///       id: ""Some id"",
+///       value: ""Some value"", // present only if retrieveValue set to true
+///       tags: <tags json>, // present only if retrieveTags set to true
+///   }],
+/// }
+extern pub fn indy_fetch_wallet_search_next_records(command_handle: u32,
+                                                    wallet_handle: i32,
+                                                    wallet_search_handle: i32,
+                                                    count: u32,
+                                                    cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                                         records_json: *const c_char)>) -> ErrorCode {}
+```
+
+## Wallet API and Storage Interface
+
+Wallet API already exists and allows wallet management. It requires to be update to allow plugging different storages implementation to libindy. For example, to allow storing
+of wallet records in SQL database. To achieve this we will replace existing ```indy_register_wallet_type``` call with ```indy_register_wallet_storage``` call:
+
+```Rust
+/// Register custom wallet storage implementation.
+///
+/// It allows library user to provide custom wallet storage implementation as set of handlers.
+///
+/// #Params
+/// command_handle: Command handle to map callback to caller context.
+/// type_: Wallet storage name.
+/// create: Wallet storage ""create"" operation handler
+/// delete: Wallet storage ""delete"" operation handler
+/// open: Wallet storage ""open"" operation handler
+/// close: Wallet storage ""close"" operation handler
+/// add_record: Wallet storage ""add_record"" operation handler
+/// update_record_value: Wallet storage ""update_record_value"" operation handler
+/// update_record_tags: Wallet storage ""update_record_tags"" operation handler
+/// add_record_tags: Wallet storage ""add_record_tags"" operation handler
+/// delete_record_tags: Wallet storage ""delete_record_tags"" operation handler
+/// delete_record: Wallet storage ""delete_record"" operation handler
+/// get_record: Wallet storage ""get_record"" operation handler
+/// get_record_id: Wallet storage ""get_record_id"" operation handler
+/// get_record_value: Wallet storage ""get_record_value"" operation handler
+/// get_record_tags: Wallet storage ""get_record_tags"" operation handler
+/// free_record: Wallet storage ""free_record"" operation handler
+/// search_records: Wallet storage ""search_records"" operation handler
+/// get_search_total_count: Wallet storage ""get_search_total_count"" operation handler
+/// get_search_count: Wallet storage ""get_search_count"" operation handler
+/// get_search_next_record: Wallet storage ""get_search_next_record"" operation handler
+/// free_search: Wallet storage ""free_search"" operation handler
+///
+/// #Returns
+/// Error code
+#[no_mangle]
+pub extern fn indy_register_wallet_storage(command_handle: i32,
+                                           type_: *const c_char,
+
+                                           /// Create the wallet storage (For example, database creation)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           create: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Delete the wallet storage (For example, database deletion)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           delete: Option<extern fn(name: *const c_char,
+                                                                    config: *const c_char,
+                                                                    credentials: *const c_char) -> ErrorCode>,
+
+                                           /// Open the wallet storage (For example, opening database connection)
+                                           ///
+                                           /// #Params
+                                           /// name: wallet storage name (the same as wallet name)
+                                           /// config: wallet storage config (For example, database config)
+                                           /// runtime_config: wallet storage runtime config (For example, connection config)
+                                           /// credentials: wallet storage credentials (For example, database credentials)
+                                           /// storage_handle_p: pointer to store opened storage handle
+                                           open: Option<extern fn(name: *const c_char,
+                                                                  config: *const c_char,
+                                                                  runtime_config: *const c_char,
+                                                                  credentials: *const c_char,
+                                                                  storage_handle_p: *mut i32) -> ErrorCode>,
+
+                                           /// Close the opened walled storage (For example, closing database connection)
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           close: Option<extern fn(handle: i32) -> ErrorCode>,
+
+                                           /// Create a new record in the wallet storage
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// value: the value of record (pointer to buffer)
+                                           /// value_len: the value of record (buffer size)
+                                           /// tags_json: the record tags used for search and storing meta information as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           add_record: Option<extern fn(storage_handle: i32,
+                                                                        type_: *const c_char,
+                                                                        id: *const c_char,
+                                                                        value: *const u8,
+                                                                        value_len: usize,
+                                                                        tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Update a record value
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// value: the value of record (pointer to buffer)
+                                           /// value_len: the value of record (buffer size)
+                                           update_record_value: Option<extern fn(storage_handle: i32,
+                                                                                 type_: *const c_char,
+                                                                                 id: *const c_char,
+                                                                                 value: *const c_char,
+                                                                                 value_len: usize) -> ErrorCode>,
+
+                                           /// Update a record tags
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tags_json: the new record tags used for search and storing meta information as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           update_record_tags: Option<extern fn(storage_handle: i32,
+                                                                                type_: *const c_char,
+                                                                                id: *const c_char,
+                                                                                tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Add new tags to the record
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tags_json: the additional record tags as json:
+                                           ///   {
+                                           ///     ""tagName1"": ""tag value 1"", // string value
+                                           ///     ""tagName2"": 123, // numeric value,
+                                           ///     ...
+                                           ///   }
+                                           ///   Note that null means no tags
+                                           ///   Note if some from provided tags already assigned to the record than
+                                           ///     corresponding tags values will be replaced
+                                           add_record_tags: Option<extern fn(storage_handle: i32,
+                                                                             type_: *const c_char,
+                                                                             id: *const c_char,
+                                                                             tags_json: *const c_char) -> ErrorCode>,
+
+                                           /// Delete tags from the record
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// tag_names_json: the list of tag names to remove from the record as json array:
+                                           ///   [""tagName1"", ""tagName2"", ...]
+                                           ///   Note that null means no tag names
+                                           delete_record_tags: Option<extern fn(storage_handle: i32,
+                                                                                type_: *const c_char,
+                                                                                id: *const c_char,
+                                                                                tag_names_json: *const c_char) -> ErrorCode>,
+
+                                           /// Delete an existing record in the wallet storage
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: record type
+                                           /// id: the id of record
+                                           delete_record: Option<extern fn(storage_handle: i32,
+                                                                           type_: *const c_char,
+                                                                           id: *const c_char) -> ErrorCode>,
+
+                                           /// Get an wallet storage record by id
+                                           ///
+                                           /// #Params
+                                           /// storage_handle: opened storage handle (See open handler)
+                                           /// type_: allows to separate different record types collections
+                                           /// id: the id of record
+                                           /// options_json: //TODO: FIXME: Think about replacing by bitmaks
+                                           ///  {
+                                           ///    retrieveValue: (optional, true by default) Retrieve record value,
+                                           ///    retrieveTags: (optional, true by default) Retrieve record tags
+                                           ///  }
+                                           /// record_handle_p: pointer to store retrieved record handle
+                                           get_record: Option<extern fn(storage_handle: u32,
+                                                                        type_: *const c_char,
+                                                                        id: *const c_char,
+                                                                        options_json: *const c_char,
+                                                                        record_handle_p: *mut u32) -> ErrorCode>,
+
+                                          /// Get an id for retrieved wallet storage record
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// record_handle: retrieved record handle (See get_record handler)
+                                          ///
+                                          /// returns: record id
+                                          ///          Note that pointer lifetime the same as retrieved record lifetime
+                                          ///            (until record_free called)
+                                          get_record_id: Option<extern fn(storage_handle: u32,
+                                                                          record_handle: u32,
+                                                                          record_id_p: *mut *const c_char) -> ErrorCode>,
+
+                                          /// Get an value for retrieved wallet storage record
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// record_handle: retrieved record handle (See get_record handler)
+                                          ///
+                                          /// returns: record value
+                                          ///          Note that pointer lifetime the same as retrieved record lifetime
+                                          ///            (until record_free called)
+                                          ///          Note that null be returned if no value retrieved
+                                          get_record_value: Option<extern fn(storage_handle: u32,
+                                                                             record_handle: u32,
+                                                                             record_value_p: *mut *const u8,
+                                                                             record_value_len_p: *mut i32) -> ErrorCode>,
+
+                                          /// Get an tags for retrieved wallet record
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open handler)
+                                          /// record_handle: retrieved record handle (See get_record handler)
+                                          ///
+                                          /// returns: record tags as json
+                                          ///          Note that pointer lifetime the same as retrieved record lifetime
+                                          ///            (until record_free called)
+                                          ///          Note that null be returned if no tags retrieved
+                                          get_record_tags: Option<extern fn(storage_handle: u32,
+                                                                            record_handle: u32,
+                                                                            record_tags_p: *mut *const c_char) -> ErrorCode>,
+
+                                          /// Free retrieved wallet record (make retrieved record handle invalid)
+                                          ///
+                                          /// #Params
+                                          /// storage_handle: opened storage handle (See open_wallet_storage)
+                                          /// record_handle: retrieved record handle (See wallet_storage_get_wallet_record)
+                                          free_record: Option<extern fn(storage_handle: u32,",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182497053,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182497053,vimmerru
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,"Correct, i32 for handles. Count should be usize. I will update. ",9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-18 16:53:28,182497335,"@@ -0,0 +1,768 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Record ids will be always encrypted.
+  * Record values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secrets API
+
+It is our existing endpoints for secrets creation and access like ```indy_create_and_store_did``` or ```indy_create_and_store_cred_def```:
+
+1. Allow to create a secret into the wallet
+1. Return record id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Non-secrets API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+```Rust
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+extern pub fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+extern pub fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+///   Note that null means no tag names
+extern pub fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+extern pub fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode> {}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+extern pub fn indy_get_wallet_record(command_handle: u32,
+                                     wallet_handle: i32,",,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182497335,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182497335,vimmerru
https://github.com/hyperledger/indy-sdk/pull/564,https://github.com/hyperledger/indy-sdk/pull/564,"Got it, will provide solution ",9579a87832c7bb4ceb0ae6a4f2beac04b98f082e,2018-04-18 16:54:00,182497505,"@@ -0,0 +1,768 @@
+# Wallet Storage Design
+
+In current state libindy allows to plug different wallet implementations. Plugged wallet now handles both security
+and storage layers. This design proposes to restrict our plugged interface by handling only storage layer.
+All encryption will be performed in libindy. It will simplify plugged wallets and warranty good security level
+for 3d party wallets implementations.
+
+Also proposals enhances our API for efficient and flexible search with paging support.
+
+Also proposals enhances our API to support storing of application specific
+data into the wallet.
+
+## Goals and ideas
+
+* Simplify plugged wallets and warranty security level for 3d party wallets implementation by perform all
+  encryption on libindy level:
+  * Record ids will be always encrypted.
+  * Record values will be always encrypted.
+  * Tag names will be always encrypted.
+  * Tag values will be **optionally** encrypted. If user wants to perform some complex searches it can
+    be possible to include some additional un-encrypted tags.
+* Allow plugging of different storages with native OpenSSL style object-oriented C interface for.
+  Try to avoid unnecessary json and re-allocation.
+* Allow efficient and flexible search for entities with pagination support.
+* Expose public API to store application specific data into the wallet. This API shouldn't
+  have an access to secrets stored by libindy.
+
+## Wallet Components
+
+![Wallet Components](./wallet-components.svg)
+
+## Secrets API
+
+It is our existing endpoints for secrets creation and access like ```indy_create_and_store_did``` or ```indy_create_and_store_cred_def```:
+
+1. Allow to create a secret into the wallet
+1. Return record id and optionally public part (if needed)
+1. Allow to search for stored secrets ids (if needed)
+1. Allow to reference secret by id in crypto calls that require this secret
+1. Don't allow to get stored secret back
+
+## Non-secrets API
+
+This API is intended to store and read application specific identity data in the wallet.
+This API shouldn't have an access to secrets stored by Secret Entities API.
+
+```Rust
+/// Create a new non-secret record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the value of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_add_wallet_record(command_handle: i32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     value: *const c_char,
+                                     tags_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record value
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// value: the new value of record
+extern pub fn indy_update_wallet_record_value(command_handle: i32,
+                                              wallet_handle: i32,
+                                              type_: *const c_char,
+                                              id: *const c_char,
+                                              value: *const c_char,
+                                              cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Update a non-secret wallet record tags
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+extern pub fn indy_update_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tags_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Add new tags to the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tags_json: the record tags used for search and storing meta information as json:
+///   {
+///     ""tagName1"": <str>, // string tag (will be stored encrypted)
+///     ""tagName2"": <int>, // int tag (will be stored encrypted)
+///     ""~tagName3"": <str>, // string tag (will be stored un-encrypted)
+///     ""~tagName4"": <int>, // int tag (will be stored un-encrypted)
+///   }
+///   Note that null means no tags
+///   If tag name starts with ""~"" the tag will be stored un-encrypted that will allow
+///   usage of this tag in complex search queries (comparison, predicates)
+///   Encrypted tags can be searched only for exact matching
+///   Note if some from provided tags already assigned to the record than
+///     corresponding tags values will be replaced
+extern pub fn indy_add_wallet_record_tags(command_handle: i32,
+                                          wallet_handle: i32,
+                                          type_: *const c_char,
+                                          id: *const c_char,
+                                          tags_json: *const c_char,
+                                          cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete tags from the wallet record
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// tag_names_json: the list of tag names to remove from the record as json array:
+///   [""tagName1"", ""tagName2"", ...]
+///   Note that null means no tag names
+extern pub fn indy_delete_wallet_record_tags(command_handle: i32,
+                                             wallet_handle: i32,
+                                             type_: *const c_char,
+                                             id: *const c_char,
+                                             tag_names_json: *const c_char,
+                                             cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode {}
+
+/// Delete an existing wallet record in the wallet
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: record type
+/// id: the id of record
+extern pub fn indy_delete_wallet_record(command_handle: i32,
+                                        wallet_handle: i32,
+                                        type_: *const c_char,
+                                        id: *const c_char,
+                                        cb: Option<extern fn(command_handle_: i32, err: ErrorCode)>) -> ErrorCode> {}
+
+/// Get an wallet record by id
+///
+/// #Params
+/// command_handle: command handle to map callback to caller context
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// id: the id of record
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags
+///  }
+/// #Returns
+/// wallet record json:
+/// {
+///   id: ""Some id"",
+///   value: ""Some value"", // present only if retrieveValue set to true
+///   tags: <tags json>, // present only if retrieveTags set to true
+/// }
+extern pub fn indy_get_wallet_record(command_handle: u32,
+                                     wallet_handle: i32,
+                                     type_: *const c_char,
+                                     id: *const c_char,
+                                     options_json: *const c_char,
+                                     cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                          record_json: *const c_char)>) -> ErrorCode {}
+
+/// Search for wallet records.
+///
+/// Note instead of immediately returning of fetched records
+/// this call returns wallet_search_handle that can be used later
+/// to fetch records by small batches (with indy_fetch_wallet_search_next_records).
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// type_: allows to separate different record types collections
+/// query_json: MongoDB style query to wallet record tags:
+///  {
+///    ""tagName"": ""tagValue"",
+///    $or: {
+///      ""tagName2"": { $regex: 'pattern' },
+///      ""tagName3"": { $gte: 123 },
+///    },
+///  }
+/// options_json: //TODO: FIXME: Think about replacing by bitmaks
+///  {
+///    retrieveRecords: (optional, true by default) If false only ""counts"" will be calculated,
+///    retrieveTotalCount: (optional, false by default) Calculate total count,
+///    retrieveValue: (optional, true by default) Retrieve record value,
+///    retrieveTags: (optional, true by default) Retrieve record tags,
+///  }
+/// #Returns
+/// wallet_search_handle: Wallet search handle that can be used later
+///   to fetch records by small batches (with indy_fetch_wallet_search_next_records)
+extern pub fn indy_open_wallet_search(command_handle: u32,
+                                      wallet_handle: i32,
+                                      type_: *const c_char,
+                                      query_json: *const c_char,
+                                      options_json: *const c_char,
+                                      cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                           wallet_search_handle_p: *mut i32)>) -> ErrorCode {}
+
+
+/// Fetch next records for wallet search.
+///
+/// Not if there are no records this call returns WalletNoRecords error.
+///
+/// #Params
+/// wallet_handle: wallet handle (created by open_wallet)
+/// wallet_search_handle: wallet wallet handle (created by indy_open_wallet_search)
+/// count: Count of records to fetch
+///
+/// #Returns
+/// wallet records json:
+/// {
+///   totalCount: <int>, // present only if retrieveTotalCount set to true
+///   records: [{ // present only if retrieveRecords set to true
+///       id: ""Some id"",
+///       value: ""Some value"", // present only if retrieveValue set to true
+///       tags: <tags json>, // present only if retrieveTags set to true
+///   }],
+/// }
+extern pub fn indy_fetch_wallet_search_next_records(command_handle: u32,
+                                                    wallet_handle: i32,
+                                                    wallet_search_handle: i32,
+                                                    count: u32,
+                                                    cb: Option<extern fn(command_handle_: i32, err: ErrorCode,
+                                                                         records_json: *const c_char)>) -> ErrorCode {}
+```
+
+## Wallet API and Storage Interface
+
+Wallet API already exists and allows wallet management. It requires to be update to allow plugging different storages implementation to libindy. For example, to allow storing
+of wallet records in SQL database. To achieve this we will replace existing ```indy_register_wallet_type``` call with ```indy_register_wallet_storage``` call:
+
+```Rust
+/// Register custom wallet storage implementation.
+///
+/// It allows library user to provide custom wallet storage implementation as set of handlers.
+///
+/// #Params
+/// command_handle: Command handle to map callback to caller context.
+/// type_: Wallet storage name.
+/// create: Wallet storage ""create"" operation handler
+/// delete: Wallet storage ""delete"" operation handler
+/// open: Wallet storage ""open"" operation handler
+/// close: Wallet storage ""close"" operation handler
+/// add_record: Wallet storage ""add_record"" operation handler
+/// update_record_value: Wallet storage ""update_record_value"" operation handler
+/// update_record_tags: Wallet storage ""update_record_tags"" operation handler
+/// add_record_tags: Wallet storage ""add_record_tags"" operation handler
+/// delete_record_tags: Wallet storage ""delete_record_tags"" operation handler
+/// delete_record: Wallet storage ""delete_record"" operation handler
+/// get_record: Wallet storage ""get_record"" operation handler
+/// get_record_id: Wallet storage ""get_record_id"" operation handler",286,2018-04-24 08:23:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/182497505,https://github.com/hyperledger/indy-sdk/pull/564#discussion_r182497505,vimmerru
https://github.com/hyperledger/indy-sdk/pull/558,https://github.com/hyperledger/indy-sdk/pull/558,"Can we just rename it to ""default-wallet.md""? ind-sdk prefix seems excess.",dac70e66720bf1858e2d07584f69cc0147294ff7,2018-02-28 21:34:06,171392307,"@@ -0,0 +1,86 @@
+# Indy-SDK Default Wallet Implementation",,2018-03-06 10:44:18,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/171392307,https://github.com/hyperledger/indy-sdk/pull/558#discussion_r171392307,vimmerru
https://github.com/hyperledger/indy-sdk/pull/551,https://github.com/hyperledger/indy-sdk/pull/551,"I suggest to don't use ""Getting Started Guide"" title as we already have ""Getting Started Guide"" as a dedicated artifact",53db2142cf93cf1729c9373a95a7221a07ead586,2018-03-01 16:34:48,171616832,"@@ -0,0 +1,29 @@
+# Indy SDK getting started guide",1,2018-03-27 00:49:36,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/171616832,https://github.com/hyperledger/indy-sdk/pull/551#discussion_r171616832,vimmerru
https://github.com/hyperledger/indy-sdk/pull/551,https://github.com/hyperledger/indy-sdk/pull/551,"also i am not sure that it is a right place to put this files.
",53db2142cf93cf1729c9373a95a7221a07ead586,2018-03-01 16:37:00,171617528,"@@ -0,0 +1,29 @@
+# Indy SDK getting started guide
+The following are scripts using the SDK and the Python wrapper. ",2,2018-03-27 00:49:36,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/171617528,https://github.com/hyperledger/indy-sdk/pull/551#discussion_r171617528,vimmerru
https://github.com/hyperledger/indy-sdk/pull/551,https://github.com/hyperledger/indy-sdk/pull/551,@vimmerru I have a different idea about where to put this. I'll talk to you.,53db2142cf93cf1729c9373a95a7221a07ead586,2018-03-01 16:40:16,171618578,"@@ -0,0 +1,29 @@
+# Indy SDK getting started guide
+The following are scripts using the SDK and the Python wrapper. ",2,2018-03-27 00:49:36,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/171618578,https://github.com/hyperledger/indy-sdk/pull/551#discussion_r171618578,dhh1128
https://github.com/hyperledger/indy-sdk/pull/550,https://github.com/hyperledger/indy-sdk/pull/550,What does rev_reg_entry_json mean? ,90c572ff720a0fd8a1b29d50c83c29e7ee8f2503,2018-02-26 19:10:55,170701864,"@@ -525,19 +597,22 @@ pub extern fn indy_prover_create_and_store_claim_req(command_handle: i32,
 pub extern fn indy_prover_store_claim(command_handle: i32,
                                       wallet_handle: i32,
                                       claims_json: *const c_char,
-                                      rev_reg_json: *const c_char,
+                                      rev_reg_def_json: *const c_char,
+                                      rev_reg_entry_json: *const c_char,",,2018-04-12 11:54:39,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/170701864,https://github.com/hyperledger/indy-sdk/pull/550#discussion_r170701864,vimmerru
https://github.com/hyperledger/indy-sdk/pull/550,https://github.com/hyperledger/indy-sdk/pull/550,What is id here?,90c572ff720a0fd8a1b29d50c83c29e7ee8f2503,2018-02-26 19:53:56,170715342,"@@ -926,3 +1010,118 @@ pub extern fn indy_verifier_verify_proof(command_handle: i32,
 
     result_to_err_code!(result)
 }
+
+#[no_mangle]
+pub extern fn indy_create_witness(command_handle: i32,
+                                  wallet_handle: i32,
+                                  tails_reader_handle: i32,
+                                  rev_reg_def_json: *const c_char,
+                                  rev_reg_delta_json: *const c_char,
+                                  rev_idx: u32,
+                                  cb: Option<extern fn(
+                                      xcommand_handle: i32, err: ErrorCode,
+                                      witness_json: *const c_char
+                                  )>) -> ErrorCode {
+    check_useful_c_str!(rev_reg_def_json, ErrorCode::CommonInvalidParam4);
+    check_useful_c_str!(rev_reg_delta_json, ErrorCode::CommonInvalidParam5);
+    check_useful_c_callback!(cb, ErrorCode::CommonInvalidParam7);
+
+    let result = CommandExecutor::instance()
+        .send(Command::Anoncreds(AnoncredsCommand::Prover(ProverCommand::CreateWitness(
+            wallet_handle,
+            tails_reader_handle,
+            rev_reg_def_json,
+            rev_reg_delta_json,
+            rev_idx,
+            Box::new(move |result| {
+                let (err, witness_json) = result_to_err_code_1!(result, String::new());
+                let witness_json = CStringUtils::string_to_cstring(witness_json);
+                cb(command_handle, err, witness_json.as_ptr())
+            })
+        ))));
+
+    result_to_err_code!(result)
+}
+
+#[no_mangle]
+pub extern fn indy_update_witness(command_handle: i32,
+                                  wallet_handle: i32,
+                                  tails_reader_handle: i32,
+                                  witness_json: *const c_char,
+                                  rev_reg_def_json: *const c_char,
+                                  rev_reg_delta_json: *const c_char,
+                                  rev_idx: u32,
+                                  cb: Option<extern fn(
+                                      xcommand_handle: i32, err: ErrorCode,
+                                      updated_witness_json: *const c_char
+                                  )>) -> ErrorCode {
+    check_useful_c_str!(witness_json, ErrorCode::CommonInvalidParam4);
+    check_useful_c_str!(rev_reg_def_json, ErrorCode::CommonInvalidParam5);
+    check_useful_c_str!(rev_reg_delta_json, ErrorCode::CommonInvalidParam6);
+    check_useful_c_callback!(cb, ErrorCode::CommonInvalidParam8);
+
+    let result = CommandExecutor::instance()
+        .send(Command::Anoncreds(AnoncredsCommand::Prover(ProverCommand::UpdateWitness(
+            wallet_handle,
+            tails_reader_handle,
+            witness_json,
+            rev_reg_def_json,
+            rev_reg_delta_json,
+            rev_idx,
+            Box::new(move |result| {
+                let (err, updated_witness_json) = result_to_err_code_1!(result, String::new());
+                let updated_witness_json = CStringUtils::string_to_cstring(updated_witness_json);
+                cb(command_handle, err, updated_witness_json.as_ptr())
+            })
+        ))));
+
+    result_to_err_code!(result)
+}
+
+#[no_mangle]
+pub extern fn indy_store_witness(command_handle: i32,
+                                 wallet_handle: i32,
+                                 id: *const c_char,",,2018-04-12 11:54:39,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/170715342,https://github.com/hyperledger/indy-sdk/pull/550#discussion_r170715342,vimmerru
https://github.com/hyperledger/indy-sdk/pull/550,https://github.com/hyperledger/indy-sdk/pull/550,May be rename to indy_open_blob_reader ???,90c572ff720a0fd8a1b29d50c83c29e7ee8f2503,2018-02-26 20:05:45,170718768,"@@ -0,0 +1,38 @@
+extern crate libc;
+
+use api::ErrorCode;
+use errors::ToErrorCode;
+use commands::{Command, CommandExecutor};
+use commands::blob_storage::BlobStorageCommand;
+use utils::cstring::CStringUtils;
+
+use self::libc::c_char;
+
+#[no_mangle]
+pub extern fn indy_open_reader(command_handle: i32,",,2018-04-12 11:54:39,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/170718768,https://github.com/hyperledger/indy-sdk/pull/550#discussion_r170718768,vimmerru
https://github.com/hyperledger/indy-sdk/pull/550,https://github.com/hyperledger/indy-sdk/pull/550,I can't find public API to get this handle. Could you point me?,90c572ff720a0fd8a1b29d50c83c29e7ee8f2503,2018-02-26 20:24:22,170723880,"@@ -83,46 +85,54 @@ pub extern fn indy_issuer_create_and_store_claim_def(command_handle: i32,
 #[no_mangle]
 pub extern fn indy_issuer_create_and_store_revoc_reg(command_handle: i32,
                                                      wallet_handle: i32,
+                                                     tails_writer_config_handle: i32,",,2018-04-12 11:54:39,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/170723880,https://github.com/hyperledger/indy-sdk/pull/550#discussion_r170723880,vimmerru
https://github.com/hyperledger/indy-sdk/pull/550,https://github.com/hyperledger/indy-sdk/pull/550,It is transaction that contains accumulator value,90c572ff720a0fd8a1b29d50c83c29e7ee8f2503,2018-02-27 06:44:36,170828390,"@@ -525,19 +597,22 @@ pub extern fn indy_prover_create_and_store_claim_req(command_handle: i32,
 pub extern fn indy_prover_store_claim(command_handle: i32,
                                       wallet_handle: i32,
                                       claims_json: *const c_char,
-                                      rev_reg_json: *const c_char,
+                                      rev_reg_def_json: *const c_char,
+                                      rev_reg_entry_json: *const c_char,",,2018-04-12 11:54:39,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/170828390,https://github.com/hyperledger/indy-sdk/pull/550#discussion_r170828390,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/550,https://github.com/hyperledger/indy-sdk/pull/550,Witness and Claim must be associated. We decided to pass the same id as a parameter in store_witness and store_credential ,90c572ff720a0fd8a1b29d50c83c29e7ee8f2503,2018-02-27 06:47:25,170828845,"@@ -926,3 +1010,118 @@ pub extern fn indy_verifier_verify_proof(command_handle: i32,
 
     result_to_err_code!(result)
 }
+
+#[no_mangle]
+pub extern fn indy_create_witness(command_handle: i32,
+                                  wallet_handle: i32,
+                                  tails_reader_handle: i32,
+                                  rev_reg_def_json: *const c_char,
+                                  rev_reg_delta_json: *const c_char,
+                                  rev_idx: u32,
+                                  cb: Option<extern fn(
+                                      xcommand_handle: i32, err: ErrorCode,
+                                      witness_json: *const c_char
+                                  )>) -> ErrorCode {
+    check_useful_c_str!(rev_reg_def_json, ErrorCode::CommonInvalidParam4);
+    check_useful_c_str!(rev_reg_delta_json, ErrorCode::CommonInvalidParam5);
+    check_useful_c_callback!(cb, ErrorCode::CommonInvalidParam7);
+
+    let result = CommandExecutor::instance()
+        .send(Command::Anoncreds(AnoncredsCommand::Prover(ProverCommand::CreateWitness(
+            wallet_handle,
+            tails_reader_handle,
+            rev_reg_def_json,
+            rev_reg_delta_json,
+            rev_idx,
+            Box::new(move |result| {
+                let (err, witness_json) = result_to_err_code_1!(result, String::new());
+                let witness_json = CStringUtils::string_to_cstring(witness_json);
+                cb(command_handle, err, witness_json.as_ptr())
+            })
+        ))));
+
+    result_to_err_code!(result)
+}
+
+#[no_mangle]
+pub extern fn indy_update_witness(command_handle: i32,
+                                  wallet_handle: i32,
+                                  tails_reader_handle: i32,
+                                  witness_json: *const c_char,
+                                  rev_reg_def_json: *const c_char,
+                                  rev_reg_delta_json: *const c_char,
+                                  rev_idx: u32,
+                                  cb: Option<extern fn(
+                                      xcommand_handle: i32, err: ErrorCode,
+                                      updated_witness_json: *const c_char
+                                  )>) -> ErrorCode {
+    check_useful_c_str!(witness_json, ErrorCode::CommonInvalidParam4);
+    check_useful_c_str!(rev_reg_def_json, ErrorCode::CommonInvalidParam5);
+    check_useful_c_str!(rev_reg_delta_json, ErrorCode::CommonInvalidParam6);
+    check_useful_c_callback!(cb, ErrorCode::CommonInvalidParam8);
+
+    let result = CommandExecutor::instance()
+        .send(Command::Anoncreds(AnoncredsCommand::Prover(ProverCommand::UpdateWitness(
+            wallet_handle,
+            tails_reader_handle,
+            witness_json,
+            rev_reg_def_json,
+            rev_reg_delta_json,
+            rev_idx,
+            Box::new(move |result| {
+                let (err, updated_witness_json) = result_to_err_code_1!(result, String::new());
+                let updated_witness_json = CStringUtils::string_to_cstring(updated_witness_json);
+                cb(command_handle, err, updated_witness_json.as_ptr())
+            })
+        ))));
+
+    result_to_err_code!(result)
+}
+
+#[no_mangle]
+pub extern fn indy_store_witness(command_handle: i32,
+                                 wallet_handle: i32,
+                                 id: *const c_char,",,2018-04-12 11:54:39,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/170828845,https://github.com/hyperledger/indy-sdk/pull/550#discussion_r170828845,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/550,https://github.com/hyperledger/indy-sdk/pull/550,"I have already changed it.
Now it look like: 
```
pub extern fn indy_issuer_create_and_store_revoc_reg(command_handle: i32,
                                                     wallet_handle: i32,
                                                     tails_writer_type: *const c_char,
                                                     tails_writer_config: *const c_char,
                                                     issuer_did: *const c_char,
                                                     schema_json: *const c_char,
                                                     max_claim_num: u32,
                                                     issuance_by_default: bool,
```",90c572ff720a0fd8a1b29d50c83c29e7ee8f2503,2018-02-27 06:49:15,170829078,"@@ -83,46 +85,54 @@ pub extern fn indy_issuer_create_and_store_claim_def(command_handle: i32,
 #[no_mangle]
 pub extern fn indy_issuer_create_and_store_revoc_reg(command_handle: i32,
                                                      wallet_handle: i32,
+                                                     tails_writer_config_handle: i32,",,2018-04-12 11:54:39,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/170829078,https://github.com/hyperledger/indy-sdk/pull/550#discussion_r170829078,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/550,https://github.com/hyperledger/indy-sdk/pull/550,or `indy_blob_storage_open_reader` ?,90c572ff720a0fd8a1b29d50c83c29e7ee8f2503,2018-02-27 07:38:33,170836143,"@@ -0,0 +1,38 @@
+extern crate libc;
+
+use api::ErrorCode;
+use errors::ToErrorCode;
+use commands::{Command, CommandExecutor};
+use commands::blob_storage::BlobStorageCommand;
+use utils::cstring::CStringUtils;
+
+use self::libc::c_char;
+
+#[no_mangle]
+pub extern fn indy_open_reader(command_handle: i32,",,2018-04-12 11:54:39,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/170836143,https://github.com/hyperledger/indy-sdk/pull/550#discussion_r170836143,jovfer
https://github.com/hyperledger/indy-sdk/pull/550,https://github.com/hyperledger/indy-sdk/pull/550,But in theory we can have multiple witnesses for one claim for different timestamps.,90c572ff720a0fd8a1b29d50c83c29e7ee8f2503,2018-02-27 18:17:03,171017312,"@@ -926,3 +1010,118 @@ pub extern fn indy_verifier_verify_proof(command_handle: i32,
 
     result_to_err_code!(result)
 }
+
+#[no_mangle]
+pub extern fn indy_create_witness(command_handle: i32,
+                                  wallet_handle: i32,
+                                  tails_reader_handle: i32,
+                                  rev_reg_def_json: *const c_char,
+                                  rev_reg_delta_json: *const c_char,
+                                  rev_idx: u32,
+                                  cb: Option<extern fn(
+                                      xcommand_handle: i32, err: ErrorCode,
+                                      witness_json: *const c_char
+                                  )>) -> ErrorCode {
+    check_useful_c_str!(rev_reg_def_json, ErrorCode::CommonInvalidParam4);
+    check_useful_c_str!(rev_reg_delta_json, ErrorCode::CommonInvalidParam5);
+    check_useful_c_callback!(cb, ErrorCode::CommonInvalidParam7);
+
+    let result = CommandExecutor::instance()
+        .send(Command::Anoncreds(AnoncredsCommand::Prover(ProverCommand::CreateWitness(
+            wallet_handle,
+            tails_reader_handle,
+            rev_reg_def_json,
+            rev_reg_delta_json,
+            rev_idx,
+            Box::new(move |result| {
+                let (err, witness_json) = result_to_err_code_1!(result, String::new());
+                let witness_json = CStringUtils::string_to_cstring(witness_json);
+                cb(command_handle, err, witness_json.as_ptr())
+            })
+        ))));
+
+    result_to_err_code!(result)
+}
+
+#[no_mangle]
+pub extern fn indy_update_witness(command_handle: i32,
+                                  wallet_handle: i32,
+                                  tails_reader_handle: i32,
+                                  witness_json: *const c_char,
+                                  rev_reg_def_json: *const c_char,
+                                  rev_reg_delta_json: *const c_char,
+                                  rev_idx: u32,
+                                  cb: Option<extern fn(
+                                      xcommand_handle: i32, err: ErrorCode,
+                                      updated_witness_json: *const c_char
+                                  )>) -> ErrorCode {
+    check_useful_c_str!(witness_json, ErrorCode::CommonInvalidParam4);
+    check_useful_c_str!(rev_reg_def_json, ErrorCode::CommonInvalidParam5);
+    check_useful_c_str!(rev_reg_delta_json, ErrorCode::CommonInvalidParam6);
+    check_useful_c_callback!(cb, ErrorCode::CommonInvalidParam8);
+
+    let result = CommandExecutor::instance()
+        .send(Command::Anoncreds(AnoncredsCommand::Prover(ProverCommand::UpdateWitness(
+            wallet_handle,
+            tails_reader_handle,
+            witness_json,
+            rev_reg_def_json,
+            rev_reg_delta_json,
+            rev_idx,
+            Box::new(move |result| {
+                let (err, updated_witness_json) = result_to_err_code_1!(result, String::new());
+                let updated_witness_json = CStringUtils::string_to_cstring(updated_witness_json);
+                cb(command_handle, err, updated_witness_json.as_ptr())
+            })
+        ))));
+
+    result_to_err_code!(result)
+}
+
+#[no_mangle]
+pub extern fn indy_store_witness(command_handle: i32,
+                                 wallet_handle: i32,
+                                 id: *const c_char,",,2018-04-12 11:54:39,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/171017312,https://github.com/hyperledger/indy-sdk/pull/550#discussion_r171017312,vimmerru
https://github.com/hyperledger/indy-sdk/pull/544,https://github.com/hyperledger/indy-sdk/pull/544,"Please, check this file. I think you have to reset changes here.",4855f575ab7499dcd0304d22367a6e03c658b748,2018-02-22 06:31:24,169864912,"@@ -150,146 +150,22 @@
       ""==============================\n"",",,2018-03-27 07:29:03,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/169864912,https://github.com/hyperledger/indy-sdk/pull/544#discussion_r169864912,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/544,https://github.com/hyperledger/indy-sdk/pull/544,"I'm not sure that try/except is a good decision here. You added it for getting_started.py but did not for anoncreds, crypto, ledger. 
Ideally, samples must run from a clean folder and clean everything after them. 
I think it would be better to add cleaning of .indy_client folder before each sample.",4855f575ab7499dcd0304d22367a6e03c658b748,2018-02-22 06:42:08,169866153,"@@ -13,11 +17,15 @@
 async def run():
     logger.info(""Getting started -> started"")
 
-    logger.info(""Open Pool Ledger"")
     pool_name = 'pool1'
+    logger.info(""Open Pool Ledger: {}"".format(pool_name))
     pool_genesis_txn_path = get_pool_genesis_txn_path(pool_name)
     pool_config = json.dumps({""genesis_txn"": str(pool_genesis_txn_path)})
-    await pool.create_pool_ledger_config(pool_name, pool_config)
+    try:
+        await pool.create_pool_ledger_config(pool_name, pool_config)
+    except IndyError as ex:
+        if ex.error_code == ErrorCode.PoolLedgerConfigAlreadyExistsError:
+            pass",30,2018-03-27 07:29:03,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/169866153,https://github.com/hyperledger/indy-sdk/pull/544#discussion_r169866153,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/544,https://github.com/hyperledger/indy-sdk/pull/544,"Ledger, anoncreds and crypto had the the code to delete wallets",4855f575ab7499dcd0304d22367a6e03c658b748,2018-02-23 15:55:13,170288566,"@@ -13,11 +17,15 @@
 async def run():
     logger.info(""Getting started -> started"")
 
-    logger.info(""Open Pool Ledger"")
     pool_name = 'pool1'
+    logger.info(""Open Pool Ledger: {}"".format(pool_name))
     pool_genesis_txn_path = get_pool_genesis_txn_path(pool_name)
     pool_config = json.dumps({""genesis_txn"": str(pool_genesis_txn_path)})
-    await pool.create_pool_ledger_config(pool_name, pool_config)
+    try:
+        await pool.create_pool_ledger_config(pool_name, pool_config)
+    except IndyError as ex:
+        if ex.error_code == ErrorCode.PoolLedgerConfigAlreadyExistsError:
+            pass",30,2018-03-27 07:29:03,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/170288566,https://github.com/hyperledger/indy-sdk/pull/544#discussion_r170288566,lovesh
https://github.com/hyperledger/indy-sdk/pull/544,https://github.com/hyperledger/indy-sdk/pull/544,Done,4855f575ab7499dcd0304d22367a6e03c658b748,2018-02-23 17:13:27,170310782,"@@ -150,146 +150,22 @@
       ""==============================\n"",",,2018-03-27 07:29:03,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/170310782,https://github.com/hyperledger/indy-sdk/pull/544#discussion_r170310782,lovesh
https://github.com/hyperledger/indy-sdk/pull/541,https://github.com/hyperledger/indy-sdk/pull/541,Could you re-check this sentence? It is a bit hard to catch meaning.,fcbfd3c2fe863d4390018af4cdf292eff656ab90,2018-02-20 16:00:30,169367036,"@@ -46,37 +46,47 @@ As a graduate of Faber College, Alice receives an alumni newsletter where she le
 
 Alice doesn’t realize it yet, but in order to use this digital transcript she will need a new type of identity -- not the traditional identity that Faber College has built for her in its on-campus database, but a new and portable one that belongs to her, independent of all past and future relationships, that nobody can revoke or co-opt or correlate without her permission. This is a **_self-sovereign identity_** and it is the core feature of the ledger.
 
-In normal contexts, managing a self-sovereign identity will require a tool such as a desktop or mobile application. It might be a standalone app, or it might leverage a third party service provider that the ledger calls an **agency**. For example, leaders in this technology such as the Sovrin Foundation and companies like Evernym, publish reference versions of such tools. Faber College will have studied these requirements and will recommend a **_Indy app_** to Alice if she doesn’t already have one; this app will install as part of the workflow from the **Get Transcript** button.
+In normal contexts, managing a self-sovereign identity will require a tool such as a desktop or mobile application. It might be a standalone app or it might leverage a third party service provider that the ledger calls an **agency**. For example, leaders in this technology such as the Sovrin Foundation and companies like Evernym, publish reference versions of such tools. Faber College will have studied these requirements and will recommend an **_Indy app_** to Alice if she doesn’t already have one. This app will install as part of the workflow from the **Get Transcript** button.
 
-When Alice clicks **Get Transcript**, she will download a file that holds an Indy **connection request**. This connection request file, having a .indy extension and associated with her Indy app, will allow her to establish a secure channel of communication with another party in the ledger ecosystem -- Faber College.
+When Alice clicks **Get Transcript**, she will download a file that holds an Indy **connection request**. This connection request file, having an .indy extension and associated with her Indy app, will allow her to establish a secure channel of communication with another party in the ledger ecosystem -- Faber College.
 
 So when Alice clicks **Get Transcript**, she will normally end up installing an app (if needed), launching it, and then being asked by the app whether she wants to accept a request to connect with Faber.
 
-For this guide, however, we’ll be using a **Indy SDK API** instead of an app, so we can see what happens behind the scenes. We will pretend to be a particularly curious and technically adventurous Alice…
+For this guide, however, we’ll be using an **Indy SDK API** instead of an app, so we can see what happens behind the scenes. We will pretend to be a particularly curious and technically adventurous Alice…
 
-## Infrastructure preparation
+## Infrastructure Preparation
 
-### Getting Trust Anchor credentials for Faber, Acme, Thrift and Government
+### Step 1: Getting Trust Anchor Credentials for Faber, Acme, Thrift and Government
 
 Faber College and another actors have done some prep steps to offer this service to Alice. To understand these steps let's start with some definitions.
 
 The ledger is intended to store **Identity Records** that describe a **Ledger Entity**. Identity Records are public data and may include Public Keys, Service Endpoints, Claim Schemas, Claim Definitions. Every **Identity Record** is associated with exactly one **DID** (Decentralized Identifier) that is globally unique and resolvable (via a ledger) without requiring any centralized resolution authority. To maintain privacy each **Identity Owner** can own multiple DIDs.
 
-In this tutorial we will use 2 type of DIDs. The first one is **Verinym**. **Verinym** is associated with the **Legal Identity** of the **Identity Owner**. For example, all parties should be able to verify that some DID is used by Government to publish schemas for some document type. The second type is **Pseudonym** - a **Blinded Identifier** used to maintain privacy in the context on an ongoing digital relationship (**Connection**). if Pseudonym is used to maintain only one digital relationship we will call it Pairwise-Unique Identifier. We will use Pairwise-Unique Identifiers to maintain secure connections between actors in this tutorial.
+In this tutorial we will use two types of DIDs. The first one is a **Verinym**. **Verinym** is associated with the **Legal Identity** of the **Identity Owner**. For example, all parties should be able to verify that some DID is used by a Government to publish schemas for some document type. The second type is a **Pseudonym** - a **Blinded Identifier** used to maintain privacy in the context on an ongoing digital relationship (**Connection**). If the Pseudonym is used to maintain only one digital relationship we will call it a Pairwise-Unique Identifier. We will use Pairwise-Unique Identifiers to maintain secure connections between actors in this tutorial.
 
-Creation of DID known to the Ledger is **Identity Record** itself (NYM transaction). NYM transaction can be used for creation of new DIDs that ledger known, setting and rotation of verification key, setting and changing of roles. The most important fields of this transaction are dest (target DID), role (role of a user NYM record being created for) and verkey (target verification key). See [Requests](https://github.com/hyperledger/indy-node/blob/master/docs/requests.md) to get more information about supported ledger transactions.
+The creation of a DID known to the Ledger is an **Identity Record** itself (NYM transaction). The NYM transaction can be used for creation of new DIDs that is known to that ledger, the setting and rotation of a verification key, and the setting and changing of roles. The most important fields of this transaction are `dest` (target DID), `role` (role of a user NYM record being created for) and the `verkey` (target verification key). See [Requests](https://github.com/hyperledger/indy-node/blob/master/docs/requests.md) to get more information about supported ledger transactions.
 
-Published with DID verification key allows to verify that someone owns this DID as he is only one who known corresponded sign key and any DID-related operation require signing with this key.
+Publishing with a DID verification key allows a person, organization or thing, to verify that someone owns this DID as he is the only one who knows the corresponding signing key and any DID-related operations require signing with this key.
 
 Our ledger is public permissioned and anyone who wants to publish DIDs need to get the role of **Trust Anchor** on the ledger. A **Trust Anchor** is a person or organization that the ledger already knows about, that is able to help bootstrap others. (It is *not* the same as what cybersecurity experts call a ""trusted third party""; think of it more like a facilitator). See [Roles](https://docs.google.com/spreadsheets/d/1TWXF7NtBjSOaUIBeIH77SyZnawfo91cJ_ns4TR-wsq4/edit#gid=0) to get more information about roles.
 
-On the first step Faber College, Acme Corp and Thrift Bank need to get the role of **Trust Anchor** on the ledger as they will need to create Verinyms and Pairwise-Unique Identifiers to provide the service to Alice. Becoming a **Trust Anchor** requires contacting a person or organization who already has **Trust Anchor** role on the ledger. In our empty test ledger we have only NYMs with **Steward** role, but all **Stewards** are automatically **Trust Anchors**.
+**The first step to being able to place transactions on the ledger, Faber College, Acme Corp and Thrift Bank will need to get the role of Trust Anchor on the ledger because they will need to create Verinyms and Pairwise-Unique Identifiers to provide the service to Alice.**",,2018-02-20 16:48:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/169367036,https://github.com/hyperledger/indy-sdk/pull/541#discussion_r169367036,vimmerru
https://github.com/hyperledger/indy-sdk/pull/541,https://github.com/hyperledger/indy-sdk/pull/541,I see what you're saying. Give me a minute to fix it.,fcbfd3c2fe863d4390018af4cdf292eff656ab90,2018-02-20 16:44:44,169382986,"@@ -46,37 +46,47 @@ As a graduate of Faber College, Alice receives an alumni newsletter where she le
 
 Alice doesn’t realize it yet, but in order to use this digital transcript she will need a new type of identity -- not the traditional identity that Faber College has built for her in its on-campus database, but a new and portable one that belongs to her, independent of all past and future relationships, that nobody can revoke or co-opt or correlate without her permission. This is a **_self-sovereign identity_** and it is the core feature of the ledger.
 
-In normal contexts, managing a self-sovereign identity will require a tool such as a desktop or mobile application. It might be a standalone app, or it might leverage a third party service provider that the ledger calls an **agency**. For example, leaders in this technology such as the Sovrin Foundation and companies like Evernym, publish reference versions of such tools. Faber College will have studied these requirements and will recommend a **_Indy app_** to Alice if she doesn’t already have one; this app will install as part of the workflow from the **Get Transcript** button.
+In normal contexts, managing a self-sovereign identity will require a tool such as a desktop or mobile application. It might be a standalone app or it might leverage a third party service provider that the ledger calls an **agency**. For example, leaders in this technology such as the Sovrin Foundation and companies like Evernym, publish reference versions of such tools. Faber College will have studied these requirements and will recommend an **_Indy app_** to Alice if she doesn’t already have one. This app will install as part of the workflow from the **Get Transcript** button.
 
-When Alice clicks **Get Transcript**, she will download a file that holds an Indy **connection request**. This connection request file, having a .indy extension and associated with her Indy app, will allow her to establish a secure channel of communication with another party in the ledger ecosystem -- Faber College.
+When Alice clicks **Get Transcript**, she will download a file that holds an Indy **connection request**. This connection request file, having an .indy extension and associated with her Indy app, will allow her to establish a secure channel of communication with another party in the ledger ecosystem -- Faber College.
 
 So when Alice clicks **Get Transcript**, she will normally end up installing an app (if needed), launching it, and then being asked by the app whether she wants to accept a request to connect with Faber.
 
-For this guide, however, we’ll be using a **Indy SDK API** instead of an app, so we can see what happens behind the scenes. We will pretend to be a particularly curious and technically adventurous Alice…
+For this guide, however, we’ll be using an **Indy SDK API** instead of an app, so we can see what happens behind the scenes. We will pretend to be a particularly curious and technically adventurous Alice…
 
-## Infrastructure preparation
+## Infrastructure Preparation
 
-### Getting Trust Anchor credentials for Faber, Acme, Thrift and Government
+### Step 1: Getting Trust Anchor Credentials for Faber, Acme, Thrift and Government
 
 Faber College and another actors have done some prep steps to offer this service to Alice. To understand these steps let's start with some definitions.
 
 The ledger is intended to store **Identity Records** that describe a **Ledger Entity**. Identity Records are public data and may include Public Keys, Service Endpoints, Claim Schemas, Claim Definitions. Every **Identity Record** is associated with exactly one **DID** (Decentralized Identifier) that is globally unique and resolvable (via a ledger) without requiring any centralized resolution authority. To maintain privacy each **Identity Owner** can own multiple DIDs.
 
-In this tutorial we will use 2 type of DIDs. The first one is **Verinym**. **Verinym** is associated with the **Legal Identity** of the **Identity Owner**. For example, all parties should be able to verify that some DID is used by Government to publish schemas for some document type. The second type is **Pseudonym** - a **Blinded Identifier** used to maintain privacy in the context on an ongoing digital relationship (**Connection**). if Pseudonym is used to maintain only one digital relationship we will call it Pairwise-Unique Identifier. We will use Pairwise-Unique Identifiers to maintain secure connections between actors in this tutorial.
+In this tutorial we will use two types of DIDs. The first one is a **Verinym**. **Verinym** is associated with the **Legal Identity** of the **Identity Owner**. For example, all parties should be able to verify that some DID is used by a Government to publish schemas for some document type. The second type is a **Pseudonym** - a **Blinded Identifier** used to maintain privacy in the context on an ongoing digital relationship (**Connection**). If the Pseudonym is used to maintain only one digital relationship we will call it a Pairwise-Unique Identifier. We will use Pairwise-Unique Identifiers to maintain secure connections between actors in this tutorial.
 
-Creation of DID known to the Ledger is **Identity Record** itself (NYM transaction). NYM transaction can be used for creation of new DIDs that ledger known, setting and rotation of verification key, setting and changing of roles. The most important fields of this transaction are dest (target DID), role (role of a user NYM record being created for) and verkey (target verification key). See [Requests](https://github.com/hyperledger/indy-node/blob/master/docs/requests.md) to get more information about supported ledger transactions.
+The creation of a DID known to the Ledger is an **Identity Record** itself (NYM transaction). The NYM transaction can be used for creation of new DIDs that is known to that ledger, the setting and rotation of a verification key, and the setting and changing of roles. The most important fields of this transaction are `dest` (target DID), `role` (role of a user NYM record being created for) and the `verkey` (target verification key). See [Requests](https://github.com/hyperledger/indy-node/blob/master/docs/requests.md) to get more information about supported ledger transactions.
 
-Published with DID verification key allows to verify that someone owns this DID as he is only one who known corresponded sign key and any DID-related operation require signing with this key.
+Publishing with a DID verification key allows a person, organization or thing, to verify that someone owns this DID as he is the only one who knows the corresponding signing key and any DID-related operations require signing with this key.
 
 Our ledger is public permissioned and anyone who wants to publish DIDs need to get the role of **Trust Anchor** on the ledger. A **Trust Anchor** is a person or organization that the ledger already knows about, that is able to help bootstrap others. (It is *not* the same as what cybersecurity experts call a ""trusted third party""; think of it more like a facilitator). See [Roles](https://docs.google.com/spreadsheets/d/1TWXF7NtBjSOaUIBeIH77SyZnawfo91cJ_ns4TR-wsq4/edit#gid=0) to get more information about roles.
 
-On the first step Faber College, Acme Corp and Thrift Bank need to get the role of **Trust Anchor** on the ledger as they will need to create Verinyms and Pairwise-Unique Identifiers to provide the service to Alice. Becoming a **Trust Anchor** requires contacting a person or organization who already has **Trust Anchor** role on the ledger. In our empty test ledger we have only NYMs with **Steward** role, but all **Stewards** are automatically **Trust Anchors**.
+**The first step to being able to place transactions on the ledger, Faber College, Acme Corp and Thrift Bank will need to get the role of Trust Anchor on the ledger because they will need to create Verinyms and Pairwise-Unique Identifiers to provide the service to Alice.**",,2018-02-20 16:48:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/169382986,https://github.com/hyperledger/indy-sdk/pull/541#discussion_r169382986,TechWritingWhiz
https://github.com/hyperledger/indy-sdk/pull/538,https://github.com/hyperledger/indy-sdk/pull/538,Could you add comment with motivation for this line?,bdbd031096fe24ebffc5a72e86350ddfe1144ba5,2018-02-16 14:32:59,168771244,"@@ -1791,6 +1791,7 @@ pub mod tests {
                 params.insert(""force"", ""true"".to_string()); // because node_works test added fifth Node
                 cmd.execute(&ctx, &params).unwrap();
             }
+            ::std::thread::sleep(::std::time::Duration::from_secs(1));",,2018-02-16 14:36:15,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/168771244,https://github.com/hyperledger/indy-sdk/pull/538#discussion_r168771244,vimmerru
https://github.com/hyperledger/indy-sdk/pull/527,https://github.com/hyperledger/indy-sdk/pull/527,"`UTF-8 or base64 seed string` is important comment about format of seed and should not be removed. If we want to have correct json, may be it's better to move this below?",070410eae01b51d81860a52ec0bc0cade3a4618e,2018-02-12 11:01:10,167522148,"@@ -96,10 +96,11 @@ pub mod import_command {
     command!(CommandMetadata::build(""import"", ""Import DIDs entities from file to the current wallet.
         File format:
         {
-            \""version\"": 1
-            \""dids\"": [
-                { \""did\"": \""did1\"", \""seed\"": \""UTF-8 or base64 seed string\"" },
-            ]
+            \""version\"": 1,
+            \""dids\"": [{
+                \""did\"": \""AAAAAAAAAAAAAAAAAAAAAA\"",
+                \""seed\"": \""00000000000000000000000000000000\""",,2018-02-14 09:45:28,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/167522148,https://github.com/hyperledger/indy-sdk/pull/527#discussion_r167522148,jovfer
https://github.com/hyperledger/indy-sdk/pull/522,https://github.com/hyperledger/indy-sdk/pull/522,@vimmerru should we release new stable version of IndyCrypto before merging this PR,606c0f655d8a2f38240b58c0b31a6770945b5ed5,2018-02-06 09:23:22,166229697,"@@ -158,7 +158,7 @@ dependencies = [
  ""etcommon-rlp 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)"",
  ""generic-array 0.8.3 (registry+https://github.com/rust-lang/crates.io-index)"",
  ""hex 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)"",
- ""indy-crypto 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)"",
+ ""indy-crypto 0.1.6-dev-25 (registry+https://github.com/rust-lang/crates.io-index)"",",,2018-02-14 14:05:10,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/166229697,https://github.com/hyperledger/indy-sdk/pull/522#discussion_r166229697,jovfer
https://github.com/hyperledger/indy-sdk/pull/522,https://github.com/hyperledger/indy-sdk/pull/522,May be changed to `master_secret_name`,606c0f655d8a2f38240b58c0b31a6770945b5ed5,2018-02-06 10:54:24,166256688,"@@ -57,13 +60,26 @@ pub struct ClaimRequest {
     pub prover_did: String,
     pub issuer_did: String,
     pub schema_key: SchemaKey,
-    pub blinded_ms: BlindedMasterSecret
+    pub blinded_ms: BlindedMasterSecret,
+    pub blinded_ms_correctness_proof: BlindedMasterSecretProofCorrectness,
+    pub nonce: Nonce,
 }
 
 impl JsonEncodable for ClaimRequest {}
 
 impl<'a> JsonDecodable<'a> for ClaimRequest {}
 
+#[derive(Debug, Serialize, Deserialize)]
+pub struct ClaimRequestMetadata {
+    pub master_secret_blinding_data: MasterSecretBlindingData,
+    pub nonce: Nonce,
+    pub master_secret: MasterSecret",,2018-02-14 14:05:10,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/166256688,https://github.com/hyperledger/indy-sdk/pull/522#discussion_r166256688,jovfer
https://github.com/hyperledger/indy-sdk/pull/522,https://github.com/hyperledger/indy-sdk/pull/522,I think so,606c0f655d8a2f38240b58c0b31a6770945b5ed5,2018-02-07 12:25:48,166601970,"@@ -158,7 +158,7 @@ dependencies = [
  ""etcommon-rlp 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)"",
  ""generic-array 0.8.3 (registry+https://github.com/rust-lang/crates.io-index)"",
  ""hex 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)"",
- ""indy-crypto 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)"",
+ ""indy-crypto 0.1.6-dev-25 (registry+https://github.com/rust-lang/crates.io-index)"",",,2018-02-14 14:05:10,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/166601970,https://github.com/hyperledger/indy-sdk/pull/522#discussion_r166601970,vimmerru
https://github.com/hyperledger/indy-sdk/pull/519,https://github.com/hyperledger/indy-sdk/pull/519,seems like `return` is missed,c053018cf49f77cfbb0122f485eabf3bb05f5a20,2018-02-02 09:39:25,165597678,"@@ -6,7 +6,11 @@ use prettytable::Table;
 use prettytable::row::Row;
 use prettytable::cell::Cell;
 
-pub fn print_list_table(rows: &Vec<serde_json::Value>, headers: &[(&str, &str)]) {
+pub fn print_list_table(rows: &Vec<serde_json::Value>, headers: &[(&str, &str)], empty_msg: &str) {
+    if rows.is_empty() {
+        println_succ!(""{}"", empty_msg);",,2018-02-02 10:08:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/165597678,https://github.com/hyperledger/indy-sdk/pull/519#discussion_r165597678,jovfer
https://github.com/hyperledger/indy-sdk/pull/508,https://github.com/hyperledger/indy-sdk/pull/508,We need to have a more clear mapping from bullet points to places in the code. May be put the part of code near each bullet point.,d0bc3c0d7a57728aabea323541825d9e9409d558,2018-02-05 13:39:32,165973466,"@@ -0,0 +1,804 @@
+# Getting Started with Libindy
+
+## A Developer Guide for an Implementation of the Libindy Code Base
+
+![logo](https://raw.githubusercontent.com/hyperledger/indy-node/master/collateral/logos/indy-logo.png)
+
+* [Getting Started with Indy](#getting-started-with-indy)
+  * [What Indy Is, and Why it Matters](#what-indy-is-and-why-it-matters)
+  * [What We'll Cover](#what-well-cover)
+  * [Involving of Alice](#involving-of-alice)
+  * [Infrastructure preparation](#infrastructure-preparation)
+      * [Getting Trust Anchor credentials for Faber, Acme, Thrift and Government](#getting-trust-anchor-credentials-for-faber-acme-thrift-and-government)
+      * [Connecting to Indy nodes pool](#connecting-to-indy-nodes-pool)
+      * [Getting the ownership for Stewards's Verinym](#getting-the-ownership-for-stewardss-verinym)
+      * [Onboarding Faber, Acme, Thrift and Government by Steward](#onboarding-faber-acme-thrift-and-government-by-steward)
+        * [Connection establishment](#connection-establishment)
+        * [Getting Verinym](#getting-verinym)
+      * [Claim Schemas Setup](#claim-schemas-setup)
+      * [Claim Definition Setup](#claim-definition-setup)
+  * [Alice Gets a Transcript](#alice-gets-a-transcript)
+  * [Apply for a Job](#apply-for-a-job)
+  * [Apply for a Loan](#apply-for-a-loan)
+  * [Explore the Code](#explore-the-code)
+
+## What Indy is, and Why it Matters
+
+The Indy code base (Indy) is a software ecosystem for private, secure, and powerful identity. Once it is implemented, it puts people — not the organizations that traditionally centralize identity — in charge of decisions about their own privacy and disclosure. This enables all kinds of rich innovation: connection contracts, revocation, novel payment workflows, asset and document management features, creative forms of escrow, curated reputation, integrations with other cool technologies, and so on.
+
+Indy uses open-source, distributed ledger technology. These ledgers are a form of database that is provided cooperatively by a pool of participants, instead of by a giant database with a central admin. Data lives redundantly in many places, and it accrues in transactions orchestrated by many machines. Strong, industry-standard cryptography protects it. Best practices in key management and cybersecurity pervade its design. The result is a reliable, public source of truth under no single entity’s control, robust to system failure, resilient to hacking, and highly immune to subversion by hostile entities.
+
+If the cryptography and blockchain details feel mysterious, fear not: this guide will help introduce you to key concepts within Indy. You’re starting in the right place.
+
+## What We’ll Cover
+
+Our goal is to introduce you to many of the concepts of Indy, and give you some idea of what happens behind the scenes to make it all work.
+
+We are going to frame the exploration with a story. Alice, a graduate of the fictional Faber College, wants to apply for a job at the fictional company Acme Corp. As soon as she has the job, she wants to apply for a loan in Thrift Bank so she can buy a car. She would like to use her college transcript as proof of her education on the job application; once hired, Alice would like to use the fact of employment as evidence of her creditworthiness for the loan.
+
+The sorts of identity and trust interactions required to pull this off are messy in the world today; they are slow, they violate privacy, and they are susceptible to fraud. We’ll show you how Indy is a quantum leap forward.
+
+Ready?
+
+## Involving of Alice
+
+As a graduate of Faber College, Alice receives an alumni newsletter where she learns that her alma mater is offering digital transcripts. She logs in to the college alumni website and requests her transcript by clicking **Get Transcript**.  (Other ways to initiate this request might include scanning a QR code, downloading a transcript package from a published URL, etc.)
+
+Alice doesn’t realize it yet, but in order to use this digital transcript she will need a new type of identity -- not the traditional identity that Faber College has built for her in its on-campus database, but a new and portable one that belongs to her, independent of all past and future relationships, that nobody can revoke or co-opt or correlate without her permission. This is a **_self-sovereign identity_** and it is the core feature of the ledger.
+
+In normal contexts, managing a self-sovereign identity will require a tool such as a desktop or mobile application. It might be a standalone app, or it might leverage a third party service provider that the ledger calls an **agency**. For example, leaders in this technology such as the Sovrin Foundation and companies like Evernym, publish reference versions of such tools. Faber College will have studied these requirements and will recommend a **_Indy app_** to Alice if she doesn’t already have one; this app will install as part of the workflow from the **Get Transcript** button.
+
+When Alice clicks **Get Transcript**, she will download a file that holds an Indy **connection request**. This connection request file, having a .indy extension and associated with her Indy app, will allow her to establish a secure channel of communication with another party in the ledger ecosystem -- Faber College.
+
+So when Alice clicks **Get Transcript**, she will normally end up installing an app (if needed), launching it, and then being asked by the app whether she wants to accept a request to connect with Faber.
+
+For this guide, however, we’ll be using a **Indy SDK API** instead of an app, so we can see what happens behind the scenes. We will pretend to be a particularly curious and technically adventurous Alice…
+
+## Infrastructure preparation
+
+### Getting Trust Anchor credentials for Faber, Acme, Thrift and Government
+
+Faber College and another actors have done some prep steps to offer this service to Alice. To understand these steps let's start with some definitions.
+
+The ledger is intended to store **Identity Records** that describe a **Ledger Entity**. Identity Records are public data and may include Public Keys, Service Endpoints, Claim Schemas, Claim Definitions. Every **Identity Record** is associated with exactly one **DID** (Decentralized Identifier) that is globally unique and resolvable (via a ledger) without requiring any centralized resolution authority. To maintain privacy each **Identity Owner** can own multiple DIDs.
+
+In this tutorial we will use 2 type of DIDs. The first one is **Verinym**. **Verinym** is associated with the **Legal Identity** of the **Identity Owner**. For example, all parties should be able to verify that some DID is used by Government to publish schemas for some document type. The second type is **Pseudonym** - a **Blinded Identifier** used to maintain privacy in the context on an ongoing digital relationship (**Connection**). if Pseudonym is used to maintain only one digital relationship we will call it Pairwise-Unique Identifier. We will use Pairwise-Unique Identifiers to maintain secure connections between actors in this tutorial.
+
+Creation of DID known to the Ledger is **Identity Record** itself (NYM transaction). NYM transaction can be used for creation of new DIDs that ledger known, setting and rotation of verification key, setting and changing of roles. The most important fields of this transaction are dest (target DID), role (role of a user NYM record being created for) and verkey (target verification key). See [Requests](https://github.com/hyperledger/indy-node/blob/master/docs/requests.md) to get more information about supported ledger transactions.
+
+Published with DID verification key allows to verify that someone owns this DID as he is only one who known corresponded sign key and any DID-related operation require signing with this key.
+
+Our ledger is public permissioned and anyone who wants to publish DIDs need to get the role of **Trust Anchor** on the ledger. A **Trust Anchor** is a person or organization that the ledger already knows about, that is able to help bootstrap others. (It is *not* the same as what cybersecurity experts call a ""trusted third party""; think of it more like a facilitator). See [Roles](https://docs.google.com/spreadsheets/d/1TWXF7NtBjSOaUIBeIH77SyZnawfo91cJ_ns4TR-wsq4/edit#gid=0) to get more information about roles.
+
+On the first step Faber College, Acme Corp and Thrift Bank need to get the role of **Trust Anchor** on the ledger as they will need to create Verinyms and Pairwise-Unique Identifiers to provide the service to Alice. Becoming a **Trust Anchor** requires contacting a person or organization who already has **Trust Anchor** role on the ledger. In our empty test ledger we have only NYMs with **Steward** role, but all **Stewards** are automatically **Trust Anchors**.
+
+#### Connecting to Indy nodes pool
+
+We are ready to start writing the code that will cover full Alice's use case. Important note is that for demo purposes it will be single test that will contain the code intended to be executed on different agents. We will always point what Agent is intended to execute each code part. Also we will use different wallets to store DID and keys of different Agents. Let's start.
+
+First code block will contain the code of **Steward's** agent. To write and read ledger's transactions we need to make connection to Indy nodes pool. Libindy allows to work with different pools like Sovrin pool or local pool we started by ourself as part of this tutorial. To work with different pools libindy has concept of **Pool Configuration**. The list of nodes in the pool is also stored in the ledger as NODE transactions. Libindy allows to restore actual list of NODE transactions by few known transactions that we call genesis transactions. Each **Pool Configuration** are defined as pair of pool configuration name and pool configuration json. The most important field in pool configuration json is path to file with the list if genesis transactions. ``pool.create_pool_ledger_config`` call allows to create named pool configuration. After pool configuration is created we can connect to the nodes pool that this configuration describes by calling ``pool.open_pool_ledger``. This call returns pool handle that can be used to reference this opened connection in future libindy calls.
+
+```python
+  "" Steward Agent
+  pool_name = 'pool1'
+  pool_genesis_txn_path = get_pool_genesis_txn_path(pool_name)
+  pool_config = json.dumps({""genesis_txn"": str(pool_genesis_txn_path)})
+  await pool.create_pool_ledger_config(pool_name, pool_config)
+  pool_handle = await pool.open_pool_ledger(pool_name, None)
+```
+
+#### Getting the ownership for Stewards's Verinym
+
+On the next step **Steward's** agent should get the ownership for DID that has corresponded NYM transaction with **Steward** role on the ledger. The test ledger we use was pre-configured to store some known **Steward** NYMs. Also we know **seed** values for random number generator that were used to generate keys for this NYMs. These **seed** values allow us to restore sign keys for these DIDs on **Steward's** agent side and as result get DID ownership.
+
+Libindy has conception of the **Wallet**. Wallet is secure storage for crypto materials like DIDs, keys and etc... To store **Steward's** DID and corresponded signkey agent should create named wallet first by calling ``pool.create_wallet``. After this wallet can be opened by calling ``pool.open_wallet``. This call returns wallet handle that can be used to reference this opened wallet in future libindy calls.
+
+After wallet is opened we can create DID record in this wallet by calling ``did.create_and_store_my_did`` that returns generated DID and verkey part of generated key. Signkey part for this DID will be stored in the wallet too, but it is impossible to read it directly.
+
+```python
+  # Steward Agent
+  steward_wallet_name = 'sovrin_steward_wallet'
+  await wallet.create_wallet(pool_name, steward_wallet_name, None, None, None)
+  steward_wallet = await wallet.open_wallet(steward_wallet_name, None, None)
+
+  steward_did_info = {'seed': '000000000000000000000000Steward1'}
+  (steward_did, steward_key) = await did.create_and_store_my_did(steward_wallet, json.dumps(steward_did_info))
+```
+
+Please note that we provided only information about seed to ``did.create_and_store_my_did``, but no any information about Steward's DID. The reason is that by default DID's are generated as fist 16 bytes of verkey. For such DID's for operations that require both DID and verkey we can use verkey in abbreviated form. In this form verkey starts with a tilde '~' followed by 22 or 23 characters. The tilde indicates that the DID itself represents the first 16 bytes of the verkey and the string following the tilde represents the second 16 bytes of the verkey, both using base58Check encoding.
+
+#### Onboarding Faber, Acme, Thrift and Government by Steward
+
+On the next step Faber, Acme, Thrift and Government should establish **Connection** with Steward. 
+Each connection is actually a pair of Pairwise-Unique Identifiers (DIDs). 
+The one DID is owned by one connection party and second by another.
+Both parties are know both DIDs and understand what connection this pair describes.
+The relationship between them is not shareable with others; it is unique to those two parties in that each pairwise relationship uses different DIDs. 
+We call process of establish connection **Onboarding**. 
+In this tutorial we will describe the simple version of onboarding process. 
+In our case one party will be always Trust Anchor. Real enterprise scenarios can use more complex version. 
+
+##### Connection establishment
+Let's look the process of connection establishment between **Steward** and **Faber College**.
+
+1. **Faber** and **Steward** contact in a some way to initiate onboarding process. 
+   It can be filling the form on web site or phone call.
+1. **Steward** creates new DID record in wallet by calling ``did.create_and_store_my_did`` that he will use for secure interactions with **Faber**.
+1. **Steward** sends corresponding `NYM` transaction to the Ledger by calling consistently ``ledger.build_nym_request`` to build NYM request and ``ledger.sign_and_submit_request`` to send the created request.
+1. **Steward** creates connection request which contains created `DID` and `Nonce`. 
+   This nonce is just a big random number generated to track the unique connection request. 
+   A nonce is a random arbitrary number that can only be used one time.  
+   When a connection request is accepted, the invitee digitally signs the nonce such that the inviter can match the response with a prior request.
+1. **Steward** sends connection request to **Faber**.
+1. **Faber** accepts connection request from **Steward**.
+1. **Faber** creates wallet if it does not exist yet.
+1. **Faber** creates new DID record in his wallet by calling ``did.create_and_store_my_did`` that he will use for secure interactions with **Steward**.
+1. **Faber** creates connection response which contains created `DID`, `Verkey` and `Nonce` from received connection request.
+1. **Faber** asks ledger for Verification key of **Steward's** DID by calling ``did.key_for_did``.
+1. **Faber** anonymous encrypts connection response by calling ``crypto.anon_crypt`` with **Steward** Verkey.
+   Anonymous-encryption schema is designed for sending of messages to a Recipient given its public key. 
+   Only the Recipient can decrypt these messages, using its private key. 
+   While the Recipient can verify the integrity of the message, it cannot verify the identity of the Sender.
+1. **Faber** sends anonymous encrypted connection response to **Steward**.
+1. **Steward** anonymous decrypts connection response by calling ``crypto.anon_decrypt``.
+1. **Steward** authenticates **Faber** by comparision of Nonce.
+1. **Steward** sends `NYM` transaction for **Faber's** DID to the Ledger. 
+Please note that despite Steward is sender of this transaction the owner of DID will be Faber as it uses Verkey provided by Faber.
+
+```python
+  (steward_faber_did, steward_faber_key) = await did.create_and_store_my_did(steward_wallet, ""{}"")",,2018-02-07 12:43:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/165973466,https://github.com/hyperledger/indy-sdk/pull/508#discussion_r165973466,vimmerru
https://github.com/hyperledger/indy-sdk/pull/508,https://github.com/hyperledger/indy-sdk/pull/508,We need to add the comment about the agent that executes each code piece for each code piece included.,d0bc3c0d7a57728aabea323541825d9e9409d558,2018-02-05 13:41:04,165973817,"@@ -0,0 +1,804 @@
+# Getting Started with Libindy
+
+## A Developer Guide for an Implementation of the Libindy Code Base
+
+![logo](https://raw.githubusercontent.com/hyperledger/indy-node/master/collateral/logos/indy-logo.png)
+
+* [Getting Started with Indy](#getting-started-with-indy)
+  * [What Indy Is, and Why it Matters](#what-indy-is-and-why-it-matters)
+  * [What We'll Cover](#what-well-cover)
+  * [Involving of Alice](#involving-of-alice)
+  * [Infrastructure preparation](#infrastructure-preparation)
+      * [Getting Trust Anchor credentials for Faber, Acme, Thrift and Government](#getting-trust-anchor-credentials-for-faber-acme-thrift-and-government)
+      * [Connecting to Indy nodes pool](#connecting-to-indy-nodes-pool)
+      * [Getting the ownership for Stewards's Verinym](#getting-the-ownership-for-stewardss-verinym)
+      * [Onboarding Faber, Acme, Thrift and Government by Steward](#onboarding-faber-acme-thrift-and-government-by-steward)
+        * [Connection establishment](#connection-establishment)
+        * [Getting Verinym](#getting-verinym)
+      * [Claim Schemas Setup](#claim-schemas-setup)
+      * [Claim Definition Setup](#claim-definition-setup)
+  * [Alice Gets a Transcript](#alice-gets-a-transcript)
+  * [Apply for a Job](#apply-for-a-job)
+  * [Apply for a Loan](#apply-for-a-loan)
+  * [Explore the Code](#explore-the-code)
+
+## What Indy is, and Why it Matters
+
+The Indy code base (Indy) is a software ecosystem for private, secure, and powerful identity. Once it is implemented, it puts people — not the organizations that traditionally centralize identity — in charge of decisions about their own privacy and disclosure. This enables all kinds of rich innovation: connection contracts, revocation, novel payment workflows, asset and document management features, creative forms of escrow, curated reputation, integrations with other cool technologies, and so on.
+
+Indy uses open-source, distributed ledger technology. These ledgers are a form of database that is provided cooperatively by a pool of participants, instead of by a giant database with a central admin. Data lives redundantly in many places, and it accrues in transactions orchestrated by many machines. Strong, industry-standard cryptography protects it. Best practices in key management and cybersecurity pervade its design. The result is a reliable, public source of truth under no single entity’s control, robust to system failure, resilient to hacking, and highly immune to subversion by hostile entities.
+
+If the cryptography and blockchain details feel mysterious, fear not: this guide will help introduce you to key concepts within Indy. You’re starting in the right place.
+
+## What We’ll Cover
+
+Our goal is to introduce you to many of the concepts of Indy, and give you some idea of what happens behind the scenes to make it all work.
+
+We are going to frame the exploration with a story. Alice, a graduate of the fictional Faber College, wants to apply for a job at the fictional company Acme Corp. As soon as she has the job, she wants to apply for a loan in Thrift Bank so she can buy a car. She would like to use her college transcript as proof of her education on the job application; once hired, Alice would like to use the fact of employment as evidence of her creditworthiness for the loan.
+
+The sorts of identity and trust interactions required to pull this off are messy in the world today; they are slow, they violate privacy, and they are susceptible to fraud. We’ll show you how Indy is a quantum leap forward.
+
+Ready?
+
+## Involving of Alice
+
+As a graduate of Faber College, Alice receives an alumni newsletter where she learns that her alma mater is offering digital transcripts. She logs in to the college alumni website and requests her transcript by clicking **Get Transcript**.  (Other ways to initiate this request might include scanning a QR code, downloading a transcript package from a published URL, etc.)
+
+Alice doesn’t realize it yet, but in order to use this digital transcript she will need a new type of identity -- not the traditional identity that Faber College has built for her in its on-campus database, but a new and portable one that belongs to her, independent of all past and future relationships, that nobody can revoke or co-opt or correlate without her permission. This is a **_self-sovereign identity_** and it is the core feature of the ledger.
+
+In normal contexts, managing a self-sovereign identity will require a tool such as a desktop or mobile application. It might be a standalone app, or it might leverage a third party service provider that the ledger calls an **agency**. For example, leaders in this technology such as the Sovrin Foundation and companies like Evernym, publish reference versions of such tools. Faber College will have studied these requirements and will recommend a **_Indy app_** to Alice if she doesn’t already have one; this app will install as part of the workflow from the **Get Transcript** button.
+
+When Alice clicks **Get Transcript**, she will download a file that holds an Indy **connection request**. This connection request file, having a .indy extension and associated with her Indy app, will allow her to establish a secure channel of communication with another party in the ledger ecosystem -- Faber College.
+
+So when Alice clicks **Get Transcript**, she will normally end up installing an app (if needed), launching it, and then being asked by the app whether she wants to accept a request to connect with Faber.
+
+For this guide, however, we’ll be using a **Indy SDK API** instead of an app, so we can see what happens behind the scenes. We will pretend to be a particularly curious and technically adventurous Alice…
+
+## Infrastructure preparation
+
+### Getting Trust Anchor credentials for Faber, Acme, Thrift and Government
+
+Faber College and another actors have done some prep steps to offer this service to Alice. To understand these steps let's start with some definitions.
+
+The ledger is intended to store **Identity Records** that describe a **Ledger Entity**. Identity Records are public data and may include Public Keys, Service Endpoints, Claim Schemas, Claim Definitions. Every **Identity Record** is associated with exactly one **DID** (Decentralized Identifier) that is globally unique and resolvable (via a ledger) without requiring any centralized resolution authority. To maintain privacy each **Identity Owner** can own multiple DIDs.
+
+In this tutorial we will use 2 type of DIDs. The first one is **Verinym**. **Verinym** is associated with the **Legal Identity** of the **Identity Owner**. For example, all parties should be able to verify that some DID is used by Government to publish schemas for some document type. The second type is **Pseudonym** - a **Blinded Identifier** used to maintain privacy in the context on an ongoing digital relationship (**Connection**). if Pseudonym is used to maintain only one digital relationship we will call it Pairwise-Unique Identifier. We will use Pairwise-Unique Identifiers to maintain secure connections between actors in this tutorial.
+
+Creation of DID known to the Ledger is **Identity Record** itself (NYM transaction). NYM transaction can be used for creation of new DIDs that ledger known, setting and rotation of verification key, setting and changing of roles. The most important fields of this transaction are dest (target DID), role (role of a user NYM record being created for) and verkey (target verification key). See [Requests](https://github.com/hyperledger/indy-node/blob/master/docs/requests.md) to get more information about supported ledger transactions.
+
+Published with DID verification key allows to verify that someone owns this DID as he is only one who known corresponded sign key and any DID-related operation require signing with this key.
+
+Our ledger is public permissioned and anyone who wants to publish DIDs need to get the role of **Trust Anchor** on the ledger. A **Trust Anchor** is a person or organization that the ledger already knows about, that is able to help bootstrap others. (It is *not* the same as what cybersecurity experts call a ""trusted third party""; think of it more like a facilitator). See [Roles](https://docs.google.com/spreadsheets/d/1TWXF7NtBjSOaUIBeIH77SyZnawfo91cJ_ns4TR-wsq4/edit#gid=0) to get more information about roles.
+
+On the first step Faber College, Acme Corp and Thrift Bank need to get the role of **Trust Anchor** on the ledger as they will need to create Verinyms and Pairwise-Unique Identifiers to provide the service to Alice. Becoming a **Trust Anchor** requires contacting a person or organization who already has **Trust Anchor** role on the ledger. In our empty test ledger we have only NYMs with **Steward** role, but all **Stewards** are automatically **Trust Anchors**.
+
+#### Connecting to Indy nodes pool
+
+We are ready to start writing the code that will cover full Alice's use case. Important note is that for demo purposes it will be single test that will contain the code intended to be executed on different agents. We will always point what Agent is intended to execute each code part. Also we will use different wallets to store DID and keys of different Agents. Let's start.
+
+First code block will contain the code of **Steward's** agent. To write and read ledger's transactions we need to make connection to Indy nodes pool. Libindy allows to work with different pools like Sovrin pool or local pool we started by ourself as part of this tutorial. To work with different pools libindy has concept of **Pool Configuration**. The list of nodes in the pool is also stored in the ledger as NODE transactions. Libindy allows to restore actual list of NODE transactions by few known transactions that we call genesis transactions. Each **Pool Configuration** are defined as pair of pool configuration name and pool configuration json. The most important field in pool configuration json is path to file with the list if genesis transactions. ``pool.create_pool_ledger_config`` call allows to create named pool configuration. After pool configuration is created we can connect to the nodes pool that this configuration describes by calling ``pool.open_pool_ledger``. This call returns pool handle that can be used to reference this opened connection in future libindy calls.
+
+```python
+  "" Steward Agent
+  pool_name = 'pool1'
+  pool_genesis_txn_path = get_pool_genesis_txn_path(pool_name)
+  pool_config = json.dumps({""genesis_txn"": str(pool_genesis_txn_path)})
+  await pool.create_pool_ledger_config(pool_name, pool_config)
+  pool_handle = await pool.open_pool_ledger(pool_name, None)
+```
+
+#### Getting the ownership for Stewards's Verinym
+
+On the next step **Steward's** agent should get the ownership for DID that has corresponded NYM transaction with **Steward** role on the ledger. The test ledger we use was pre-configured to store some known **Steward** NYMs. Also we know **seed** values for random number generator that were used to generate keys for this NYMs. These **seed** values allow us to restore sign keys for these DIDs on **Steward's** agent side and as result get DID ownership.
+
+Libindy has conception of the **Wallet**. Wallet is secure storage for crypto materials like DIDs, keys and etc... To store **Steward's** DID and corresponded signkey agent should create named wallet first by calling ``pool.create_wallet``. After this wallet can be opened by calling ``pool.open_wallet``. This call returns wallet handle that can be used to reference this opened wallet in future libindy calls.
+
+After wallet is opened we can create DID record in this wallet by calling ``did.create_and_store_my_did`` that returns generated DID and verkey part of generated key. Signkey part for this DID will be stored in the wallet too, but it is impossible to read it directly.
+
+```python
+  # Steward Agent
+  steward_wallet_name = 'sovrin_steward_wallet'
+  await wallet.create_wallet(pool_name, steward_wallet_name, None, None, None)
+  steward_wallet = await wallet.open_wallet(steward_wallet_name, None, None)
+
+  steward_did_info = {'seed': '000000000000000000000000Steward1'}
+  (steward_did, steward_key) = await did.create_and_store_my_did(steward_wallet, json.dumps(steward_did_info))
+```
+
+Please note that we provided only information about seed to ``did.create_and_store_my_did``, but no any information about Steward's DID. The reason is that by default DID's are generated as fist 16 bytes of verkey. For such DID's for operations that require both DID and verkey we can use verkey in abbreviated form. In this form verkey starts with a tilde '~' followed by 22 or 23 characters. The tilde indicates that the DID itself represents the first 16 bytes of the verkey and the string following the tilde represents the second 16 bytes of the verkey, both using base58Check encoding.
+
+#### Onboarding Faber, Acme, Thrift and Government by Steward
+
+On the next step Faber, Acme, Thrift and Government should establish **Connection** with Steward. 
+Each connection is actually a pair of Pairwise-Unique Identifiers (DIDs). 
+The one DID is owned by one connection party and second by another.
+Both parties are know both DIDs and understand what connection this pair describes.
+The relationship between them is not shareable with others; it is unique to those two parties in that each pairwise relationship uses different DIDs. 
+We call process of establish connection **Onboarding**. 
+In this tutorial we will describe the simple version of onboarding process. 
+In our case one party will be always Trust Anchor. Real enterprise scenarios can use more complex version. 
+
+##### Connection establishment
+Let's look the process of connection establishment between **Steward** and **Faber College**.
+
+1. **Faber** and **Steward** contact in a some way to initiate onboarding process. 
+   It can be filling the form on web site or phone call.
+1. **Steward** creates new DID record in wallet by calling ``did.create_and_store_my_did`` that he will use for secure interactions with **Faber**.
+1. **Steward** sends corresponding `NYM` transaction to the Ledger by calling consistently ``ledger.build_nym_request`` to build NYM request and ``ledger.sign_and_submit_request`` to send the created request.
+1. **Steward** creates connection request which contains created `DID` and `Nonce`. 
+   This nonce is just a big random number generated to track the unique connection request. 
+   A nonce is a random arbitrary number that can only be used one time.  
+   When a connection request is accepted, the invitee digitally signs the nonce such that the inviter can match the response with a prior request.
+1. **Steward** sends connection request to **Faber**.
+1. **Faber** accepts connection request from **Steward**.
+1. **Faber** creates wallet if it does not exist yet.
+1. **Faber** creates new DID record in his wallet by calling ``did.create_and_store_my_did`` that he will use for secure interactions with **Steward**.
+1. **Faber** creates connection response which contains created `DID`, `Verkey` and `Nonce` from received connection request.
+1. **Faber** asks ledger for Verification key of **Steward's** DID by calling ``did.key_for_did``.
+1. **Faber** anonymous encrypts connection response by calling ``crypto.anon_crypt`` with **Steward** Verkey.
+   Anonymous-encryption schema is designed for sending of messages to a Recipient given its public key. 
+   Only the Recipient can decrypt these messages, using its private key. 
+   While the Recipient can verify the integrity of the message, it cannot verify the identity of the Sender.
+1. **Faber** sends anonymous encrypted connection response to **Steward**.
+1. **Steward** anonymous decrypts connection response by calling ``crypto.anon_decrypt``.
+1. **Steward** authenticates **Faber** by comparision of Nonce.
+1. **Steward** sends `NYM` transaction for **Faber's** DID to the Ledger. 
+Please note that despite Steward is sender of this transaction the owner of DID will be Faber as it uses Verkey provided by Faber.
+
+```python
+  (steward_faber_did, steward_faber_key) = await did.create_and_store_my_did(steward_wallet, ""{}"")",,2018-02-07 12:43:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/165973817,https://github.com/hyperledger/indy-sdk/pull/508#discussion_r165973817,vimmerru
https://github.com/hyperledger/indy-sdk/pull/508,https://github.com/hyperledger/indy-sdk/pull/508,Alice don't need Verinym. Pairwise DIDs are enough.,d0bc3c0d7a57728aabea323541825d9e9409d558,2018-02-05 13:41:58,165974021,"@@ -0,0 +1,804 @@
+# Getting Started with Libindy
+
+## A Developer Guide for an Implementation of the Libindy Code Base
+
+![logo](https://raw.githubusercontent.com/hyperledger/indy-node/master/collateral/logos/indy-logo.png)
+
+* [Getting Started with Indy](#getting-started-with-indy)
+  * [What Indy Is, and Why it Matters](#what-indy-is-and-why-it-matters)
+  * [What We'll Cover](#what-well-cover)
+  * [Involving of Alice](#involving-of-alice)
+  * [Infrastructure preparation](#infrastructure-preparation)
+      * [Getting Trust Anchor credentials for Faber, Acme, Thrift and Government](#getting-trust-anchor-credentials-for-faber-acme-thrift-and-government)
+      * [Connecting to Indy nodes pool](#connecting-to-indy-nodes-pool)
+      * [Getting the ownership for Stewards's Verinym](#getting-the-ownership-for-stewardss-verinym)
+      * [Onboarding Faber, Acme, Thrift and Government by Steward](#onboarding-faber-acme-thrift-and-government-by-steward)
+        * [Connection establishment](#connection-establishment)
+        * [Getting Verinym](#getting-verinym)
+      * [Claim Schemas Setup](#claim-schemas-setup)
+      * [Claim Definition Setup](#claim-definition-setup)
+  * [Alice Gets a Transcript](#alice-gets-a-transcript)
+  * [Apply for a Job](#apply-for-a-job)
+  * [Apply for a Loan](#apply-for-a-loan)
+  * [Explore the Code](#explore-the-code)
+
+## What Indy is, and Why it Matters
+
+The Indy code base (Indy) is a software ecosystem for private, secure, and powerful identity. Once it is implemented, it puts people — not the organizations that traditionally centralize identity — in charge of decisions about their own privacy and disclosure. This enables all kinds of rich innovation: connection contracts, revocation, novel payment workflows, asset and document management features, creative forms of escrow, curated reputation, integrations with other cool technologies, and so on.
+
+Indy uses open-source, distributed ledger technology. These ledgers are a form of database that is provided cooperatively by a pool of participants, instead of by a giant database with a central admin. Data lives redundantly in many places, and it accrues in transactions orchestrated by many machines. Strong, industry-standard cryptography protects it. Best practices in key management and cybersecurity pervade its design. The result is a reliable, public source of truth under no single entity’s control, robust to system failure, resilient to hacking, and highly immune to subversion by hostile entities.
+
+If the cryptography and blockchain details feel mysterious, fear not: this guide will help introduce you to key concepts within Indy. You’re starting in the right place.
+
+## What We’ll Cover
+
+Our goal is to introduce you to many of the concepts of Indy, and give you some idea of what happens behind the scenes to make it all work.
+
+We are going to frame the exploration with a story. Alice, a graduate of the fictional Faber College, wants to apply for a job at the fictional company Acme Corp. As soon as she has the job, she wants to apply for a loan in Thrift Bank so she can buy a car. She would like to use her college transcript as proof of her education on the job application; once hired, Alice would like to use the fact of employment as evidence of her creditworthiness for the loan.
+
+The sorts of identity and trust interactions required to pull this off are messy in the world today; they are slow, they violate privacy, and they are susceptible to fraud. We’ll show you how Indy is a quantum leap forward.
+
+Ready?
+
+## Involving of Alice
+
+As a graduate of Faber College, Alice receives an alumni newsletter where she learns that her alma mater is offering digital transcripts. She logs in to the college alumni website and requests her transcript by clicking **Get Transcript**.  (Other ways to initiate this request might include scanning a QR code, downloading a transcript package from a published URL, etc.)
+
+Alice doesn’t realize it yet, but in order to use this digital transcript she will need a new type of identity -- not the traditional identity that Faber College has built for her in its on-campus database, but a new and portable one that belongs to her, independent of all past and future relationships, that nobody can revoke or co-opt or correlate without her permission. This is a **_self-sovereign identity_** and it is the core feature of the ledger.
+
+In normal contexts, managing a self-sovereign identity will require a tool such as a desktop or mobile application. It might be a standalone app, or it might leverage a third party service provider that the ledger calls an **agency**. For example, leaders in this technology such as the Sovrin Foundation and companies like Evernym, publish reference versions of such tools. Faber College will have studied these requirements and will recommend a **_Indy app_** to Alice if she doesn’t already have one; this app will install as part of the workflow from the **Get Transcript** button.
+
+When Alice clicks **Get Transcript**, she will download a file that holds an Indy **connection request**. This connection request file, having a .indy extension and associated with her Indy app, will allow her to establish a secure channel of communication with another party in the ledger ecosystem -- Faber College.
+
+So when Alice clicks **Get Transcript**, she will normally end up installing an app (if needed), launching it, and then being asked by the app whether she wants to accept a request to connect with Faber.
+
+For this guide, however, we’ll be using a **Indy SDK API** instead of an app, so we can see what happens behind the scenes. We will pretend to be a particularly curious and technically adventurous Alice…
+
+## Infrastructure preparation
+
+### Getting Trust Anchor credentials for Faber, Acme, Thrift and Government
+
+Faber College and another actors have done some prep steps to offer this service to Alice. To understand these steps let's start with some definitions.
+
+The ledger is intended to store **Identity Records** that describe a **Ledger Entity**. Identity Records are public data and may include Public Keys, Service Endpoints, Claim Schemas, Claim Definitions. Every **Identity Record** is associated with exactly one **DID** (Decentralized Identifier) that is globally unique and resolvable (via a ledger) without requiring any centralized resolution authority. To maintain privacy each **Identity Owner** can own multiple DIDs.
+
+In this tutorial we will use 2 type of DIDs. The first one is **Verinym**. **Verinym** is associated with the **Legal Identity** of the **Identity Owner**. For example, all parties should be able to verify that some DID is used by Government to publish schemas for some document type. The second type is **Pseudonym** - a **Blinded Identifier** used to maintain privacy in the context on an ongoing digital relationship (**Connection**). if Pseudonym is used to maintain only one digital relationship we will call it Pairwise-Unique Identifier. We will use Pairwise-Unique Identifiers to maintain secure connections between actors in this tutorial.
+
+Creation of DID known to the Ledger is **Identity Record** itself (NYM transaction). NYM transaction can be used for creation of new DIDs that ledger known, setting and rotation of verification key, setting and changing of roles. The most important fields of this transaction are dest (target DID), role (role of a user NYM record being created for) and verkey (target verification key). See [Requests](https://github.com/hyperledger/indy-node/blob/master/docs/requests.md) to get more information about supported ledger transactions.
+
+Published with DID verification key allows to verify that someone owns this DID as he is only one who known corresponded sign key and any DID-related operation require signing with this key.
+
+Our ledger is public permissioned and anyone who wants to publish DIDs need to get the role of **Trust Anchor** on the ledger. A **Trust Anchor** is a person or organization that the ledger already knows about, that is able to help bootstrap others. (It is *not* the same as what cybersecurity experts call a ""trusted third party""; think of it more like a facilitator). See [Roles](https://docs.google.com/spreadsheets/d/1TWXF7NtBjSOaUIBeIH77SyZnawfo91cJ_ns4TR-wsq4/edit#gid=0) to get more information about roles.
+
+On the first step Faber College, Acme Corp and Thrift Bank need to get the role of **Trust Anchor** on the ledger as they will need to create Verinyms and Pairwise-Unique Identifiers to provide the service to Alice. Becoming a **Trust Anchor** requires contacting a person or organization who already has **Trust Anchor** role on the ledger. In our empty test ledger we have only NYMs with **Steward** role, but all **Stewards** are automatically **Trust Anchors**.
+
+#### Connecting to Indy nodes pool
+
+We are ready to start writing the code that will cover full Alice's use case. Important note is that for demo purposes it will be single test that will contain the code intended to be executed on different agents. We will always point what Agent is intended to execute each code part. Also we will use different wallets to store DID and keys of different Agents. Let's start.
+
+First code block will contain the code of **Steward's** agent. To write and read ledger's transactions we need to make connection to Indy nodes pool. Libindy allows to work with different pools like Sovrin pool or local pool we started by ourself as part of this tutorial. To work with different pools libindy has concept of **Pool Configuration**. The list of nodes in the pool is also stored in the ledger as NODE transactions. Libindy allows to restore actual list of NODE transactions by few known transactions that we call genesis transactions. Each **Pool Configuration** are defined as pair of pool configuration name and pool configuration json. The most important field in pool configuration json is path to file with the list if genesis transactions. ``pool.create_pool_ledger_config`` call allows to create named pool configuration. After pool configuration is created we can connect to the nodes pool that this configuration describes by calling ``pool.open_pool_ledger``. This call returns pool handle that can be used to reference this opened connection in future libindy calls.
+
+```python
+  "" Steward Agent
+  pool_name = 'pool1'
+  pool_genesis_txn_path = get_pool_genesis_txn_path(pool_name)
+  pool_config = json.dumps({""genesis_txn"": str(pool_genesis_txn_path)})
+  await pool.create_pool_ledger_config(pool_name, pool_config)
+  pool_handle = await pool.open_pool_ledger(pool_name, None)
+```
+
+#### Getting the ownership for Stewards's Verinym
+
+On the next step **Steward's** agent should get the ownership for DID that has corresponded NYM transaction with **Steward** role on the ledger. The test ledger we use was pre-configured to store some known **Steward** NYMs. Also we know **seed** values for random number generator that were used to generate keys for this NYMs. These **seed** values allow us to restore sign keys for these DIDs on **Steward's** agent side and as result get DID ownership.
+
+Libindy has conception of the **Wallet**. Wallet is secure storage for crypto materials like DIDs, keys and etc... To store **Steward's** DID and corresponded signkey agent should create named wallet first by calling ``pool.create_wallet``. After this wallet can be opened by calling ``pool.open_wallet``. This call returns wallet handle that can be used to reference this opened wallet in future libindy calls.
+
+After wallet is opened we can create DID record in this wallet by calling ``did.create_and_store_my_did`` that returns generated DID and verkey part of generated key. Signkey part for this DID will be stored in the wallet too, but it is impossible to read it directly.
+
+```python
+  # Steward Agent
+  steward_wallet_name = 'sovrin_steward_wallet'
+  await wallet.create_wallet(pool_name, steward_wallet_name, None, None, None)
+  steward_wallet = await wallet.open_wallet(steward_wallet_name, None, None)
+
+  steward_did_info = {'seed': '000000000000000000000000Steward1'}
+  (steward_did, steward_key) = await did.create_and_store_my_did(steward_wallet, json.dumps(steward_did_info))
+```
+
+Please note that we provided only information about seed to ``did.create_and_store_my_did``, but no any information about Steward's DID. The reason is that by default DID's are generated as fist 16 bytes of verkey. For such DID's for operations that require both DID and verkey we can use verkey in abbreviated form. In this form verkey starts with a tilde '~' followed by 22 or 23 characters. The tilde indicates that the DID itself represents the first 16 bytes of the verkey and the string following the tilde represents the second 16 bytes of the verkey, both using base58Check encoding.
+
+#### Onboarding Faber, Acme, Thrift and Government by Steward
+
+On the next step Faber, Acme, Thrift and Government should establish **Connection** with Steward. 
+Each connection is actually a pair of Pairwise-Unique Identifiers (DIDs). 
+The one DID is owned by one connection party and second by another.
+Both parties are know both DIDs and understand what connection this pair describes.
+The relationship between them is not shareable with others; it is unique to those two parties in that each pairwise relationship uses different DIDs. 
+We call process of establish connection **Onboarding**. 
+In this tutorial we will describe the simple version of onboarding process. 
+In our case one party will be always Trust Anchor. Real enterprise scenarios can use more complex version. 
+
+##### Connection establishment
+Let's look the process of connection establishment between **Steward** and **Faber College**.
+
+1. **Faber** and **Steward** contact in a some way to initiate onboarding process. 
+   It can be filling the form on web site or phone call.
+1. **Steward** creates new DID record in wallet by calling ``did.create_and_store_my_did`` that he will use for secure interactions with **Faber**.
+1. **Steward** sends corresponding `NYM` transaction to the Ledger by calling consistently ``ledger.build_nym_request`` to build NYM request and ``ledger.sign_and_submit_request`` to send the created request.
+1. **Steward** creates connection request which contains created `DID` and `Nonce`. 
+   This nonce is just a big random number generated to track the unique connection request. 
+   A nonce is a random arbitrary number that can only be used one time.  
+   When a connection request is accepted, the invitee digitally signs the nonce such that the inviter can match the response with a prior request.
+1. **Steward** sends connection request to **Faber**.
+1. **Faber** accepts connection request from **Steward**.
+1. **Faber** creates wallet if it does not exist yet.
+1. **Faber** creates new DID record in his wallet by calling ``did.create_and_store_my_did`` that he will use for secure interactions with **Steward**.
+1. **Faber** creates connection response which contains created `DID`, `Verkey` and `Nonce` from received connection request.
+1. **Faber** asks ledger for Verification key of **Steward's** DID by calling ``did.key_for_did``.
+1. **Faber** anonymous encrypts connection response by calling ``crypto.anon_crypt`` with **Steward** Verkey.
+   Anonymous-encryption schema is designed for sending of messages to a Recipient given its public key. 
+   Only the Recipient can decrypt these messages, using its private key. 
+   While the Recipient can verify the integrity of the message, it cannot verify the identity of the Sender.
+1. **Faber** sends anonymous encrypted connection response to **Steward**.
+1. **Steward** anonymous decrypts connection response by calling ``crypto.anon_decrypt``.
+1. **Steward** authenticates **Faber** by comparision of Nonce.
+1. **Steward** sends `NYM` transaction for **Faber's** DID to the Ledger. 
+Please note that despite Steward is sender of this transaction the owner of DID will be Faber as it uses Verkey provided by Faber.
+
+```python
+  (steward_faber_did, steward_faber_key) = await did.create_and_store_my_did(steward_wallet, ""{}"")
+  nym_request = await ledger.build_nym_request(steward_did, steward_faber_did, steward_faber_key, None, role)
+  await ledger.sign_and_submit_request(pool_handle, steward_wallet, steward_did, nym_request)
+   
+  connection_request = {
+      'did': steward_faber_did,
+      'nonce': 123456789
+  }
+    
+  await wallet.create_wallet(pool_name, 'faber_wallet', None, None, None)
+  faber_wallet = await wallet.open_wallet('faber_wallet', None, None)
+    
+  (faber_steward_did, faber_steward_key) = await did.create_and_store_my_did(faber_wallet, ""{}"")
+  steward_faber_verkey = await did.key_for_did(pool_handle, faber_wallet, connection_request['did'])
+    
+  connection_response = json.dumps({
+      'did': faber_steward_did,
+      'verkey': faber_steward_key,
+      'nonce': connection_request['nonce']
+  })
+  anoncrypted_connection_response = await crypto.anon_crypt(steward_faber_verkey, connection_response.encode('utf-8'))
+    
+  decrypted_connection_response = \
+      (await crypto.anon_decrypt(steward_wallet, steward_faber_key, anoncrypted_connection_response)).decode(""utf-8"")
+      
+  assert connection_request['nonce'] == decrypted_connection_response['nonce']
+        
+  nym_request = await ledger.build_nym_request(steward_did, decrypted_connection_response['did'], decrypted_connection_response['verkey'], None, role)
+  await ledger.sign_and_submit_request(pool_handle, steward_wallet, steward_did, nym_request)
+```
+
+At this point **Faber** is connected to **Steward** and can interact in a secure way and can trust the response from **Steward** because 
+(1) he connects to the current endpoint, 
+(2) no replay - attack is possible, due to her random challenge, 
+(3) he knows the verification key used to verify **Steward** digital signature is the correct one because he just confirmed it on the ledger.
+
+Note: **Every Side** must not use same DID's to establish other relationships.
+By having independent pairwise relationships, we reduces the ability for others to correlate your activities across multiple interactions.
+
+##### Getting Verinym
+
+It is important to understand that created early **Faber** DID is not, in and of itself, the same thing as self-sovereign identity.
+This DID must be used only for secure interaction with **Steward**.
+After the connection is established **Faber** must create new DID record that he will use as Verinym in the Ledger.
+1. **Faber** creates new DID in his wallet by calling ``did.create_and_store_my_did``.
+1. **Faber** prepares the message that will contain created DID and Verkey.
+1. **Faber** authenticated encrypts the message by calling ``crypto.auth_crypt`` using Verkeys created for secure communication with **Steward**. 
+   Authenticated-encryption schema is designed for sending of a confidential message specifically for Recipient, using Sender's public key.
+   Using Recipient's public key, Sender can compute a shared secret key. Using Sender's public key and his secret key, Recipient can compute the exact same shared secret key.
+   That shared secret key can be used to verify that the encrypted message was not tampered with, before eventually decrypting it.
+1. **Faber** sends encrypted message to **Steward**.
+1. **Steward** decrypts received message by calling ``crypto.auth_decrypt``.
+1. **Steward** asks ledger for Verification key of **Faber's** DID by calling ``did.key_for_did``.
+1. **Steward** authenticates **Faber** by comparision of Message Sender Verkey and **Faber** Verkey received from the Ledger.
+1. **Steward** sends corresponded NYM transaction to the Ledger with `TRUST ANCHOR` role.
+Please note that despite Steward is sender of this transaction the owner of DID will be Faber as it uses Verkey provided by Faber.
+
+```python
+  (faber_did, faber_key) = await did.create_and_store_my_did(faber_wallet, ""{}"")
+    
+  faber_did_info_json = json.dumps({
+      'did': faber_did,
+      'verkey': faber_key
+  })
+  authcrypted_faber_did_info_json = \
+      await crypto.auth_crypt(faber_wallet, faber_steward_key, steward_faber_key, faber_did_info_json.encode('utf-8'))
+        
+  sender_verkey, authdecrypted_faber_did_info_json = \
+      await crypto.auth_decrypt(steward_handle, steward_faber_key, authcrypted_faber_did_info_json)
+  faber_did_info = json.loads(authdecrypted_faber_did_info_json)
+  
+  assert sender_verkey == await did.key_for_did(pool_handle, from_wallet, faber_did_info['did'])
+        
+  nym_request = await ledger.build_nym_request(steward_did, decrypted_faber_did_info_json['did'],
+                                               decrypted_faber_did_info_json['verkey'], None, 'TRUST_ANCHOR')
+  await ledger.sign_and_submit_request(pool_handle, steward_wallet, steward_did, nym_request)
+```
+At this point **Faber** has DID related to his identity in the Ledger. 
+
+**Acme**, **Thrift Bank**, and **Government** must pass the same Onboarding process connection establishment with **Steward**.
+
+#### Claim Schemas Setup
+**Claim Schema** - is the base semantic structure that describes the list of attributes which one particular Claim can contain. 
+
+Note: It's not possible to update existing Schema. So, if the Schema needs to be evolved, a new Schema with a new version or name needs to be created.
+
+**Claim Schema** can be created and saved in the Ledger by any **Trust Anchor** by following the next steps:
+1. **Trust Anchor** optionally creates new DID record in his wallet and sends corresponded NYM transaction to the Ledger.
+1. **Trust Anchor** prepares **Claim Schema**.
+1. **Trust Anchor** sends corresponded Schema transaction to the Ledger by calling consistently ``ledger.build_schema_request`` to build Schema request and ``ledger.sign_and_submit_request`` to send created request.
+
+Here is **Government** creates and publishes **Transcript** Claim Schema to the Ledger:
+```python
+  (government_issuer_did, government_issuer_key) = await did.create_and_store_my_did(government_wallet, ""{}"")
+  nym_request = await ledger.build_nym_request(government_did, government_issuer_did, government_issuer_key, None, None)
+  await ledger.sign_and_submit_request(pool_handle, government_handle, government_did, nym_request)
+        
+  transcript_schema = {
+      'name': 'Transcript',
+      'version': '1.2',
+      'attr_names': ['first_name', 'last_name', 'degree', 'status', 'year', 'average', 'ssn']
+  }
+  schema_request = await ledger.build_schema_request(government_issuer_did, json.dumps(transcript_schema))
+  await ledger.sign_and_submit_request(pool_handle, government_wallet, government_issuer_did, schema_request)
+```
+
+The same way **Government** creates and publishes **Job-Certificate** Claim Schema to the Ledger:
+```python    
+  job_certificate_schema = {
+      'name': 'Job-Certificate',
+      'version': '0.2',
+      'attr_names': ['first_name', 'last_name', 'salary', 'employee_status', 'experience']
+  }
+  schema_request = await ledger.build_schema_request(government_issuer_did, json.dumps(to the Ledger))
+  await ledger.sign_and_submit_request(pool_handle, government_wallet, government_issuer_did, schema_request)
+```
+
+At this point we have **Transcript** and **Job-Certificate** Claim Schemas published by **Government** to the Ledger.
+
+#### Claim Definition Setup
+Claim Definition is similar to keys that Issuer use for signing of Claims satisfied specific Claim Schema. 
+
+Note: One Issuer DID can create just one Claim Definition for the specific Claim Schema, but different Issuer DIDs can create numerous Claim Definitions for the same Claim Schema.
+
+Note: It's not possible to update data in existing Claim Def. So, if a ClaimDef needs to be evolved (for example, a key needs to be rotated), then a new Claim Def needs to be created by a new Issuer DID.
+
+**Claim Definition** can be created and saved in the Ledger by any **Trust Anchor** by following the next steps:
+1. **Trust Anchor** optionally creates new DID record in his wallet and sends corresponded NYM transaction to the Ledger.
+1. **Trust Anchor** gets specific **Claim Schema** from the Ledger by calling consistently ``ledger.build_get_schema_request`` to build GetSchema request and ``ledger.sign_and_submit_request`` to send created request.
+1. **Trust Anchor** creates **Claim Definition** related to received **Claim Schema** by calling ``anoncreds.issuer_create_and_store_claim_def``that returns generated public Claim Definition. 
+   Private Claim Definition part for this **Claim Schema** will be stored in the wallet too, but it is impossible to read it directly. 
+1. **Trust Anchor** sends corresponded ClaimDef transaction to the Ledger by calling consistently ``ledger.build_claim_def_txn`` to build ClaimDef request and ``ledger.sign_and_submit_request`` to send created request.
+
+Here is **Faber** creates and publishes Claim Definition for known **Transcript** Claim Schema to the Ledger:
+```python
+  (faber_issuer_did, faber_issuer_key) = await did.create_and_store_my_did(faber_wallet, ""{}"")
+  await send_nym(pool_handle, faber_wallet, faber_did, faber_issuer_did, faber_issuer_key, None)
+    
+  get_schema_data = json.dumps({
+      'name': 'Transcript',
+      'version': '1.2'
+  })
+  get_schema_request = await ledger.build_get_schema_request(faber_issuer_did, government_issuer_did, get_schema_data)
+  get_schema_response = await ledger.submit_request(pool_handle, get_schema_request)
+  transcript_schema = json.loads(get_schema_response)['result']
+    
+  faber_transcript_claim_def_json = \
+      await anoncreds.issuer_create_and_store_claim_def(faber_wallet, faber_issuer_did, json.dumps(transcript_schema), 'CL', False)
+  faber_transcript_claim_def = json.loads(faber_transcript_claim_def_json)
+    
+  claim_def_request = \
+      await ledger.build_claim_def_txn(faber_issuer_did, faber_transcript_claim_def['ref'], 
+                                       faber_transcript_claim_def['signature_type'], json.faber_transcript_claim_def(claim_def['data']))
+  await ledger.sign_and_submit_request(pool_handle, faber_wallet, faber_issuer_did, claim_def_request)
+```
+The same way **Acme** creates and publishes Claim Definition for known **Job-Certificate** Claim Schema to the Ledger.
+```python
+  (acme_issuer_did, acme_issuer_key) = await did.create_and_store_my_did(acme_wallet, ""{}"")
+  await send_nym(pool_handle, acme_wallet, acme_did, acme_issuer_did, acme_issuer_key, None)
+    
+  get_schema_data = json.dumps({
+      'name': 'Job-Certificate',
+      'version': '0.2'
+  })
+  get_schema_request = await ledger.build_get_schema_request(acme_issuer_did, government_issuer_did, get_schema_data)
+  get_schema_response = await ledger.submit_request(pool_handle, get_schema_request)
+  job_certificate_schema = json.loads(get_schema_response)['result']
+    
+  acme_job_certificate_claim_def_json = \
+      await anoncreds.issuer_create_and_store_claim_def(acme_wallet, acme_issuer_did, json.dumps(job_certificate_schema), 'CL', False)
+  acme_transcript_claim_def = json.loads(acme_job_certificate_claim_def_json)
+    
+  claim_def_request = \
+      await ledger.build_claim_def_txn(acme_issuer_did, acme_transcript_claim_def['ref'], 
+                                       acme_transcript_claim_def['signature_type'], acme_transcript_claim_def.dumps(claim_def['data']))
+  await ledger.sign_and_submit_request(pool_handle, acme_wallet, acme_issuer_did, claim_def_request)
+```
+
+At this point we have **Claim Definition** for **Job-Certificate** Claim Schema published by **Acme** and
+ **Claim Definition** for **Transcript** Claim Schema published by **Faber**. 
+
+## Alice Gets a Transcript
+
+A claim is a piece of information about an identity -- a name, an age, a credit score… It is information claimed to be true.
+In this case, the claim is named, ""Transcript"".
+
+Claims are offered by an issuer. 
+An issuer may be any identity owner known to the Ledger and any issuer may issue a claim about any identity owner it can identify.
+The usefulness and reliability of a claim are tied to the reputation of the issuer with respect to the claim at hand. 
+For Alice to self-issue a claim that she likes chocolate ice cream may be perfectly reasonable, but for her to self-issue a claim that she graduated from Faber College should not impress anyone. 
+
+As we mentioned in [Involving of Alice](#involving-of-alice) **Alice** graduate **Faber College**.
+After Alice had established connection with **Faber College** and had got Verinym, she got Claim Offer about the issuance of **Transcript** Claim.",,2018-02-07 12:43:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/165974021,https://github.com/hyperledger/indy-sdk/pull/508#discussion_r165974021,vimmerru
https://github.com/hyperledger/indy-sdk/pull/508,https://github.com/hyperledger/indy-sdk/pull/508,Alice don't need Verinym. Pairwise DIDs are enough.,d0bc3c0d7a57728aabea323541825d9e9409d558,2018-02-05 13:42:52,165974206,"@@ -102,17 +122,22 @@ A->AW: Create and store ""Alice Faber Pairwise"" DID
 A->F: Anoncrypted connection response with ""Alice Faber Pairwise"" DID, verkey and nonce
 F->L: Send Nym for ""Alice Faber Pairwise"" DID
 
-== Getting HE Diploma with Faber - Getting HE Diploma Claim ==
-F->A: Send authcrypted ""Alice Faber HE Diploma"" Claim Offer
-A->AW: Store ""Alice Faber HE Diploma"" Claim Offer
+== Getting Transcript with Faber - Alice getting Verinym  ==",,2018-02-07 12:43:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/165974206,https://github.com/hyperledger/indy-sdk/pull/508#discussion_r165974206,vimmerru
https://github.com/hyperledger/indy-sdk/pull/508,https://github.com/hyperledger/indy-sdk/pull/508,I suggest to remove this info as in current design of Revocation we are intended to break these rules.,d0bc3c0d7a57728aabea323541825d9e9409d558,2018-02-05 13:44:41,165974671,"@@ -0,0 +1,804 @@
+# Getting Started with Libindy
+
+## A Developer Guide for an Implementation of the Libindy Code Base
+
+![logo](https://raw.githubusercontent.com/hyperledger/indy-node/master/collateral/logos/indy-logo.png)
+
+* [Getting Started with Indy](#getting-started-with-indy)
+  * [What Indy Is, and Why it Matters](#what-indy-is-and-why-it-matters)
+  * [What We'll Cover](#what-well-cover)
+  * [Involving of Alice](#involving-of-alice)
+  * [Infrastructure preparation](#infrastructure-preparation)
+      * [Getting Trust Anchor credentials for Faber, Acme, Thrift and Government](#getting-trust-anchor-credentials-for-faber-acme-thrift-and-government)
+      * [Connecting to Indy nodes pool](#connecting-to-indy-nodes-pool)
+      * [Getting the ownership for Stewards's Verinym](#getting-the-ownership-for-stewardss-verinym)
+      * [Onboarding Faber, Acme, Thrift and Government by Steward](#onboarding-faber-acme-thrift-and-government-by-steward)
+        * [Connection establishment](#connection-establishment)
+        * [Getting Verinym](#getting-verinym)
+      * [Claim Schemas Setup](#claim-schemas-setup)
+      * [Claim Definition Setup](#claim-definition-setup)
+  * [Alice Gets a Transcript](#alice-gets-a-transcript)
+  * [Apply for a Job](#apply-for-a-job)
+  * [Apply for a Loan](#apply-for-a-loan)
+  * [Explore the Code](#explore-the-code)
+
+## What Indy is, and Why it Matters
+
+The Indy code base (Indy) is a software ecosystem for private, secure, and powerful identity. Once it is implemented, it puts people — not the organizations that traditionally centralize identity — in charge of decisions about their own privacy and disclosure. This enables all kinds of rich innovation: connection contracts, revocation, novel payment workflows, asset and document management features, creative forms of escrow, curated reputation, integrations with other cool technologies, and so on.
+
+Indy uses open-source, distributed ledger technology. These ledgers are a form of database that is provided cooperatively by a pool of participants, instead of by a giant database with a central admin. Data lives redundantly in many places, and it accrues in transactions orchestrated by many machines. Strong, industry-standard cryptography protects it. Best practices in key management and cybersecurity pervade its design. The result is a reliable, public source of truth under no single entity’s control, robust to system failure, resilient to hacking, and highly immune to subversion by hostile entities.
+
+If the cryptography and blockchain details feel mysterious, fear not: this guide will help introduce you to key concepts within Indy. You’re starting in the right place.
+
+## What We’ll Cover
+
+Our goal is to introduce you to many of the concepts of Indy, and give you some idea of what happens behind the scenes to make it all work.
+
+We are going to frame the exploration with a story. Alice, a graduate of the fictional Faber College, wants to apply for a job at the fictional company Acme Corp. As soon as she has the job, she wants to apply for a loan in Thrift Bank so she can buy a car. She would like to use her college transcript as proof of her education on the job application; once hired, Alice would like to use the fact of employment as evidence of her creditworthiness for the loan.
+
+The sorts of identity and trust interactions required to pull this off are messy in the world today; they are slow, they violate privacy, and they are susceptible to fraud. We’ll show you how Indy is a quantum leap forward.
+
+Ready?
+
+## Involving of Alice
+
+As a graduate of Faber College, Alice receives an alumni newsletter where she learns that her alma mater is offering digital transcripts. She logs in to the college alumni website and requests her transcript by clicking **Get Transcript**.  (Other ways to initiate this request might include scanning a QR code, downloading a transcript package from a published URL, etc.)
+
+Alice doesn’t realize it yet, but in order to use this digital transcript she will need a new type of identity -- not the traditional identity that Faber College has built for her in its on-campus database, but a new and portable one that belongs to her, independent of all past and future relationships, that nobody can revoke or co-opt or correlate without her permission. This is a **_self-sovereign identity_** and it is the core feature of the ledger.
+
+In normal contexts, managing a self-sovereign identity will require a tool such as a desktop or mobile application. It might be a standalone app, or it might leverage a third party service provider that the ledger calls an **agency**. For example, leaders in this technology such as the Sovrin Foundation and companies like Evernym, publish reference versions of such tools. Faber College will have studied these requirements and will recommend a **_Indy app_** to Alice if she doesn’t already have one; this app will install as part of the workflow from the **Get Transcript** button.
+
+When Alice clicks **Get Transcript**, she will download a file that holds an Indy **connection request**. This connection request file, having a .indy extension and associated with her Indy app, will allow her to establish a secure channel of communication with another party in the ledger ecosystem -- Faber College.
+
+So when Alice clicks **Get Transcript**, she will normally end up installing an app (if needed), launching it, and then being asked by the app whether she wants to accept a request to connect with Faber.
+
+For this guide, however, we’ll be using a **Indy SDK API** instead of an app, so we can see what happens behind the scenes. We will pretend to be a particularly curious and technically adventurous Alice…
+
+## Infrastructure preparation
+
+### Getting Trust Anchor credentials for Faber, Acme, Thrift and Government
+
+Faber College and another actors have done some prep steps to offer this service to Alice. To understand these steps let's start with some definitions.
+
+The ledger is intended to store **Identity Records** that describe a **Ledger Entity**. Identity Records are public data and may include Public Keys, Service Endpoints, Claim Schemas, Claim Definitions. Every **Identity Record** is associated with exactly one **DID** (Decentralized Identifier) that is globally unique and resolvable (via a ledger) without requiring any centralized resolution authority. To maintain privacy each **Identity Owner** can own multiple DIDs.
+
+In this tutorial we will use 2 type of DIDs. The first one is **Verinym**. **Verinym** is associated with the **Legal Identity** of the **Identity Owner**. For example, all parties should be able to verify that some DID is used by Government to publish schemas for some document type. The second type is **Pseudonym** - a **Blinded Identifier** used to maintain privacy in the context on an ongoing digital relationship (**Connection**). if Pseudonym is used to maintain only one digital relationship we will call it Pairwise-Unique Identifier. We will use Pairwise-Unique Identifiers to maintain secure connections between actors in this tutorial.
+
+Creation of DID known to the Ledger is **Identity Record** itself (NYM transaction). NYM transaction can be used for creation of new DIDs that ledger known, setting and rotation of verification key, setting and changing of roles. The most important fields of this transaction are dest (target DID), role (role of a user NYM record being created for) and verkey (target verification key). See [Requests](https://github.com/hyperledger/indy-node/blob/master/docs/requests.md) to get more information about supported ledger transactions.
+
+Published with DID verification key allows to verify that someone owns this DID as he is only one who known corresponded sign key and any DID-related operation require signing with this key.
+
+Our ledger is public permissioned and anyone who wants to publish DIDs need to get the role of **Trust Anchor** on the ledger. A **Trust Anchor** is a person or organization that the ledger already knows about, that is able to help bootstrap others. (It is *not* the same as what cybersecurity experts call a ""trusted third party""; think of it more like a facilitator). See [Roles](https://docs.google.com/spreadsheets/d/1TWXF7NtBjSOaUIBeIH77SyZnawfo91cJ_ns4TR-wsq4/edit#gid=0) to get more information about roles.
+
+On the first step Faber College, Acme Corp and Thrift Bank need to get the role of **Trust Anchor** on the ledger as they will need to create Verinyms and Pairwise-Unique Identifiers to provide the service to Alice. Becoming a **Trust Anchor** requires contacting a person or organization who already has **Trust Anchor** role on the ledger. In our empty test ledger we have only NYMs with **Steward** role, but all **Stewards** are automatically **Trust Anchors**.
+
+#### Connecting to Indy nodes pool
+
+We are ready to start writing the code that will cover full Alice's use case. Important note is that for demo purposes it will be single test that will contain the code intended to be executed on different agents. We will always point what Agent is intended to execute each code part. Also we will use different wallets to store DID and keys of different Agents. Let's start.
+
+First code block will contain the code of **Steward's** agent. To write and read ledger's transactions we need to make connection to Indy nodes pool. Libindy allows to work with different pools like Sovrin pool or local pool we started by ourself as part of this tutorial. To work with different pools libindy has concept of **Pool Configuration**. The list of nodes in the pool is also stored in the ledger as NODE transactions. Libindy allows to restore actual list of NODE transactions by few known transactions that we call genesis transactions. Each **Pool Configuration** are defined as pair of pool configuration name and pool configuration json. The most important field in pool configuration json is path to file with the list if genesis transactions. ``pool.create_pool_ledger_config`` call allows to create named pool configuration. After pool configuration is created we can connect to the nodes pool that this configuration describes by calling ``pool.open_pool_ledger``. This call returns pool handle that can be used to reference this opened connection in future libindy calls.
+
+```python
+  "" Steward Agent
+  pool_name = 'pool1'
+  pool_genesis_txn_path = get_pool_genesis_txn_path(pool_name)
+  pool_config = json.dumps({""genesis_txn"": str(pool_genesis_txn_path)})
+  await pool.create_pool_ledger_config(pool_name, pool_config)
+  pool_handle = await pool.open_pool_ledger(pool_name, None)
+```
+
+#### Getting the ownership for Stewards's Verinym
+
+On the next step **Steward's** agent should get the ownership for DID that has corresponded NYM transaction with **Steward** role on the ledger. The test ledger we use was pre-configured to store some known **Steward** NYMs. Also we know **seed** values for random number generator that were used to generate keys for this NYMs. These **seed** values allow us to restore sign keys for these DIDs on **Steward's** agent side and as result get DID ownership.
+
+Libindy has conception of the **Wallet**. Wallet is secure storage for crypto materials like DIDs, keys and etc... To store **Steward's** DID and corresponded signkey agent should create named wallet first by calling ``pool.create_wallet``. After this wallet can be opened by calling ``pool.open_wallet``. This call returns wallet handle that can be used to reference this opened wallet in future libindy calls.
+
+After wallet is opened we can create DID record in this wallet by calling ``did.create_and_store_my_did`` that returns generated DID and verkey part of generated key. Signkey part for this DID will be stored in the wallet too, but it is impossible to read it directly.
+
+```python
+  # Steward Agent
+  steward_wallet_name = 'sovrin_steward_wallet'
+  await wallet.create_wallet(pool_name, steward_wallet_name, None, None, None)
+  steward_wallet = await wallet.open_wallet(steward_wallet_name, None, None)
+
+  steward_did_info = {'seed': '000000000000000000000000Steward1'}
+  (steward_did, steward_key) = await did.create_and_store_my_did(steward_wallet, json.dumps(steward_did_info))
+```
+
+Please note that we provided only information about seed to ``did.create_and_store_my_did``, but no any information about Steward's DID. The reason is that by default DID's are generated as fist 16 bytes of verkey. For such DID's for operations that require both DID and verkey we can use verkey in abbreviated form. In this form verkey starts with a tilde '~' followed by 22 or 23 characters. The tilde indicates that the DID itself represents the first 16 bytes of the verkey and the string following the tilde represents the second 16 bytes of the verkey, both using base58Check encoding.
+
+#### Onboarding Faber, Acme, Thrift and Government by Steward
+
+On the next step Faber, Acme, Thrift and Government should establish **Connection** with Steward. 
+Each connection is actually a pair of Pairwise-Unique Identifiers (DIDs). 
+The one DID is owned by one connection party and second by another.
+Both parties are know both DIDs and understand what connection this pair describes.
+The relationship between them is not shareable with others; it is unique to those two parties in that each pairwise relationship uses different DIDs. 
+We call process of establish connection **Onboarding**. 
+In this tutorial we will describe the simple version of onboarding process. 
+In our case one party will be always Trust Anchor. Real enterprise scenarios can use more complex version. 
+
+##### Connection establishment
+Let's look the process of connection establishment between **Steward** and **Faber College**.
+
+1. **Faber** and **Steward** contact in a some way to initiate onboarding process. 
+   It can be filling the form on web site or phone call.
+1. **Steward** creates new DID record in wallet by calling ``did.create_and_store_my_did`` that he will use for secure interactions with **Faber**.
+1. **Steward** sends corresponding `NYM` transaction to the Ledger by calling consistently ``ledger.build_nym_request`` to build NYM request and ``ledger.sign_and_submit_request`` to send the created request.
+1. **Steward** creates connection request which contains created `DID` and `Nonce`. 
+   This nonce is just a big random number generated to track the unique connection request. 
+   A nonce is a random arbitrary number that can only be used one time.  
+   When a connection request is accepted, the invitee digitally signs the nonce such that the inviter can match the response with a prior request.
+1. **Steward** sends connection request to **Faber**.
+1. **Faber** accepts connection request from **Steward**.
+1. **Faber** creates wallet if it does not exist yet.
+1. **Faber** creates new DID record in his wallet by calling ``did.create_and_store_my_did`` that he will use for secure interactions with **Steward**.
+1. **Faber** creates connection response which contains created `DID`, `Verkey` and `Nonce` from received connection request.
+1. **Faber** asks ledger for Verification key of **Steward's** DID by calling ``did.key_for_did``.
+1. **Faber** anonymous encrypts connection response by calling ``crypto.anon_crypt`` with **Steward** Verkey.
+   Anonymous-encryption schema is designed for sending of messages to a Recipient given its public key. 
+   Only the Recipient can decrypt these messages, using its private key. 
+   While the Recipient can verify the integrity of the message, it cannot verify the identity of the Sender.
+1. **Faber** sends anonymous encrypted connection response to **Steward**.
+1. **Steward** anonymous decrypts connection response by calling ``crypto.anon_decrypt``.
+1. **Steward** authenticates **Faber** by comparision of Nonce.
+1. **Steward** sends `NYM` transaction for **Faber's** DID to the Ledger. 
+Please note that despite Steward is sender of this transaction the owner of DID will be Faber as it uses Verkey provided by Faber.
+
+```python
+  (steward_faber_did, steward_faber_key) = await did.create_and_store_my_did(steward_wallet, ""{}"")
+  nym_request = await ledger.build_nym_request(steward_did, steward_faber_did, steward_faber_key, None, role)
+  await ledger.sign_and_submit_request(pool_handle, steward_wallet, steward_did, nym_request)
+   
+  connection_request = {
+      'did': steward_faber_did,
+      'nonce': 123456789
+  }
+    
+  await wallet.create_wallet(pool_name, 'faber_wallet', None, None, None)
+  faber_wallet = await wallet.open_wallet('faber_wallet', None, None)
+    
+  (faber_steward_did, faber_steward_key) = await did.create_and_store_my_did(faber_wallet, ""{}"")
+  steward_faber_verkey = await did.key_for_did(pool_handle, faber_wallet, connection_request['did'])
+    
+  connection_response = json.dumps({
+      'did': faber_steward_did,
+      'verkey': faber_steward_key,
+      'nonce': connection_request['nonce']
+  })
+  anoncrypted_connection_response = await crypto.anon_crypt(steward_faber_verkey, connection_response.encode('utf-8'))
+    
+  decrypted_connection_response = \
+      (await crypto.anon_decrypt(steward_wallet, steward_faber_key, anoncrypted_connection_response)).decode(""utf-8"")
+      
+  assert connection_request['nonce'] == decrypted_connection_response['nonce']
+        
+  nym_request = await ledger.build_nym_request(steward_did, decrypted_connection_response['did'], decrypted_connection_response['verkey'], None, role)
+  await ledger.sign_and_submit_request(pool_handle, steward_wallet, steward_did, nym_request)
+```
+
+At this point **Faber** is connected to **Steward** and can interact in a secure way and can trust the response from **Steward** because 
+(1) he connects to the current endpoint, 
+(2) no replay - attack is possible, due to her random challenge, 
+(3) he knows the verification key used to verify **Steward** digital signature is the correct one because he just confirmed it on the ledger.
+
+Note: **Every Side** must not use same DID's to establish other relationships.
+By having independent pairwise relationships, we reduces the ability for others to correlate your activities across multiple interactions.
+
+##### Getting Verinym
+
+It is important to understand that created early **Faber** DID is not, in and of itself, the same thing as self-sovereign identity.
+This DID must be used only for secure interaction with **Steward**.
+After the connection is established **Faber** must create new DID record that he will use as Verinym in the Ledger.
+1. **Faber** creates new DID in his wallet by calling ``did.create_and_store_my_did``.
+1. **Faber** prepares the message that will contain created DID and Verkey.
+1. **Faber** authenticated encrypts the message by calling ``crypto.auth_crypt`` using Verkeys created for secure communication with **Steward**. 
+   Authenticated-encryption schema is designed for sending of a confidential message specifically for Recipient, using Sender's public key.
+   Using Recipient's public key, Sender can compute a shared secret key. Using Sender's public key and his secret key, Recipient can compute the exact same shared secret key.
+   That shared secret key can be used to verify that the encrypted message was not tampered with, before eventually decrypting it.
+1. **Faber** sends encrypted message to **Steward**.
+1. **Steward** decrypts received message by calling ``crypto.auth_decrypt``.
+1. **Steward** asks ledger for Verification key of **Faber's** DID by calling ``did.key_for_did``.
+1. **Steward** authenticates **Faber** by comparision of Message Sender Verkey and **Faber** Verkey received from the Ledger.
+1. **Steward** sends corresponded NYM transaction to the Ledger with `TRUST ANCHOR` role.
+Please note that despite Steward is sender of this transaction the owner of DID will be Faber as it uses Verkey provided by Faber.
+
+```python
+  (faber_did, faber_key) = await did.create_and_store_my_did(faber_wallet, ""{}"")
+    
+  faber_did_info_json = json.dumps({
+      'did': faber_did,
+      'verkey': faber_key
+  })
+  authcrypted_faber_did_info_json = \
+      await crypto.auth_crypt(faber_wallet, faber_steward_key, steward_faber_key, faber_did_info_json.encode('utf-8'))
+        
+  sender_verkey, authdecrypted_faber_did_info_json = \
+      await crypto.auth_decrypt(steward_handle, steward_faber_key, authcrypted_faber_did_info_json)
+  faber_did_info = json.loads(authdecrypted_faber_did_info_json)
+  
+  assert sender_verkey == await did.key_for_did(pool_handle, from_wallet, faber_did_info['did'])
+        
+  nym_request = await ledger.build_nym_request(steward_did, decrypted_faber_did_info_json['did'],
+                                               decrypted_faber_did_info_json['verkey'], None, 'TRUST_ANCHOR')
+  await ledger.sign_and_submit_request(pool_handle, steward_wallet, steward_did, nym_request)
+```
+At this point **Faber** has DID related to his identity in the Ledger. 
+
+**Acme**, **Thrift Bank**, and **Government** must pass the same Onboarding process connection establishment with **Steward**.
+
+#### Claim Schemas Setup
+**Claim Schema** - is the base semantic structure that describes the list of attributes which one particular Claim can contain. 
+
+Note: It's not possible to update existing Schema. So, if the Schema needs to be evolved, a new Schema with a new version or name needs to be created.
+
+**Claim Schema** can be created and saved in the Ledger by any **Trust Anchor** by following the next steps:
+1. **Trust Anchor** optionally creates new DID record in his wallet and sends corresponded NYM transaction to the Ledger.
+1. **Trust Anchor** prepares **Claim Schema**.
+1. **Trust Anchor** sends corresponded Schema transaction to the Ledger by calling consistently ``ledger.build_schema_request`` to build Schema request and ``ledger.sign_and_submit_request`` to send created request.
+
+Here is **Government** creates and publishes **Transcript** Claim Schema to the Ledger:
+```python
+  (government_issuer_did, government_issuer_key) = await did.create_and_store_my_did(government_wallet, ""{}"")
+  nym_request = await ledger.build_nym_request(government_did, government_issuer_did, government_issuer_key, None, None)
+  await ledger.sign_and_submit_request(pool_handle, government_handle, government_did, nym_request)
+        
+  transcript_schema = {
+      'name': 'Transcript',
+      'version': '1.2',
+      'attr_names': ['first_name', 'last_name', 'degree', 'status', 'year', 'average', 'ssn']
+  }
+  schema_request = await ledger.build_schema_request(government_issuer_did, json.dumps(transcript_schema))
+  await ledger.sign_and_submit_request(pool_handle, government_wallet, government_issuer_did, schema_request)
+```
+
+The same way **Government** creates and publishes **Job-Certificate** Claim Schema to the Ledger:
+```python    
+  job_certificate_schema = {
+      'name': 'Job-Certificate',
+      'version': '0.2',
+      'attr_names': ['first_name', 'last_name', 'salary', 'employee_status', 'experience']
+  }
+  schema_request = await ledger.build_schema_request(government_issuer_did, json.dumps(to the Ledger))
+  await ledger.sign_and_submit_request(pool_handle, government_wallet, government_issuer_did, schema_request)
+```
+
+At this point we have **Transcript** and **Job-Certificate** Claim Schemas published by **Government** to the Ledger.
+
+#### Claim Definition Setup
+Claim Definition is similar to keys that Issuer use for signing of Claims satisfied specific Claim Schema. 
+
+Note: One Issuer DID can create just one Claim Definition for the specific Claim Schema, but different Issuer DIDs can create numerous Claim Definitions for the same Claim Schema.",,2018-02-07 12:43:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/165974671,https://github.com/hyperledger/indy-sdk/pull/508#discussion_r165974671,vimmerru
https://github.com/hyperledger/indy-sdk/pull/494,https://github.com/hyperledger/indy-sdk/pull/494,Can we stay InvalidState error for some unexpected errors and catch specific error from rusqlciphter::Error as Security error?,0e962894f40a687d1f65fc9ccd5beb36391828e9,2018-01-19 09:27:30,162572501,"@@ -280,7 +289,7 @@ impl From<rusqlcipher::Error> for WalletError {
     fn from(err: rusqlcipher::Error) -> WalletError {
         match err {
             rusqlcipher::Error::QueryReturnedNoRows => WalletError::NotFound(format!(""Wallet record is not found: {}"", err.description())),
-            _ => WalletError::CommonError(CommonError::InvalidState(format!(""Unexpected SQLite error: {}"", err.description())))
+            _ => WalletError::SecurityError(format!(""Unexpected SQLite error: {}"", err.description()))",,2018-01-26 10:11:23,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/162572501,https://github.com/hyperledger/indy-sdk/pull/494#discussion_r162572501,jovfer
https://github.com/hyperledger/indy-sdk/pull/494,https://github.com/hyperledger/indy-sdk/pull/494,"@vimmerru `rusqlcipher::ErrorCode::NotADatabase` is returned by `rusqlcipher` in case of incorrect key. May be we should introduce slightly different error code, like `WalletFailAccessToDatabase` ?",0e962894f40a687d1f65fc9ccd5beb36391828e9,2018-01-19 14:20:29,162633424,"@@ -83,6 +83,9 @@ pub enum ErrorCode
     // Trying to open wallet that was opened already
     WalletAlreadyOpenedError = 206,
 
+    // Attempt to open encrypted wallet with invalid credentials
+    WalletSecurityError = 207,",,2018-01-26 10:11:23,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/162633424,https://github.com/hyperledger/indy-sdk/pull/494#discussion_r162633424,jovfer
https://github.com/hyperledger/indy-sdk/pull/494,https://github.com/hyperledger/indy-sdk/pull/494,For this case we can't authenticate. I more like WalletSecurityError approach or WalletInvalidCredentials.,0e962894f40a687d1f65fc9ccd5beb36391828e9,2018-01-19 14:28:43,162635425,"@@ -83,6 +83,9 @@ pub enum ErrorCode
     // Trying to open wallet that was opened already
     WalletAlreadyOpenedError = 206,
 
+    // Attempt to open encrypted wallet with invalid credentials
+    WalletSecurityError = 207,",,2018-01-26 10:11:23,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/162635425,https://github.com/hyperledger/indy-sdk/pull/494#discussion_r162635425,vimmerru
https://github.com/hyperledger/indy-sdk/pull/494,https://github.com/hyperledger/indy-sdk/pull/494,But `rusqlcipher` doesn't provide ability to distinct security error and invalid database file,0e962894f40a687d1f65fc9ccd5beb36391828e9,2018-01-19 14:32:15,162636340,"@@ -83,6 +83,9 @@ pub enum ErrorCode
     // Trying to open wallet that was opened already
     WalletAlreadyOpenedError = 206,
 
+    // Attempt to open encrypted wallet with invalid credentials
+    WalletSecurityError = 207,",,2018-01-26 10:11:23,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/162636340,https://github.com/hyperledger/indy-sdk/pull/494#discussion_r162636340,jovfer
https://github.com/hyperledger/indy-sdk/pull/494,https://github.com/hyperledger/indy-sdk/pull/494,@Artemkaaas after discussion we suggest to use `WalletAccessFailed`,0e962894f40a687d1f65fc9ccd5beb36391828e9,2018-01-19 14:55:58,162642600,"@@ -83,6 +83,9 @@ pub enum ErrorCode
     // Trying to open wallet that was opened already
     WalletAlreadyOpenedError = 206,
 
+    // Attempt to open encrypted wallet with invalid credentials
+    WalletSecurityError = 207,",,2018-01-26 10:11:23,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/162642600,https://github.com/hyperledger/indy-sdk/pull/494#discussion_r162642600,jovfer
https://github.com/hyperledger/indy-sdk/pull/481,https://github.com/hyperledger/indy-sdk/pull/481,Do we need switching to ensurePreviousRequestApplied ?,a07b87527592d5a70e40a888b7fa1964c723f85f,2018-01-18 08:00:45,162270378,"@@ -32,6 +32,8 @@ public void testGetEndpointForDidWorksFromLedger() throws Exception {
 		String attribRequest = Ledger.buildAttribRequest(trusteeDid, trusteeDid, null, endpoint, null).get();
 		Ledger.signAndSubmitRequest(pool, wallet, trusteeDid, attribRequest).get();
 
+		Thread.sleep(5_000);",,2018-01-18 15:17:37,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/162270378,https://github.com/hyperledger/indy-sdk/pull/481#discussion_r162270378,vimmerru
https://github.com/hyperledger/indy-sdk/pull/481,https://github.com/hyperledger/indy-sdk/pull/481,Could we switch to ensurePreviousRequestApplied concept here too?,a07b87527592d5a70e40a888b7fa1964c723f85f,2018-01-18 08:02:46,162270708,"@@ -108,6 +115,38 @@ impl LedgerUtils {
         Ok(request_result_json)
     }
 
+    pub fn extract_timestamp_from_reply(reply: &str) -> Result<u64, &'static str> {",25,2018-01-18 15:17:37,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/162270708,https://github.com/hyperledger/indy-sdk/pull/481#discussion_r162270708,vimmerru
https://github.com/hyperledger/indy-sdk/pull/481,https://github.com/hyperledger/indy-sdk/pull/481,Only via one more GET_ATTRIB request to ledger and still without guaranties,a07b87527592d5a70e40a888b7fa1964c723f85f,2018-01-18 08:12:11,162272077,"@@ -32,6 +32,8 @@ public void testGetEndpointForDidWorksFromLedger() throws Exception {
 		String attribRequest = Ledger.buildAttribRequest(trusteeDid, trusteeDid, null, endpoint, null).get();
 		Ledger.signAndSubmitRequest(pool, wallet, trusteeDid, attribRequest).get();
 
+		Thread.sleep(5_000);",,2018-01-18 15:17:37,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/162272077,https://github.com/hyperledger/indy-sdk/pull/481#discussion_r162272077,jovfer
https://github.com/hyperledger/indy-sdk/pull/467,https://github.com/hyperledger/indy-sdk/pull/467,`set_opened_wallet` should be performed in one place: after final `res` will be determined.,aa75c3bbf451e35eebe72c43bc06eb27b6d89149,2018-01-11 11:28:37,160931454,"@@ -117,10 +117,15 @@ pub mod open_command {
                         set_opened_wallet(ctx, Some((handle, name.to_owned())));
                         Ok(println_succ!(""Wallet \""{}\"" has been opened"", name))
                     }
-                    Err(ErrorCode::CommonInvalidStructure) => Err(println_err!(""Invalid wallet config"")),
-                    Err(ErrorCode::WalletAlreadyOpenedError) => Err(println_err!(""Wallet \""{}\"" already opened"", name)),
-                    Err(ErrorCode::CommonIOError) => Err(println_err!(""Wallet \""{}\"" not found or unavailable"", name)),
-                    Err(err) => Err(println_err!(""Indy SDK error occurred {:?}"", err)),
+                    Err(err) => {
+                        set_opened_wallet(ctx, None);",21,2018-01-11 12:23:30,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/160931454,https://github.com/hyperledger/indy-sdk/pull/467#discussion_r160931454,jovfer
https://github.com/hyperledger/indy-sdk/pull/467,https://github.com/hyperledger/indy-sdk/pull/467,"UPD: one call above seems redundant, so we can leave 2 calls of `set_opened_wallet`",aa75c3bbf451e35eebe72c43bc06eb27b6d89149,2018-01-11 12:26:31,160943980,"@@ -117,10 +117,15 @@ pub mod open_command {
                         set_opened_wallet(ctx, Some((handle, name.to_owned())));
                         Ok(println_succ!(""Wallet \""{}\"" has been opened"", name))
                     }
-                    Err(ErrorCode::CommonInvalidStructure) => Err(println_err!(""Invalid wallet config"")),
-                    Err(ErrorCode::WalletAlreadyOpenedError) => Err(println_err!(""Wallet \""{}\"" already opened"", name)),
-                    Err(ErrorCode::CommonIOError) => Err(println_err!(""Wallet \""{}\"" not found or unavailable"", name)),
-                    Err(err) => Err(println_err!(""Indy SDK error occurred {:?}"", err)),
+                    Err(err) => {
+                        set_opened_wallet(ctx, None);",21,2018-01-11 12:26:49,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/160943980,https://github.com/hyperledger/indy-sdk/pull/467#discussion_r160943980,jovfer
https://github.com/hyperledger/indy-sdk/pull/458,https://github.com/hyperledger/indy-sdk/pull/458,Need to get Claim Def of Faber here,29d78e8125b9197676937e765e831c8df6507354,2017-12-28 16:07:08,158964245,"@@ -0,0 +1,170 @@
+@startuml
+
+box ""Alice"" #LightBlue
+actor ""Agent"" as A
+participant ""Wallet"" as AW
+endbox
+
+box ""Faber College"" #LightYellow
+actor ""Agent"" as F
+participant ""Wallet"" as FW
+endbox
+
+box ""Acme Corp"" #LightBlue
+actor ""Agent"" as AC
+participant ""Wallet"" as ACW
+endbox
+
+box ""Thrift Bank"" #LightYellow
+actor ""Agent"" as T
+participant ""Wallet"" as TW
+endbox
+
+participant ""Ledger"" as L
+
+box ""Government"" #LightBlue
+actor ""Agent"" as G
+participant ""Wallet"" as GW
+endbox
+
+box ""Sovrin Steward"" #LightYellow
+actor ""Agent"" as S
+participant ""Wallet"" as SW
+endbox
+
+=== Getting Trust Anchor credentials for Faber, Acme, Thrift and Government  ==
+S->SW: Create ""Sovrin Steward"" wallet
+S->SW: Create and store ""Sovrin Steward"" DID from seed
+
+== Getting Trust Anchor credentials - Government Onboarding  ==
+S->SW: Create and store ""Sovrin Steward Government Pairwise"" DID
+S->L: Send Nym for ""Sovrin Steward Government Pairwise"" DID
+S->G: Connection request with ""Sovrin Steward Government Pairwise"" DID and nonce
+G->GW: Create ""Government"" wallet
+G->GW: Create and store ""Government Sovrin Steward Pairwise"" DID
+G->S: Anoncrypted connection response with ""Government Sovrin Steward Pairwise"" DID, verkey and nonce
+S->L: Send Nym for ""Government Sovrin Steward Pairwise"" DID with Trust Anchor Role
+
+== Getting Trust Anchor credentials - Faber Onboarding  ==
+S->SW: Create and store ""Sovrin Steward Faber Pairwise"" DID
+S->L: Send Nym for ""Sovrin Steward Faber Pairwise"" DID
+S->F: Connection request with ""Sovrin Steward Faber Pairwise"" DID and nonce
+F->FW: Create ""Faber"" wallet
+F->FW: Create and store ""Faber Sovrin Steward Pairwise"" DID
+F->S: Anoncrypted connection response with ""Faber Sovrin Steward Pairwise"" DID, verkey and nonce
+S->L: Send Nym for ""Faber Sovrin Steward Pairwise"" DID with Trust Anchor Role
+
+== Getting Trust Anchor credentials - Acme Onboarding  ==
+S->SW: Create and store ""Sovrin Steward Acme Pairwise"" DID
+S->L: Send Nym for ""Sovrin Steward Acme Pairwise"" DID
+S->AC: Connection request with ""Sovrin Steward Acme Pairwise"" DID and nonce
+AC->ACW: Create ""Acme"" wallet
+AC->ACW: Create and store ""Acme Sovrin Steward Pairwise"" DID
+AC->S: Anoncrypted connection response with ""Acme Sovrin Steward Pairwise"" DID, verkey and nonce
+S->L: Send Nym for ""Acme Sovrin Steward Pairwise"" DID with Trust Anchor Role
+
+== Getting Trust Anchor credentials - Thrift Onboarding  ==
+S->SW: Create and store ""Sovrin Steward Thrift Pairwise"" DID
+S->L: Send Nym for ""Sovrin Steward Thrift Pairwise"" DID
+S->T: Connection request with ""Sovrin Steward Thrift Pairwise"" DID and nonce
+T->TW: Create ""Thrift"" wallet
+T->TW: Create and store ""Thrift Sovrin Steward Pairwise"" DID
+T->S: Anoncrypted connection response with ""Thrift Sovrin Steward Pairwise"" DID, verkey and nonce
+S->L: Send Nym for ""Thrift Sovrin Steward Pairwise"" DID with Trust Anchor Role
+
+=== Claim Schemas Setup ==
+G->GW: Create and store ""Government Schema Issuer"" DID
+G->L: Send Nym for ""Government Schema Issuer"" DID
+G->L: Send Schema for ""Employment History"" Schema
+G->L: Send Schema for ""HE Diploma"" Schema
+
+=== Faber Claim Definition Setup ==
+F->FW: Create and store ""Faber Claim Issuer"" DID
+F->L: Send Nym for ""Faber Claim Issuer"" DID
+F->L: Send GetSchema for ""HE Diploma"" Schema
+F->FW: Create and store ""Faber HE Diploma"" Claim Definition
+F->L: Send ClaimDef for ""Faber HE Diploma"" Claim Defition
+
+=== Acme Claim Definition Setup ==
+AC->ACW: Create and store ""Acme Claim Issuer"" DID
+AC->L: Send Nym for ""Acme Claim Issuer"" DID
+AC->L: Send GetSchema for ""Employment History"" Schema
+AC->ACW: Create and store ""Acme Employment History"" Claim Definition
+AC->L: Send ClaimDef for ""Acme Employment History"" Claim Definition
+
+=== Getting HE Diploma with Faber ==
+== Getting HE Diploma with Faber - Onboarding ==
+F->FW: Create and store ""Faber Alice Pairwise"" DID
+F->L: Send Nym for ""Faber Alice Pairwise"" DID
+F->A: Connection request with ""Faber Alice Pairwise"" DID and nonce
+A->AW: Create ""Alice"" wallet
+A->AW: Create and store ""Alice Faber Pairwise"" DID
+A->F: Anoncrypted connection response with ""Alice Faber Pairwise"" DID, verkey and nonce
+F->L: Send Nym for ""Alice Faber Pairwise"" DID
+
+== Getting HE Diploma with Faber - Getting HE Diploma Claim ==
+F->A: Send authcrypted ""Alice Faber HE Diploma"" Claim Offer
+A->AW: Store ""Alice Faber HE Diploma"" Claim Offer
+A->AW: Create and store ""Alice"" Master Secret
+A->L: Send GetClaimDef for ""Faber HE Diploma"" Claim Definition
+A->AW: Create and store ""Alice Faber HE Diploma"" Claim Request
+A->F: Send authcrypted ""Alice Faber HE Diploma"" Claim Request
+F->F: Create ""Alice Faber HE Diploma"" Claim
+F->A: Send authcrypted ""Alice Faber HE Diploma"" Claim
+A->AW: Store ""Alice Faber HE Diploma"" Claim
+
+=== Apply for the job with Acme ==
+== Apply for the job with Acme - Onboarding ==
+AC->ACW: Create and store ""Acme Alice Pairwise"" DID
+AC->L: Send Nym for ""Acme Alice Pairwise"" DID
+AC->A: Connection request with ""Acme Alice Pairwise"" DID and nonce
+A->AW: Create and store ""Alice Acme Pairwise"" DID
+A->AC: Anoncrypted connection response with ""Alice Acme Pairwise"" DID, verkey and nonce
+AC->L: Send Nym for ""Alice Acme Pairwise"" DID
+
+== Apply for the job with Acme - HE Diploma proving ==
+AC->A: Send authcrypted ""HE Diploma"" Proof Request
+A->AW: Get claims for ""HE Diploma"" Proof Request
+AW->A: ""Alice Faber HE Diploma"" Claim
+A->A: Create ""Alice HE Diploma"" Proof
+A->AC: Send ""Alice HE Diploma"" Proof
+AC->L: Send GetSchema for ""HE Diploma"" Schema",131,2017-12-28 16:16:24,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158964245,https://github.com/hyperledger/indy-sdk/pull/458#discussion_r158964245,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/458,https://github.com/hyperledger/indy-sdk/pull/458,Looks like some copy-paste,29d78e8125b9197676937e765e831c8df6507354,2017-12-28 16:09:09,158964527,"@@ -0,0 +1,170 @@
+@startuml
+
+box ""Alice"" #LightBlue
+actor ""Agent"" as A
+participant ""Wallet"" as AW
+endbox
+
+box ""Faber College"" #LightYellow
+actor ""Agent"" as F
+participant ""Wallet"" as FW
+endbox
+
+box ""Acme Corp"" #LightBlue
+actor ""Agent"" as AC
+participant ""Wallet"" as ACW
+endbox
+
+box ""Thrift Bank"" #LightYellow
+actor ""Agent"" as T
+participant ""Wallet"" as TW
+endbox
+
+participant ""Ledger"" as L
+
+box ""Government"" #LightBlue
+actor ""Agent"" as G
+participant ""Wallet"" as GW
+endbox
+
+box ""Sovrin Steward"" #LightYellow
+actor ""Agent"" as S
+participant ""Wallet"" as SW
+endbox
+
+=== Getting Trust Anchor credentials for Faber, Acme, Thrift and Government  ==
+S->SW: Create ""Sovrin Steward"" wallet
+S->SW: Create and store ""Sovrin Steward"" DID from seed
+
+== Getting Trust Anchor credentials - Government Onboarding  ==
+S->SW: Create and store ""Sovrin Steward Government Pairwise"" DID
+S->L: Send Nym for ""Sovrin Steward Government Pairwise"" DID
+S->G: Connection request with ""Sovrin Steward Government Pairwise"" DID and nonce
+G->GW: Create ""Government"" wallet
+G->GW: Create and store ""Government Sovrin Steward Pairwise"" DID
+G->S: Anoncrypted connection response with ""Government Sovrin Steward Pairwise"" DID, verkey and nonce
+S->L: Send Nym for ""Government Sovrin Steward Pairwise"" DID with Trust Anchor Role
+
+== Getting Trust Anchor credentials - Faber Onboarding  ==
+S->SW: Create and store ""Sovrin Steward Faber Pairwise"" DID
+S->L: Send Nym for ""Sovrin Steward Faber Pairwise"" DID
+S->F: Connection request with ""Sovrin Steward Faber Pairwise"" DID and nonce
+F->FW: Create ""Faber"" wallet
+F->FW: Create and store ""Faber Sovrin Steward Pairwise"" DID
+F->S: Anoncrypted connection response with ""Faber Sovrin Steward Pairwise"" DID, verkey and nonce
+S->L: Send Nym for ""Faber Sovrin Steward Pairwise"" DID with Trust Anchor Role
+
+== Getting Trust Anchor credentials - Acme Onboarding  ==
+S->SW: Create and store ""Sovrin Steward Acme Pairwise"" DID
+S->L: Send Nym for ""Sovrin Steward Acme Pairwise"" DID
+S->AC: Connection request with ""Sovrin Steward Acme Pairwise"" DID and nonce
+AC->ACW: Create ""Acme"" wallet
+AC->ACW: Create and store ""Acme Sovrin Steward Pairwise"" DID
+AC->S: Anoncrypted connection response with ""Acme Sovrin Steward Pairwise"" DID, verkey and nonce
+S->L: Send Nym for ""Acme Sovrin Steward Pairwise"" DID with Trust Anchor Role
+
+== Getting Trust Anchor credentials - Thrift Onboarding  ==
+S->SW: Create and store ""Sovrin Steward Thrift Pairwise"" DID
+S->L: Send Nym for ""Sovrin Steward Thrift Pairwise"" DID
+S->T: Connection request with ""Sovrin Steward Thrift Pairwise"" DID and nonce
+T->TW: Create ""Thrift"" wallet
+T->TW: Create and store ""Thrift Sovrin Steward Pairwise"" DID
+T->S: Anoncrypted connection response with ""Thrift Sovrin Steward Pairwise"" DID, verkey and nonce
+S->L: Send Nym for ""Thrift Sovrin Steward Pairwise"" DID with Trust Anchor Role
+
+=== Claim Schemas Setup ==
+G->GW: Create and store ""Government Schema Issuer"" DID
+G->L: Send Nym for ""Government Schema Issuer"" DID
+G->L: Send Schema for ""Employment History"" Schema
+G->L: Send Schema for ""HE Diploma"" Schema
+
+=== Faber Claim Definition Setup ==
+F->FW: Create and store ""Faber Claim Issuer"" DID
+F->L: Send Nym for ""Faber Claim Issuer"" DID
+F->L: Send GetSchema for ""HE Diploma"" Schema
+F->FW: Create and store ""Faber HE Diploma"" Claim Definition
+F->L: Send ClaimDef for ""Faber HE Diploma"" Claim Defition
+
+=== Acme Claim Definition Setup ==
+AC->ACW: Create and store ""Acme Claim Issuer"" DID
+AC->L: Send Nym for ""Acme Claim Issuer"" DID
+AC->L: Send GetSchema for ""Employment History"" Schema
+AC->ACW: Create and store ""Acme Employment History"" Claim Definition
+AC->L: Send ClaimDef for ""Acme Employment History"" Claim Definition
+
+=== Getting HE Diploma with Faber ==
+== Getting HE Diploma with Faber - Onboarding ==
+F->FW: Create and store ""Faber Alice Pairwise"" DID
+F->L: Send Nym for ""Faber Alice Pairwise"" DID
+F->A: Connection request with ""Faber Alice Pairwise"" DID and nonce
+A->AW: Create ""Alice"" wallet
+A->AW: Create and store ""Alice Faber Pairwise"" DID
+A->F: Anoncrypted connection response with ""Alice Faber Pairwise"" DID, verkey and nonce
+F->L: Send Nym for ""Alice Faber Pairwise"" DID
+
+== Getting HE Diploma with Faber - Getting HE Diploma Claim ==
+F->A: Send authcrypted ""Alice Faber HE Diploma"" Claim Offer
+A->AW: Store ""Alice Faber HE Diploma"" Claim Offer
+A->AW: Create and store ""Alice"" Master Secret
+A->L: Send GetClaimDef for ""Faber HE Diploma"" Claim Definition
+A->AW: Create and store ""Alice Faber HE Diploma"" Claim Request
+A->F: Send authcrypted ""Alice Faber HE Diploma"" Claim Request
+F->F: Create ""Alice Faber HE Diploma"" Claim
+F->A: Send authcrypted ""Alice Faber HE Diploma"" Claim
+A->AW: Store ""Alice Faber HE Diploma"" Claim
+
+=== Apply for the job with Acme ==
+== Apply for the job with Acme - Onboarding ==
+AC->ACW: Create and store ""Acme Alice Pairwise"" DID
+AC->L: Send Nym for ""Acme Alice Pairwise"" DID
+AC->A: Connection request with ""Acme Alice Pairwise"" DID and nonce
+A->AW: Create and store ""Alice Acme Pairwise"" DID
+A->AC: Anoncrypted connection response with ""Alice Acme Pairwise"" DID, verkey and nonce
+AC->L: Send Nym for ""Alice Acme Pairwise"" DID
+
+== Apply for the job with Acme - HE Diploma proving ==
+AC->A: Send authcrypted ""HE Diploma"" Proof Request
+A->AW: Get claims for ""HE Diploma"" Proof Request
+AW->A: ""Alice Faber HE Diploma"" Claim
+A->A: Create ""Alice HE Diploma"" Proof
+A->AC: Send ""Alice HE Diploma"" Proof
+AC->L: Send GetSchema for ""HE Diploma"" Schema
+AC->AC: Verify ""Alice HE Diploma"" Proof
+
+== Apply for the job with Acme - Getting Employment History Claim ==
+AC->A: Send authcrypted ""Alice Acme Employment History"" Claim Offer
+A->AW: Store ""Alice Acme Employment History"" Claim Offer
+A->L: Send GetClaimDef for ""Acme Employment History"" Claim Definition
+A->AW: Create and store ""Alice Acme Employment History"" Claim Request
+A->AC: Send authcrypted ""Alice Acme Employment History"" Claim Request
+AC->AC: Create ""Alice Acme Employment History"" Claim
+F->A: Send authcrypted ""Alice Acme Employment History"" Claim
+A->AW: Store ""Alice Acme Employment History"" Claim
+
+=== Apply for the loan with Thrift ==
+== Apply for the loan with Thrift - Onboarding ==
+A->AW: Create and store ""Alice Thrift Pairwise"" DID",,2017-12-28 16:16:24,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158964527,https://github.com/hyperledger/indy-sdk/pull/458#discussion_r158964527,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/458,https://github.com/hyperledger/indy-sdk/pull/458,Claim Defs (both Acme and Faber) are required as well,29d78e8125b9197676937e765e831c8df6507354,2017-12-28 16:09:55,158964655,"@@ -0,0 +1,170 @@
+@startuml
+
+box ""Alice"" #LightBlue
+actor ""Agent"" as A
+participant ""Wallet"" as AW
+endbox
+
+box ""Faber College"" #LightYellow
+actor ""Agent"" as F
+participant ""Wallet"" as FW
+endbox
+
+box ""Acme Corp"" #LightBlue
+actor ""Agent"" as AC
+participant ""Wallet"" as ACW
+endbox
+
+box ""Thrift Bank"" #LightYellow
+actor ""Agent"" as T
+participant ""Wallet"" as TW
+endbox
+
+participant ""Ledger"" as L
+
+box ""Government"" #LightBlue
+actor ""Agent"" as G
+participant ""Wallet"" as GW
+endbox
+
+box ""Sovrin Steward"" #LightYellow
+actor ""Agent"" as S
+participant ""Wallet"" as SW
+endbox
+
+=== Getting Trust Anchor credentials for Faber, Acme, Thrift and Government  ==
+S->SW: Create ""Sovrin Steward"" wallet
+S->SW: Create and store ""Sovrin Steward"" DID from seed
+
+== Getting Trust Anchor credentials - Government Onboarding  ==
+S->SW: Create and store ""Sovrin Steward Government Pairwise"" DID
+S->L: Send Nym for ""Sovrin Steward Government Pairwise"" DID
+S->G: Connection request with ""Sovrin Steward Government Pairwise"" DID and nonce
+G->GW: Create ""Government"" wallet
+G->GW: Create and store ""Government Sovrin Steward Pairwise"" DID
+G->S: Anoncrypted connection response with ""Government Sovrin Steward Pairwise"" DID, verkey and nonce
+S->L: Send Nym for ""Government Sovrin Steward Pairwise"" DID with Trust Anchor Role
+
+== Getting Trust Anchor credentials - Faber Onboarding  ==
+S->SW: Create and store ""Sovrin Steward Faber Pairwise"" DID
+S->L: Send Nym for ""Sovrin Steward Faber Pairwise"" DID
+S->F: Connection request with ""Sovrin Steward Faber Pairwise"" DID and nonce
+F->FW: Create ""Faber"" wallet
+F->FW: Create and store ""Faber Sovrin Steward Pairwise"" DID
+F->S: Anoncrypted connection response with ""Faber Sovrin Steward Pairwise"" DID, verkey and nonce
+S->L: Send Nym for ""Faber Sovrin Steward Pairwise"" DID with Trust Anchor Role
+
+== Getting Trust Anchor credentials - Acme Onboarding  ==
+S->SW: Create and store ""Sovrin Steward Acme Pairwise"" DID
+S->L: Send Nym for ""Sovrin Steward Acme Pairwise"" DID
+S->AC: Connection request with ""Sovrin Steward Acme Pairwise"" DID and nonce
+AC->ACW: Create ""Acme"" wallet
+AC->ACW: Create and store ""Acme Sovrin Steward Pairwise"" DID
+AC->S: Anoncrypted connection response with ""Acme Sovrin Steward Pairwise"" DID, verkey and nonce
+S->L: Send Nym for ""Acme Sovrin Steward Pairwise"" DID with Trust Anchor Role
+
+== Getting Trust Anchor credentials - Thrift Onboarding  ==
+S->SW: Create and store ""Sovrin Steward Thrift Pairwise"" DID
+S->L: Send Nym for ""Sovrin Steward Thrift Pairwise"" DID
+S->T: Connection request with ""Sovrin Steward Thrift Pairwise"" DID and nonce
+T->TW: Create ""Thrift"" wallet
+T->TW: Create and store ""Thrift Sovrin Steward Pairwise"" DID
+T->S: Anoncrypted connection response with ""Thrift Sovrin Steward Pairwise"" DID, verkey and nonce
+S->L: Send Nym for ""Thrift Sovrin Steward Pairwise"" DID with Trust Anchor Role
+
+=== Claim Schemas Setup ==
+G->GW: Create and store ""Government Schema Issuer"" DID
+G->L: Send Nym for ""Government Schema Issuer"" DID
+G->L: Send Schema for ""Employment History"" Schema
+G->L: Send Schema for ""HE Diploma"" Schema
+
+=== Faber Claim Definition Setup ==
+F->FW: Create and store ""Faber Claim Issuer"" DID
+F->L: Send Nym for ""Faber Claim Issuer"" DID
+F->L: Send GetSchema for ""HE Diploma"" Schema
+F->FW: Create and store ""Faber HE Diploma"" Claim Definition
+F->L: Send ClaimDef for ""Faber HE Diploma"" Claim Defition
+
+=== Acme Claim Definition Setup ==
+AC->ACW: Create and store ""Acme Claim Issuer"" DID
+AC->L: Send Nym for ""Acme Claim Issuer"" DID
+AC->L: Send GetSchema for ""Employment History"" Schema
+AC->ACW: Create and store ""Acme Employment History"" Claim Definition
+AC->L: Send ClaimDef for ""Acme Employment History"" Claim Definition
+
+=== Getting HE Diploma with Faber ==
+== Getting HE Diploma with Faber - Onboarding ==
+F->FW: Create and store ""Faber Alice Pairwise"" DID
+F->L: Send Nym for ""Faber Alice Pairwise"" DID
+F->A: Connection request with ""Faber Alice Pairwise"" DID and nonce
+A->AW: Create ""Alice"" wallet
+A->AW: Create and store ""Alice Faber Pairwise"" DID
+A->F: Anoncrypted connection response with ""Alice Faber Pairwise"" DID, verkey and nonce
+F->L: Send Nym for ""Alice Faber Pairwise"" DID
+
+== Getting HE Diploma with Faber - Getting HE Diploma Claim ==
+F->A: Send authcrypted ""Alice Faber HE Diploma"" Claim Offer
+A->AW: Store ""Alice Faber HE Diploma"" Claim Offer
+A->AW: Create and store ""Alice"" Master Secret
+A->L: Send GetClaimDef for ""Faber HE Diploma"" Claim Definition
+A->AW: Create and store ""Alice Faber HE Diploma"" Claim Request
+A->F: Send authcrypted ""Alice Faber HE Diploma"" Claim Request
+F->F: Create ""Alice Faber HE Diploma"" Claim
+F->A: Send authcrypted ""Alice Faber HE Diploma"" Claim
+A->AW: Store ""Alice Faber HE Diploma"" Claim
+
+=== Apply for the job with Acme ==
+== Apply for the job with Acme - Onboarding ==
+AC->ACW: Create and store ""Acme Alice Pairwise"" DID
+AC->L: Send Nym for ""Acme Alice Pairwise"" DID
+AC->A: Connection request with ""Acme Alice Pairwise"" DID and nonce
+A->AW: Create and store ""Alice Acme Pairwise"" DID
+A->AC: Anoncrypted connection response with ""Alice Acme Pairwise"" DID, verkey and nonce
+AC->L: Send Nym for ""Alice Acme Pairwise"" DID
+
+== Apply for the job with Acme - HE Diploma proving ==
+AC->A: Send authcrypted ""HE Diploma"" Proof Request
+A->AW: Get claims for ""HE Diploma"" Proof Request
+AW->A: ""Alice Faber HE Diploma"" Claim
+A->A: Create ""Alice HE Diploma"" Proof
+A->AC: Send ""Alice HE Diploma"" Proof
+AC->L: Send GetSchema for ""HE Diploma"" Schema
+AC->AC: Verify ""Alice HE Diploma"" Proof
+
+== Apply for the job with Acme - Getting Employment History Claim ==
+AC->A: Send authcrypted ""Alice Acme Employment History"" Claim Offer
+A->AW: Store ""Alice Acme Employment History"" Claim Offer
+A->L: Send GetClaimDef for ""Acme Employment History"" Claim Definition
+A->AW: Create and store ""Alice Acme Employment History"" Claim Request
+A->AC: Send authcrypted ""Alice Acme Employment History"" Claim Request
+AC->AC: Create ""Alice Acme Employment History"" Claim
+F->A: Send authcrypted ""Alice Acme Employment History"" Claim
+A->AW: Store ""Alice Acme Employment History"" Claim
+
+=== Apply for the loan with Thrift ==
+== Apply for the loan with Thrift - Onboarding ==
+A->AW: Create and store ""Alice Thrift Pairwise"" DID
+A->T: Send ""Alice Thrift Pairwise"" DID\nand corresponded verkey.
+T->TW: Create and store ""Thrift Alice Pairwise"" DID
+T->L: Send Nym for ""Alice Thrift Pairwise"" DID
+T->L: Send Nym for ""Acme Thrift Pairwise"" DID
+T->A: Send ""Thrift Alice Pairwise"" DID
+
+T->TW: Create and store ""Thrift Alice Pairwise"" DID
+T->L: Send Nym for ""Thrift Alice Pairwise"" DID
+T->A: Connection request with ""Thrift Alice Pairwise"" DID and nonce
+A->AW: Create and store ""Alice Thrift Pairwise"" DID
+A->T: Anoncrypted connection response with ""Alice Thrift Pairwise"" DID, verkey and nonce
+T->L: Send Nym for ""Alice Thrift Pairwise"" DID
+
+== Apply for the loan with Thrift - HE Diploma and Employment History proving  ==
+T->A: Send authcrypted ""HE Diploma and Employment History"" Proof Request
+A->AW: Get claims for ""HE Diplomaand Employment History"" Proof Request
+AW->A: ""Alice Faber HE Diploma and Alice Acme Employment History"" Claim
+A->A: Create ""Alice Faber HE Diploma and Alice Acme Employment History"" Proof
+A->T: Send ""Alice Faber HE Diploma and Alice Acme Employment History"" Proof
+T->L: Send GetSchema for ""HE Diploma"" Schema
+T->L: Send GetSchema for ""Employment History"" Schema",160,2017-12-28 16:16:24,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158964655,https://github.com/hyperledger/indy-sdk/pull/458#discussion_r158964655,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/455,https://github.com/hyperledger/indy-sdk/pull/455,Restore iOS error codes,af3fbff7ccf8005a25794fd413efe3a3347b09ce,2017-12-28 14:14:53,158948689,"@@ -83,18 +83,15 @@ typedef NS_ENUM(NSInteger, IndyErrorCode)
     
     // No concensus during ledger operation
     LedgerNoConsensusError = 303,
-    
-    // Attempt to send unknown or incomplete transaction message
-    LedgerInvalidTransaction = 304,
-    
+
     // Attempt to send transaction without the necessary privileges
-    LedgerSecurityError = 305,
+    LedgerSecurityError = 304,",,2017-12-29 05:01:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158948689,https://github.com/hyperledger/indy-sdk/pull/455#discussion_r158948689,jovfer
https://github.com/hyperledger/indy-sdk/pull/450,https://github.com/hyperledger/indy-sdk/pull/450,Why didn't we need it before?,ce8768741ef4a944ba6c15b1114dc4eb68dcd7f1,2017-12-26 14:24:36,158709869,"@@ -65,19 +63,18 @@ pub extern fn indy_issuer_create_and_store_claim_def(command_handle: i32,
 }
 
 /// Create a new revocation registry for the given claim definition.
-/// Stores it in a secure wallet identifying by the returned key.
+/// Stores it in a secure wallet.
 ///
 /// #Params
 /// wallet_handle: wallet handler (created by open_wallet).
 /// command_handle: command handle to map callback to user context.
 /// issuer_did: a DID of the issuer signing revoc_reg transaction to the Ledger
-/// schema_seq_no: seq no of a schema transaction in Ledger
+/// schema_json: schema as a json",28,2017-12-29 08:39:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158709869,https://github.com/hyperledger/indy-sdk/pull/450#discussion_r158709869,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/450,https://github.com/hyperledger/indy-sdk/pull/450,Why didn't we need it before?,ce8768741ef4a944ba6c15b1114dc4eb68dcd7f1,2017-12-26 14:24:55,158709892,"@@ -87,12 +84,13 @@ pub extern fn indy_issuer_create_and_store_claim_def(command_handle: i32,
 pub extern fn indy_issuer_create_and_store_revoc_reg(command_handle: i32,
                                                      wallet_handle: i32,
                                                      issuer_did: *const c_char,
-                                                     schema_seq_no: i32,
+                                                     schema_json: *const c_char,",44,2017-12-29 08:39:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158709892,https://github.com/hyperledger/indy-sdk/pull/450#discussion_r158709892,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/450,https://github.com/hyperledger/indy-sdk/pull/450,Why didn't we need it before?,ce8768741ef4a944ba6c15b1114dc4eb68dcd7f1,2017-12-26 14:47:10,158711485,"@@ -101,7 +99,7 @@ pub extern fn indy_issuer_create_and_store_revoc_reg(command_handle: i32,
                 IssuerCommand::CreateAndStoreRevocationRegistry(
                     wallet_handle,
                     issuer_did,
-                    schema_seq_no,
+                    schema_json,",59,2017-12-29 08:39:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158711485,https://github.com/hyperledger/indy-sdk/pull/450#discussion_r158711485,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/450,https://github.com/hyperledger/indy-sdk/pull/450,"it contains not schema_seq_no, but schema_key (triple)",ce8768741ef4a944ba6c15b1114dc4eb68dcd7f1,2017-12-26 14:47:49,158711527,"@@ -113,23 +111,24 @@ pub extern fn indy_issuer_create_and_store_revoc_reg(command_handle: i32,
     result_to_err_code!(result)
 }
 
-/// Signs a given claim for the given user by a given key (claim ef).
+/// Signs a given claim values for the given user by a given key (claim def).
 /// The corresponding claim definition and revocation registry must be already created
 /// an stored into the wallet.
 ///
 /// #Params
 /// wallet_handle: wallet handler (created by open_wallet).
 /// command_handle: command handle to map callback to user context.
 /// claim_req_json: a claim request with a blinded secret
-///     from the user (returned by prover_create_and_store_claim_req).
-///     Also contains schema_seq_no and issuer_did
+/// from the user (returned by prover_create_and_store_claim_req).
+/// Also contains schema_seq_no and issuer_did",,2017-12-29 08:39:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158711527,https://github.com/hyperledger/indy-sdk/pull/450#discussion_r158711527,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/450,https://github.com/hyperledger/indy-sdk/pull/450,Why do we need prover DID here?,ce8768741ef4a944ba6c15b1114dc4eb68dcd7f1,2017-12-26 14:48:06,158711542,"@@ -113,23 +111,24 @@ pub extern fn indy_issuer_create_and_store_revoc_reg(command_handle: i32,
     result_to_err_code!(result)
 }
 
-/// Signs a given claim for the given user by a given key (claim ef).
+/// Signs a given claim values for the given user by a given key (claim def).
 /// The corresponding claim definition and revocation registry must be already created
 /// an stored into the wallet.
 ///
 /// #Params
 /// wallet_handle: wallet handler (created by open_wallet).
 /// command_handle: command handle to map callback to user context.
 /// claim_req_json: a claim request with a blinded secret
-///     from the user (returned by prover_create_and_store_claim_req).
-///     Also contains schema_seq_no and issuer_did
+/// from the user (returned by prover_create_and_store_claim_req).
+/// Also contains schema_seq_no and issuer_did
 ///     Example:
 ///     {
 ///      ""blinded_ms"" : <blinded_master_secret>,
-///      ""schema_seq_no"" : <schema_seq_no>,
-///      ""issuer_did"" : <issuer_did>
+///      ""schema_key"" : {name: string, version: string, did: string},
+///      ""issuer_did"" : string
+///      ""prover_did"" : string",87,2017-12-29 08:39:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158711542,https://github.com/hyperledger/indy-sdk/pull/450#discussion_r158711542,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/450,https://github.com/hyperledger/indy-sdk/pull/450,Why do we need prover_did?,ce8768741ef4a944ba6c15b1114dc4eb68dcd7f1,2017-12-26 14:49:10,158711626,"@@ -386,8 +387,9 @@ pub extern fn indy_prover_create_master_secret(command_handle: i32,
 /// Claim request json.
 ///     {
 ///      ""blinded_ms"" : <blinded_master_secret>,
-///      ""schema_seq_no"" : <schema_seq_no>,
-///      ""issuer_did"" : <issuer_did>
+///      ""schema_key"" : {name: string, version: string, did: string},
+///      ""issuer_did"" : string,
+///      ""prover_did"" : string",250,2017-12-29 08:39:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158711626,https://github.com/hyperledger/indy-sdk/pull/450#discussion_r158711626,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/450,https://github.com/hyperledger/indy-sdk/pull/450,"Each part of the proof may belong to different schemas and issuers. Why did we move this information out of `""claim_proofX_referent""`?",ce8768741ef4a944ba6c15b1114dc4eb68dcd7f1,2017-12-26 14:50:48,158711762,"@@ -706,12 +712,15 @@ pub extern fn indy_prover_get_claims_for_proof_req(command_handle: i32,
 ///             ""requested_predicate_1_referent"": [claim_proof2_referent],
 ///             ""requested_predicate_2_referent"": [claim_proof3_referent],
 ///         }
-///         ""claim_proofs"": {
-///             ""claim_proof1_referent"": [<claim_proof>, issuer_did, schema_seq_no, revoc_reg_seq_no],
-///             ""claim_proof2_referent"": [<claim_proof>, issuer_did, schema_seq_no, revoc_reg_seq_no],
-///             ""claim_proof3_referent"": [<claim_proof>, issuer_did, schema_seq_no, revoc_reg_seq_no]
-///         },
-///         ""aggregated_proof"": <aggregated_proof>
+///         ""proof"": {
+///             ""proofs"": {
+///                 ""claim_proof1_referent"": <claim_proof>,
+///                 ""claim_proof2_referent"": <claim_proof>,
+///                 ""claim_proof3_referent"": <claim_proof>
+///             },
+///             ""aggregated_proof"": <aggregated_proof>
+///         }
+///         ""identifiers"": [{issuer_did, rev_reg_seq_no, schema_key: {name, version, did}}]",,2017-12-29 08:39:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158711762,https://github.com/hyperledger/indy-sdk/pull/450#discussion_r158711762,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/450,https://github.com/hyperledger/indy-sdk/pull/450,prover_did is used in Issuer::sign_claim function,ce8768741ef4a944ba6c15b1114dc4eb68dcd7f1,2017-12-27 05:55:09,158765548,"@@ -386,8 +387,9 @@ pub extern fn indy_prover_create_master_secret(command_handle: i32,
 /// Claim request json.
 ///     {
 ///      ""blinded_ms"" : <blinded_master_secret>,
-///      ""schema_seq_no"" : <schema_seq_no>,
-///      ""issuer_did"" : <issuer_did>
+///      ""schema_key"" : {name: string, version: string, did: string},
+///      ""issuer_did"" : string,
+///      ""prover_did"" : string",250,2017-12-29 08:39:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158765548,https://github.com/hyperledger/indy-sdk/pull/450#discussion_r158765548,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/450,https://github.com/hyperledger/indy-sdk/pull/450,We used to use issuer_did:schema_seq_no to identify rev_reg inside wallet. Now we have following key issuer_did:(schema_key),ce8768741ef4a944ba6c15b1114dc4eb68dcd7f1,2017-12-27 05:58:33,158765748,"@@ -65,19 +63,18 @@ pub extern fn indy_issuer_create_and_store_claim_def(command_handle: i32,
 }
 
 /// Create a new revocation registry for the given claim definition.
-/// Stores it in a secure wallet identifying by the returned key.
+/// Stores it in a secure wallet.
 ///
 /// #Params
 /// wallet_handle: wallet handler (created by open_wallet).
 /// command_handle: command handle to map callback to user context.
 /// issuer_did: a DID of the issuer signing revoc_reg transaction to the Ledger
-/// schema_seq_no: seq no of a schema transaction in Ledger
+/// schema_json: schema as a json",28,2017-12-29 08:39:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158765748,https://github.com/hyperledger/indy-sdk/pull/450#discussion_r158765748,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/450,https://github.com/hyperledger/indy-sdk/pull/450,"Changed identifiers format to
```""identifiers"": {""claim_proof1_referent"":{issuer_did, rev_reg_seq_no, schema_key: {name, version, did}}} ```",ce8768741ef4a944ba6c15b1114dc4eb68dcd7f1,2017-12-27 06:29:00,158767895,"@@ -706,12 +712,15 @@ pub extern fn indy_prover_get_claims_for_proof_req(command_handle: i32,
 ///             ""requested_predicate_1_referent"": [claim_proof2_referent],
 ///             ""requested_predicate_2_referent"": [claim_proof3_referent],
 ///         }
-///         ""claim_proofs"": {
-///             ""claim_proof1_referent"": [<claim_proof>, issuer_did, schema_seq_no, revoc_reg_seq_no],
-///             ""claim_proof2_referent"": [<claim_proof>, issuer_did, schema_seq_no, revoc_reg_seq_no],
-///             ""claim_proof3_referent"": [<claim_proof>, issuer_did, schema_seq_no, revoc_reg_seq_no]
-///         },
-///         ""aggregated_proof"": <aggregated_proof>
+///         ""proof"": {
+///             ""proofs"": {
+///                 ""claim_proof1_referent"": <claim_proof>,
+///                 ""claim_proof2_referent"": <claim_proof>,
+///                 ""claim_proof3_referent"": <claim_proof>
+///             },
+///             ""aggregated_proof"": <aggregated_proof>
+///         }
+///         ""identifiers"": [{issuer_did, rev_reg_seq_no, schema_key: {name, version, did}}]",,2017-12-29 08:39:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158767895,https://github.com/hyperledger/indy-sdk/pull/450#discussion_r158767895,Artemkaaas
https://github.com/hyperledger/indy-sdk/pull/450,https://github.com/hyperledger/indy-sdk/pull/450,Please add a comment about pattern matching for requested attributes in proof request (that it's case insensitive and ignore spaces). Add the comment in all methods dealing with proof request and pattern matching,ce8768741ef4a944ba6c15b1114dc4eb68dcd7f1,2017-12-27 08:28:59,158778967,"@@ -685,7 +691,7 @@ pub extern fn indy_prover_get_claims_for_proof_req(command_handle: i32,
 ///         ""value"": requested value of attribute
 ///         ""restrictions"": [
 ///             {
-///                 ""schema_seq_no"": int, (Optional)
+///                 ""schema_key"": {name (Optional), version (Optional), did (Optional)}, (Optional)",395,2017-12-29 08:39:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158778967,https://github.com/hyperledger/indy-sdk/pull/450#discussion_r158778967,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/450,https://github.com/hyperledger/indy-sdk/pull/450,Please make sure that we can use any part of the Schema (name or verion or did),ce8768741ef4a944ba6c15b1114dc4eb68dcd7f1,2017-12-27 08:30:56,158779172,"@@ -128,39 +110,52 @@ mod high_cases {
             let claim_offers: Vec<ClaimOffer> = serde_json::from_str(&claim_offers).unwrap();
 
             assert_eq!(claim_offers.len(), 2);
-            assert!(claim_offers.contains(&ClaimOffer { issuer_did: ISSUER_DID.to_string(), schema_seq_no: GVT_SEQ_NO }));
-            assert!(claim_offers.contains(&ClaimOffer { issuer_did: ISSUER_DID.to_string(), schema_seq_no: XYZ_SEQ_NO }));
+            assert!(claim_offers.contains(&ClaimOffer { issuer_did: ISSUER_DID.to_string(), schema_key: AnoncredsUtils::gvt_schema_key() }));
+            assert!(claim_offers.contains(&ClaimOffer { issuer_did: ISSUER_DID.to_string(), schema_key: AnoncredsUtils::xyz_schema_key() }));
         }
 
         #[test]
         fn prover_get_claim_offers_works_for_filter_by_schema() {
             let (wallet_handle, _) = AnoncredsUtils::init_common_wallet();
 
-            let claim_offers = AnoncredsUtils::prover_get_claim_offers(wallet_handle, &format!(r#""{{""schema_seq_no"":{}}}""#, GVT_SEQ_NO)).unwrap();
+            let claim_offers = AnoncredsUtils::prover_get_claim_offers(wallet_handle,
+                                                                       &format!(r#""{{""schema_key"":{}}}""#, AnoncredsUtils::gvt_schema_key_json())).unwrap();
+            let claim_offers: Vec<ClaimOffer> = serde_json::from_str(&claim_offers).unwrap();
+
+            assert_eq!(claim_offers.len(), 2);
+            assert!(claim_offers.contains(&ClaimOffer { issuer_did: ISSUER_DID.to_string(), schema_key: AnoncredsUtils::gvt_schema_key() }));
+            assert!(claim_offers.contains(&ClaimOffer { issuer_did: DID.to_string(), schema_key: AnoncredsUtils::gvt_schema_key() }));
+        }
+
+        #[test]
+        fn prover_get_claim_offers_works_for_filter_by_part_of_schema() {
+            let (wallet_handle, _) = AnoncredsUtils::init_common_wallet();
+
+            let claim_offers = AnoncredsUtils::prover_get_claim_offers(wallet_handle, r#""{""schema_key"":{""name"":""gvt""}}""#).unwrap();",,2017-12-29 08:39:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158779172,https://github.com/hyperledger/indy-sdk/pull/450#discussion_r158779172,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/450,https://github.com/hyperledger/indy-sdk/pull/450,Please add tests to make sure that we can use any part of the Schema (name or verion or did),ce8768741ef4a944ba6c15b1114dc4eb68dcd7f1,2017-12-27 08:34:53,158779592,"@@ -384,31 +370,44 @@ mod high_cases {
         fn prover_get_claims_works_for_filter_by_schema() {
             let (wallet_handle, _) = AnoncredsUtils::init_common_wallet();
 
-            let claims = AnoncredsUtils::prover_get_claims(wallet_handle, &format!(r#""{{""schema_seq_no"":{}}}""#, GVT_SEQ_NO)).unwrap();
+            let claims = AnoncredsUtils::prover_get_claims(wallet_handle, &format!(r#""{{""schema_key"":{}}}""#, &AnoncredsUtils::gvt_schema_key_json())).unwrap();
             let claims: Vec<ClaimInfo> = serde_json::from_str(&claims).unwrap();
 
             assert_eq!(claims.len(), 2);
-            assert_eq!(claims[0].schema_seq_no, GVT_SEQ_NO);
-            assert_eq!(claims[1].schema_seq_no, GVT_SEQ_NO);
+            assert_eq!(claims[0].schema_key, AnoncredsUtils::gvt_schema_key());
+            assert_eq!(claims[1].schema_key, AnoncredsUtils::gvt_schema_key());
+        }
+
+
+        #[test]
+        fn prover_get_claims_works_for_filter_by_part_of_schema() {
+            let (wallet_handle, _) = AnoncredsUtils::init_common_wallet();
+
+            let claims = AnoncredsUtils::prover_get_claims(wallet_handle, r#""{""schema_key"":{""name"":""gvt""}}""#).unwrap();",,2017-12-29 08:39:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158779592,https://github.com/hyperledger/indy-sdk/pull/450#discussion_r158779592,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/449,https://github.com/hyperledger/indy-sdk/pull/449,"I suggest to add a bit more background information:

### Old python-based CLI migration

It is possible to import did's stored in the wallet of deprecated python-based CLI tool. To achieve this user needs to perform the following steps...

Also we need mention that user needs to update old CLI. After this execute script on machine with installed old CLI. After this install new CLI and etc....",dff3fc0dde2e2ae763fe4d22063b3a2a7c606aac,2017-12-26 11:27:41,158696537,"@@ -26,4 +26,18 @@ CLI supports 2 execution modes:
 * Batch. In this mode all commands will be read from text file or pipe and executed in series. To start this mode run `indy-cli <path-to-text-file>`. Batch mode supports the same commands as interactive mode. Note that by default if some command finishes with the error batch execution will be interrupted. To prevent this start command with `-`. For example, `-wallet create test`. In this case the result of this command will be ignored.
 
 ### Getting help
-The most simple way is just start cli by `indy-cli` command and put `help` command. Also you can look to [Indy CLI Design](../doc/cli-design.md) doc that contains the list of commands and architecture overview.
\ No newline at end of file
+The most simple way is just start cli by `indy-cli` command and put `help` command. Also you can look to [Indy CLI Design](../doc/cli-design.md) doc that contains the list of commands and architecture overview.
+
+### Migration",,2017-12-29 13:37:35,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158696537,https://github.com/hyperledger/indy-sdk/pull/449#discussion_r158696537,vimmerru
https://github.com/hyperledger/indy-sdk/pull/449,https://github.com/hyperledger/indy-sdk/pull/449,We need to describe the format of file.,dff3fc0dde2e2ae763fe4d22063b3a2a7c606aac,2017-12-27 09:48:30,158789124,"@@ -81,6 +82,62 @@ pub mod new_command {
     }
 }
 
+pub mod import_command {
+    use super::*;
+    use std::io::Read;
+
+    command!(CommandMetadata::build(""import"", ""Import DIDs entities from file to the current wallet."")",,2017-12-29 13:37:35,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158789124,https://github.com/hyperledger/indy-sdk/pull/449#discussion_r158789124,vimmerru
https://github.com/hyperledger/indy-sdk/pull/449,https://github.com/hyperledger/indy-sdk/pull/449,Update script name and params,dff3fc0dde2e2ae763fe4d22063b3a2a7c606aac,2017-12-28 15:17:57,158957178,"@@ -26,4 +26,25 @@ CLI supports 2 execution modes:
 * Batch. In this mode all commands will be read from text file or pipe and executed in series. To start this mode run `indy-cli <path-to-text-file>`. Batch mode supports the same commands as interactive mode. Note that by default if some command finishes with the error batch execution will be interrupted. To prevent this start command with `-`. For example, `-wallet create test`. In this case the result of this command will be ignored.
 
 ### Getting help
-The most simple way is just start cli by `indy-cli` command and put `help` command. Also you can look to [Indy CLI Design](../doc/cli-design.md) doc that contains the list of commands and architecture overview.
\ No newline at end of file
+The most simple way is just start cli by `indy-cli` command and put `help` command. Also you can look to [Indy CLI Design](../doc/cli-design.md) doc that contains the list of commands and architecture overview.
+
+### Old python-based CLI migration
+It is possible to import did's stored in the wallet of deprecated python-based CLI tool. 
+To achieve this user needs to perform the following steps:
+1. Execute script on machine with installed old python-based CLI. 
+    ```
+    indy_export_dids [-e <env name>] -w <wallet name> [-f <path to the result file>]",,2017-12-29 13:37:35,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158957178,https://github.com/hyperledger/indy-sdk/pull/449#discussion_r158957178,jovfer
https://github.com/hyperledger/indy-sdk/pull/434,https://github.com/hyperledger/indy-sdk/pull/434,Update comment about returned values,e71784a36b963a65b967fa5a927fecd6f3faa251,2017-12-20 13:10:12,158018514,"@@ -240,20 +235,18 @@ extern ""C"" {
     /// Common*
     /// Wallet*
     /// Crypto*
-    extern indy_error_t indy_crypto_box_open(indy_handle_t      command_handle,
-                                             indy_handle_t      wallet_handle,
-                                             const char *       my_vk,
-                                             const char *       their_vk,
-                                             const indy_u8_t*   encrypted_msg_raw,
-                                             indy_u32_t         encrypted_msg_len,
-                                             const indy_u8_t*   nonce_raw,
-                                             indy_u32_t         nonce_len,
+    extern indy_error_t indy_crypto_auth_decrypt(indy_handle_t      command_handle,
+                                                 indy_handle_t      wallet_handle,
+                                                 const char *       my_vk,
+                                                 const indy_u8_t*   encrypted_msg_raw,
+                                                 indy_u32_t         encrypted_msg_len,
 
-                                             void           (*cb)(indy_handle_t     xcommand_handle,
-                                                                  indy_error_t      err,
-                                                                  const indy_u8_t*  decrypted_msg_raw,
-                                                                  indy_u32_t        decrypted_msg_len)
-                                            );
+                                                 void           (*cb)(indy_handle_t     xcommand_handle,
+                                                                      indy_error_t      err,
+                                                                      const char *      their_vk,",100,2017-12-22 05:13:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158018514,https://github.com/hyperledger/indy-sdk/pull/434#discussion_r158018514,jovfer
https://github.com/hyperledger/indy-sdk/pull/434,https://github.com/hyperledger/indy-sdk/pull/434,Fix comment about data for description on recipient side.,e71784a36b963a65b967fa5a927fecd6f3faa251,2017-12-20 13:10:44,158018648,"@@ -193,20 +193,18 @@ extern ""C"" {
     /// Wallet*
     /// Ledger*
     /// Crypto*
-    extern indy_error_t indy_crypto_box(indy_handle_t      command_handle,
-                                        indy_handle_t      wallet_handle,
-                                        const char *       my_vk,
-                                        const char *       their_vk,
-                                        const indy_u8_t *  message_raw,
-                                        indy_u32_t         message_len,
+    extern indy_error_t indy_crypto_auth_crypt(indy_handle_t      command_handle,",28,2017-12-22 05:13:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158018648,https://github.com/hyperledger/indy-sdk/pull/434#discussion_r158018648,jovfer
https://github.com/hyperledger/indy-sdk/pull/434,https://github.com/hyperledger/indy-sdk/pull/434,Fix alignment,e71784a36b963a65b967fa5a927fecd6f3faa251,2017-12-20 13:11:47,158018889,"@@ -95,34 +95,34 @@ extern ""C"" {
                                                                      indy_error_t  err)
                                                );
 
-    /// Saves their DID for a pairwise connection in a secured Wallet,
-    /// so that it can be used to verify transaction.
-    ///
-    /// #Params
-    /// wallet_handle: wallet handler (created by open_wallet).
-    /// command_handle: command handle to map callback to user context.
-    /// identity_json: Identity information as json. Example:
-    ///     {
-    ///        ""did"": string, (required)
-    ///        ""verkey"": string (optional, can be avoided if did is cryptonym: did == verkey)
-    ///     }
-    /// cb: Callback that takes command result as parameter.
-    ///
-    /// #Returns
-    /// None
-    ///
-    /// #Errors
-    /// Common*
-    /// Wallet*
-    /// Crypto*
-
-    extern indy_error_t indy_store_their_did(indy_handle_t command_handle,
-                                             indy_handle_t wallet_handle,
-                                             const char *  identity_json,
-
-                                             void           (*cb)(indy_handle_t xcommand_handle,
-                                                                  indy_error_t  err)
-                                            );
+/// Saves their DID for a pairwise connection in a secured Wallet,",,2017-12-22 05:13:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158018889,https://github.com/hyperledger/indy-sdk/pull/434#discussion_r158018889,jovfer
https://github.com/hyperledger/indy-sdk/pull/434,https://github.com/hyperledger/indy-sdk/pull/434,@vimmerru will we change to message pack serialization? In this case base64 encoding will be removed,e71784a36b963a65b967fa5a927fecd6f3faa251,2017-12-20 13:45:01,158026165,"@@ -89,162 +97,252 @@ impl CryptoCommandExecutor {
                 info!(""CryptoVerify command received"");
                 cb(self.crypto_verify(their_vk, msg, signature));
             }
-            CryptoCommand::CryptoBox(wallet_handle, my_vk, their_vk, msg, cb) => {
-                info!(""CryptoBox command received"");
-                cb(self.crypto_box(wallet_handle, my_vk, their_vk, msg));
+            CryptoCommand::AuthenticatedEncrypt(wallet_handle, my_vk, their_vk, msg, cb) => {
+                info!(""AuthenticatedEncrypt command received"");
+                cb(self.authenticated_encrypt(wallet_handle, my_vk, their_vk, msg));
             }
-            CryptoCommand::CryptoBoxOpen(wallet_handle, my_vk, their_vk, encrypted_msg, nonce, cb) => {
-                info!(""CryptoBoxOpen command received"");
-                cb(self.crypto_box_open(wallet_handle, my_vk, their_vk, encrypted_msg, nonce));
+            CryptoCommand::AuthenticatedDecrypt(wallet_handle, my_vk, encrypted_msg, cb) => {
+                info!(""AuthenticatedDecrypt command received"");
+                cb(self.authenticated_decrypt(wallet_handle, my_vk, encrypted_msg));
             }
-            CryptoCommand::CryptoBoxSeal(their_vk, msg, cb) => {
-                info!(""CryptoBoxSeal command received"");
-                cb(self.crypto_box_seal(their_vk, msg));
+            CryptoCommand::AnonymousEncrypt(their_vk, msg, cb) => {
+                info!(""AnonymousEncrypt command received"");
+                cb(self.anonymous_encrypt(their_vk, msg));
             }
-            CryptoCommand::CryptoBoxSealOpen(wallet_handle, my_vk, encrypted_msg, cb) => {
-                info!(""CryptoBoxSealOpen command received"");
-                cb(self.crypto_box_seal_open(wallet_handle, my_vk, encrypted_msg));
-            }
-            CryptoCommand::SetKeyMetadata(wallet_handle, verkey, metadata, cb) => {
-                info!(""SetKeyMetadata command received"");
-                cb(self.set_key_metadata(wallet_handle, verkey, metadata));
-            }
-            CryptoCommand::GetKeyMetadata(wallet_handle, verkey, cb) => {
-                info!(""GetKeyMetadata command received"");
-                cb(self.get_key_metadata(wallet_handle, verkey));
+            CryptoCommand::AnonymousDecrypt(wallet_handle, my_vk, encrypted_msg, cb) => {
+                info!(""AnonymousDecrypt command received"");
+                cb(self.anonymous_decrypt(wallet_handle, my_vk, encrypted_msg));
             }
         };
     }
 
     fn create_key(&self, wallet_handle: i32, key_info_json: String) -> Result<String, IndyError> {
+        info!(""create_key >>> wallet_handle: {:?}, key_info_json: {:?}"", wallet_handle, key_info_json);
+
         let key_info = KeyInfo::from_json(&key_info_json)
             .map_err(map_err_trace!())
             .map_err(|err|
                 CommonError::InvalidStructure(
                     format!(""Invalid KeyInfo json: {}"", err.description())))?;
 
-        let key = self.signus_service.create_key(&key_info)?;
+        let key = self.crypto_service.create_key(&key_info)?;
         self._wallet_set_key(wallet_handle, &key)?;
 
         let res = key.verkey;
+
+        info!(""create_key <<< res: {:?}"", res);
+
         Ok(res)
     }
 
     fn crypto_sign(&self,
                    wallet_handle: i32,
                    my_vk: &str,
                    msg: &[u8]) -> Result<Vec<u8>, IndyError> {
-        self.signus_service.validate_key(my_vk)?;
+        info!(""crypto_sign >>> wallet_handle: {:?}, sender_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, msg);
+
+        self.crypto_service.validate_key(my_vk)?;
 
         let key = self._wallet_get_key(wallet_handle, &my_vk)?;
 
-        let res = self.signus_service.sign(&key, msg)?;
+        let res = self.crypto_service.sign(&key, msg)?;
+
+        info!(""crypto_sign <<< res: {:?}"", res);
+
         Ok(res)
     }
 
     fn crypto_verify(&self,
                      their_vk: String,
                      msg: Vec<u8>,
                      signature: Vec<u8>) -> Result<bool, IndyError> {
-        self.signus_service.validate_key(&their_vk)?;
+        info!(""crypto_verify >>> their_vk: {:?}, msg: {:?}, signature: {:?}"", their_vk, msg, signature);
+
+        self.crypto_service.validate_key(&their_vk)?;
+
+        let res = self.crypto_service.verify(&their_vk, &msg, &signature)?;
+
+        info!(""crypto_verify <<< res: {:?}"", res);
 
-        let res = self.signus_service.verify(&their_vk, &msg, &signature)?;
         Ok(res)
     }
 
-    fn crypto_box(&self,
-                  wallet_handle: i32,
-                  my_vk: String,
-                  their_vk: String,
-                  msg: Vec<u8>) -> Result<(Vec<u8>, Vec<u8>), IndyError> {
-        self.signus_service.validate_key(&my_vk)?;
-        self.signus_service.validate_key(&their_vk)?;
+    fn authenticated_encrypt(&self,
+                             wallet_handle: i32,
+                             my_vk: String,
+                             their_vk: String,
+                             msg: Vec<u8>) -> Result<Vec<u8>, IndyError> {
+        info!(""authenticated_encrypt >>> wallet_handle: {:?}, my_vk: {:?}, their_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, their_vk, msg);
+
+        let sender_key_json = self.wallet_service.get(wallet_handle, &format!(""key::{}"", my_vk))?;
+
+        let sender_key = Key::from_json(&sender_key_json)
+            .map_err(|err| CommonError::InvalidState(format!(""Can't deserialize Key: {:?}"", err)))?;
 
-        let my_key = self._wallet_get_key(wallet_handle, &my_vk)?;
+        let (msg, nonce) = self.crypto_service.encrypt(&sender_key, &their_vk, msg.as_slice())?;
+
+        let msg = Message {
+            msg: base64::encode(msg.as_slice()),
+            sender: my_vk.to_string(),
+            nonce: base64::encode(nonce.as_slice())
+        };
+
+        let msg = msg.to_json()",,2017-12-22 05:13:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158026165,https://github.com/hyperledger/indy-sdk/pull/434#discussion_r158026165,jovfer
https://github.com/hyperledger/indy-sdk/pull/434,https://github.com/hyperledger/indy-sdk/pull/434,restore key validation,e71784a36b963a65b967fa5a927fecd6f3faa251,2017-12-20 13:46:48,158026602,"@@ -89,162 +97,252 @@ impl CryptoCommandExecutor {
                 info!(""CryptoVerify command received"");
                 cb(self.crypto_verify(their_vk, msg, signature));
             }
-            CryptoCommand::CryptoBox(wallet_handle, my_vk, their_vk, msg, cb) => {
-                info!(""CryptoBox command received"");
-                cb(self.crypto_box(wallet_handle, my_vk, their_vk, msg));
+            CryptoCommand::AuthenticatedEncrypt(wallet_handle, my_vk, their_vk, msg, cb) => {
+                info!(""AuthenticatedEncrypt command received"");
+                cb(self.authenticated_encrypt(wallet_handle, my_vk, their_vk, msg));
             }
-            CryptoCommand::CryptoBoxOpen(wallet_handle, my_vk, their_vk, encrypted_msg, nonce, cb) => {
-                info!(""CryptoBoxOpen command received"");
-                cb(self.crypto_box_open(wallet_handle, my_vk, their_vk, encrypted_msg, nonce));
+            CryptoCommand::AuthenticatedDecrypt(wallet_handle, my_vk, encrypted_msg, cb) => {
+                info!(""AuthenticatedDecrypt command received"");
+                cb(self.authenticated_decrypt(wallet_handle, my_vk, encrypted_msg));
             }
-            CryptoCommand::CryptoBoxSeal(their_vk, msg, cb) => {
-                info!(""CryptoBoxSeal command received"");
-                cb(self.crypto_box_seal(their_vk, msg));
+            CryptoCommand::AnonymousEncrypt(their_vk, msg, cb) => {
+                info!(""AnonymousEncrypt command received"");
+                cb(self.anonymous_encrypt(their_vk, msg));
             }
-            CryptoCommand::CryptoBoxSealOpen(wallet_handle, my_vk, encrypted_msg, cb) => {
-                info!(""CryptoBoxSealOpen command received"");
-                cb(self.crypto_box_seal_open(wallet_handle, my_vk, encrypted_msg));
-            }
-            CryptoCommand::SetKeyMetadata(wallet_handle, verkey, metadata, cb) => {
-                info!(""SetKeyMetadata command received"");
-                cb(self.set_key_metadata(wallet_handle, verkey, metadata));
-            }
-            CryptoCommand::GetKeyMetadata(wallet_handle, verkey, cb) => {
-                info!(""GetKeyMetadata command received"");
-                cb(self.get_key_metadata(wallet_handle, verkey));
+            CryptoCommand::AnonymousDecrypt(wallet_handle, my_vk, encrypted_msg, cb) => {
+                info!(""AnonymousDecrypt command received"");
+                cb(self.anonymous_decrypt(wallet_handle, my_vk, encrypted_msg));
             }
         };
     }
 
     fn create_key(&self, wallet_handle: i32, key_info_json: String) -> Result<String, IndyError> {
+        info!(""create_key >>> wallet_handle: {:?}, key_info_json: {:?}"", wallet_handle, key_info_json);
+
         let key_info = KeyInfo::from_json(&key_info_json)
             .map_err(map_err_trace!())
             .map_err(|err|
                 CommonError::InvalidStructure(
                     format!(""Invalid KeyInfo json: {}"", err.description())))?;
 
-        let key = self.signus_service.create_key(&key_info)?;
+        let key = self.crypto_service.create_key(&key_info)?;
         self._wallet_set_key(wallet_handle, &key)?;
 
         let res = key.verkey;
+
+        info!(""create_key <<< res: {:?}"", res);
+
         Ok(res)
     }
 
     fn crypto_sign(&self,
                    wallet_handle: i32,
                    my_vk: &str,
                    msg: &[u8]) -> Result<Vec<u8>, IndyError> {
-        self.signus_service.validate_key(my_vk)?;
+        info!(""crypto_sign >>> wallet_handle: {:?}, sender_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, msg);
+
+        self.crypto_service.validate_key(my_vk)?;
 
         let key = self._wallet_get_key(wallet_handle, &my_vk)?;
 
-        let res = self.signus_service.sign(&key, msg)?;
+        let res = self.crypto_service.sign(&key, msg)?;
+
+        info!(""crypto_sign <<< res: {:?}"", res);
+
         Ok(res)
     }
 
     fn crypto_verify(&self,
                      their_vk: String,
                      msg: Vec<u8>,
                      signature: Vec<u8>) -> Result<bool, IndyError> {
-        self.signus_service.validate_key(&their_vk)?;
+        info!(""crypto_verify >>> their_vk: {:?}, msg: {:?}, signature: {:?}"", their_vk, msg, signature);
+
+        self.crypto_service.validate_key(&their_vk)?;
+
+        let res = self.crypto_service.verify(&their_vk, &msg, &signature)?;
+
+        info!(""crypto_verify <<< res: {:?}"", res);
 
-        let res = self.signus_service.verify(&their_vk, &msg, &signature)?;
         Ok(res)
     }
 
-    fn crypto_box(&self,
-                  wallet_handle: i32,
-                  my_vk: String,
-                  their_vk: String,
-                  msg: Vec<u8>) -> Result<(Vec<u8>, Vec<u8>), IndyError> {
-        self.signus_service.validate_key(&my_vk)?;
-        self.signus_service.validate_key(&their_vk)?;
+    fn authenticated_encrypt(&self,
+                             wallet_handle: i32,
+                             my_vk: String,
+                             their_vk: String,
+                             msg: Vec<u8>) -> Result<Vec<u8>, IndyError> {
+        info!(""authenticated_encrypt >>> wallet_handle: {:?}, my_vk: {:?}, their_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, their_vk, msg);
+
+        let sender_key_json = self.wallet_service.get(wallet_handle, &format!(""key::{}"", my_vk))?;
+
+        let sender_key = Key::from_json(&sender_key_json)
+            .map_err(|err| CommonError::InvalidState(format!(""Can't deserialize Key: {:?}"", err)))?;
 
-        let my_key = self._wallet_get_key(wallet_handle, &my_vk)?;
+        let (msg, nonce) = self.crypto_service.encrypt(&sender_key, &their_vk, msg.as_slice())?;
+
+        let msg = Message {
+            msg: base64::encode(msg.as_slice()),
+            sender: my_vk.to_string(),
+            nonce: base64::encode(nonce.as_slice())
+        };
+
+        let msg = msg.to_json()
+            .map_err(|e| CommonError::InvalidState(format!(""Can't serialize AuthenticatedEncryptedMessage: {:?}"", e)))?;
+
+        let res = self.crypto_service.encrypt_sealed(&their_vk, msg.as_bytes())?;
+
+        info!(""authenticated_encrypt <<< res: {:?}"", res);
 
-        let res = self.signus_service.encrypt(&my_key, &their_vk, &msg)?;
         Ok(res)
     }
 
-    fn crypto_box_open(&self,
-                       wallet_handle: i32,
-                       my_vk: String,
-                       their_vk: String,
-                       encrypted_msg: Vec<u8>,
-                       nonce: Vec<u8>) -> Result<Vec<u8>, IndyError> {
-        self.signus_service.validate_key(&my_vk)?;
-        self.signus_service.validate_key(&their_vk)?;
+    fn authenticated_decrypt(&self,
+                             wallet_handle: i32,
+                             my_vk: String,
+                             msg: Vec<u8>) -> Result<(String, Vec<u8>), IndyError> {
+        info!(""authenticated_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, msg);
+
+        let my_key_json = self.wallet_service.get(wallet_handle, &format!(""key::{}"", my_vk))?;
 
-        let my_key = self._wallet_get_key(wallet_handle, &my_vk)?;
+        let my_key = Key::from_json(&my_key_json)
+            .map_err(|err| IndyError::CommonError(CommonError::InvalidState(format!(""Can't deserialize Key: {:?}"", err))))?;
+
+        let decrypted_msg = self.crypto_service.decrypt_sealed(&my_key, &msg)?;
+
+        let parsed_msg: Message = serde_json::from_slice(decrypted_msg.as_slice())
+            .map_err(|err| CommonError::InvalidStructure(format!(""Can't deserialize AuthenticatedEncryptedMessage: {:?}"", err)))?;
+
+        let doc: Vec<u8> = base64::decode(&parsed_msg.msg)
+            .map_err(|err| CommonError::InvalidStructure(format!(""Can't decode internal msg filed from base64 {}"", err)))?;
+
+        let nonce: Vec<u8> = base64::decode(&parsed_msg.nonce)
+            .map_err(|err| CommonError::InvalidStructure(format!(""Can't decode nonce from base64 {}"", err)))?;
+
+        let decrypted_msg = self.crypto_service.decrypt(&my_key, &parsed_msg.sender, &doc, &nonce)?;
+
+        let res = (parsed_msg.sender.clone(), decrypted_msg);
+
+        info!(""authenticated_decrypt <<< res: {:?}"", res);
 
-        let res = self.signus_service.decrypt(&my_key, &their_vk, &encrypted_msg, &nonce)?;
         Ok(res)
     }
 
-    fn crypto_box_seal(&self,
-                       their_vk: String,
-                       msg: Vec<u8>) -> Result<Vec<u8>, IndyError> {
-        self.signus_service.validate_key(&their_vk)?;
+    fn anonymous_encrypt(&self,
+                         their_vk: String,
+                         msg: Vec<u8>) -> Result<Vec<u8>, IndyError> {
+        info!(""anonymous_encrypt >>> their_vk: {:?}, msg: {:?}"", their_vk, msg);
+",298,2017-12-22 05:13:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158026602,https://github.com/hyperledger/indy-sdk/pull/434#discussion_r158026602,jovfer
https://github.com/hyperledger/indy-sdk/pull/434,https://github.com/hyperledger/indy-sdk/pull/434,restore key validation,e71784a36b963a65b967fa5a927fecd6f3faa251,2017-12-20 13:47:26,158026746,"@@ -89,162 +97,252 @@ impl CryptoCommandExecutor {
                 info!(""CryptoVerify command received"");
                 cb(self.crypto_verify(their_vk, msg, signature));
             }
-            CryptoCommand::CryptoBox(wallet_handle, my_vk, their_vk, msg, cb) => {
-                info!(""CryptoBox command received"");
-                cb(self.crypto_box(wallet_handle, my_vk, their_vk, msg));
+            CryptoCommand::AuthenticatedEncrypt(wallet_handle, my_vk, their_vk, msg, cb) => {
+                info!(""AuthenticatedEncrypt command received"");
+                cb(self.authenticated_encrypt(wallet_handle, my_vk, their_vk, msg));
             }
-            CryptoCommand::CryptoBoxOpen(wallet_handle, my_vk, their_vk, encrypted_msg, nonce, cb) => {
-                info!(""CryptoBoxOpen command received"");
-                cb(self.crypto_box_open(wallet_handle, my_vk, their_vk, encrypted_msg, nonce));
+            CryptoCommand::AuthenticatedDecrypt(wallet_handle, my_vk, encrypted_msg, cb) => {
+                info!(""AuthenticatedDecrypt command received"");
+                cb(self.authenticated_decrypt(wallet_handle, my_vk, encrypted_msg));
             }
-            CryptoCommand::CryptoBoxSeal(their_vk, msg, cb) => {
-                info!(""CryptoBoxSeal command received"");
-                cb(self.crypto_box_seal(their_vk, msg));
+            CryptoCommand::AnonymousEncrypt(their_vk, msg, cb) => {
+                info!(""AnonymousEncrypt command received"");
+                cb(self.anonymous_encrypt(their_vk, msg));
             }
-            CryptoCommand::CryptoBoxSealOpen(wallet_handle, my_vk, encrypted_msg, cb) => {
-                info!(""CryptoBoxSealOpen command received"");
-                cb(self.crypto_box_seal_open(wallet_handle, my_vk, encrypted_msg));
-            }
-            CryptoCommand::SetKeyMetadata(wallet_handle, verkey, metadata, cb) => {
-                info!(""SetKeyMetadata command received"");
-                cb(self.set_key_metadata(wallet_handle, verkey, metadata));
-            }
-            CryptoCommand::GetKeyMetadata(wallet_handle, verkey, cb) => {
-                info!(""GetKeyMetadata command received"");
-                cb(self.get_key_metadata(wallet_handle, verkey));
+            CryptoCommand::AnonymousDecrypt(wallet_handle, my_vk, encrypted_msg, cb) => {
+                info!(""AnonymousDecrypt command received"");
+                cb(self.anonymous_decrypt(wallet_handle, my_vk, encrypted_msg));
             }
         };
     }
 
     fn create_key(&self, wallet_handle: i32, key_info_json: String) -> Result<String, IndyError> {
+        info!(""create_key >>> wallet_handle: {:?}, key_info_json: {:?}"", wallet_handle, key_info_json);
+
         let key_info = KeyInfo::from_json(&key_info_json)
             .map_err(map_err_trace!())
             .map_err(|err|
                 CommonError::InvalidStructure(
                     format!(""Invalid KeyInfo json: {}"", err.description())))?;
 
-        let key = self.signus_service.create_key(&key_info)?;
+        let key = self.crypto_service.create_key(&key_info)?;
         self._wallet_set_key(wallet_handle, &key)?;
 
         let res = key.verkey;
+
+        info!(""create_key <<< res: {:?}"", res);
+
         Ok(res)
     }
 
     fn crypto_sign(&self,
                    wallet_handle: i32,
                    my_vk: &str,
                    msg: &[u8]) -> Result<Vec<u8>, IndyError> {
-        self.signus_service.validate_key(my_vk)?;
+        info!(""crypto_sign >>> wallet_handle: {:?}, sender_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, msg);
+
+        self.crypto_service.validate_key(my_vk)?;
 
         let key = self._wallet_get_key(wallet_handle, &my_vk)?;
 
-        let res = self.signus_service.sign(&key, msg)?;
+        let res = self.crypto_service.sign(&key, msg)?;
+
+        info!(""crypto_sign <<< res: {:?}"", res);
+
         Ok(res)
     }
 
     fn crypto_verify(&self,
                      their_vk: String,
                      msg: Vec<u8>,
                      signature: Vec<u8>) -> Result<bool, IndyError> {
-        self.signus_service.validate_key(&their_vk)?;
+        info!(""crypto_verify >>> their_vk: {:?}, msg: {:?}, signature: {:?}"", their_vk, msg, signature);
+
+        self.crypto_service.validate_key(&their_vk)?;
+
+        let res = self.crypto_service.verify(&their_vk, &msg, &signature)?;
+
+        info!(""crypto_verify <<< res: {:?}"", res);
 
-        let res = self.signus_service.verify(&their_vk, &msg, &signature)?;
         Ok(res)
     }
 
-    fn crypto_box(&self,
-                  wallet_handle: i32,
-                  my_vk: String,
-                  their_vk: String,
-                  msg: Vec<u8>) -> Result<(Vec<u8>, Vec<u8>), IndyError> {
-        self.signus_service.validate_key(&my_vk)?;
-        self.signus_service.validate_key(&their_vk)?;
+    fn authenticated_encrypt(&self,
+                             wallet_handle: i32,
+                             my_vk: String,
+                             their_vk: String,
+                             msg: Vec<u8>) -> Result<Vec<u8>, IndyError> {
+        info!(""authenticated_encrypt >>> wallet_handle: {:?}, my_vk: {:?}, their_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, their_vk, msg);
+
+        let sender_key_json = self.wallet_service.get(wallet_handle, &format!(""key::{}"", my_vk))?;
+
+        let sender_key = Key::from_json(&sender_key_json)
+            .map_err(|err| CommonError::InvalidState(format!(""Can't deserialize Key: {:?}"", err)))?;
 
-        let my_key = self._wallet_get_key(wallet_handle, &my_vk)?;
+        let (msg, nonce) = self.crypto_service.encrypt(&sender_key, &their_vk, msg.as_slice())?;
+
+        let msg = Message {
+            msg: base64::encode(msg.as_slice()),
+            sender: my_vk.to_string(),
+            nonce: base64::encode(nonce.as_slice())
+        };
+
+        let msg = msg.to_json()
+            .map_err(|e| CommonError::InvalidState(format!(""Can't serialize AuthenticatedEncryptedMessage: {:?}"", e)))?;
+
+        let res = self.crypto_service.encrypt_sealed(&their_vk, msg.as_bytes())?;
+
+        info!(""authenticated_encrypt <<< res: {:?}"", res);
 
-        let res = self.signus_service.encrypt(&my_key, &their_vk, &msg)?;
         Ok(res)
     }
 
-    fn crypto_box_open(&self,
-                       wallet_handle: i32,
-                       my_vk: String,
-                       their_vk: String,
-                       encrypted_msg: Vec<u8>,
-                       nonce: Vec<u8>) -> Result<Vec<u8>, IndyError> {
-        self.signus_service.validate_key(&my_vk)?;
-        self.signus_service.validate_key(&their_vk)?;
+    fn authenticated_decrypt(&self,
+                             wallet_handle: i32,
+                             my_vk: String,
+                             msg: Vec<u8>) -> Result<(String, Vec<u8>), IndyError> {
+        info!(""authenticated_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, msg);
+
+        let my_key_json = self.wallet_service.get(wallet_handle, &format!(""key::{}"", my_vk))?;
 
-        let my_key = self._wallet_get_key(wallet_handle, &my_vk)?;
+        let my_key = Key::from_json(&my_key_json)
+            .map_err(|err| IndyError::CommonError(CommonError::InvalidState(format!(""Can't deserialize Key: {:?}"", err))))?;
+
+        let decrypted_msg = self.crypto_service.decrypt_sealed(&my_key, &msg)?;
+
+        let parsed_msg: Message = serde_json::from_slice(decrypted_msg.as_slice())
+            .map_err(|err| CommonError::InvalidStructure(format!(""Can't deserialize AuthenticatedEncryptedMessage: {:?}"", err)))?;
+
+        let doc: Vec<u8> = base64::decode(&parsed_msg.msg)
+            .map_err(|err| CommonError::InvalidStructure(format!(""Can't decode internal msg filed from base64 {}"", err)))?;
+
+        let nonce: Vec<u8> = base64::decode(&parsed_msg.nonce)
+            .map_err(|err| CommonError::InvalidStructure(format!(""Can't decode nonce from base64 {}"", err)))?;
+
+        let decrypted_msg = self.crypto_service.decrypt(&my_key, &parsed_msg.sender, &doc, &nonce)?;
+
+        let res = (parsed_msg.sender.clone(), decrypted_msg);
+
+        info!(""authenticated_decrypt <<< res: {:?}"", res);
 
-        let res = self.signus_service.decrypt(&my_key, &their_vk, &encrypted_msg, &nonce)?;
         Ok(res)
     }
 
-    fn crypto_box_seal(&self,
-                       their_vk: String,
-                       msg: Vec<u8>) -> Result<Vec<u8>, IndyError> {
-        self.signus_service.validate_key(&their_vk)?;
+    fn anonymous_encrypt(&self,
+                         their_vk: String,
+                         msg: Vec<u8>) -> Result<Vec<u8>, IndyError> {
+        info!(""anonymous_encrypt >>> their_vk: {:?}, msg: {:?}"", their_vk, msg);
+
+        let res = self.crypto_service.encrypt_sealed(&their_vk, &msg)?;;
+
+        info!(""anonymous_encrypt <<< res: {:?}"", res);
 
-        let res = self.signus_service.encrypt_sealed(&their_vk, &msg)?;
         Ok(res)
     }
 
-    fn crypto_box_seal_open(&self,
-                            wallet_handle: i32,
-                            my_vk: String,
-                            encrypted_msg: Vec<u8>) -> Result<Vec<u8>, IndyError> {
-        self.signus_service.validate_key(&my_vk)?;
+    fn anonymous_decrypt(&self,
+                         wallet_handle: i32,
+                         my_vk: String,
+                         encrypted_msg: Vec<u8>) -> Result<Vec<u8>, IndyError> {
+        info!(""anonymous_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, encrypted_msg: {:?}"", wallet_handle, my_vk, encrypted_msg);
 
-        let key = self._wallet_get_key(wallet_handle, &my_vk)?;
+        let my_key_json = self.wallet_service.get(wallet_handle, &format!(""key::{}"", my_vk))?;",,2017-12-22 05:13:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158026746,https://github.com/hyperledger/indy-sdk/pull/434#discussion_r158026746,jovfer
https://github.com/hyperledger/indy-sdk/pull/434,https://github.com/hyperledger/indy-sdk/pull/434,revert logic to crypto_box_seal,e71784a36b963a65b967fa5a927fecd6f3faa251,2017-12-20 13:49:21,158027234,"@@ -89,162 +97,252 @@ impl CryptoCommandExecutor {
                 info!(""CryptoVerify command received"");
                 cb(self.crypto_verify(their_vk, msg, signature));
             }
-            CryptoCommand::CryptoBox(wallet_handle, my_vk, their_vk, msg, cb) => {
-                info!(""CryptoBox command received"");
-                cb(self.crypto_box(wallet_handle, my_vk, their_vk, msg));
+            CryptoCommand::AuthenticatedEncrypt(wallet_handle, my_vk, their_vk, msg, cb) => {
+                info!(""AuthenticatedEncrypt command received"");
+                cb(self.authenticated_encrypt(wallet_handle, my_vk, their_vk, msg));
             }
-            CryptoCommand::CryptoBoxOpen(wallet_handle, my_vk, their_vk, encrypted_msg, nonce, cb) => {
-                info!(""CryptoBoxOpen command received"");
-                cb(self.crypto_box_open(wallet_handle, my_vk, their_vk, encrypted_msg, nonce));
+            CryptoCommand::AuthenticatedDecrypt(wallet_handle, my_vk, encrypted_msg, cb) => {
+                info!(""AuthenticatedDecrypt command received"");
+                cb(self.authenticated_decrypt(wallet_handle, my_vk, encrypted_msg));
             }
-            CryptoCommand::CryptoBoxSeal(their_vk, msg, cb) => {
-                info!(""CryptoBoxSeal command received"");
-                cb(self.crypto_box_seal(their_vk, msg));
+            CryptoCommand::AnonymousEncrypt(their_vk, msg, cb) => {
+                info!(""AnonymousEncrypt command received"");
+                cb(self.anonymous_encrypt(their_vk, msg));
             }
-            CryptoCommand::CryptoBoxSealOpen(wallet_handle, my_vk, encrypted_msg, cb) => {
-                info!(""CryptoBoxSealOpen command received"");
-                cb(self.crypto_box_seal_open(wallet_handle, my_vk, encrypted_msg));
-            }
-            CryptoCommand::SetKeyMetadata(wallet_handle, verkey, metadata, cb) => {
-                info!(""SetKeyMetadata command received"");
-                cb(self.set_key_metadata(wallet_handle, verkey, metadata));
-            }
-            CryptoCommand::GetKeyMetadata(wallet_handle, verkey, cb) => {
-                info!(""GetKeyMetadata command received"");
-                cb(self.get_key_metadata(wallet_handle, verkey));
+            CryptoCommand::AnonymousDecrypt(wallet_handle, my_vk, encrypted_msg, cb) => {
+                info!(""AnonymousDecrypt command received"");
+                cb(self.anonymous_decrypt(wallet_handle, my_vk, encrypted_msg));
             }
         };
     }
 
     fn create_key(&self, wallet_handle: i32, key_info_json: String) -> Result<String, IndyError> {
+        info!(""create_key >>> wallet_handle: {:?}, key_info_json: {:?}"", wallet_handle, key_info_json);
+
         let key_info = KeyInfo::from_json(&key_info_json)
             .map_err(map_err_trace!())
             .map_err(|err|
                 CommonError::InvalidStructure(
                     format!(""Invalid KeyInfo json: {}"", err.description())))?;
 
-        let key = self.signus_service.create_key(&key_info)?;
+        let key = self.crypto_service.create_key(&key_info)?;
         self._wallet_set_key(wallet_handle, &key)?;
 
         let res = key.verkey;
+
+        info!(""create_key <<< res: {:?}"", res);
+
         Ok(res)
     }
 
     fn crypto_sign(&self,
                    wallet_handle: i32,
                    my_vk: &str,
                    msg: &[u8]) -> Result<Vec<u8>, IndyError> {
-        self.signus_service.validate_key(my_vk)?;
+        info!(""crypto_sign >>> wallet_handle: {:?}, sender_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, msg);
+
+        self.crypto_service.validate_key(my_vk)?;
 
         let key = self._wallet_get_key(wallet_handle, &my_vk)?;
 
-        let res = self.signus_service.sign(&key, msg)?;
+        let res = self.crypto_service.sign(&key, msg)?;
+
+        info!(""crypto_sign <<< res: {:?}"", res);
+
         Ok(res)
     }
 
     fn crypto_verify(&self,
                      their_vk: String,
                      msg: Vec<u8>,
                      signature: Vec<u8>) -> Result<bool, IndyError> {
-        self.signus_service.validate_key(&their_vk)?;
+        info!(""crypto_verify >>> their_vk: {:?}, msg: {:?}, signature: {:?}"", their_vk, msg, signature);
+
+        self.crypto_service.validate_key(&their_vk)?;
+
+        let res = self.crypto_service.verify(&their_vk, &msg, &signature)?;
+
+        info!(""crypto_verify <<< res: {:?}"", res);
 
-        let res = self.signus_service.verify(&their_vk, &msg, &signature)?;
         Ok(res)
     }
 
-    fn crypto_box(&self,
-                  wallet_handle: i32,
-                  my_vk: String,
-                  their_vk: String,
-                  msg: Vec<u8>) -> Result<(Vec<u8>, Vec<u8>), IndyError> {
-        self.signus_service.validate_key(&my_vk)?;
-        self.signus_service.validate_key(&their_vk)?;
+    fn authenticated_encrypt(&self,
+                             wallet_handle: i32,
+                             my_vk: String,
+                             their_vk: String,
+                             msg: Vec<u8>) -> Result<Vec<u8>, IndyError> {
+        info!(""authenticated_encrypt >>> wallet_handle: {:?}, my_vk: {:?}, their_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, their_vk, msg);
+
+        let sender_key_json = self.wallet_service.get(wallet_handle, &format!(""key::{}"", my_vk))?;
+
+        let sender_key = Key::from_json(&sender_key_json)
+            .map_err(|err| CommonError::InvalidState(format!(""Can't deserialize Key: {:?}"", err)))?;
 
-        let my_key = self._wallet_get_key(wallet_handle, &my_vk)?;
+        let (msg, nonce) = self.crypto_service.encrypt(&sender_key, &their_vk, msg.as_slice())?;
+
+        let msg = Message {
+            msg: base64::encode(msg.as_slice()),
+            sender: my_vk.to_string(),
+            nonce: base64::encode(nonce.as_slice())
+        };
+
+        let msg = msg.to_json()
+            .map_err(|e| CommonError::InvalidState(format!(""Can't serialize AuthenticatedEncryptedMessage: {:?}"", e)))?;
+
+        let res = self.crypto_service.encrypt_sealed(&their_vk, msg.as_bytes())?;
+
+        info!(""authenticated_encrypt <<< res: {:?}"", res);
 
-        let res = self.signus_service.encrypt(&my_key, &their_vk, &msg)?;
         Ok(res)
     }
 
-    fn crypto_box_open(&self,
-                       wallet_handle: i32,
-                       my_vk: String,
-                       their_vk: String,
-                       encrypted_msg: Vec<u8>,
-                       nonce: Vec<u8>) -> Result<Vec<u8>, IndyError> {
-        self.signus_service.validate_key(&my_vk)?;
-        self.signus_service.validate_key(&their_vk)?;
+    fn authenticated_decrypt(&self,
+                             wallet_handle: i32,
+                             my_vk: String,
+                             msg: Vec<u8>) -> Result<(String, Vec<u8>), IndyError> {
+        info!(""authenticated_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, msg);
+
+        let my_key_json = self.wallet_service.get(wallet_handle, &format!(""key::{}"", my_vk))?;
 
-        let my_key = self._wallet_get_key(wallet_handle, &my_vk)?;
+        let my_key = Key::from_json(&my_key_json)
+            .map_err(|err| IndyError::CommonError(CommonError::InvalidState(format!(""Can't deserialize Key: {:?}"", err))))?;
+
+        let decrypted_msg = self.crypto_service.decrypt_sealed(&my_key, &msg)?;
+
+        let parsed_msg: Message = serde_json::from_slice(decrypted_msg.as_slice())
+            .map_err(|err| CommonError::InvalidStructure(format!(""Can't deserialize AuthenticatedEncryptedMessage: {:?}"", err)))?;
+
+        let doc: Vec<u8> = base64::decode(&parsed_msg.msg)
+            .map_err(|err| CommonError::InvalidStructure(format!(""Can't decode internal msg filed from base64 {}"", err)))?;
+
+        let nonce: Vec<u8> = base64::decode(&parsed_msg.nonce)
+            .map_err(|err| CommonError::InvalidStructure(format!(""Can't decode nonce from base64 {}"", err)))?;
+
+        let decrypted_msg = self.crypto_service.decrypt(&my_key, &parsed_msg.sender, &doc, &nonce)?;
+
+        let res = (parsed_msg.sender.clone(), decrypted_msg);
+
+        info!(""authenticated_decrypt <<< res: {:?}"", res);
 
-        let res = self.signus_service.decrypt(&my_key, &their_vk, &encrypted_msg, &nonce)?;
         Ok(res)
     }
 
-    fn crypto_box_seal(&self,
-                       their_vk: String,
-                       msg: Vec<u8>) -> Result<Vec<u8>, IndyError> {
-        self.signus_service.validate_key(&their_vk)?;
+    fn anonymous_encrypt(&self,",294,2017-12-22 05:13:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158027234,https://github.com/hyperledger/indy-sdk/pull/434#discussion_r158027234,jovfer
https://github.com/hyperledger/indy-sdk/pull/434,https://github.com/hyperledger/indy-sdk/pull/434,move to service?,e71784a36b963a65b967fa5a927fecd6f3faa251,2017-12-20 13:52:09,158027863,"@@ -89,162 +97,252 @@ impl CryptoCommandExecutor {
                 info!(""CryptoVerify command received"");
                 cb(self.crypto_verify(their_vk, msg, signature));
             }
-            CryptoCommand::CryptoBox(wallet_handle, my_vk, their_vk, msg, cb) => {
-                info!(""CryptoBox command received"");
-                cb(self.crypto_box(wallet_handle, my_vk, their_vk, msg));
+            CryptoCommand::AuthenticatedEncrypt(wallet_handle, my_vk, their_vk, msg, cb) => {
+                info!(""AuthenticatedEncrypt command received"");
+                cb(self.authenticated_encrypt(wallet_handle, my_vk, their_vk, msg));
             }
-            CryptoCommand::CryptoBoxOpen(wallet_handle, my_vk, their_vk, encrypted_msg, nonce, cb) => {
-                info!(""CryptoBoxOpen command received"");
-                cb(self.crypto_box_open(wallet_handle, my_vk, their_vk, encrypted_msg, nonce));
+            CryptoCommand::AuthenticatedDecrypt(wallet_handle, my_vk, encrypted_msg, cb) => {
+                info!(""AuthenticatedDecrypt command received"");
+                cb(self.authenticated_decrypt(wallet_handle, my_vk, encrypted_msg));
             }
-            CryptoCommand::CryptoBoxSeal(their_vk, msg, cb) => {
-                info!(""CryptoBoxSeal command received"");
-                cb(self.crypto_box_seal(their_vk, msg));
+            CryptoCommand::AnonymousEncrypt(their_vk, msg, cb) => {
+                info!(""AnonymousEncrypt command received"");
+                cb(self.anonymous_encrypt(their_vk, msg));
             }
-            CryptoCommand::CryptoBoxSealOpen(wallet_handle, my_vk, encrypted_msg, cb) => {
-                info!(""CryptoBoxSealOpen command received"");
-                cb(self.crypto_box_seal_open(wallet_handle, my_vk, encrypted_msg));
-            }
-            CryptoCommand::SetKeyMetadata(wallet_handle, verkey, metadata, cb) => {
-                info!(""SetKeyMetadata command received"");
-                cb(self.set_key_metadata(wallet_handle, verkey, metadata));
-            }
-            CryptoCommand::GetKeyMetadata(wallet_handle, verkey, cb) => {
-                info!(""GetKeyMetadata command received"");
-                cb(self.get_key_metadata(wallet_handle, verkey));
+            CryptoCommand::AnonymousDecrypt(wallet_handle, my_vk, encrypted_msg, cb) => {
+                info!(""AnonymousDecrypt command received"");
+                cb(self.anonymous_decrypt(wallet_handle, my_vk, encrypted_msg));
             }
         };
     }
 
     fn create_key(&self, wallet_handle: i32, key_info_json: String) -> Result<String, IndyError> {
+        info!(""create_key >>> wallet_handle: {:?}, key_info_json: {:?}"", wallet_handle, key_info_json);
+
         let key_info = KeyInfo::from_json(&key_info_json)
             .map_err(map_err_trace!())
             .map_err(|err|
                 CommonError::InvalidStructure(
                     format!(""Invalid KeyInfo json: {}"", err.description())))?;
 
-        let key = self.signus_service.create_key(&key_info)?;
+        let key = self.crypto_service.create_key(&key_info)?;
         self._wallet_set_key(wallet_handle, &key)?;
 
         let res = key.verkey;
+
+        info!(""create_key <<< res: {:?}"", res);
+
         Ok(res)
     }
 
     fn crypto_sign(&self,
                    wallet_handle: i32,
                    my_vk: &str,
                    msg: &[u8]) -> Result<Vec<u8>, IndyError> {
-        self.signus_service.validate_key(my_vk)?;
+        info!(""crypto_sign >>> wallet_handle: {:?}, sender_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, msg);
+
+        self.crypto_service.validate_key(my_vk)?;
 
         let key = self._wallet_get_key(wallet_handle, &my_vk)?;
 
-        let res = self.signus_service.sign(&key, msg)?;
+        let res = self.crypto_service.sign(&key, msg)?;
+
+        info!(""crypto_sign <<< res: {:?}"", res);
+
         Ok(res)
     }
 
     fn crypto_verify(&self,
                      their_vk: String,
                      msg: Vec<u8>,
                      signature: Vec<u8>) -> Result<bool, IndyError> {
-        self.signus_service.validate_key(&their_vk)?;
+        info!(""crypto_verify >>> their_vk: {:?}, msg: {:?}, signature: {:?}"", their_vk, msg, signature);
+
+        self.crypto_service.validate_key(&their_vk)?;
+
+        let res = self.crypto_service.verify(&their_vk, &msg, &signature)?;
+
+        info!(""crypto_verify <<< res: {:?}"", res);
 
-        let res = self.signus_service.verify(&their_vk, &msg, &signature)?;
         Ok(res)
     }
 
-    fn crypto_box(&self,
-                  wallet_handle: i32,
-                  my_vk: String,
-                  their_vk: String,
-                  msg: Vec<u8>) -> Result<(Vec<u8>, Vec<u8>), IndyError> {
-        self.signus_service.validate_key(&my_vk)?;
-        self.signus_service.validate_key(&their_vk)?;
+    fn authenticated_encrypt(&self,
+                             wallet_handle: i32,
+                             my_vk: String,
+                             their_vk: String,
+                             msg: Vec<u8>) -> Result<Vec<u8>, IndyError> {
+        info!(""authenticated_encrypt >>> wallet_handle: {:?}, my_vk: {:?}, their_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, their_vk, msg);
+
+        let sender_key_json = self.wallet_service.get(wallet_handle, &format!(""key::{}"", my_vk))?;
+
+        let sender_key = Key::from_json(&sender_key_json)
+            .map_err(|err| CommonError::InvalidState(format!(""Can't deserialize Key: {:?}"", err)))?;
 
-        let my_key = self._wallet_get_key(wallet_handle, &my_vk)?;
+        let (msg, nonce) = self.crypto_service.encrypt(&sender_key, &their_vk, msg.as_slice())?;
+
+        let msg = Message {
+            msg: base64::encode(msg.as_slice()),
+            sender: my_vk.to_string(),
+            nonce: base64::encode(nonce.as_slice())
+        };
+
+        let msg = msg.to_json()
+            .map_err(|e| CommonError::InvalidState(format!(""Can't serialize AuthenticatedEncryptedMessage: {:?}"", e)))?;
+
+        let res = self.crypto_service.encrypt_sealed(&their_vk, msg.as_bytes())?;
+
+        info!(""authenticated_encrypt <<< res: {:?}"", res);
 
-        let res = self.signus_service.encrypt(&my_key, &their_vk, &msg)?;
         Ok(res)
     }
 
-    fn crypto_box_open(&self,
-                       wallet_handle: i32,
-                       my_vk: String,
-                       their_vk: String,
-                       encrypted_msg: Vec<u8>,
-                       nonce: Vec<u8>) -> Result<Vec<u8>, IndyError> {
-        self.signus_service.validate_key(&my_vk)?;
-        self.signus_service.validate_key(&their_vk)?;
+    fn authenticated_decrypt(&self,
+                             wallet_handle: i32,
+                             my_vk: String,
+                             msg: Vec<u8>) -> Result<(String, Vec<u8>), IndyError> {
+        info!(""authenticated_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, msg: {:?}"", wallet_handle, my_vk, msg);
+
+        let my_key_json = self.wallet_service.get(wallet_handle, &format!(""key::{}"", my_vk))?;
 
-        let my_key = self._wallet_get_key(wallet_handle, &my_vk)?;
+        let my_key = Key::from_json(&my_key_json)
+            .map_err(|err| IndyError::CommonError(CommonError::InvalidState(format!(""Can't deserialize Key: {:?}"", err))))?;
+
+        let decrypted_msg = self.crypto_service.decrypt_sealed(&my_key, &msg)?;
+
+        let parsed_msg: Message = serde_json::from_slice(decrypted_msg.as_slice())
+            .map_err(|err| CommonError::InvalidStructure(format!(""Can't deserialize AuthenticatedEncryptedMessage: {:?}"", err)))?;
+
+        let doc: Vec<u8> = base64::decode(&parsed_msg.msg)
+            .map_err(|err| CommonError::InvalidStructure(format!(""Can't decode internal msg filed from base64 {}"", err)))?;
+
+        let nonce: Vec<u8> = base64::decode(&parsed_msg.nonce)
+            .map_err(|err| CommonError::InvalidStructure(format!(""Can't decode nonce from base64 {}"", err)))?;
+
+        let decrypted_msg = self.crypto_service.decrypt(&my_key, &parsed_msg.sender, &doc, &nonce)?;
+
+        let res = (parsed_msg.sender.clone(), decrypted_msg);
+
+        info!(""authenticated_decrypt <<< res: {:?}"", res);
 
-        let res = self.signus_service.decrypt(&my_key, &their_vk, &encrypted_msg, &nonce)?;
         Ok(res)
     }
 
-    fn crypto_box_seal(&self,
-                       their_vk: String,
-                       msg: Vec<u8>) -> Result<Vec<u8>, IndyError> {
-        self.signus_service.validate_key(&their_vk)?;
+    fn anonymous_encrypt(&self,
+                         their_vk: String,
+                         msg: Vec<u8>) -> Result<Vec<u8>, IndyError> {
+        info!(""anonymous_encrypt >>> their_vk: {:?}, msg: {:?}"", their_vk, msg);
+
+        let res = self.crypto_service.encrypt_sealed(&their_vk, &msg)?;;
+
+        info!(""anonymous_encrypt <<< res: {:?}"", res);
 
-        let res = self.signus_service.encrypt_sealed(&their_vk, &msg)?;
         Ok(res)
     }
 
-    fn crypto_box_seal_open(&self,
-                            wallet_handle: i32,
-                            my_vk: String,
-                            encrypted_msg: Vec<u8>) -> Result<Vec<u8>, IndyError> {
-        self.signus_service.validate_key(&my_vk)?;
+    fn anonymous_decrypt(&self,
+                         wallet_handle: i32,
+                         my_vk: String,
+                         encrypted_msg: Vec<u8>) -> Result<Vec<u8>, IndyError> {
+        info!(""anonymous_decrypt >>> wallet_handle: {:?}, my_vk: {:?}, encrypted_msg: {:?}"", wallet_handle, my_vk, encrypted_msg);
 
-        let key = self._wallet_get_key(wallet_handle, &my_vk)?;
+        let my_key_json = self.wallet_service.get(wallet_handle, &format!(""key::{}"", my_vk))?;
+
+        let my_key = Key::from_json(&my_key_json)
+            .map_err(|err| IndyError::CommonError(CommonError::InvalidState(format!(""Invalid Key json: {:?}"", err))))?;
+
+        let res = self.crypto_service.decrypt_sealed(&my_key, &encrypted_msg)?;
+
+        info!(""anonymous_decrypt <<< res: {:?}"", res);
 
-        let res = self.signus_service.decrypt_sealed(&key, &encrypted_msg)?;
         Ok(res)
     }
 
     fn set_key_metadata(&self, wallet_handle: i32, verkey: String, metadata: String) -> Result<(), IndyError> {
-        self.signus_service.validate_key(&verkey)?;
-        self._wallet_set_key_metadata(wallet_handle, &verkey, &metadata)?;
-        Ok(())
+        info!(""set_key_metadata >>> wallet_handle: {:?}, verkey: {:?}, metadata: {:?}"", wallet_handle, verkey, metadata);
+
+        self.crypto_service.validate_key(&verkey)?;
+        let res = self._wallet_set_key_metadata(wallet_handle, &verkey, &metadata)?;
+
+        info!(""set_key_metadata <<< res: {:?}"", res);
+
+        Ok(res)
     }
 
     fn get_key_metadata(&self,
                         wallet_handle: i32,
                         verkey: String) -> Result<String, IndyError> {
-        self.signus_service.validate_key(&verkey)?;
+        info!(""get_key_metadata >>> wallet_handle: {:?}, verkey: {:?}"", wallet_handle, verkey);
+
+        self.crypto_service.validate_key(&verkey)?;
         let res = self._wallet_get_key_metadata(wallet_handle, &verkey)?;
+
+        info!(""get_key_metadata <<< res: {:?}"", res);
+
         Ok(res)
     }
 
     fn _wallet_set_key(&self, wallet_handle: i32, key: &Key) -> Result<(), IndyError> {
+        info!(""_wallet_set_key >>> wallet_handle: {:?}, key: {:?}"", wallet_handle, key);
+
         let key_json = Key::to_json(&key)
             .map_err(map_err_trace!())
             .map_err(|err|
                 CommonError::InvalidState(
                     format!(""Can't serialize Key: {}"", err.description())))?;
 
-        self.wallet_service.set(wallet_handle, &format!(""key::{}"", key.verkey), &key_json)?;
-        Ok(())
+        let res = self.wallet_service.set(wallet_handle, &format!(""key::{}"", key.verkey), &key_json)?;
+
+        info!(""_wallet_set_key <<< res: {:?}"", res);
+
+        Ok(res)
     }
 
     fn _wallet_get_key(&self, wallet_handle: i32, key: &str) -> Result<Key, IndyError> {
+        info!(""_wallet_get_key >>> wallet_handle: {:?}, key: {:?}"", wallet_handle, key);
+
         let key_json = self.wallet_service.get(wallet_handle, &format!(""key::{}"", key))?;
 
         let res = Key::from_json(&key_json)
             .map_err(map_err_trace!())
             .map_err(|err|
                 CommonError::InvalidState(
                     format!(""Can't deserialize Key: {}"", err.description())))?;
+
+        info!(""_wallet_get_key <<< res: {:?}"", res);
+
         Ok(res)
     }
 
     fn _wallet_set_key_metadata(&self, wallet_handle: i32, verkey: &str, metadata: &str) -> Result<(), IndyError> {
-        self.wallet_service.set(wallet_handle, &format!(""key::{}::metadata"", verkey), metadata)?;
-        Ok(())
+        info!(""_wallet_set_key_metadata >>> wallet_handle: {:?}, verkey: {:?}, metadata: {:?}"", wallet_handle, verkey, metadata);
+
+        let res = self.wallet_service.set(wallet_handle, &format!(""key::{}::metadata"", verkey), metadata)?;
+
+        info!(""_wallet_set_key_metadata <<< res: {:?}"", res);
+
+        Ok(res)
     }
 
     fn _wallet_get_key_metadata(&self, wallet_handle: i32, verkey: &str) -> Result<String, IndyError> {
+        info!(""_wallet_get_key_metadata >>> wallet_handle: {:?}, verkey: {:?}"", wallet_handle, verkey);
+
         let res = self.wallet_service.get(wallet_handle, &format!(""key::{}::metadata"", verkey))?;
+
+        info!(""_wallet_get_key_metadata <<< res: {:?}"", res);
+
         Ok(res)
     }
 }
+
+
+#[derive(Serialize, Deserialize)]
+struct Message {",,2017-12-22 05:13:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158027863,https://github.com/hyperledger/indy-sdk/pull/434#discussion_r158027863,jovfer
https://github.com/hyperledger/indy-sdk/pull/434,https://github.com/hyperledger/indy-sdk/pull/434,Directly use CommonError,e71784a36b963a65b967fa5a927fecd6f3faa251,2017-12-20 13:55:22,158028631,"@@ -233,20 +233,20 @@ impl LedgerCommandExecutor {
 
         let mut request: Value = serde_json::from_str(request_json)
             .map_err(|err|
-                IndyError::SignusError(SignusError::CommonError(
+                IndyError::CryptoError(CryptoError::CommonError(",,2017-12-22 05:13:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158028631,https://github.com/hyperledger/indy-sdk/pull/434#discussion_r158028631,jovfer
https://github.com/hyperledger/indy-sdk/pull/434,https://github.com/hyperledger/indy-sdk/pull/434,Directly use CommonError,e71784a36b963a65b967fa5a927fecd6f3faa251,2017-12-20 13:56:57,158029084,"@@ -233,20 +233,20 @@ impl LedgerCommandExecutor {
 
         let mut request: Value = serde_json::from_str(request_json)
             .map_err(|err|
-                IndyError::SignusError(SignusError::CommonError(
+                IndyError::CryptoError(CryptoError::CommonError(
                     CommonError::InvalidStructure(format!(""Message is invalid json: {}"", err.description())))))?;
 
         if !request.is_object() {
-            return Err(IndyError::SignusError(SignusError::CommonError(
+            return Err(IndyError::CryptoError(CryptoError::CommonError(",,2017-12-22 05:13:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158029084,https://github.com/hyperledger/indy-sdk/pull/434#discussion_r158029084,jovfer
https://github.com/hyperledger/indy-sdk/pull/434,https://github.com/hyperledger/indy-sdk/pull/434,Directly use CommonError?,e71784a36b963a65b967fa5a927fecd6f3faa251,2017-12-20 13:57:26,158029187,"@@ -233,20 +233,20 @@ impl LedgerCommandExecutor {
 
         let mut request: Value = serde_json::from_str(request_json)
             .map_err(|err|
-                IndyError::SignusError(SignusError::CommonError(
+                IndyError::CryptoError(CryptoError::CommonError(
                     CommonError::InvalidStructure(format!(""Message is invalid json: {}"", err.description())))))?;
 
         if !request.is_object() {
-            return Err(IndyError::SignusError(SignusError::CommonError(
+            return Err(IndyError::CryptoError(CryptoError::CommonError(
                 CommonError::InvalidStructure(format!(""Message is invalid json: {}"", request)))));
         }
         let serialized_request = serialize_signature(request.clone())?;
-        let signature = self.signus_service.sign(&my_key, &serialized_request.as_bytes().to_vec())?;
+        let signature = self.crypto_service.sign(&my_key, &serialized_request.as_bytes().to_vec())?;
 
         request[""signature""] = Value::String(Base58::encode(&signature));
         let signed_request: String = serde_json::to_string(&request)
             .map_err(|err|
-                IndyError::SignusError(SignusError::CommonError(
+                IndyError::CryptoError(CryptoError::CommonError(",,2017-12-22 05:13:57,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158029187,https://github.com/hyperledger/indy-sdk/pull/434#discussion_r158029187,jovfer
https://github.com/hyperledger/indy-sdk/pull/432,https://github.com/hyperledger/indy-sdk/pull/432,Please use Python 3.5,89aa8146917305411d199fb71c03f033d3062d31,2017-12-28 08:33:20,158912411,"@@ -0,0 +1,73 @@
+# Indy Python wrapper functional test
+
+This is a Python wrapper functional test for Indy. The tests are not driven by any unit test framework but are standalone python scripts.
+
+This Python wrapper functional test currently requires python 3.6, base58.
+
+### How to run
+
+After building successfully the Indy SDK for Python, you need to run the commands below so that could run the tests:
+
+- Install base58 dependency with pip install: 
+```
+     python3.6 -m pip install base58",13,2017-12-28 08:33:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/158912411,https://github.com/hyperledger/indy-sdk/pull/432#discussion_r158912411,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/432,https://github.com/hyperledger/indy-sdk/pull/432,We will update this on next commit.,89aa8146917305411d199fb71c03f033d3062d31,2018-01-02 08:08:14,159183980,"@@ -0,0 +1,73 @@
+# Indy Python wrapper functional test
+
+This is a Python wrapper functional test for Indy. The tests are not driven by any unit test framework but are standalone python scripts.
+
+This Python wrapper functional test currently requires python 3.6, base58.
+
+### How to run
+
+After building successfully the Indy SDK for Python, you need to run the commands below so that could run the tests:
+
+- Install base58 dependency with pip install: 
+```
+     python3.6 -m pip install base58",13,2018-01-02 08:08:14,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/159183980,https://github.com/hyperledger/indy-sdk/pull/432#discussion_r159183980,nghia47
https://github.com/hyperledger/indy-sdk/pull/428,https://github.com/hyperledger/indy-sdk/pull/428,"This unwrap is a bug - ""gen_txn_file"" is required param",02f9755f7182a9561ef023ac04c993c4eb93934c,2017-12-14 15:23:39,156972632,"@@ -27,7 +27,7 @@ pub mod create_command {
 
         let name = get_str_param(""name"", params).map_err(error_err!())?;
         let gen_txn_file = get_opt_str_param(""gen_txn_file"", params).map_err(error_err!())?
-            .unwrap_or(""pool_transactions_genesis"");
+            .unwrap_or(""docker_pool_transactions_genesis"");",,2017-12-18 16:29:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/156972632,https://github.com/hyperledger/indy-sdk/pull/428#discussion_r156972632,jovfer
https://github.com/hyperledger/indy-sdk/pull/424,https://github.com/hyperledger/indy-sdk/pull/424,"I suggest to pop up help compiltion from this and next blocks.
Something like
```
if !line.contains(""help"") {
  completes.push(""help"");
}
```",553e7359addd955b983475f7e20598f64c55cd85,2017-12-14 15:05:28,156967461,"@@ -295,6 +295,99 @@ impl CommandExecutor {
         &self.ctx
     }
 
+    pub fn complete(&self, line: &str, word: &str, _start: usize, _end: usize) -> Vec<(String, char)> {
+        let mut completes: Vec<(String, char)> = vec![];
+
+        let (cmd, params) = CommandExecutor::_split_first_word(line);
+
+        if let Some(ref command) = self.commands.get(cmd) {
+            // Complete command params
+
+            if ""help"".starts_with(word) {",12,2017-12-15 08:02:50,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/156967461,https://github.com/hyperledger/indy-sdk/pull/424#discussion_r156967461,jovfer
https://github.com/hyperledger/indy-sdk/pull/424,https://github.com/hyperledger/indy-sdk/pull/424,Will be fixed at the next iteration.,553e7359addd955b983475f7e20598f64c55cd85,2017-12-14 15:58:41,156983869,"@@ -295,6 +295,99 @@ impl CommandExecutor {
         &self.ctx
     }
 
+    pub fn complete(&self, line: &str, word: &str, _start: usize, _end: usize) -> Vec<(String, char)> {
+        let mut completes: Vec<(String, char)> = vec![];
+
+        let (cmd, params) = CommandExecutor::_split_first_word(line);
+
+        if let Some(ref command) = self.commands.get(cmd) {
+            // Complete command params
+
+            if ""help"".starts_with(word) {",12,2017-12-15 08:02:50,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/156983869,https://github.com/hyperledger/indy-sdk/pull/424#discussion_r156983869,jovfer
https://github.com/hyperledger/indy-sdk/pull/415,https://github.com/hyperledger/indy-sdk/pull/415,Restore info about current,ec28383522ba0d1292d2fa8eda93ceb66999fa00,2017-12-07 15:15:13,155549106,"@@ -157,17 +160,20 @@ impl Command for ListCommand {
 
         let res = match Pool::list() {
             Ok(pools) => {
-                let pools = pools.replace("","", ""\n"").replace(""]"", """").replace(""["", """");
-                if pools.trim().len() > 0 {
-                    println_succ!(""Existing pools: \n{}"", pools.trim());
-                } else {
-                    println_succ!(""There are no pools"");
-                }
-                if let Some(cur_pool) = self.ctx.get_connected_pool_name() {
-                    println_succ!(""Current pool \""{}\"""", cur_pool);
+                let pools: Vec<String> = serde_json::from_str(&pools)
+                    .map_err(|_| println_err!(""Wrong data has been received""))?;
+
+                let mut table = Table::new();
+                table.add_row(row![Fgb->""name""]);
+                for pool in pools {
+                    table.add_row(row![pool]);",,2017-12-08 10:44:42,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/155549106,https://github.com/hyperledger/indy-sdk/pull/415#discussion_r155549106,jovfer
https://github.com/hyperledger/indy-sdk/pull/415,https://github.com/hyperledger/indy-sdk/pull/415,"Add info about current
",ec28383522ba0d1292d2fa8eda93ceb66999fa00,2017-12-07 15:15:30,155549179,"@@ -241,12 +243,14 @@ impl Command for ListCommand {
                 let dids: Vec<serde_json::Value> = serde_json::from_str(&dids)
                     .map_err(|_| println_err!(""Wrong data has been received""))?;
                 if dids.len() > 0 {
-                    println_acc!(""{0: <24} | {1: <46} | {2}"", ""did"", ""verkey"", ""metadata"");
-
+                    let mut table = Table::new();
+                    table.add_row(row![Fgb->""did"", Fgb->""verkey"", Fgb->""metadata""]);
                     for did in dids {
-                        println!(""{0: <24} | {1: <46} | {2} "", did[""did""].as_str().unwrap_or(""-""),
-                                 did[""verkey""].as_str().unwrap_or(""-""), did[""metadata""].as_str().unwrap_or(""-""));
+                        table.add_row(row![did[""did""].as_str().unwrap_or(""-""),
+                                           did[""verkey""].as_str().unwrap_or(""-""),
+                                           did[""metadata""].as_str().unwrap_or(""-"")]);
                     }
+                    table.printstd();",,2017-12-08 10:44:42,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/155549179,https://github.com/hyperledger/indy-sdk/pull/415#discussion_r155549179,jovfer
https://github.com/hyperledger/indy-sdk/pull/415,https://github.com/hyperledger/indy-sdk/pull/415,Comment like this may be better rather empty table,ec28383522ba0d1292d2fa8eda93ceb66999fa00,2017-12-07 15:17:58,155549837,"@@ -157,17 +160,20 @@ impl Command for ListCommand {
 
         let res = match Pool::list() {
             Ok(pools) => {
-                let pools = pools.replace("","", ""\n"").replace(""]"", """").replace(""["", """");
-                if pools.trim().len() > 0 {
-                    println_succ!(""Existing pools: \n{}"", pools.trim());
-                } else {
-                    println_succ!(""There are no pools"");",,2017-12-08 10:44:42,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/155549837,https://github.com/hyperledger/indy-sdk/pull/415#discussion_r155549837,jovfer
https://github.com/hyperledger/indy-sdk/pull/401,https://github.com/hyperledger/indy-sdk/pull/401,Should be fixed after https://github.com/hyperledger/indy-crypto/pull/54 merge,a78f8c6311565239d0b6332037293707432805fa,2017-12-05 09:04:47,154882682,"@@ -33,7 +33,7 @@ interoperability_tests = []
 revocation_tests = []
 
 [dependencies]
-indy-crypto = { version = ""0.1.6"", optional = true }
+indy-crypto = { git = ""https://github.com/jovfer/indy-crypto"", optional = true}",,2017-12-18 08:43:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/154882682,https://github.com/hyperledger/indy-sdk/pull/401#discussion_r154882682,jovfer
https://github.com/hyperledger/indy-sdk/pull/401,https://github.com/hyperledger/indy-sdk/pull/401,update TODO,a78f8c6311565239d0b6332037293707432805fa,2017-12-05 09:07:13,154883250,"@@ -144,117 +138,119 @@ impl IssuerCommandExecutor {
                                              wallet_handle: i32,
                                              issuer_did: &str,
                                              schema_seq_no: i32,
-                                             max_claim_num: i32) -> Result<String, IndyError> {
-        let claim_def_json = self.wallet_service.get(wallet_handle, &format!(""claim_definition::{}"", &get_composite_id(issuer_did, schema_seq_no)))?;
-        let claim_def = ClaimDefinition::from_json(&claim_def_json)
-            .map_err(map_err_trace!())
-            .map_err(|err| CommonError::InvalidState(format!(""Invalid claim definition json: {}"", err.to_string())))?;
+                                             max_claim_num: u32) -> Result<String, IndyError> {
+        info!(target: ""commands/anoncreds/issuer"", ""create_and_store_revocation_registry >>> wallet_handle: {:?}, issuer_did: {:?}, schema_seq_no: {:?}, \
+                       max_claim_num: {:?}"", wallet_handle, issuer_did, schema_seq_no, max_claim_num);
 
-        let pk_r = claim_def.data.public_key_revocation
-            .ok_or(IndyError::AnoncredsError(AnoncredsError::NotIssuedError(""Revocation Public Key for this claim definition"".to_string())))?;
+        let claim_def_json = self.wallet_service.get(wallet_handle, &format!(""claim_definition::{}"", &get_composite_id(issuer_did, schema_seq_no)))?;
+        let claim_def: ClaimDefinition = ClaimDefinition::from_json(&claim_def_json)
+            .map_err(|err| CommonError::InvalidState(format!(""Cannon deserialize claim definition: {:?}"", err)))?;
 
         let (revocation_registry, revocation_registry_private) =
-            self.anoncreds_service.issuer.issue_accumulator(&pk_r, max_claim_num, issuer_did, schema_seq_no)?;
+            self.anoncreds_service.issuer.new_revocation_registry(&claim_def.data, max_claim_num, issuer_did, schema_seq_no)?;
+
+        let revocation_registry_json = revocation_registry.to_json()
+            .map_err(|err| CommonError::InvalidState(format!(""Cannon serialize revocation registry: {:?}"", err)))?;
 
-        let revocation_registry_json = RevocationRegistry::to_json(&revocation_registry)
-            .map_err(map_err_trace!())
-            .map_err(|err| CommonError::InvalidState(format!(""Invalid revocation registry: {}"", err.to_string())))?;
+        let revocation_registry_private_json = revocation_registry_private.to_json()
+            .map_err(|err| CommonError::InvalidState(format!(""Cannon serialize revocation registry private: {:?}"", err)))?;
 
-        let revocation_registry_private_json = RevocationRegistryPrivate::to_json(&revocation_registry_private)
-            .map_err(map_err_trace!())
-            .map_err(|err| CommonError::InvalidState(format!(""Invalid revocation registry private: {}"", err.to_string())))?;
+        let id = get_composite_id(issuer_did, schema_seq_no);
+        self.wallet_service.set(wallet_handle, &format!(""revocation_registry::{}"", id), &revocation_registry_json)?;
+        self.wallet_service.set(wallet_handle, &format!(""revocation_registry_private::{}"", id), &revocation_registry_private_json)?;
 
-        self.wallet_service.set(wallet_handle, &format!(""revocation_registry::{}"", &get_composite_id(issuer_did, schema_seq_no)), &revocation_registry_json)?;
-        self.wallet_service.set(wallet_handle, &format!(""revocation_registry_private::{}"", &get_composite_id(issuer_did, schema_seq_no)), &revocation_registry_private_json)?;
-        // TODO: change it
-        let tails_dash = serde_json::to_string(&revocation_registry_private.tails_dash)
-            .map_err(map_err_trace!())
-            .map_err(|err| CommonError::InvalidState(format!(""Invalid revocation registry private: {}"", err.to_string())))?;
+        //        // TODO: change it",,2017-12-18 08:43:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/154883250,https://github.com/hyperledger/indy-sdk/pull/401#discussion_r154883250,jovfer
https://github.com/hyperledger/indy-sdk/pull/401,https://github.com/hyperledger/indy-sdk/pull/401,should be trace without specific target,a78f8c6311565239d0b6332037293707432805fa,2017-12-05 11:01:28,154911387,"@@ -109,23 +100,26 @@ impl IssuerCommandExecutor {
                                           schema_json: &str,
                                           signature_type: Option<&str>,
                                           create_non_revoc: bool) -> Result<String, IndyError> {
-        let schema = Schema::from_json(schema_json)
-            .map_err(map_err_trace!())
+        info!(target: ""commands/anoncreds/issuer"", ""create_and_store_claim_definition >>> wallet_handle: {:?}, issuer_did: {:?}, schema_json: {:?}, \",,2017-12-18 08:43:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/154911387,https://github.com/hyperledger/indy-sdk/pull/401#discussion_r154911387,jovfer
https://github.com/hyperledger/indy-sdk/pull/401,https://github.com/hyperledger/indy-sdk/pull/401,Uncomment and disable feature in pipeline,a78f8c6311565239d0b6332037293707432805fa,2017-12-05 11:07:05,154912758,"@@ -1430,321 +1390,321 @@ mod demos {
     #[cfg(feature = ""interoperability_tests"")]
     use std::{thread, time};
 
-    #[cfg(feature = ""interoperability_tests"")]
-    #[test]
-    fn interoperability_test_pyindy_is_issuer() {
-        TestUtils::cleanup_storage();
-
-        let pool_name = ""pool1"";
-        let xtype = ""default"";
-
-        //1. Create Prover wallet, get wallet handle
-        let prover_wallet_handle = WalletUtils::create_and_open_wallet(pool_name, Some(xtype)).unwrap();
-
-        let schema_seq_no = 1;
-        let schema = AnoncredsUtils::get_gvt_schema_json(schema_seq_no);
-
-        //2. Prover create Master Secret
-        let master_secret_name = ""prover_master_secret"";
-
-        AnoncredsUtils::prover_create_master_secret(prover_wallet_handle, master_secret_name).unwrap();
-
-        //3. Prover store Claim Offer received from Issuer
-        let claim_offer_json = AnoncredsUtils::get_claim_offer(ISSUER_DID, schema_seq_no);
-
-        AnoncredsUtils::prover_store_claim_offer(prover_wallet_handle, &claim_offer_json).unwrap();
-
-        //4. Prover get Claim Offers
-        let filter_json = format!(r#""{{""issuer_did"":""{}""}}""#, ISSUER_DID);
-
-        let claim_offers_json = AnoncredsUtils::prover_get_claim_offers(prover_wallet_handle, &filter_json).unwrap();
-
-        let claim_offers: Vec<ClaimOffer> = serde_json::from_str(&claim_offers_json).unwrap();
-        assert!(claim_offers.len() == 1);
-        let claim_offer_json = serde_json::to_string(&claim_offers[0]).unwrap();
-
-        Command::new(""python3"")
-            .arg(""/home/indy/indy-anoncreds/anoncreds/test/test_interoperability_with_libindy_pyindy_is_issuer.py"")
-            .spawn().expect(""failed to execute process"");
-        thread::sleep(time::Duration::from_millis(3000));
-
-        let mut stream = TcpStream::connect(""127.0.0.1:1234"").unwrap();
-
-        let _ = stream.write(r#""{""type"":""get_claim_def""}""#.as_bytes());
-        let mut buf = vec![0; 10240];
-        stream.read(&mut buf).unwrap();
-        buf.retain(|&element| element != 0);
-
-        let claim_def_data: ClaimDefinitionData = serde_json::from_str(&String::from_utf8(buf).unwrap()).unwrap();
-
-        let claim_def = ClaimDefinition {
-            issuer_did: ISSUER_DID.to_string(),
-            signature_type: ""CL"".to_string(),
-            schema_seq_no: schema_seq_no,
-            data: claim_def_data
-        };
-
-        let claim_def_json = serde_json::to_string(&claim_def).unwrap();
-
-        //5. Prover create Claim Request
-        let prover_did = ""BzfFCYk"";
-        let claim_req = AnoncredsUtils::prover_create_and_store_claim_req(prover_wallet_handle,
-                                                                          prover_did,
-                                                                          &claim_offer_json,
-                                                                          &claim_def_json,
-                                                                          master_secret_name).unwrap();
-
-        let _ = stream.write(format!(r#""{{""type"":""issue_claim"", ""data"": {}}}""#, claim_req).as_bytes());
-        let mut buf = vec![0; 10240];
-        stream.read(&mut buf).unwrap();
-        let _ = stream.write(r#""{""type"":""close""}""#.as_bytes());
-        buf.retain(|&element| element != 0);
-
-        let mut claim_json: ClaimJson = serde_json::from_str(&String::from_utf8(buf).unwrap()).unwrap();
-        claim_json.schema_seq_no = Some(schema_seq_no);
-        claim_json.issuer_did = Some(ISSUER_DID.to_string());
-
-        // 6. Prover store received Claim
-        AnoncredsUtils::prover_store_claim(prover_wallet_handle, &serde_json::to_string(&claim_json).unwrap()).unwrap();
-
-        // 7. Prover gets Claims for Proof Request
-        let proof_req_json = format!(r#""{{
-                               ""nonce"":""123432421212"",
-                               ""name"":""proof_req_1"",
-                               ""version"":""0.1"",
-                               ""requested_attrs"":{{""attr1_uuid"":{{""schema_seq_no"":{},""name"":""name""}},
-                                                   ""attr2_uuid"":{{""schema_seq_no"":{},""name"":""sex""}}}},
-                               ""requested_predicates"":{{""predicate1_uuid"":{{""attr_name"":""age"",""p_type"":""GE"",""value"":18}}}}
-                            }}""#, schema_seq_no, schema_seq_no);
-
-        let claims_json = AnoncredsUtils::prover_get_claims_for_proof_req(prover_wallet_handle, &proof_req_json).unwrap();
-        let claims: ProofClaimsJson = serde_json::from_str(&claims_json).unwrap();
-        info!(""claims_json: {}"", &claims_json);
-        let claims_for_attr_1 = claims.attrs.get(""attr1_uuid"").unwrap();
-        assert_eq!(1, claims_for_attr_1.len());
-        let claim = claims_for_attr_1[0].clone();
-
-        // 8. Prover create Proof
-        let self_attested_value = ""value"";
-        let requested_claims_json = format!(r#""{{
-                                      ""self_attested_attributes"":{{""self1"":""{}""}},
-                                      ""requested_attrs"":{{""attr1_uuid"":[""{}"",true],
-                                                          ""attr2_uuid"":[""{}"", false]}},
-                                      ""requested_predicates"":{{""predicate1_uuid"":""{}""}}
-                                    }}""#, self_attested_value, claim.claim_uuid, claim.claim_uuid, claim.claim_uuid);
-
-        let schemas_json = format!(r#""{{""{}"":{}}}""#, claim.claim_uuid, schema);
-        let claim_defs_json = format!(r#""{{""{}"":{}}}""#, claim.claim_uuid, claim_def_json);
-        let revoc_regs_jsons = ""{}"";
-
-        let proof_json = AnoncredsUtils::prover_create_proof(prover_wallet_handle,
-                                                             &proof_req_json,
-                                                             &requested_claims_json,
-                                                             &schemas_json,
-                                                             &master_secret_name,
-                                                             &claim_defs_json,
-                                                             &revoc_regs_jsons).unwrap();
-
-        let proof: ProofJson = serde_json::from_str(&proof_json).unwrap();
-
-        let &(_, ref value, _) = proof.requested_proof.revealed_attrs.get(""attr1_uuid"").unwrap();
-        assert_eq!(value, ""Alex"");
-
-        proof.requested_proof.unrevealed_attrs.get(""attr2_uuid"").unwrap();
-
-        let value = proof.requested_proof.self_attested_attrs.get(""self1"").unwrap();
-        assert_eq!(value, self_attested_value);
-
-        // 9. Verifier verify proof
-        let valid = AnoncredsUtils::verifier_verify_proof(&proof_req_json,
-                                                          &proof_json,
-                                                          &schemas_json,
-                                                          &claim_defs_json,
-                                                          &revoc_regs_jsons).unwrap();
-        assert!(valid);
-
-        TestUtils::cleanup_storage();
-    }
-
-    #[cfg(feature = ""interoperability_tests"")]
-    #[test]
-    fn interoperability_test_pyindy_is_verifier() {
-        TestUtils::cleanup_storage();
-
-        let pool_name = ""pool1"";
-        let xtype = ""default"";
-
-        //1. Create Issuer wallet, get wallet handle
-        let issuer_wallet_handle = WalletUtils::create_and_open_wallet(pool_name, Some(xtype)).unwrap();
-
-        //2. Create Prover wallet, get wallet handle
-        let prover_wallet_handle = WalletUtils::create_and_open_wallet(pool_name, Some(xtype)).unwrap();
-
-        //3. Issuer create claim definition
-        let schema_seq_no = 1;
-        let schema = AnoncredsUtils::get_gvt_schema_json(schema_seq_no);
-
-        let claim_def_json = AnoncredsUtils::issuer_create_claim_definition(issuer_wallet_handle, &ISSUER_DID, &schema, None, false).unwrap();
-
-        Command::new(""python3"")
-            .arg(""/home/indy/indy-anoncreds/anoncreds/test/test_interoperability_with_libindy_pyindy_is_verifier.py"")
-            .spawn().expect(""failed to execute process"");
-        thread::sleep(time::Duration::from_millis(3000));
-
-        let mut stream = TcpStream::connect(""127.0.0.1:1234"").unwrap();
-
-        let _ = stream.write(format!(r#""{{""type"":""receive_claim_def"", ""data"": {}}}""#, claim_def_json).as_bytes());
-
-        //4. Prover create Master Secret
-        let master_secret_name = ""prover_master_secret"";
-
-        AnoncredsUtils::prover_create_master_secret(prover_wallet_handle, master_secret_name).unwrap();
-
-        //5. Prover store Claim Offer received from Issuer
-        let claim_offer_json = AnoncredsUtils::get_claim_offer(ISSUER_DID, schema_seq_no);
-
-        AnoncredsUtils::prover_store_claim_offer(prover_wallet_handle, &claim_offer_json).unwrap();
-
-        //6. Prover get Claim Offers
-        let filter_json = format!(r#""{{""issuer_did"":""{}""}}""#, ISSUER_DID);
-
-        let claim_offers_json = AnoncredsUtils::prover_get_claim_offers(prover_wallet_handle, &filter_json).unwrap();
-
-        let claim_offers: Vec<ClaimOffer> = serde_json::from_str(&claim_offers_json).unwrap();
-        assert!(claim_offers.len() == 1);
-        let claim_offer_json = serde_json::to_string(&claim_offers[0]).unwrap();
-
-        //7. Prover create Claim Request
-        let prover_did = ""BzfFCYk"";
-        let claim_req = AnoncredsUtils::prover_create_and_store_claim_req(prover_wallet_handle,
-                                                                          prover_did,
-                                                                          &claim_offer_json,
-                                                                          &claim_def_json,
-                                                                          master_secret_name).unwrap();
-
-        //8. Issuer create Claim
-        let claim_json = AnoncredsUtils::get_gvt_claim_json();
-        let (_, xclaim_json) = AnoncredsUtils::issuer_create_claim(issuer_wallet_handle,
-                                                                   &claim_req,
-                                                                   &claim_json, None).unwrap();
-
-        // 9. Prover store received Claim
-        AnoncredsUtils::prover_store_claim(prover_wallet_handle, &xclaim_json).unwrap();
-
-        let _ = stream.write(r#""{""type"":""get_proof_request""}""#.as_bytes());
-        let mut buf = vec![0; 10240];
-        stream.read(&mut buf).unwrap();
-        buf.retain(|&element| element != 0);
-
-        let proof_req_json = String::from_utf8(buf).unwrap();
-
-        let claims_json = AnoncredsUtils::prover_get_claims_for_proof_req(prover_wallet_handle, &proof_req_json).unwrap();
-        let claims: ProofClaimsJson = serde_json::from_str(&claims_json).unwrap();
-
-        let claims_for_attr = claims.attrs.get(""attr_uuid"").unwrap();
-        assert_eq!(1, claims_for_attr.len());
-        let claim = claims_for_attr[0].clone();
-
-        // 11. Prover create Proof
-        let self_attested_value = ""value"";
-        let requested_claims_json = format!(r#""{{
-                                          ""self_attested_attributes"":{{""self1"":""{}""}},
-                                          ""requested_attrs"":{{""attr_uuid"":[""{}"",true]}},
-                                          ""requested_predicates"":{{""predicate_uuid"":""{}""}}
-                                        }}""#, self_attested_value, claim.claim_uuid, claim.claim_uuid);
-
-        let schemas_json = format!(r#""{{""{}"":{}}}""#, claim.claim_uuid, schema);
-        let claim_defs_json = format!(r#""{{""{}"":{}}}""#, claim.claim_uuid, claim_def_json);
-        let revoc_regs_jsons = ""{}"";
-
-        let proof_json = AnoncredsUtils::prover_create_proof(prover_wallet_handle,
-                                                             &proof_req_json,
-                                                             &requested_claims_json,
-                                                             &schemas_json,
-                                                             &master_secret_name,
-                                                             &claim_defs_json,
-                                                             &revoc_regs_jsons).unwrap();
-
-        let _ = stream.write(format!(r#""{{""type"":""check_proof"", ""data"": {}}}""#, proof_json).as_bytes());
-        let mut buf = vec![0; 102400];
-        stream.read(&mut buf).unwrap();
-        let _ = stream.write(r#""{""type"":""close""}""#.as_bytes());
-        buf.retain(|&element| element != 0);
-
-        let valid = String::from_utf8(buf).unwrap();
-        assert_eq!(""true"", valid);
-
-        TestUtils::cleanup_storage();
-    }
-
-    #[cfg(feature = ""interoperability_tests"")]
-    #[test]
-    fn interoperability_test_pyindy_is_prover() {
-        TestUtils::cleanup_storage();
-
-        let schema_seq_no = 1;
-        let schema = AnoncredsUtils::get_gvt_schema_json(schema_seq_no);
-
-        Command::new(""python3"")
-            .arg(""/home/indy/indy-anoncreds/anoncreds/test/test_interoperability_with_libindy_pyindy_is_prover.py"")
-            .spawn().expect(""failed to execute process"");
-        thread::sleep(time::Duration::from_millis(3000));
-
-        let mut stream = TcpStream::connect(""127.0.0.1:1234"").unwrap();
-
-        let _ = stream.write(r#""{""type"":""get_claim_def""}""#.as_bytes());
-        let mut buf = vec![0; 10240];
-        stream.read(&mut buf).unwrap();
-        buf.retain(|&element| element != 0);
-
-        let claim_def_data: ClaimDefinitionData = serde_json::from_str(&String::from_utf8(buf).unwrap()).unwrap();
-
-        let claim_def = ClaimDefinition {
-            issuer_did: ISSUER_DID.to_string(),
-            signature_type: ""CL"".to_string(),
-            schema_seq_no: schema_seq_no,
-            data: claim_def_data
-        };
-
-        let claim_def_json = serde_json::to_string(&claim_def).unwrap();
-
-        // 7. Prover gets Claims for Proof Request
-        let proof_req_json = format!(r#""{{
-                               ""nonce"":""123432421212"",
-                               ""name"":""proof_req_1"",
-                               ""version"":""0.1"",
-                               ""requested_attrs"":{{""attr_uuid"":{{""schema_seq_no"":{},""name"":""name""}}}},
-                               ""requested_predicates"":{{""predicate_uuid"":{{""attr_name"":""age"",""p_type"":""GE"",""value"":18}}}}
-                            }}""#, schema_seq_no);
-
-        let _ = stream.write(format!(r#""{{""type"":""get_proof"", ""data"": {}}}""#, proof_req_json).as_bytes());
-        let mut buf = vec![0; 102400];
-        stream.read(&mut buf).unwrap();
-        buf.retain(|&element| element != 0);
-
-        let proof: ProofJson = serde_json::from_str(&String::from_utf8(buf).unwrap()).unwrap();
-        println!(""proof: {:?}"", proof);
-
-        let _ = stream.write(r#""{""type"":""close""}""#.as_bytes());
-        let schemas_json = format!(r#""{{""{}"":{}}}""#, 1, schema);
-
-        let &(_, ref value, _) = proof.requested_proof.revealed_attrs.get(""attr_uuid"").unwrap();
-        assert_eq!(value, ""Alex"");
-
-        let proof_json = serde_json::to_string(&proof).unwrap();
-        let claim_defs_json = format!(r#""{{""{}"":{}}}""#, 1, claim_def_json);
-        let revoc_regs_jsons = ""{}"";
-
-        // 9. Verifier verify proof
-        let valid = AnoncredsUtils::verifier_verify_proof(&proof_req_json,
-                                                          &proof_json,
-                                                          &schemas_json,
-                                                          &claim_defs_json,
-                                                          &revoc_regs_jsons).unwrap();
-        assert!(valid);
-
-        TestUtils::cleanup_storage();
-    }
+    //    #[cfg(feature = ""interoperability_tests"")]",,2017-12-18 08:43:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/154912758,https://github.com/hyperledger/indy-sdk/pull/401#discussion_r154912758,jovfer
https://github.com/hyperledger/indy-sdk/pull/401,https://github.com/hyperledger/indy-sdk/pull/401,remove this file from PR,a78f8c6311565239d0b6332037293707432805fa,2017-12-05 11:11:16,154913730,"@@ -0,0 +1,31 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>",1,2017-12-18 08:43:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/154913730,https://github.com/hyperledger/indy-sdk/pull/401#discussion_r154913730,jovfer
https://github.com/hyperledger/indy-sdk/pull/401,https://github.com/hyperledger/indy-sdk/pull/401,Why is it false now?,a78f8c6311565239d0b6332037293707432805fa,2017-12-12 10:56:57,156332633,"@@ -257,7 +258,7 @@ def windowsTesting() {
 def ubuntuTesting() {
     node('ubuntu') {
         stage('Ubuntu Test') {
-            linuxTesting(""ci/ubuntu.dockerfile ci"", ""Ubuntu"", true, ""pool_network"")
+            linuxTesting(""ci/ubuntu.dockerfile ci"", ""Ubuntu"", false, ""pool_network"")",,2017-12-18 08:43:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/156332633,https://github.com/hyperledger/indy-sdk/pull/401#discussion_r156332633,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/401,https://github.com/hyperledger/indy-sdk/pull/401,Please specify what values do we return: encoded or not or both,a78f8c6311565239d0b6332037293707432805fa,2017-12-12 11:04:23,156334368,"@@ -494,7 +494,7 @@ pub extern fn indy_prover_store_claim(command_handle: i32,
 /// #Returns
 /// claims json
 ///     [{
-///         ""claim_uuid"": <string>,
+///         ""referent"": <string>,
 ///         ""attrs"": [{""attr_name"" : ""attr_value""}],",,2017-12-18 08:43:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/156334368,https://github.com/hyperledger/indy-sdk/pull/401#discussion_r156334368,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/401,https://github.com/hyperledger/indy-sdk/pull/401,Please specify how <attr_info> looks like,a78f8c6311565239d0b6332037293707432805fa,2017-12-12 11:04:55,156334467,"@@ -538,26 +538,26 @@ pub extern fn indy_prover_get_claims(command_handle: i32,
 ///         ""name"": string,
 ///         ""version"": string,
 ///         ""nonce"": string,
-///         ""requested_attr1_uuid"": <attr_info>,
-///         ""requested_attr2_uuid"": <attr_info>,
-///         ""requested_attr3_uuid"": <attr_info>,
-///         ""requested_predicate_1_uuid"": <predicate_info>,
-///         ""requested_predicate_2_uuid"": <predicate_info>,
+///         ""requested_attr1_referent"": <attr_info>,",47,2017-12-18 08:43:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/156334467,https://github.com/hyperledger/indy-sdk/pull/401#discussion_r156334467,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/401,https://github.com/hyperledger/indy-sdk/pull/401,Please specify what values do we return: encoded or not or both,a78f8c6311565239d0b6332037293707432805fa,2017-12-12 11:05:30,156334594,"@@ -538,26 +538,26 @@ pub extern fn indy_prover_get_claims(command_handle: i32,
 ///         ""name"": string,
 ///         ""version"": string,
 ///         ""nonce"": string,
-///         ""requested_attr1_uuid"": <attr_info>,
-///         ""requested_attr2_uuid"": <attr_info>,
-///         ""requested_attr3_uuid"": <attr_info>,
-///         ""requested_predicate_1_uuid"": <predicate_info>,
-///         ""requested_predicate_2_uuid"": <predicate_info>,
+///         ""requested_attr1_referent"": <attr_info>,
+///         ""requested_attr2_referent"": <attr_info>,
+///         ""requested_attr3_referent"": <attr_info>,
+///         ""requested_predicate_1_referent"": <predicate_info>,
+///         ""requested_predicate_2_referent"": <predicate_info>,
 ///     }
 /// cb: Callback that takes command result as parameter.
 ///
 /// #Returns
 /// json with claims for the given pool request.
-/// Claim consists of uuid, human-readable attributes (key-value map), schema_seq_no, issuer_did and revoc_reg_seq_no.
+/// Claim consists of referent, human-readable attributes (key-value map), schema_seq_no, issuer_did and revoc_reg_seq_no.
 ///     {
-///         ""requested_attr1_uuid"": [claim1, claim2],
-///         ""requested_attr2_uuid"": [],
-///         ""requested_attr3_uuid"": [claim3],
-///         ""requested_predicate_1_uuid"": [claim1, claim3],
-///         ""requested_predicate_2_uuid"": [claim2],
+///         ""requested_attr1_referent"": [claim1, claim2],
+///         ""requested_attr2_referent"": [],
+///         ""requested_attr3_referent"": [claim3],
+///         ""requested_predicate_1_referent"": [claim1, claim3],
+///         ""requested_predicate_2_referent"": [claim2],
 ///     }, where claim is
 ///     {
-///         ""claim_uuid"": <string>,
+///         ""referent"": <string>,
 ///         ""attrs"": [{""attr_name"" : ""attr_value""}],",,2017-12-18 08:43:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/156334594,https://github.com/hyperledger/indy-sdk/pull/401#discussion_r156334594,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/401,https://github.com/hyperledger/indy-sdk/pull/401,Please specify what values do we return: encoded or not or both,a78f8c6311565239d0b6332037293707432805fa,2017-12-12 11:05:41,156334638,"@@ -607,43 +607,58 @@ pub extern fn indy_prover_get_claims_for_proof_req(command_handle: i32,
 /// proof_req_json: proof request json as come from the verifier
 ///     {
 ///         ""nonce"": string,
-///         ""requested_attr1_uuid"": <attr_info>,
-///         ""requested_attr2_uuid"": <attr_info>,
-///         ""requested_attr3_uuid"": <attr_info>,
-///         ""requested_predicate_1_uuid"": <predicate_info>,
-///         ""requested_predicate_2_uuid"": <predicate_info>,
+///         ""requested_attr1_referent"": <attr_info>,",47,2017-12-18 08:43:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/156334638,https://github.com/hyperledger/indy-sdk/pull/401#discussion_r156334638,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/401,https://github.com/hyperledger/indy-sdk/pull/401,Probably it's better to specify a list of issuer DIDs for **each** schema_seq_no?,a78f8c6311565239d0b6332037293707432805fa,2017-12-12 11:08:43,156335325,"@@ -607,43 +607,58 @@ pub extern fn indy_prover_get_claims_for_proof_req(command_handle: i32,
 /// proof_req_json: proof request json as come from the verifier
 ///     {
 ///         ""nonce"": string,
-///         ""requested_attr1_uuid"": <attr_info>,
-///         ""requested_attr2_uuid"": <attr_info>,
-///         ""requested_attr3_uuid"": <attr_info>,
-///         ""requested_predicate_1_uuid"": <predicate_info>,
-///         ""requested_predicate_2_uuid"": <predicate_info>,
+///         ""requested_attr1_referent"": <attr_info>,
+///         ""requested_attr2_referent"": <attr_info>,
+///         ""requested_attr3_referent"": <attr_info>,
+///         ""requested_predicate_1_referent"": <predicate_info>,
+///         ""requested_predicate_2_referent"": <predicate_info>,
 ///     }
 /// requested_claims_json: either a claim or self-attested attribute for each requested attribute
 ///     {
-///         ""requested_attr1_uuid"": [claim1_uuid_in_wallet, true <reveal_attr>],
-///         ""requested_attr2_uuid"": [self_attested_attribute],
-///         ""requested_attr3_uuid"": [claim2_seq_no_in_wallet, false]
-///         ""requested_attr4_uuid"": [claim2_seq_no_in_wallet, true]
-///         ""requested_predicate_1_uuid"": [claim2_seq_no_in_wallet],
-///         ""requested_predicate_2_uuid"": [claim3_seq_no_in_wallet],
+///         ""requested_attr1_referent"": [claim1_referent_in_wallet, true <reveal_attr>],
+///         ""requested_attr2_referent"": [self_attested_attribute],
+///         ""requested_attr3_referent"": [claim2_seq_no_in_wallet, false]
+///         ""requested_attr4_referent"": [claim2_seq_no_in_wallet, true]
+///         ""requested_predicate_1_referent"": [claim2_seq_no_in_wallet],
+///         ""requested_predicate_2_referent"": [claim3_seq_no_in_wallet],
 ///     }
 /// schemas_jsons: all schema jsons participating in the proof request
 ///     {
-///         ""claim1_uuid_in_wallet"": <schema1>,
-///         ""claim2_uuid_in_wallet"": <schema2>,
-///         ""claim3_uuid_in_wallet"": <schema3>,
+///         ""claim1_referent_in_wallet"": <schema1>,
+///         ""claim2_referent_in_wallet"": <schema2>,
+///         ""claim3_referent_in_wallet"": <schema3>,
 ///     }
 ///
 /// master_secret_name: the name of the master secret stored in the wallet
 /// claim_def_jsons: all claim definition jsons participating in the proof request
 ///     {
-///         ""claim1_uuid_in_wallet"": <claim_def1>,
-///         ""claim2_uuid_in_wallet"": <claim_def2>,
-///         ""claim3_uuid_in_wallet"": <claim_def3>,
+///         ""claim1_referent_in_wallet"": <claim_def1>,
+///         ""claim2_referent_in_wallet"": <claim_def2>,
+///         ""claim3_referent_in_wallet"": <claim_def3>,
 ///     }
 /// revoc_regs_jsons: all revocation registry jsons participating in the proof request
 ///     {
-///         ""claim1_uuid_in_wallet"": <revoc_reg1>,
-///         ""claim2_uuid_in_wallet"": <revoc_reg2>,
-///         ""claim3_uuid_in_wallet"": <revoc_reg3>,
+///         ""claim1_referent_in_wallet"": <revoc_reg1>,
+///         ""claim2_referent_in_wallet"": <revoc_reg2>,
+///         ""claim3_referent_in_wallet"": <revoc_reg3>,
 ///     }
 /// cb: Callback that takes command result as parameter.
 ///
+/// where attr_info:
+///     {
+///         ""name"": attribute name,
+///         ""schemas_seq_no"": a list of schema sequence numbers allowed for proving of the attribute",,2017-12-18 08:43:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/156335325,https://github.com/hyperledger/indy-sdk/pull/401#discussion_r156335325,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/401,https://github.com/hyperledger/indy-sdk/pull/401,Did we rename GE to something else?,a78f8c6311565239d0b6332037293707432805fa,2017-12-12 11:09:29,156335493,"@@ -607,43 +607,58 @@ pub extern fn indy_prover_get_claims_for_proof_req(command_handle: i32,
 /// proof_req_json: proof request json as come from the verifier
 ///     {
 ///         ""nonce"": string,
-///         ""requested_attr1_uuid"": <attr_info>,
-///         ""requested_attr2_uuid"": <attr_info>,
-///         ""requested_attr3_uuid"": <attr_info>,
-///         ""requested_predicate_1_uuid"": <predicate_info>,
-///         ""requested_predicate_2_uuid"": <predicate_info>,
+///         ""requested_attr1_referent"": <attr_info>,
+///         ""requested_attr2_referent"": <attr_info>,
+///         ""requested_attr3_referent"": <attr_info>,
+///         ""requested_predicate_1_referent"": <predicate_info>,
+///         ""requested_predicate_2_referent"": <predicate_info>,
 ///     }
 /// requested_claims_json: either a claim or self-attested attribute for each requested attribute
 ///     {
-///         ""requested_attr1_uuid"": [claim1_uuid_in_wallet, true <reveal_attr>],
-///         ""requested_attr2_uuid"": [self_attested_attribute],
-///         ""requested_attr3_uuid"": [claim2_seq_no_in_wallet, false]
-///         ""requested_attr4_uuid"": [claim2_seq_no_in_wallet, true]
-///         ""requested_predicate_1_uuid"": [claim2_seq_no_in_wallet],
-///         ""requested_predicate_2_uuid"": [claim3_seq_no_in_wallet],
+///         ""requested_attr1_referent"": [claim1_referent_in_wallet, true <reveal_attr>],
+///         ""requested_attr2_referent"": [self_attested_attribute],
+///         ""requested_attr3_referent"": [claim2_seq_no_in_wallet, false]
+///         ""requested_attr4_referent"": [claim2_seq_no_in_wallet, true]
+///         ""requested_predicate_1_referent"": [claim2_seq_no_in_wallet],
+///         ""requested_predicate_2_referent"": [claim3_seq_no_in_wallet],
 ///     }
 /// schemas_jsons: all schema jsons participating in the proof request
 ///     {
-///         ""claim1_uuid_in_wallet"": <schema1>,
-///         ""claim2_uuid_in_wallet"": <schema2>,
-///         ""claim3_uuid_in_wallet"": <schema3>,
+///         ""claim1_referent_in_wallet"": <schema1>,
+///         ""claim2_referent_in_wallet"": <schema2>,
+///         ""claim3_referent_in_wallet"": <schema3>,
 ///     }
 ///
 /// master_secret_name: the name of the master secret stored in the wallet
 /// claim_def_jsons: all claim definition jsons participating in the proof request
 ///     {
-///         ""claim1_uuid_in_wallet"": <claim_def1>,
-///         ""claim2_uuid_in_wallet"": <claim_def2>,
-///         ""claim3_uuid_in_wallet"": <claim_def3>,
+///         ""claim1_referent_in_wallet"": <claim_def1>,
+///         ""claim2_referent_in_wallet"": <claim_def2>,
+///         ""claim3_referent_in_wallet"": <claim_def3>,
 ///     }
 /// revoc_regs_jsons: all revocation registry jsons participating in the proof request
 ///     {
-///         ""claim1_uuid_in_wallet"": <revoc_reg1>,
-///         ""claim2_uuid_in_wallet"": <revoc_reg2>,
-///         ""claim3_uuid_in_wallet"": <revoc_reg3>,
+///         ""claim1_referent_in_wallet"": <revoc_reg1>,
+///         ""claim2_referent_in_wallet"": <revoc_reg2>,
+///         ""claim3_referent_in_wallet"": <revoc_reg3>,
 ///     }
 /// cb: Callback that takes command result as parameter.
 ///
+/// where attr_info:
+///     {
+///         ""name"": attribute name,
+///         ""schemas_seq_no"": a list of schema sequence numbers allowed for proving of the attribute
+///         ""issuer_dids"":  a list of issuer dids allowed for proving of the attribute
+///     }
+/// predicate_info:
+///     {
+///         ""attr_name"": attribute name,
+///         ""p_type"": predicate type (Currently GE only)",,2017-12-18 08:43:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/156335493,https://github.com/hyperledger/indy-sdk/pull/401#discussion_r156335493,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/401,https://github.com/hyperledger/indy-sdk/pull/401,We need to rename GE to something more human readable?,a78f8c6311565239d0b6332037293707432805fa,2017-12-12 11:10:42,156335743,"@@ -1,242 +1,45 @@
-extern crate rand;
-extern crate openssl;
 extern crate indy_crypto;
 
 use errors::common::CommonError;
 
-use services::anoncreds::constants::LARGE_MVECT;
-use utils::crypto::bn::BigNumber;
-use std::hash::Hash;
-use std::cmp::max;
-use std::collections::HashMap;
-use self::indy_crypto::pair::{GroupOrderElement, PointG1, Pair};
+use services::anoncreds::types::PredicateInfo;
+use self::indy_crypto::cl::{issuer, verifier, ClaimSchema, ClaimValues, SubProofRequest};
 
-#[cfg(not(test))]
-pub fn random_qr(n: &BigNumber) -> Result<BigNumber, CommonError> {
-    let random = n
-        .rand_range()?
-        .sqr(None)?
-        .modulus(&n, None)?;
-    Ok(random)
-}
-
-#[cfg(test)]
-pub fn random_qr(n: &BigNumber) -> Result<BigNumber, CommonError> {
-    Ok(BigNumber::from_dec(""64684820421150545443421261645532741305438158267230326415141505826951816460650437611148133267480407958360035501128469885271549378871140475869904030424615175830170939416512594291641188403335834762737251794282186335118831803135149622404791467775422384378569231649224208728902565541796896860352464500717052768431523703881746487372385032277847026560711719065512366600220045978358915680277126661923892187090579302197390903902744925313826817940566429968987709582805451008234648959429651259809188953915675063700676546393568304468609062443048457324721450190021552656280473128156273976008799243162970386898307404395608179975243"")?)
-}
-
-pub fn bitwise_or_big_int(a: &BigNumber, b: &BigNumber) -> Result<BigNumber, CommonError> {
-    let significant_bits = max(a.num_bits()?, b.num_bits()?);
-    let mut result = BigNumber::new()?;
-    for i in 0..significant_bits {
-        if a.is_bit_set(i)? || b.is_bit_set(i)? {
-            result.set_bit(i)?;
-        }
-    }
-    Ok(result)
-}
-
-//Byte order: Little
-pub fn transform_u32_to_array_of_u8(x: u32) -> Vec<u8> {
-    let mut result: Vec<u8> = Vec::new();
-    for i in (0..4).rev() {
-        result.push((x >> i * 8) as u8);
-    }
-    result
-}
-
-pub fn get_hash_as_int(nums: &mut Vec<Vec<u8>>) -> Result<BigNumber, CommonError> {
-    nums.sort();
-
-    let mut hashed_array: Vec<u8> = BigNumber::hash_array(&nums)?;
-    hashed_array.reverse();
-
-    BigNumber::from_bytes(&hashed_array[..])
-}
-
-pub fn get_mtilde(unrevealed_attrs: &Vec<String>)
-                  -> Result<HashMap<String, BigNumber>, CommonError> {
-    let mut mtilde: HashMap<String, BigNumber> = HashMap::new();
-
-    for attr in unrevealed_attrs.iter() {
-        mtilde.insert(attr.clone(), BigNumber::rand(LARGE_MVECT)?);
-    }
-    Ok(mtilde)
-}
-
-fn largest_square_less_than(delta: usize) -> usize {
-    (delta as f64).sqrt().floor() as usize
-}
-
-pub fn four_squares(delta: i32) -> Result<HashMap<String, BigNumber>, CommonError> {
-    if delta < 0 {
-        return Err(CommonError::InvalidStructure(format!(""Cannot get the four squares for delta {} "", delta)));
-    }
-
-    let d = delta as usize;
-    let mut roots: [usize; 4] = [largest_square_less_than(d), 0, 0, 0];
-
-    'outer: for i in (1 .. roots[0] + 1).rev() {
-        roots[0] = i;
-        if d == roots[0].pow(2) {
-            roots[1] = 0;
-            roots[2] = 0;
-            roots[3] = 0;
-            break 'outer;
-        }
-        roots[1] = largest_square_less_than(d - roots[0].pow(2));
-        for j in (1 .. roots[1] + 1).rev() {
-            roots[1] = j;
-            if d == roots[0].pow(2) + roots[1].pow(2) {
-                roots[2] = 0;
-                roots[3] = 0;
-                break 'outer;
-            }
-            roots[2] = largest_square_less_than(d - roots[0].pow(2) - roots[1].pow(2));
-            for k in (1 .. roots[2] + 1).rev() {
-                roots[2] = k;
-                if d == roots[0].pow(2) + roots[1].pow(2) + roots[2].pow(2) {
-                    roots[3] = 0;
-                    break 'outer;
-                }
-                roots[3] = largest_square_less_than(d - roots[0].pow(2) - roots[1].pow(2) - roots[2].pow(2));
-                if d == roots[0].pow(2) + roots[1].pow(2) + roots[2].pow(2) + roots[3].pow(2) {
-                    break 'outer;
-                }
-            }
-        }
-    }
-
-    let mut res: HashMap<String, BigNumber> = HashMap::new();
-    res.insert(""0"".to_string(), BigNumber::from_dec(&roots[0].to_string()[..])?);
-    res.insert(""1"".to_string(), BigNumber::from_dec(&roots[1].to_string()[..])?);
-    res.insert(""2"".to_string(), BigNumber::from_dec(&roots[2].to_string()[..])?);
-    res.insert(""3"".to_string(), BigNumber::from_dec(&roots[3].to_string()[..])?);
-
-    Ok(res)
-}
-
-
-pub trait BytesView {
-    fn to_bytes(&self) -> Result<Vec<u8>, CommonError>;
-}
+use std::collections::{HashSet, HashMap};
 
-impl BytesView for PointG1 {
-    fn to_bytes(&self) -> Result<Vec<u8>, CommonError> {
-        Ok(self.to_bytes()?)
-    }
-}
-
-impl BytesView for GroupOrderElement {
-    fn to_bytes(&self) -> Result<Vec<u8>, CommonError> {
-        Ok(self.to_bytes()?)
-    }
+pub fn get_composite_id(issuer_did: &str, schema_seq_no: i32) -> String {
+    issuer_did.to_string() + "":"" + &schema_seq_no.to_string()
 }
 
-impl BytesView for Pair {
-    fn to_bytes(&self) -> Result<Vec<u8>, CommonError> {
-        Ok(self.to_bytes()?)
+pub fn build_claim_schema(attrs: &HashSet<String>) -> Result<ClaimSchema, CommonError> {
+    let mut claim_schema_builder = issuer::Issuer::new_claim_schema_builder()?;
+    for attr in attrs {
+        claim_schema_builder.add_attr(&attr)?;
     }
+    Ok(claim_schema_builder.finalize()?)
 }
 
-pub trait AppendByteArray {
-    fn append_vec<T: BytesView>(&mut self, other: &Vec<T>) -> Result<(), CommonError>;
-}
+pub fn build_claim_values(claim_values: &HashMap<String, Vec<String>>) -> Result<ClaimValues, CommonError> {
+    let mut claim_values_builder = issuer::Issuer::new_claim_values_builder()?;
+    for (attr, values) in claim_values {
+        let dec_val = values.get(1)
+            .ok_or(CommonError::InvalidStructure(format!(""Encoded value not found"")))?;
 
-impl AppendByteArray for Vec<Vec<u8>> {
-    fn append_vec<T: BytesView>(&mut self, other: &Vec<T>) -> Result<(), CommonError> {
-        for el in other.iter() {
-            self.push(el.to_bytes()?);
-        }
-        Ok(())
+        claim_values_builder.add_value(&attr, &dec_val)?;
     }
+    Ok(claim_values_builder.finalize()?)
 }
 
-pub fn clone_bignum_map<K: Clone + Eq + Hash>(other: &HashMap<K, BigNumber>)
-                                              -> Result<HashMap<K, BigNumber>, CommonError> {
-    let mut res: HashMap<K, BigNumber> = HashMap::new();
-    for (k, v) in other {
-        res.insert(k.clone(), v.clone()?);
-    }
-    Ok(res)
-}
-
-pub fn group_element_to_bignum(el: &GroupOrderElement) -> Result<BigNumber, CommonError> {
-    Ok(BigNumber::from_bytes(&el.to_bytes()?)?)
-}
-
-pub fn bignum_to_group_element(num: &BigNumber) -> Result<GroupOrderElement, CommonError> {
-    Ok(GroupOrderElement::from_bytes(&num.to_bytes()?)?)
-}
-
-pub fn get_composite_id(issuer_did: &str, schema_seq_no: i32) -> String {
-    issuer_did.to_string() + "":"" + &schema_seq_no.to_string()
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
+pub fn build_sub_proof_request(attrs_for_claim: &Vec<String>, predicates_for_claim: &Vec<PredicateInfo>) -> Result<SubProofRequest, CommonError> {
+    let mut sub_proof_request_builder = verifier::Verifier::new_sub_proof_request_builder()?;
 
-    #[test]
-    fn bitwise_or_big_int_works() {
-        let a = BigNumber::from_dec(""778378032744961463933002553964902776831187587689736807008034459507677878432383414623740074"");
-        let b = BigNumber::from_dec(""1018517988167243043134222844204689080525734196832968125318070224677190649881668353091698688"");
-        let result = BigNumber::from_dec(""1796896020912204507067225398169591857356921784522704932326104684184868528314051767715438762"");
-        assert_eq!(result.unwrap(), bitwise_or_big_int(&a.unwrap(), &b.unwrap()).unwrap());
+    for attr in attrs_for_claim {
+        sub_proof_request_builder.add_revealed_attr(&attr)?
     }
 
-    #[test]
-    fn get_hash_as_int_works() {
-        let mut nums = vec![
-            BigNumber::from_hex(""ff9d2eedfee9cffd9ef6dbffedff3fcbef4caecb9bffe79bfa94d3fdf6abfbff"").unwrap().to_bytes().unwrap(),
-            BigNumber::from_hex(""ff9d2eedfee9cffd9ef6dbffedff3fcbef4caecb9bffe79bfa9168615ccbc546"").unwrap().to_bytes().unwrap()
-        ];
-        let res = get_hash_as_int(&mut nums);
-
-        assert!(res.is_ok());
-        assert_eq!(""9E2A0653691B96A9B55B3D1133F9FEE2F2C37B848DBADF2F70DFFFE9E47C5A5D"", res.unwrap().to_hex().unwrap());
+    for predicate in predicates_for_claim {
+        sub_proof_request_builder.add_predicate(&predicate.attr_name, ""GE"", predicate.value)?;",220,2017-12-18 08:43:25,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/156335743,https://github.com/hyperledger/indy-sdk/pull/401#discussion_r156335743,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/392,https://github.com/hyperledger/indy-sdk/pull/392,@srottem @vimmerru should we move it to hyperledger.github.io ?,f7de26138b964cb0b2d565825b4b917fa8a1e78b,2017-11-24 09:23:56,152925480,"@@ -7,6 +7,10 @@ The wrapper is designed to be platform independent and targets the .NET Standard
 
 Pull requests welcome!
 
+### Documentation
+
+Documentation for the .NET wrapper is available [here](https://srottem.github.io/indy-sdk/wrappers/dotnet/docs/index.html).",,2018-03-27 23:14:12,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/152925480,https://github.com/hyperledger/indy-sdk/pull/392#discussion_r152925480,jovfer
https://github.com/hyperledger/indy-sdk/pull/392,https://github.com/hyperledger/indy-sdk/pull/392,I asked about hosting the docs a couple of months back on Rochetchat. I never got an answer so pursued a solution myself. I have no objection to it being moved but I do want it live somewhere it can be linked to from the project page.  ,f7de26138b964cb0b2d565825b4b917fa8a1e78b,2017-11-25 00:57:40,153035073,"@@ -7,6 +7,10 @@ The wrapper is designed to be platform independent and targets the .NET Standard
 
 Pull requests welcome!
 
+### Documentation
+
+Documentation for the .NET wrapper is available [here](https://srottem.github.io/indy-sdk/wrappers/dotnet/docs/index.html).",,2018-03-27 23:14:12,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/153035073,https://github.com/hyperledger/indy-sdk/pull/392#discussion_r153035073,srottem
https://github.com/hyperledger/indy-sdk/pull/392,https://github.com/hyperledger/indy-sdk/pull/392,@vimmerru @ashcherbakov ^,f7de26138b964cb0b2d565825b4b917fa8a1e78b,2017-11-27 13:39:27,153197884,"@@ -7,6 +7,10 @@ The wrapper is designed to be platform independent and targets the .NET Standard
 
 Pull requests welcome!
 
+### Documentation
+
+Documentation for the .NET wrapper is available [here](https://srottem.github.io/indy-sdk/wrappers/dotnet/docs/index.html).",,2018-03-27 23:14:12,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/153197884,https://github.com/hyperledger/indy-sdk/pull/392#discussion_r153197884,jovfer
https://github.com/hyperledger/indy-sdk/pull/392,https://github.com/hyperledger/indy-sdk/pull/392,For me it looks much better to store documentation and wrapper code in one repo. I don't see problems in merging of  dotnet/docs/* to main repo.,f7de26138b964cb0b2d565825b4b917fa8a1e78b,2017-11-27 15:17:27,153224935,"@@ -7,6 +7,10 @@ The wrapper is designed to be platform independent and targets the .NET Standard
 
 Pull requests welcome!
 
+### Documentation
+
+Documentation for the .NET wrapper is available [here](https://srottem.github.io/indy-sdk/wrappers/dotnet/docs/index.html).",,2018-03-27 23:14:12,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/153224935,https://github.com/hyperledger/indy-sdk/pull/392#discussion_r153224935,vimmerru
https://github.com/hyperledger/indy-sdk/pull/392,https://github.com/hyperledger/indy-sdk/pull/392,The way I've approched it on my repo is to segregate the generated documentation into a separate branch named gh-pages so that it doesn't pollute the codebase but is available as github.io pages.  The project has code for *generating* the documentation already under dotnet/indy-sdk-dotnet-doc.  Just an FYI.,f7de26138b964cb0b2d565825b4b917fa8a1e78b,2017-11-27 21:58:33,153336333,"@@ -7,6 +7,10 @@ The wrapper is designed to be platform independent and targets the .NET Standard
 
 Pull requests welcome!
 
+### Documentation
+
+Documentation for the .NET wrapper is available [here](https://srottem.github.io/indy-sdk/wrappers/dotnet/docs/index.html).",,2018-03-27 23:14:12,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/153336333,https://github.com/hyperledger/indy-sdk/pull/392#discussion_r153336333,srottem
https://github.com/hyperledger/indy-sdk/pull/392,https://github.com/hyperledger/indy-sdk/pull/392,I've added the generated docs to the branch and updated the readme.md to link to the hyperledger.github.io page.  The indy-sdk repo will need to be configured to enable Github Pages on the master branch.  ,f7de26138b964cb0b2d565825b4b917fa8a1e78b,2017-11-29 11:39:39,153763467,"@@ -7,6 +7,10 @@ The wrapper is designed to be platform independent and targets the .NET Standard
 
 Pull requests welcome!
 
+### Documentation
+
+Documentation for the .NET wrapper is available [here](https://srottem.github.io/indy-sdk/wrappers/dotnet/docs/index.html).",,2018-03-27 23:14:12,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/153763467,https://github.com/hyperledger/indy-sdk/pull/392#discussion_r153763467,srottem
https://github.com/hyperledger/indy-sdk/pull/385,https://github.com/hyperledger/indy-sdk/pull/385,Please add comment about reason to set libsodium from url. (non-last 1.0.12 version required),45c1798bb443e762a541a1d29ad444b93061a115,2017-11-16 16:21:08,151463754,"@@ -5,7 +5,7 @@
 
    ```
    brew install pkg-config
-   brew install libsodium
+   brew install https://raw.githubusercontent.com/Homebrew/homebrew-core/65effd2b617bade68a8a2c5b39e1c3089cc0e945/Formula/libsodium.rb   ",10,2017-12-15 16:14:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/151463754,https://github.com/hyperledger/indy-sdk/pull/385#discussion_r151463754,jovfer
https://github.com/hyperledger/indy-sdk/pull/385,https://github.com/hyperledger/indy-sdk/pull/385,done!,45c1798bb443e762a541a1d29ad444b93061a115,2017-11-16 16:58:16,151475012,"@@ -5,7 +5,7 @@
 
    ```
    brew install pkg-config
-   brew install libsodium
+   brew install https://raw.githubusercontent.com/Homebrew/homebrew-core/65effd2b617bade68a8a2c5b39e1c3089cc0e945/Formula/libsodium.rb   ",10,2017-12-15 16:14:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/151475012,https://github.com/hyperledger/indy-sdk/pull/385#discussion_r151475012,deerdear
https://github.com/hyperledger/indy-sdk/pull/360,https://github.com/hyperledger/indy-sdk/pull/360,remove error from function signature result,8aa3eef6b7af50032bad869e10301f6072067bec,2017-11-03 09:06:37,148732428,"@@ -194,7 +194,7 @@ impl TransactionHandler {
                         signature,
                         participants.as_slice(),
                         &value,
-                        self.nodes.as_slice(), self.f, &self.gen);
+                        self.nodes.as_slice(), self.f, &self.gen)?;",,2017-11-03 13:34:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/148732428,https://github.com/hyperledger/indy-sdk/pull/360#discussion_r148732428,jovfer
https://github.com/hyperledger/indy-sdk/pull/360,https://github.com/hyperledger/indy-sdk/pull/360,rm printline,8aa3eef6b7af50032bad869e10301f6072067bec,2017-11-03 09:06:46,148732452,"@@ -533,31 +533,44 @@ impl PoolWorker {
 
         let ctx: zmq::Context = zmq::Context::new();
         let key_pair = zmq::CurveKeyPair::new()?;
-        for gen_txn in &merkle_tree {
-            let gen_txn_num = rmp_serde::decode::from_slice::<GenTransaction<u32>>(gen_txn.as_slice());
-            let gen_txn_str = rmp_serde::decode::from_slice::<GenTransaction<String>>(gen_txn.as_slice());
-
-            let rn = if let Ok(gen_txn) = gen_txn_num {
-                RemoteNode::new(&gen_txn)
-            } else if let Ok(gen_txn) = gen_txn_str {
-                RemoteNode::new(&gen_txn)
-            } else {
-                warn!(""MerkleTree contains invalid data:\n{:?}\n{:?}"",
-                            gen_txn_str.unwrap_err(), gen_txn_num.unwrap_err());
-                continue;
-            };
-            let mut rn = rn.map_err(map_err_trace!())?;
-            rn.connect(&ctx, &key_pair)?;
-            rn.send_str(""pi"")?;
-            self.handler.nodes_mut().push(rn);
+
+        let gen_tnxs = PoolWorker::_build_node_state(&merkle_tree)?;
+
+        for (_, gen_txn) in &gen_tnxs {
+            let mut rn: RemoteNode = RemoteNode::new(&gen_txn)?;
+            if rn.zaddr.is_some() {
+                println!(""gen_txn {:?}"", gen_txn);",,2017-11-03 13:34:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/148732452,https://github.com/hyperledger/indy-sdk/pull/360#discussion_r148732452,jovfer
https://github.com/hyperledger/indy-sdk/pull/360,https://github.com/hyperledger/indy-sdk/pull/360,"filter VALIDATORs, address",8aa3eef6b7af50032bad869e10301f6072067bec,2017-11-03 09:06:59,148732485,"@@ -533,31 +533,44 @@ impl PoolWorker {
 
         let ctx: zmq::Context = zmq::Context::new();
         let key_pair = zmq::CurveKeyPair::new()?;
-        for gen_txn in &merkle_tree {
-            let gen_txn_num = rmp_serde::decode::from_slice::<GenTransaction<u32>>(gen_txn.as_slice());
-            let gen_txn_str = rmp_serde::decode::from_slice::<GenTransaction<String>>(gen_txn.as_slice());
-
-            let rn = if let Ok(gen_txn) = gen_txn_num {
-                RemoteNode::new(&gen_txn)
-            } else if let Ok(gen_txn) = gen_txn_str {
-                RemoteNode::new(&gen_txn)
-            } else {
-                warn!(""MerkleTree contains invalid data:\n{:?}\n{:?}"",
-                            gen_txn_str.unwrap_err(), gen_txn_num.unwrap_err());
-                continue;
-            };
-            let mut rn = rn.map_err(map_err_trace!())?;
-            rn.connect(&ctx, &key_pair)?;
-            rn.send_str(""pi"")?;
-            self.handler.nodes_mut().push(rn);
+
+        let gen_tnxs = PoolWorker::_build_node_state(&merkle_tree)?;
+
+        for (_, gen_txn) in &gen_tnxs {
+            let mut rn: RemoteNode = RemoteNode::new(&gen_txn)?;",,2017-11-03 13:34:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/148732485,https://github.com/hyperledger/indy-sdk/pull/360#discussion_r148732485,jovfer
https://github.com/hyperledger/indy-sdk/pull/360,https://github.com/hyperledger/indy-sdk/pull/360,try if let Some,8aa3eef6b7af50032bad869e10301f6072067bec,2017-11-03 09:09:23,148732879,"@@ -533,31 +533,44 @@ impl PoolWorker {
 
         let ctx: zmq::Context = zmq::Context::new();
         let key_pair = zmq::CurveKeyPair::new()?;
-        for gen_txn in &merkle_tree {
-            let gen_txn_num = rmp_serde::decode::from_slice::<GenTransaction<u32>>(gen_txn.as_slice());
-            let gen_txn_str = rmp_serde::decode::from_slice::<GenTransaction<String>>(gen_txn.as_slice());
-
-            let rn = if let Ok(gen_txn) = gen_txn_num {
-                RemoteNode::new(&gen_txn)
-            } else if let Ok(gen_txn) = gen_txn_str {
-                RemoteNode::new(&gen_txn)
-            } else {
-                warn!(""MerkleTree contains invalid data:\n{:?}\n{:?}"",
-                            gen_txn_str.unwrap_err(), gen_txn_num.unwrap_err());
-                continue;
-            };
-            let mut rn = rn.map_err(map_err_trace!())?;
-            rn.connect(&ctx, &key_pair)?;
-            rn.send_str(""pi"")?;
-            self.handler.nodes_mut().push(rn);
+
+        let gen_tnxs = PoolWorker::_build_node_state(&merkle_tree)?;
+
+        for (_, gen_txn) in &gen_tnxs {
+            let mut rn: RemoteNode = RemoteNode::new(&gen_txn)?;
+            if rn.zaddr.is_some() {
+                println!(""gen_txn {:?}"", gen_txn);
+                rn.connect(&ctx, &key_pair)?;
+                rn.send_str(""pi"")?;
+                self.handler.nodes_mut().push(rn);
+            }
         }
-        self.handler.set_f(PoolWorker::get_f(merkle_tree.count())); //TODO set cnt to connect
+
+        let cnt = self.handler.nodes().len();
+        self.handler.set_f(PoolWorker::get_f(cnt)); //TODO set cnt to connect
         if let PoolWorkerHandler::CatchupHandler(ref mut handler) = self.handler {
             handler.reset_nodes_votes();
         }
         Ok(())
     }
 
+    fn _build_node_state(merkle_tree: &MerkleTree) -> Result<HashMap<String, NodeTransaction>, CommonError> {
+        let mut gen_tnxs: HashMap<String, NodeTransaction> = HashMap::new();
+
+        for gen_txn in merkle_tree {
+            let mut gen_txn: NodeTransaction = rmp_serde::decode::from_slice(gen_txn.as_slice())
+                .map_err(|e|
+                    CommonError::InvalidState(format!(""MerkleTree contains invalid data {:?}"", e)))?;
+
+            if gen_tnxs.contains_key(&gen_txn.dest) {",116,2017-11-03 13:34:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/148732879,https://github.com/hyperledger/indy-sdk/pull/360#discussion_r148732879,jovfer
https://github.com/hyperledger/indy-sdk/pull/360,https://github.com/hyperledger/indy-sdk/pull/360,assert dests,8aa3eef6b7af50032bad869e10301f6072067bec,2017-11-03 09:21:03,148734827,"@@ -7,42 +8,94 @@ use std::collections::HashMap;
 use std::hash::{Hash, Hasher};
 use super::zmq;
 use errors::common::CommonError;
+use utils::crypto::verkey_builder::build_full_verkey;
 
 use self::indy_crypto::bls;
 
 use services::ledger::merkletree::merkletree::MerkleTree;
 use utils::json::{JsonDecodable, JsonEncodable};
 
+
 #[derive(Serialize, Deserialize, Debug, Eq, PartialEq)]
-pub struct NodeData<T> {
+pub struct NodeData {
     pub alias: String,
-    pub client_ip: String,
-    pub client_port: T,
-    pub node_ip: String,
-    pub node_port: T,
-    pub services: Vec<String>,
-    pub blskey: String
+    pub client_ip: Option<String>,
+    #[serde(deserialize_with = ""string_or_number"")]
+    #[serde(default)]
+    pub client_port: Option<u64>,
+    pub node_ip: Option<String>,
+    #[serde(deserialize_with = ""string_or_number"")]
+    #[serde(default)]
+    pub node_port: Option<u64>,
+    pub services: Option<Vec<String>>,
+    pub blskey: Option<String>
+}
+
+fn string_or_number<'de, D>(deserializer: D) -> Result<Option<u64>, D::Error>
+    where D: serde::Deserializer<'de>
+{
+    let deser_res: Result<serde_json::Value, _> = serde::Deserialize::deserialize(deserializer);
+    match deser_res {
+        Ok(serde_json::Value::String(s)) => match s.parse::<u64>() {
+            Ok(num) => Ok(Some(num)),
+            Err(err) => Err(serde::de::Error::custom(format!(""Invalid Node transaction: {:?}"", err)))
+        },
+        Ok(serde_json::Value::Number(n)) => match n.as_u64() {
+            Some(num) => Ok(Some(num)),
+            None => Err(serde::de::Error::custom(format!(""Invalid Node transaction"")))
+        },
+        Ok(serde_json::Value::Null) => Ok(None),
+        _ => Err(serde::de::Error::custom(format!(""Invalid Node transaction""))),
+    }
 }
 
 #[derive(Serialize, Deserialize, Debug, Eq, PartialEq)]
-pub struct GenTransaction<T> {
-    pub data: NodeData<T>,
+pub struct NodeTransaction {
+    pub data: NodeData,
     pub dest: String,
     pub identifier: String,
     #[serde(rename = ""txnId"")]
     pub txn_id: Option<String>,
+    pub verkey: Option<String>,
     #[serde(rename = ""type"")]
     pub txn_type: String
 }
 
-impl JsonEncodable for GenTransaction<u32> {}
+impl JsonEncodable for NodeTransaction {}
 
-impl<'a> JsonDecodable<'a> for GenTransaction<u32> {}
+impl<'a> JsonDecodable<'a> for NodeTransaction {}
 
-impl GenTransaction<u32> {
+impl NodeTransaction {
     pub fn to_msg_pack(&self) -> Result<Vec<u8>, rmp_serde::encode::Error> {
         rmp_serde::to_vec_named(self)
     }
+
+    pub fn update(&mut self, other: &mut NodeTransaction) -> Result<(), CommonError> {
+        assert_eq!(self.data.alias, other.data.alias);",,2017-11-03 13:34:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/148734827,https://github.com/hyperledger/indy-sdk/pull/360#discussion_r148734827,jovfer
https://github.com/hyperledger/indy-sdk/pull/359,https://github.com/hyperledger/indy-sdk/pull/359,"RC branch was tested on '1.1.24', '1.0.10', '1.1.33' versions. So, if we want to have quick hotfix for sources in RC branch, we should set appropriate versions, not latest. Or wait next RC/stable.",8004135f738b63237d6e010d2431e5c24175ee69,2017-11-03 14:13:53,148792474,"@@ -24,9 +24,9 @@ RUN echo ""deb https://repo.sovrin.org/deb xenial $sovrin_stream"" >> /etc/apt/sou
 
 RUN useradd -ms /bin/bash -u $uid sovrin
 
-ARG indy_plenum_ver=1.1.112
-ARG indy_anoncreds_ver=1.0.25
-ARG indy_node_ver=1.1.119
+ARG indy_plenum_ver=1.1.27
+ARG indy_anoncreds_ver=1.0.10
+ARG indy_node_ver=1.1.43",,2017-11-06 22:42:33,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/148792474,https://github.com/hyperledger/indy-sdk/pull/359#discussion_r148792474,jovfer
https://github.com/hyperledger/indy-sdk/pull/354,https://github.com/hyperledger/indy-sdk/pull/354,pool_handle should be optional. This check should be performed only in case of missed local value.,670aa7dba033a3a3c809f946542d1f50e667a2b3,2017-10-31 15:48:56,148038813,"@@ -477,14 +488,27 @@ impl SignusCommandExecutor {
 
     fn get_endpoint_for_did(&self,
                             wallet_handle: i32,
-                            did: String) -> Result<(String, String), IndyError> {
-        self.signus_service.validate_did(&did)?;
-
-        // TODO: FIXME: It should support resolving of endpoint from ledget!!!
-        let endpoint = self._wallet_get_did_endpoint(wallet_handle, &did)?;
+                            pool_handle: i32,
+                            did: String,
+                            cb: Box<Fn(Result<(String, String), IndyError>) + Send>) {
+        try_cb!(self.signus_service.validate_did(&did), cb);
 
-        let res = (endpoint.ha, endpoint.verkey);
-        Ok(res)
+        check_wallet_and_pool_handles_consistency!(self.wallet_service, self.pool_service,",,2017-11-01 11:05:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/148038813,https://github.com/hyperledger/indy-sdk/pull/354#discussion_r148038813,jovfer
https://github.com/hyperledger/indy-sdk/pull/354,https://github.com/hyperledger/indy-sdk/pull/354,also it will simplify some tests,670aa7dba033a3a3c809f946542d1f50e667a2b3,2017-10-31 15:50:53,148039426,"@@ -477,14 +488,27 @@ impl SignusCommandExecutor {
 
     fn get_endpoint_for_did(&self,
                             wallet_handle: i32,
-                            did: String) -> Result<(String, String), IndyError> {
-        self.signus_service.validate_did(&did)?;
-
-        // TODO: FIXME: It should support resolving of endpoint from ledget!!!
-        let endpoint = self._wallet_get_did_endpoint(wallet_handle, &did)?;
+                            pool_handle: i32,
+                            did: String,
+                            cb: Box<Fn(Result<(String, String), IndyError>) + Send>) {
+        try_cb!(self.signus_service.validate_did(&did), cb);
 
-        let res = (endpoint.ha, endpoint.verkey);
-        Ok(res)
+        check_wallet_and_pool_handles_consistency!(self.wallet_service, self.pool_service,",,2017-11-01 11:05:11,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/148039426,https://github.com/hyperledger/indy-sdk/pull/354#discussion_r148039426,jovfer
https://github.com/hyperledger/indy-sdk/pull/342,https://github.com/hyperledger/indy-sdk/pull/342,"Link to repository doesn't acceptable, we need for separate Rust crates like `rusqlcipher`
@mikelodder7 could you create it, please?",8522cf756beb757bd8f884b35042f48f2b79d19d,2017-10-26 09:20:41,147087205,"@@ -44,7 +44,7 @@ log = ""0.3.7""
 openssl = { version = ""0.9.11"", optional = true }
 rand = ""0.3""
 rlp = ""0.2.0""
-rusqlite = ""0.10.1""
+rusqlite = { git = ""https://github.com/mikelodder7/rusqlcipher"", features=[""bundled""] }",,2017-11-10 00:10:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/147087205,https://github.com/hyperledger/indy-sdk/pull/342#discussion_r147087205,jovfer
https://github.com/hyperledger/indy-sdk/pull/342,https://github.com/hyperledger/indy-sdk/pull/342,"It would be nice to provide some additional test cases:

1. Trying to open unencrypted database with some key
2. Trying to open encrypted database with invalid key
3. Trying to use key without Key Derivation (in format ""x'2DD29CA851E7B56E4697B0E1F08507293D761A05CE4D1B628663F411A8086D99'"")",8522cf756beb757bd8f884b35042f48f2b79d19d,2017-11-07 13:04:04,149360669,"@@ -403,4 +430,30 @@ mod tests {
 
         TestUtils::cleanup_indy_home();
     }
-}
\ No newline at end of file
+
+    #[test]
+    fn default_wallet_create_encrypted() {",,2017-11-10 00:10:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/149360669,https://github.com/hyperledger/indy-sdk/pull/342#discussion_r149360669,vimmerru
https://github.com/hyperledger/indy-sdk/pull/342,https://github.com/hyperledger/indy-sdk/pull/342,"We need to update documentation for indy_create_wallet/indy_open_wallet functions and describe format of credentials param. We need it in:

- api/wallet.rs comments
- include/wallet.h comments
- python wrapper
- java wrapper
- iOS wrapper
- .Net wrapper too. ",8522cf756beb757bd8f884b35042f48f2b79d19d,2017-11-07 13:07:09,149361289,"@@ -30,10 +30,18 @@ impl Default for DefaultWalletRuntimeConfig {
 }
 
 #[derive(Deserialize)]
-struct DefaultWalletCredentials {}
+struct DefaultWalletCredentials {
+    key: String
+}
 
 impl<'a> JsonDecodable<'a> for DefaultWalletCredentials {}
 
+impl Default for DefaultWalletCredentials {",29,2017-11-10 00:10:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/149361289,https://github.com/hyperledger/indy-sdk/pull/342#discussion_r149361289,vimmerru
https://github.com/hyperledger/indy-sdk/pull/342,https://github.com/hyperledger/indy-sdk/pull/342,"Ideally, we need to add these tests to wrappers too, but as it backward compatible change we can merge it without wrappers update, but for Rust code, we need these tests.",8522cf756beb757bd8f884b35042f48f2b79d19d,2017-11-07 13:08:51,149361597,"@@ -403,4 +430,30 @@ mod tests {
 
         TestUtils::cleanup_indy_home();
     }
-}
\ No newline at end of file
+
+    #[test]
+    fn default_wallet_create_encrypted() {",,2017-11-10 00:10:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/149361597,https://github.com/hyperledger/indy-sdk/pull/342#discussion_r149361597,vimmerru
https://github.com/hyperledger/indy-sdk/pull/335,https://github.com/hyperledger/indy-sdk/pull/335,"use separate wallet, full decryption",2030acc26913855cdf99c0cdf4bd809f30d1965c,2017-10-23 12:28:35,146248357,"@@ -517,6 +518,278 @@ mod high_cases {
             TestUtils::cleanup_storage();
         }
     }
+
+    mod prep_msg {
+        use super::*;
+
+        fn check_message(wallet_handle: i32, recipient_did: &str, sender_vk: &str, encrypted_msg: &Vec<u8>) {
+            let decrypted_message = SignusUtils::decrypt_sealed(wallet_handle, recipient_did, encrypted_msg).unwrap();",,2017-10-23 15:11:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/146248357,https://github.com/hyperledger/indy-sdk/pull/335#discussion_r146248357,jovfer
https://github.com/hyperledger/indy-sdk/pull/335,https://github.com/hyperledger/indy-sdk/pull/335,split into 2 wallets,2030acc26913855cdf99c0cdf4bd809f30d1965c,2017-10-23 12:33:24,146249419,"@@ -517,6 +518,278 @@ mod high_cases {
             TestUtils::cleanup_storage();
         }
     }
+
+    mod prep_msg {
+        use super::*;
+
+        fn check_message(wallet_handle: i32, recipient_did: &str, sender_vk: &str, encrypted_msg: &Vec<u8>) {
+            let decrypted_message = SignusUtils::decrypt_sealed(wallet_handle, recipient_did, encrypted_msg).unwrap();
+            let decrypted_msg_json = std::str::from_utf8(&decrypted_message).unwrap();
+            let decrypted_msg: serde_json::Value = serde_json::from_str(decrypted_msg_json).unwrap();
+
+            assert_eq!(true, decrypted_msg[""auth""].as_bool().unwrap());
+            assert_eq!(sender_vk, decrypted_msg[""sender""].as_str().unwrap());
+            decrypted_msg[""nonce""].as_str().unwrap();
+            decrypted_msg[""msg""].as_str().unwrap();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_created_key() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+            let (recipient_did, recipient_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_msg(wallet_handle, &sender_vk, &recipient_vk, MESSAGE.as_bytes()).unwrap();
+            check_message(wallet_handle, &recipient_did, &sender_vk, &encrypted_msg);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_created_did() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (_, sender_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+            let (recipient_did, recipient_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_msg(wallet_handle, &sender_vk, &recipient_vk, MESSAGE.as_bytes()).unwrap();
+            check_message(wallet_handle, &recipient_did, &sender_vk, &encrypted_msg);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_created_did_as_cid() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (_, sender_vk, _) = SignusUtils::create_my_did(wallet_handle, &format!(r#""{{""seed"":""{}"", ""cid"":true}}""#, MY1_SEED)).unwrap();
+            let (recipient_did, recipient_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_msg(wallet_handle, &sender_vk, &recipient_vk, MESSAGE.as_bytes()).unwrap();
+            check_message(wallet_handle, &recipient_did, &sender_vk, &encrypted_msg);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_unknown_sender_verkey() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = ""aqWVAsHd2VvWrQEwWWFgbVCRteYnPqsJwraqVaQRvAqH"";
+            let res = AgentUtils::prep_msg(wallet_handle, &sender_vk, VERKEY, MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = AgentUtils::prep_msg(invalid_wallet_handle, &sender_vk, VERKEY, MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_invalid_recipient_vk() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let res = AgentUtils::prep_msg(wallet_handle, &sender_vk, INVALID_VERKEY_LENGTH, MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            let res = AgentUtils::prep_msg(wallet_handle, &sender_vk, INVALID_BASE58_VERKEY, MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod prep_anonymous_msg {
+        use super::*;
+        use base64;
+
+        fn check_message(wallet_handle: i32, recipient_did: &str, encrypted_msg: &Vec<u8>) {
+            let decrypted_message = SignusUtils::decrypt_sealed(wallet_handle, recipient_did, encrypted_msg).unwrap();
+            let decrypted_msg_json = std::str::from_utf8(&decrypted_message).unwrap();
+            let decrypted_msg: serde_json::Value = serde_json::from_str(decrypted_msg_json).unwrap();
+
+            assert_eq!(false, decrypted_msg[""auth""].as_bool().unwrap());
+            assert_eq!(MESSAGE.as_bytes().to_vec(), base64::decode(decrypted_msg[""msg""].as_str().unwrap()).unwrap());
+        }
+
+        #[test]
+        fn indy_prep_anonymous_msg_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (recipient_did, recipient_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_anonymous_msg(&recipient_vk, &MESSAGE.as_bytes()).unwrap();
+            check_message(wallet_handle, &recipient_did, &encrypted_msg);
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_anonymous_msg_works_for_invalid_recipient_vk() {
+            TestUtils::cleanup_storage();
+
+            let res = AgentUtils::prep_anonymous_msg(INVALID_VERKEY_LENGTH, &MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            let res = AgentUtils::prep_anonymous_msg(INVALID_BASE58_VERKEY, &MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod parse_msg {
+        use super::*;
+
+        #[test]
+        fn indy_parse_msg_works_for_authenticated_message() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();",,2017-10-23 15:11:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/146249419,https://github.com/hyperledger/indy-sdk/pull/335#discussion_r146249419,jovfer
https://github.com/hyperledger/indy-sdk/pull/335,https://github.com/hyperledger/indy-sdk/pull/335,simplify to `unencrypted body`,2030acc26913855cdf99c0cdf4bd809f30d1965c,2017-10-23 12:34:58,146249769,"@@ -517,6 +518,278 @@ mod high_cases {
             TestUtils::cleanup_storage();
         }
     }
+
+    mod prep_msg {
+        use super::*;
+
+        fn check_message(wallet_handle: i32, recipient_did: &str, sender_vk: &str, encrypted_msg: &Vec<u8>) {
+            let decrypted_message = SignusUtils::decrypt_sealed(wallet_handle, recipient_did, encrypted_msg).unwrap();
+            let decrypted_msg_json = std::str::from_utf8(&decrypted_message).unwrap();
+            let decrypted_msg: serde_json::Value = serde_json::from_str(decrypted_msg_json).unwrap();
+
+            assert_eq!(true, decrypted_msg[""auth""].as_bool().unwrap());
+            assert_eq!(sender_vk, decrypted_msg[""sender""].as_str().unwrap());
+            decrypted_msg[""nonce""].as_str().unwrap();
+            decrypted_msg[""msg""].as_str().unwrap();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_created_key() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+            let (recipient_did, recipient_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_msg(wallet_handle, &sender_vk, &recipient_vk, MESSAGE.as_bytes()).unwrap();
+            check_message(wallet_handle, &recipient_did, &sender_vk, &encrypted_msg);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_created_did() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (_, sender_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+            let (recipient_did, recipient_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_msg(wallet_handle, &sender_vk, &recipient_vk, MESSAGE.as_bytes()).unwrap();
+            check_message(wallet_handle, &recipient_did, &sender_vk, &encrypted_msg);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_created_did_as_cid() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (_, sender_vk, _) = SignusUtils::create_my_did(wallet_handle, &format!(r#""{{""seed"":""{}"", ""cid"":true}}""#, MY1_SEED)).unwrap();
+            let (recipient_did, recipient_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_msg(wallet_handle, &sender_vk, &recipient_vk, MESSAGE.as_bytes()).unwrap();
+            check_message(wallet_handle, &recipient_did, &sender_vk, &encrypted_msg);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_unknown_sender_verkey() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = ""aqWVAsHd2VvWrQEwWWFgbVCRteYnPqsJwraqVaQRvAqH"";
+            let res = AgentUtils::prep_msg(wallet_handle, &sender_vk, VERKEY, MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = AgentUtils::prep_msg(invalid_wallet_handle, &sender_vk, VERKEY, MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_invalid_recipient_vk() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let res = AgentUtils::prep_msg(wallet_handle, &sender_vk, INVALID_VERKEY_LENGTH, MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            let res = AgentUtils::prep_msg(wallet_handle, &sender_vk, INVALID_BASE58_VERKEY, MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod prep_anonymous_msg {
+        use super::*;
+        use base64;
+
+        fn check_message(wallet_handle: i32, recipient_did: &str, encrypted_msg: &Vec<u8>) {
+            let decrypted_message = SignusUtils::decrypt_sealed(wallet_handle, recipient_did, encrypted_msg).unwrap();
+            let decrypted_msg_json = std::str::from_utf8(&decrypted_message).unwrap();
+            let decrypted_msg: serde_json::Value = serde_json::from_str(decrypted_msg_json).unwrap();
+
+            assert_eq!(false, decrypted_msg[""auth""].as_bool().unwrap());
+            assert_eq!(MESSAGE.as_bytes().to_vec(), base64::decode(decrypted_msg[""msg""].as_str().unwrap()).unwrap());
+        }
+
+        #[test]
+        fn indy_prep_anonymous_msg_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (recipient_did, recipient_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_anonymous_msg(&recipient_vk, &MESSAGE.as_bytes()).unwrap();
+            check_message(wallet_handle, &recipient_did, &encrypted_msg);
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_anonymous_msg_works_for_invalid_recipient_vk() {
+            TestUtils::cleanup_storage();
+
+            let res = AgentUtils::prep_anonymous_msg(INVALID_VERKEY_LENGTH, &MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            let res = AgentUtils::prep_anonymous_msg(INVALID_BASE58_VERKEY, &MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod parse_msg {
+        use super::*;
+
+        #[test]
+        fn indy_parse_msg_works_for_authenticated_message() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+            let recipient_vk = SignusUtils::create_key(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_msg(wallet_handle, &sender_vk, &recipient_vk, MESSAGE.as_bytes()).unwrap();
+
+            let (vk, msg) = AgentUtils::parse_msg(wallet_handle, &recipient_vk, &encrypted_msg).unwrap();
+            assert_eq!(MESSAGE.as_bytes().to_vec(), msg);
+            assert_eq!(sender_vk, vk.unwrap());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_parse_msg_works_for_anonymous_message() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let recipient_vk = SignusUtils::create_key(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_anonymous_msg(&recipient_vk, MESSAGE.as_bytes()).unwrap();
+
+            let (sender_vk, msg) = AgentUtils::parse_msg(wallet_handle, &recipient_vk, &encrypted_msg).unwrap();
+            assert_eq!(MESSAGE.as_bytes().to_vec(), msg);
+            assert_eq!(None, sender_vk);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_parse_msg_works_for_invalid_authenticated_msg() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let recipient_vk = SignusUtils::create_key(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = format!(r#""{{""auth"":true,""nonce"":{:?},""msg"":{:?}}}""#, NONCE, MESSAGE.as_bytes());",,2017-10-23 15:11:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/146249769,https://github.com/hyperledger/indy-sdk/pull/335#discussion_r146249769,jovfer
https://github.com/hyperledger/indy-sdk/pull/335,https://github.com/hyperledger/indy-sdk/pull/335,Simplify,2030acc26913855cdf99c0cdf4bd809f30d1965c,2017-10-23 12:35:27,146249877,"@@ -517,6 +518,278 @@ mod high_cases {
             TestUtils::cleanup_storage();
         }
     }
+
+    mod prep_msg {
+        use super::*;
+
+        fn check_message(wallet_handle: i32, recipient_did: &str, sender_vk: &str, encrypted_msg: &Vec<u8>) {
+            let decrypted_message = SignusUtils::decrypt_sealed(wallet_handle, recipient_did, encrypted_msg).unwrap();
+            let decrypted_msg_json = std::str::from_utf8(&decrypted_message).unwrap();
+            let decrypted_msg: serde_json::Value = serde_json::from_str(decrypted_msg_json).unwrap();
+
+            assert_eq!(true, decrypted_msg[""auth""].as_bool().unwrap());
+            assert_eq!(sender_vk, decrypted_msg[""sender""].as_str().unwrap());
+            decrypted_msg[""nonce""].as_str().unwrap();
+            decrypted_msg[""msg""].as_str().unwrap();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_created_key() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+            let (recipient_did, recipient_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_msg(wallet_handle, &sender_vk, &recipient_vk, MESSAGE.as_bytes()).unwrap();
+            check_message(wallet_handle, &recipient_did, &sender_vk, &encrypted_msg);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_created_did() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (_, sender_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+            let (recipient_did, recipient_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_msg(wallet_handle, &sender_vk, &recipient_vk, MESSAGE.as_bytes()).unwrap();
+            check_message(wallet_handle, &recipient_did, &sender_vk, &encrypted_msg);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_created_did_as_cid() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (_, sender_vk, _) = SignusUtils::create_my_did(wallet_handle, &format!(r#""{{""seed"":""{}"", ""cid"":true}}""#, MY1_SEED)).unwrap();
+            let (recipient_did, recipient_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_msg(wallet_handle, &sender_vk, &recipient_vk, MESSAGE.as_bytes()).unwrap();
+            check_message(wallet_handle, &recipient_did, &sender_vk, &encrypted_msg);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_unknown_sender_verkey() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = ""aqWVAsHd2VvWrQEwWWFgbVCRteYnPqsJwraqVaQRvAqH"";
+            let res = AgentUtils::prep_msg(wallet_handle, &sender_vk, VERKEY, MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = AgentUtils::prep_msg(invalid_wallet_handle, &sender_vk, VERKEY, MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_invalid_recipient_vk() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let res = AgentUtils::prep_msg(wallet_handle, &sender_vk, INVALID_VERKEY_LENGTH, MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            let res = AgentUtils::prep_msg(wallet_handle, &sender_vk, INVALID_BASE58_VERKEY, MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod prep_anonymous_msg {
+        use super::*;
+        use base64;
+
+        fn check_message(wallet_handle: i32, recipient_did: &str, encrypted_msg: &Vec<u8>) {
+            let decrypted_message = SignusUtils::decrypt_sealed(wallet_handle, recipient_did, encrypted_msg).unwrap();
+            let decrypted_msg_json = std::str::from_utf8(&decrypted_message).unwrap();
+            let decrypted_msg: serde_json::Value = serde_json::from_str(decrypted_msg_json).unwrap();
+
+            assert_eq!(false, decrypted_msg[""auth""].as_bool().unwrap());
+            assert_eq!(MESSAGE.as_bytes().to_vec(), base64::decode(decrypted_msg[""msg""].as_str().unwrap()).unwrap());
+        }
+
+        #[test]
+        fn indy_prep_anonymous_msg_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (recipient_did, recipient_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_anonymous_msg(&recipient_vk, &MESSAGE.as_bytes()).unwrap();
+            check_message(wallet_handle, &recipient_did, &encrypted_msg);
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_anonymous_msg_works_for_invalid_recipient_vk() {
+            TestUtils::cleanup_storage();
+
+            let res = AgentUtils::prep_anonymous_msg(INVALID_VERKEY_LENGTH, &MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            let res = AgentUtils::prep_anonymous_msg(INVALID_BASE58_VERKEY, &MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod parse_msg {
+        use super::*;
+
+        #[test]
+        fn indy_parse_msg_works_for_authenticated_message() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+            let recipient_vk = SignusUtils::create_key(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_msg(wallet_handle, &sender_vk, &recipient_vk, MESSAGE.as_bytes()).unwrap();
+
+            let (vk, msg) = AgentUtils::parse_msg(wallet_handle, &recipient_vk, &encrypted_msg).unwrap();
+            assert_eq!(MESSAGE.as_bytes().to_vec(), msg);
+            assert_eq!(sender_vk, vk.unwrap());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_parse_msg_works_for_anonymous_message() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let recipient_vk = SignusUtils::create_key(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_anonymous_msg(&recipient_vk, MESSAGE.as_bytes()).unwrap();
+
+            let (sender_vk, msg) = AgentUtils::parse_msg(wallet_handle, &recipient_vk, &encrypted_msg).unwrap();
+            assert_eq!(MESSAGE.as_bytes().to_vec(), msg);
+            assert_eq!(None, sender_vk);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_parse_msg_works_for_invalid_authenticated_msg() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let recipient_vk = SignusUtils::create_key(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = format!(r#""{{""auth"":true,""nonce"":{:?},""msg"":{:?}}}""#, NONCE, MESSAGE.as_bytes());
+
+            let res = AgentUtils::parse_msg(wallet_handle, &recipient_vk, &encrypted_msg.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_parse_msg_works_for_invalid_anonymous_msg() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let recipient_vk = SignusUtils::create_key(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = format!(r#""{{""auth"":false,""msg"":{:?}}}""#, MESSAGE.as_bytes());",,2017-10-23 15:11:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/146249877,https://github.com/hyperledger/indy-sdk/pull/335#discussion_r146249877,jovfer
https://github.com/hyperledger/indy-sdk/pull/335,https://github.com/hyperledger/indy-sdk/pull/335,should be wallet invalid handle,2030acc26913855cdf99c0cdf4bd809f30d1965c,2017-10-23 12:36:25,146250077,"@@ -517,6 +518,278 @@ mod high_cases {
             TestUtils::cleanup_storage();
         }
     }
+
+    mod prep_msg {
+        use super::*;
+
+        fn check_message(wallet_handle: i32, recipient_did: &str, sender_vk: &str, encrypted_msg: &Vec<u8>) {
+            let decrypted_message = SignusUtils::decrypt_sealed(wallet_handle, recipient_did, encrypted_msg).unwrap();
+            let decrypted_msg_json = std::str::from_utf8(&decrypted_message).unwrap();
+            let decrypted_msg: serde_json::Value = serde_json::from_str(decrypted_msg_json).unwrap();
+
+            assert_eq!(true, decrypted_msg[""auth""].as_bool().unwrap());
+            assert_eq!(sender_vk, decrypted_msg[""sender""].as_str().unwrap());
+            decrypted_msg[""nonce""].as_str().unwrap();
+            decrypted_msg[""msg""].as_str().unwrap();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_created_key() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+            let (recipient_did, recipient_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_msg(wallet_handle, &sender_vk, &recipient_vk, MESSAGE.as_bytes()).unwrap();
+            check_message(wallet_handle, &recipient_did, &sender_vk, &encrypted_msg);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_created_did() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (_, sender_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+            let (recipient_did, recipient_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_msg(wallet_handle, &sender_vk, &recipient_vk, MESSAGE.as_bytes()).unwrap();
+            check_message(wallet_handle, &recipient_did, &sender_vk, &encrypted_msg);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_created_did_as_cid() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (_, sender_vk, _) = SignusUtils::create_my_did(wallet_handle, &format!(r#""{{""seed"":""{}"", ""cid"":true}}""#, MY1_SEED)).unwrap();
+            let (recipient_did, recipient_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_msg(wallet_handle, &sender_vk, &recipient_vk, MESSAGE.as_bytes()).unwrap();
+            check_message(wallet_handle, &recipient_did, &sender_vk, &encrypted_msg);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_unknown_sender_verkey() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = ""aqWVAsHd2VvWrQEwWWFgbVCRteYnPqsJwraqVaQRvAqH"";
+            let res = AgentUtils::prep_msg(wallet_handle, &sender_vk, VERKEY, MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = AgentUtils::prep_msg(invalid_wallet_handle, &sender_vk, VERKEY, MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_msg_works_for_invalid_recipient_vk() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let res = AgentUtils::prep_msg(wallet_handle, &sender_vk, INVALID_VERKEY_LENGTH, MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            let res = AgentUtils::prep_msg(wallet_handle, &sender_vk, INVALID_BASE58_VERKEY, MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod prep_anonymous_msg {
+        use super::*;
+        use base64;
+
+        fn check_message(wallet_handle: i32, recipient_did: &str, encrypted_msg: &Vec<u8>) {
+            let decrypted_message = SignusUtils::decrypt_sealed(wallet_handle, recipient_did, encrypted_msg).unwrap();
+            let decrypted_msg_json = std::str::from_utf8(&decrypted_message).unwrap();
+            let decrypted_msg: serde_json::Value = serde_json::from_str(decrypted_msg_json).unwrap();
+
+            assert_eq!(false, decrypted_msg[""auth""].as_bool().unwrap());
+            assert_eq!(MESSAGE.as_bytes().to_vec(), base64::decode(decrypted_msg[""msg""].as_str().unwrap()).unwrap());
+        }
+
+        #[test]
+        fn indy_prep_anonymous_msg_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (recipient_did, recipient_vk, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_anonymous_msg(&recipient_vk, &MESSAGE.as_bytes()).unwrap();
+            check_message(wallet_handle, &recipient_did, &encrypted_msg);
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_prep_anonymous_msg_works_for_invalid_recipient_vk() {
+            TestUtils::cleanup_storage();
+
+            let res = AgentUtils::prep_anonymous_msg(INVALID_VERKEY_LENGTH, &MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            let res = AgentUtils::prep_anonymous_msg(INVALID_BASE58_VERKEY, &MESSAGE.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod parse_msg {
+        use super::*;
+
+        #[test]
+        fn indy_parse_msg_works_for_authenticated_message() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let sender_vk = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+            let recipient_vk = SignusUtils::create_key(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_msg(wallet_handle, &sender_vk, &recipient_vk, MESSAGE.as_bytes()).unwrap();
+
+            let (vk, msg) = AgentUtils::parse_msg(wallet_handle, &recipient_vk, &encrypted_msg).unwrap();
+            assert_eq!(MESSAGE.as_bytes().to_vec(), msg);
+            assert_eq!(sender_vk, vk.unwrap());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_parse_msg_works_for_anonymous_message() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let recipient_vk = SignusUtils::create_key(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_anonymous_msg(&recipient_vk, MESSAGE.as_bytes()).unwrap();
+
+            let (sender_vk, msg) = AgentUtils::parse_msg(wallet_handle, &recipient_vk, &encrypted_msg).unwrap();
+            assert_eq!(MESSAGE.as_bytes().to_vec(), msg);
+            assert_eq!(None, sender_vk);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_parse_msg_works_for_invalid_authenticated_msg() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let recipient_vk = SignusUtils::create_key(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = format!(r#""{{""auth"":true,""nonce"":{:?},""msg"":{:?}}}""#, NONCE, MESSAGE.as_bytes());
+
+            let res = AgentUtils::parse_msg(wallet_handle, &recipient_vk, &encrypted_msg.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_parse_msg_works_for_invalid_anonymous_msg() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let recipient_vk = SignusUtils::create_key(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = format!(r#""{{""auth"":false,""msg"":{:?}}}""#, MESSAGE.as_bytes());
+
+            let res = AgentUtils::parse_msg(wallet_handle, &recipient_vk, &encrypted_msg.as_bytes());
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_parse_msg_msg_works_for_unknown_recipient_vk() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_anonymous_msg(VERKEY, &MESSAGE.as_bytes()).unwrap();
+
+            let res = AgentUtils::parse_msg(wallet_handle, VERKEY, &encrypted_msg);
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_parse_msg_msg_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let recipient_vk = SignusUtils::create_key(wallet_handle, Some(MY2_SEED)).unwrap();
+
+            let encrypted_msg = AgentUtils::prep_anonymous_msg(&recipient_vk, &MESSAGE.as_bytes()).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = AgentUtils::parse_msg(invalid_wallet_handle, &recipient_vk, &encrypted_msg);
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());",,2017-10-23 15:11:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/146250077,https://github.com/hyperledger/indy-sdk/pull/335#discussion_r146250077,jovfer
https://github.com/hyperledger/indy-sdk/pull/335,https://github.com/hyperledger/indy-sdk/pull/335,May be just use TRUSTEE,2030acc26913855cdf99c0cdf4bd809f30d1965c,2017-10-23 12:42:50,146251580,"@@ -26,16 +26,640 @@ use indy::api::ErrorCode;
 
 use std::{thread, time};
 
-pub const MESSAGE: &'static str = r#""{""reqId"":1496822211362017764}""#;
 pub const ENCRYPTED_MESSAGE: &'static [u8; 45] = &[187, 227, 10, 29, 46, 178, 12, 179, 197, 69, 171, 70, 228, 204, 52, 22, 199, 54, 62, 13, 115, 5, 216, 66, 20, 131, 121, 29, 251, 224, 253, 201, 75, 73, 225, 237, 219, 133, 35, 217, 131, 135, 232, 129, 32];
-pub const NONCE: &'static [u8; 24] = &[242, 246, 53, 153, 106, 37, 185, 65, 212, 14, 109, 131, 200, 169, 94, 110, 51, 47, 101, 89, 0, 171, 105, 183];
 pub const SIGNATURE: &'static [u8; 64] = &[169, 215, 8, 225, 7, 107, 110, 9, 193, 162, 202, 214, 162, 66, 238, 211, 63, 209, 12, 196, 8, 211, 55, 27, 120, 94, 204, 147, 53, 104, 103, 61, 60, 249, 237, 127, 103, 46, 220, 223, 10, 95, 75, 53, 245, 210, 241, 151, 191, 41, 48, 30, 9, 16, 78, 252, 157, 206, 210, 145, 125, 133, 109, 11];
 pub const DID: &'static str = ""NcYxiDXkpYi6ov5FcYDi1e"";
-pub const VERKEY: &'static str = ""CnEDk9HrMnmiHXEV1WFgbVCRteYnPqsJwrTdcZaNhFVW"";
+pub const METADATA: &'static str = ""some_metadata"";
+
 
 mod high_cases {
     use super::*;
 
+    mod create_key {
+        use super::*;
+        use rust_base58::FromBase58;
+
+        #[test]
+        fn indy_create_key_works_for_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let verkey = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+            assert_eq!(verkey.from_base58().unwrap().len(), 32);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_without_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let verkey = SignusUtils::create_key(wallet_handle, None).unwrap();
+            assert_eq!(verkey.from_base58().unwrap().len(), 32);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_for_invalid_wallet_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::create_key(invalid_wallet_handle, None);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_for_invalid_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::create_key(wallet_handle, Some(""invalidSeedLength""));
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            let res = SignusUtils::create_key(wallet_handle, Some(""invalid_base58_string11111111111""));
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod store_key_metadata {
+        use super::*;
+
+        #[test]
+        fn indy_store_key_metadata_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_replace() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!(METADATA.to_string(), metadata);
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, ""updated metadata"").unwrap();
+            let updated_metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_ne!(METADATA.to_string(), updated_metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::store_key_metadata(invalid_wallet_handle, VERKEY, METADATA);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_empty_string() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, """").unwrap();
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod get_key_metadata {
+        use super::*;
+
+        #[test]
+        fn indy_get_key_metadata_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!(METADATA.to_string(), metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_empty_string() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, """").unwrap();
+
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!("""", metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_no_metadata() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::get_key_metadata(wallet_handle, VERKEY);
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            let invalid_invalid_handle = wallet_handle + 1;
+            let res = SignusUtils::get_key_metadata(invalid_invalid_handle, VERKEY);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod key_for_did {
+        use super::*;
+
+        #[test]
+        fn indy_key_for_did_works_for_my_did() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (did, verkey, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, &did).unwrap();
+            assert_eq!(verkey, received_verkey);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_their_did() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let identity_json = format!(r#""{{""did"":""{}"", ""verkey"":""{}""}}""#, DID, VERKEY);
+            SignusUtils::store_their_did(wallet_handle, &identity_json).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, DID).unwrap();
+            assert_eq!(VERKEY, received_verkey);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_get_key_from_ledger() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let trustee_wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (trustee_did, _, _) = SignusUtils::create_and_store_my_did(trustee_wallet_handle, Some(TRUSTEE_SEED)).unwrap();
+            let (did, verkey, _) = SignusUtils::create_and_store_my_did(trustee_wallet_handle, None).unwrap();
+
+            let nym_request = LedgerUtils::build_nym_request(&trustee_did, &did, Some(&verkey), None, None).unwrap();
+            LedgerUtils::sign_and_submit_request(pool_handle, trustee_wallet_handle, &trustee_did, &nym_request).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, &did).unwrap();",268,2017-10-23 15:11:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/146251580,https://github.com/hyperledger/indy-sdk/pull/335#discussion_r146251580,jovfer
https://github.com/hyperledger/indy-sdk/pull/335,https://github.com/hyperledger/indy-sdk/pull/335,`...for_invalid_wallet_handle`,2030acc26913855cdf99c0cdf4bd809f30d1965c,2017-10-23 12:44:21,146252097,"@@ -26,16 +26,640 @@ use indy::api::ErrorCode;
 
 use std::{thread, time};
 
-pub const MESSAGE: &'static str = r#""{""reqId"":1496822211362017764}""#;
 pub const ENCRYPTED_MESSAGE: &'static [u8; 45] = &[187, 227, 10, 29, 46, 178, 12, 179, 197, 69, 171, 70, 228, 204, 52, 22, 199, 54, 62, 13, 115, 5, 216, 66, 20, 131, 121, 29, 251, 224, 253, 201, 75, 73, 225, 237, 219, 133, 35, 217, 131, 135, 232, 129, 32];
-pub const NONCE: &'static [u8; 24] = &[242, 246, 53, 153, 106, 37, 185, 65, 212, 14, 109, 131, 200, 169, 94, 110, 51, 47, 101, 89, 0, 171, 105, 183];
 pub const SIGNATURE: &'static [u8; 64] = &[169, 215, 8, 225, 7, 107, 110, 9, 193, 162, 202, 214, 162, 66, 238, 211, 63, 209, 12, 196, 8, 211, 55, 27, 120, 94, 204, 147, 53, 104, 103, 61, 60, 249, 237, 127, 103, 46, 220, 223, 10, 95, 75, 53, 245, 210, 241, 151, 191, 41, 48, 30, 9, 16, 78, 252, 157, 206, 210, 145, 125, 133, 109, 11];
 pub const DID: &'static str = ""NcYxiDXkpYi6ov5FcYDi1e"";
-pub const VERKEY: &'static str = ""CnEDk9HrMnmiHXEV1WFgbVCRteYnPqsJwrTdcZaNhFVW"";
+pub const METADATA: &'static str = ""some_metadata"";
+
 
 mod high_cases {
     use super::*;
 
+    mod create_key {
+        use super::*;
+        use rust_base58::FromBase58;
+
+        #[test]
+        fn indy_create_key_works_for_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let verkey = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+            assert_eq!(verkey.from_base58().unwrap().len(), 32);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_without_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let verkey = SignusUtils::create_key(wallet_handle, None).unwrap();
+            assert_eq!(verkey.from_base58().unwrap().len(), 32);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_for_invalid_wallet_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::create_key(invalid_wallet_handle, None);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_for_invalid_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::create_key(wallet_handle, Some(""invalidSeedLength""));
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            let res = SignusUtils::create_key(wallet_handle, Some(""invalid_base58_string11111111111""));
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod store_key_metadata {
+        use super::*;
+
+        #[test]
+        fn indy_store_key_metadata_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_replace() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!(METADATA.to_string(), metadata);
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, ""updated metadata"").unwrap();
+            let updated_metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_ne!(METADATA.to_string(), updated_metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::store_key_metadata(invalid_wallet_handle, VERKEY, METADATA);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_empty_string() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, """").unwrap();
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod get_key_metadata {
+        use super::*;
+
+        #[test]
+        fn indy_get_key_metadata_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!(METADATA.to_string(), metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_empty_string() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, """").unwrap();
+
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!("""", metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_no_metadata() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::get_key_metadata(wallet_handle, VERKEY);
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            let invalid_invalid_handle = wallet_handle + 1;
+            let res = SignusUtils::get_key_metadata(invalid_invalid_handle, VERKEY);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod key_for_did {
+        use super::*;
+
+        #[test]
+        fn indy_key_for_did_works_for_my_did() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (did, verkey, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, &did).unwrap();
+            assert_eq!(verkey, received_verkey);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_their_did() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let identity_json = format!(r#""{{""did"":""{}"", ""verkey"":""{}""}}""#, DID, VERKEY);
+            SignusUtils::store_their_did(wallet_handle, &identity_json).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, DID).unwrap();
+            assert_eq!(VERKEY, received_verkey);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_get_key_from_ledger() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let trustee_wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (trustee_did, _, _) = SignusUtils::create_and_store_my_did(trustee_wallet_handle, Some(TRUSTEE_SEED)).unwrap();
+            let (did, verkey, _) = SignusUtils::create_and_store_my_did(trustee_wallet_handle, None).unwrap();
+
+            let nym_request = LedgerUtils::build_nym_request(&trustee_did, &did, Some(&verkey), None, None).unwrap();
+            LedgerUtils::sign_and_submit_request(pool_handle, trustee_wallet_handle, &trustee_did, &nym_request).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, &did).unwrap();
+            assert_eq!(verkey, received_verkey);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_unknown_did() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::key_for_did(pool_handle, wallet_handle, DID);
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_incompatible_wallet_and_pool() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(""other pool"", None).unwrap();
+
+            let (did, _, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let res = SignusUtils::key_for_did(pool_handle, wallet_handle, &did);
+            assert_eq!(ErrorCode::WalletIncompatiblePoolError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_invalid_pool_handle() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (did, _, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let invalid_pool_handle = pool_handle + 1;
+            let res = SignusUtils::key_for_did(invalid_pool_handle, wallet_handle, &did);
+            assert_eq!(ErrorCode::PoolLedgerInvalidPoolHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_invalid_handle() {",,2017-10-23 15:11:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/146252097,https://github.com/hyperledger/indy-sdk/pull/335#discussion_r146252097,jovfer
https://github.com/hyperledger/indy-sdk/pull/335,https://github.com/hyperledger/indy-sdk/pull/335,set should set both endpoint(url) and transport key,2030acc26913855cdf99c0cdf4bd809f30d1965c,2017-10-23 12:52:12,146254005,"@@ -26,16 +26,640 @@ use indy::api::ErrorCode;
 
 use std::{thread, time};
 
-pub const MESSAGE: &'static str = r#""{""reqId"":1496822211362017764}""#;
 pub const ENCRYPTED_MESSAGE: &'static [u8; 45] = &[187, 227, 10, 29, 46, 178, 12, 179, 197, 69, 171, 70, 228, 204, 52, 22, 199, 54, 62, 13, 115, 5, 216, 66, 20, 131, 121, 29, 251, 224, 253, 201, 75, 73, 225, 237, 219, 133, 35, 217, 131, 135, 232, 129, 32];
-pub const NONCE: &'static [u8; 24] = &[242, 246, 53, 153, 106, 37, 185, 65, 212, 14, 109, 131, 200, 169, 94, 110, 51, 47, 101, 89, 0, 171, 105, 183];
 pub const SIGNATURE: &'static [u8; 64] = &[169, 215, 8, 225, 7, 107, 110, 9, 193, 162, 202, 214, 162, 66, 238, 211, 63, 209, 12, 196, 8, 211, 55, 27, 120, 94, 204, 147, 53, 104, 103, 61, 60, 249, 237, 127, 103, 46, 220, 223, 10, 95, 75, 53, 245, 210, 241, 151, 191, 41, 48, 30, 9, 16, 78, 252, 157, 206, 210, 145, 125, 133, 109, 11];
 pub const DID: &'static str = ""NcYxiDXkpYi6ov5FcYDi1e"";
-pub const VERKEY: &'static str = ""CnEDk9HrMnmiHXEV1WFgbVCRteYnPqsJwrTdcZaNhFVW"";
+pub const METADATA: &'static str = ""some_metadata"";
+
 
 mod high_cases {
     use super::*;
 
+    mod create_key {
+        use super::*;
+        use rust_base58::FromBase58;
+
+        #[test]
+        fn indy_create_key_works_for_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let verkey = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+            assert_eq!(verkey.from_base58().unwrap().len(), 32);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_without_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let verkey = SignusUtils::create_key(wallet_handle, None).unwrap();
+            assert_eq!(verkey.from_base58().unwrap().len(), 32);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_for_invalid_wallet_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::create_key(invalid_wallet_handle, None);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_for_invalid_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::create_key(wallet_handle, Some(""invalidSeedLength""));
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            let res = SignusUtils::create_key(wallet_handle, Some(""invalid_base58_string11111111111""));
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod store_key_metadata {
+        use super::*;
+
+        #[test]
+        fn indy_store_key_metadata_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_replace() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!(METADATA.to_string(), metadata);
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, ""updated metadata"").unwrap();
+            let updated_metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_ne!(METADATA.to_string(), updated_metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::store_key_metadata(invalid_wallet_handle, VERKEY, METADATA);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_empty_string() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, """").unwrap();
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod get_key_metadata {
+        use super::*;
+
+        #[test]
+        fn indy_get_key_metadata_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!(METADATA.to_string(), metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_empty_string() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, """").unwrap();
+
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!("""", metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_no_metadata() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::get_key_metadata(wallet_handle, VERKEY);
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            let invalid_invalid_handle = wallet_handle + 1;
+            let res = SignusUtils::get_key_metadata(invalid_invalid_handle, VERKEY);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod key_for_did {
+        use super::*;
+
+        #[test]
+        fn indy_key_for_did_works_for_my_did() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (did, verkey, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, &did).unwrap();
+            assert_eq!(verkey, received_verkey);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_their_did() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let identity_json = format!(r#""{{""did"":""{}"", ""verkey"":""{}""}}""#, DID, VERKEY);
+            SignusUtils::store_their_did(wallet_handle, &identity_json).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, DID).unwrap();
+            assert_eq!(VERKEY, received_verkey);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_get_key_from_ledger() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let trustee_wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (trustee_did, _, _) = SignusUtils::create_and_store_my_did(trustee_wallet_handle, Some(TRUSTEE_SEED)).unwrap();
+            let (did, verkey, _) = SignusUtils::create_and_store_my_did(trustee_wallet_handle, None).unwrap();
+
+            let nym_request = LedgerUtils::build_nym_request(&trustee_did, &did, Some(&verkey), None, None).unwrap();
+            LedgerUtils::sign_and_submit_request(pool_handle, trustee_wallet_handle, &trustee_did, &nym_request).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, &did).unwrap();
+            assert_eq!(verkey, received_verkey);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_unknown_did() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::key_for_did(pool_handle, wallet_handle, DID);
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_incompatible_wallet_and_pool() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(""other pool"", None).unwrap();
+
+            let (did, _, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let res = SignusUtils::key_for_did(pool_handle, wallet_handle, &did);
+            assert_eq!(ErrorCode::WalletIncompatiblePoolError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_invalid_pool_handle() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (did, _, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let invalid_pool_handle = pool_handle + 1;
+            let res = SignusUtils::key_for_did(invalid_pool_handle, wallet_handle, &did);
+            assert_eq!(ErrorCode::PoolLedgerInvalidPoolHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (did, _, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::key_for_did(pool_handle, invalid_wallet_handle, &did);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod set_endpoint_for_did {",350,2017-10-23 15:11:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/146254005,https://github.com/hyperledger/indy-sdk/pull/335#discussion_r146254005,jovfer
https://github.com/hyperledger/indy-sdk/pull/335,https://github.com/hyperledger/indy-sdk/pull/335,Redundant test,2030acc26913855cdf99c0cdf4bd809f30d1965c,2017-10-23 12:54:01,146254450,"@@ -26,16 +26,640 @@ use indy::api::ErrorCode;
 
 use std::{thread, time};
 
-pub const MESSAGE: &'static str = r#""{""reqId"":1496822211362017764}""#;
 pub const ENCRYPTED_MESSAGE: &'static [u8; 45] = &[187, 227, 10, 29, 46, 178, 12, 179, 197, 69, 171, 70, 228, 204, 52, 22, 199, 54, 62, 13, 115, 5, 216, 66, 20, 131, 121, 29, 251, 224, 253, 201, 75, 73, 225, 237, 219, 133, 35, 217, 131, 135, 232, 129, 32];
-pub const NONCE: &'static [u8; 24] = &[242, 246, 53, 153, 106, 37, 185, 65, 212, 14, 109, 131, 200, 169, 94, 110, 51, 47, 101, 89, 0, 171, 105, 183];
 pub const SIGNATURE: &'static [u8; 64] = &[169, 215, 8, 225, 7, 107, 110, 9, 193, 162, 202, 214, 162, 66, 238, 211, 63, 209, 12, 196, 8, 211, 55, 27, 120, 94, 204, 147, 53, 104, 103, 61, 60, 249, 237, 127, 103, 46, 220, 223, 10, 95, 75, 53, 245, 210, 241, 151, 191, 41, 48, 30, 9, 16, 78, 252, 157, 206, 210, 145, 125, 133, 109, 11];
 pub const DID: &'static str = ""NcYxiDXkpYi6ov5FcYDi1e"";
-pub const VERKEY: &'static str = ""CnEDk9HrMnmiHXEV1WFgbVCRteYnPqsJwrTdcZaNhFVW"";
+pub const METADATA: &'static str = ""some_metadata"";
+
 
 mod high_cases {
     use super::*;
 
+    mod create_key {
+        use super::*;
+        use rust_base58::FromBase58;
+
+        #[test]
+        fn indy_create_key_works_for_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let verkey = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+            assert_eq!(verkey.from_base58().unwrap().len(), 32);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_without_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let verkey = SignusUtils::create_key(wallet_handle, None).unwrap();
+            assert_eq!(verkey.from_base58().unwrap().len(), 32);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_for_invalid_wallet_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::create_key(invalid_wallet_handle, None);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_for_invalid_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::create_key(wallet_handle, Some(""invalidSeedLength""));
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            let res = SignusUtils::create_key(wallet_handle, Some(""invalid_base58_string11111111111""));
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod store_key_metadata {
+        use super::*;
+
+        #[test]
+        fn indy_store_key_metadata_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_replace() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!(METADATA.to_string(), metadata);
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, ""updated metadata"").unwrap();
+            let updated_metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_ne!(METADATA.to_string(), updated_metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::store_key_metadata(invalid_wallet_handle, VERKEY, METADATA);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_empty_string() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, """").unwrap();
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod get_key_metadata {
+        use super::*;
+
+        #[test]
+        fn indy_get_key_metadata_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!(METADATA.to_string(), metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_empty_string() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, """").unwrap();
+
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!("""", metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_no_metadata() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::get_key_metadata(wallet_handle, VERKEY);
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            let invalid_invalid_handle = wallet_handle + 1;
+            let res = SignusUtils::get_key_metadata(invalid_invalid_handle, VERKEY);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod key_for_did {
+        use super::*;
+
+        #[test]
+        fn indy_key_for_did_works_for_my_did() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (did, verkey, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, &did).unwrap();
+            assert_eq!(verkey, received_verkey);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_their_did() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let identity_json = format!(r#""{{""did"":""{}"", ""verkey"":""{}""}}""#, DID, VERKEY);
+            SignusUtils::store_their_did(wallet_handle, &identity_json).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, DID).unwrap();
+            assert_eq!(VERKEY, received_verkey);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_get_key_from_ledger() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let trustee_wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (trustee_did, _, _) = SignusUtils::create_and_store_my_did(trustee_wallet_handle, Some(TRUSTEE_SEED)).unwrap();
+            let (did, verkey, _) = SignusUtils::create_and_store_my_did(trustee_wallet_handle, None).unwrap();
+
+            let nym_request = LedgerUtils::build_nym_request(&trustee_did, &did, Some(&verkey), None, None).unwrap();
+            LedgerUtils::sign_and_submit_request(pool_handle, trustee_wallet_handle, &trustee_did, &nym_request).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, &did).unwrap();
+            assert_eq!(verkey, received_verkey);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_unknown_did() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::key_for_did(pool_handle, wallet_handle, DID);
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_incompatible_wallet_and_pool() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(""other pool"", None).unwrap();
+
+            let (did, _, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let res = SignusUtils::key_for_did(pool_handle, wallet_handle, &did);
+            assert_eq!(ErrorCode::WalletIncompatiblePoolError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_invalid_pool_handle() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (did, _, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let invalid_pool_handle = pool_handle + 1;
+            let res = SignusUtils::key_for_did(invalid_pool_handle, wallet_handle, &did);
+            assert_eq!(ErrorCode::PoolLedgerInvalidPoolHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (did, _, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::key_for_did(pool_handle, invalid_wallet_handle, &did);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod set_endpoint_for_did {
+        use super::*;
+
+        #[test]
+        fn indy_set_endpoint_for_did_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::set_endpoint_for_did(wallet_handle, DID, ENDPOINT).unwrap();
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_set_endpoint_for_did_works_for_invalid_did() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::set_endpoint_for_did(wallet_handle, ""invalid_base58string"", ENDPOINT);
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            let res = SignusUtils::set_endpoint_for_did(wallet_handle, ""invalidDidLength"", ENDPOINT);
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_set_endpoint_for_did_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::set_endpoint_for_did(invalid_wallet_handle, DID, ENDPOINT);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod get_endpoint_for_did {
+        use super::*;
+
+        #[test]
+        fn indy_get_endpoint_for_did_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let identity_json = format!(r#""{{""did"":""{}"", ""verkey"":""{}""}}""#, DID, VERKEY);
+            SignusUtils::create_my_did(wallet_handle, &identity_json).unwrap();
+
+            SignusUtils::set_endpoint_for_did(wallet_handle, DID, ENDPOINT).unwrap();
+
+            let (endpoint, key) = SignusUtils::get_endpoint_for_did(wallet_handle, DID).unwrap();
+            assert_eq!(ENDPOINT, endpoint);
+            assert_eq!(VERKEY, key.unwrap());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_endpoint_for_did_works_for_their_did() {",,2017-10-23 15:11:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/146254450,https://github.com/hyperledger/indy-sdk/pull/335#discussion_r146254450,jovfer
https://github.com/hyperledger/indy-sdk/pull/335,https://github.com/hyperledger/indy-sdk/pull/335,Unclear test name,2030acc26913855cdf99c0cdf4bd809f30d1965c,2017-10-23 12:54:35,146254591,"@@ -26,16 +26,640 @@ use indy::api::ErrorCode;
 
 use std::{thread, time};
 
-pub const MESSAGE: &'static str = r#""{""reqId"":1496822211362017764}""#;
 pub const ENCRYPTED_MESSAGE: &'static [u8; 45] = &[187, 227, 10, 29, 46, 178, 12, 179, 197, 69, 171, 70, 228, 204, 52, 22, 199, 54, 62, 13, 115, 5, 216, 66, 20, 131, 121, 29, 251, 224, 253, 201, 75, 73, 225, 237, 219, 133, 35, 217, 131, 135, 232, 129, 32];
-pub const NONCE: &'static [u8; 24] = &[242, 246, 53, 153, 106, 37, 185, 65, 212, 14, 109, 131, 200, 169, 94, 110, 51, 47, 101, 89, 0, 171, 105, 183];
 pub const SIGNATURE: &'static [u8; 64] = &[169, 215, 8, 225, 7, 107, 110, 9, 193, 162, 202, 214, 162, 66, 238, 211, 63, 209, 12, 196, 8, 211, 55, 27, 120, 94, 204, 147, 53, 104, 103, 61, 60, 249, 237, 127, 103, 46, 220, 223, 10, 95, 75, 53, 245, 210, 241, 151, 191, 41, 48, 30, 9, 16, 78, 252, 157, 206, 210, 145, 125, 133, 109, 11];
 pub const DID: &'static str = ""NcYxiDXkpYi6ov5FcYDi1e"";
-pub const VERKEY: &'static str = ""CnEDk9HrMnmiHXEV1WFgbVCRteYnPqsJwrTdcZaNhFVW"";
+pub const METADATA: &'static str = ""some_metadata"";
+
 
 mod high_cases {
     use super::*;
 
+    mod create_key {
+        use super::*;
+        use rust_base58::FromBase58;
+
+        #[test]
+        fn indy_create_key_works_for_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let verkey = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+            assert_eq!(verkey.from_base58().unwrap().len(), 32);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_without_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let verkey = SignusUtils::create_key(wallet_handle, None).unwrap();
+            assert_eq!(verkey.from_base58().unwrap().len(), 32);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_for_invalid_wallet_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::create_key(invalid_wallet_handle, None);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_for_invalid_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::create_key(wallet_handle, Some(""invalidSeedLength""));
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            let res = SignusUtils::create_key(wallet_handle, Some(""invalid_base58_string11111111111""));
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod store_key_metadata {
+        use super::*;
+
+        #[test]
+        fn indy_store_key_metadata_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_replace() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!(METADATA.to_string(), metadata);
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, ""updated metadata"").unwrap();
+            let updated_metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_ne!(METADATA.to_string(), updated_metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::store_key_metadata(invalid_wallet_handle, VERKEY, METADATA);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_empty_string() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, """").unwrap();
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod get_key_metadata {
+        use super::*;
+
+        #[test]
+        fn indy_get_key_metadata_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!(METADATA.to_string(), metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_empty_string() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, """").unwrap();
+
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!("""", metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_no_metadata() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::get_key_metadata(wallet_handle, VERKEY);
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            let invalid_invalid_handle = wallet_handle + 1;
+            let res = SignusUtils::get_key_metadata(invalid_invalid_handle, VERKEY);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod key_for_did {
+        use super::*;
+
+        #[test]
+        fn indy_key_for_did_works_for_my_did() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (did, verkey, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, &did).unwrap();
+            assert_eq!(verkey, received_verkey);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_their_did() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let identity_json = format!(r#""{{""did"":""{}"", ""verkey"":""{}""}}""#, DID, VERKEY);
+            SignusUtils::store_their_did(wallet_handle, &identity_json).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, DID).unwrap();
+            assert_eq!(VERKEY, received_verkey);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_get_key_from_ledger() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let trustee_wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (trustee_did, _, _) = SignusUtils::create_and_store_my_did(trustee_wallet_handle, Some(TRUSTEE_SEED)).unwrap();
+            let (did, verkey, _) = SignusUtils::create_and_store_my_did(trustee_wallet_handle, None).unwrap();
+
+            let nym_request = LedgerUtils::build_nym_request(&trustee_did, &did, Some(&verkey), None, None).unwrap();
+            LedgerUtils::sign_and_submit_request(pool_handle, trustee_wallet_handle, &trustee_did, &nym_request).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, &did).unwrap();
+            assert_eq!(verkey, received_verkey);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_unknown_did() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::key_for_did(pool_handle, wallet_handle, DID);
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_incompatible_wallet_and_pool() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(""other pool"", None).unwrap();
+
+            let (did, _, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let res = SignusUtils::key_for_did(pool_handle, wallet_handle, &did);
+            assert_eq!(ErrorCode::WalletIncompatiblePoolError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_invalid_pool_handle() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (did, _, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let invalid_pool_handle = pool_handle + 1;
+            let res = SignusUtils::key_for_did(invalid_pool_handle, wallet_handle, &did);
+            assert_eq!(ErrorCode::PoolLedgerInvalidPoolHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (did, _, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::key_for_did(pool_handle, invalid_wallet_handle, &did);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod set_endpoint_for_did {
+        use super::*;
+
+        #[test]
+        fn indy_set_endpoint_for_did_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::set_endpoint_for_did(wallet_handle, DID, ENDPOINT).unwrap();
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_set_endpoint_for_did_works_for_invalid_did() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::set_endpoint_for_did(wallet_handle, ""invalid_base58string"", ENDPOINT);
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            let res = SignusUtils::set_endpoint_for_did(wallet_handle, ""invalidDidLength"", ENDPOINT);
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_set_endpoint_for_did_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::set_endpoint_for_did(invalid_wallet_handle, DID, ENDPOINT);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod get_endpoint_for_did {
+        use super::*;
+
+        #[test]
+        fn indy_get_endpoint_for_did_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let identity_json = format!(r#""{{""did"":""{}"", ""verkey"":""{}""}}""#, DID, VERKEY);
+            SignusUtils::create_my_did(wallet_handle, &identity_json).unwrap();
+
+            SignusUtils::set_endpoint_for_did(wallet_handle, DID, ENDPOINT).unwrap();
+
+            let (endpoint, key) = SignusUtils::get_endpoint_for_did(wallet_handle, DID).unwrap();
+            assert_eq!(ENDPOINT, endpoint);
+            assert_eq!(VERKEY, key.unwrap());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_endpoint_for_did_works_for_their_did() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let identity_json = format!(r#""{{""did"":""{}"", ""verkey"":""{}"", ""endpoint"":""{}""}}""#, DID, VERKEY, ENDPOINT);
+            SignusUtils::store_their_did(wallet_handle, &identity_json).unwrap();
+
+            SignusUtils::set_endpoint_for_did(wallet_handle, DID, ENDPOINT).unwrap();
+
+            let (endpoint, key) = SignusUtils::get_endpoint_for_did(wallet_handle, DID).unwrap();
+            assert_eq!(ENDPOINT, endpoint);
+            assert_eq!(VERKEY, key.unwrap());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_endpoint_for_did_works_for_unknown_endpoint() {",,2017-10-23 15:11:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/146254591,https://github.com/hyperledger/indy-sdk/pull/335#discussion_r146254591,jovfer
https://github.com/hyperledger/indy-sdk/pull/335,https://github.com/hyperledger/indy-sdk/pull/335,assert_eq,2030acc26913855cdf99c0cdf4bd809f30d1965c,2017-10-23 12:56:35,146255074,"@@ -26,16 +26,640 @@ use indy::api::ErrorCode;
 
 use std::{thread, time};
 
-pub const MESSAGE: &'static str = r#""{""reqId"":1496822211362017764}""#;
 pub const ENCRYPTED_MESSAGE: &'static [u8; 45] = &[187, 227, 10, 29, 46, 178, 12, 179, 197, 69, 171, 70, 228, 204, 52, 22, 199, 54, 62, 13, 115, 5, 216, 66, 20, 131, 121, 29, 251, 224, 253, 201, 75, 73, 225, 237, 219, 133, 35, 217, 131, 135, 232, 129, 32];
-pub const NONCE: &'static [u8; 24] = &[242, 246, 53, 153, 106, 37, 185, 65, 212, 14, 109, 131, 200, 169, 94, 110, 51, 47, 101, 89, 0, 171, 105, 183];
 pub const SIGNATURE: &'static [u8; 64] = &[169, 215, 8, 225, 7, 107, 110, 9, 193, 162, 202, 214, 162, 66, 238, 211, 63, 209, 12, 196, 8, 211, 55, 27, 120, 94, 204, 147, 53, 104, 103, 61, 60, 249, 237, 127, 103, 46, 220, 223, 10, 95, 75, 53, 245, 210, 241, 151, 191, 41, 48, 30, 9, 16, 78, 252, 157, 206, 210, 145, 125, 133, 109, 11];
 pub const DID: &'static str = ""NcYxiDXkpYi6ov5FcYDi1e"";
-pub const VERKEY: &'static str = ""CnEDk9HrMnmiHXEV1WFgbVCRteYnPqsJwrTdcZaNhFVW"";
+pub const METADATA: &'static str = ""some_metadata"";
+
 
 mod high_cases {
     use super::*;
 
+    mod create_key {
+        use super::*;
+        use rust_base58::FromBase58;
+
+        #[test]
+        fn indy_create_key_works_for_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let verkey = SignusUtils::create_key(wallet_handle, Some(MY1_SEED)).unwrap();
+            assert_eq!(verkey.from_base58().unwrap().len(), 32);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_without_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let verkey = SignusUtils::create_key(wallet_handle, None).unwrap();
+            assert_eq!(verkey.from_base58().unwrap().len(), 32);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_for_invalid_wallet_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::create_key(invalid_wallet_handle, None);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_create_key_works_for_invalid_seed() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::create_key(wallet_handle, Some(""invalidSeedLength""));
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            let res = SignusUtils::create_key(wallet_handle, Some(""invalid_base58_string11111111111""));
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod store_key_metadata {
+        use super::*;
+
+        #[test]
+        fn indy_store_key_metadata_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_replace() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!(METADATA.to_string(), metadata);
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, ""updated metadata"").unwrap();
+            let updated_metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_ne!(METADATA.to_string(), updated_metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::store_key_metadata(invalid_wallet_handle, VERKEY, METADATA);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_store_key_metadata_works_for_empty_string() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, """").unwrap();
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod get_key_metadata {
+        use super::*;
+
+        #[test]
+        fn indy_get_key_metadata_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!(METADATA.to_string(), metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_empty_string() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, """").unwrap();
+
+            let metadata = SignusUtils::get_key_metadata(wallet_handle, VERKEY).unwrap();
+            assert_eq!("""", metadata);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_no_metadata() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::get_key_metadata(wallet_handle, VERKEY);
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_key_metadata_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::store_key_metadata(wallet_handle, VERKEY, METADATA).unwrap();
+
+            let invalid_invalid_handle = wallet_handle + 1;
+            let res = SignusUtils::get_key_metadata(invalid_invalid_handle, VERKEY);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod key_for_did {
+        use super::*;
+
+        #[test]
+        fn indy_key_for_did_works_for_my_did() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (did, verkey, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, &did).unwrap();
+            assert_eq!(verkey, received_verkey);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_their_did() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let identity_json = format!(r#""{{""did"":""{}"", ""verkey"":""{}""}}""#, DID, VERKEY);
+            SignusUtils::store_their_did(wallet_handle, &identity_json).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, DID).unwrap();
+            assert_eq!(VERKEY, received_verkey);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_get_key_from_ledger() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let trustee_wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (trustee_did, _, _) = SignusUtils::create_and_store_my_did(trustee_wallet_handle, Some(TRUSTEE_SEED)).unwrap();
+            let (did, verkey, _) = SignusUtils::create_and_store_my_did(trustee_wallet_handle, None).unwrap();
+
+            let nym_request = LedgerUtils::build_nym_request(&trustee_did, &did, Some(&verkey), None, None).unwrap();
+            LedgerUtils::sign_and_submit_request(pool_handle, trustee_wallet_handle, &trustee_did, &nym_request).unwrap();
+
+            let received_verkey = SignusUtils::key_for_did(pool_handle, wallet_handle, &did).unwrap();
+            assert_eq!(verkey, received_verkey);
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_unknown_did() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::key_for_did(pool_handle, wallet_handle, DID);
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_incompatible_wallet_and_pool() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(""other pool"", None).unwrap();
+
+            let (did, _, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let res = SignusUtils::key_for_did(pool_handle, wallet_handle, &did);
+            assert_eq!(ErrorCode::WalletIncompatiblePoolError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_invalid_pool_handle() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (did, _, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let invalid_pool_handle = pool_handle + 1;
+            let res = SignusUtils::key_for_did(invalid_pool_handle, wallet_handle, &did);
+            assert_eq!(ErrorCode::PoolLedgerInvalidPoolHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_key_for_did_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let pool_handle = PoolUtils::create_and_open_pool_ledger(POOL).unwrap();
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let (did, _, _) = SignusUtils::create_and_store_my_did(wallet_handle, Some(MY1_SEED)).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::key_for_did(pool_handle, invalid_wallet_handle, &did);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+            PoolUtils::close(pool_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod set_endpoint_for_did {
+        use super::*;
+
+        #[test]
+        fn indy_set_endpoint_for_did_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::set_endpoint_for_did(wallet_handle, DID, ENDPOINT).unwrap();
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_set_endpoint_for_did_works_for_invalid_did() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::set_endpoint_for_did(wallet_handle, ""invalid_base58string"", ENDPOINT);
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            let res = SignusUtils::set_endpoint_for_did(wallet_handle, ""invalidDidLength"", ENDPOINT);
+            assert_eq!(ErrorCode::CommonInvalidStructure, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_set_endpoint_for_did_works_for_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::set_endpoint_for_did(invalid_wallet_handle, DID, ENDPOINT);
+            assert_eq!(ErrorCode::WalletInvalidHandle, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod get_endpoint_for_did {
+        use super::*;
+
+        #[test]
+        fn indy_get_endpoint_for_did_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let identity_json = format!(r#""{{""did"":""{}"", ""verkey"":""{}""}}""#, DID, VERKEY);
+            SignusUtils::create_my_did(wallet_handle, &identity_json).unwrap();
+
+            SignusUtils::set_endpoint_for_did(wallet_handle, DID, ENDPOINT).unwrap();
+
+            let (endpoint, key) = SignusUtils::get_endpoint_for_did(wallet_handle, DID).unwrap();
+            assert_eq!(ENDPOINT, endpoint);
+            assert_eq!(VERKEY, key.unwrap());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_endpoint_for_did_works_for_their_did() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let identity_json = format!(r#""{{""did"":""{}"", ""verkey"":""{}"", ""endpoint"":""{}""}}""#, DID, VERKEY, ENDPOINT);
+            SignusUtils::store_their_did(wallet_handle, &identity_json).unwrap();
+
+            SignusUtils::set_endpoint_for_did(wallet_handle, DID, ENDPOINT).unwrap();
+
+            let (endpoint, key) = SignusUtils::get_endpoint_for_did(wallet_handle, DID).unwrap();
+            assert_eq!(ENDPOINT, endpoint);
+            assert_eq!(VERKEY, key.unwrap());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_endpoint_for_did_works_for_unknown_endpoint() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let identity_json = format!(r#""{{""did"":""{}"", ""verkey"":""{}""}}""#, DID, VERKEY);
+            SignusUtils::create_my_did(wallet_handle, &identity_json).unwrap();
+
+            let res = SignusUtils::get_endpoint_for_did(wallet_handle, DID);
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_endpoint_for_did_works_for_unknown_did() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let res = SignusUtils::get_endpoint_for_did(wallet_handle, DID);
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_get_endpoint_for_did_works_invalid_handle() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            let identity_json = format!(r#""{{""did"":""{}"", ""verkey"":""{}"", ""endpoint"":""{}""}}""#, DID, VERKEY, ENDPOINT);
+            SignusUtils::create_my_did(wallet_handle, &identity_json).unwrap();
+
+            SignusUtils::set_endpoint_for_did(wallet_handle, DID, ENDPOINT).unwrap();
+
+            let invalid_wallet_handle = wallet_handle + 1;
+            let res = SignusUtils::get_endpoint_for_did(invalid_wallet_handle, DID);
+            assert_eq!(ErrorCode::WalletNotFoundError, res.unwrap_err());
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+    }
+
+    mod set_did_metadata {
+        use super::*;
+
+        #[test]
+        fn indy_set_did_metadata_works() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::set_did_metadata(wallet_handle, DID, METADATA).unwrap();
+
+            WalletUtils::close_wallet(wallet_handle).unwrap();
+
+            TestUtils::cleanup_storage();
+        }
+
+        #[test]
+        fn indy_set_did_metadata_works_for_replace() {
+            TestUtils::cleanup_storage();
+
+            let wallet_handle = WalletUtils::create_and_open_wallet(POOL, None).unwrap();
+
+            SignusUtils::set_did_metadata(wallet_handle, DID, METADATA).unwrap();
+            let metadata = SignusUtils::get_did_metadata(wallet_handle, DID).unwrap();
+            assert_eq!(METADATA.to_string(), metadata);
+
+            SignusUtils::set_did_metadata(wallet_handle, DID, ""updated metadata"").unwrap();
+            let updated_metadata = SignusUtils::get_did_metadata(wallet_handle, DID).unwrap();
+            assert_ne!(METADATA.to_string(), updated_metadata);",518,2017-10-23 15:11:38,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/146255074,https://github.com/hyperledger/indy-sdk/pull/335#discussion_r146255074,jovfer
https://github.com/hyperledger/indy-sdk/pull/321,https://github.com/hyperledger/indy-sdk/pull/321,"Wallet Closed is not full term for this error, please return to WalletInvalidHandleException.",1a34b4b8077ca284f0e184fe87bb88f3d9775f44,2017-10-19 09:44:54,145649395,"@@ -1,40 +1,133 @@
 package org.hyperledger.indy.sdk;
 
+import org.hyperledger.indy.sdk.anoncreds.AccumulatorFullException;
+import org.hyperledger.indy.sdk.anoncreds.ClaimRevokedException;
+import org.hyperledger.indy.sdk.anoncreds.NotIssuedException;
+import org.hyperledger.indy.sdk.anoncreds.DuplicateMasterSecretNameException;
+import org.hyperledger.indy.sdk.anoncreds.InvalidUserRevocIndexException;
+import org.hyperledger.indy.sdk.anoncreds.ProofRejectedException;
+import org.hyperledger.indy.sdk.anoncreds.RevocationRegistryFullException;
+import org.hyperledger.indy.sdk.ledger.ConsensusException;
+import org.hyperledger.indy.sdk.ledger.InvalidLedgerTransactionException;
+import org.hyperledger.indy.sdk.ledger.LedgerSecurityException;
+import org.hyperledger.indy.sdk.pool.PoolClosedException;
+import org.hyperledger.indy.sdk.pool.PoolConfigNotCreatedException;
+import org.hyperledger.indy.sdk.pool.PoolLedgerConfigExistsException;
+import org.hyperledger.indy.sdk.pool.PoolLedgerTerminatedException;
+import org.hyperledger.indy.sdk.signus.UnknownCryptoException;
+import org.hyperledger.indy.sdk.wallet.DuplicateWalletTypeException;
+import org.hyperledger.indy.sdk.wallet.UnknownWalletTypeException;
+import org.hyperledger.indy.sdk.wallet.WalletAlreadyOpenedException;
+import org.hyperledger.indy.sdk.wallet.WalletClosedException;
+import org.hyperledger.indy.sdk.wallet.WalletExistsException;
+import org.hyperledger.indy.sdk.wallet.WalletValueNotFoundException;
+import org.hyperledger.indy.sdk.wallet.WrongWalletForPoolException;
+
 /**
- * Indy specific exception.
+ * Thrown when an Indy specific error has occurred.
  */
 public class IndyException extends Exception {
 
 	private static final long serialVersionUID = 2650355290834266477L;
-
-	private ErrorCode errorCode;
+	private int sdkErrorCode;
 
 	/**
 	 * Initializes a new IndyException with the specified message.
 	 * 
 	 * @param message The message for the exception.
 	 */
-	public IndyException(String message) {
-
+	protected IndyException(String message, int sdkErrorCode) {
 		super(message);
+		this.sdkErrorCode = sdkErrorCode;
 	}
 
 	/**
-	 * Initializes a new IndyException using the specified ErrorCode.
+	 * Gets the SDK error code for the exception.
 	 * 
-	 * @param errorCode The error code for the exception.
+	 * @return The SDK error code used to construct the exception.
 	 */
-	public IndyException(ErrorCode errorCode) {
-		this(String.format(""%s: %d"", errorCode.name(), errorCode.value()));
-		this.errorCode = errorCode;
+	public int getSdkErrorCode() {
+		return sdkErrorCode;
 	}
-
+	
 	/**
-	 * Gets the ErrorCode for the exception.
+	 * Initializes a new IndyException using the specified SDK error code.
 	 * 
-	 * @return The ErrorCode used to construct the exception.
+	 * @param sdkErrorCode The SDK error code to construct the exception from.
 	 */
-	public ErrorCode getErrorCode() {
-		return errorCode;
+	public static IndyException fromSdkError(int sdkErrorCode) {
+		
+		ErrorCode errorCode = ErrorCode.valueOf(sdkErrorCode);
+		
+		switch(errorCode){
+			case CommonInvalidParam1:
+			case CommonInvalidParam2:
+			case CommonInvalidParam3:
+			case CommonInvalidParam4:
+			case CommonInvalidParam5:
+			case CommonInvalidParam6:
+			case CommonInvalidParam7:
+			case CommonInvalidParam8:
+			case CommonInvalidParam9:
+			case CommonInvalidParam10:
+			case CommonInvalidParam11:
+			case CommonInvalidParam12:
+				return new InvalidParameterException(sdkErrorCode);
+			case CommonInvalidState:
+				return new InvalidStateException();
+			case CommonInvalidStructure:
+				return new InvalidStructureException();
+			case CommonIOError:
+				return new IOException();
+			case WalletInvalidHandle:
+				return new WalletClosedException();",,2017-10-19 15:35:47,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/145649395,https://github.com/hyperledger/indy-sdk/pull/321#discussion_r145649395,jovfer
https://github.com/hyperledger/indy-sdk/pull/321,https://github.com/hyperledger/indy-sdk/pull/321,Like a Wallet invalid/closed: should be PoolInvalidHandleException,1a34b4b8077ca284f0e184fe87bb88f3d9775f44,2017-10-19 09:46:17,145649706,"@@ -1,40 +1,133 @@
 package org.hyperledger.indy.sdk;
 
+import org.hyperledger.indy.sdk.anoncreds.AccumulatorFullException;
+import org.hyperledger.indy.sdk.anoncreds.ClaimRevokedException;
+import org.hyperledger.indy.sdk.anoncreds.NotIssuedException;
+import org.hyperledger.indy.sdk.anoncreds.DuplicateMasterSecretNameException;
+import org.hyperledger.indy.sdk.anoncreds.InvalidUserRevocIndexException;
+import org.hyperledger.indy.sdk.anoncreds.ProofRejectedException;
+import org.hyperledger.indy.sdk.anoncreds.RevocationRegistryFullException;
+import org.hyperledger.indy.sdk.ledger.ConsensusException;
+import org.hyperledger.indy.sdk.ledger.InvalidLedgerTransactionException;
+import org.hyperledger.indy.sdk.ledger.LedgerSecurityException;
+import org.hyperledger.indy.sdk.pool.PoolClosedException;
+import org.hyperledger.indy.sdk.pool.PoolConfigNotCreatedException;
+import org.hyperledger.indy.sdk.pool.PoolLedgerConfigExistsException;
+import org.hyperledger.indy.sdk.pool.PoolLedgerTerminatedException;
+import org.hyperledger.indy.sdk.signus.UnknownCryptoException;
+import org.hyperledger.indy.sdk.wallet.DuplicateWalletTypeException;
+import org.hyperledger.indy.sdk.wallet.UnknownWalletTypeException;
+import org.hyperledger.indy.sdk.wallet.WalletAlreadyOpenedException;
+import org.hyperledger.indy.sdk.wallet.WalletClosedException;
+import org.hyperledger.indy.sdk.wallet.WalletExistsException;
+import org.hyperledger.indy.sdk.wallet.WalletValueNotFoundException;
+import org.hyperledger.indy.sdk.wallet.WrongWalletForPoolException;
+
 /**
- * Indy specific exception.
+ * Thrown when an Indy specific error has occurred.
  */
 public class IndyException extends Exception {
 
 	private static final long serialVersionUID = 2650355290834266477L;
-
-	private ErrorCode errorCode;
+	private int sdkErrorCode;
 
 	/**
 	 * Initializes a new IndyException with the specified message.
 	 * 
 	 * @param message The message for the exception.
 	 */
-	public IndyException(String message) {
-
+	protected IndyException(String message, int sdkErrorCode) {
 		super(message);
+		this.sdkErrorCode = sdkErrorCode;
 	}
 
 	/**
-	 * Initializes a new IndyException using the specified ErrorCode.
+	 * Gets the SDK error code for the exception.
 	 * 
-	 * @param errorCode The error code for the exception.
+	 * @return The SDK error code used to construct the exception.
 	 */
-	public IndyException(ErrorCode errorCode) {
-		this(String.format(""%s: %d"", errorCode.name(), errorCode.value()));
-		this.errorCode = errorCode;
+	public int getSdkErrorCode() {
+		return sdkErrorCode;
 	}
-
+	
 	/**
-	 * Gets the ErrorCode for the exception.
+	 * Initializes a new IndyException using the specified SDK error code.
 	 * 
-	 * @return The ErrorCode used to construct the exception.
+	 * @param sdkErrorCode The SDK error code to construct the exception from.
 	 */
-	public ErrorCode getErrorCode() {
-		return errorCode;
+	public static IndyException fromSdkError(int sdkErrorCode) {
+		
+		ErrorCode errorCode = ErrorCode.valueOf(sdkErrorCode);
+		
+		switch(errorCode){
+			case CommonInvalidParam1:
+			case CommonInvalidParam2:
+			case CommonInvalidParam3:
+			case CommonInvalidParam4:
+			case CommonInvalidParam5:
+			case CommonInvalidParam6:
+			case CommonInvalidParam7:
+			case CommonInvalidParam8:
+			case CommonInvalidParam9:
+			case CommonInvalidParam10:
+			case CommonInvalidParam11:
+			case CommonInvalidParam12:
+				return new InvalidParameterException(sdkErrorCode);
+			case CommonInvalidState:
+				return new InvalidStateException();
+			case CommonInvalidStructure:
+				return new InvalidStructureException();
+			case CommonIOError:
+				return new IOException();
+			case WalletInvalidHandle:
+				return new WalletClosedException();
+			case WalletUnknownTypeError:
+				return new UnknownWalletTypeException();
+			case WalletTypeAlreadyRegisteredError:
+				return new DuplicateWalletTypeException();
+			case WalletAlreadyExistsError:
+				return new WalletExistsException();
+			case WalletNotFoundError:
+				return new WalletValueNotFoundException();
+			case WalletIncompatiblePoolError:
+				return new WrongWalletForPoolException();
+			case WalletAlreadyOpenedError:
+				return new WalletAlreadyOpenedException();
+			case PoolLedgerNotCreatedError:
+				return new PoolConfigNotCreatedException();
+			case PoolLedgerInvalidPoolHandle:
+				return new PoolClosedException();",,2017-10-19 15:35:47,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/145649706,https://github.com/hyperledger/indy-sdk/pull/321#discussion_r145649706,jovfer
https://github.com/hyperledger/indy-sdk/pull/321,https://github.com/hyperledger/indy-sdk/pull/321,"WalletInvalidHandleException is not really a clear description either - the developer never sees the handle as they only work with Wallet instances.  Perhaps there's a better term we could use? Handles are an internal artifact for the Java wrapper.
",1a34b4b8077ca284f0e184fe87bb88f3d9775f44,2017-10-19 11:56:52,145677688,"@@ -1,40 +1,133 @@
 package org.hyperledger.indy.sdk;
 
+import org.hyperledger.indy.sdk.anoncreds.AccumulatorFullException;
+import org.hyperledger.indy.sdk.anoncreds.ClaimRevokedException;
+import org.hyperledger.indy.sdk.anoncreds.NotIssuedException;
+import org.hyperledger.indy.sdk.anoncreds.DuplicateMasterSecretNameException;
+import org.hyperledger.indy.sdk.anoncreds.InvalidUserRevocIndexException;
+import org.hyperledger.indy.sdk.anoncreds.ProofRejectedException;
+import org.hyperledger.indy.sdk.anoncreds.RevocationRegistryFullException;
+import org.hyperledger.indy.sdk.ledger.ConsensusException;
+import org.hyperledger.indy.sdk.ledger.InvalidLedgerTransactionException;
+import org.hyperledger.indy.sdk.ledger.LedgerSecurityException;
+import org.hyperledger.indy.sdk.pool.PoolClosedException;
+import org.hyperledger.indy.sdk.pool.PoolConfigNotCreatedException;
+import org.hyperledger.indy.sdk.pool.PoolLedgerConfigExistsException;
+import org.hyperledger.indy.sdk.pool.PoolLedgerTerminatedException;
+import org.hyperledger.indy.sdk.signus.UnknownCryptoException;
+import org.hyperledger.indy.sdk.wallet.DuplicateWalletTypeException;
+import org.hyperledger.indy.sdk.wallet.UnknownWalletTypeException;
+import org.hyperledger.indy.sdk.wallet.WalletAlreadyOpenedException;
+import org.hyperledger.indy.sdk.wallet.WalletClosedException;
+import org.hyperledger.indy.sdk.wallet.WalletExistsException;
+import org.hyperledger.indy.sdk.wallet.WalletValueNotFoundException;
+import org.hyperledger.indy.sdk.wallet.WrongWalletForPoolException;
+
 /**
- * Indy specific exception.
+ * Thrown when an Indy specific error has occurred.
  */
 public class IndyException extends Exception {
 
 	private static final long serialVersionUID = 2650355290834266477L;
-
-	private ErrorCode errorCode;
+	private int sdkErrorCode;
 
 	/**
 	 * Initializes a new IndyException with the specified message.
 	 * 
 	 * @param message The message for the exception.
 	 */
-	public IndyException(String message) {
-
+	protected IndyException(String message, int sdkErrorCode) {
 		super(message);
+		this.sdkErrorCode = sdkErrorCode;
 	}
 
 	/**
-	 * Initializes a new IndyException using the specified ErrorCode.
+	 * Gets the SDK error code for the exception.
 	 * 
-	 * @param errorCode The error code for the exception.
+	 * @return The SDK error code used to construct the exception.
 	 */
-	public IndyException(ErrorCode errorCode) {
-		this(String.format(""%s: %d"", errorCode.name(), errorCode.value()));
-		this.errorCode = errorCode;
+	public int getSdkErrorCode() {
+		return sdkErrorCode;
 	}
-
+	
 	/**
-	 * Gets the ErrorCode for the exception.
+	 * Initializes a new IndyException using the specified SDK error code.
 	 * 
-	 * @return The ErrorCode used to construct the exception.
+	 * @param sdkErrorCode The SDK error code to construct the exception from.
 	 */
-	public ErrorCode getErrorCode() {
-		return errorCode;
+	public static IndyException fromSdkError(int sdkErrorCode) {
+		
+		ErrorCode errorCode = ErrorCode.valueOf(sdkErrorCode);
+		
+		switch(errorCode){
+			case CommonInvalidParam1:
+			case CommonInvalidParam2:
+			case CommonInvalidParam3:
+			case CommonInvalidParam4:
+			case CommonInvalidParam5:
+			case CommonInvalidParam6:
+			case CommonInvalidParam7:
+			case CommonInvalidParam8:
+			case CommonInvalidParam9:
+			case CommonInvalidParam10:
+			case CommonInvalidParam11:
+			case CommonInvalidParam12:
+				return new InvalidParameterException(sdkErrorCode);
+			case CommonInvalidState:
+				return new InvalidStateException();
+			case CommonInvalidStructure:
+				return new InvalidStructureException();
+			case CommonIOError:
+				return new IOException();
+			case WalletInvalidHandle:
+				return new WalletClosedException();",,2017-10-19 15:35:47,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/145677688,https://github.com/hyperledger/indy-sdk/pull/321#discussion_r145677688,srottem
https://github.com/hyperledger/indy-sdk/pull/321,https://github.com/hyperledger/indy-sdk/pull/321,"Thanks for note, java wrapper API is actually handle-less.
As for **current implementation** of wrapper for wallet it's actually only `WalletClosed`...
But if we modify something it may add another reasons. So both WalletClosed and WalletInvalidHandle seems inaccuracy.
May be `InvalidWallet` or `WalletInvalidState` are more applicable terms. I haven't good idea for this exception. @vimmerru?",1a34b4b8077ca284f0e184fe87bb88f3d9775f44,2017-10-19 13:16:14,145695661,"@@ -1,40 +1,133 @@
 package org.hyperledger.indy.sdk;
 
+import org.hyperledger.indy.sdk.anoncreds.AccumulatorFullException;
+import org.hyperledger.indy.sdk.anoncreds.ClaimRevokedException;
+import org.hyperledger.indy.sdk.anoncreds.NotIssuedException;
+import org.hyperledger.indy.sdk.anoncreds.DuplicateMasterSecretNameException;
+import org.hyperledger.indy.sdk.anoncreds.InvalidUserRevocIndexException;
+import org.hyperledger.indy.sdk.anoncreds.ProofRejectedException;
+import org.hyperledger.indy.sdk.anoncreds.RevocationRegistryFullException;
+import org.hyperledger.indy.sdk.ledger.ConsensusException;
+import org.hyperledger.indy.sdk.ledger.InvalidLedgerTransactionException;
+import org.hyperledger.indy.sdk.ledger.LedgerSecurityException;
+import org.hyperledger.indy.sdk.pool.PoolClosedException;
+import org.hyperledger.indy.sdk.pool.PoolConfigNotCreatedException;
+import org.hyperledger.indy.sdk.pool.PoolLedgerConfigExistsException;
+import org.hyperledger.indy.sdk.pool.PoolLedgerTerminatedException;
+import org.hyperledger.indy.sdk.signus.UnknownCryptoException;
+import org.hyperledger.indy.sdk.wallet.DuplicateWalletTypeException;
+import org.hyperledger.indy.sdk.wallet.UnknownWalletTypeException;
+import org.hyperledger.indy.sdk.wallet.WalletAlreadyOpenedException;
+import org.hyperledger.indy.sdk.wallet.WalletClosedException;
+import org.hyperledger.indy.sdk.wallet.WalletExistsException;
+import org.hyperledger.indy.sdk.wallet.WalletValueNotFoundException;
+import org.hyperledger.indy.sdk.wallet.WrongWalletForPoolException;
+
 /**
- * Indy specific exception.
+ * Thrown when an Indy specific error has occurred.
  */
 public class IndyException extends Exception {
 
 	private static final long serialVersionUID = 2650355290834266477L;
-
-	private ErrorCode errorCode;
+	private int sdkErrorCode;
 
 	/**
 	 * Initializes a new IndyException with the specified message.
 	 * 
 	 * @param message The message for the exception.
 	 */
-	public IndyException(String message) {
-
+	protected IndyException(String message, int sdkErrorCode) {
 		super(message);
+		this.sdkErrorCode = sdkErrorCode;
 	}
 
 	/**
-	 * Initializes a new IndyException using the specified ErrorCode.
+	 * Gets the SDK error code for the exception.
 	 * 
-	 * @param errorCode The error code for the exception.
+	 * @return The SDK error code used to construct the exception.
 	 */
-	public IndyException(ErrorCode errorCode) {
-		this(String.format(""%s: %d"", errorCode.name(), errorCode.value()));
-		this.errorCode = errorCode;
+	public int getSdkErrorCode() {
+		return sdkErrorCode;
 	}
-
+	
 	/**
-	 * Gets the ErrorCode for the exception.
+	 * Initializes a new IndyException using the specified SDK error code.
 	 * 
-	 * @return The ErrorCode used to construct the exception.
+	 * @param sdkErrorCode The SDK error code to construct the exception from.
 	 */
-	public ErrorCode getErrorCode() {
-		return errorCode;
+	public static IndyException fromSdkError(int sdkErrorCode) {
+		
+		ErrorCode errorCode = ErrorCode.valueOf(sdkErrorCode);
+		
+		switch(errorCode){
+			case CommonInvalidParam1:
+			case CommonInvalidParam2:
+			case CommonInvalidParam3:
+			case CommonInvalidParam4:
+			case CommonInvalidParam5:
+			case CommonInvalidParam6:
+			case CommonInvalidParam7:
+			case CommonInvalidParam8:
+			case CommonInvalidParam9:
+			case CommonInvalidParam10:
+			case CommonInvalidParam11:
+			case CommonInvalidParam12:
+				return new InvalidParameterException(sdkErrorCode);
+			case CommonInvalidState:
+				return new InvalidStateException();
+			case CommonInvalidStructure:
+				return new InvalidStructureException();
+			case CommonIOError:
+				return new IOException();
+			case WalletInvalidHandle:
+				return new WalletClosedException();",,2017-10-19 15:35:47,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/145695661,https://github.com/hyperledger/indy-sdk/pull/321#discussion_r145695661,jovfer
https://github.com/hyperledger/indy-sdk/pull/321,https://github.com/hyperledger/indy-sdk/pull/321,I suggest leaving original errors without introducing new abstraction level. ,1a34b4b8077ca284f0e184fe87bb88f3d9775f44,2017-10-19 15:01:39,145727492,"@@ -1,40 +1,133 @@
 package org.hyperledger.indy.sdk;
 
+import org.hyperledger.indy.sdk.anoncreds.AccumulatorFullException;
+import org.hyperledger.indy.sdk.anoncreds.ClaimRevokedException;
+import org.hyperledger.indy.sdk.anoncreds.NotIssuedException;
+import org.hyperledger.indy.sdk.anoncreds.DuplicateMasterSecretNameException;
+import org.hyperledger.indy.sdk.anoncreds.InvalidUserRevocIndexException;
+import org.hyperledger.indy.sdk.anoncreds.ProofRejectedException;
+import org.hyperledger.indy.sdk.anoncreds.RevocationRegistryFullException;
+import org.hyperledger.indy.sdk.ledger.ConsensusException;
+import org.hyperledger.indy.sdk.ledger.InvalidLedgerTransactionException;
+import org.hyperledger.indy.sdk.ledger.LedgerSecurityException;
+import org.hyperledger.indy.sdk.pool.PoolClosedException;
+import org.hyperledger.indy.sdk.pool.PoolConfigNotCreatedException;
+import org.hyperledger.indy.sdk.pool.PoolLedgerConfigExistsException;
+import org.hyperledger.indy.sdk.pool.PoolLedgerTerminatedException;
+import org.hyperledger.indy.sdk.signus.UnknownCryptoException;
+import org.hyperledger.indy.sdk.wallet.DuplicateWalletTypeException;
+import org.hyperledger.indy.sdk.wallet.UnknownWalletTypeException;
+import org.hyperledger.indy.sdk.wallet.WalletAlreadyOpenedException;
+import org.hyperledger.indy.sdk.wallet.WalletClosedException;
+import org.hyperledger.indy.sdk.wallet.WalletExistsException;
+import org.hyperledger.indy.sdk.wallet.WalletValueNotFoundException;
+import org.hyperledger.indy.sdk.wallet.WrongWalletForPoolException;
+
 /**
- * Indy specific exception.
+ * Thrown when an Indy specific error has occurred.
  */
 public class IndyException extends Exception {
 
 	private static final long serialVersionUID = 2650355290834266477L;
-
-	private ErrorCode errorCode;
+	private int sdkErrorCode;
 
 	/**
 	 * Initializes a new IndyException with the specified message.
 	 * 
 	 * @param message The message for the exception.
 	 */
-	public IndyException(String message) {
-
+	protected IndyException(String message, int sdkErrorCode) {
 		super(message);
+		this.sdkErrorCode = sdkErrorCode;
 	}
 
 	/**
-	 * Initializes a new IndyException using the specified ErrorCode.
+	 * Gets the SDK error code for the exception.
 	 * 
-	 * @param errorCode The error code for the exception.
+	 * @return The SDK error code used to construct the exception.
 	 */
-	public IndyException(ErrorCode errorCode) {
-		this(String.format(""%s: %d"", errorCode.name(), errorCode.value()));
-		this.errorCode = errorCode;
+	public int getSdkErrorCode() {
+		return sdkErrorCode;
 	}
-
+	
 	/**
-	 * Gets the ErrorCode for the exception.
+	 * Initializes a new IndyException using the specified SDK error code.
 	 * 
-	 * @return The ErrorCode used to construct the exception.
+	 * @param sdkErrorCode The SDK error code to construct the exception from.
 	 */
-	public ErrorCode getErrorCode() {
-		return errorCode;
+	public static IndyException fromSdkError(int sdkErrorCode) {
+		
+		ErrorCode errorCode = ErrorCode.valueOf(sdkErrorCode);
+		
+		switch(errorCode){
+			case CommonInvalidParam1:
+			case CommonInvalidParam2:
+			case CommonInvalidParam3:
+			case CommonInvalidParam4:
+			case CommonInvalidParam5:
+			case CommonInvalidParam6:
+			case CommonInvalidParam7:
+			case CommonInvalidParam8:
+			case CommonInvalidParam9:
+			case CommonInvalidParam10:
+			case CommonInvalidParam11:
+			case CommonInvalidParam12:
+				return new InvalidParameterException(sdkErrorCode);
+			case CommonInvalidState:
+				return new InvalidStateException();
+			case CommonInvalidStructure:
+				return new InvalidStructureException();
+			case CommonIOError:
+				return new IOException();
+			case WalletInvalidHandle:
+				return new WalletClosedException();
+			case WalletUnknownTypeError:
+				return new UnknownWalletTypeException();
+			case WalletTypeAlreadyRegisteredError:
+				return new DuplicateWalletTypeException();
+			case WalletAlreadyExistsError:
+				return new WalletExistsException();
+			case WalletNotFoundError:
+				return new WalletValueNotFoundException();
+			case WalletIncompatiblePoolError:
+				return new WrongWalletForPoolException();
+			case WalletAlreadyOpenedError:
+				return new WalletAlreadyOpenedException();
+			case PoolLedgerNotCreatedError:
+				return new PoolConfigNotCreatedException();
+			case PoolLedgerInvalidPoolHandle:
+				return new PoolClosedException();",,2017-10-19 15:35:47,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/145727492,https://github.com/hyperledger/indy-sdk/pull/321#discussion_r145727492,vimmerru
https://github.com/hyperledger/indy-sdk/pull/321,https://github.com/hyperledger/indy-sdk/pull/321,We already had a discussion about this here: https://github.com/hyperledger/indy-sdk/pull/274.  The change was approved for the .NET wrapper so doesn't it make sense to have it in the Java wrapper too?,1a34b4b8077ca284f0e184fe87bb88f3d9775f44,2017-10-19 15:19:25,145733220,"@@ -1,40 +1,133 @@
 package org.hyperledger.indy.sdk;
 
+import org.hyperledger.indy.sdk.anoncreds.AccumulatorFullException;
+import org.hyperledger.indy.sdk.anoncreds.ClaimRevokedException;
+import org.hyperledger.indy.sdk.anoncreds.NotIssuedException;
+import org.hyperledger.indy.sdk.anoncreds.DuplicateMasterSecretNameException;
+import org.hyperledger.indy.sdk.anoncreds.InvalidUserRevocIndexException;
+import org.hyperledger.indy.sdk.anoncreds.ProofRejectedException;
+import org.hyperledger.indy.sdk.anoncreds.RevocationRegistryFullException;
+import org.hyperledger.indy.sdk.ledger.ConsensusException;
+import org.hyperledger.indy.sdk.ledger.InvalidLedgerTransactionException;
+import org.hyperledger.indy.sdk.ledger.LedgerSecurityException;
+import org.hyperledger.indy.sdk.pool.PoolClosedException;
+import org.hyperledger.indy.sdk.pool.PoolConfigNotCreatedException;
+import org.hyperledger.indy.sdk.pool.PoolLedgerConfigExistsException;
+import org.hyperledger.indy.sdk.pool.PoolLedgerTerminatedException;
+import org.hyperledger.indy.sdk.signus.UnknownCryptoException;
+import org.hyperledger.indy.sdk.wallet.DuplicateWalletTypeException;
+import org.hyperledger.indy.sdk.wallet.UnknownWalletTypeException;
+import org.hyperledger.indy.sdk.wallet.WalletAlreadyOpenedException;
+import org.hyperledger.indy.sdk.wallet.WalletClosedException;
+import org.hyperledger.indy.sdk.wallet.WalletExistsException;
+import org.hyperledger.indy.sdk.wallet.WalletValueNotFoundException;
+import org.hyperledger.indy.sdk.wallet.WrongWalletForPoolException;
+
 /**
- * Indy specific exception.
+ * Thrown when an Indy specific error has occurred.
  */
 public class IndyException extends Exception {
 
 	private static final long serialVersionUID = 2650355290834266477L;
-
-	private ErrorCode errorCode;
+	private int sdkErrorCode;
 
 	/**
 	 * Initializes a new IndyException with the specified message.
 	 * 
 	 * @param message The message for the exception.
 	 */
-	public IndyException(String message) {
-
+	protected IndyException(String message, int sdkErrorCode) {
 		super(message);
+		this.sdkErrorCode = sdkErrorCode;
 	}
 
 	/**
-	 * Initializes a new IndyException using the specified ErrorCode.
+	 * Gets the SDK error code for the exception.
 	 * 
-	 * @param errorCode The error code for the exception.
+	 * @return The SDK error code used to construct the exception.
 	 */
-	public IndyException(ErrorCode errorCode) {
-		this(String.format(""%s: %d"", errorCode.name(), errorCode.value()));
-		this.errorCode = errorCode;
+	public int getSdkErrorCode() {
+		return sdkErrorCode;
 	}
-
+	
 	/**
-	 * Gets the ErrorCode for the exception.
+	 * Initializes a new IndyException using the specified SDK error code.
 	 * 
-	 * @return The ErrorCode used to construct the exception.
+	 * @param sdkErrorCode The SDK error code to construct the exception from.
 	 */
-	public ErrorCode getErrorCode() {
-		return errorCode;
+	public static IndyException fromSdkError(int sdkErrorCode) {
+		
+		ErrorCode errorCode = ErrorCode.valueOf(sdkErrorCode);
+		
+		switch(errorCode){
+			case CommonInvalidParam1:
+			case CommonInvalidParam2:
+			case CommonInvalidParam3:
+			case CommonInvalidParam4:
+			case CommonInvalidParam5:
+			case CommonInvalidParam6:
+			case CommonInvalidParam7:
+			case CommonInvalidParam8:
+			case CommonInvalidParam9:
+			case CommonInvalidParam10:
+			case CommonInvalidParam11:
+			case CommonInvalidParam12:
+				return new InvalidParameterException(sdkErrorCode);
+			case CommonInvalidState:
+				return new InvalidStateException();
+			case CommonInvalidStructure:
+				return new InvalidStructureException();
+			case CommonIOError:
+				return new IOException();
+			case WalletInvalidHandle:
+				return new WalletClosedException();
+			case WalletUnknownTypeError:
+				return new UnknownWalletTypeException();
+			case WalletTypeAlreadyRegisteredError:
+				return new DuplicateWalletTypeException();
+			case WalletAlreadyExistsError:
+				return new WalletExistsException();
+			case WalletNotFoundError:
+				return new WalletValueNotFoundException();
+			case WalletIncompatiblePoolError:
+				return new WrongWalletForPoolException();
+			case WalletAlreadyOpenedError:
+				return new WalletAlreadyOpenedException();
+			case PoolLedgerNotCreatedError:
+				return new PoolConfigNotCreatedException();
+			case PoolLedgerInvalidPoolHandle:
+				return new PoolClosedException();",,2017-10-19 15:35:47,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/145733220,https://github.com/hyperledger/indy-sdk/pull/321#discussion_r145733220,srottem
https://github.com/hyperledger/indy-sdk/pull/321,https://github.com/hyperledger/indy-sdk/pull/321,"@srottem, we discuss with @vimmerru and choose `InvalidWallet` and `InvalidPool`. Please use it, if you will not find better names.",1a34b4b8077ca284f0e184fe87bb88f3d9775f44,2017-10-19 15:22:01,145734069,"@@ -1,40 +1,133 @@
 package org.hyperledger.indy.sdk;
 
+import org.hyperledger.indy.sdk.anoncreds.AccumulatorFullException;
+import org.hyperledger.indy.sdk.anoncreds.ClaimRevokedException;
+import org.hyperledger.indy.sdk.anoncreds.NotIssuedException;
+import org.hyperledger.indy.sdk.anoncreds.DuplicateMasterSecretNameException;
+import org.hyperledger.indy.sdk.anoncreds.InvalidUserRevocIndexException;
+import org.hyperledger.indy.sdk.anoncreds.ProofRejectedException;
+import org.hyperledger.indy.sdk.anoncreds.RevocationRegistryFullException;
+import org.hyperledger.indy.sdk.ledger.ConsensusException;
+import org.hyperledger.indy.sdk.ledger.InvalidLedgerTransactionException;
+import org.hyperledger.indy.sdk.ledger.LedgerSecurityException;
+import org.hyperledger.indy.sdk.pool.PoolClosedException;
+import org.hyperledger.indy.sdk.pool.PoolConfigNotCreatedException;
+import org.hyperledger.indy.sdk.pool.PoolLedgerConfigExistsException;
+import org.hyperledger.indy.sdk.pool.PoolLedgerTerminatedException;
+import org.hyperledger.indy.sdk.signus.UnknownCryptoException;
+import org.hyperledger.indy.sdk.wallet.DuplicateWalletTypeException;
+import org.hyperledger.indy.sdk.wallet.UnknownWalletTypeException;
+import org.hyperledger.indy.sdk.wallet.WalletAlreadyOpenedException;
+import org.hyperledger.indy.sdk.wallet.WalletClosedException;
+import org.hyperledger.indy.sdk.wallet.WalletExistsException;
+import org.hyperledger.indy.sdk.wallet.WalletValueNotFoundException;
+import org.hyperledger.indy.sdk.wallet.WrongWalletForPoolException;
+
 /**
- * Indy specific exception.
+ * Thrown when an Indy specific error has occurred.
  */
 public class IndyException extends Exception {
 
 	private static final long serialVersionUID = 2650355290834266477L;
-
-	private ErrorCode errorCode;
+	private int sdkErrorCode;
 
 	/**
 	 * Initializes a new IndyException with the specified message.
 	 * 
 	 * @param message The message for the exception.
 	 */
-	public IndyException(String message) {
-
+	protected IndyException(String message, int sdkErrorCode) {
 		super(message);
+		this.sdkErrorCode = sdkErrorCode;
 	}
 
 	/**
-	 * Initializes a new IndyException using the specified ErrorCode.
+	 * Gets the SDK error code for the exception.
 	 * 
-	 * @param errorCode The error code for the exception.
+	 * @return The SDK error code used to construct the exception.
 	 */
-	public IndyException(ErrorCode errorCode) {
-		this(String.format(""%s: %d"", errorCode.name(), errorCode.value()));
-		this.errorCode = errorCode;
+	public int getSdkErrorCode() {
+		return sdkErrorCode;
 	}
-
+	
 	/**
-	 * Gets the ErrorCode for the exception.
+	 * Initializes a new IndyException using the specified SDK error code.
 	 * 
-	 * @return The ErrorCode used to construct the exception.
+	 * @param sdkErrorCode The SDK error code to construct the exception from.
 	 */
-	public ErrorCode getErrorCode() {
-		return errorCode;
+	public static IndyException fromSdkError(int sdkErrorCode) {
+		
+		ErrorCode errorCode = ErrorCode.valueOf(sdkErrorCode);
+		
+		switch(errorCode){
+			case CommonInvalidParam1:
+			case CommonInvalidParam2:
+			case CommonInvalidParam3:
+			case CommonInvalidParam4:
+			case CommonInvalidParam5:
+			case CommonInvalidParam6:
+			case CommonInvalidParam7:
+			case CommonInvalidParam8:
+			case CommonInvalidParam9:
+			case CommonInvalidParam10:
+			case CommonInvalidParam11:
+			case CommonInvalidParam12:
+				return new InvalidParameterException(sdkErrorCode);
+			case CommonInvalidState:
+				return new InvalidStateException();
+			case CommonInvalidStructure:
+				return new InvalidStructureException();
+			case CommonIOError:
+				return new IOException();
+			case WalletInvalidHandle:
+				return new WalletClosedException();",,2017-10-19 15:35:47,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/145734069,https://github.com/hyperledger/indy-sdk/pull/321#discussion_r145734069,jovfer
https://github.com/hyperledger/indy-sdk/pull/321,https://github.com/hyperledger/indy-sdk/pull/321,They work for me.,1a34b4b8077ca284f0e184fe87bb88f3d9775f44,2017-10-19 15:22:52,145734303,"@@ -1,40 +1,133 @@
 package org.hyperledger.indy.sdk;
 
+import org.hyperledger.indy.sdk.anoncreds.AccumulatorFullException;
+import org.hyperledger.indy.sdk.anoncreds.ClaimRevokedException;
+import org.hyperledger.indy.sdk.anoncreds.NotIssuedException;
+import org.hyperledger.indy.sdk.anoncreds.DuplicateMasterSecretNameException;
+import org.hyperledger.indy.sdk.anoncreds.InvalidUserRevocIndexException;
+import org.hyperledger.indy.sdk.anoncreds.ProofRejectedException;
+import org.hyperledger.indy.sdk.anoncreds.RevocationRegistryFullException;
+import org.hyperledger.indy.sdk.ledger.ConsensusException;
+import org.hyperledger.indy.sdk.ledger.InvalidLedgerTransactionException;
+import org.hyperledger.indy.sdk.ledger.LedgerSecurityException;
+import org.hyperledger.indy.sdk.pool.PoolClosedException;
+import org.hyperledger.indy.sdk.pool.PoolConfigNotCreatedException;
+import org.hyperledger.indy.sdk.pool.PoolLedgerConfigExistsException;
+import org.hyperledger.indy.sdk.pool.PoolLedgerTerminatedException;
+import org.hyperledger.indy.sdk.signus.UnknownCryptoException;
+import org.hyperledger.indy.sdk.wallet.DuplicateWalletTypeException;
+import org.hyperledger.indy.sdk.wallet.UnknownWalletTypeException;
+import org.hyperledger.indy.sdk.wallet.WalletAlreadyOpenedException;
+import org.hyperledger.indy.sdk.wallet.WalletClosedException;
+import org.hyperledger.indy.sdk.wallet.WalletExistsException;
+import org.hyperledger.indy.sdk.wallet.WalletValueNotFoundException;
+import org.hyperledger.indy.sdk.wallet.WrongWalletForPoolException;
+
 /**
- * Indy specific exception.
+ * Thrown when an Indy specific error has occurred.
  */
 public class IndyException extends Exception {
 
 	private static final long serialVersionUID = 2650355290834266477L;
-
-	private ErrorCode errorCode;
+	private int sdkErrorCode;
 
 	/**
 	 * Initializes a new IndyException with the specified message.
 	 * 
 	 * @param message The message for the exception.
 	 */
-	public IndyException(String message) {
-
+	protected IndyException(String message, int sdkErrorCode) {
 		super(message);
+		this.sdkErrorCode = sdkErrorCode;
 	}
 
 	/**
-	 * Initializes a new IndyException using the specified ErrorCode.
+	 * Gets the SDK error code for the exception.
 	 * 
-	 * @param errorCode The error code for the exception.
+	 * @return The SDK error code used to construct the exception.
 	 */
-	public IndyException(ErrorCode errorCode) {
-		this(String.format(""%s: %d"", errorCode.name(), errorCode.value()));
-		this.errorCode = errorCode;
+	public int getSdkErrorCode() {
+		return sdkErrorCode;
 	}
-
+	
 	/**
-	 * Gets the ErrorCode for the exception.
+	 * Initializes a new IndyException using the specified SDK error code.
 	 * 
-	 * @return The ErrorCode used to construct the exception.
+	 * @param sdkErrorCode The SDK error code to construct the exception from.
 	 */
-	public ErrorCode getErrorCode() {
-		return errorCode;
+	public static IndyException fromSdkError(int sdkErrorCode) {
+		
+		ErrorCode errorCode = ErrorCode.valueOf(sdkErrorCode);
+		
+		switch(errorCode){
+			case CommonInvalidParam1:
+			case CommonInvalidParam2:
+			case CommonInvalidParam3:
+			case CommonInvalidParam4:
+			case CommonInvalidParam5:
+			case CommonInvalidParam6:
+			case CommonInvalidParam7:
+			case CommonInvalidParam8:
+			case CommonInvalidParam9:
+			case CommonInvalidParam10:
+			case CommonInvalidParam11:
+			case CommonInvalidParam12:
+				return new InvalidParameterException(sdkErrorCode);
+			case CommonInvalidState:
+				return new InvalidStateException();
+			case CommonInvalidStructure:
+				return new InvalidStructureException();
+			case CommonIOError:
+				return new IOException();
+			case WalletInvalidHandle:
+				return new WalletClosedException();",,2017-10-19 15:35:47,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/145734303,https://github.com/hyperledger/indy-sdk/pull/321#discussion_r145734303,srottem
https://github.com/hyperledger/indy-sdk/pull/313,https://github.com/hyperledger/indy-sdk/pull/313,"May be
`Also Ubundu deb packages can be installed from APT repository:`
",da16bcb59ace7996e164e913ac87da9052b853de,2017-10-27 14:39:50,147428983,"@@ -28,9 +28,16 @@ us on [Hyperledger's Rocket.Chat](https://chat.hyperledger.org/) at #indy-sdk to
 * [iOS](wrappers/ios/ios-build.md)
 
 ## Binaries
-Builded binaries can be downloaded from https://repo.evernym.com/libindy:
-* ubuntu/{master,stable,rc} - Ubuntu deb packages
-* windows/{master,stable,rc} - Windows zip-archive with all required DLLs (include libindy itself) and headers
-* windows/deps/ - Windows zip archive with dependencies (DLLs and headers) to build libindy from sources
-* ios/stable/ - Pods for iOS
-* rhel/{master,stable,rc} - RHEL rpms
+Builded binaries can be downloaded from https://repo.sovrin.org/:
+* lib/apt/xenial/{master,stable,rc} - Ubuntu deb packages
+* windows/libindy/{master,stable,rc} - Windows zip-archive with all required DLLs (include libindy itself) and headers
+* windows/libindy/deps/ - Windows zip archive with dependencies (DLLs and headers) to build libindy from sources
+* ios/libindy/stable/ - Pods for iOS
+* rhel/libindy/{master,stable,rc} - RHEL rpms
+
+Alternatively Ubundu deb packages can be installed by running following commands:",,2017-10-30 06:34:36,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/147428983,https://github.com/hyperledger/indy-sdk/pull/313#discussion_r147428983,jovfer
https://github.com/hyperledger/indy-sdk/pull/305,https://github.com/hyperledger/indy-sdk/pull/305,According to our documentation default IP of pool is 127.0.0.1,bd023855454fd2652f1983f7dcb647cb5edbe570,2017-10-12 13:37:13,144290633,"@@ -91,7 +91,7 @@ RUN init_indy_keys --name Node2 --seed 111111111111111111111111111Node2 --force
 RUN init_indy_keys --name Node3 --seed 111111111111111111111111111Node3 --force
 RUN init_indy_keys --name Node4 --seed 111111111111111111111111111Node4 --force
 
-ARG pool_ip=127.0.0.1
+ARG pool_ip=10.0.0.2",,2017-10-12 14:49:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/144290633,https://github.com/hyperledger/indy-sdk/pull/305#discussion_r144290633,jovfer
https://github.com/hyperledger/indy-sdk/pull/299,https://github.com/hyperledger/indy-sdk/pull/299,"Should not expect error, please change transaction file",6325e11b0422b3a50a60cf34255e9d9d08203cbc,2017-10-09 15:22:08,143499896,"@@ -7,13 +7,17 @@
 import org.junit.Test;
 
 import java.io.File;
+import java.util.concurrent.ExecutionException;
 
 import static org.junit.Assert.assertTrue;
 
 public class CreatePoolTest extends IndyIntegrationTest {
 
 	@Test
 	public void testCreatePoolWorksForNullConfig() throws Exception {
+		thrown.expect(ExecutionException.class);",,2017-10-10 10:18:21,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/143499896,https://github.com/hyperledger/indy-sdk/pull/299#discussion_r143499896,jovfer
https://github.com/hyperledger/indy-sdk/pull/296,https://github.com/hyperledger/indy-sdk/pull/296,Should not completely hide previous error.,096903f8512a42e44ccca252f0bdd38703cca39b,2017-10-05 14:26:07,142953195,"@@ -0,0 +1,47 @@
+extern crate sodiumoxide;
+
+use errors::common::CommonError;
+
+use self::sodiumoxide::crypto::box_;
+use self::sodiumoxide::crypto::sealedbox;
+use utils::byte_array::_clone_into_array;
+
+pub struct Sealbox {}
+
+impl Sealbox {
+    pub fn new() -> Sealbox {
+        Sealbox {}
+    }
+
+    pub fn encrypt(pk: &[u8], doc: &[u8]) -> Result<Vec<u8>, CommonError> {
+        Ok(sealedbox::seal(doc,
+                           &box_::PublicKey(_clone_into_array(pk))))
+    }
+
+    pub fn decrypt(pk: &[u8], sk: &[u8], doc: &[u8]) -> Result<Vec<u8>, CommonError> {
+        sealedbox::open(&doc,
+                        &box_::PublicKey(_clone_into_array(pk)),
+                        &box_::SecretKey(_clone_into_array(sk)))
+            .map_err(|_| CommonError::InvalidStructure(""Unable to decrypt data"".to_string()))",,2017-10-11 07:36:02,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/142953195,https://github.com/hyperledger/indy-sdk/pull/296#discussion_r142953195,jovfer
https://github.com/hyperledger/indy-sdk/pull/294,https://github.com/hyperledger/indy-sdk/pull/294,There are a lot of same `@Before` and `@After` with creating simple wallet. So I suggest to create `class IndyIntegrationTestWithSingleWallet extends IndyIntegrationTest`,193c1067c657a161f312bf5e60946cd9dacc204a,2017-10-05 11:00:59,142907613,"@@ -0,0 +1,72 @@
+package org.hyperladger.indy.sdk.pairwise;
+
+import org.hyperledger.indy.sdk.ErrorCode;
+import org.hyperledger.indy.sdk.ErrorCodeMatcher;
+import org.hyperledger.indy.sdk.IndyIntegrationTest;
+import org.hyperledger.indy.sdk.pairwise.Pairwise;
+import org.hyperledger.indy.sdk.signus.Signus;
+import org.hyperledger.indy.sdk.signus.SignusResults.CreateAndStoreMyDidResult;
+import org.hyperledger.indy.sdk.wallet.Wallet;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.concurrent.ExecutionException;
+
+public class CreatePairwiseTest extends IndyIntegrationTest {
+
+	private Wallet wallet;
+	private String walletName = ""pairwiseWallet"";
+	private String unknownDid = ""NcYxiDXkpYi6ov5FcYDi1e"";
+	private String myDid;
+	private String theirDid;
+
+	@Before
+	public void createWallet() throws Exception {",25,2017-10-05 12:32:18,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/142907613,https://github.com/hyperledger/indy-sdk/pull/294#discussion_r142907613,jovfer
https://github.com/hyperledger/indy-sdk/pull/294,https://github.com/hyperledger/indy-sdk/pull/294,@vimmerru Should be logic moved to `services::pairwise`?,193c1067c657a161f312bf5e60946cd9dacc204a,2017-10-05 11:15:44,142910109,"@@ -0,0 +1,225 @@
+extern crate serde_json;
+
+use utils::json::{JsonDecodable, JsonEncodable};
+use errors::common::CommonError;
+use errors::indy::IndyError;
+use errors::wallet::WalletError;
+use services::wallet::WalletService;
+
+use std::error::Error;
+use std::rc::Rc;
+use std::str;
+
+pub enum PairwiseCommand {
+    PairwiseExists(
+        i32, // wallet handle
+        String, // their_did
+        Box<Fn(Result<bool, IndyError>) + Send>),
+    CreatePairwise(
+        i32, // wallet handle
+        String, // their_did
+        String, // my_did
+        Option<String>, // metadata
+        Box<Fn(Result<(), IndyError>) + Send>),
+    ListPairwise(
+        i32, // wallet handle
+        Box<Fn(Result<String, IndyError>) + Send>),
+    GetPairwise(
+        i32, // wallet handle
+        String, // their_did
+        Box<Fn(Result<String, IndyError>) + Send>),
+    SetPairwiseMetadata(
+        i32, // wallet handle
+        String, // their_did
+        String, // metadata
+        Box<Fn(Result<(), IndyError>) + Send>)
+}
+
+pub struct PairwiseCommandExecutor {
+    wallet_service: Rc<WalletService>
+}
+
+impl PairwiseCommandExecutor {
+    pub fn new(wallet_service: Rc<WalletService>) -> PairwiseCommandExecutor {
+        PairwiseCommandExecutor {
+            wallet_service: wallet_service
+        }
+    }
+
+    pub fn execute(&self, command: PairwiseCommand) {
+        match command {
+            PairwiseCommand::PairwiseExists(wallet_handle, their_did, cb) => {
+                info!(target: ""pairwise_command_executor"", ""PairwiseExists command received"");
+                self.pairwise_exists(wallet_handle, &their_did, cb);
+            }
+            PairwiseCommand::CreatePairwise(wallet_handle, their_did, my_did, metadata, cb) => {
+                info!(target: ""pairwise_command_executor"", ""CreatePairwise command received"");
+                self.create_pairwise(wallet_handle, &their_did, &my_did, metadata.as_ref().map(String::as_str), cb);
+            }
+            PairwiseCommand::ListPairwise(wallet_handle, cb) => {
+                info!(target: ""pairwise_command_executor"", ""ListPairwise command received"");
+                self.list_pairwise(wallet_handle, cb);
+            }
+            PairwiseCommand::GetPairwise(wallet_handle, their_did, cb) => {
+                info!(target: ""pairwise_command_executor"", ""GetPairwise command received"");
+                self.get_pairwise(wallet_handle, &their_did, cb);
+            }
+            PairwiseCommand::SetPairwiseMetadata(wallet_handle, their_did, metadata, cb) => {
+                info!(target: ""pairwise_command_executor"", ""SetPairwiseMetadata command received"");
+                self.set_pairwise_metadata(wallet_handle, &their_did, &metadata, cb);
+            }
+        };
+    }
+
+    fn pairwise_exists(&self,
+                       wallet_handle: i32,
+                       their_did: &str,
+                       cb: Box<Fn(Result<bool, IndyError>) + Send>) {
+        cb(match self.wallet_service.get(wallet_handle, &format!(""pairwise::{}"", their_did)) {
+            Ok(_) => Ok(true),
+            Err(WalletError::NotFound(_)) => Ok(false),
+            Err(err) => Err(IndyError::WalletError(err)),
+        });
+    }
+
+    fn create_pairwise(&self,
+                       wallet_handle: i32,
+                       their_did: &str,
+                       my_did: &str,
+                       metadata: Option<&str>,
+                       cb: Box<Fn(Result<(), IndyError>) + Send>) {
+        cb(self._create_pairwise(wallet_handle, their_did, my_did, metadata));
+    }
+
+    fn _create_pairwise(&self,
+                        wallet_handle: i32,
+                        their_did: &str,
+                        my_did: &str,
+                        metadata: Option<&str>) -> Result<(), IndyError> {
+        self.wallet_service.get(wallet_handle, &format!(""my_did::{}"", my_did))?;
+        self.wallet_service.get(wallet_handle, &format!(""their_did::{}"", their_did))?;
+
+        let pairwise_json = Pairwise::new(my_did.to_string(), their_did.to_string(),
+                                          metadata.map(str::to_string)).to_json()
+            .map_err(|err|
+                CommonError::InvalidState(
+                    format!(""Can't serialize Pairwise: {}"", err.description())))?;
+
+        self.wallet_service.set(wallet_handle, &format!(""pairwise::{}"", their_did), &pairwise_json)?;
+
+        Ok(())
+    }
+
+    fn list_pairwise(&self,
+                     wallet_handle: i32,
+                     cb: Box<Fn(Result<String, IndyError>) + Send>) {
+        cb(self._list_pairwise(wallet_handle));
+    }
+
+    fn _list_pairwise(&self,
+                      wallet_handle: i32) -> Result<String, IndyError> {
+        let list_pairwise: Vec<String> =
+            self.wallet_service.list(wallet_handle, &format!(""pairwise::""))?
+                .iter()
+                .map(|&(_, ref pair)| pair.clone())
+                .collect::<Vec<String>>();
+
+        let list_pairwise_json = serde_json::to_string(&list_pairwise)
+            .map_err(|err| CommonError::InvalidStructure(format!(""Can't serialize {}"", err)))?;
+
+        Ok(list_pairwise_json)
+    }
+
+    fn get_pairwise(&self,
+                    wallet_handle: i32,
+                    their_did: &str,
+                    cb: Box<Fn(Result<String, IndyError>) + Send>) {
+        cb(self._get_pairwise(wallet_handle, their_did));
+    }
+
+    fn _get_pairwise(&self,
+                     wallet_handle: i32,
+                     their_did: &str) -> Result<String, IndyError> {
+        let pairwise = self.wallet_service.get(wallet_handle, &format!(""pairwise::{}"", their_did))?;
+
+        let pairwise_info: PairwiseInfo = PairwiseInfo::from_json(&pairwise)
+            .map_err(|e|
+                CommonError::InvalidState(format!(""Can't deserialize PairwiseInfo: {:?}"", e)))?;
+
+        let pairwise_info_json = pairwise_info.to_json()
+            .map_err(|e|
+                CommonError::InvalidState(format!(""Can't serialize PairwiseInfo: {:?}"", e)))?;
+
+        Ok(pairwise_info_json)
+    }
+
+    fn set_pairwise_metadata(&self,
+                             wallet_handle: i32,
+                             their_did: &str,
+                             metadata: &str,
+                             cb: Box<Fn(Result<(), IndyError>) + Send>) {
+        cb(self._set_pairwise_metadata(wallet_handle, their_did, metadata))
+    }
+
+    fn _set_pairwise_metadata(&self,
+                              wallet_handle: i32,
+                              their_did: &str,
+                              metadata: &str) -> Result<(), IndyError> {
+        let pairwise_json = self.wallet_service.get(wallet_handle, &format!(""pairwise::{}"", their_did))?;
+
+        let mut pairwise: Pairwise = Pairwise::from_json(&pairwise_json)
+            .map_err(|err|
+                CommonError::InvalidState(format!(""Can't deserialize Pairwise: {:?}"", err)))?;
+
+        pairwise.metadata = Some(metadata.to_string());
+
+        let pairwise_json = pairwise.to_json()
+            .map_err(|err|
+                CommonError::InvalidState(format!(""Can't serialize Pairwise: {:?}"", err)))?;
+
+        self.wallet_service.set(wallet_handle, &format!(""pairwise::{}"", their_did), &pairwise_json)?;
+        Ok(())
+    }
+}
+",184,2017-10-05 12:32:18,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/142910109,https://github.com/hyperledger/indy-sdk/pull/294#discussion_r142910109,jovfer
https://github.com/hyperledger/indy-sdk/pull/294,https://github.com/hyperledger/indy-sdk/pull/294,"@Artemkaaas I can`t find usage of it, please re-check.",193c1067c657a161f312bf5e60946cd9dacc204a,2017-10-05 11:17:04,142910360,"@@ -116,4 +116,23 @@ impl TheirDid {
 
 impl JsonEncodable for TheirDid {}
 
-impl<'a> JsonDecodable<'a> for TheirDid {}
\ No newline at end of file
+impl<'a> JsonDecodable<'a> for TheirDid {}
+
+#[derive(Serialize, Deserialize)]
+pub struct DidPair {",,2017-10-05 12:32:18,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/142910360,https://github.com/hyperledger/indy-sdk/pull/294#discussion_r142910360,jovfer
https://github.com/hyperledger/indy-sdk/pull/294,https://github.com/hyperledger/indy-sdk/pull/294,Not sure that this PR is the right place for this refactoring. I suggest to merge this and add some technical debt task.,193c1067c657a161f312bf5e60946cd9dacc204a,2017-10-05 13:35:54,142938600,"@@ -0,0 +1,72 @@
+package org.hyperladger.indy.sdk.pairwise;
+
+import org.hyperledger.indy.sdk.ErrorCode;
+import org.hyperledger.indy.sdk.ErrorCodeMatcher;
+import org.hyperledger.indy.sdk.IndyIntegrationTest;
+import org.hyperledger.indy.sdk.pairwise.Pairwise;
+import org.hyperledger.indy.sdk.signus.Signus;
+import org.hyperledger.indy.sdk.signus.SignusResults.CreateAndStoreMyDidResult;
+import org.hyperledger.indy.sdk.wallet.Wallet;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.concurrent.ExecutionException;
+
+public class CreatePairwiseTest extends IndyIntegrationTest {
+
+	private Wallet wallet;
+	private String walletName = ""pairwiseWallet"";
+	private String unknownDid = ""NcYxiDXkpYi6ov5FcYDi1e"";
+	private String myDid;
+	private String theirDid;
+
+	@Before
+	public void createWallet() throws Exception {",25,2017-10-05 13:35:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/142938600,https://github.com/hyperledger/indy-sdk/pull/294#discussion_r142938600,vimmerru
https://github.com/hyperledger/indy-sdk/pull/288,https://github.com/hyperledger/indy-sdk/pull/288,Please update comment too.,a1e8cc2f18b653315317ea7cf3c8111043d3af60,2017-10-02 12:10:44,142121213,"@@ -65,16 +65,37 @@ extern ""C"" {
     /// Wallet*
     /// Crypto*
 
-    extern indy_error_t indy_replace_keys(indy_handle_t command_handle,
-                                          indy_handle_t wallet_handle,
-                                          const char *  did,
-                                          const char *  identity_json,
+    extern indy_error_t indy_replace_keys_start(indy_handle_t command_handle,",17,2017-10-02 15:27:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/142121213,https://github.com/hyperledger/indy-sdk/pull/288#discussion_r142121213,jovfer
https://github.com/hyperledger/indy-sdk/pull/288,https://github.com/hyperledger/indy-sdk/pull/288,"Should we delete temporary entry?
@vimmerru ",a1e8cc2f18b653315317ea7cf3c8111043d3af60,2017-10-02 12:12:21,142121518,"@@ -205,11 +215,28 @@ impl SignusCommandExecutor {
                 CommonError::InvalidState(
                     format!(""Can't serialize MyDid: {}"", err.description())))?;
 
-        self.wallet_service.set(wallet_handle, &format!(""my_did::{}"", my_did.did), &my_did_json)?;
+        self.wallet_service.set(wallet_handle, &format!(""my_did_temporary_keys::{}"", my_did.did), &my_did_json)?;
 
         Ok((my_did.verkey, my_did.pk))
     }
 
+    fn replace_keys_apply(&self,
+                          wallet_handle: i32,
+                          did: &str,
+                          cb: Box<Fn(Result<(), IndyError>) + Send>) {
+        cb(self._replace_keys_apply(wallet_handle, did));
+    }
+
+    fn _replace_keys_apply(&self,",82,2017-10-02 15:27:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/142121518,https://github.com/hyperledger/indy-sdk/pull/288#discussion_r142121518,jovfer
https://github.com/hyperledger/indy-sdk/pull/288,https://github.com/hyperledger/indy-sdk/pull/288,"It is better to remove from my point of view, but we can leave it as is if we need to introduce additional wallet interfaces.",a1e8cc2f18b653315317ea7cf3c8111043d3af60,2017-10-02 13:43:13,142141975,"@@ -205,11 +215,28 @@ impl SignusCommandExecutor {
                 CommonError::InvalidState(
                     format!(""Can't serialize MyDid: {}"", err.description())))?;
 
-        self.wallet_service.set(wallet_handle, &format!(""my_did::{}"", my_did.did), &my_did_json)?;
+        self.wallet_service.set(wallet_handle, &format!(""my_did_temporary_keys::{}"", my_did.did), &my_did_json)?;
 
         Ok((my_did.verkey, my_did.pk))
     }
 
+    fn replace_keys_apply(&self,
+                          wallet_handle: i32,
+                          did: &str,
+                          cb: Box<Fn(Result<(), IndyError>) + Send>) {
+        cb(self._replace_keys_apply(wallet_handle, did));
+    }
+
+    fn _replace_keys_apply(&self,",82,2017-10-02 15:27:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/142141975,https://github.com/hyperledger/indy-sdk/pull/288#discussion_r142141975,vimmerru
https://github.com/hyperledger/indy-sdk/pull/282,https://github.com/hyperledger/indy-sdk/pull/282,"@vimmerru there is alternative option to manual download from maven.apache.org ZIP archive, unzip and set PATH... What option do you prefer?",00927057f2b3c48e386ccac8d485c4c2463b8287,2017-10-02 10:59:12,142109320,"@@ -29,7 +29,14 @@ RUN cd /tmp && \
 ENV PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig
 ENV LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib
 
-ENV RUST_ARCHIVE=rust-1.19.0-x86_64-unknown-linux-gnu.tar.gz
+RUN yum install -y java-1.8.0-openjdk-devel
+ENV JAVA_HOME /usr/lib/jvm/java-1.8.0-openjdk
+
+RUN wget https://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo -O /etc/yum.repos.d/epel-apache-maven.repo",8,2017-10-03 09:19:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/142109320,https://github.com/hyperledger/indy-sdk/pull/282#discussion_r142109320,jovfer
https://github.com/hyperledger/indy-sdk/pull/282,https://github.com/hyperledger/indy-sdk/pull/282,I more like usage of fedora repo.,00927057f2b3c48e386ccac8d485c4c2463b8287,2017-10-03 09:19:19,142351178,"@@ -29,7 +29,14 @@ RUN cd /tmp && \
 ENV PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig
 ENV LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib
 
-ENV RUST_ARCHIVE=rust-1.19.0-x86_64-unknown-linux-gnu.tar.gz
+RUN yum install -y java-1.8.0-openjdk-devel
+ENV JAVA_HOME /usr/lib/jvm/java-1.8.0-openjdk
+
+RUN wget https://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo -O /etc/yum.repos.d/epel-apache-maven.repo",8,2017-10-03 09:19:31,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/142351178,https://github.com/hyperledger/indy-sdk/pull/282#discussion_r142351178,vimmerru
https://github.com/hyperledger/indy-sdk/pull/249,https://github.com/hyperledger/indy-sdk/pull/249,"Name of DYLD_LIBRARY_PATH variable is platform specific. On Linux it will be LD_LIBRARY_PATH, on Windows just PATH. Also, it would be nice to add a note about execution pool in Docker.",fd2add350e3af8a4c2383c9c3dba192b13277618,2017-09-06 07:17:45,137188221,"@@ -0,0 +1,18 @@
+
+How to run:
+
+__Intellij__
+
+* Open the project in IntelliJ
+* [Optional] Change the version number of indy to latest in pom.xml like:
+    ``` 
+    <dependency>
+       			<groupId>org.hyperledger</groupId>
+       			<artifactId>indy</artifactId>
+       			<version>1.0.0</version>
+     </dependency>
+     ```
+     
+* Click on Edit configuration and edit Main.config, add DYLD_LIBRARY_PATH=<path to indy dll/so/dylib>",,2017-09-06 15:18:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/137188221,https://github.com/hyperledger/indy-sdk/pull/249#discussion_r137188221,vimmerru
https://github.com/hyperledger/indy-sdk/pull/249,https://github.com/hyperledger/indy-sdk/pull/249,Done,fd2add350e3af8a4c2383c9c3dba192b13277618,2017-09-06 07:59:37,137196337,"@@ -0,0 +1,18 @@
+
+How to run:
+
+__Intellij__
+
+* Open the project in IntelliJ
+* [Optional] Change the version number of indy to latest in pom.xml like:
+    ``` 
+    <dependency>
+       			<groupId>org.hyperledger</groupId>
+       			<artifactId>indy</artifactId>
+       			<version>1.0.0</version>
+     </dependency>
+     ```
+     
+* Click on Edit configuration and edit Main.config, add DYLD_LIBRARY_PATH=<path to indy dll/so/dylib>",,2017-09-06 15:18:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/137196337,https://github.com/hyperledger/indy-sdk/pull/249#discussion_r137196337,faisal00813
https://github.com/hyperledger/indy-sdk/pull/245,https://github.com/hyperledger/indy-sdk/pull/245,"Can we remove `.Sdk.` part of packages names? In our current vision SDK is complex of wrappers, lib, docs, samples etc. So, in wrapper it seems like redundant.",ae1bc1fed193504c076f3f510baa1afa6125db66,2017-09-08 11:42:58,137770339,"@@ -1,8 +1,9 @@
-﻿using Indy.Sdk.Dotnet.Wrapper;
+﻿using Hyperledger.Indy.Sdk.AgentApi;
+using Hyperledger.Indy.Sdk.SignUsApi;
 using Microsoft.VisualStudio.TestTools.UnitTesting;
 using System.Threading.Tasks;
 
-namespace Indy.Sdk.Dotnet.Test.Wrapper.AgentTests
+namespace Hyperledger.Indy.Sdk.Test.AgentTests",,2017-09-08 13:00:09,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/137770339,https://github.com/hyperledger/indy-sdk/pull/245#discussion_r137770339,jovfer
https://github.com/hyperledger/indy-sdk/pull/245,https://github.com/hyperledger/indy-sdk/pull/245,"We discuss with @vimmerru and our vision is `Api` suffix is redundant (here and below: Signus, AnonCreds ...)",ae1bc1fed193504c076f3f510baa1afa6125db66,2017-09-08 11:44:43,137770601,"@@ -1,8 +1,9 @@
-﻿using Indy.Sdk.Dotnet.Wrapper;
+﻿using Hyperledger.Indy.Sdk.AgentApi;",,2017-09-08 13:00:09,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/137770601,https://github.com/hyperledger/indy-sdk/pull/245#discussion_r137770601,jovfer
https://github.com/hyperledger/indy-sdk/pull/245,https://github.com/hyperledger/indy-sdk/pull/245,"Initially `us` is just a suffix for `sign`, let's change back `SignUs` to `Signus`.",ae1bc1fed193504c076f3f510baa1afa6125db66,2017-09-08 11:47:21,137770981,"@@ -12,12 +13,12 @@ public class AgentCloseConnectionTest : AgentIntegrationTestBase
         {
             var endpoint = ""127.0.0.1:9603"";
 
-            var myDid = await Signus.CreateAndStoreMyDidAsync(_wallet, ""{}"");
+            var myDid = await SignUs.CreateAndStoreMyDidAsync(_wallet, ""{}"");",,2017-09-08 13:00:09,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/137770981,https://github.com/hyperledger/indy-sdk/pull/245#discussion_r137770981,jovfer
https://github.com/hyperledger/indy-sdk/pull/245,https://github.com/hyperledger/indy-sdk/pull/245,"The issue with this is that it's bad form to have a namespace that conflicts with a class name so an Agent namespace and an Agent class will cause problems, hence the selection of the Api suffix.  The same isn't true of package names in Java.",ae1bc1fed193504c076f3f510baa1afa6125db66,2017-09-08 11:51:17,137771556,"@@ -1,8 +1,9 @@
-﻿using Indy.Sdk.Dotnet.Wrapper;
+﻿using Hyperledger.Indy.Sdk.AgentApi;",,2017-09-08 13:00:09,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/137771556,https://github.com/hyperledger/indy-sdk/pull/245#discussion_r137771556,srottem
https://github.com/hyperledger/indy-sdk/pull/245,https://github.com/hyperledger/indy-sdk/pull/245,"Sounds reasonable, so sure.",ae1bc1fed193504c076f3f510baa1afa6125db66,2017-09-08 11:51:45,137771616,"@@ -1,8 +1,9 @@
-﻿using Indy.Sdk.Dotnet.Wrapper;
+﻿using Hyperledger.Indy.Sdk.AgentApi;
+using Hyperledger.Indy.Sdk.SignUsApi;
 using Microsoft.VisualStudio.TestTools.UnitTesting;
 using System.Threading.Tasks;
 
-namespace Indy.Sdk.Dotnet.Test.Wrapper.AgentTests
+namespace Hyperledger.Indy.Sdk.Test.AgentTests",,2017-09-08 13:00:09,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/137771616,https://github.com/hyperledger/indy-sdk/pull/245#discussion_r137771616,srottem
https://github.com/hyperledger/indy-sdk/pull/245,https://github.com/hyperledger/indy-sdk/pull/245,"OK.  The only reason I changed it is that it's unclear what the pronunciation of ""Signus"" is; it could be with a hard 'g'.  Slava mentioned that the correct pronunciation is ""sign us"" so I change the case to reflect that.  If after reviewing this the preference is still to roll back to the original name I don't see a problem.",ae1bc1fed193504c076f3f510baa1afa6125db66,2017-09-08 11:53:39,137772006,"@@ -12,12 +13,12 @@ public class AgentCloseConnectionTest : AgentIntegrationTestBase
         {
             var endpoint = ""127.0.0.1:9603"";
 
-            var myDid = await Signus.CreateAndStoreMyDidAsync(_wallet, ""{}"");
+            var myDid = await SignUs.CreateAndStoreMyDidAsync(_wallet, ""{}"");",,2017-09-08 13:00:09,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/137772006,https://github.com/hyperledger/indy-sdk/pull/245#discussion_r137772006,srottem
https://github.com/hyperledger/indy-sdk/pull/245,https://github.com/hyperledger/indy-sdk/pull/245,"> If after reviewing this the preference is still to roll back to the original name I don't see a problem.

yes, please roll back",ae1bc1fed193504c076f3f510baa1afa6125db66,2017-09-08 12:00:22,137773193,"@@ -12,12 +13,12 @@ public class AgentCloseConnectionTest : AgentIntegrationTestBase
         {
             var endpoint = ""127.0.0.1:9603"";
 
-            var myDid = await Signus.CreateAndStoreMyDidAsync(_wallet, ""{}"");
+            var myDid = await SignUs.CreateAndStoreMyDidAsync(_wallet, ""{}"");",,2017-09-08 13:00:09,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/137773193,https://github.com/hyperledger/indy-sdk/pull/245#discussion_r137773193,jovfer
https://github.com/hyperledger/indy-sdk/pull/245,https://github.com/hyperledger/indy-sdk/pull/245,"OK, we haven't any another proposal for the suffix, let's use `API`",ae1bc1fed193504c076f3f510baa1afa6125db66,2017-09-08 12:02:23,137773490,"@@ -1,8 +1,9 @@
-﻿using Indy.Sdk.Dotnet.Wrapper;
+﻿using Hyperledger.Indy.Sdk.AgentApi;",,2017-09-08 13:00:09,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/137773490,https://github.com/hyperledger/indy-sdk/pull/245#discussion_r137773490,jovfer
https://github.com/hyperledger/indy-sdk/pull/238,https://github.com/hyperledger/indy-sdk/pull/238,Мне кажется лучше это добавить в test-design.md ну либо в другой md,3121164ea2f6a87401f49fbb6fdf870c1dbae67a,2017-09-01 07:49:09,136517238,"@@ -0,0 +1,16 @@
+Steps to perform acceptance testing on Ubuntu:",,2017-10-02 14:58:03,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/136517238,https://github.com/hyperledger/indy-sdk/pull/238#discussion_r136517238,vimmerru
https://github.com/hyperledger/indy-sdk/pull/238,https://github.com/hyperledger/indy-sdk/pull/238,Moved to test-design.md -> Installability testing -> Ubuntu testing,3121164ea2f6a87401f49fbb6fdf870c1dbae67a,2017-09-11 08:16:21,138005186,"@@ -0,0 +1,16 @@
+Steps to perform acceptance testing on Ubuntu:",,2017-10-02 14:58:03,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/138005186,https://github.com/hyperledger/indy-sdk/pull/238#discussion_r138005186,jovfer
https://github.com/hyperledger/indy-sdk/pull/215,https://github.com/hyperledger/indy-sdk/pull/215,Logging should be commented too.,a6bbf9abf367a7e99f790072524fa6ce5cc0c670,2017-08-24 08:32:23,134956615,"@@ -33,16 +33,16 @@ cd $CUR_DIR
 
 echo ""Uploading....""",,2017-08-29 07:39:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/134956615,https://github.com/hyperledger/indy-sdk/pull/215#discussion_r134956615,jovfer
https://github.com/hyperledger/indy-sdk/pull/215,https://github.com/hyperledger/indy-sdk/pull/215,Remove redundant function.,a6bbf9abf367a7e99f790072524fa6ce5cc0c670,2017-08-24 08:37:02,134957543,"@@ -35,10 +35,12 @@ + (PoolUtils *)sharedInstance
 
 + (NSString *) nodeIp",,2017-08-29 07:39:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/134957543,https://github.com/hyperledger/indy-sdk/pull/215#discussion_r134957543,jovfer
https://github.com/hyperledger/indy-sdk/pull/215,https://github.com/hyperledger/indy-sdk/pull/215,Done. Moved testPoolIp to TestUtils.,a6bbf9abf367a7e99f790072524fa6ce5cc0c670,2017-08-28 13:07:56,135519400,"@@ -35,10 +35,12 @@ + (PoolUtils *)sharedInstance
 
 + (NSString *) nodeIp",,2017-08-29 07:39:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/135519400,https://github.com/hyperledger/indy-sdk/pull/215#discussion_r135519400,anastasia-tarasova
https://github.com/hyperledger/indy-sdk/pull/215,https://github.com/hyperledger/indy-sdk/pull/215,Done,a6bbf9abf367a7e99f790072524fa6ce5cc0c670,2017-08-28 13:11:15,135520048,"@@ -33,16 +33,16 @@ cd $CUR_DIR
 
 echo ""Uploading....""",,2017-08-29 07:39:20,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/135520048,https://github.com/hyperledger/indy-sdk/pull/215#discussion_r135520048,anastasia-tarasova
https://github.com/hyperledger/indy-sdk/pull/198,https://github.com/hyperledger/indy-sdk/pull/198,Should be added to appropriate header,718a800a9bddb480fdd98121818b722a06d2e995,2017-08-22 07:49:59,134407270,"@@ -115,11 +115,13 @@ pub enum ErrorCode
 
     AnoncredsNotIssuedError = 403,
 
-    // Attempt to generate master secret with dupplicated name
+    // Attempt to generate master secret with duplicated name
     AnoncredsMasterSecretDuplicateNameError = 404,
 
     AnoncredsProofRejected = 405,
 
+    AnoncredsClaimRevoked = 406,",10,2017-08-22 14:03:19,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/134407270,https://github.com/hyperledger/indy-sdk/pull/198#discussion_r134407270,jovfer
https://github.com/hyperledger/indy-sdk/pull/198,https://github.com/hyperledger/indy-sdk/pull/198,"Not obvious format of ints: should be in hex format.
Also `transform_u32_to_array_of_u8` should have comment or suffix about byte order",718a800a9bddb480fdd98121818b722a06d2e995,2017-08-22 08:12:11,134411432,"@@ -165,7 +165,7 @@ mod tests {
     #[test]
     fn transform_u32_to_array_of_u8_works() {
         let int = 1958376517;
-        let answer = vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 186, 116, 69];
+        let answer = vec![116, 186, 116, 69];",,2017-08-22 14:03:19,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/134411432,https://github.com/hyperledger/indy-sdk/pull/198#discussion_r134411432,jovfer
https://github.com/hyperledger/indy-sdk/pull/198,https://github.com/hyperledger/indy-sdk/pull/198,Unify approach with revoke.,718a800a9bddb480fdd98121818b722a06d2e995,2017-08-22 08:52:49,134420733,"@@ -195,18 +159,18 @@ impl Issuer {
         let revocation_registry_private = RevocationRegistryPrivate::new(acc_sk, g, g_dash);
 
         info!(target: ""anoncreds_service"",
-        ""Issuer create accumulator for issuer_did {} and schema_seq_no {} -> done"",
-        issuer_did, schema_seq_no);
+              ""Issuer create accumulator for issuer_did {} and schema_seq_no {} -> done"",
+              issuer_did, schema_seq_no);
         Ok((revocation_registry, revocation_registry_private))
     }
 
     pub fn create_claim(&self, claim_definition: &ClaimDefinition,
                         claim_definition_private: &ClaimDefinitionPrivate,
-                        revocation_registry: &Option<RefCell<RevocationRegistry>>,
+                        revocation_registry: &Option<RevocationRegistry>,",,2017-08-22 14:03:19,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/134420733,https://github.com/hyperledger/indy-sdk/pull/198#discussion_r134420733,jovfer
https://github.com/hyperledger/indy-sdk/pull/195,https://github.com/hyperledger/indy-sdk/pull/195,Should it be `./indy-sdk/libindy/` ?,ee37b23c2ac05f1811847837804629743f3efb4e,2017-08-17 15:48:48,133752960,"@@ -16,9 +16,10 @@
 1. Checkout and build the library:
    
    ```
-   git checkout https://github.com/hyperledger/indy-sdk.git
-   cd ./indy-sdk
+   git clone https://github.com/hyperledger/indy-sdk.git
+   cd ./indy-sdk/indy-sdk",,2017-08-23 09:31:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/133752960,https://github.com/hyperledger/indy-sdk/pull/195#discussion_r133752960,jovfer
https://github.com/hyperledger/indy-sdk/pull/195,https://github.com/hyperledger/indy-sdk/pull/195,Should it be  ./indy-sdk/libindy ???,ee37b23c2ac05f1811847837804629743f3efb4e,2017-08-17 15:49:28,133753133,"@@ -16,9 +16,10 @@
 1. Checkout and build the library:
    
    ```
-   git checkout https://github.com/hyperledger/indy-sdk.git
-   cd ./indy-sdk
+   git clone https://github.com/hyperledger/indy-sdk.git
+   cd ./indy-sdk/indy-sdk",,2017-08-23 09:31:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/133753133,https://github.com/hyperledger/indy-sdk/pull/195#discussion_r133753133,vimmerru
https://github.com/hyperledger/indy-sdk/pull/195,https://github.com/hyperledger/indy-sdk/pull/195,"Yes, I am sure you are correct.",ee37b23c2ac05f1811847837804629743f3efb4e,2017-08-17 18:23:57,133791907,"@@ -16,9 +16,10 @@
 1. Checkout and build the library:
    
    ```
-   git checkout https://github.com/hyperledger/indy-sdk.git
-   cd ./indy-sdk
+   git clone https://github.com/hyperledger/indy-sdk.git
+   cd ./indy-sdk/indy-sdk",,2017-08-23 09:31:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/133791907,https://github.com/hyperledger/indy-sdk/pull/195#discussion_r133791907,sklump
https://github.com/hyperledger/indy-sdk/pull/195,https://github.com/hyperledger/indy-sdk/pull/195,"Yes, thanks. My mistake.",ee37b23c2ac05f1811847837804629743f3efb4e,2017-08-17 18:24:09,133791944,"@@ -16,9 +16,10 @@
 1. Checkout and build the library:
    
    ```
-   git checkout https://github.com/hyperledger/indy-sdk.git
-   cd ./indy-sdk
+   git clone https://github.com/hyperledger/indy-sdk.git
+   cd ./indy-sdk/indy-sdk",,2017-08-23 09:31:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/133791944,https://github.com/hyperledger/indy-sdk/pull/195#discussion_r133791944,sklump
https://github.com/hyperledger/indy-sdk/pull/195,https://github.com/hyperledger/indy-sdk/pull/195,"Actually pool use only 9701-9708 ports. So this change should not be applied.
@vimmerru I think we should fix it in appropriate dockerfile also. May be we can merge this PR, and fix this line and dockerfile in the new one.",ee37b23c2ac05f1811847837804629743f3efb4e,2017-08-21 11:08:32,134205435,"@@ -19,9 +19,10 @@
    git clone https://github.com/hyperledger/indy-sdk.git
    cd ./indy-sdk/libindy
    cargo build
+   cd ..
    ```
 1. Run integration tests:
-   * Start local nodes pool on `127.0.0.1:9701-9708` with Docker:
+   * Start local nodes pool on `127.0.0.1:9701-9709` with Docker:",,2017-08-23 09:31:27,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/134205435,https://github.com/hyperledger/indy-sdk/pull/195#discussion_r134205435,jovfer
https://github.com/hyperledger/indy-sdk/pull/186,https://github.com/hyperledger/indy-sdk/pull/186,Convert rust syntax to c,d4d457450dd7195e33476566177ff018bb8ef9a1,2017-08-15 09:48:51,133153860,"@@ -129,11 +130,13 @@ extern ""C"" {
     extern indy_error_t indy_sign(indy_handle_t command_handle,
                                       indy_handle_t wallet_handle,
                                       const char *    did,
-                                      const char *    msg,
-                                      
+                                      message_raw: *const indy_u8_t,",,2017-08-15 11:19:47,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/133153860,https://github.com/hyperledger/indy-sdk/pull/186#discussion_r133153860,jovfer
https://github.com/hyperledger/indy-sdk/pull/186,https://github.com/hyperledger/indy-sdk/pull/186,Restore align for parameters names,d4d457450dd7195e33476566177ff018bb8ef9a1,2017-08-15 09:49:24,133153955,"@@ -166,8 +171,10 @@ extern ""C"" {
                                                   indy_handle_t pool_handle,
                                                   
                                                   const char *    did,
-                                                  const char *    msg,
-                                                  const char *    signature,
+                                                  const indy_u8_t *      message_raw,",,2017-08-15 11:19:47,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/133153955,https://github.com/hyperledger/indy-sdk/pull/186#discussion_r133153955,jovfer
https://github.com/hyperledger/indy-sdk/pull/186,https://github.com/hyperledger/indy-sdk/pull/186,Invalid pointer: vector will be freed at the end of this function,d4d457450dd7195e33476566177ff018bb8ef9a1,2017-08-15 10:48:16,133162452,"@@ -0,0 +1,15 @@
+macro_rules! get_byte_array {
+    ($x:ident, $l:expr, $e:expr) => {
+        if $x.is_null() {
+            return $e
+        }
+
+        let $x =  unsafe { slice::from_raw_parts($x, $l as usize) };
+        let $x = $x.to_vec();
+    }
+}
+
+pub fn vec_to_pointer(v: Vec<u8>) -> (*const u8, u32) {
+    let len = v.len() as u32;
+    (v.as_ptr() as *const u8, len)",,2017-08-15 11:19:47,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/133162452,https://github.com/hyperledger/indy-sdk/pull/186#discussion_r133162452,jovfer
https://github.com/hyperledger/indy-sdk/pull/186,https://github.com/hyperledger/indy-sdk/pull/186,Why not just message.as_ptr()?,d4d457450dd7195e33476566177ff018bb8ef9a1,2017-08-15 10:52:09,133163059,"@@ -1049,16 +1049,20 @@ fn signus_demo_works() {
             ""dest"":""4efZu2SXufS556yss7W5k6Po37jt4371RM4whbPKBKdB""
         }
     }""#;
+
+    let message_ptr = message.as_bytes().as_ptr() as *const u8;",,2017-08-15 11:19:47,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/133163059,https://github.com/hyperledger/indy-sdk/pull/186#discussion_r133163059,jovfer
https://github.com/hyperledger/indy-sdk/pull/185,https://github.com/hyperledger/indy-sdk/pull/185,"You created 2 dedicated methods WaitForConnection and WaitForMessage. The problem with this approach is that during awaiting of Connection events you can't receive Message events and vice versa. I see 2 solutions:

1. It can be possible to combine 2 Tasks in the way that awaiting will be finished on the finishing of first task. So we need to check .Net asyncio docs how and provide an example if it is possible.
2. Create a single waitForEvent method that will return generic event. Python wrapper follows this way.",4fb6b69f75823c5ab99f49c2feac11af425dc4d9,2017-08-14 07:23:04,132886886,"@@ -1,69 +1,45 @@
 ﻿using Indy.Sdk.Dotnet.Wrapper;
 using Microsoft.VisualStudio.TestTools.UnitTesting;
-using System;
 using System.Threading.Tasks;
-using static Indy.Sdk.Dotnet.Wrapper.Agent;
 
 namespace Indy.Sdk.Dotnet.Test.Wrapper.AgentTests
 {
     [TestClass]
     public class AgentSendTest : AgentIntegrationTestBase
     {
-        private static TaskCompletionSource<Connection> serverToClientConnectionFuture = new TaskCompletionSource<Connection>();
-        private static TaskCompletionSource<string> serverToClientMsgFuture = new TaskCompletionSource<string>();
-        private static TaskCompletionSource<string> clientToServerMsgFuture = new TaskCompletionSource<string>();
-
-        private new static MessageReceivedHandler _messageObserver = (Connection connection, string message) =>
-            {
-                Console.WriteLine(""Received message '"" + message + ""' on connection "" + connection);
-
-                serverToClientMsgFuture.SetResult(message);
-            };
-
-        private new static MessageReceivedHandler _messageObserverForIncoming = (Connection connection, string message) =>
-            {
-                Console.WriteLine(""Received message '"" + message + ""' on incoming connection "" + connection);
-
-                clientToServerMsgFuture.SetResult(message);
-            };
-
-        private new static ConnectionOpenedHandler _incomingConnectionObserver = (Listener listener, Connection connection, string senderDid, string receiverDid) =>
-            {
-                Console.WriteLine(""New connection "" + connection);
-
-                serverToClientConnectionFuture.SetResult(connection);
-
-                return _messageObserverForIncoming;
-            };
-
         [TestMethod]
-        public void TestAgentSendWorks()
+        public async Task TestAgentSendWorks()
         {
             var endpoint = ""127.0.0.1:9609"";
 
-            var myDidResult = Signus.CreateAndStoreMyDidAsync(_wallet, ""{}"").Result;
+            var myDidResult = await Signus.CreateAndStoreMyDidAsync(_wallet, ""{}"");
 
             var identityJson = string.Format(""{{\""did\"":\""{0}\"", \""pk\"":\""{1}\"", \""verkey\"":\""{2}\"", \""endpoint\"":\""{3}\""}}"",
                     myDidResult.Did, myDidResult.Pk, myDidResult.VerKey, endpoint);
-            Signus.StoreTheirDidAsync(_wallet, identityJson).Wait();
+            await Signus.StoreTheirDidAsync(_wallet, identityJson);
 
-            var activeListener = Agent.AgentListenAsync(endpoint, _incomingConnectionObserver).Result;
+            var listener = await Agent.AgentListenAsync(endpoint);
+            await listener.AddIdentityAsync(_pool, _wallet, myDidResult.Did);
 
-            activeListener.AddIdentityAsync(_pool, _wallet, myDidResult.Did).Wait();
+            var clientConnection = await Agent.AgentConnectAsync(_pool, _wallet, myDidResult.Did, myDidResult.Did);
 
-            var clientToServerConnection = Agent.AgentConnectAsync(_pool, _wallet, myDidResult.Did, myDidResult.Did, _messageObserver).Result;
+            var connectionEvent = await listener.WaitForConnection();
+            var serverConnection = connectionEvent.Connection;
 
             var clientToServerMessage = ""msg_from_client"";
             var serverToClientMessage = ""msg_from_server"";
 
-            clientToServerConnection.SendAsync(clientToServerMessage).Wait();
+            await clientConnection.SendAsync(clientToServerMessage);
+
+            var serverMessageEvent = await serverConnection.WaitForMessage();",70,2017-08-14 07:23:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/132886886,https://github.com/hyperledger/indy-sdk/pull/185#discussion_r132886886,vimmerru
https://github.com/hyperledger/indy-sdk/pull/185,https://github.com/hyperledger/indy-sdk/pull/185,".NET does have Task.WaitAll() and Task.WaitAny() as well as
Task.WhenAll() and Task.WhenAny() which take an array of async tasks to
wait on.  Is that what you're looking for?",4fb6b69f75823c5ab99f49c2feac11af425dc4d9,2017-08-14 08:04:59,132893164,"@@ -1,69 +1,45 @@
 ﻿using Indy.Sdk.Dotnet.Wrapper;
 using Microsoft.VisualStudio.TestTools.UnitTesting;
-using System;
 using System.Threading.Tasks;
-using static Indy.Sdk.Dotnet.Wrapper.Agent;
 
 namespace Indy.Sdk.Dotnet.Test.Wrapper.AgentTests
 {
     [TestClass]
     public class AgentSendTest : AgentIntegrationTestBase
     {
-        private static TaskCompletionSource<Connection> serverToClientConnectionFuture = new TaskCompletionSource<Connection>();
-        private static TaskCompletionSource<string> serverToClientMsgFuture = new TaskCompletionSource<string>();
-        private static TaskCompletionSource<string> clientToServerMsgFuture = new TaskCompletionSource<string>();
-
-        private new static MessageReceivedHandler _messageObserver = (Connection connection, string message) =>
-            {
-                Console.WriteLine(""Received message '"" + message + ""' on connection "" + connection);
-
-                serverToClientMsgFuture.SetResult(message);
-            };
-
-        private new static MessageReceivedHandler _messageObserverForIncoming = (Connection connection, string message) =>
-            {
-                Console.WriteLine(""Received message '"" + message + ""' on incoming connection "" + connection);
-
-                clientToServerMsgFuture.SetResult(message);
-            };
-
-        private new static ConnectionOpenedHandler _incomingConnectionObserver = (Listener listener, Connection connection, string senderDid, string receiverDid) =>
-            {
-                Console.WriteLine(""New connection "" + connection);
-
-                serverToClientConnectionFuture.SetResult(connection);
-
-                return _messageObserverForIncoming;
-            };
-
         [TestMethod]
-        public void TestAgentSendWorks()
+        public async Task TestAgentSendWorks()
         {
             var endpoint = ""127.0.0.1:9609"";
 
-            var myDidResult = Signus.CreateAndStoreMyDidAsync(_wallet, ""{}"").Result;
+            var myDidResult = await Signus.CreateAndStoreMyDidAsync(_wallet, ""{}"");
 
             var identityJson = string.Format(""{{\""did\"":\""{0}\"", \""pk\"":\""{1}\"", \""verkey\"":\""{2}\"", \""endpoint\"":\""{3}\""}}"",
                     myDidResult.Did, myDidResult.Pk, myDidResult.VerKey, endpoint);
-            Signus.StoreTheirDidAsync(_wallet, identityJson).Wait();
+            await Signus.StoreTheirDidAsync(_wallet, identityJson);
 
-            var activeListener = Agent.AgentListenAsync(endpoint, _incomingConnectionObserver).Result;
+            var listener = await Agent.AgentListenAsync(endpoint);
+            await listener.AddIdentityAsync(_pool, _wallet, myDidResult.Did);
 
-            activeListener.AddIdentityAsync(_pool, _wallet, myDidResult.Did).Wait();
+            var clientConnection = await Agent.AgentConnectAsync(_pool, _wallet, myDidResult.Did, myDidResult.Did);
 
-            var clientToServerConnection = Agent.AgentConnectAsync(_pool, _wallet, myDidResult.Did, myDidResult.Did, _messageObserver).Result;
+            var connectionEvent = await listener.WaitForConnection();
+            var serverConnection = connectionEvent.Connection;
 
             var clientToServerMessage = ""msg_from_client"";
             var serverToClientMessage = ""msg_from_server"";
 
-            clientToServerConnection.SendAsync(clientToServerMessage).Wait();
+            await clientConnection.SendAsync(clientToServerMessage);
+
+            var serverMessageEvent = await serverConnection.WaitForMessage();",70,2017-08-14 08:05:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/132893164,https://github.com/hyperledger/indy-sdk/pull/185#discussion_r132893164,srottem
https://github.com/hyperledger/indy-sdk/pull/185,https://github.com/hyperledger/indy-sdk/pull/185,"Yes, I suggest trying rewriting of this tests with WaitForAny usage and check how usable it will be. ",4fb6b69f75823c5ab99f49c2feac11af425dc4d9,2017-08-14 12:01:47,132933812,"@@ -1,69 +1,45 @@
 ﻿using Indy.Sdk.Dotnet.Wrapper;
 using Microsoft.VisualStudio.TestTools.UnitTesting;
-using System;
 using System.Threading.Tasks;
-using static Indy.Sdk.Dotnet.Wrapper.Agent;
 
 namespace Indy.Sdk.Dotnet.Test.Wrapper.AgentTests
 {
     [TestClass]
     public class AgentSendTest : AgentIntegrationTestBase
     {
-        private static TaskCompletionSource<Connection> serverToClientConnectionFuture = new TaskCompletionSource<Connection>();
-        private static TaskCompletionSource<string> serverToClientMsgFuture = new TaskCompletionSource<string>();
-        private static TaskCompletionSource<string> clientToServerMsgFuture = new TaskCompletionSource<string>();
-
-        private new static MessageReceivedHandler _messageObserver = (Connection connection, string message) =>
-            {
-                Console.WriteLine(""Received message '"" + message + ""' on connection "" + connection);
-
-                serverToClientMsgFuture.SetResult(message);
-            };
-
-        private new static MessageReceivedHandler _messageObserverForIncoming = (Connection connection, string message) =>
-            {
-                Console.WriteLine(""Received message '"" + message + ""' on incoming connection "" + connection);
-
-                clientToServerMsgFuture.SetResult(message);
-            };
-
-        private new static ConnectionOpenedHandler _incomingConnectionObserver = (Listener listener, Connection connection, string senderDid, string receiverDid) =>
-            {
-                Console.WriteLine(""New connection "" + connection);
-
-                serverToClientConnectionFuture.SetResult(connection);
-
-                return _messageObserverForIncoming;
-            };
-
         [TestMethod]
-        public void TestAgentSendWorks()
+        public async Task TestAgentSendWorks()
         {
             var endpoint = ""127.0.0.1:9609"";
 
-            var myDidResult = Signus.CreateAndStoreMyDidAsync(_wallet, ""{}"").Result;
+            var myDidResult = await Signus.CreateAndStoreMyDidAsync(_wallet, ""{}"");
 
             var identityJson = string.Format(""{{\""did\"":\""{0}\"", \""pk\"":\""{1}\"", \""verkey\"":\""{2}\"", \""endpoint\"":\""{3}\""}}"",
                     myDidResult.Did, myDidResult.Pk, myDidResult.VerKey, endpoint);
-            Signus.StoreTheirDidAsync(_wallet, identityJson).Wait();
+            await Signus.StoreTheirDidAsync(_wallet, identityJson);
 
-            var activeListener = Agent.AgentListenAsync(endpoint, _incomingConnectionObserver).Result;
+            var listener = await Agent.AgentListenAsync(endpoint);
+            await listener.AddIdentityAsync(_pool, _wallet, myDidResult.Did);
 
-            activeListener.AddIdentityAsync(_pool, _wallet, myDidResult.Did).Wait();
+            var clientConnection = await Agent.AgentConnectAsync(_pool, _wallet, myDidResult.Did, myDidResult.Did);
 
-            var clientToServerConnection = Agent.AgentConnectAsync(_pool, _wallet, myDidResult.Did, myDidResult.Did, _messageObserver).Result;
+            var connectionEvent = await listener.WaitForConnection();
+            var serverConnection = connectionEvent.Connection;
 
             var clientToServerMessage = ""msg_from_client"";
             var serverToClientMessage = ""msg_from_server"";
 
-            clientToServerConnection.SendAsync(clientToServerMessage).Wait();
+            await clientConnection.SendAsync(clientToServerMessage);
+
+            var serverMessageEvent = await serverConnection.WaitForMessage();",70,2017-08-14 12:01:47,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/132933812,https://github.com/hyperledger/indy-sdk/pull/185#discussion_r132933812,vimmerru
https://github.com/hyperledger/indy-sdk/pull/172,https://github.com/hyperledger/indy-sdk/pull/172,Is it indy_sign_request?,c13a3280402c945a10a47640cbcb0d4871e723d2,2017-08-10 09:07:57,132400608,"@@ -68,6 +68,39 @@ extern ""C"" {
                                                                      const char*     request_result_json)
                                                );
 
+
+    /// Signs request message.
+    ///
+    /// Adds submitter information to passed request json, signs it with submitter
+    /// sign key (see wallet_sign).
+    ///
+    /// #Params
+    /// command_handle: command handle to map callback to caller context.
+    /// wallet_handle: wallet handle (created by open_wallet).
+    /// submitter_did: Id of Identity stored in secured Wallet.
+    /// request_json: Request data json.
+    /// cb: Callback that takes command result as parameter.
+    ///
+    /// #Returns
+    /// Signed request json.
+    ///
+    /// #Errors
+    /// Common*
+    /// Wallet*
+    /// Ledger*
+    /// Crypto*
+
+    extern indy_error_t indy_sign_and_submit_request(indy_handle_t command_handle,",,2017-08-11 07:11:49,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/132400608,https://github.com/hyperledger/indy-sdk/pull/172#discussion_r132400608,jovfer
https://github.com/hyperledger/indy-sdk/pull/172,https://github.com/hyperledger/indy-sdk/pull/172,@vimmerru should we also implement indy_verify_request?,c13a3280402c945a10a47640cbcb0d4871e723d2,2017-08-10 09:12:32,132401589,"@@ -68,6 +68,39 @@ extern ""C"" {
                                                                      const char*     request_result_json)
                                                );
 
+
+    /// Signs request message.
+    ///
+    /// Adds submitter information to passed request json, signs it with submitter
+    /// sign key (see wallet_sign).
+    ///
+    /// #Params
+    /// command_handle: command handle to map callback to caller context.
+    /// wallet_handle: wallet handle (created by open_wallet).
+    /// submitter_did: Id of Identity stored in secured Wallet.
+    /// request_json: Request data json.
+    /// cb: Callback that takes command result as parameter.
+    ///
+    /// #Returns
+    /// Signed request json.
+    ///
+    /// #Errors
+    /// Common*
+    /// Wallet*
+    /// Ledger*
+    /// Crypto*
+
+    extern indy_error_t indy_sign_and_submit_request(indy_handle_t command_handle,
+                                                         indy_handle_t wallet_handle,
+                                                         const char *    submitter_did,
+                                                         const char *    request_json,
+
+                                                         void           (*cb)(indy_handle_t xcommand_handle,
+                                                                              indy_error_t  err,
+                                                                              const char*     signed_request_json)
+                                                         );
+
+",36,2017-08-11 07:11:49,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/132401589,https://github.com/hyperledger/indy-sdk/pull/172#discussion_r132401589,jovfer
https://github.com/hyperledger/indy-sdk/pull/172,https://github.com/hyperledger/indy-sdk/pull/172,"No, I don't see a use case for this request. We sign request to be only verified by pool nodes.",c13a3280402c945a10a47640cbcb0d4871e723d2,2017-08-10 09:41:30,132408062,"@@ -68,6 +68,39 @@ extern ""C"" {
                                                                      const char*     request_result_json)
                                                );
 
+
+    /// Signs request message.
+    ///
+    /// Adds submitter information to passed request json, signs it with submitter
+    /// sign key (see wallet_sign).
+    ///
+    /// #Params
+    /// command_handle: command handle to map callback to caller context.
+    /// wallet_handle: wallet handle (created by open_wallet).
+    /// submitter_did: Id of Identity stored in secured Wallet.
+    /// request_json: Request data json.
+    /// cb: Callback that takes command result as parameter.
+    ///
+    /// #Returns
+    /// Signed request json.
+    ///
+    /// #Errors
+    /// Common*
+    /// Wallet*
+    /// Ledger*
+    /// Crypto*
+
+    extern indy_error_t indy_sign_and_submit_request(indy_handle_t command_handle,
+                                                         indy_handle_t wallet_handle,
+                                                         const char *    submitter_did,
+                                                         const char *    request_json,
+
+                                                         void           (*cb)(indy_handle_t xcommand_handle,
+                                                                              indy_error_t  err,
+                                                                              const char*     signed_request_json)
+                                                         );
+
+",36,2017-08-11 07:11:49,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/132408062,https://github.com/hyperledger/indy-sdk/pull/172#discussion_r132408062,vimmerru
https://github.com/hyperledger/indy-sdk/pull/172,https://github.com/hyperledger/indy-sdk/pull/172,Should not be merged into master,c13a3280402c945a10a47640cbcb0d4871e723d2,2017-08-10 15:41:40,132490979,"@@ -11,7 +11,7 @@ RUN apt-get install -y \
       gdebi \
       apt-utils
 
-ADD https://repo.evernym.com/deb/indy-sdk/0.1.1-100/indy-sdk_0.1.1_amd64.deb .
+ADD https://repo.evernym.com/deb/indy-sdk/0.1.1-7/indy-sdk_0.1.1_amd64.deb .",5,2017-08-11 07:11:49,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/132490979,https://github.com/hyperledger/indy-sdk/pull/172#discussion_r132490979,jovfer
https://github.com/hyperledger/indy-sdk/pull/172,https://github.com/hyperledger/indy-sdk/pull/172,"Should operate with byte arrays, not with strings.",c13a3280402c945a10a47640cbcb0d4871e723d2,2017-08-11 11:13:04,132663544,"@@ -165,7 +166,8 @@ extern ""C"" {
                                                   indy_handle_t pool_handle,
                                                   
                                                   const char *    did,
-                                                  const char *    signed_msg,
+                                                  const char *    msg,",13,2017-08-11 11:13:04,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/132663544,https://github.com/hyperledger/indy-sdk/pull/172#discussion_r132663544,jovfer
https://github.com/hyperledger/indy-sdk/pull/169,https://github.com/hyperledger/indy-sdk/pull/169,I am not sure that looking for libindy inside jar is a good idea at all. libindy should be installed with corresponded installation package and loaded from system LD path.,95a428504f9be0de05315b4af6d765935510e76f,2017-08-09 12:09:28,132164872,"@@ -3,12 +3,10 @@
 
 import org.hyperledger.indy.sdk.LibIndy;
 
-import java.io.File;
-
 public class InitHelper {
 	public static void init() {
 
-		if (!LibIndy.isInitialized()) LibIndy.init(new File(""./lib/libindy""));
+		if (!LibIndy.isInitialized()) LibIndy.init(""./lib/"");",10,2017-08-09 12:10:13,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/132164872,https://github.com/hyperledger/indy-sdk/pull/169#discussion_r132164872,vimmerru
https://github.com/hyperledger/indy-sdk/pull/169,https://github.com/hyperledger/indy-sdk/pull/169,"It doesn't look for libindy inside the jar.

Calling `LibIndy.init()` will load libindy from system LD path. <-- default
Calling `LibIndy.init(new File(""./lib/libindy.so""))` will load libindy from a given file path. <-- not platform independent.
Calling `LibIndy.init(""./lib/"")` will load libindy from a given directory path. <-- useful for testing, this is new.
",95a428504f9be0de05315b4af6d765935510e76f,2017-08-09 12:49:50,132173278,"@@ -3,12 +3,10 @@
 
 import org.hyperledger.indy.sdk.LibIndy;
 
-import java.io.File;
-
 public class InitHelper {
 	public static void init() {
 
-		if (!LibIndy.isInitialized()) LibIndy.init(new File(""./lib/libindy""));
+		if (!LibIndy.isInitialized()) LibIndy.init(""./lib/"");",10,2017-08-09 12:49:50,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/132173278,https://github.com/hyperledger/indy-sdk/pull/169#discussion_r132173278,peacekeeper
https://github.com/hyperledger/indy-sdk/pull/169,https://github.com/hyperledger/indy-sdk/pull/169,"Personally, i prefer lazy loading without providing explicit LibIndy.init() API at all. If a user (or tester) needs to load the library from the specific place he can just modify LD path for the current process that can be easily done with environment variables on the most platforms.

What do you think about this?",95a428504f9be0de05315b4af6d765935510e76f,2017-08-09 14:47:52,132206019,"@@ -3,12 +3,10 @@
 
 import org.hyperledger.indy.sdk.LibIndy;
 
-import java.io.File;
-
 public class InitHelper {
 	public static void init() {
 
-		if (!LibIndy.isInitialized()) LibIndy.init(new File(""./lib/libindy""));
+		if (!LibIndy.isInitialized()) LibIndy.init(""./lib/"");",10,2017-08-09 14:47:52,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/132206019,https://github.com/hyperledger/indy-sdk/pull/169#discussion_r132206019,vimmerru
https://github.com/hyperledger/indy-sdk/pull/169,https://github.com/hyperledger/indy-sdk/pull/169,"For example, I am working with python and java wrapper on the windows and instead of 
```
maven test
```

command I just use

```
PATH=C:\indy-sdk\libindy\target\debug;%PATH% maven test
```",95a428504f9be0de05315b4af6d765935510e76f,2017-08-09 14:53:23,132207912,"@@ -3,12 +3,10 @@
 
 import org.hyperledger.indy.sdk.LibIndy;
 
-import java.io.File;
-
 public class InitHelper {
 	public static void init() {
 
-		if (!LibIndy.isInitialized()) LibIndy.init(new File(""./lib/libindy""));
+		if (!LibIndy.isInitialized()) LibIndy.init(""./lib/"");",10,2017-08-09 14:53:23,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/132207912,https://github.com/hyperledger/indy-sdk/pull/169#discussion_r132207912,vimmerru
https://github.com/hyperledger/indy-sdk/pull/169,https://github.com/hyperledger/indy-sdk/pull/169,"I agree. Actually, if libindy is in the LD path, it is already loaded automatically today, and the user doesn't have to manually call the LibIndy.init() API at all.

But for example the current unit tests (see [InitHelper.java](https://github.com/hyperledger/indy-sdk/blob/master/wrappers/java/src/test/java/org/hyperledger/indy/sdk/utils/InitHelper.java)) are loading libindy from a local directory as follows:

`LibIndy.init(new File(""./lib/libindy""));
`

I agree it's preferable to load libindy from the LD path, but just in case someone doesn't want to do it, this PR provides a better, platform-independent way of doing it.",95a428504f9be0de05315b4af6d765935510e76f,2017-08-09 15:31:23,132220156,"@@ -3,12 +3,10 @@
 
 import org.hyperledger.indy.sdk.LibIndy;
 
-import java.io.File;
-
 public class InitHelper {
 	public static void init() {
 
-		if (!LibIndy.isInitialized()) LibIndy.init(new File(""./lib/libindy""));
+		if (!LibIndy.isInitialized()) LibIndy.init(""./lib/"");",10,2017-08-09 15:31:23,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/132220156,https://github.com/hyperledger/indy-sdk/pull/169#discussion_r132220156,peacekeeper
https://github.com/hyperledger/indy-sdk/pull/157,https://github.com/hyperledger/indy-sdk/pull/157,Can we check that genesis txns are really applied/processed?,a0a825f98d49e5214448ca305870eb5435b71eff,2017-08-03 12:26:51,131126791,"@@ -1,31 +1,45 @@
-from tests.utils import pool, storage
+import json
+
+from indy import pool
+from tests.utils import pool as pool_utils, storage as storage_utils
 from indy.error import ErrorCode, IndyError
 
 import pytest
 
 
 @pytest.mark.asyncio
 async def test_create_pool_ledger_config_works(cleanup_storage):
-    await pool.create_pool_ledger_config(""pool_1"")
+    await pool.create_pool_ledger_config(",,2017-08-08 11:55:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/131126791,https://github.com/hyperledger/indy-sdk/pull/157#discussion_r131126791,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/157,https://github.com/hyperledger/indy-sdk/pull/157,Can we check that it's really deleted?,a0a825f98d49e5214448ca305870eb5435b71eff,2017-08-03 12:27:28,131126917,"@@ -1,21 +1,29 @@
-from tests.utils import pool
-from indy.pool import delete_pool_ledger_config
+import json
+
+from tests.utils import pool as pool_utils
+from indy import pool
 from indy.error import ErrorCode, IndyError
 
 import pytest
 
 
 @pytest.mark.asyncio
 async def test_delete_pool_ledger_config_works(cleanup_storage):
-    await pool.create_pool_ledger_config(""pool_1"")
-    await delete_pool_ledger_config(""pool_1"")
+    await pool.create_pool_ledger_config(
+        ""pool_1"",
+        json.dumps({
+            ""genesis_txn"": str(pool_utils.create_genesis_txn_file_for_test_pool(""pool_1""))
+        }))
+
+    await pool.delete_pool_ledger_config(""pool_1"")",,2017-08-08 11:55:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/131126917,https://github.com/hyperledger/indy-sdk/pull/157#discussion_r131126917,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/157,https://github.com/hyperledger/indy-sdk/pull/157,Should we move this code into a fixture as it's used in multiple tests?,a0a825f98d49e5214448ca305870eb5435b71eff,2017-08-03 12:28:20,131127072,"@@ -1,58 +1,81 @@
-from tests.utils import pool
-from indy.pool import open_pool_ledger
+import json
+
+from tests.utils import pool as pool_utils
+from indy import pool
 from indy.error import ErrorCode, IndyError
 
 import pytest
 
 
 @pytest.mark.asyncio
 async def test_open_pool_ledger_works(cleanup_storage):
-    await pool.create_pool_ledger_config(""pool_1"")
-    pool_handle = await open_pool_ledger(""pool_1"", """")
+    await pool.create_pool_ledger_config(",,2017-08-08 11:55:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/131127072,https://github.com/hyperledger/indy-sdk/pull/157#discussion_r131127072,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/157,https://github.com/hyperledger/indy-sdk/pull/157,How do we check that it's really opened? is `assert pool_handle is not None` enough?,a0a825f98d49e5214448ca305870eb5435b71eff,2017-08-03 12:29:23,131127270,"@@ -1,58 +1,81 @@
-from tests.utils import pool
-from indy.pool import open_pool_ledger
+import json
+
+from tests.utils import pool as pool_utils
+from indy import pool
 from indy.error import ErrorCode, IndyError
 
 import pytest
 
 
 @pytest.mark.asyncio
 async def test_open_pool_ledger_works(cleanup_storage):
-    await pool.create_pool_ledger_config(""pool_1"")
-    pool_handle = await open_pool_ledger(""pool_1"", """")
+    await pool.create_pool_ledger_config(
+        ""pool_1"",
+        json.dumps({
+            ""genesis_txn"": str(pool_utils.create_genesis_txn_file_for_test_pool(""pool_1""))
+        }))
+
+    pool_handle = await pool.open_pool_ledger(""pool_1"", None)
     assert pool_handle is not None
+
     await pool.close_pool_ledger(pool_handle)
 
 
 @pytest.mark.asyncio
 async def test_open_pool_ledger_works_for_config(cleanup_storage):
-    config = '{""refreshOnOpen"": true}'
-    await pool.create_pool_ledger_config(""pool_1"")
-    pool_handle = await open_pool_ledger(""pool_1"", config)
+    await pool.create_pool_ledger_config(
+        ""pool_1"",
+        json.dumps({
+            ""genesis_txn"": str(pool_utils.create_genesis_txn_file_for_test_pool(""pool_1""))
+        }))
+
+    pool_handle = await pool.open_pool_ledger(""pool_1"", '{""refreshOnOpen"": true}')
     assert pool_handle is not None
+
     await pool.close_pool_ledger(pool_handle)
 
 
 @pytest.mark.asyncio
 async def test_open_pool_ledger_works_for_twice(cleanup_storage):
-    await pool.create_pool_ledger_config(""pool_1"")
-    pool_handle = await open_pool_ledger(""pool_1"", """")
+    await pool.create_pool_ledger_config(
+        ""pool_1"",
+        json.dumps({
+            ""genesis_txn"": str(pool_utils.create_genesis_txn_file_for_test_pool(""pool_1""))
+        }))
+
+    pool_handle = await pool.open_pool_ledger(""pool_1"", None)
     assert pool_handle is not None
+
     with pytest.raises(IndyError) as e:
-        await open_pool_ledger(""pool_1"", """")
+        await pool.open_pool_ledger(""pool_1"", """")
+
     assert ErrorCode.PoolLedgerInvalidPoolHandle == e.value.error_code
     await pool.close_pool_ledger(pool_handle)
 
 
 @pytest.mark.asyncio
 async def test_open_pool_ledger_works_for_two_nodes(cleanup_storage):
-    nodes = [
-        ""{\""data\"":{\""alias\"":\""Node1\"",\""client_ip\"":\""10.0.0.2\"",\""client_port\"":9702,\""node_ip\"":\""10.0.0.2\"",\""node_port\"":9701,\""services\"":[\""VALIDATOR\""]},\""dest\"":\""Gw6pDLhcBcoQesN72qfotTgFa7cbuqZpkX3Xo6pLhPhv\"",\""identifier\"":\""Th7MpTaRZVRYnPiabds81Y\"",\""txnId\"":\""fea82e10e894419fe2bea7d96296a6d46f50f93f9eeda954ec461b2ed2950b62\"",\""type\"":\""0\""}\n"",
-        ""{\""data\"":{\""alias\"":\""Node2\"",\""client_ip\"":\""10.0.0.2\"",\""client_port\"":9704,\""node_ip\"":\""10.0.0.2\"",\""node_port\"":9703,\""services\"":[\""VALIDATOR\""]},\""dest\"":\""8ECVSk179mjsjKRLWiQtssMLgp6EPhWXtaYyStWPSGAb\"",\""identifier\"":\""EbP4aYNeTHL6q385GuVpRV\"",\""txnId\"":\""1ac8aece2a18ced660fef8694b61aac3af08ba875ce3026a160acbc3a3af35fc\"",\""type\"":\""0\""}\n""
-    ]
-    await pool.create_pool_ledger_config(""pool_1"", nodes)
-    pool_handle = await open_pool_ledger(""pool_1"", None)
+    await pool.create_pool_ledger_config(
+        ""pool_1"",
+        json.dumps({
+            ""genesis_txn"": str(pool_utils.create_genesis_txn_file_for_test_pool(""pool_1"", 2))
+        }))
+
+    pool_handle = await pool.open_pool_ledger(""pool_1"", None)",,2017-08-08 11:55:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/131127270,https://github.com/hyperledger/indy-sdk/pull/157#discussion_r131127270,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/157,https://github.com/hyperledger/indy-sdk/pull/157,"Looks like we need to start a discussion about test procedure design.

My vision is the following. This method provides only ok/exception for checking as a public interface. Integration tests should work on this public interface level only.

Sure we can perform additional checks:

1. Try to create config twice and get corresponded exception, but it is a dedicated test case. In rust we have this test case, but it is in the medium cases bunch. So we didn't port it to python.
2. We can try to open pool with this configuration, but it will actually test case for open_pool method. We have this test case in a dedicated file.
3. We can check that files on file system are actually created, but it is testing of non-documented side effects. It can be good unit tests for libindy, but we don't need this test for python wrapper.",a0a825f98d49e5214448ca305870eb5435b71eff,2017-08-03 12:45:35,131130552,"@@ -1,31 +1,45 @@
-from tests.utils import pool, storage
+import json
+
+from indy import pool
+from tests.utils import pool as pool_utils, storage as storage_utils
 from indy.error import ErrorCode, IndyError
 
 import pytest
 
 
 @pytest.mark.asyncio
 async def test_create_pool_ledger_config_works(cleanup_storage):
-    await pool.create_pool_ledger_config(""pool_1"")
+    await pool.create_pool_ledger_config(",,2017-08-08 11:55:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/131130552,https://github.com/hyperledger/indy-sdk/pull/157#discussion_r131130552,vimmerru
https://github.com/hyperledger/indy-sdk/pull/157,https://github.com/hyperledger/indy-sdk/pull/157,See my comment about create_pool_ledger_config. We have exactly same situation here.,a0a825f98d49e5214448ca305870eb5435b71eff,2017-08-03 15:17:36,131172260,"@@ -1,21 +1,29 @@
-from tests.utils import pool
-from indy.pool import delete_pool_ledger_config
+import json
+
+from tests.utils import pool as pool_utils
+from indy import pool
 from indy.error import ErrorCode, IndyError
 
 import pytest
 
 
 @pytest.mark.asyncio
 async def test_delete_pool_ledger_config_works(cleanup_storage):
-    await pool.create_pool_ledger_config(""pool_1"")
-    await delete_pool_ledger_config(""pool_1"")
+    await pool.create_pool_ledger_config(
+        ""pool_1"",
+        json.dumps({
+            ""genesis_txn"": str(pool_utils.create_genesis_txn_file_for_test_pool(""pool_1""))
+        }))
+
+    await pool.delete_pool_ledger_config(""pool_1"")",,2017-08-08 11:55:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/131172260,https://github.com/hyperledger/indy-sdk/pull/157#discussion_r131172260,vimmerru
https://github.com/hyperledger/indy-sdk/pull/157,https://github.com/hyperledger/indy-sdk/pull/157,See my comment about create_pool_ledger_config. We have an exactly same situation here.,a0a825f98d49e5214448ca305870eb5435b71eff,2017-08-03 15:17:53,131172358,"@@ -1,58 +1,81 @@
-from tests.utils import pool
-from indy.pool import open_pool_ledger
+import json
+
+from tests.utils import pool as pool_utils
+from indy import pool
 from indy.error import ErrorCode, IndyError
 
 import pytest
 
 
 @pytest.mark.asyncio
 async def test_open_pool_ledger_works(cleanup_storage):
-    await pool.create_pool_ledger_config(""pool_1"")
-    pool_handle = await open_pool_ledger(""pool_1"", """")
+    await pool.create_pool_ledger_config(
+        ""pool_1"",
+        json.dumps({
+            ""genesis_txn"": str(pool_utils.create_genesis_txn_file_for_test_pool(""pool_1""))
+        }))
+
+    pool_handle = await pool.open_pool_ledger(""pool_1"", None)
     assert pool_handle is not None
+
     await pool.close_pool_ledger(pool_handle)
 
 
 @pytest.mark.asyncio
 async def test_open_pool_ledger_works_for_config(cleanup_storage):
-    config = '{""refreshOnOpen"": true}'
-    await pool.create_pool_ledger_config(""pool_1"")
-    pool_handle = await open_pool_ledger(""pool_1"", config)
+    await pool.create_pool_ledger_config(
+        ""pool_1"",
+        json.dumps({
+            ""genesis_txn"": str(pool_utils.create_genesis_txn_file_for_test_pool(""pool_1""))
+        }))
+
+    pool_handle = await pool.open_pool_ledger(""pool_1"", '{""refreshOnOpen"": true}')
     assert pool_handle is not None
+
     await pool.close_pool_ledger(pool_handle)
 
 
 @pytest.mark.asyncio
 async def test_open_pool_ledger_works_for_twice(cleanup_storage):
-    await pool.create_pool_ledger_config(""pool_1"")
-    pool_handle = await open_pool_ledger(""pool_1"", """")
+    await pool.create_pool_ledger_config(
+        ""pool_1"",
+        json.dumps({
+            ""genesis_txn"": str(pool_utils.create_genesis_txn_file_for_test_pool(""pool_1""))
+        }))
+
+    pool_handle = await pool.open_pool_ledger(""pool_1"", None)
     assert pool_handle is not None
+
     with pytest.raises(IndyError) as e:
-        await open_pool_ledger(""pool_1"", """")
+        await pool.open_pool_ledger(""pool_1"", """")
+
     assert ErrorCode.PoolLedgerInvalidPoolHandle == e.value.error_code
     await pool.close_pool_ledger(pool_handle)
 
 
 @pytest.mark.asyncio
 async def test_open_pool_ledger_works_for_two_nodes(cleanup_storage):
-    nodes = [
-        ""{\""data\"":{\""alias\"":\""Node1\"",\""client_ip\"":\""10.0.0.2\"",\""client_port\"":9702,\""node_ip\"":\""10.0.0.2\"",\""node_port\"":9701,\""services\"":[\""VALIDATOR\""]},\""dest\"":\""Gw6pDLhcBcoQesN72qfotTgFa7cbuqZpkX3Xo6pLhPhv\"",\""identifier\"":\""Th7MpTaRZVRYnPiabds81Y\"",\""txnId\"":\""fea82e10e894419fe2bea7d96296a6d46f50f93f9eeda954ec461b2ed2950b62\"",\""type\"":\""0\""}\n"",
-        ""{\""data\"":{\""alias\"":\""Node2\"",\""client_ip\"":\""10.0.0.2\"",\""client_port\"":9704,\""node_ip\"":\""10.0.0.2\"",\""node_port\"":9703,\""services\"":[\""VALIDATOR\""]},\""dest\"":\""8ECVSk179mjsjKRLWiQtssMLgp6EPhWXtaYyStWPSGAb\"",\""identifier\"":\""EbP4aYNeTHL6q385GuVpRV\"",\""txnId\"":\""1ac8aece2a18ced660fef8694b61aac3af08ba875ce3026a160acbc3a3af35fc\"",\""type\"":\""0\""}\n""
-    ]
-    await pool.create_pool_ledger_config(""pool_1"", nodes)
-    pool_handle = await open_pool_ledger(""pool_1"", None)
+    await pool.create_pool_ledger_config(
+        ""pool_1"",
+        json.dumps({
+            ""genesis_txn"": str(pool_utils.create_genesis_txn_file_for_test_pool(""pool_1"", 2))
+        }))
+
+    pool_handle = await pool.open_pool_ledger(""pool_1"", None)",,2017-08-08 11:55:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/131172358,https://github.com/hyperledger/indy-sdk/pull/157#discussion_r131172358,vimmerru
https://github.com/hyperledger/indy-sdk/pull/157,https://github.com/hyperledger/indy-sdk/pull/157,"Why did we remove the assert? I think each test should have some assertion because of two reasons:
- this is the main purpose of the test 
- it becomes clear that the test is complete, and not just a stub",a0a825f98d49e5214448ca305870eb5435b71eff,2017-08-08 10:49:06,131879755,"@@ -1,11 +1,13 @@
 import pytest
 
 
+# noinspection PyUnusedLocal
 @pytest.mark.asyncio
 async def test_agent_add_identity_works(listener_with_identity):
-    assert listener_with_identity is not None
+    pass
 
 
+# noinspection PyUnusedLocal
 @pytest.mark.asyncio
 async def test_agent_add_identity_works_for_multiply_keys(listener_with_identities):
-    assert listener_with_identities is not None
+    pass",15,2017-08-08 11:55:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/131879755,https://github.com/hyperledger/indy-sdk/pull/157#discussion_r131879755,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/157,https://github.com/hyperledger/indy-sdk/pull/157,Should we check that returned proof satisfies the expected result (as defined by the API)?,a0a825f98d49e5214448ca305870eb5435b71eff,2017-08-08 10:57:47,131881528,"@@ -42,29 +44,33 @@
     }
 
     schemas = {
-        claim_for_attr: anoncreds.get_gvt_schema_json(1)
+        claim_for_attr: gvt_schema
     }
 
     claim_defs = {
-        claim_for_attr: json.loads(init_common_wallet[1])
+        claim_for_attr: json.loads(claim_def_json)
     }
 
-    await prover_create_proof(init_common_wallet[0], json.dumps(proof_req), json.dumps(requested_claims),
-                              json.dumps(schemas), anoncreds.COMMON_MASTER_SECRET_NAME,
+    await prover_create_proof(wallet_handle, json.dumps(proof_req), json.dumps(requested_claims),",54,2017-08-08 11:55:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/131881528,https://github.com/hyperledger/indy-sdk/pull/157#discussion_r131881528,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/157,https://github.com/hyperledger/indy-sdk/pull/157,Can we check that the returned claim offers match the expected result (as defined by API)?,a0a825f98d49e5214448ca305870eb5435b71eff,2017-08-08 10:59:10,131881803,"@@ -1,57 +1,74 @@
 from indy.anoncreds import prover_get_claim_offers
 from indy.error import ErrorCode, IndyError
 
-from tests.utils import anoncreds
-
 import json
 import pytest
 
 
+# noinspection PyUnusedLocal
 @pytest.mark.asyncio
-async def test_prover_get_claim_offers_works_for_empty_filter(init_common_wallet):
-    claim_offers = json.loads(await prover_get_claim_offers(init_common_wallet[0], ""{}""))
+async def test_prover_get_claim_offers_works_for_empty_filter(wallet_handle, prepopulated_wallet):
+    claim_offers = json.loads(
+        await prover_get_claim_offers(wallet_handle, ""{}""))
+
     assert len(claim_offers) == 3",18,2017-08-08 11:55:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/131881803,https://github.com/hyperledger/indy-sdk/pull/157#discussion_r131881803,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/157,https://github.com/hyperledger/indy-sdk/pull/157,Can we check that the returned claims match the expected result (as defined by API)?,a0a825f98d49e5214448ca305870eb5435b71eff,2017-08-08 11:00:04,131881968,"@@ -1,40 +1,54 @@
 from indy.anoncreds import prover_get_claims
 from indy.error import ErrorCode, IndyError
 
-from tests.utils import anoncreds
-
 import json
 import pytest
 
 
+# noinspection PyUnusedLocal
 @pytest.mark.asyncio
-async def test_prover_get_claims_works_for_empty_filter(init_common_wallet):
-    claims = json.loads(await prover_get_claims(init_common_wallet[0], ""{}""))
+async def test_prover_get_claims_works_for_empty_filter(wallet_handle, prepopulated_wallet):
+    claims = json.loads(
+        await prover_get_claims(wallet_handle, ""{}""))
+
     assert len(claims) == 1",18,2017-08-08 11:55:54,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/131881968,https://github.com/hyperledger/indy-sdk/pull/157#discussion_r131881968,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/152,https://github.com/hyperledger/indy-sdk/pull/152,"This file seems like garbage after merge, please re-check and clean-up.",24ca0732d8dfacf408ea37ff758c325269b0a290,2017-08-04 20:33:25,131480709,"@@ -0,0 +1,202 @@
+extern crate time;",,2017-08-07 08:05:46,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/131480709,https://github.com/hyperledger/indy-sdk/pull/152#discussion_r131480709,jovfer
https://github.com/hyperledger/indy-sdk/pull/152,https://github.com/hyperledger/indy-sdk/pull/152,Please re-check the next line: should be swapped with current?,24ca0732d8dfacf408ea37ff758c325269b0a290,2017-08-04 20:35:23,131481125,"@@ -22,6 +22,7 @@ fi
 echo ""Packing...\n\n""
 
 cp include/*.h $WORK_DIR
+cd ../",,2017-08-07 08:05:46,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/131481125,https://github.com/hyperledger/indy-sdk/pull/152#discussion_r131481125,jovfer
https://github.com/hyperledger/indy-sdk/pull/152,https://github.com/hyperledger/indy-sdk/pull/152,this line is deleted,24ca0732d8dfacf408ea37ff758c325269b0a290,2017-08-07 08:06:19,131593968,"@@ -22,6 +22,7 @@ fi
 echo ""Packing...\n\n""
 
 cp include/*.h $WORK_DIR
+cd ../",,2017-08-07 08:06:19,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/131593968,https://github.com/hyperledger/indy-sdk/pull/152#discussion_r131593968,anastasia-tarasova
https://github.com/hyperledger/indy-sdk/pull/152,https://github.com/hyperledger/indy-sdk/pull/152,This file is deleted.,24ca0732d8dfacf408ea37ff758c325269b0a290,2017-08-07 08:06:44,131594037,"@@ -0,0 +1,202 @@
+extern crate time;",,2017-08-07 08:06:44,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/131594037,https://github.com/hyperledger/indy-sdk/pull/152#discussion_r131594037,anastasia-tarasova
https://github.com/hyperledger/indy-sdk/pull/145,https://github.com/hyperledger/indy-sdk/pull/145,"At this point I am not sure from the error message what path the library is seeing verses what path I am passing in the config.

It would help to have the path that the rust library is seeing in the error message",8cf126f0bfd880f2a53e74a631ffc5655d4ebec1,2017-07-28 14:54:26,130109711,"@@ -578,7 +578,8 @@ impl PoolService {
         };
 
         if path.as_path().exists() {
-            return Err(PoolError::NotCreated(""Already created"".to_string()));
+            return Err(PoolError::AlreadyExists(",,2017-08-01 06:00:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/130109711,https://github.com/hyperledger/indy-sdk/pull/145#discussion_r130109711,FarooqKhan
https://github.com/hyperledger/indy-sdk/pull/145,https://github.com/hyperledger/indy-sdk/pull/145,"> It would help to have the path that the rust library is seeing in the error message

It is internal information about libindy persistent storage. All you need to know as the developer is the pool config name, but you just passed this name to this call. 

Actually, it is a good idea to add pool config name to this error message.",8cf126f0bfd880f2a53e74a631ffc5655d4ebec1,2017-07-28 15:06:24,130112803,"@@ -578,7 +578,8 @@ impl PoolService {
         };
 
         if path.as_path().exists() {
-            return Err(PoolError::NotCreated(""Already created"".to_string()));
+            return Err(PoolError::AlreadyExists(",,2017-08-01 06:00:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/130112803,https://github.com/hyperledger/indy-sdk/pull/145#discussion_r130112803,vimmerru
https://github.com/hyperledger/indy-sdk/pull/145,https://github.com/hyperledger/indy-sdk/pull/145,"I am not sure that it is the correct terminology. Actually we are creating pool ledger config, but not just pool ledger. I suggest to change it in all places.",8cf126f0bfd880f2a53e74a631ffc5655d4ebec1,2017-07-28 15:10:42,130113892,"@@ -93,6 +93,9 @@ typedef enum
     // Attempt to send transaction without the necessary privileges
     LedgerSecurityError = 305,
 
+    // Attempt to create pool with name used for another exists pool
+    PoolLedgerAlreadyExistsError = 306,",,2017-08-01 06:00:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/130113892,https://github.com/hyperledger/indy-sdk/pull/145#discussion_r130113892,vimmerru
https://github.com/hyperledger/indy-sdk/pull/145,https://github.com/hyperledger/indy-sdk/pull/145,"> Pool already exists

should be changed to

> Pool ledger config already exists

Also, we need pool config name in the description",8cf126f0bfd880f2a53e74a631ffc5655d4ebec1,2017-07-28 15:11:51,130114178,"@@ -24,6 +25,7 @@ impl fmt::Display for PoolError {
             PoolError::InvalidHandle(ref description) => write!(f, ""Invalid Handle: {}"", description),
             PoolError::Rejected(ref description) => write!(f, ""Rejected by pool: {}"", description),
             PoolError::Terminate => write!(f, ""Pool work terminated""),
+            PoolError::AlreadyExists(ref description) => write!(f, ""Pool already exists {}"", description),",,2017-08-01 06:00:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/130114178,https://github.com/hyperledger/indy-sdk/pull/145#discussion_r130114178,vimmerru
https://github.com/hyperledger/indy-sdk/pull/145,https://github.com/hyperledger/indy-sdk/pull/145,Need to correct English in some messages. Discuss this with me.,8cf126f0bfd880f2a53e74a631ffc5655d4ebec1,2017-07-28 15:12:54,130114438,"@@ -578,7 +578,8 @@ impl PoolService {
         };
 
         if path.as_path().exists() {
-            return Err(PoolError::NotCreated(""Already created"".to_string()));
+            return Err(PoolError::AlreadyExists(
+                ""Pool config file with same name already exists"".to_string()));",,2017-08-01 06:00:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/130114438,https://github.com/hyperledger/indy-sdk/pull/145#discussion_r130114438,vimmerru
https://github.com/hyperledger/indy-sdk/pull/145,https://github.com/hyperledger/indy-sdk/pull/145,May be it is better to rename this to PoolLedgerConfigAlreadyExistsError. Let's discuss offline.,8cf126f0bfd880f2a53e74a631ffc5655d4ebec1,2017-07-28 15:13:43,130114635,"@@ -92,6 +92,9 @@ class ErrorCode(IntEnum):
     # Attempt to send transaction without the necessary privileges
     LedgerSecurityError = 305,
 
+    # Attempt to create pool with name used for another exists pool
+    PoolLedgerAlreadyExistsError = 306,",,2017-08-01 06:00:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/130114635,https://github.com/hyperledger/indy-sdk/pull/145#discussion_r130114635,vimmerru
https://github.com/hyperledger/indy-sdk/pull/145,https://github.com/hyperledger/indy-sdk/pull/145,I meant the path of the ledger transaction file,8cf126f0bfd880f2a53e74a631ffc5655d4ebec1,2017-07-28 21:50:16,130193625,"@@ -578,7 +578,8 @@ impl PoolService {
         };
 
         if path.as_path().exists() {
-            return Err(PoolError::NotCreated(""Already created"".to_string()));
+            return Err(PoolError::AlreadyExists(",,2017-08-01 06:00:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/130193625,https://github.com/hyperledger/indy-sdk/pull/145#discussion_r130193625,FarooqKhan
https://github.com/hyperledger/indy-sdk/pull/133,https://github.com/hyperledger/indy-sdk/pull/133,I think it would be better to have two separate wallets and endpoints ,0e2f8254f39d129af38f9e326bdb6a3c2f6e719d,2017-07-25 08:58:07,129248365,"@@ -0,0 +1,84 @@
+import json
+
+import pytest
+
+from indy import signus, agent
+
+
+@pytest.fixture
+async def endpoint():
+    return ""127.0.0.1:9701""
+
+
+@pytest.fixture
+async def wallet_with_identity(wallet_handle, endpoint):
+    did, verkey, pk = await signus.create_and_store_my_did(wallet_handle, ""{}"")
+    await signus.store_their_did(wallet_handle,",16,2017-07-25 08:58:07,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/129248365,https://github.com/hyperledger/indy-sdk/pull/133#discussion_r129248365,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/133,https://github.com/hyperledger/indy-sdk/pull/133,"Do we have a test to check a pairwise connection, that is communication in both directions (with replies)?",0e2f8254f39d129af38f9e326bdb6a3c2f6e719d,2017-07-25 09:25:19,129254404,"@@ -0,0 +1,25 @@
+import json
+
+import pytest
+
+from indy import signus, ledger, agent
+from tests.utils import wallet
+
+
+@pytest.mark.asyncio
+async def test_agent_send_works_for_all_data_in_wallet_present(connection):",10,2017-07-25 09:25:19,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/129254404,https://github.com/hyperledger/indy-sdk/pull/133#discussion_r129254404,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/132,https://github.com/hyperledger/indy-sdk/pull/132,Use config.py and shared fixtures,4668cf2d38907dad6b3b9433a1b2d5ccc69c0220,2017-07-26 08:02:05,129504827,"@@ -0,0 +1,94 @@
+from indy import agent
+from indy import ledger, signus, wallet, pool
+from indy.pool import open_pool_ledger
+
+from tests.utils import storage
+
+import pytest
+import logging
+import json
+
+from tests.utils.pool import create_genesis_txn_file
+
+logging.basicConfig(level=logging.DEBUG)
+
+
+@pytest.fixture(autouse=True)
+def before_after_each():",,2017-07-26 10:39:42,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/129504827,https://github.com/hyperledger/indy-sdk/pull/132#discussion_r129504827,vimmerru
https://github.com/hyperledger/indy-sdk/pull/119,https://github.com/hyperledger/indy-sdk/pull/119,Check whether it can cause problems when modified in multiple instances,3b6b81252d17314a7db19a6bd2251b0fc185de31,2017-07-21 11:55:51,128745109,"@@ -0,0 +1,308 @@
+import asyncio
+import logging
+from ctypes import *
+from typing import List, Tuple, Any
+
+from .error import ErrorCode, IndyError
+from .libindy import do_call, create_cb
+
+
+class Event:
+    handle: int",,2017-07-21 16:23:42,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/128745109,https://github.com/hyperledger/indy-sdk/pull/119#discussion_r128745109,mzk-vct
https://github.com/hyperledger/indy-sdk/pull/119,https://github.com/hyperledger/indy-sdk/pull/119,"Add docstring with descriptions of these classes, public methods, functions and their params",3b6b81252d17314a7db19a6bd2251b0fc185de31,2017-07-21 12:01:09,128745877,"@@ -0,0 +1,308 @@
+import asyncio
+import logging
+from ctypes import *
+from typing import List, Tuple, Any
+
+from .error import ErrorCode, IndyError
+from .libindy import do_call, create_cb
+
+
+class Event:
+    handle: int
+    error: IndexError
+
+    def is_success(self):
+        return self.error is None
+
+
+class ConnectionEvent(Event):",,2017-07-21 16:23:42,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/128745877,https://github.com/hyperledger/indy-sdk/pull/119#discussion_r128745877,mzk-vct
https://github.com/hyperledger/indy-sdk/pull/93,https://github.com/hyperledger/indy-sdk/pull/93,Implement `else`: may be raise error?,e83d2de747e1bbaef8a681bd20a55a9d900f1ff8,2017-07-11 16:36:10,126743171,"@@ -0,0 +1,45 @@
+//
+//  SovrinSequenceUtils.m
+//  libsovrin
+//
+//  Created by Anastasia Tarasova on 10/07/2017.
+//  Copyright © 2017 Kirill Neznamov. All rights reserved.
+//
+
+#import ""SovrinSequenceUtils.h""
+
+@interface SovrinSequenceUtils()
+
+@property (atomic, strong) NSLock *lock;
+@property (atomic, assign) NSUInteger idsCounter;
+
+@end
+
+@implementation SovrinSequenceUtils
+
++ (SovrinSequenceUtils *)sharedInstance
+{
+    static SovrinSequenceUtils *instance = nil;
+    static dispatch_once_t dispatch_once_block;
+    
+    dispatch_once(&dispatch_once_block, ^{
+        instance = [SovrinSequenceUtils new];
+        instance.idsCounter = 0;
+        instance.lock = [NSLock new];
+    });
+    
+    return instance;
+}
+
+
+- (NSUInteger)getNextId
+{
+    if ([self.lock tryLock])
+    {
+        self.idsCounter +=1;
+    }",,2017-07-12 11:53:43,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/126743171,https://github.com/hyperledger/indy-sdk/pull/93#discussion_r126743171,jovfer
https://github.com/hyperledger/indy-sdk/pull/84,https://github.com/hyperledger/indy-sdk/pull/84,Remove these catches. You swallow errors here,89f4106b53c6e1467bd1567be46e5f765d38fc3e,2017-07-18 10:52:00,127942173,"@@ -51,66 +71,79 @@ try {
     }
 }
 
-def testUbuntu() {
+def testPipeline(file, env_name, run_interoperability_tests) {
     def poolInst
     def network_name = ""pool_network""
     try {
-        echo 'Ubuntu Test: Checkout csm'
+        echo ""${env_name} Test: Checkout csm""
         checkout scm
 
-        echo ""Ubuntu Test: Create docker network (${network_name}) for nodes pool and test image""
+        echo ""${env_name} Test: Create docker network (${network_name}) for nodes pool and test image""
         sh ""docker network create --subnet=10.0.0.0/8 ${network_name}""
 
-        echo 'Ubuntu Test: Build docker image for nodes pool'
+        echo ""${env_name} Test: Build docker image for nodes pool""
         def poolEnv = dockerHelpers.build('indy_pool', 'ci/indy-pool.dockerfile ci')
-        echo 'Ubuntu Test: Run nodes pool'
+        echo ""${env_name} Test: Run nodes pool""
         poolInst = poolEnv.run(""--ip=\""10.0.0.2\"" --network=${network_name}"")
 
-        echo 'Ubuntu Test: Build docker image'
-        def testEnv = dockerHelpers.build(name)
+        echo ""${env_name} Test: Build docker image""
+        def testEnv = dockerHelpers.build(name, file)
 
         testEnv.inside(""--ip=\""10.0.0.3\"" --network=${network_name}"") {
-            echo 'Ubuntu Test: Test'
-            sh 'chmod -R 777 /home/indy/'
-            sh 'cargo update'
-
-            try {
-                sh 'RUST_BACKTRACE=1 RUST_TEST_THREADS=1 cargo test --features ""interoperability_tests""'
-                /* TODO FIXME restore after xunit will be fixed
-                sh 'RUST_TEST_THREADS=1 cargo test-xunit'
-                 */
-            }
-            finally {
-                /* TODO FIXME restore after xunit will be fixed
-                junit 'test-results.xml'
+           echo ""${env_name} Test: Test""
+           sh 'chmod -R 777 /home/indy/'
+           sh 'cargo update'
+
+           try {
+                if (run_interoperability_tests) {
+                    sh 'RUST_BACKTRACE=1 RUST_TEST_THREADS=1 cargo test --features ""interoperability_tests""'
+                }
+                else {
+                    sh 'RUST_BACKTRACE=1 RUST_TEST_THREADS=1 cargo test'
+                }
+               /* TODO FIXME restore after xunit will be fixed
+               sh 'RUST_TEST_THREADS=1 cargo test-xunit'
                 */
-            }
+           }
+           finally {
+               /* TODO FIXME restore after xunit will be fixed
+               junit 'test-results.xml'
+               */
+           }
         }
     }
     finally {
-        echo 'Ubuntu Test: Cleanup'
+        echo ""${env_name} Test: Cleanup""
         try {
             sh ""docker network inspect ${network_name}""
         } catch (ignore) {",,2017-07-21 13:27:16,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/127942173,https://github.com/hyperledger/indy-sdk/pull/84#discussion_r127942173,keenondrums
https://github.com/hyperledger/indy-sdk/pull/84,https://github.com/hyperledger/indy-sdk/pull/84,"Why do you need this if?
",89f4106b53c6e1467bd1567be46e5f765d38fc3e,2017-07-18 10:53:23,127942411,"@@ -51,66 +71,79 @@ try {
     }
 }
 
-def testUbuntu() {
+def testPipeline(file, env_name, run_interoperability_tests) {
     def poolInst
     def network_name = ""pool_network""
     try {
-        echo 'Ubuntu Test: Checkout csm'
+        echo ""${env_name} Test: Checkout csm""
         checkout scm
 
-        echo ""Ubuntu Test: Create docker network (${network_name}) for nodes pool and test image""
+        echo ""${env_name} Test: Create docker network (${network_name}) for nodes pool and test image""
         sh ""docker network create --subnet=10.0.0.0/8 ${network_name}""
 
-        echo 'Ubuntu Test: Build docker image for nodes pool'
+        echo ""${env_name} Test: Build docker image for nodes pool""
         def poolEnv = dockerHelpers.build('indy_pool', 'ci/indy-pool.dockerfile ci')
-        echo 'Ubuntu Test: Run nodes pool'
+        echo ""${env_name} Test: Run nodes pool""
         poolInst = poolEnv.run(""--ip=\""10.0.0.2\"" --network=${network_name}"")
 
-        echo 'Ubuntu Test: Build docker image'
-        def testEnv = dockerHelpers.build(name)
+        echo ""${env_name} Test: Build docker image""
+        def testEnv = dockerHelpers.build(name, file)
 
         testEnv.inside(""--ip=\""10.0.0.3\"" --network=${network_name}"") {
-            echo 'Ubuntu Test: Test'
-            sh 'chmod -R 777 /home/indy/'
-            sh 'cargo update'
-
-            try {
-                sh 'RUST_BACKTRACE=1 RUST_TEST_THREADS=1 cargo test --features ""interoperability_tests""'
-                /* TODO FIXME restore after xunit will be fixed
-                sh 'RUST_TEST_THREADS=1 cargo test-xunit'
-                 */
-            }
-            finally {
-                /* TODO FIXME restore after xunit will be fixed
-                junit 'test-results.xml'
+           echo ""${env_name} Test: Test""
+           sh 'chmod -R 777 /home/indy/'
+           sh 'cargo update'
+
+           try {
+                if (run_interoperability_tests) {
+                    sh 'RUST_BACKTRACE=1 RUST_TEST_THREADS=1 cargo test --features ""interoperability_tests""'
+                }
+                else {
+                    sh 'RUST_BACKTRACE=1 RUST_TEST_THREADS=1 cargo test'
+                }
+               /* TODO FIXME restore after xunit will be fixed
+               sh 'RUST_TEST_THREADS=1 cargo test-xunit'
                 */
-            }
+           }
+           finally {
+               /* TODO FIXME restore after xunit will be fixed
+               junit 'test-results.xml'
+               */
+           }
         }
     }
     finally {
-        echo 'Ubuntu Test: Cleanup'
+        echo ""${env_name} Test: Cleanup""
         try {
             sh ""docker network inspect ${network_name}""
         } catch (ignore) {
         }
         try {
             if (poolInst) {",,2017-07-21 13:27:16,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/127942411,https://github.com/hyperledger/indy-sdk/pull/84#discussion_r127942411,keenondrums
https://github.com/hyperledger/indy-sdk/pull/84,https://github.com/hyperledger/indy-sdk/pull/84,Seems we unnecessary install libsodium-devel as we compile it from sources later,89f4106b53c6e1467bd1567be46e5f765d38fc3e,2017-07-21 13:03:34,128756364,"@@ -6,15 +6,20 @@ RUN \
     yum clean all \
     && yum upgrade -y \
     && yum groupinstall -y ""Development Tools"" \
+    && yum install -y epel-release \
+    && yum-config-manager --enable epel \
     && yum install -y \
            wget \
            cmake \
            pkgconfig \
            openssl-devel \
-           sqlite-devel
+           sqlite-devel \
+           libsodium-devel \",,2017-07-21 13:27:16,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/128756364,https://github.com/hyperledger/indy-sdk/pull/84#discussion_r128756364,vimmerru
https://github.com/hyperledger/indy-sdk/pull/83,https://github.com/hyperledger/indy-sdk/pull/83,Looks like `claim_def_id ` is used in multiple places. Can we have a helper method for this?,d79396b8cb51556ea1fda75868893dec482aa326,2017-07-06 11:47:22,125877104,"@@ -199,9 +205,10 @@ impl IssuerCommandExecutor {
             .map_err(map_err_trace!())
             .map_err(|err| CommonError::InvalidStructure(format!(""Invalid claim_req_json: {}"", err.to_string())))?;
 
-        let claim_def_uuid = self.wallet_service.get(wallet_handle, &format!(""seq_no::{}"", &claim_req_json.claim_def_seq_no))?;
-        let claim_def_json = self.wallet_service.get(wallet_handle, &format!(""claim_definition::{}"", &claim_def_uuid))?;
-        let claim_def_private_json = self.wallet_service.get(wallet_handle, &format!(""claim_definition_private::{}"", &claim_def_uuid))?;
+        let claim_def_id = claim_req_json.issuer_did.clone() + "":"" + &claim_req_json.schema_seq_no.to_string();",,2017-07-07 07:55:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125877104,https://github.com/hyperledger/indy-sdk/pull/83#discussion_r125877104,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/83,https://github.com/hyperledger/indy-sdk/pull/83,"Can we move ISSUER_DID ""NcYxiDXkpYi6ov5FcYDi1e"" into a helper function?",d79396b8cb51556ea1fda75868893dec482aa326,2017-07-06 11:49:28,125877457,"@@ -497,7 +498,7 @@ mod tests {
         let signature_type = None;
         let create_non_revoc = false;
 
-        let result = issuer.generate_claim_definition(schema, signature_type, create_non_revoc);
+        let result = issuer.generate_claim_definition(""NcYxiDXkpYi6ov5FcYDi1e"", schema, signature_type, create_non_revoc);",,2017-07-07 07:55:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125877457,https://github.com/hyperledger/indy-sdk/pull/83#discussion_r125877457,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/83,https://github.com/hyperledger/indy-sdk/pull/83,Can we move ISSUER_DID NcYxiDXkpYi6ov5FcYDi1e into a helper method?,d79396b8cb51556ea1fda75868893dec482aa326,2017-07-06 11:50:54,125877671,"@@ -1543,61 +1549,64 @@ pub mod mocks {
 
     pub fn get_gvt_claim_info() -> ClaimInfo {
         let attrs = issuer::mocks::get_gvt_row_attributes();
-        ClaimInfo::new(""1"".to_string(), attrs, 1, None, 1, ""did"".to_string())
+        ClaimInfo::new(""1"".to_string(), attrs, None, 1, ""NcYxiDXkpYi6ov5FcYDi1e"".to_string())",,2017-07-07 07:55:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125877671,https://github.com/hyperledger/indy-sdk/pull/83#discussion_r125877671,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/83,https://github.com/hyperledger/indy-sdk/pull/83,I think we should not use `verifiableAttributes` term.,d79396b8cb51556ea1fda75868893dec482aa326,2017-07-06 11:56:33,125878608,"@@ -908,15 +910,20 @@ impl<'a> JsonDecodable<'a> for ProofClaimsJson {}
 #[derive(Debug, Deserialize, Serialize)]
 pub struct ProofRequestJson {
     pub nonce: BigNumber,
+    pub name: String,
+    pub version: String,
+    #[serde(rename = ""verifiableAttributes"")]",,2017-07-07 07:55:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125878608,https://github.com/hyperledger/indy-sdk/pull/83#discussion_r125878608,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/83,https://github.com/hyperledger/indy-sdk/pull/83,I think we should not use `verifiableAttributes` term.,d79396b8cb51556ea1fda75868893dec482aa326,2017-07-06 11:56:45,125878638,"@@ -413,7 +404,9 @@ mod high_cases {
             let (wallet_handle, _) = AnoncredsUtils::init_common_wallet();
 
             let proof_req = r#""{""nonce"":""123432421212"",
-                                ""requested_attrs"":{""attr1_uuid"":{""schema_seq_no"":1, ""name"":""name""}},
+                                ""name"":""proof_req_1"",
+                                ""version"":""0.1"",
+                                ""verifiableAttributes"":{""attr1_uuid"":{""schema_seq_no"":1, ""name"":""name""}},",,2017-07-07 07:55:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125878638,https://github.com/hyperledger/indy-sdk/pull/83#discussion_r125878638,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/83,https://github.com/hyperledger/indy-sdk/pull/83,Why do we rename this?,d79396b8cb51556ea1fda75868893dec482aa326,2017-07-06 11:59:01,125879008,"@@ -167,10 +166,12 @@ pub struct ClaimRequest {
 #[derive(Debug, Deserialize, Serialize)]
 pub struct ClaimJson {
     pub claim: HashMap<String, Vec<String>>,
-    pub claim_def_seq_no: i32,
     pub revoc_reg_seq_no: Option<i32>,
     pub schema_seq_no: i32,
-    pub signature: ClaimSignature
+    #[serde(rename = ""claims_signature"")]",,2017-07-07 07:55:48,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125879008,https://github.com/hyperledger/indy-sdk/pull/83#discussion_r125879008,ashcherbakov
https://github.com/hyperledger/indy-sdk/pull/81,https://github.com/hyperledger/indy-sdk/pull/81,"- [ ] Temporary fix, now should be reverted.",fc13169c7ed642a046eb552680b0ae1427c1eb90,2017-07-05 14:55:15,125666415,"@@ -1,17 +1,17 @@
 source 'https://github.com/CocoaPods/Specs.git'
-source 'https://github.com/hyperledger/indy-sdk.git'
+source 'https://github.com/jovfer/indy-sdk.git'",,2017-07-06 11:52:02,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125666415,https://github.com/hyperledger/indy-sdk/pull/81#discussion_r125666415,jovfer
https://github.com/hyperledger/indy-sdk/pull/81,https://github.com/hyperledger/indy-sdk/pull/81,"- [ ] also temporary, can be reverted to 3.0.0",fc13169c7ed642a046eb552680b0ae1427c1eb90,2017-07-05 14:56:12,125666732,"@@ -1,17 +1,17 @@
 source 'https://github.com/CocoaPods/Specs.git'
-source 'https://github.com/hyperledger/indy-sdk.git'
+source 'https://github.com/jovfer/indy-sdk.git'
 platform :ios, '10.2'
 
 workspace 'libsovrin.xcworkspace'
 
 #use_frameworks!
 
 def appPods
-    pod 'libsodium',""~> 1.0.12""
-    pod 'libzmq',""~> 4.2.3""
+    pod 'libsodium',""1.0.12""
+    pod 'libzmq-pw',""4.2.2""
     pod 'OpenSSL'
-    pod 'milagro'
-    pod 'libsovrin-core'
+    pod 'milagro', ""3.0.1""",,2017-07-06 11:52:02,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125666732,https://github.com/hyperledger/indy-sdk/pull/81#discussion_r125666732,jovfer
https://github.com/hyperledger/indy-sdk/pull/81,https://github.com/hyperledger/indy-sdk/pull/81,- [ ] new libsovrin core pod will be 0.1.1 (same as libsovrin crate),fc13169c7ed642a046eb552680b0ae1427c1eb90,2017-07-05 14:56:59,125666955,"@@ -1,17 +1,17 @@
 source 'https://github.com/CocoaPods/Specs.git'
-source 'https://github.com/hyperledger/indy-sdk.git'
+source 'https://github.com/jovfer/indy-sdk.git'
 platform :ios, '10.2'
 
 workspace 'libsovrin.xcworkspace'
 
 #use_frameworks!
 
 def appPods
-    pod 'libsodium',""~> 1.0.12""
-    pod 'libzmq',""~> 4.2.3""
+    pod 'libsodium',""1.0.12""
+    pod 'libzmq-pw',""4.2.2""
     pod 'OpenSSL'
-    pod 'milagro'
-    pod 'libsovrin-core'
+    pod 'milagro', ""3.0.1""
+    pod 'libsovrin-core', ""0.0.3""",,2017-07-06 11:52:02,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125666955,https://github.com/hyperledger/indy-sdk/pull/81#discussion_r125666955,jovfer
https://github.com/hyperledger/indy-sdk/pull/81,https://github.com/hyperledger/indy-sdk/pull/81,- [ ] do not use 97xx port in iOS test.,fc13169c7ed642a046eb552680b0ae1427c1eb90,2017-07-05 14:59:25,125667740,"@@ -300,7 +328,210 @@ - (void)testAgentListenWorksForAllDataInWalletPresent
     [TestUtils cleanupStorage];
 }
 
-// MARK: - Agent seed
+// MARK: - Add identity
+
+- (void)testAgentAddIdentityWorks
+{
+    [TestUtils cleanupStorage];
+    NSError *ret;
+    NSString *endpoint = @""127.0.0.1:9711"";",,2017-07-06 11:52:02,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125667740,https://github.com/hyperledger/indy-sdk/pull/81#discussion_r125667740,jovfer
https://github.com/hyperledger/indy-sdk/pull/81,https://github.com/hyperledger/indy-sdk/pull/81,- [ ] change port to 98xx,fc13169c7ed642a046eb552680b0ae1427c1eb90,2017-07-05 15:07:59,125670346,"@@ -300,7 +328,210 @@ - (void)testAgentListenWorksForAllDataInWalletPresent
     [TestUtils cleanupStorage];
 }
 
-// MARK: - Agent seed
+// MARK: - Add identity
+
+- (void)testAgentAddIdentityWorks
+{
+    [TestUtils cleanupStorage];
+    NSError *ret;
+    NSString *endpoint = @""127.0.0.1:9711"";
+    
+    // 1. Create and open receiver's wallet
+    SovrinHandle receiverWallet = 0;
+    ret = [[WalletUtils sharedInstance] createAndOpenWalletWithPoolName:@""ignore""
+                                                             walletName:@""wallet11receiver""
+                                                                  xtype:@""default""
+                                                                 handle:&receiverWallet];
+     XCTAssertEqual(ret.code, Success, @""WalletUtils::createAndOpenWalletWithPoolName() failed for receiverWallet"");
+    
+    // 2. listen
+    SovrinHandle listenerHandle = 0;
+    ret = [[AgentUtils sharedInstance] listenForEndpoint:endpoint
+                                       connectionCallback:nil
+                                          messageCallback:nil
+                                        outListenerHandle:&listenerHandle];
+    XCTAssertEqual(ret.code, Success, @""AgentUtils::listenWithEndpoint() failed"");
+    
+    // 3. Create and store receiver's did
+    NSString *receiverDid;
+    NSString *receiverVerkey;
+    NSString *receiverPk;
+    ret = [[SignusUtils sharedInstance] createAndStoreMyDidWithWalletHandle:receiverWallet
+                                                                       seed:nil
+                                                                   outMyDid:&receiverDid
+                                                                outMyVerkey:&receiverVerkey
+                                                                    outMyPk:&receiverPk];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::createAndStoreMyDidWithWalletHandle() failed for receiverDid"");
+    
+    
+    // 4. Add identity
+    ret = [[AgentUtils sharedInstance] addIdentityForListenerHandle:listenerHandle
+                                                         poolHandle:-1
+                                                       walletHandle:receiverWallet
+                                                                did:receiverDid];
+    XCTAssertEqual(ret.code, Success, @""AgentUtils::addIdentityForListenerHandle() failed"");
+    
+    ret = [[SignusUtils sharedInstance] storeTheirDidFromPartsWithWalletHandle:receiverWallet
+                                                                      theirDid:receiverDid
+                                                                       theirPk:receiverPk
+                                                                   theirVerkey:receiverVerkey
+                                                                      endpoint:endpoint];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::storeTheirDidFromPartsWithWalletHandle() failed"");
+    
+    // TODO: There is some zmq for sockets involved for clean test.
+    SovrinHandle connectionHandle = 0;
+    ret = [[AgentUtils sharedInstance] connectWithPoolHandle:-1
+                                                walletHandle:receiverWallet
+                                                   senderDid:receiverDid
+                                                 receiverDid:receiverDid
+                                             messageCallback:nil
+                                         outConnectionHandle:&connectionHandle];
+    XCTAssertEqual(ret.code, Success, @""AgentUtils::connectWithPoolHandle() failed"");
+    
+    
+    [TestUtils cleanupStorage];
+}
+
+- (void)testAgentAddIdentityWorksForMultipleKeys
+{
+    [TestUtils cleanupStorage];
+    NSError *ret;
+    NSString *endpoint = @""127.0.0.1:9811"";
+    
+    // 1. Create and open receiver's wallet
+    SovrinHandle receiverWallet = 0;
+    ret = [[WalletUtils sharedInstance] createAndOpenWalletWithPoolName:@""ignore""
+                                                             walletName:@""wallet14receiver""
+                                                                  xtype:@""default""
+                                                                 handle:&receiverWallet];
+    XCTAssertEqual(ret.code, Success, @""WalletUtils::createAndOpenWalletWithPoolName() failed for receiverWallet"");
+    
+    // 2. listen
+    SovrinHandle listenerHandle = 0;
+    ret = [[AgentUtils sharedInstance] listenForEndpoint:endpoint
+                                       connectionCallback:nil
+                                          messageCallback:nil
+                                        outListenerHandle:&listenerHandle];
+    XCTAssertEqual(ret.code, Success, @""AgentUtils::listenWithEndpoint() failed"");
+    
+    // 3. Create and store receiver DID 1
+    NSString *receiverDid1;
+    NSString *receiverVerkey1;
+    NSString *receiverPk1;
+    ret = [[SignusUtils sharedInstance] createAndStoreMyDidWithWalletHandle:receiverWallet
+                                                                       seed:nil
+                                                                   outMyDid:&receiverDid1
+                                                                outMyVerkey:&receiverVerkey1
+                                                                    outMyPk:&receiverPk1];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::createAndStoreMyDidWithWalletHandle() failed for receiverDid 1"");
+    
+    // 4. Create and store receiver DID 2
+    NSString *receiverDid2;
+    NSString *receiverVerkey2;
+    NSString *receiverPk2;
+    ret = [[SignusUtils sharedInstance] createAndStoreMyDidWithWalletHandle:receiverWallet
+                                                                       seed:nil
+                                                                   outMyDid:&receiverDid2
+                                                                outMyVerkey:&receiverVerkey2
+                                                                    outMyPk:&receiverPk2];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::createAndStoreMyDidWithWalletHandle() failed for receiverDid 2"");
+    
+    // TODO: In Rust there is socket code.
+    
+    // 5. Add identities
+    NSMutableArray *receiverDids = [NSMutableArray new];
+    [receiverDids addObject:receiverDid1];
+    [receiverDids addObject:receiverDid2];
+    
+    for (NSString *did in receiverDids)
+    {
+        ret = [[AgentUtils sharedInstance] addIdentityForListenerHandle:listenerHandle
+                                                             poolHandle:-1
+                                                           walletHandle:receiverWallet
+                                                                    did:did];
+        XCTAssertEqual(ret.code, Success, @""AgentUtils::addIdentityForListenerHandle() failed for DID: %@"", did);
+    }
+    
+    ret = [[SignusUtils sharedInstance] storeTheirDidFromPartsWithWalletHandle:receiverWallet
+                                                                      theirDid:receiverDid1
+                                                                       theirPk:receiverPk1
+                                                                   theirVerkey:receiverVerkey1
+                                                                      endpoint:endpoint];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::storeTheirDidFromPartsWithWalletHandle() failed"");
+    
+    ret = [[SignusUtils sharedInstance] storeTheirDidFromPartsWithWalletHandle:receiverWallet
+                                                                      theirDid:receiverDid2
+                                                                       theirPk:receiverPk2
+                                                                   theirVerkey:receiverVerkey2
+                                                                      endpoint:endpoint];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::storeTheirDidFromPartsWithWalletHandle() failed"");
+    
+    // 6. Connect with DID 1
+    ret = [[AgentUtils sharedInstance] connectWithPoolHandle:-1
+                                                walletHandle:receiverWallet
+                                                   senderDid:receiverDid1
+                                                 receiverDid:receiverDid1
+                                             messageCallback:nil
+                                         outConnectionHandle:nil];
+     XCTAssertEqual(ret.code, Success, @""AgentUtils::connectWithPoolHandle() failed for DID 1"");
+    
+     // 6. Connect with DID 2
+    ret = [[AgentUtils sharedInstance] connectWithPoolHandle:-1
+                                                walletHandle:receiverWallet
+                                                   senderDid:receiverDid2
+                                                 receiverDid:receiverDid2
+                                             messageCallback:nil
+                                         outConnectionHandle:nil];
+    XCTAssertEqual(ret.code, Success, @""AgentUtils::connectWithPoolHandle() failed for DID 2"");
+    
+    [TestUtils cleanupStorage];
+}
+
+// MARK: - Remove identity
+
+-(void)testAgentRemoveIdentityWorks
+{
+    [TestUtils cleanupStorage];
+    NSString *endpoint = @""127.0.0.1:9713"";",,2017-07-06 11:52:02,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125670346,https://github.com/hyperledger/indy-sdk/pull/81#discussion_r125670346,jovfer
https://github.com/hyperledger/indy-sdk/pull/81,https://github.com/hyperledger/indy-sdk/pull/81,- [ ] change port to 98xx,fc13169c7ed642a046eb552680b0ae1427c1eb90,2017-07-05 15:08:41,125670655,"@@ -429,22 +671,29 @@ - (void)testAgentCloseConnectionWorksForOngoing
     
     // 3. listen
     NSString *endpoint = @""127.0.0.1:9705"";",,2017-07-06 11:52:02,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125670655,https://github.com/hyperledger/indy-sdk/pull/81#discussion_r125670655,jovfer
https://github.com/hyperledger/indy-sdk/pull/81,https://github.com/hyperledger/indy-sdk/pull/81,- [ ] change port to 98xx,fc13169c7ed642a046eb552680b0ae1427c1eb90,2017-07-05 15:09:07,125670789,"@@ -34,4 +29,310 @@ - (void)tearDown
     [super tearDown];
 }
 
+// MARK: - Add identity
+- (void)testAgentAddIdentityWorksForIncomingConnectionRequireLedgerRequestButPoolHandleIsInvalid
+{
+    [TestUtils cleanupStorage];
+    NSError *ret;
+    NSString *endpoint = @""127.0.0.1:9712"";",,2017-07-06 11:52:02,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125670789,https://github.com/hyperledger/indy-sdk/pull/81#discussion_r125670789,jovfer
https://github.com/hyperledger/indy-sdk/pull/81,https://github.com/hyperledger/indy-sdk/pull/81,- [ ] change port to 98xx,fc13169c7ed642a046eb552680b0ae1427c1eb90,2017-07-05 15:09:24,125670897,"@@ -34,4 +29,310 @@ - (void)tearDown
     [super tearDown];
 }
 
+// MARK: - Add identity
+- (void)testAgentAddIdentityWorksForIncomingConnectionRequireLedgerRequestButPoolHandleIsInvalid
+{
+    [TestUtils cleanupStorage];
+    NSError *ret;
+    NSString *endpoint = @""127.0.0.1:9712"";
+    NSString *xtype = @""default"";
+    NSString *poolName = @""sovrin_agent_add_identity_works_for_incoming_connection_require_ledger_request_but_pool_handle_is_invalid"";
+    
+    // 1. Obtain pool handle
+    SovrinHandle poolHandle = 0;
+    ret = [[PoolUtils sharedInstance] createAndOpenPoolLedgerConfigWithName:poolName
+                                                                 poolHandle:&poolHandle];
+    XCTAssertEqual(ret.code, Success, @""PoolUtils::createAndOpenPoolLedgerConfigWithName() failed"");
+    
+    // 2. Obtain listener's wallet
+    SovrinHandle listenerWalletHandle = 0;
+    ret = [[WalletUtils sharedInstance] createAndOpenWalletWithPoolName:poolName
+                                                             walletName:@""wallet12.1""
+                                                                  xtype:xtype
+                                                                 handle:&listenerWalletHandle];
+    XCTAssertEqual(ret.code, Success, @""PoolUtils::createAndOpenWalletWithPoolName() failed"");
+    
+    // 3. Obtain trustee's wallet
+    SovrinHandle trusteeWalletHandle = 0;
+    ret = [[WalletUtils sharedInstance] createAndOpenWalletWithPoolName:poolName
+                                                             walletName:@""wallet12.2""
+                                                                  xtype:xtype
+                                                                 handle:&trusteeWalletHandle];
+    XCTAssertEqual(ret.code, Success, @""PoolUtils::createAndOpenWalletWithPoolName() failed"");
+    
+    // 4. Create and store listener's did
+    NSString *listenerDid;
+    NSString *listenerVerKey;
+    NSString *listenerPubKey;
+    ret = [[SignusUtils sharedInstance] createAndStoreMyDidWithWalletHandle:listenerWalletHandle
+                                                                       seed:nil
+                                                                   outMyDid:&listenerDid
+                                                                outMyVerkey:&listenerVerKey
+                                                                    outMyPk:&listenerPubKey];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::createAndStoreMyDidWithWalletHandle() failed"");
+    
+    // 5. create trustee did
+    
+    NSString *trusteeDid;
+    NSString *trusteeDidJson = @""{\""seed\"":\""000000000000000000000000Trustee1\"",\""cid\"":true}"";
+    ret = [[SignusUtils sharedInstance] createMyDidWithWalletHandle:trusteeWalletHandle
+                                                          myDidJson:trusteeDidJson
+                                                           outMyDid:&trusteeDid
+                                                        outMyVerkey:nil
+                                                            outMyPk:nil];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::createMyDidWithWalletHandle() failed"");
+    
+    // 6. Build nym request for listener
+    NSString *listenerNymRequest;
+    ret = [[LedgerUtils sharedInstance] buildNymRequestWithSubmitterDid:trusteeDid
+                                                              targetDid:listenerDid
+                                                                 verkey:listenerVerKey
+                                                                  alias:nil
+                                                                   role:nil
+                                                             outRequest:&listenerNymRequest];
+     XCTAssertEqual(ret.code, Success, @""LedgerUtils::buildNymRequestWithSubmitterDid() failed"");
+    
+    // 7. Sign and submit listener's nym request
+    NSString *listenerNymResponse;
+    ret = [[LedgerUtils sharedInstance] signAndSubmitRequestWithPoolHandle:poolHandle
+                                                              walletHandle:trusteeWalletHandle
+                                                              submitterDid:trusteeDid
+                                                               requestJson:listenerNymRequest
+                                                           outResponseJson:&listenerNymResponse];
+    XCTAssertEqual(ret.code, Success, @""LedgerUtils::signAndSubmitRequestWithPoolHandle() failed for listenerNymRequest"");
+    
+    // 8. Build listener attribute request
+    NSString *rawJson =[NSString stringWithFormat:@""{\""endpoint\"":{\""ha\"":\""%@\"", \""verkey\"":\""%@\""}}"", endpoint, listenerPubKey];
+    NSString *listenerAttributeRequest;
+    ret = [[LedgerUtils sharedInstance] buildAttribRequestWithSubmitterDid:listenerDid
+                                                                                                targetDid:listenerDid
+                                                                                                     hash:nil
+                                                                                                      raw:rawJson
+                                                                                                      enc:nil
+                                                                resultJson:&listenerAttributeRequest];
+     XCTAssertEqual(ret.code, Success, @""LedgerUtils::buildAttribRequestWithSubmitterDid() failed"");
+    
+    // 9. Sign and submit listener's attribute request
+    NSString *listenerAttributeResponse;
+    ret = [[LedgerUtils sharedInstance] signAndSubmitRequestWithPoolHandle:poolHandle
+                                                              walletHandle:listenerWalletHandle
+                                                              submitterDid:listenerDid
+                                                               requestJson:listenerAttributeRequest
+                                                           outResponseJson:&listenerAttributeResponse];
+    XCTAssertEqual(ret.code, Success, @""LedgerUtils::buildAttribRequestWithSubmitterDid() failed for listenerAttributeResponse"");
+    
+    // 10. listen
+    SovrinHandle listenerHandle = 0;
+    ret = [[AgentUtils sharedInstance] listenForEndpoint:endpoint
+                                       connectionCallback:nil
+                                          messageCallback:nil
+                                        outListenerHandle:&listenerHandle];
+    XCTAssertEqual(ret.code, Success, @""LedgerUtils::listenWithEndpoint()"");
+    
+    // 11. Add identity
+    SovrinHandle invalidPoolHandle = listenerHandle;
+    ret = [[AgentUtils sharedInstance] addIdentityForListenerHandle:listenerHandle
+                                                         poolHandle:invalidPoolHandle
+                                                       walletHandle:listenerWalletHandle
+                                                                did:listenerDid];
+    XCTAssertEqual(ret.code, Success, @""LedgerUtils::addIdentityForListenerHandle() failed for listenerDid"");
+    
+    /* TODO
+     * Currently pool_handle and wallet_handle of add_identity will be checked only at required:
+     * when listener will check incoming connection and go to ledger for info.
+     * As result, add_identity will be successful but next connect will fail.
+     * Possible the test should be split into two:
+     * - add_identity_works_for_incompatible_pool_and_wallet
+     *    with immediately check in the library
+     * - connect_works_for_incorrect_connect_request
+     *    actual info in ledger or listener_wallet, wrong public key in sender_wallet
+     */
+    
+    // 12. Connect
+    NSString *senderDid = [NSString stringWithString:trusteeDid];
+    SovrinHandle senderWalletHandle = trusteeWalletHandle;
+    
+    ret = [[AgentUtils sharedInstance] connectWithPoolHandle:poolHandle
+                                                walletHandle:senderWalletHandle
+                                                   senderDid:senderDid
+                                                 receiverDid:listenerDid
+                                             messageCallback:nil
+                                         outConnectionHandle:nil];
+    XCTAssertEqual(ret.code, CommonInvalidState, @""AgentUtils::connectWithPoolHandle() returned wrong code"");
+    [TestUtils cleanupStorage];
+}
+
+// MARK: - Close connection
+
+- (void)testAgentCloseConnectionWorksForIncorrectConnectionHandle
+{
+    [TestUtils cleanupStorage];
+    NSError *ret;
+    
+    // 1. create and open wallet handle
+    SovrinHandle walletHandle = 0;
+    ret = [[WalletUtils sharedInstance] createAndOpenWalletWithPoolName:@""pool6""
+                                                             walletName:@""wallet6""
+                                                                  xtype:@""default""
+                                                                 handle:&walletHandle];
+    XCTAssertEqual(ret.code, Success, @""WalletUtils::createAndOpenWalletWithPoolName() failed"");
+    
+    // 2. obtain did
+    NSString *did;
+    NSString *verKey;
+    NSString *pubKey;
+    ret = [[SignusUtils sharedInstance] createAndStoreMyDidWithWalletHandle:walletHandle
+                                                                       seed:nil
+                                                                   outMyDid:&did
+                                                                outMyVerkey:&verKey
+                                                                    outMyPk:&pubKey];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::createAndStoreMyDidWithWalletHandle() failed"");
+    
+    // 3. listen
+    NSString *endpoint = @""127.0.0.1:9707"";
+    
+    XCTestExpectation* messageExpectation = [[ XCTestExpectation alloc] initWithDescription: @""message completion finished""];
+    
+    SovrinHandle listenerHandler = 0;
+    __block NSString* messageFromClient;
+    ret = [[AgentUtils sharedInstance] listenForEndpoint:endpoint
+                                       connectionCallback:nil
+                                          messageCallback:^(SovrinHandle connectionHandle, NSString *message)
+    {
+        messageFromClient = message;
+        [messageExpectation fulfill];
+    }
+                                        outListenerHandle:&listenerHandler];
+    XCTAssertEqual(ret.code, Success, @""AgentUtils::listenWithEndpoint() failed"");
+
+    // 4. add identity
+    ret = [[AgentUtils sharedInstance] addIdentityForListenerHandle:listenerHandler
+                                                         poolHandle:-1
+                                                       walletHandle:walletHandle
+                                                                did:did];
+    XCTAssertEqual(ret.code, Success, @""AgentUtils::addIdentityForListenerHandle() failed"");
+    
+    // 5. store their did from parts
+    ret = [[SignusUtils sharedInstance] storeTheirDidFromPartsWithWalletHandle:walletHandle
+                                                                      theirDid:did
+                                                                       theirPk:pubKey
+                                                                   theirVerkey:verKey
+                                                                      endpoint:endpoint];
+    XCTAssertEqual(ret.code, Success, @""AgentUtils::storeTheirDidFromPartsWithWalletHandle() failed"");
+    
+    // 6. Connect
+    SovrinHandle connectionHandle = 0;
+    ret = [[AgentUtils sharedInstance] connectWithPoolHandle:0
+                                                walletHandle:walletHandle
+                                                   senderDid:did
+                                                 receiverDid:did
+                                             messageCallback:nil
+                                         outConnectionHandle:&connectionHandle];
+    XCTAssertEqual(ret.code, Success, @""AgentUtils::connectWithPoolHandle() failed"");
+    
+    // 7. Close connection
+    ret = [[AgentUtils sharedInstance] closeConnection:connectionHandle + 100];
+    XCTAssertEqual(ret.code, CommonInvalidStructure, @""AgentUtils::closeConnection() returned wrong code"");
+    
+    // 8. send
+    NSString *clientMessage = @""msg_from_cli_to_srv"";
+    ret = [[AgentUtils sharedInstance] sendWithConnectionHandler:connectionHandle
+                                                         message:clientMessage];
+    XCTAssertEqual(ret.code, Success, @""AgentUtils::sendWithConnectionHandler() failed"");
+    
+    // 9. wait for message callback
+    [self waitForExpectations: @[messageExpectation] timeout:[TestUtils defaultTimeout]];
+    
+    XCTAssertTrue([messageFromClient isEqualToString:clientMessage], @""wrong message from client!"");
+    
+    [TestUtils cleanupStorage];
+}
+
+// MARK: - Close listener
+
+- (void)testAgentCloseListenerWorksForIncorrectHandle
+{
+    [TestUtils cleanupStorage];
+    NSError *ret;
+    
+    // 1.Create and open wallet
+    SovrinHandle walletHandle;
+    ret = [[WalletUtils sharedInstance] createAndOpenWalletWithPoolName:@""pool9""
+                                                             walletName:@""wallet9""
+                                                                  xtype:@""default""
+                                                                 handle:&walletHandle];
+     XCTAssertEqual(ret.code, Success, @""WalletUtils::createAndOpenWalletWithPoolName() failed"");
+    
+    // 2. obtain did
+    NSString *did;
+    NSString *verKey;
+    NSString *pubKey;
+    ret = [[SignusUtils sharedInstance] createAndStoreMyDidWithWalletHandle:walletHandle
+                                                                       seed:nil
+                                                                   outMyDid:&did
+                                                                outMyVerkey:&verKey
+                                                                    outMyPk:&pubKey];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::createAndStoreMyDidWithWalletHandle() failed"");
+    
+    // 3. listen
+    NSString *endpoint = @""127.0.0.1:9709"";",,2017-07-06 11:52:02,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125670897,https://github.com/hyperledger/indy-sdk/pull/81#discussion_r125670897,jovfer
https://github.com/hyperledger/indy-sdk/pull/81,https://github.com/hyperledger/indy-sdk/pull/81,- [ ] remove temporary bunch or make it more concrete and rename.,fc13169c7ed642a046eb552680b0ae1427c1eb90,2017-07-05 15:10:57,125671385,"@@ -323,7 +323,14 @@ - (void)testDeletePoolLedgerConfigWorksForOpened
     // 2. delete
     ret = [[PoolUtils sharedInstance] deletePoolWithName:poolName];
     XCTAssertEqual(ret.code, CommonInvalidState, @""PoolUtils::deletePoolWithName() returned wrong code!"");
+    
     [TestUtils cleanupStorage];
+}
+
+- (void)testBunch",,2017-07-06 11:52:02,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125671385,https://github.com/hyperledger/indy-sdk/pull/81#discussion_r125671385,jovfer
https://github.com/hyperledger/indy-sdk/pull/81,https://github.com/hyperledger/indy-sdk/pull/81,- [ ] remove if this code actually not needed,fc13169c7ed642a046eb552680b0ae1427c1eb90,2017-07-05 15:13:18,125672077,"@@ -147,15 +147,15 @@ - (NSError *)buildAttribRequestWithSubmitterDid:(NSString *)submitterDid
     __block NSString *outJson = nil;
     NSError *ret;
     
-    NSString* hashStr = (hash) ? hash : @"""";
-    NSString* rawStr = (raw) ? raw : @"""";
-    NSString* encStr = (enc) ? enc : @"""";
+    //NSString* hashStr = (hash) ? hash : @"""";",,2017-07-06 11:52:02,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125672077,https://github.com/hyperledger/indy-sdk/pull/81#discussion_r125672077,jovfer
https://github.com/hyperledger/indy-sdk/pull/81,https://github.com/hyperledger/indy-sdk/pull/81,- [ ] remove call is missed?,fc13169c7ed642a046eb552680b0ae1427c1eb90,2017-07-05 16:15:02,125690099,"@@ -300,7 +328,210 @@ - (void)testAgentListenWorksForAllDataInWalletPresent
     [TestUtils cleanupStorage];
 }
 
-// MARK: - Agent seed
+// MARK: - Add identity
+
+- (void)testAgentAddIdentityWorks
+{
+    [TestUtils cleanupStorage];
+    NSError *ret;
+    NSString *endpoint = @""127.0.0.1:9811"";
+    
+    // 1. Create and open receiver's wallet
+    SovrinHandle receiverWallet = 0;
+    ret = [[WalletUtils sharedInstance] createAndOpenWalletWithPoolName:@""ignore""
+                                                             walletName:@""wallet11receiver""
+                                                                  xtype:@""default""
+                                                                 handle:&receiverWallet];
+     XCTAssertEqual(ret.code, Success, @""WalletUtils::createAndOpenWalletWithPoolName() failed for receiverWallet"");
+    
+    // 2. listen
+    SovrinHandle listenerHandle = 0;
+    ret = [[AgentUtils sharedInstance] listenForEndpoint:endpoint
+                                       connectionCallback:nil
+                                          messageCallback:nil
+                                        outListenerHandle:&listenerHandle];
+    XCTAssertEqual(ret.code, Success, @""AgentUtils::listenWithEndpoint() failed"");
+    
+    // 3. Create and store receiver's did
+    NSString *receiverDid;
+    NSString *receiverVerkey;
+    NSString *receiverPk;
+    ret = [[SignusUtils sharedInstance] createAndStoreMyDidWithWalletHandle:receiverWallet
+                                                                       seed:nil
+                                                                   outMyDid:&receiverDid
+                                                                outMyVerkey:&receiverVerkey
+                                                                    outMyPk:&receiverPk];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::createAndStoreMyDidWithWalletHandle() failed for receiverDid"");
+    
+    
+    // 4. Add identity
+    ret = [[AgentUtils sharedInstance] addIdentityForListenerHandle:listenerHandle
+                                                         poolHandle:-1
+                                                       walletHandle:receiverWallet
+                                                                did:receiverDid];
+    XCTAssertEqual(ret.code, Success, @""AgentUtils::addIdentityForListenerHandle() failed"");
+    
+    ret = [[SignusUtils sharedInstance] storeTheirDidFromPartsWithWalletHandle:receiverWallet
+                                                                      theirDid:receiverDid
+                                                                       theirPk:receiverPk
+                                                                   theirVerkey:receiverVerkey
+                                                                      endpoint:endpoint];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::storeTheirDidFromPartsWithWalletHandle() failed"");
+    
+    // TODO: There is some zmq for sockets involved for clean test.
+    SovrinHandle connectionHandle = 0;
+    ret = [[AgentUtils sharedInstance] connectWithPoolHandle:-1
+                                                walletHandle:receiverWallet
+                                                   senderDid:receiverDid
+                                                 receiverDid:receiverDid
+                                             messageCallback:nil
+                                         outConnectionHandle:&connectionHandle];
+    XCTAssertEqual(ret.code, Success, @""AgentUtils::connectWithPoolHandle() failed"");
+    
+    
+    [TestUtils cleanupStorage];
+}
+
+- (void)testAgentAddIdentityWorksForMultipleKeys
+{
+    [TestUtils cleanupStorage];
+    NSError *ret;
+    NSString *endpoint = @""127.0.0.1:9811"";
+    
+    // 1. Create and open receiver's wallet
+    SovrinHandle receiverWallet = 0;
+    ret = [[WalletUtils sharedInstance] createAndOpenWalletWithPoolName:@""ignore""
+                                                             walletName:@""wallet14receiver""
+                                                                  xtype:@""default""
+                                                                 handle:&receiverWallet];
+    XCTAssertEqual(ret.code, Success, @""WalletUtils::createAndOpenWalletWithPoolName() failed for receiverWallet"");
+    
+    // 2. listen
+    SovrinHandle listenerHandle = 0;
+    ret = [[AgentUtils sharedInstance] listenForEndpoint:endpoint
+                                       connectionCallback:nil
+                                          messageCallback:nil
+                                        outListenerHandle:&listenerHandle];
+    XCTAssertEqual(ret.code, Success, @""AgentUtils::listenWithEndpoint() failed"");
+    
+    // 3. Create and store receiver DID 1
+    NSString *receiverDid1;
+    NSString *receiverVerkey1;
+    NSString *receiverPk1;
+    ret = [[SignusUtils sharedInstance] createAndStoreMyDidWithWalletHandle:receiverWallet
+                                                                       seed:nil
+                                                                   outMyDid:&receiverDid1
+                                                                outMyVerkey:&receiverVerkey1
+                                                                    outMyPk:&receiverPk1];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::createAndStoreMyDidWithWalletHandle() failed for receiverDid 1"");
+    
+    // 4. Create and store receiver DID 2
+    NSString *receiverDid2;
+    NSString *receiverVerkey2;
+    NSString *receiverPk2;
+    ret = [[SignusUtils sharedInstance] createAndStoreMyDidWithWalletHandle:receiverWallet
+                                                                       seed:nil
+                                                                   outMyDid:&receiverDid2
+                                                                outMyVerkey:&receiverVerkey2
+                                                                    outMyPk:&receiverPk2];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::createAndStoreMyDidWithWalletHandle() failed for receiverDid 2"");
+    
+    // TODO: In Rust there is socket code.
+    
+    // 5. Add identities
+    NSMutableArray *receiverDids = [NSMutableArray new];
+    [receiverDids addObject:receiverDid1];
+    [receiverDids addObject:receiverDid2];
+    
+    for (NSString *did in receiverDids)
+    {
+        ret = [[AgentUtils sharedInstance] addIdentityForListenerHandle:listenerHandle
+                                                             poolHandle:-1
+                                                           walletHandle:receiverWallet
+                                                                    did:did];
+        XCTAssertEqual(ret.code, Success, @""AgentUtils::addIdentityForListenerHandle() failed for DID: %@"", did);
+    }
+    
+    ret = [[SignusUtils sharedInstance] storeTheirDidFromPartsWithWalletHandle:receiverWallet
+                                                                      theirDid:receiverDid1
+                                                                       theirPk:receiverPk1
+                                                                   theirVerkey:receiverVerkey1
+                                                                      endpoint:endpoint];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::storeTheirDidFromPartsWithWalletHandle() failed"");
+    
+    ret = [[SignusUtils sharedInstance] storeTheirDidFromPartsWithWalletHandle:receiverWallet
+                                                                      theirDid:receiverDid2
+                                                                       theirPk:receiverPk2
+                                                                   theirVerkey:receiverVerkey2
+                                                                      endpoint:endpoint];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::storeTheirDidFromPartsWithWalletHandle() failed"");
+    
+    // 6. Connect with DID 1
+    ret = [[AgentUtils sharedInstance] connectWithPoolHandle:-1
+                                                walletHandle:receiverWallet
+                                                   senderDid:receiverDid1
+                                                 receiverDid:receiverDid1
+                                             messageCallback:nil
+                                         outConnectionHandle:nil];
+     XCTAssertEqual(ret.code, Success, @""AgentUtils::connectWithPoolHandle() failed for DID 1"");
+    
+     // 6. Connect with DID 2
+    ret = [[AgentUtils sharedInstance] connectWithPoolHandle:-1
+                                                walletHandle:receiverWallet
+                                                   senderDid:receiverDid2
+                                                 receiverDid:receiverDid2
+                                             messageCallback:nil
+                                         outConnectionHandle:nil];
+    XCTAssertEqual(ret.code, Success, @""AgentUtils::connectWithPoolHandle() failed for DID 2"");
+    
+    [TestUtils cleanupStorage];
+}
+
+// MARK: - Remove identity
+
+-(void)testAgentRemoveIdentityWorks
+{
+    [TestUtils cleanupStorage];
+    NSString *endpoint = @""127.0.0.1:9813"";
+    NSError *ret;
+    
+    // 1. Obtain receiver's wallet handle
+    SovrinHandle receiverWalletHandle = 0;
+    ret = [[WalletUtils sharedInstance] createAndOpenWalletWithPoolName:@""ignore""
+                                                             walletName:@""wallet13receiver""
+                                                                  xtype:@""default""
+                                                                 handle:&receiverWalletHandle];
+    XCTAssertEqual(ret.code, Success, @""WalletUtils::createAndOpenWalletWithPoolName() failed"");
+    
+    // 2. Listen
+    SovrinHandle listenerHandle = 0;
+    ret = [[AgentUtils sharedInstance] listenForEndpoint:endpoint
+                                       connectionCallback:nil messageCallback:nil outListenerHandle:&listenerHandle];
+    XCTAssertEqual(ret.code, Success, @""AgentUtils::listenWithEndpoint() failed"");
+    
+    // 3. Create and store receiver's DID
+    NSString *receiverDid;
+    NSString *receiverPk;
+    ret = [[SignusUtils sharedInstance] createAndStoreMyDidWithWalletHandle:receiverWalletHandle
+                                                                       seed:nil
+                                                                   outMyDid:&receiverDid
+                                                                outMyVerkey:nil
+                                                                    outMyPk:&receiverPk];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::createAndStoreMyDidWithWalletHandle() failed for receiverDid 2"");
+    
+    // 4. Add identity
+    ret = [[AgentUtils sharedInstance] addIdentityForListenerHandle:listenerHandle
+                                                         poolHandle:-1
+                                                       walletHandle:receiverWalletHandle
+                                                                did:receiverDid];
+    XCTAssertEqual(ret.code, Success, @""SignusUtils::createAndStoreMyDidWithWalletHandle() failed for receiverDid 2"");
+    
+    ",,2017-07-06 11:52:02,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125690099,https://github.com/hyperledger/indy-sdk/pull/81#discussion_r125690099,jovfer
https://github.com/hyperledger/indy-sdk/pull/77,https://github.com/hyperledger/indy-sdk/pull/77,change to `sovrin_i32_t data`,4d47f92c36e19023d8995e0a857930fe35c4090e,2017-07-06 13:18:28,125895866,"@@ -323,6 +323,30 @@ extern ""C"" {
                                                                          sovrin_error_t  err,
                                                                          const char*     request_json)
                                                    );
+
+
+    /// Builds a GET_TXN request.
+    ///
+    /// #Params
+    /// command_handle: command handle to map callback to caller context.
+    /// submitter_did: Id of Identity stored in secured Wallet.
+    /// data: seq_no of transaction in ledger
+    /// cb: Callback that takes command result as parameter.
+    ///
+    /// #Returns
+    /// Request result as json.
+    ///
+    /// #Errors
+    /// Common*
+
+    extern sovrin_error_t sovrin_build_get_txn_request(sovrin_handle_t command_handle,
+                                                        const char *    submitter_did,
+                                                        i32    data,",,2017-07-11 13:59:18,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125895866,https://github.com/hyperledger/indy-sdk/pull/77#discussion_r125895866,jovfer
https://github.com/hyperledger/indy-sdk/pull/77,https://github.com/hyperledger/indy-sdk/pull/77,Add comment about ignore (also possible create ticket in JIRA) - for this and the next one test.,4d47f92c36e19023d8995e0a857930fe35c4090e,2017-07-07 14:35:58,126162286,"@@ -679,6 +679,96 @@ mod high_cases {
             TestUtils::cleanup_storage();
         }
     }
+
+    mod get_txn_requests {
+        use super::*;
+
+        #[test]
+        fn sovrin_build_get_txn_request() {
+            let identifier = ""identifier"";
+            let data = 1;
+
+            let expected_result = r#""""identifier"":""identifier"",""operation"":{""type"":""106"",""data"":1}""#;
+
+            let get_txn_request = LedgerUtils::build_get_txn_request(identifier, data).unwrap();
+            assert!(get_txn_request.contains(expected_result));
+        }
+
+        #[test]
+        #[ignore]",,2017-07-11 13:59:18,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/126162286,https://github.com/hyperledger/indy-sdk/pull/77#discussion_r126162286,jovfer
https://github.com/hyperledger/indy-sdk/pull/73,https://github.com/hyperledger/indy-sdk/pull/73,Add to headers CommonInvalidParam11 and CommonInvalidParam12,ad220be4074da651bee7198f3b376c8e9cc203fa,2017-06-30 15:33:57,125067672,"@@ -44,6 +44,15 @@ pub enum ErrorCode
     // Caller passed invalid value as param 9 (null, invalid json and etc..)
     CommonInvalidParam9,
 
+    // Caller passed invalid value as param 10 (null, invalid json and etc..)
+    CommonInvalidParam10,
+
+    // Caller passed invalid value as param 11 (null, invalid json and etc..)
+    CommonInvalidParam11,",8,2017-07-07 15:07:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125067672,https://github.com/hyperledger/indy-sdk/pull/73#discussion_r125067672,jovfer
https://github.com/hyperledger/indy-sdk/pull/73,https://github.com/hyperledger/indy-sdk/pull/73,Should be `value_ptr *mut *const c_char` here and below,ad220be4074da651bee7198f3b376c8e9cc203fa,2017-06-30 15:38:46,125068807,"@@ -13,45 +13,82 @@ use self::libc::c_char;
 /// It allows library user to provide custom wallet implementation.
 ///
 /// #Params
+/// command_handle: Command handle to map callback to caller context.
 /// xtype: Wallet type name.
-/// create: create operation handler
-/// create: open operation handler
-/// set: set operation handler
-/// get: get operation handler
-/// close: close operation handler
-/// free: free operation handler
+/// create: WalletType create operation handler
+/// open: WalletType open operation handler
+/// set: Wallet set operation handler
+/// get: Wallet get operation handler
+/// get_not_expired: Wallet get_not_expired operation handler
+/// list: Wallet list operation handler
+/// close: Wallet close operation handler
+/// delete: WalletType delete operation handler
+/// free: Handler that allows to de-allocate strings allocated in caller code
 ///
 /// #Returns
-/// error code
-///
-/// #Errors
-/// CommonInvalidParam1
-/// CommonInvalidParam2
-/// CommonInvalidParam3
-/// CommonInvalidParam4
-/// CommonInvalidParam5
-/// WalletTypeAlreadyRegistered
+/// Error code
 #[no_mangle]
-#[allow(unused_variables)] /* FIXME */
-pub extern fn sovrin_register_wallet_type(xtype: *const c_char,
-                                          create: extern fn(name: *const c_char,
-                                                            config: *const c_char,
-                                                            credentials: *const c_char) -> ErrorCode,
-                                          open: extern fn(name: *const c_char,
-                                                          config: *const c_char,
-                                                          credentials: *const c_char,
-                                                          handle: *const *mut i32) -> ErrorCode,
-                                          set: extern fn(handle: i32,
-                                                         key: *const c_char, sub_key: *const c_char,
-                                                         value: *const c_char) -> ErrorCode,
-                                          get: extern fn(handle: i32,
-                                                         key: *const c_char, sub_key: *const c_char,
-                                                         value_ptr: *const *mut c_char,
-                                                         value_life_time: *const *mut i32) -> ErrorCode,
-                                          close: extern fn(handle: i32) -> ErrorCode,
-                                          delete: extern fn(name: *const c_char) -> ErrorCode,
-                                          free: extern fn(wallet_handle: i32, str: *const c_char) -> ErrorCode) -> ErrorCode {
-    unimplemented!();
+pub extern fn sovrin_register_wallet_type(command_handle: i32,
+                                          xtype: *const c_char,
+                                          create: Option<extern fn(name: *const c_char,
+                                                                   config: *const c_char,
+                                                                   credentials: *const c_char) -> ErrorCode>,
+                                          open: Option<extern fn(name: *const c_char,
+                                                                 config: *const c_char,
+                                                                 runtime_config: *const c_char,
+                                                                 credentials: *const c_char,
+                                                                 handle: *mut i32) -> ErrorCode>,
+                                          set: Option<extern fn(handle: i32,
+                                                                key: *const c_char,
+                                                                value: *const c_char) -> ErrorCode>,
+                                          get: Option<extern fn(handle: i32,
+                                                                key: *const c_char,
+                                                                value_ptr: *const *mut c_char) -> ErrorCode>,",,2017-07-07 15:07:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125068807,https://github.com/hyperledger/indy-sdk/pull/73#discussion_r125068807,jovfer
https://github.com/hyperledger/indy-sdk/pull/73,https://github.com/hyperledger/indy-sdk/pull/73,Remove spaces after broken autoformat,ad220be4074da651bee7198f3b376c8e9cc203fa,2017-06-30 15:40:16,125069116,"@@ -39,31 +69,76 @@ impl WalletCommandExecutor {
 
     pub fn execute(&self, command: WalletCommand) {
         match command {
+            WalletCommand::RegisterWalletType(xtype, create, open, set, get,
+                                              get_not_expired, list, close, delete, free, cb) => {
+                info! (target: ""wallet_command_executor"", ""RegisterWalletType command received"");
+                self.register_type(&xtype, create, open, set,
+                                   get, get_not_expired, list, close, delete, free, cb);
+            }
             WalletCommand::Create(pool_name, name, xtype, config, credentials, cb) => {
-                info!(target: ""wallet_command_executor"", ""Create command received"");
+                info! (target: ""wallet_command_executor"", ""Create command received"");",,2017-07-07 15:07:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125069116,https://github.com/hyperledger/indy-sdk/pull/73#discussion_r125069116,jovfer
https://github.com/hyperledger/indy-sdk/pull/73,https://github.com/hyperledger/indy-sdk/pull/73,Done,ad220be4074da651bee7198f3b376c8e9cc203fa,2017-07-04 10:27:35,125441355,"@@ -44,6 +44,15 @@ pub enum ErrorCode
     // Caller passed invalid value as param 9 (null, invalid json and etc..)
     CommonInvalidParam9,
 
+    // Caller passed invalid value as param 10 (null, invalid json and etc..)
+    CommonInvalidParam10,
+
+    // Caller passed invalid value as param 11 (null, invalid json and etc..)
+    CommonInvalidParam11,",8,2017-07-07 15:07:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125441355,https://github.com/hyperledger/indy-sdk/pull/73#discussion_r125441355,vimmerru
https://github.com/hyperledger/indy-sdk/pull/73,https://github.com/hyperledger/indy-sdk/pull/73,Done,ad220be4074da651bee7198f3b376c8e9cc203fa,2017-07-04 11:03:02,125447056,"@@ -39,31 +69,76 @@ impl WalletCommandExecutor {
 
     pub fn execute(&self, command: WalletCommand) {
         match command {
+            WalletCommand::RegisterWalletType(xtype, create, open, set, get,
+                                              get_not_expired, list, close, delete, free, cb) => {
+                info! (target: ""wallet_command_executor"", ""RegisterWalletType command received"");
+                self.register_type(&xtype, create, open, set,
+                                   get, get_not_expired, list, close, delete, free, cb);
+            }
             WalletCommand::Create(pool_name, name, xtype, config, credentials, cb) => {
-                info!(target: ""wallet_command_executor"", ""Create command received"");
+                info! (target: ""wallet_command_executor"", ""Create command received"");",,2017-07-07 15:07:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125447056,https://github.com/hyperledger/indy-sdk/pull/73#discussion_r125447056,vimmerru
https://github.com/hyperledger/indy-sdk/pull/73,https://github.com/hyperledger/indy-sdk/pull/73,Done,ad220be4074da651bee7198f3b376c8e9cc203fa,2017-07-04 11:03:07,125447066,"@@ -13,45 +13,82 @@ use self::libc::c_char;
 /// It allows library user to provide custom wallet implementation.
 ///
 /// #Params
+/// command_handle: Command handle to map callback to caller context.
 /// xtype: Wallet type name.
-/// create: create operation handler
-/// create: open operation handler
-/// set: set operation handler
-/// get: get operation handler
-/// close: close operation handler
-/// free: free operation handler
+/// create: WalletType create operation handler
+/// open: WalletType open operation handler
+/// set: Wallet set operation handler
+/// get: Wallet get operation handler
+/// get_not_expired: Wallet get_not_expired operation handler
+/// list: Wallet list operation handler
+/// close: Wallet close operation handler
+/// delete: WalletType delete operation handler
+/// free: Handler that allows to de-allocate strings allocated in caller code
 ///
 /// #Returns
-/// error code
-///
-/// #Errors
-/// CommonInvalidParam1
-/// CommonInvalidParam2
-/// CommonInvalidParam3
-/// CommonInvalidParam4
-/// CommonInvalidParam5
-/// WalletTypeAlreadyRegistered
+/// Error code
 #[no_mangle]
-#[allow(unused_variables)] /* FIXME */
-pub extern fn sovrin_register_wallet_type(xtype: *const c_char,
-                                          create: extern fn(name: *const c_char,
-                                                            config: *const c_char,
-                                                            credentials: *const c_char) -> ErrorCode,
-                                          open: extern fn(name: *const c_char,
-                                                          config: *const c_char,
-                                                          credentials: *const c_char,
-                                                          handle: *const *mut i32) -> ErrorCode,
-                                          set: extern fn(handle: i32,
-                                                         key: *const c_char, sub_key: *const c_char,
-                                                         value: *const c_char) -> ErrorCode,
-                                          get: extern fn(handle: i32,
-                                                         key: *const c_char, sub_key: *const c_char,
-                                                         value_ptr: *const *mut c_char,
-                                                         value_life_time: *const *mut i32) -> ErrorCode,
-                                          close: extern fn(handle: i32) -> ErrorCode,
-                                          delete: extern fn(name: *const c_char) -> ErrorCode,
-                                          free: extern fn(wallet_handle: i32, str: *const c_char) -> ErrorCode) -> ErrorCode {
-    unimplemented!();
+pub extern fn sovrin_register_wallet_type(command_handle: i32,
+                                          xtype: *const c_char,
+                                          create: Option<extern fn(name: *const c_char,
+                                                                   config: *const c_char,
+                                                                   credentials: *const c_char) -> ErrorCode>,
+                                          open: Option<extern fn(name: *const c_char,
+                                                                 config: *const c_char,
+                                                                 runtime_config: *const c_char,
+                                                                 credentials: *const c_char,
+                                                                 handle: *mut i32) -> ErrorCode>,
+                                          set: Option<extern fn(handle: i32,
+                                                                key: *const c_char,
+                                                                value: *const c_char) -> ErrorCode>,
+                                          get: Option<extern fn(handle: i32,
+                                                                key: *const c_char,
+                                                                value_ptr: *const *mut c_char) -> ErrorCode>,",,2017-07-07 15:07:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125447066,https://github.com/hyperledger/indy-sdk/pull/73#discussion_r125447066,vimmerru
https://github.com/hyperledger/indy-sdk/pull/73,https://github.com/hyperledger/indy-sdk/pull/73,- [x] Add to C header,ad220be4074da651bee7198f3b376c8e9cc203fa,2017-07-05 16:39:05,125695934,"@@ -72,6 +81,9 @@ pub enum ErrorCode
     // Trying to use wallet with pool that has different name
     WalletIncompatiblePoolError,
 
+    // Trying to open wallet that was opened already
+    WalletAlreadyOpenedError,",21,2017-07-07 15:07:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125695934,https://github.com/hyperledger/indy-sdk/pull/73#discussion_r125695934,jovfer
https://github.com/hyperledger/indy-sdk/pull/73,https://github.com/hyperledger/indy-sdk/pull/73,Done,ad220be4074da651bee7198f3b376c8e9cc203fa,2017-07-06 07:45:03,125830931,"@@ -72,6 +81,9 @@ pub enum ErrorCode
     // Trying to use wallet with pool that has different name
     WalletIncompatiblePoolError,
 
+    // Trying to open wallet that was opened already
+    WalletAlreadyOpenedError,",21,2017-07-07 15:07:56,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/125830931,https://github.com/hyperledger/indy-sdk/pull/73#discussion_r125830931,vimmerru
https://github.com/hyperledger/indy-sdk/pull/71,https://github.com/hyperledger/indy-sdk/pull/71,I suggest changing result type from Future to CompletableFuture in all methods. CompletableFuture has additional methods that allow reducing boilerplate code in complex async scenarios. ,56401cbf6c77fce7f56c9297b31d474601ccf572,2017-07-10 12:45:44,126410730,"@@ -0,0 +1,329 @@
+package org.hyperledger.indy.sdk.agent;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Future;
+
+import org.hyperledger.indy.sdk.LibSovrin;
+import org.hyperledger.indy.sdk.SovrinException;
+import org.hyperledger.indy.sdk.SovrinJava;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentAddIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseConnectionResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseListenerResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentConnectResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentListenResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentRemoveIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentSendResult;
+import org.hyperledger.indy.sdk.pool.Pool;
+import org.hyperledger.indy.sdk.wallet.Wallet;
+
+import com.sun.jna.Callback;
+
+/**
+ * agent.rs API
+ */
+public class Agent extends SovrinJava.API {
+
+	private Agent() {
+
+	}
+
+	/*
+	 * STATIC METHODS
+	 */
+
+	public static Future<AgentConnectResult> agentConnect(",,2017-07-13 09:19:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/126410730,https://github.com/hyperledger/indy-sdk/pull/71#discussion_r126410730,vimmerru
https://github.com/hyperledger/indy-sdk/pull/71,https://github.com/hyperledger/indy-sdk/pull/71,"> Callback messageCb

It is low-level c callback that uses low-level ids, handles and error codes as params. It would be nice to hide this details from library user. I suggest using observer-like approach. We can define interface 

```
interface MessageObserver {
  void onMessage(AgentConnection connection, String message);
}
```

And ask a user to pass implementation of this observer as the latest parameter of agentConnect. 

",56401cbf6c77fce7f56c9297b31d474601ccf572,2017-07-10 12:55:39,126412998,"@@ -0,0 +1,329 @@
+package org.hyperledger.indy.sdk.agent;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Future;
+
+import org.hyperledger.indy.sdk.LibSovrin;
+import org.hyperledger.indy.sdk.SovrinException;
+import org.hyperledger.indy.sdk.SovrinJava;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentAddIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseConnectionResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseListenerResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentConnectResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentListenResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentRemoveIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentSendResult;
+import org.hyperledger.indy.sdk.pool.Pool;
+import org.hyperledger.indy.sdk.wallet.Wallet;
+
+import com.sun.jna.Callback;
+
+/**
+ * agent.rs API
+ */
+public class Agent extends SovrinJava.API {
+
+	private Agent() {
+
+	}
+
+	/*
+	 * STATIC METHODS
+	 */
+
+	public static Future<AgentConnectResult> agentConnect(
+			Pool pool,
+			Wallet wallet,
+			String senderDid,
+			String receiverDid,
+			Callback messageCb) throws SovrinException {",,2017-07-13 09:19:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/126412998,https://github.com/hyperledger/indy-sdk/pull/71#discussion_r126412998,vimmerru
https://github.com/hyperledger/indy-sdk/pull/71,https://github.com/hyperledger/indy-sdk/pull/71,"> agentConnect

I am not sure that we need agent prefix in all methods as this prefix is already present in the class name.  Just Agent::connect() seems enough.",56401cbf6c77fce7f56c9297b31d474601ccf572,2017-07-10 12:57:52,126413453,"@@ -0,0 +1,329 @@
+package org.hyperledger.indy.sdk.agent;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Future;
+
+import org.hyperledger.indy.sdk.LibSovrin;
+import org.hyperledger.indy.sdk.SovrinException;
+import org.hyperledger.indy.sdk.SovrinJava;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentAddIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseConnectionResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseListenerResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentConnectResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentListenResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentRemoveIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentSendResult;
+import org.hyperledger.indy.sdk.pool.Pool;
+import org.hyperledger.indy.sdk.wallet.Wallet;
+
+import com.sun.jna.Callback;
+
+/**
+ * agent.rs API
+ */
+public class Agent extends SovrinJava.API {
+
+	private Agent() {
+
+	}
+
+	/*
+	 * STATIC METHODS
+	 */
+
+	public static Future<AgentConnectResult> agentConnect(",,2017-07-13 09:19:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/126413453,https://github.com/hyperledger/indy-sdk/pull/71#discussion_r126413453,vimmerru
https://github.com/hyperledger/indy-sdk/pull/71,https://github.com/hyperledger/indy-sdk/pull/71,"I see that all return types have Result wrapper. For me, it looks like just additional boilerplate. I suggest:

1. if there are no fields in Result then just return Future<Void>
2. if we return an intermediate object like AgentConnection then return it directly without Result wrapper. For example,

`public static Future<AgentConnection> connect`

3. If the result is a simple type like String then use this type directly. For example, `Result<String>`
4. And only If the result is a tuple then define a custom Result type.",56401cbf6c77fce7f56c9297b31d474601ccf572,2017-07-10 13:05:01,126415095,"@@ -0,0 +1,329 @@
+package org.hyperledger.indy.sdk.agent;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Future;
+
+import org.hyperledger.indy.sdk.LibSovrin;
+import org.hyperledger.indy.sdk.SovrinException;
+import org.hyperledger.indy.sdk.SovrinJava;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentAddIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseConnectionResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseListenerResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentConnectResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentListenResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentRemoveIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentSendResult;
+import org.hyperledger.indy.sdk.pool.Pool;
+import org.hyperledger.indy.sdk.wallet.Wallet;
+
+import com.sun.jna.Callback;
+
+/**
+ * agent.rs API
+ */
+public class Agent extends SovrinJava.API {
+
+	private Agent() {
+
+	}
+
+	/*
+	 * STATIC METHODS
+	 */
+
+	public static Future<AgentConnectResult> agentConnect(",,2017-07-13 09:19:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/126415095,https://github.com/hyperledger/indy-sdk/pull/71#discussion_r126415095,vimmerru
https://github.com/hyperledger/indy-sdk/pull/71,https://github.com/hyperledger/indy-sdk/pull/71,"> Callback connectionCb
> Callback messageCb

These callbacks are low-level c callbacks that use low-level ids, handles and error codes as params. It would be nice to hide this details from library user. I suggest using observer-like approach. We can define one interface 

```
interface ConnectionObserver {
  void onConnection(AgentConnection connection);
  void onMessage(AgentConnection connection, String message);
}
```

And ask a user to pass implementation of this observer as the latest parameter of agentConnect. This parameter will replace both callbacks. 

",56401cbf6c77fce7f56c9297b31d474601ccf572,2017-07-10 13:08:11,126415768,"@@ -0,0 +1,329 @@
+package org.hyperledger.indy.sdk.agent;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Future;
+
+import org.hyperledger.indy.sdk.LibSovrin;
+import org.hyperledger.indy.sdk.SovrinException;
+import org.hyperledger.indy.sdk.SovrinJava;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentAddIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseConnectionResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseListenerResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentConnectResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentListenResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentRemoveIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentSendResult;
+import org.hyperledger.indy.sdk.pool.Pool;
+import org.hyperledger.indy.sdk.wallet.Wallet;
+
+import com.sun.jna.Callback;
+
+/**
+ * agent.rs API
+ */
+public class Agent extends SovrinJava.API {
+
+	private Agent() {
+
+	}
+
+	/*
+	 * STATIC METHODS
+	 */
+
+	public static Future<AgentConnectResult> agentConnect(
+			Pool pool,
+			Wallet wallet,
+			String senderDid,
+			String receiverDid,
+			Callback messageCb) throws SovrinException {
+
+		final CompletableFuture<AgentConnectResult> future = new CompletableFuture<> ();
+
+		Callback connectionCb = new Callback() {
+
+			@SuppressWarnings(""unused"")
+			public void callback(int xcommand_handle, int err, int connection_handle) {
+
+				if (! checkCallback(future, xcommand_handle, err)) return;
+
+				Agent.Connection connection = new Agent.Connection(connection_handle);
+
+				AgentConnectResult result = new AgentConnectResult(connection);
+				future.complete(result);
+			}
+		};
+
+		int poolHandle = pool.getPoolHandle();
+		int walletHandle = wallet.getWalletHandle();
+
+		int result = LibSovrin.api.sovrin_agent_connect(
+				FIXED_COMMAND_HANDLE, 
+				poolHandle,
+				walletHandle, 
+				senderDid,
+				receiverDid,
+				connectionCb,
+				messageCb);
+
+		checkResult(result);
+
+		return future;
+	}
+
+	public static Future<AgentListenResult> agentListen(",,2017-07-13 09:19:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/126415768,https://github.com/hyperledger/indy-sdk/pull/71#discussion_r126415768,vimmerru
https://github.com/hyperledger/indy-sdk/pull/71,https://github.com/hyperledger/indy-sdk/pull/71,"> connectionCb = new Callback()

We are creating a new instance of Callback for each call and perform passing of this callback to c function. JVM can't manage reference counting in C code. As result, GC will free this object on the next GC iteration and it will cause bad behavior like crashes or missed callback calls. 

To avoid this I suggest the following:

1. For each call create one static callback instance and `static Map<i32 /* command handle */, Future>`
2. Use global atomic counter to generate new command handles
3. When user calls our method generate new command handles and put corresponded Future to static Map
4. When libsovrin calls our callback resolve corresponded future with result",56401cbf6c77fce7f56c9297b31d474601ccf572,2017-07-10 13:26:50,126420355,"@@ -0,0 +1,329 @@
+package org.hyperledger.indy.sdk.agent;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Future;
+
+import org.hyperledger.indy.sdk.LibSovrin;
+import org.hyperledger.indy.sdk.SovrinException;
+import org.hyperledger.indy.sdk.SovrinJava;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentAddIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseConnectionResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseListenerResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentConnectResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentListenResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentRemoveIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentSendResult;
+import org.hyperledger.indy.sdk.pool.Pool;
+import org.hyperledger.indy.sdk.wallet.Wallet;
+
+import com.sun.jna.Callback;
+
+/**
+ * agent.rs API
+ */
+public class Agent extends SovrinJava.API {
+
+	private Agent() {
+
+	}
+
+	/*
+	 * STATIC METHODS
+	 */
+
+	public static Future<AgentConnectResult> agentConnect(
+			Pool pool,
+			Wallet wallet,
+			String senderDid,
+			String receiverDid,
+			Callback messageCb) throws SovrinException {
+
+		final CompletableFuture<AgentConnectResult> future = new CompletableFuture<> ();
+
+		Callback connectionCb = new Callback() {",,2017-07-13 09:19:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/126420355,https://github.com/hyperledger/indy-sdk/pull/71#discussion_r126420355,vimmerru
https://github.com/hyperledger/indy-sdk/pull/71,https://github.com/hyperledger/indy-sdk/pull/71,"> Callback connectionCb,
> Callback messageCb

I don't understand why agentAddIdentity and agentRemoveIdentity require these params. It looks like copy-paste issue.",56401cbf6c77fce7f56c9297b31d474601ccf572,2017-07-10 13:28:02,126420652,"@@ -0,0 +1,329 @@
+package org.hyperledger.indy.sdk.agent;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Future;
+
+import org.hyperledger.indy.sdk.LibSovrin;
+import org.hyperledger.indy.sdk.SovrinException;
+import org.hyperledger.indy.sdk.SovrinJava;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentAddIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseConnectionResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseListenerResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentConnectResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentListenResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentRemoveIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentSendResult;
+import org.hyperledger.indy.sdk.pool.Pool;
+import org.hyperledger.indy.sdk.wallet.Wallet;
+
+import com.sun.jna.Callback;
+
+/**
+ * agent.rs API
+ */
+public class Agent extends SovrinJava.API {
+
+	private Agent() {
+
+	}
+
+	/*
+	 * STATIC METHODS
+	 */
+
+	public static Future<AgentConnectResult> agentConnect(
+			Pool pool,
+			Wallet wallet,
+			String senderDid,
+			String receiverDid,
+			Callback messageCb) throws SovrinException {
+
+		final CompletableFuture<AgentConnectResult> future = new CompletableFuture<> ();
+
+		Callback connectionCb = new Callback() {
+
+			@SuppressWarnings(""unused"")
+			public void callback(int xcommand_handle, int err, int connection_handle) {
+
+				if (! checkCallback(future, xcommand_handle, err)) return;
+
+				Agent.Connection connection = new Agent.Connection(connection_handle);
+
+				AgentConnectResult result = new AgentConnectResult(connection);
+				future.complete(result);
+			}
+		};
+
+		int poolHandle = pool.getPoolHandle();
+		int walletHandle = wallet.getWalletHandle();
+
+		int result = LibSovrin.api.sovrin_agent_connect(
+				FIXED_COMMAND_HANDLE, 
+				poolHandle,
+				walletHandle, 
+				senderDid,
+				receiverDid,
+				connectionCb,
+				messageCb);
+
+		checkResult(result);
+
+		return future;
+	}
+
+	public static Future<AgentListenResult> agentListen(
+			String endpoint,
+			Callback connectionCb,
+			Callback messageCb) throws SovrinException {
+
+		final CompletableFuture<AgentListenResult> future = new CompletableFuture<> ();
+
+		Callback listenerCb = new Callback() {
+
+			@SuppressWarnings(""unused"")
+			public void callback(int xcommand_handle, int err, int listener_handle) {
+
+				if (! checkCallback(future, xcommand_handle, err)) return;
+
+				Agent.Listener connection = new Agent.Listener(listener_handle);
+
+				AgentListenResult result = new AgentListenResult(connection);
+				future.complete(result);
+			}
+		};
+
+		int result = LibSovrin.api.sovrin_agent_listen(
+				FIXED_COMMAND_HANDLE, 
+				endpoint,
+				listenerCb,
+				connectionCb,
+				messageCb);
+
+		checkResult(result);
+
+		return future;
+	}
+
+	public static Future<AgentAddIdentityResult> agentAddIdentity(
+			Agent.Listener listener,
+			Pool pool,
+			Wallet wallet,
+			String did,
+			Callback connectionCb,",,2017-07-13 09:19:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/126420652,https://github.com/hyperledger/indy-sdk/pull/71#discussion_r126420652,vimmerru
https://github.com/hyperledger/indy-sdk/pull/71,https://github.com/hyperledger/indy-sdk/pull/71,"You can check https://github.com/java-native-access/jna/blob/master/www/CallbacksAndClosures.md

""If your callback needs to live beyond the method invocation where it is used, make sure you keep a reference to it or the native code will call back to an empty stub after the callback object is garbage collected.""",56401cbf6c77fce7f56c9297b31d474601ccf572,2017-07-10 13:43:46,126424499,"@@ -0,0 +1,329 @@
+package org.hyperledger.indy.sdk.agent;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Future;
+
+import org.hyperledger.indy.sdk.LibSovrin;
+import org.hyperledger.indy.sdk.SovrinException;
+import org.hyperledger.indy.sdk.SovrinJava;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentAddIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseConnectionResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseListenerResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentConnectResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentListenResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentRemoveIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentSendResult;
+import org.hyperledger.indy.sdk.pool.Pool;
+import org.hyperledger.indy.sdk.wallet.Wallet;
+
+import com.sun.jna.Callback;
+
+/**
+ * agent.rs API
+ */
+public class Agent extends SovrinJava.API {
+
+	private Agent() {
+
+	}
+
+	/*
+	 * STATIC METHODS
+	 */
+
+	public static Future<AgentConnectResult> agentConnect(
+			Pool pool,
+			Wallet wallet,
+			String senderDid,
+			String receiverDid,
+			Callback messageCb) throws SovrinException {
+
+		final CompletableFuture<AgentConnectResult> future = new CompletableFuture<> ();
+
+		Callback connectionCb = new Callback() {",,2017-07-13 09:19:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/126424499,https://github.com/hyperledger/indy-sdk/pull/71#discussion_r126424499,vimmerru
https://github.com/hyperledger/indy-sdk/pull/71,https://github.com/hyperledger/indy-sdk/pull/71,"agree, fixed in a7b0eaaf4d6d9fe62f3dd3e503d61e75498d7d6f",56401cbf6c77fce7f56c9297b31d474601ccf572,2017-07-11 13:22:20,126685929,"@@ -0,0 +1,329 @@
+package org.hyperledger.indy.sdk.agent;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Future;
+
+import org.hyperledger.indy.sdk.LibSovrin;
+import org.hyperledger.indy.sdk.SovrinException;
+import org.hyperledger.indy.sdk.SovrinJava;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentAddIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseConnectionResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseListenerResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentConnectResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentListenResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentRemoveIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentSendResult;
+import org.hyperledger.indy.sdk.pool.Pool;
+import org.hyperledger.indy.sdk.wallet.Wallet;
+
+import com.sun.jna.Callback;
+
+/**
+ * agent.rs API
+ */
+public class Agent extends SovrinJava.API {
+
+	private Agent() {
+
+	}
+
+	/*
+	 * STATIC METHODS
+	 */
+
+	public static Future<AgentConnectResult> agentConnect(
+			Pool pool,
+			Wallet wallet,
+			String senderDid,
+			String receiverDid,
+			Callback messageCb) throws SovrinException {
+
+		final CompletableFuture<AgentConnectResult> future = new CompletableFuture<> ();
+
+		Callback connectionCb = new Callback() {
+
+			@SuppressWarnings(""unused"")
+			public void callback(int xcommand_handle, int err, int connection_handle) {
+
+				if (! checkCallback(future, xcommand_handle, err)) return;
+
+				Agent.Connection connection = new Agent.Connection(connection_handle);
+
+				AgentConnectResult result = new AgentConnectResult(connection);
+				future.complete(result);
+			}
+		};
+
+		int poolHandle = pool.getPoolHandle();
+		int walletHandle = wallet.getWalletHandle();
+
+		int result = LibSovrin.api.sovrin_agent_connect(
+				FIXED_COMMAND_HANDLE, 
+				poolHandle,
+				walletHandle, 
+				senderDid,
+				receiverDid,
+				connectionCb,
+				messageCb);
+
+		checkResult(result);
+
+		return future;
+	}
+
+	public static Future<AgentListenResult> agentListen(
+			String endpoint,
+			Callback connectionCb,
+			Callback messageCb) throws SovrinException {
+
+		final CompletableFuture<AgentListenResult> future = new CompletableFuture<> ();
+
+		Callback listenerCb = new Callback() {
+
+			@SuppressWarnings(""unused"")
+			public void callback(int xcommand_handle, int err, int listener_handle) {
+
+				if (! checkCallback(future, xcommand_handle, err)) return;
+
+				Agent.Listener connection = new Agent.Listener(listener_handle);
+
+				AgentListenResult result = new AgentListenResult(connection);
+				future.complete(result);
+			}
+		};
+
+		int result = LibSovrin.api.sovrin_agent_listen(
+				FIXED_COMMAND_HANDLE, 
+				endpoint,
+				listenerCb,
+				connectionCb,
+				messageCb);
+
+		checkResult(result);
+
+		return future;
+	}
+
+	public static Future<AgentAddIdentityResult> agentAddIdentity(
+			Agent.Listener listener,
+			Pool pool,
+			Wallet wallet,
+			String did,
+			Callback connectionCb,",,2017-07-13 09:19:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/126685929,https://github.com/hyperledger/indy-sdk/pull/71#discussion_r126685929,peacekeeper
https://github.com/hyperledger/indy-sdk/pull/71,https://github.com/hyperledger/indy-sdk/pull/71,"agree, fixed in 2c8fc025ae72f0b1d1737f13dee81710b84d0ba5",56401cbf6c77fce7f56c9297b31d474601ccf572,2017-07-11 13:27:05,126687205,"@@ -0,0 +1,329 @@
+package org.hyperledger.indy.sdk.agent;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Future;
+
+import org.hyperledger.indy.sdk.LibSovrin;
+import org.hyperledger.indy.sdk.SovrinException;
+import org.hyperledger.indy.sdk.SovrinJava;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentAddIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseConnectionResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseListenerResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentConnectResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentListenResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentRemoveIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentSendResult;
+import org.hyperledger.indy.sdk.pool.Pool;
+import org.hyperledger.indy.sdk.wallet.Wallet;
+
+import com.sun.jna.Callback;
+
+/**
+ * agent.rs API
+ */
+public class Agent extends SovrinJava.API {
+
+	private Agent() {
+
+	}
+
+	/*
+	 * STATIC METHODS
+	 */
+
+	public static Future<AgentConnectResult> agentConnect(",,2017-07-13 09:19:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/126687205,https://github.com/hyperledger/indy-sdk/pull/71#discussion_r126687205,peacekeeper
https://github.com/hyperledger/indy-sdk/pull/71,https://github.com/hyperledger/indy-sdk/pull/71,"agree, fixed in 14326b46f870c2ce5d84ce6b480b1a4249e596d0",56401cbf6c77fce7f56c9297b31d474601ccf572,2017-07-11 14:33:09,126706581,"@@ -0,0 +1,329 @@
+package org.hyperledger.indy.sdk.agent;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Future;
+
+import org.hyperledger.indy.sdk.LibSovrin;
+import org.hyperledger.indy.sdk.SovrinException;
+import org.hyperledger.indy.sdk.SovrinJava;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentAddIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseConnectionResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseListenerResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentConnectResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentListenResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentRemoveIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentSendResult;
+import org.hyperledger.indy.sdk.pool.Pool;
+import org.hyperledger.indy.sdk.wallet.Wallet;
+
+import com.sun.jna.Callback;
+
+/**
+ * agent.rs API
+ */
+public class Agent extends SovrinJava.API {
+
+	private Agent() {
+
+	}
+
+	/*
+	 * STATIC METHODS
+	 */
+
+	public static Future<AgentConnectResult> agentConnect(",,2017-07-13 09:19:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/126706581,https://github.com/hyperledger/indy-sdk/pull/71#discussion_r126706581,peacekeeper
https://github.com/hyperledger/indy-sdk/pull/71,https://github.com/hyperledger/indy-sdk/pull/71,see dcbd87f19300dfbf1795c4ee2c5762caf6914449 for initial commit to use observer pattern,56401cbf6c77fce7f56c9297b31d474601ccf572,2017-07-11 19:12:43,126781771,"@@ -0,0 +1,329 @@
+package org.hyperledger.indy.sdk.agent;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Future;
+
+import org.hyperledger.indy.sdk.LibSovrin;
+import org.hyperledger.indy.sdk.SovrinException;
+import org.hyperledger.indy.sdk.SovrinJava;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentAddIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseConnectionResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseListenerResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentConnectResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentListenResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentRemoveIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentSendResult;
+import org.hyperledger.indy.sdk.pool.Pool;
+import org.hyperledger.indy.sdk.wallet.Wallet;
+
+import com.sun.jna.Callback;
+
+/**
+ * agent.rs API
+ */
+public class Agent extends SovrinJava.API {
+
+	private Agent() {
+
+	}
+
+	/*
+	 * STATIC METHODS
+	 */
+
+	public static Future<AgentConnectResult> agentConnect(
+			Pool pool,
+			Wallet wallet,
+			String senderDid,
+			String receiverDid,
+			Callback messageCb) throws SovrinException {",,2017-07-13 09:19:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/126781771,https://github.com/hyperledger/indy-sdk/pull/71#discussion_r126781771,peacekeeper
https://github.com/hyperledger/indy-sdk/pull/71,https://github.com/hyperledger/indy-sdk/pull/71,see dcbd87f19300dfbf1795c4ee2c5762caf6914449 for initial commit to use observer pattern,56401cbf6c77fce7f56c9297b31d474601ccf572,2017-07-11 19:12:55,126781826,"@@ -0,0 +1,329 @@
+package org.hyperledger.indy.sdk.agent;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Future;
+
+import org.hyperledger.indy.sdk.LibSovrin;
+import org.hyperledger.indy.sdk.SovrinException;
+import org.hyperledger.indy.sdk.SovrinJava;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentAddIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseConnectionResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseListenerResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentConnectResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentListenResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentRemoveIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentSendResult;
+import org.hyperledger.indy.sdk.pool.Pool;
+import org.hyperledger.indy.sdk.wallet.Wallet;
+
+import com.sun.jna.Callback;
+
+/**
+ * agent.rs API
+ */
+public class Agent extends SovrinJava.API {
+
+	private Agent() {
+
+	}
+
+	/*
+	 * STATIC METHODS
+	 */
+
+	public static Future<AgentConnectResult> agentConnect(
+			Pool pool,
+			Wallet wallet,
+			String senderDid,
+			String receiverDid,
+			Callback messageCb) throws SovrinException {
+
+		final CompletableFuture<AgentConnectResult> future = new CompletableFuture<> ();
+
+		Callback connectionCb = new Callback() {
+
+			@SuppressWarnings(""unused"")
+			public void callback(int xcommand_handle, int err, int connection_handle) {
+
+				if (! checkCallback(future, xcommand_handle, err)) return;
+
+				Agent.Connection connection = new Agent.Connection(connection_handle);
+
+				AgentConnectResult result = new AgentConnectResult(connection);
+				future.complete(result);
+			}
+		};
+
+		int poolHandle = pool.getPoolHandle();
+		int walletHandle = wallet.getWalletHandle();
+
+		int result = LibSovrin.api.sovrin_agent_connect(
+				FIXED_COMMAND_HANDLE, 
+				poolHandle,
+				walletHandle, 
+				senderDid,
+				receiverDid,
+				connectionCb,
+				messageCb);
+
+		checkResult(result);
+
+		return future;
+	}
+
+	public static Future<AgentListenResult> agentListen(",,2017-07-13 09:19:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/126781826,https://github.com/hyperledger/indy-sdk/pull/71#discussion_r126781826,peacekeeper
https://github.com/hyperledger/indy-sdk/pull/71,https://github.com/hyperledger/indy-sdk/pull/71,this is now WIP in 29813c7874f18551e8b174d424a114071259da23,56401cbf6c77fce7f56c9297b31d474601ccf572,2017-07-12 07:26:31,126881357,"@@ -0,0 +1,329 @@
+package org.hyperledger.indy.sdk.agent;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Future;
+
+import org.hyperledger.indy.sdk.LibSovrin;
+import org.hyperledger.indy.sdk.SovrinException;
+import org.hyperledger.indy.sdk.SovrinJava;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentAddIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseConnectionResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentCloseListenerResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentConnectResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentListenResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentRemoveIdentityResult;
+import org.hyperledger.indy.sdk.agent.AgentResults.AgentSendResult;
+import org.hyperledger.indy.sdk.pool.Pool;
+import org.hyperledger.indy.sdk.wallet.Wallet;
+
+import com.sun.jna.Callback;
+
+/**
+ * agent.rs API
+ */
+public class Agent extends SovrinJava.API {
+
+	private Agent() {
+
+	}
+
+	/*
+	 * STATIC METHODS
+	 */
+
+	public static Future<AgentConnectResult> agentConnect(
+			Pool pool,
+			Wallet wallet,
+			String senderDid,
+			String receiverDid,
+			Callback messageCb) throws SovrinException {
+
+		final CompletableFuture<AgentConnectResult> future = new CompletableFuture<> ();
+
+		Callback connectionCb = new Callback() {",,2017-07-13 09:19:22,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/126881357,https://github.com/hyperledger/indy-sdk/pull/71#discussion_r126881357,peacekeeper
https://github.com/hyperledger/indy-sdk/pull/34,https://github.com/hyperledger/indy-sdk/pull/34,- [x] Update C headers too (include/sovrin_ledger.h),6f68b175595d5f99cb7d5d7c9666bbcedd61fc84,2017-06-06 11:00:58,120324154,"@@ -158,26 +157,23 @@ pub extern fn sovrin_build_nym_request(command_handle: i32,
                                        submitter_did: *const c_char,
                                        target_did: *const c_char,
                                        verkey: *const c_char,
-                                       xref: *const c_char,
-                                       data: *const c_char,
+                                       alias: *const c_char,",16,2017-06-08 10:34:16,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/120324154,https://github.com/hyperledger/indy-sdk/pull/34#discussion_r120324154,jovfer
https://github.com/hyperledger/indy-sdk/pull/15,https://github.com/hyperledger/indy-sdk/pull/15,Moving of сlosing parenthesis of function params list to next line is bad code style. Please fix it.,eea8420072a5b2a2d6a6cdaddb219e7082ae79d9,2017-05-25 12:13:50,118473244,"@@ -216,79 +231,112 @@ impl LedgerCommandExecutor {
                              submitter_did: &str,
                              target_did: &str,
                              cb: Box<Fn(Result<String, SovrinError>) + Send>) {
-        cb(Ok("""".to_string()));
+        cb(self.ledger_service.build_get_ddo_request(submitter_did, target_did)
+            .map_err(|err| SovrinError::CommonError(err)))
     }
 
     fn build_nym_request(&self,
                          submitter_did: &str,
                          target_did: &str,
-                         verkey: &str,
-                         xref: &str,
-                         data: &str,
-                         role: &str,
+                         verkey: Option<&str>,
+                         xref: Option<&str>,
+                         data: Option<&str>,
+                         role: Option<&str>,
                          cb: Box<Fn(Result<String, SovrinError>) + Send>) {
-        cb(Ok("""".to_string()));
+        cb(self.ledger_service.build_nym_request(submitter_did,
+                                                 target_did,
+                                                 verkey,
+                                                 xref,
+                                                 data,
+                                                 role
+        ).map_err(|err| SovrinError::CommonError(err)))",155,2017-06-02 10:35:40,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/118473244,https://github.com/hyperledger/indy-sdk/pull/15#discussion_r118473244,vimmerru
https://github.com/hyperledger/indy-sdk/pull/15,https://github.com/hyperledger/indy-sdk/pull/15,Common mapping from json error to Ledger error looks wrong. Depend on situation it can be Common::InvalidParam or Common::InvalidState,eea8420072a5b2a2d6a6cdaddb219e7082ae79d9,2017-05-25 12:16:06,118473535,"@@ -58,6 +60,12 @@ impl ToErrorCode for LedgerError {
     }
 }
 
+impl From<serde_json::Error> for LedgerError {
+    fn from(err: serde_json::Error) -> LedgerError {",11,2017-06-02 10:35:40,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/118473535,https://github.com/hyperledger/indy-sdk/pull/15#discussion_r118473535,vimmerru
https://github.com/hyperledger/indy-sdk/pull/15,https://github.com/hyperledger/indy-sdk/pull/15,Looks like we should remove CryptoError::InvalidStructure. We have exactly the same common error.,eea8420072a5b2a2d6a6cdaddb219e7082ae79d9,2017-05-25 12:35:49,118476152,"@@ -72,7 +72,7 @@ impl Issuer {
         info!(target: ""anoncreds_service"", ""Issuer generate primary keys for Schema {:?} -> start"", &schema);
         let mut ctx = BigNumber::new_context()?;
 
-        if schema.attribute_names.len() == 0 {
+        if schema.attr_names.len() == 0 {
             return Err(CryptoError::InvalidStructure(format!(""List of attribute names is required to setup claim definition"")))",,2017-06-02 10:35:40,https://api.github.com/repos/hyperledger/indy-sdk/pulls/comments/118476152,https://github.com/hyperledger/indy-sdk/pull/15#discussion_r118476152,vimmerru
