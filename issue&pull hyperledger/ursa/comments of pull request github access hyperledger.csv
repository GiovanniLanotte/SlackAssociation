pull request url html,pull request url,body,commit_id,create at,id,diff_hunk,position,update at,url,html url,user
https://github.com/hyperledger/ursa/pull/17,https://github.com/hyperledger/ursa/pull/17,The caller of `keypair` will lose access to `s`. Should this function be zeroing `s`?  ,d80b3e46069111abf2b9f2c0ef16f1b2d1ed3030,2019-03-18 19:50:49,266613532,"@@ -1,163 +1,58 @@
-use super::*;
+use super::{SignatureScheme, KeyPairOption, PublicKey, PrivateKey};
 use CryptoError;
+pub use ed25519_dalek::{PUBLIC_KEY_LENGTH as PUBLIC_KEY_SIZE, EXPANDED_SECRET_KEY_LENGTH as PRIVATE_KEY_SIZE, SIGNATURE_LENGTH as SIGNATURE_SIZE};
+use ed25519_dalek::{Signature, Keypair, PublicKey as PK};
+use rand_chacha::ChaChaRng;
+use rand::rngs::OsRng;
+use rand::SeedableRng;
+use sha2::Digest;
 
-pub const PRIVATE_KEY_SIZE: usize = 64;
-pub const PUBLIC_KEY_SIZE: usize = 32;
-pub const SIGNATURE_SIZE: usize = 64;
 pub const ALGORITHM_NAME: &str = ""ED25519_SHA2_512"";
 
-pub struct Ed25519Sha512(ed25519_sha2_512::Ed25519Sha512Impl);
+pub struct Ed25519Sha512;
 
 impl SignatureScheme for Ed25519Sha512 {
-    fn new() -> Ed25519Sha512 {
-        Ed25519Sha512(ed25519_sha2_512::Ed25519Sha512Impl::new())
+    fn new() -> Self {
+        Self
     }
     fn keypair(&self, option: Option<KeyPairOption>) -> Result<(PublicKey, PrivateKey), CryptoError> {
-        self.0.keypair(option)
+        let kp = match option {
+            Some(o) => match o {
+                KeyPairOption::UseSeed(s) => {
+                    let hash = sha2::Sha256::digest(s.as_slice());",31,2019-03-19 13:58:56,https://api.github.com/repos/hyperledger/ursa/pulls/comments/266613532,https://github.com/hyperledger/ursa/pull/17#discussion_r266613532,lovesh
https://github.com/hyperledger/ursa/pull/17,https://github.com/hyperledger/ursa/pull/17,`s` will not be returned so the caller has no control to zero it? Should this code zero it or that is not a concern for now?,d80b3e46069111abf2b9f2c0ef16f1b2d1ed3030,2019-03-18 19:56:02,266615657,"@@ -77,18 +79,19 @@ mod ecdsa_secp256k1sha256 {
             let pk = PublicKey(res.serialize().to_vec());
             Ok(pk)
         }
-        pub fn new() -> EcdsaSecp256k1Sha256Impl {
-            EcdsaSecp256k1Sha256Impl(libsecp256k1::Secp256k1::new())
+        pub fn new() -> Self {
+            Self(libsecp256k1::Secp256k1::new())
         }
-        pub fn keypair(&self, option: Option<KeyPairOption>) -> Result<(PublicKey, PrivateKey), CryptoError> {
+        pub fn keypair<D>(&self, option: Option<KeyPairOption>) -> Result<(PublicKey, PrivateKey), CryptoError> where D: Digest<OutputSize = U32> {
             let sk = match option {
                     Some(o) => {
                         match o {
                             KeyPairOption::UseSeed(seed) => {
                                 let mut s = [0u8; PRIVATE_KEY_SIZE];
                                 let mut rng = ChaChaRng::from_seed(*array_ref!(seed.as_slice(), 0, 32));
                                 rng.fill_bytes(&mut s);",83,2019-03-19 13:58:56,https://api.github.com/repos/hyperledger/ursa/pulls/comments/266615657,https://github.com/hyperledger/ursa/pull/17#discussion_r266615657,lovesh
https://github.com/hyperledger/ursa/pull/17,https://github.com/hyperledger/ursa/pull/17,Who zeroes `seed`,d80b3e46069111abf2b9f2c0ef16f1b2d1ed3030,2019-03-18 19:56:18,266615753,"@@ -77,18 +79,19 @@ mod ecdsa_secp256k1sha256 {
             let pk = PublicKey(res.serialize().to_vec());
             Ok(pk)
         }
-        pub fn new() -> EcdsaSecp256k1Sha256Impl {
-            EcdsaSecp256k1Sha256Impl(libsecp256k1::Secp256k1::new())
+        pub fn new() -> Self {
+            Self(libsecp256k1::Secp256k1::new())
         }
-        pub fn keypair(&self, option: Option<KeyPairOption>) -> Result<(PublicKey, PrivateKey), CryptoError> {
+        pub fn keypair<D>(&self, option: Option<KeyPairOption>) -> Result<(PublicKey, PrivateKey), CryptoError> where D: Digest<OutputSize = U32> {
             let sk = match option {
                     Some(o) => {
                         match o {
                             KeyPairOption::UseSeed(seed) => {",,2019-03-19 13:58:56,https://api.github.com/repos/hyperledger/ursa/pulls/comments/266615753,https://github.com/hyperledger/ursa/pull/17#discussion_r266615753,lovesh
https://github.com/hyperledger/ursa/pull/17,https://github.com/hyperledger/ursa/pull/17,Who zeroes this `s`?,d80b3e46069111abf2b9f2c0ef16f1b2d1ed3030,2019-03-18 19:56:55,266616014,"@@ -97,21 +100,22 @@ mod ecdsa_secp256k1sha256 {
                         let mut rng = OsRng::new().map_err(|err| CryptoError::KeyGenError(format!(""{}"", err)))?;
                         let mut s = [0u8; PRIVATE_KEY_SIZE];
                         rng.fill_bytes(&mut s);
-                        libsecp256k1::key::SecretKey::from_slice(&s[..])?
+                        let s = D::digest(&s);
+                        libsecp256k1::key::SecretKey::from_slice(s.as_slice())?",,2019-03-19 13:58:56,https://api.github.com/repos/hyperledger/ursa/pulls/comments/266616014,https://github.com/hyperledger/ursa/pull/17#discussion_r266616014,lovesh
https://github.com/hyperledger/ursa/pull/17,https://github.com/hyperledger/ursa/pull/17,`s` should be zeroed,d80b3e46069111abf2b9f2c0ef16f1b2d1ed3030,2019-03-18 19:57:34,266616242,"@@ -97,21 +100,22 @@ mod ecdsa_secp256k1sha256 {
                         let mut rng = OsRng::new().map_err(|err| CryptoError::KeyGenError(format!(""{}"", err)))?;
                         let mut s = [0u8; PRIVATE_KEY_SIZE];
                         rng.fill_bytes(&mut s);
-                        libsecp256k1::key::SecretKey::from_slice(&s[..])?
+                        let s = D::digest(&s);
+                        libsecp256k1::key::SecretKey::from_slice(s.as_slice())?
                     }
                 };
             let pk = libsecp256k1::key::PublicKey::from_secret_key(&self.0, &sk);
             Ok((PublicKey(pk.serialize().to_vec()), PrivateKey(sk[..].to_vec())))
         }
-        pub fn sign(&self, message: &[u8], sk: &PrivateKey) -> Result<Vec<u8>, CryptoError> {
-            let h = digest(DigestAlgorithm::Sha2_256, message)?;
+        pub fn sign<D>(&self, message: &[u8], sk: &PrivateKey) -> Result<Vec<u8>, CryptoError> where D: Digest<OutputSize = U32> {
+            let h = D::digest(message);
             let msg = libsecp256k1::Message::from_slice(h.as_slice())?;
             let s = libsecp256k1::key::SecretKey::from_slice(&sk[..])?;",109,2019-03-19 13:58:56,https://api.github.com/repos/hyperledger/ursa/pulls/comments/266616242,https://github.com/hyperledger/ursa/pull/17#discussion_r266616242,lovesh
https://github.com/hyperledger/ursa/pull/17,https://github.com/hyperledger/ursa/pull/17,`s` is zero'd in the Drop trait. See libursa/src/utils/macros.,d80b3e46069111abf2b9f2c0ef16f1b2d1ed3030,2019-03-19 13:56:03,266898628,"@@ -97,21 +100,22 @@ mod ecdsa_secp256k1sha256 {
                         let mut rng = OsRng::new().map_err(|err| CryptoError::KeyGenError(format!(""{}"", err)))?;
                         let mut s = [0u8; PRIVATE_KEY_SIZE];
                         rng.fill_bytes(&mut s);
-                        libsecp256k1::key::SecretKey::from_slice(&s[..])?
+                        let s = D::digest(&s);
+                        libsecp256k1::key::SecretKey::from_slice(s.as_slice())?
                     }
                 };
             let pk = libsecp256k1::key::PublicKey::from_secret_key(&self.0, &sk);
             Ok((PublicKey(pk.serialize().to_vec()), PrivateKey(sk[..].to_vec())))
         }
-        pub fn sign(&self, message: &[u8], sk: &PrivateKey) -> Result<Vec<u8>, CryptoError> {
-            let h = digest(DigestAlgorithm::Sha2_256, message)?;
+        pub fn sign<D>(&self, message: &[u8], sk: &PrivateKey) -> Result<Vec<u8>, CryptoError> where D: Digest<OutputSize = U32> {
+            let h = D::digest(message);
             let msg = libsecp256k1::Message::from_slice(h.as_slice())?;
             let s = libsecp256k1::key::SecretKey::from_slice(&sk[..])?;",109,2019-03-19 13:58:56,https://api.github.com/repos/hyperledger/ursa/pulls/comments/266898628,https://github.com/hyperledger/ursa/pull/17#discussion_r266898628,mikelodder7
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,"Wouldn't it be better to make `UseSeed` and `FromSecretKey` borrow seed or the private key than taking ownership of it? That way the caller needs to take care of zeroing out the memory and in somecases the caller might not have ownership of the secret data as there is a 3rd party who owns it. 
The usages i have seen of `seed` or PrivateKey don't demand having ownership anyway.",0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-19 07:20:05,266755422,"@@ -1,20 +1,53 @@
-use encoding::hex::bin2hex;
+use zeroize::Zeroize;
+use encoding::hex::{bin2hex, hex2bin};
+use std::ops::Drop;
+
+#[cfg(feature = ""wasm"")]
+use wasm_bindgen::prelude::*;
 
 // A private key instance.
 /// The underlying content is dependent on implementation.
+#[cfg_attr(feature = ""wasm"", wasm_bindgen)]
 pub struct PrivateKey(pub Vec<u8>);
 impl_bytearray!(PrivateKey);
 
+#[cfg_attr(feature = ""wasm"", wasm_bindgen)]
 pub struct PublicKey(pub Vec<u8>);
 impl_bytearray!(PublicKey);
 
+#[cfg_attr(feature = ""wasm"", wasm_bindgen)]
 pub struct SessionKey(pub Vec<u8>);
 impl_bytearray!(SessionKey);
 
+#[cfg_attr(feature = ""wasm"", wasm_bindgen)]
 pub struct MacKey(pub Vec<u8>);
 impl_bytearray!(MacKey);
 
-pub enum KeyPairOption<'a> {
+//#[cfg_attr(feature = ""wasm"", wasm_bindgen)]
+#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
+pub enum KeyGenOption {
     UseSeed(Vec<u8>),
-    FromSecretKey(&'a PrivateKey)
+    FromSecretKey(PrivateKey)
+}
+
+impl Drop for KeyGenOption {",36,2019-03-20 02:58:22,https://api.github.com/repos/hyperledger/ursa/pulls/comments/266755422,https://github.com/hyperledger/ursa/pull/14#discussion_r266755422,lovesh
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,Maybe a todo here saying that we add `public_key_compressed_size` later,0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-19 07:24:14,266756494,"@@ -49,16 +49,17 @@ impl<'a, 'b, T: 'a + SignatureScheme> Signer<'a, 'b, T> {
     ///
     /// * `public_key` - the public key instance
     pub fn get_public_key(&self) -> Result<PublicKey, CryptoError> {
-        let (pubk, _) = self.scheme.keypair(Some(KeyPairOption::FromSecretKey(self.key))).unwrap();
+        let sk = PrivateKey(self.key[..].to_vec());
+        let (pubk, _) = self.scheme.keypair(Some(KeyGenOption::FromSecretKey(sk))).unwrap();
         Ok(pubk)
     }
 }
 
 pub trait EcdsaPublicKeyHandler {
     /// Returns the compressed bytes
-    fn serialize(&self, pk: &PublicKey) -> Vec<u8>;
+    fn public_key_compressed(&self, pk: &PublicKey) -> Vec<u8>;
     /// Returns the uncompressed bytes
-    fn serialize_uncompressed(&self, pk: &PublicKey) -> Vec<u8>;
+    fn public_key_uncompressed(&self, pk: &PublicKey) -> Vec<u8>;
     /// Read raw bytes into key struct. Can be either compressed or uncompressed
     fn parse(&self, data: &[u8]) -> Result<PublicKey, CryptoError>;
     fn public_key_uncompressed_size() -> usize;",34,2019-03-20 02:58:22,https://api.github.com/repos/hyperledger/ursa/pulls/comments/266756494,https://github.com/hyperledger/ursa/pull/14#discussion_r266756494,lovesh
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,`&s[..]` is same as `&s` here.,0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-19 07:32:41,266758401,"@@ -77,20 +112,20 @@ mod ecdsa_secp256k1sha256 {
             let pk = PublicKey(res.serialize().to_vec());
             Ok(pk)
         }
-        pub fn new() -> EcdsaSecp256k1Sha256Impl {
+        pub fn new() -> Self {
             EcdsaSecp256k1Sha256Impl(libsecp256k1::Secp256k1::new())
         }
-        pub fn keypair(&self, option: Option<KeyPairOption>) -> Result<(PublicKey, PrivateKey), CryptoError> {
+        pub fn keypair(&self, option: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError> {
             let sk = match option {
                     Some(o) => {
                         match o {
-                            KeyPairOption::UseSeed(seed) => {
+                            KeyGenOption::UseSeed(ref seed) => {
                                 let mut s = [0u8; PRIVATE_KEY_SIZE];
                                 let mut rng = ChaChaRng::from_seed(*array_ref!(seed.as_slice(), 0, 32));
                                 rng.fill_bytes(&mut s);
                                 libsecp256k1::key::SecretKey::from_slice(&s[..])?",,2019-03-20 02:58:22,https://api.github.com/repos/hyperledger/ursa/pulls/comments/266758401,https://github.com/hyperledger/ursa/pull/14#discussion_r266758401,lovesh
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,Same as last comment,0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-19 07:32:54,266758437,"@@ -77,20 +112,20 @@ mod ecdsa_secp256k1sha256 {
             let pk = PublicKey(res.serialize().to_vec());
             Ok(pk)
         }
-        pub fn new() -> EcdsaSecp256k1Sha256Impl {
+        pub fn new() -> Self {
             EcdsaSecp256k1Sha256Impl(libsecp256k1::Secp256k1::new())
         }
-        pub fn keypair(&self, option: Option<KeyPairOption>) -> Result<(PublicKey, PrivateKey), CryptoError> {
+        pub fn keypair(&self, option: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError> {
             let sk = match option {
                     Some(o) => {
                         match o {
-                            KeyPairOption::UseSeed(seed) => {
+                            KeyGenOption::UseSeed(ref seed) => {
                                 let mut s = [0u8; PRIVATE_KEY_SIZE];
                                 let mut rng = ChaChaRng::from_seed(*array_ref!(seed.as_slice(), 0, 32));
                                 rng.fill_bytes(&mut s);
                                 libsecp256k1::key::SecretKey::from_slice(&s[..])?
                             },
-                            KeyPairOption::FromSecretKey(s) => libsecp256k1::key::SecretKey::from_slice(&s[..])?
+                            KeyGenOption::FromSecretKey(ref s) => libsecp256k1::key::SecretKey::from_slice(&s[..])?",116,2019-03-20 02:58:22,https://api.github.com/repos/hyperledger/ursa/pulls/comments/266758437,https://github.com/hyperledger/ursa/pull/14#discussion_r266758437,lovesh
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,`d` needs to be zeroed out.,0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-19 07:34:14,266758705,"@@ -166,28 +202,28 @@ mod ecdsa_secp256k1sha256 {
                 _ => Err(CryptoError::ParseError(""Invalid key length"".to_string()))
             }
         }
-        pub fn new() -> EcdsaSecp256k1Sha256Impl {
+        pub fn new() -> Self {
             EcdsaSecp256k1Sha256Impl{}
         }
-        pub fn keypair(&self, option: Option<KeyPairOption>) -> Result<(PublicKey, PrivateKey), CryptoError> {
+        pub fn keypair(&self, option: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError> {
             let mut sk = [0u8; PRIVATE_KEY_SIZE];
             match option {
                     Some(o) => {
                         match o {
-                            KeyPairOption::UseSeed(seed) => {
+                            KeyGenOption::UseSeed(ref seed) => {
                                 let mut rng = ChaChaRng::from_seed(*array_ref!(seed.as_slice(), 0, PRIVATE_KEY_SIZE));
                                 rng.fill_bytes(&mut sk);
                                 let d = digest(DigestAlgorithm::Sha2_256, &sk[..])?;
-                                array_copy!(d.as_slice(), sk)
+                                sk.clone_from_slice(d.as_slice());",,2019-03-20 02:58:22,https://api.github.com/repos/hyperledger/ursa/pulls/comments/266758705,https://github.com/hyperledger/ursa/pull/14#discussion_r266758705,lovesh
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,"`d` needs to be zeroed out.

",0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-19 07:34:32,266758762,"@@ -166,28 +202,28 @@ mod ecdsa_secp256k1sha256 {
                 _ => Err(CryptoError::ParseError(""Invalid key length"".to_string()))
             }
         }
-        pub fn new() -> EcdsaSecp256k1Sha256Impl {
+        pub fn new() -> Self {
             EcdsaSecp256k1Sha256Impl{}
         }
-        pub fn keypair(&self, option: Option<KeyPairOption>) -> Result<(PublicKey, PrivateKey), CryptoError> {
+        pub fn keypair(&self, option: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError> {
             let mut sk = [0u8; PRIVATE_KEY_SIZE];
             match option {
                     Some(o) => {
                         match o {
-                            KeyPairOption::UseSeed(seed) => {
+                            KeyGenOption::UseSeed(ref seed) => {
                                 let mut rng = ChaChaRng::from_seed(*array_ref!(seed.as_slice(), 0, PRIVATE_KEY_SIZE));
                                 rng.fill_bytes(&mut sk);
                                 let d = digest(DigestAlgorithm::Sha2_256, &sk[..])?;
-                                array_copy!(d.as_slice(), sk)
+                                sk.clone_from_slice(d.as_slice());
                             },
-                            KeyPairOption::FromSecretKey(s) => array_copy!(s, sk)
+                            KeyGenOption::FromSecretKey(ref s) => array_copy!(s, sk)
                         }
                     },
                     None => {
                         let mut rng = OsRng::new().map_err(|err| CryptoError::KeyGenError(format!(""{}"", err)))?;
                         rng.fill_bytes(&mut sk);
                         let d = digest(DigestAlgorithm::Sha2_256, &sk[..])?;
-                        array_copy!(d.as_slice(), sk);
+                        sk.clone_from_slice(d.as_slice());",195,2019-03-20 02:58:22,https://api.github.com/repos/hyperledger/ursa/pulls/comments/266758762,https://github.com/hyperledger/ursa/pull/14#discussion_r266758762,lovesh
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,"There is a bit of non-uniformity here; the objects in `bls` module like `Generator`, `SignKey` and `Verkey` have a method called `as_bytes` that return a slice whereas in this wasm module's `as_bytes` that returns a vector. It would be good if `Generator` in `bls` module had a method like `to_bytes` that returns a vector apart from `as_bytes` returning slice. 
Do we have a need for 2 methods returning slice and vector?",0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-19 07:50:18,266762683,"@@ -1,209 +1,142 @@
 use wasm_bindgen::prelude::*;
 
 use bls;
-use errors::UrsaCryptoError;
-use errors::ToErrorCode;
-use serde;
+use super::convert_from_js;
 
-impl From<UrsaCryptoError> for JsValue {
-    fn from(err: UrsaCryptoError) -> JsValue {
-        let error_code = err.to_error_code();
-        JsValue::from_serde(&error_code).unwrap()
+#[wasm_bindgen]
+pub struct Generator(bls::Generator);
+
+#[wasm_bindgen]
+impl Generator {
+    pub fn new() -> Result<Generator, JsValue> {
+        Ok(Generator(maperr!(bls::Generator::new())))
     }
-}
 
-fn convert_from_js<T>(val: &JsValue) -> Result<T, UrsaCryptoError>
-where
-    for<'a> T: serde::Deserialize<'a>,
-{
-    match val.into_serde() {
-        Ok(unwrapped) => Ok(unwrapped),
-        Err(_) => Err(UrsaCryptoError::InvalidStructure(
-            ""Invalid argument"".to_string(),
-        )),
+    pub fn as_bytes(&self) -> Vec<u8> {
+        self.0.as_bytes().to_vec()",33,2019-03-20 02:58:22,https://api.github.com/repos/hyperledger/ursa/pulls/comments/266762683,https://github.com/hyperledger/ursa/pull/14#discussion_r266762683,lovesh
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,Is `rev_reg_from` typed as &JsValue because wasm-bindgen does not support Option?,0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-19 08:06:13,266766909,"@@ -0,0 +1,509 @@
+use wasm_bindgen::prelude::*;
+use js_sys::Function;
+
+use std::collections::HashSet;
+
+use cl;
+use cl::RevocationTailsAccessor;
+
+use super::convert_from_js;
+
+#[wasm_bindgen]
+pub struct CredentialSchema(cl::CredentialSchemaBuilder);
+
+#[wasm_bindgen]
+impl CredentialSchema {
+    pub fn new() -> CredentialSchema {
+        CredentialSchema(cl::CredentialSchemaBuilder::new().unwrap())
+    }
+
+    pub fn add_attr(&mut self, attribute: &str) {
+        self.0.add_attr(attribute).unwrap();
+    }
+}
+
+#[wasm_bindgen]
+pub struct NonCredentialSchema(cl::NonCredentialSchemaBuilder);
+
+#[wasm_bindgen]
+impl NonCredentialSchema {
+    pub fn new() -> NonCredentialSchema {
+        NonCredentialSchema(cl::NonCredentialSchemaBuilder::new().unwrap())
+    }
+
+    pub fn add_attr(&mut self, attribute: &str) {
+        self.0.add_attr(attribute).unwrap();
+    }
+}
+
+#[wasm_bindgen]
+pub struct CredentialValues(cl::CredentialValuesBuilder);
+
+#[wasm_bindgen]
+impl CredentialValues {
+    pub fn new() -> CredentialValues {
+        CredentialValues(cl::CredentialValuesBuilder::new().unwrap())
+    }
+
+    pub fn add_master_secret(&mut self, value: &MasterSecret) -> Result<(), JsValue> {
+        let ms = maperr!(value.0.value());
+        maperr!(self.0.add_value_hidden(""master_secret"", &ms));
+        Ok(())
+    }
+
+    pub fn add_known(&mut self, attr: &str, value: &str) -> Result<(), JsValue> {
+        maperr!(self.0.add_dec_known(attr, value));
+        Ok(())
+    }
+
+    pub fn add_hidden(&mut self, attr: &str, value: &str) -> Result<(), JsValue> {
+        maperr!(self.0.add_dec_hidden(attr, value));
+        Ok(())
+    }
+
+    pub fn add_commitment(&mut self, attr: &str, value: &str, blinding_factor: &str) -> Result<(), JsValue> {
+        maperr!(self.0.add_dec_commitment(attr, value, blinding_factor));
+        Ok(())
+    }
+}
+
+#[wasm_bindgen]
+pub struct CredentialPrimaryPublicKey(cl::CredentialPrimaryPublicKey);
+
+#[wasm_bindgen]
+pub struct CredentialPublicKey(cl::CredentialPublicKey);
+
+#[wasm_bindgen]
+#[allow(non_snake_case)]
+impl CredentialPublicKey {
+    pub fn getPrimaryKey(&self) -> Result<CredentialPrimaryPublicKey, JsValue> {
+        Ok(CredentialPrimaryPublicKey(maperr!(self.0.get_primary_key())))
+    }
+    pub fn getRevocationKey(&self) -> Result<JsValue, JsValue> {
+        match maperr!(self.0.get_revocation_key()) {
+            Some(k) => Ok(JsValue::from_serde(&CredentialRevocationPublicKey(k)).unwrap()),
+            None => Ok(JsValue::NULL)
+        }
+    }
+}
+
+#[wasm_bindgen]
+#[derive(Serialize, Deserialize)]
+pub struct CredentialRevocationPublicKey(cl::CredentialRevocationPublicKey);
+
+#[wasm_bindgen]
+pub struct CredentialPrivateKey(cl::CredentialPrivateKey);
+
+#[wasm_bindgen]
+pub struct CredentialKeyCorrectnessProof(cl::CredentialKeyCorrectnessProof);
+
+/// Convenience class for javascript. This provides a name-value pair structure
+/// instead of a tuple. The compiler complains about unused fields
+/// so allow(unused) is in place for now
+#[wasm_bindgen]
+#[allow(non_snake_case, unused)]
+pub struct CredentialDefinition {
+    publicKey: CredentialPublicKey,
+    privateKey: CredentialPrivateKey,
+    keyCorrectnessProof: CredentialKeyCorrectnessProof
+}
+
+#[wasm_bindgen]
+pub struct MasterSecret(cl::MasterSecret);
+
+#[wasm_bindgen]
+impl MasterSecret {
+    pub fn new() -> Result<MasterSecret, JsValue> {
+        Ok(MasterSecret(maperr!(cl::prover::Prover::new_master_secret())))
+    }
+}
+
+#[wasm_bindgen]
+pub struct Nonce(cl::Nonce);
+
+#[wasm_bindgen]
+impl Nonce {
+    pub fn new() -> Result<Nonce, JsValue> {
+        Ok(Nonce(maperr!(cl::new_nonce())))
+    }
+}
+
+#[wasm_bindgen]
+pub struct BlindedCredentialSecrets(cl::BlindedCredentialSecrets);
+
+#[wasm_bindgen]
+pub struct CredentialSecretsBlindingFactors(cl::CredentialSecretsBlindingFactors);
+
+#[wasm_bindgen]
+pub struct BlindedCredentialSecretsCorrectnessProof(cl::BlindedCredentialSecretsCorrectnessProof);
+
+/// Convenience class for javascript. This provides a name-value pair structure
+/// instead of a tuple. The compiler complains about unused fields
+/// so allow(unused) is in place for now
+#[wasm_bindgen]
+#[allow(non_snake_case, unused)]
+pub struct ProverBlindedCredentialSecrets {
+    blindedCredentialSecrets: BlindedCredentialSecrets,
+    credentialSecretsBlindingFactors: CredentialSecretsBlindingFactors,
+    blindedCredentialSecretsCorrectnessProof: BlindedCredentialSecretsCorrectnessProof
+}
+
+#[wasm_bindgen]
+pub struct CredentialSignature(cl::CredentialSignature);
+
+#[wasm_bindgen]
+#[allow(non_snake_case)]
+impl CredentialSignature {
+    pub fn extractIndex(&self) -> Option<u32> {
+        self.0.extract_index()
+    }
+}
+
+#[wasm_bindgen]
+pub struct SignatureCorrectnessProof(cl::SignatureCorrectnessProof);
+
+#[wasm_bindgen]
+#[allow(non_snake_case)]
+pub struct IssuedCredential {
+    credentialSignature: CredentialSignature,
+    signatureCorrectnessProof: SignatureCorrectnessProof
+}
+
+/// Convenience class for javascript. This provides a name-value pair structure
+/// instead of a tuple. The compiler complains about unused fields
+/// so allow(unused) is in place for now
+#[wasm_bindgen]
+#[allow(non_snake_case, unused)]
+pub struct IssuedCredentialWithRevocation {
+    issuedCredential: IssuedCredential,
+    delta: Option<RevocationRegistryDelta>
+}
+
+#[wasm_bindgen]
+#[derive(Serialize, Deserialize)]
+pub struct Tail(cl::Tail);
+
+#[wasm_bindgen]
+#[derive(Serialize, Deserialize)]
+pub struct RevocationPublicKey(cl::RevocationKeyPublic);
+
+#[wasm_bindgen]
+pub struct RevocationPrivateKey(cl::RevocationKeyPrivate);
+
+#[wasm_bindgen]
+#[derive(Serialize, Deserialize)]
+pub struct RevocationRegistry(cl::RevocationRegistry);
+
+#[wasm_bindgen]
+pub struct RevocationRegistryDelta(cl::RevocationRegistryDelta);
+
+#[wasm_bindgen]
+#[allow(non_snake_case)]
+impl RevocationRegistryDelta {
+    pub fn fromParts(rev_reg_from: &JsValue,",203,2019-03-20 02:58:22,https://api.github.com/repos/hyperledger/ursa/pulls/comments/266766909,https://github.com/hyperledger/ursa/pull/14#discussion_r266766909,lovesh
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,We should avoid commented-out-code in the repo.,0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-19 18:39:03,267042240,"@@ -0,0 +1,63 @@
+use signatures::SignatureScheme;
+use signatures::secp256k1::EcdsaSecp256k1Sha256;
+use keys::{KeyPairOption, PublicKey, PrivateKey};
+use encoding::hex::{bin2hex, hex2bin};
+
+use wasm_bindgen::prelude::*;
+use super::convert_from_js;
+
+#[wasm_bindgen]
+#[derive(Serialize, Deserialize)]
+pub struct KeyPair {
+    pk: PublicKey,
+    sk: PrivateKey
+}
+
+#[wasm_bindgen]
+#[allow(non_snake_case)]
+pub fn secp256k1New() -> EcdsaSecp256k1Sha256 {
+    EcdsaSecp256k1Sha256::new()
+}
+
+#[wasm_bindgen]
+#[allow(non_snake_case)]
+pub fn secp256k1KeyPair(secp256k1: &EcdsaSecp256k1Sha256) -> Result<KeyPair, JsValue> {
+    let (pk, sk) = secp256k1.keypair(None).map_err(|e| e.to_string())?;
+    Ok(KeyPair { pk, sk })
+}
+
+#[wasm_bindgen]
+#[allow(non_snake_case)]
+pub fn secp256k1KeyPairFromSeed(secp256k1: &EcdsaSecp256k1Sha256, seed: &str) -> Result<KeyPair, JsValue> {
+    let seed = hex2bin(seed).map_err(|e|e.to_string())?;
+    let (pk, sk) = secp256k1.keypair(Some(KeyPairOption::UseSeed(seed))).map_err(|e|e.to_string())?;
+    Ok(KeyPair { pk, sk })
+}
+
+#[wasm_bindgen]
+#[allow(non_snake_case)]
+pub fn secp256k1KeyPairFromSecretKey(secp256k1: &EcdsaSecp256k1Sha256, sk: &PrivateKey) -> Result<KeyPair, JsValue> {
+    let (pk, sk) = secp256k1.keypair(Some(KeyPairOption::FromSecretKey(sk.clone()))).map_err(|e|e.to_string())?;
+    Ok(KeyPair { pk, sk })
+}
+
+#[wasm_bindgen]
+#[allow(non_snake_case)]
+pub fn secp256k1Sign(secp256k1: &JsValue, message: &str, sk: &PrivateKey) -> Result<JsValue, JsValue> {
+    let secp256k1: EcdsaSecp256k1Sha256 = convert_from_js(secp256k1)?;
+
+    let sig = secp256k1.sign(message.as_bytes(), &sk).map_err(|e|e.to_string())?;
+    Ok(JsValue::from_serde(&bin2hex(sig.as_slice())).unwrap())
+}
+
+#[wasm_bindgen]
+#[allow(non_snake_case)]
+pub fn secp256k1Verify(secp256k1: &JsValue, message: &str, signature: &str, pk: &PublicKey) -> Result<bool, JsValue> {
+    let secp256k1: EcdsaSecp256k1Sha256 = convert_from_js(secp256k1)?;
+    let signature = hex2bin(signature).map_err(|e|e.to_string())?;
+    Ok(secp256k1.verify(message.as_bytes(),signature.as_slice(), pk).map_err(|e|e.to_string())?)
+}
+
+//pub fn secp256k1NormalizeS(secp256k1: &JsValue, ) -> Result<JsValue, JsValue> {",,2019-03-20 02:58:22,https://api.github.com/repos/hyperledger/ursa/pulls/comments/267042240,https://github.com/hyperledger/ursa/pull/14#discussion_r267042240,vaporos
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,Perl? Why not have this written in rust?,0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-19 18:43:41,267044282,"@@ -0,0 +1,243 @@
+#!/usr/bin/perl",,2019-03-20 02:58:22,https://api.github.com/repos/hyperledger/ursa/pulls/comments/267044282,https://github.com/hyperledger/ursa/pull/14#discussion_r267044282,vaporos
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,You can't borrow with wasm. It passes it to Javascript.,0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-20 01:47:06,267160082,"@@ -1,20 +1,53 @@
-use encoding::hex::bin2hex;
+use zeroize::Zeroize;
+use encoding::hex::{bin2hex, hex2bin};
+use std::ops::Drop;
+
+#[cfg(feature = ""wasm"")]
+use wasm_bindgen::prelude::*;
 
 // A private key instance.
 /// The underlying content is dependent on implementation.
+#[cfg_attr(feature = ""wasm"", wasm_bindgen)]
 pub struct PrivateKey(pub Vec<u8>);
 impl_bytearray!(PrivateKey);
 
+#[cfg_attr(feature = ""wasm"", wasm_bindgen)]
 pub struct PublicKey(pub Vec<u8>);
 impl_bytearray!(PublicKey);
 
+#[cfg_attr(feature = ""wasm"", wasm_bindgen)]
 pub struct SessionKey(pub Vec<u8>);
 impl_bytearray!(SessionKey);
 
+#[cfg_attr(feature = ""wasm"", wasm_bindgen)]
 pub struct MacKey(pub Vec<u8>);
 impl_bytearray!(MacKey);
 
-pub enum KeyPairOption<'a> {
+//#[cfg_attr(feature = ""wasm"", wasm_bindgen)]
+#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
+pub enum KeyGenOption {
     UseSeed(Vec<u8>),
-    FromSecretKey(&'a PrivateKey)
+    FromSecretKey(PrivateKey)
+}
+
+impl Drop for KeyGenOption {",36,2019-03-20 02:58:22,https://api.github.com/repos/hyperledger/ursa/pulls/comments/267160082,https://github.com/hyperledger/ursa/pull/14#discussion_r267160082,mikelodder7
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,not necessary because its in the SignatureScheme Trait.,0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-20 01:49:26,267160437,"@@ -49,16 +49,17 @@ impl<'a, 'b, T: 'a + SignatureScheme> Signer<'a, 'b, T> {
     ///
     /// * `public_key` - the public key instance
     pub fn get_public_key(&self) -> Result<PublicKey, CryptoError> {
-        let (pubk, _) = self.scheme.keypair(Some(KeyPairOption::FromSecretKey(self.key))).unwrap();
+        let sk = PrivateKey(self.key[..].to_vec());
+        let (pubk, _) = self.scheme.keypair(Some(KeyGenOption::FromSecretKey(sk))).unwrap();
         Ok(pubk)
     }
 }
 
 pub trait EcdsaPublicKeyHandler {
     /// Returns the compressed bytes
-    fn serialize(&self, pk: &PublicKey) -> Vec<u8>;
+    fn public_key_compressed(&self, pk: &PublicKey) -> Vec<u8>;
     /// Returns the uncompressed bytes
-    fn serialize_uncompressed(&self, pk: &PublicKey) -> Vec<u8>;
+    fn public_key_uncompressed(&self, pk: &PublicKey) -> Vec<u8>;
     /// Read raw bytes into key struct. Can be either compressed or uncompressed
     fn parse(&self, data: &[u8]) -> Result<PublicKey, CryptoError>;
     fn public_key_uncompressed_size() -> usize;",34,2019-03-20 02:58:22,https://api.github.com/repos/hyperledger/ursa/pulls/comments/267160437,https://github.com/hyperledger/ursa/pull/14#discussion_r267160437,mikelodder7
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,With vectors yes but not with structs.,0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-20 01:50:00,267160520,"@@ -77,20 +112,20 @@ mod ecdsa_secp256k1sha256 {
             let pk = PublicKey(res.serialize().to_vec());
             Ok(pk)
         }
-        pub fn new() -> EcdsaSecp256k1Sha256Impl {
+        pub fn new() -> Self {
             EcdsaSecp256k1Sha256Impl(libsecp256k1::Secp256k1::new())
         }
-        pub fn keypair(&self, option: Option<KeyPairOption>) -> Result<(PublicKey, PrivateKey), CryptoError> {
+        pub fn keypair(&self, option: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError> {
             let sk = match option {
                     Some(o) => {
                         match o {
-                            KeyPairOption::UseSeed(seed) => {
+                            KeyGenOption::UseSeed(ref seed) => {
                                 let mut s = [0u8; PRIVATE_KEY_SIZE];
                                 let mut rng = ChaChaRng::from_seed(*array_ref!(seed.as_slice(), 0, 32));
                                 rng.fill_bytes(&mut s);
                                 libsecp256k1::key::SecretKey::from_slice(&s[..])?",,2019-03-20 02:58:22,https://api.github.com/repos/hyperledger/ursa/pulls/comments/267160520,https://github.com/hyperledger/ursa/pull/14#discussion_r267160520,mikelodder7
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,WASM doesn't like byte arrays. We could do that but why,0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-20 01:51:44,267160765,"@@ -1,209 +1,142 @@
 use wasm_bindgen::prelude::*;
 
 use bls;
-use errors::UrsaCryptoError;
-use errors::ToErrorCode;
-use serde;
+use super::convert_from_js;
 
-impl From<UrsaCryptoError> for JsValue {
-    fn from(err: UrsaCryptoError) -> JsValue {
-        let error_code = err.to_error_code();
-        JsValue::from_serde(&error_code).unwrap()
+#[wasm_bindgen]
+pub struct Generator(bls::Generator);
+
+#[wasm_bindgen]
+impl Generator {
+    pub fn new() -> Result<Generator, JsValue> {
+        Ok(Generator(maperr!(bls::Generator::new())))
     }
-}
 
-fn convert_from_js<T>(val: &JsValue) -> Result<T, UrsaCryptoError>
-where
-    for<'a> T: serde::Deserialize<'a>,
-{
-    match val.into_serde() {
-        Ok(unwrapped) => Ok(unwrapped),
-        Err(_) => Err(UrsaCryptoError::InvalidStructure(
-            ""Invalid argument"".to_string(),
-        )),
+    pub fn as_bytes(&self) -> Vec<u8> {
+        self.0.as_bytes().to_vec()",33,2019-03-20 02:58:22,https://api.github.com/repos/hyperledger/ursa/pulls/comments/267160765,https://github.com/hyperledger/ursa/pull/14#discussion_r267160765,mikelodder7
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,Some things don't play nicely with wasm like lifetimes.,0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-20 01:52:43,267160925,"@@ -0,0 +1,509 @@
+use wasm_bindgen::prelude::*;
+use js_sys::Function;
+
+use std::collections::HashSet;
+
+use cl;
+use cl::RevocationTailsAccessor;
+
+use super::convert_from_js;
+
+#[wasm_bindgen]
+pub struct CredentialSchema(cl::CredentialSchemaBuilder);
+
+#[wasm_bindgen]
+impl CredentialSchema {
+    pub fn new() -> CredentialSchema {
+        CredentialSchema(cl::CredentialSchemaBuilder::new().unwrap())
+    }
+
+    pub fn add_attr(&mut self, attribute: &str) {
+        self.0.add_attr(attribute).unwrap();
+    }
+}
+
+#[wasm_bindgen]
+pub struct NonCredentialSchema(cl::NonCredentialSchemaBuilder);
+
+#[wasm_bindgen]
+impl NonCredentialSchema {
+    pub fn new() -> NonCredentialSchema {
+        NonCredentialSchema(cl::NonCredentialSchemaBuilder::new().unwrap())
+    }
+
+    pub fn add_attr(&mut self, attribute: &str) {
+        self.0.add_attr(attribute).unwrap();
+    }
+}
+
+#[wasm_bindgen]
+pub struct CredentialValues(cl::CredentialValuesBuilder);
+
+#[wasm_bindgen]
+impl CredentialValues {
+    pub fn new() -> CredentialValues {
+        CredentialValues(cl::CredentialValuesBuilder::new().unwrap())
+    }
+
+    pub fn add_master_secret(&mut self, value: &MasterSecret) -> Result<(), JsValue> {
+        let ms = maperr!(value.0.value());
+        maperr!(self.0.add_value_hidden(""master_secret"", &ms));
+        Ok(())
+    }
+
+    pub fn add_known(&mut self, attr: &str, value: &str) -> Result<(), JsValue> {
+        maperr!(self.0.add_dec_known(attr, value));
+        Ok(())
+    }
+
+    pub fn add_hidden(&mut self, attr: &str, value: &str) -> Result<(), JsValue> {
+        maperr!(self.0.add_dec_hidden(attr, value));
+        Ok(())
+    }
+
+    pub fn add_commitment(&mut self, attr: &str, value: &str, blinding_factor: &str) -> Result<(), JsValue> {
+        maperr!(self.0.add_dec_commitment(attr, value, blinding_factor));
+        Ok(())
+    }
+}
+
+#[wasm_bindgen]
+pub struct CredentialPrimaryPublicKey(cl::CredentialPrimaryPublicKey);
+
+#[wasm_bindgen]
+pub struct CredentialPublicKey(cl::CredentialPublicKey);
+
+#[wasm_bindgen]
+#[allow(non_snake_case)]
+impl CredentialPublicKey {
+    pub fn getPrimaryKey(&self) -> Result<CredentialPrimaryPublicKey, JsValue> {
+        Ok(CredentialPrimaryPublicKey(maperr!(self.0.get_primary_key())))
+    }
+    pub fn getRevocationKey(&self) -> Result<JsValue, JsValue> {
+        match maperr!(self.0.get_revocation_key()) {
+            Some(k) => Ok(JsValue::from_serde(&CredentialRevocationPublicKey(k)).unwrap()),
+            None => Ok(JsValue::NULL)
+        }
+    }
+}
+
+#[wasm_bindgen]
+#[derive(Serialize, Deserialize)]
+pub struct CredentialRevocationPublicKey(cl::CredentialRevocationPublicKey);
+
+#[wasm_bindgen]
+pub struct CredentialPrivateKey(cl::CredentialPrivateKey);
+
+#[wasm_bindgen]
+pub struct CredentialKeyCorrectnessProof(cl::CredentialKeyCorrectnessProof);
+
+/// Convenience class for javascript. This provides a name-value pair structure
+/// instead of a tuple. The compiler complains about unused fields
+/// so allow(unused) is in place for now
+#[wasm_bindgen]
+#[allow(non_snake_case, unused)]
+pub struct CredentialDefinition {
+    publicKey: CredentialPublicKey,
+    privateKey: CredentialPrivateKey,
+    keyCorrectnessProof: CredentialKeyCorrectnessProof
+}
+
+#[wasm_bindgen]
+pub struct MasterSecret(cl::MasterSecret);
+
+#[wasm_bindgen]
+impl MasterSecret {
+    pub fn new() -> Result<MasterSecret, JsValue> {
+        Ok(MasterSecret(maperr!(cl::prover::Prover::new_master_secret())))
+    }
+}
+
+#[wasm_bindgen]
+pub struct Nonce(cl::Nonce);
+
+#[wasm_bindgen]
+impl Nonce {
+    pub fn new() -> Result<Nonce, JsValue> {
+        Ok(Nonce(maperr!(cl::new_nonce())))
+    }
+}
+
+#[wasm_bindgen]
+pub struct BlindedCredentialSecrets(cl::BlindedCredentialSecrets);
+
+#[wasm_bindgen]
+pub struct CredentialSecretsBlindingFactors(cl::CredentialSecretsBlindingFactors);
+
+#[wasm_bindgen]
+pub struct BlindedCredentialSecretsCorrectnessProof(cl::BlindedCredentialSecretsCorrectnessProof);
+
+/// Convenience class for javascript. This provides a name-value pair structure
+/// instead of a tuple. The compiler complains about unused fields
+/// so allow(unused) is in place for now
+#[wasm_bindgen]
+#[allow(non_snake_case, unused)]
+pub struct ProverBlindedCredentialSecrets {
+    blindedCredentialSecrets: BlindedCredentialSecrets,
+    credentialSecretsBlindingFactors: CredentialSecretsBlindingFactors,
+    blindedCredentialSecretsCorrectnessProof: BlindedCredentialSecretsCorrectnessProof
+}
+
+#[wasm_bindgen]
+pub struct CredentialSignature(cl::CredentialSignature);
+
+#[wasm_bindgen]
+#[allow(non_snake_case)]
+impl CredentialSignature {
+    pub fn extractIndex(&self) -> Option<u32> {
+        self.0.extract_index()
+    }
+}
+
+#[wasm_bindgen]
+pub struct SignatureCorrectnessProof(cl::SignatureCorrectnessProof);
+
+#[wasm_bindgen]
+#[allow(non_snake_case)]
+pub struct IssuedCredential {
+    credentialSignature: CredentialSignature,
+    signatureCorrectnessProof: SignatureCorrectnessProof
+}
+
+/// Convenience class for javascript. This provides a name-value pair structure
+/// instead of a tuple. The compiler complains about unused fields
+/// so allow(unused) is in place for now
+#[wasm_bindgen]
+#[allow(non_snake_case, unused)]
+pub struct IssuedCredentialWithRevocation {
+    issuedCredential: IssuedCredential,
+    delta: Option<RevocationRegistryDelta>
+}
+
+#[wasm_bindgen]
+#[derive(Serialize, Deserialize)]
+pub struct Tail(cl::Tail);
+
+#[wasm_bindgen]
+#[derive(Serialize, Deserialize)]
+pub struct RevocationPublicKey(cl::RevocationKeyPublic);
+
+#[wasm_bindgen]
+pub struct RevocationPrivateKey(cl::RevocationKeyPrivate);
+
+#[wasm_bindgen]
+#[derive(Serialize, Deserialize)]
+pub struct RevocationRegistry(cl::RevocationRegistry);
+
+#[wasm_bindgen]
+pub struct RevocationRegistryDelta(cl::RevocationRegistryDelta);
+
+#[wasm_bindgen]
+#[allow(non_snake_case)]
+impl RevocationRegistryDelta {
+    pub fn fromParts(rev_reg_from: &JsValue,",203,2019-03-20 02:58:22,https://api.github.com/repos/hyperledger/ursa/pulls/comments/267160925,https://github.com/hyperledger/ursa/pull/14#discussion_r267160925,mikelodder7
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,File doesn't exist.,0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-20 02:12:41,267164001,"@@ -0,0 +1,243 @@
+#!/usr/bin/perl",,2019-03-20 02:58:22,https://api.github.com/repos/hyperledger/ursa/pulls/comments/267164001,https://github.com/hyperledger/ursa/pull/14#discussion_r267164001,mikelodder7
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,Can you explain what is passed to Javascript and where in the code? The occurences i see only need a reference to seed or PrivateKey.,0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-20 05:40:44,267191527,"@@ -1,20 +1,53 @@
-use encoding::hex::bin2hex;
+use zeroize::Zeroize;
+use encoding::hex::{bin2hex, hex2bin};
+use std::ops::Drop;
+
+#[cfg(feature = ""wasm"")]
+use wasm_bindgen::prelude::*;
 
 // A private key instance.
 /// The underlying content is dependent on implementation.
+#[cfg_attr(feature = ""wasm"", wasm_bindgen)]
 pub struct PrivateKey(pub Vec<u8>);
 impl_bytearray!(PrivateKey);
 
+#[cfg_attr(feature = ""wasm"", wasm_bindgen)]
 pub struct PublicKey(pub Vec<u8>);
 impl_bytearray!(PublicKey);
 
+#[cfg_attr(feature = ""wasm"", wasm_bindgen)]
 pub struct SessionKey(pub Vec<u8>);
 impl_bytearray!(SessionKey);
 
+#[cfg_attr(feature = ""wasm"", wasm_bindgen)]
 pub struct MacKey(pub Vec<u8>);
 impl_bytearray!(MacKey);
 
-pub enum KeyPairOption<'a> {
+//#[cfg_attr(feature = ""wasm"", wasm_bindgen)]
+#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
+pub enum KeyGenOption {
     UseSeed(Vec<u8>),
-    FromSecretKey(&'a PrivateKey)
+    FromSecretKey(PrivateKey)
+}
+
+impl Drop for KeyGenOption {",36,2019-03-20 05:40:44,https://api.github.com/repos/hyperledger/ursa/pulls/comments/267191527,https://github.com/hyperledger/ursa/pull/14#discussion_r267191527,lovesh
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,This is not a struct,0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-20 05:41:21,267191635,"@@ -77,20 +112,20 @@ mod ecdsa_secp256k1sha256 {
             let pk = PublicKey(res.serialize().to_vec());
             Ok(pk)
         }
-        pub fn new() -> EcdsaSecp256k1Sha256Impl {
+        pub fn new() -> Self {
             EcdsaSecp256k1Sha256Impl(libsecp256k1::Secp256k1::new())
         }
-        pub fn keypair(&self, option: Option<KeyPairOption>) -> Result<(PublicKey, PrivateKey), CryptoError> {
+        pub fn keypair(&self, option: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError> {
             let sk = match option {
                     Some(o) => {
                         match o {
-                            KeyPairOption::UseSeed(seed) => {
+                            KeyGenOption::UseSeed(ref seed) => {
                                 let mut s = [0u8; PRIVATE_KEY_SIZE];
                                 let mut rng = ChaChaRng::from_seed(*array_ref!(seed.as_slice(), 0, 32));
                                 rng.fill_bytes(&mut s);
                                 libsecp256k1::key::SecretKey::from_slice(&s[..])?",,2019-03-20 05:41:22,https://api.github.com/repos/hyperledger/ursa/pulls/comments/267191635,https://github.com/hyperledger/ursa/pull/14#discussion_r267191635,lovesh
https://github.com/hyperledger/ursa/pull/14,https://github.com/hyperledger/ursa/pull/14,"I don't understand what you mean be ""WASM doesn't like byte arrays"". If it does not then why is thi function returning a byte array?
The reason for keeping uniformity is that it makes code less complicated.",0523c268ac1ba491fcf8cae17d2081bc6d2a0da7,2019-03-20 05:56:45,267193855,"@@ -1,209 +1,142 @@
 use wasm_bindgen::prelude::*;
 
 use bls;
-use errors::UrsaCryptoError;
-use errors::ToErrorCode;
-use serde;
+use super::convert_from_js;
 
-impl From<UrsaCryptoError> for JsValue {
-    fn from(err: UrsaCryptoError) -> JsValue {
-        let error_code = err.to_error_code();
-        JsValue::from_serde(&error_code).unwrap()
+#[wasm_bindgen]
+pub struct Generator(bls::Generator);
+
+#[wasm_bindgen]
+impl Generator {
+    pub fn new() -> Result<Generator, JsValue> {
+        Ok(Generator(maperr!(bls::Generator::new())))
     }
-}
 
-fn convert_from_js<T>(val: &JsValue) -> Result<T, UrsaCryptoError>
-where
-    for<'a> T: serde::Deserialize<'a>,
-{
-    match val.into_serde() {
-        Ok(unwrapped) => Ok(unwrapped),
-        Err(_) => Err(UrsaCryptoError::InvalidStructure(
-            ""Invalid argument"".to_string(),
-        )),
+    pub fn as_bytes(&self) -> Vec<u8> {
+        self.0.as_bytes().to_vec()",33,2019-03-20 05:56:46,https://api.github.com/repos/hyperledger/ursa/pulls/comments/267193855,https://github.com/hyperledger/ursa/pull/14#discussion_r267193855,lovesh
https://github.com/hyperledger/ursa/pull/13,https://github.com/hyperledger/ursa/pull/13,Shouldn't the `num-bigint` dependency be mentioned too?,54c3888942400d89bf53a33652a120367db80f73,2019-02-05 17:37:17,253970062,"@@ -1,30 +1,41 @@
-# Hyperledger Ursa
+<p align=""center""><h1>Hyperledger URSA</h1></p><br>
+---
+
+- [Introduction](#introduction)
+- [Features](#features)
+    - [Libursa](#Libursa)
+    - [Libzmix](#libzmix)
+- [Dependencies](#dependencies)
+- [Building from source](#building-from-source)
+- [Contributing](#contributing)
+
+# Introduction
 
 Ursa was created because people in the Hyperledger community realized that it would save time and effort and improve security if we all collaborated on our cryptographic code. Since cryptographic APIs are relatively straightforward to define, it would be possible for many different projects to utilize the same code without too much difficulty.
 
 First and foremost, we hope in the long run that Ursa provides open-source blockchain developers with reliable, secure, easy-to-use, and pluggable cryptographic implementations.
 
+# Features
 The major artifacts of Ursa are:
 - C-callable library interface
 - Rust crate
 
-All bugs, stories, and backlog for this project are managed through Hyperledger's Jira in project IS (note that regular Ursa tickets are in the URSA project). Also, join us on [Hyperledger Rocket.Chat](https://chat.hyperledger.org) at #ursa to discuss. The ursa group also meets biweekly on Wednesday's at 7 AM PST at https://zoom.us/my/hyperledger.community. The meeting notes are available [here](https://docs.google.com/document/d/1Z_8o8k_PFRM4XfZyv9jH1_-IyN0CsCMI2JlrGsCX378/edit).
-
-Major modifications to ursa are submitted as RFCs to the [Ursa RFC repo](https://github.com/hyperledger/ursa-rfcs). 
-
 Ursa is divided into two sub libraries: libursa and libzmix.
 
-Libursa is designed for cryptographic primitives like simple digital signatures, encryption schemes, and key exchange.
+## Libursa
+
+Designed for cryptographic primitives like simple digital signatures, encryption schemes, and key exchange.
 
-Libzmix offers a generic way to create zero-knowledge proofs, proving statements about multiple cryptographic building blocks, containing signatures, commitments, and verifiable encryption. Libzmix uses many of the building blocks found in Libursa.
+## Libzmix
+A generic way to create zero-knowledge proofs, proving statements about multiple cryptographic building blocks, containing signatures, commitments, and verifiable encryption. Libzmix uses many of the building blocks found in Libursa.
 
-## Dependencies
+# Dependencies
 
 Ursa and zmix use the following external dependencies:
 
-- libsodium 1.0.14 (Written in C)
-- openssl 1.1.0j or newer (Written in C)
-- libsecp256k1 (Written in C)
+- [libsodium 1.0.14](https://download.libsodium.org/libsodium/releases/old/libsodium-1.0.14.tar.gz) (Written in C)
+- [openssl 1.1.0j](https://www.openssl.org/source/openssl-1.1.0j.tar.gz) or newer (Written in C)
+- [libsecp256k1](https://github.com/bitcoin-core/secp256k1) (Written in C)",49,2019-02-13 16:48:21,https://api.github.com/repos/hyperledger/ursa/pulls/comments/253970062,https://github.com/hyperledger/ursa/pull/13#discussion_r253970062,lovesh
https://github.com/hyperledger/ursa/pull/13,https://github.com/hyperledger/ursa/pull/13,"@mikelodder7 ?
",54c3888942400d89bf53a33652a120367db80f73,2019-02-05 17:38:31,253970495,"@@ -1,30 +1,41 @@
-# Hyperledger Ursa
+<p align=""center""><h1>Hyperledger URSA</h1></p><br>
+---
+
+- [Introduction](#introduction)
+- [Features](#features)
+    - [Libursa](#Libursa)
+    - [Libzmix](#libzmix)
+- [Dependencies](#dependencies)
+- [Building from source](#building-from-source)
+- [Contributing](#contributing)
+
+# Introduction
 
 Ursa was created because people in the Hyperledger community realized that it would save time and effort and improve security if we all collaborated on our cryptographic code. Since cryptographic APIs are relatively straightforward to define, it would be possible for many different projects to utilize the same code without too much difficulty.
 
 First and foremost, we hope in the long run that Ursa provides open-source blockchain developers with reliable, secure, easy-to-use, and pluggable cryptographic implementations.
 
+# Features
 The major artifacts of Ursa are:
 - C-callable library interface
 - Rust crate
 
-All bugs, stories, and backlog for this project are managed through Hyperledger's Jira in project IS (note that regular Ursa tickets are in the URSA project). Also, join us on [Hyperledger Rocket.Chat](https://chat.hyperledger.org) at #ursa to discuss. The ursa group also meets biweekly on Wednesday's at 7 AM PST at https://zoom.us/my/hyperledger.community. The meeting notes are available [here](https://docs.google.com/document/d/1Z_8o8k_PFRM4XfZyv9jH1_-IyN0CsCMI2JlrGsCX378/edit).
-
-Major modifications to ursa are submitted as RFCs to the [Ursa RFC repo](https://github.com/hyperledger/ursa-rfcs). 
-
 Ursa is divided into two sub libraries: libursa and libzmix.
 
-Libursa is designed for cryptographic primitives like simple digital signatures, encryption schemes, and key exchange.
+## Libursa
+
+Designed for cryptographic primitives like simple digital signatures, encryption schemes, and key exchange.
 
-Libzmix offers a generic way to create zero-knowledge proofs, proving statements about multiple cryptographic building blocks, containing signatures, commitments, and verifiable encryption. Libzmix uses many of the building blocks found in Libursa.
+## Libzmix
+A generic way to create zero-knowledge proofs, proving statements about multiple cryptographic building blocks, containing signatures, commitments, and verifiable encryption. Libzmix uses many of the building blocks found in Libursa.
 
-## Dependencies
+# Dependencies
 
 Ursa and zmix use the following external dependencies:
 
-- libsodium 1.0.14 (Written in C)
-- openssl 1.1.0j or newer (Written in C)
-- libsecp256k1 (Written in C)
+- [libsodium 1.0.14](https://download.libsodium.org/libsodium/releases/old/libsodium-1.0.14.tar.gz) (Written in C)
+- [openssl 1.1.0j](https://www.openssl.org/source/openssl-1.1.0j.tar.gz) or newer (Written in C)
+- [libsecp256k1](https://github.com/bitcoin-core/secp256k1) (Written in C)",49,2019-02-13 16:48:21,https://api.github.com/repos/hyperledger/ursa/pulls/comments/253970495,https://github.com/hyperledger/ursa/pull/13#discussion_r253970495,cam-parra
https://github.com/hyperledger/ursa/pull/13,https://github.com/hyperledger/ursa/pull/13,No,54c3888942400d89bf53a33652a120367db80f73,2019-02-13 16:48:12,256486689,"@@ -1,30 +1,41 @@
-# Hyperledger Ursa
+<p align=""center""><h1>Hyperledger URSA</h1></p><br>
+---
+
+- [Introduction](#introduction)
+- [Features](#features)
+    - [Libursa](#Libursa)
+    - [Libzmix](#libzmix)
+- [Dependencies](#dependencies)
+- [Building from source](#building-from-source)
+- [Contributing](#contributing)
+
+# Introduction
 
 Ursa was created because people in the Hyperledger community realized that it would save time and effort and improve security if we all collaborated on our cryptographic code. Since cryptographic APIs are relatively straightforward to define, it would be possible for many different projects to utilize the same code without too much difficulty.
 
 First and foremost, we hope in the long run that Ursa provides open-source blockchain developers with reliable, secure, easy-to-use, and pluggable cryptographic implementations.
 
+# Features
 The major artifacts of Ursa are:
 - C-callable library interface
 - Rust crate
 
-All bugs, stories, and backlog for this project are managed through Hyperledger's Jira in project IS (note that regular Ursa tickets are in the URSA project). Also, join us on [Hyperledger Rocket.Chat](https://chat.hyperledger.org) at #ursa to discuss. The ursa group also meets biweekly on Wednesday's at 7 AM PST at https://zoom.us/my/hyperledger.community. The meeting notes are available [here](https://docs.google.com/document/d/1Z_8o8k_PFRM4XfZyv9jH1_-IyN0CsCMI2JlrGsCX378/edit).
-
-Major modifications to ursa are submitted as RFCs to the [Ursa RFC repo](https://github.com/hyperledger/ursa-rfcs). 
-
 Ursa is divided into two sub libraries: libursa and libzmix.
 
-Libursa is designed for cryptographic primitives like simple digital signatures, encryption schemes, and key exchange.
+## Libursa
+
+Designed for cryptographic primitives like simple digital signatures, encryption schemes, and key exchange.
 
-Libzmix offers a generic way to create zero-knowledge proofs, proving statements about multiple cryptographic building blocks, containing signatures, commitments, and verifiable encryption. Libzmix uses many of the building blocks found in Libursa.
+## Libzmix
+A generic way to create zero-knowledge proofs, proving statements about multiple cryptographic building blocks, containing signatures, commitments, and verifiable encryption. Libzmix uses many of the building blocks found in Libursa.
 
-## Dependencies
+# Dependencies
 
 Ursa and zmix use the following external dependencies:
 
-- libsodium 1.0.14 (Written in C)
-- openssl 1.1.0j or newer (Written in C)
-- libsecp256k1 (Written in C)
+- [libsodium 1.0.14](https://download.libsodium.org/libsodium/releases/old/libsodium-1.0.14.tar.gz) (Written in C)
+- [openssl 1.1.0j](https://www.openssl.org/source/openssl-1.1.0j.tar.gz) or newer (Written in C)
+- [libsecp256k1](https://github.com/bitcoin-core/secp256k1) (Written in C)",49,2019-02-13 16:48:21,https://api.github.com/repos/hyperledger/ursa/pulls/comments/256486689,https://github.com/hyperledger/ursa/pull/13#discussion_r256486689,mikelodder7
https://github.com/hyperledger/ursa/pull/11,https://github.com/hyperledger/ursa/pull/11,Lets have it be PedersenCommitmentBLS12_381Sha256G1,3435444eda1a9768b1be21e815a29592225b6a52,2019-01-25 15:28:03,251024268,"@@ -14,7 +12,7 @@ use utils::random::random_big_number;
 const SETUP_SEED_G1: &'static str = ""Hyperledger-Cryptolib-Pedersen-Commitment-BLS-12-381-G1"";
 const GROUP_G1_SIZE: usize = 2 * MODBYTES + 1;
 
-struct PedersenCommitmentBLS12_381_SHA256_G1 {}
+struct Pedersencommitmentbls12_381Sha256G1 {}
 ",12,2019-02-05 16:26:19,https://api.github.com/repos/hyperledger/ursa/pulls/comments/251024268,https://github.com/hyperledger/ursa/pull/11#discussion_r251024268,mikelodder7
https://github.com/hyperledger/ursa/pull/11,https://github.com/hyperledger/ursa/pull/11,Why not use `#[allow(unused_variables)]`. The reason compiler is complaining about the name is that the function is not implemented. What if we had a Parser trait and this was just one of the implementation. We would not want to change arg names.,3435444eda1a9768b1be21e815a29592225b6a52,2019-01-31 19:35:49,252810080,"@@ -3,7 +3,7 @@ pub mod spec;
 pub struct Parser {}
 
 impl Parser {
-    pub fn parse(proof_spec: &spec::ProofSpec, witness: &Witness) -> Result<Proof, ZKLError> {
+    pub fn parse(_proof_spec: &spec::ProofSpec, _witness: &Witness) -> Result<Proof, ZKLError> {",,2019-02-05 16:26:19,https://api.github.com/repos/hyperledger/ursa/pulls/comments/252810080,https://github.com/hyperledger/ursa/pull/11#discussion_r252810080,lovesh
https://github.com/hyperledger/ursa/pull/11,https://github.com/hyperledger/ursa/pull/11,Same comment as above,3435444eda1a9768b1be21e815a29592225b6a52,2019-01-31 19:36:05,252810177,"@@ -21,7 +21,7 @@ impl WitnessBuilder {
 pub struct Proof {}
 
 impl Proof {
-    pub fn verify(&self, proof_spec: &spec::ProofSpec) -> Result<bool, ZKLError> {
+    pub fn verify(&self, _proof_spec: &spec::ProofSpec) -> Result<bool, ZKLError> {",,2019-02-05 16:26:19,https://api.github.com/repos/hyperledger/ursa/pulls/comments/252810177,https://github.com/hyperledger/ursa/pull/11#discussion_r252810177,lovesh
https://github.com/hyperledger/ursa/pull/11,https://github.com/hyperledger/ursa/pull/11,"I agree with this. Making the changes. 
",3435444eda1a9768b1be21e815a29592225b6a52,2019-02-01 12:05:05,253027628,"@@ -3,7 +3,7 @@ pub mod spec;
 pub struct Parser {}
 
 impl Parser {
-    pub fn parse(proof_spec: &spec::ProofSpec, witness: &Witness) -> Result<Proof, ZKLError> {
+    pub fn parse(_proof_spec: &spec::ProofSpec, _witness: &Witness) -> Result<Proof, ZKLError> {",,2019-02-05 16:26:19,https://api.github.com/repos/hyperledger/ursa/pulls/comments/253027628,https://github.com/hyperledger/ursa/pull/11#discussion_r253027628,cam-parra
https://github.com/hyperledger/ursa/pull/11,https://github.com/hyperledger/ursa/pull/11,What about `_witness`?,3435444eda1a9768b1be21e815a29592225b6a52,2019-02-05 15:05:56,253901713,"@@ -2,8 +2,9 @@ pub mod spec;
 
 pub struct Parser {}
 
+#[allow(unused_variables)]
 impl Parser {
-    pub fn parse(_proof_spec: &spec::ProofSpec, _witness: &Witness) -> Result<Proof, ZKLError> {
+    pub fn parse(proof_spec: &spec::ProofSpec, _witness: &Witness) -> Result<Proof, ZKLError> {",,2019-02-05 16:26:19,https://api.github.com/repos/hyperledger/ursa/pulls/comments/253901713,https://github.com/hyperledger/ursa/pull/11#discussion_r253901713,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,"```
match prime::new(size)?.to_bigint() {
            Some(bn) => Ok(BigNumber { bn }),
            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
        }
```
This code can be encapsulated in a macro that takes a prime generator, i.e `prime` or `safe_prime` and an error message thus avoiding code duplication",68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 09:12:34,248970598,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {",,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/248970598,https://github.com/hyperledger/ursa/pull/8#discussion_r248970598,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,Why is this mask needed?,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 09:28:26,248975345,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();",,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/248975345,https://github.com/hyperledger/ursa/pull/8#discussion_r248975345,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,A comment explaning the need of applying the mask would be very helpful,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 09:30:57,248976109,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;",,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/248976109,https://github.com/hyperledger/ursa/pull/8#discussion_r248976109,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,Why not use `is_negative()`?,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 09:32:50,248976697,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {",,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/248976697,https://github.com/hyperledger/ursa/pull/8#discussion_r248976697,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,Can't this logic be abstracted in a macro taking `prime` or `safe_prime` and an error message as an argument?,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 09:33:42,248976893,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {",,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/248976893,https://github.com/hyperledger/ursa/pull/8#discussion_r248976893,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,I assume this is for deserializing a stored `BigInt`. Does this assume that the serialized `BigInt` was positive?,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 09:43:01,248979696,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {",157,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/248979696,https://github.com/hyperledger/ursa/pull/8#discussion_r248979696,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,"Shouldn't we have several methods like `sha2_256_hash`, `sha2_512_hash`, `sha3_256_hash`",68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 09:44:23,248980128,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from_bytes_be(Sign::Plus, bytes) })
+    }
+
+    pub fn to_dec(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(10))
+    }
+
+    pub fn to_hex(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(16).to_uppercase())
+    }
+
+    pub fn to_bytes(&self) -> Result<Vec<u8>, UrsaCryptoError> {
+        let (_, res) = self.bn.to_bytes_be();
+        Ok(res)
+    }
+
+    pub fn hash(data: &[u8]) -> Result<Vec<u8>, UrsaCryptoError> {",174,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/248980128,https://github.com/hyperledger/ursa/pull/8#discussion_r248980128,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,`modpow` [panics](https://docs.rs/num-bigint/0.2.2/num_bigint/struct.BigInt.html#method.modpow) if modulus is less than 1 so a check for `b` is needed. ,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 10:44:02,248998998,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from_bytes_be(Sign::Plus, bytes) })
+    }
+
+    pub fn to_dec(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(10))
+    }
+
+    pub fn to_hex(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(16).to_uppercase())
+    }
+
+    pub fn to_bytes(&self) -> Result<Vec<u8>, UrsaCryptoError> {
+        let (_, res) = self.bn.to_bytes_be();
+        Ok(res)
+    }
+
+    pub fn hash(data: &[u8]) -> Result<Vec<u8>, UrsaCryptoError> {
+        digest(DigestAlgorithm::Sha2_256, data).map_err(|e| UrsaCryptoError::InvalidStructure(e.to_string()))
+    }
+
+    pub fn add(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn + &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sub(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn - &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sqr(&self, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &self.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mul(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_mul(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        //TODO: Use montgomery reduction
+        let res = (&self.bn * &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_sub(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = (&self.bn - &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn div(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn / &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn add_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn += w;
+        Ok(self)
+    }
+
+    pub fn sub_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn -= w;
+        Ok(self)
+    }
+
+    pub fn mul_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn *= w;
+        Ok(self)
+    }
+
+    pub fn div_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn /= w;
+        Ok(self)
+    }
+
+    pub fn mod_exp(&self, a: &BigNumber, b: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if a.is_negative() {",245,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/248998998,https://github.com/hyperledger/ursa/pull/8#discussion_r248998998,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,Check needed to ensure `a` > 0,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 10:45:47,248999516,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from_bytes_be(Sign::Plus, bytes) })
+    }
+
+    pub fn to_dec(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(10))
+    }
+
+    pub fn to_hex(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(16).to_uppercase())
+    }
+
+    pub fn to_bytes(&self) -> Result<Vec<u8>, UrsaCryptoError> {
+        let (_, res) = self.bn.to_bytes_be();
+        Ok(res)
+    }
+
+    pub fn hash(data: &[u8]) -> Result<Vec<u8>, UrsaCryptoError> {
+        digest(DigestAlgorithm::Sha2_256, data).map_err(|e| UrsaCryptoError::InvalidStructure(e.to_string()))
+    }
+
+    pub fn add(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn + &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sub(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn - &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sqr(&self, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &self.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mul(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_mul(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        //TODO: Use montgomery reduction
+        let res = (&self.bn * &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_sub(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = (&self.bn - &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn div(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn / &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn add_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn += w;
+        Ok(self)
+    }
+
+    pub fn sub_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn -= w;
+        Ok(self)
+    }
+
+    pub fn mul_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn *= w;
+        Ok(self)
+    }
+
+    pub fn div_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn /= w;
+        Ok(self)
+    }
+
+    pub fn mod_exp(&self, a: &BigNumber, b: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if a.is_negative() {
+            let res = self.inverse(&b, _ctx)?;
+            let a = a.set_negative(false)?;
+            Ok(BigNumber{ bn: res.bn.modpow(&a.bn, &b.bn) })
+        } else {
+            let res = self.bn.modpow(&a.bn, &b.bn);
+            Ok(BigNumber { bn: res })
+        }
+    }
+
+    pub fn modulus(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn % &a.bn;",,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/248999516,https://github.com/hyperledger/ursa/pull/8#discussion_r248999516,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,I think it makes to add the above check and use this method instead of `%` in oher places in the code,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 10:52:00,249001237,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from_bytes_be(Sign::Plus, bytes) })
+    }
+
+    pub fn to_dec(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(10))
+    }
+
+    pub fn to_hex(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(16).to_uppercase())
+    }
+
+    pub fn to_bytes(&self) -> Result<Vec<u8>, UrsaCryptoError> {
+        let (_, res) = self.bn.to_bytes_be();
+        Ok(res)
+    }
+
+    pub fn hash(data: &[u8]) -> Result<Vec<u8>, UrsaCryptoError> {
+        digest(DigestAlgorithm::Sha2_256, data).map_err(|e| UrsaCryptoError::InvalidStructure(e.to_string()))
+    }
+
+    pub fn add(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn + &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sub(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn - &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sqr(&self, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &self.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mul(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_mul(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        //TODO: Use montgomery reduction
+        let res = (&self.bn * &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_sub(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = (&self.bn - &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn div(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn / &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn add_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn += w;
+        Ok(self)
+    }
+
+    pub fn sub_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn -= w;
+        Ok(self)
+    }
+
+    pub fn mul_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn *= w;
+        Ok(self)
+    }
+
+    pub fn div_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn /= w;
+        Ok(self)
+    }
+
+    pub fn mod_exp(&self, a: &BigNumber, b: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if a.is_negative() {
+            let res = self.inverse(&b, _ctx)?;
+            let a = a.set_negative(false)?;
+            Ok(BigNumber{ bn: res.bn.modpow(&a.bn, &b.bn) })
+        } else {
+            let res = self.bn.modpow(&a.bn, &b.bn);
+            Ok(BigNumber { bn: res })
+        }
+    }
+
+    pub fn modulus(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn % &a.bn;",,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249001237,https://github.com/hyperledger/ursa/pull/8#discussion_r249001237,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,a negative `n` will result in a panic,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 11:00:13,249003617,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from_bytes_be(Sign::Plus, bytes) })
+    }
+
+    pub fn to_dec(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(10))
+    }
+
+    pub fn to_hex(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(16).to_uppercase())
+    }
+
+    pub fn to_bytes(&self) -> Result<Vec<u8>, UrsaCryptoError> {
+        let (_, res) = self.bn.to_bytes_be();
+        Ok(res)
+    }
+
+    pub fn hash(data: &[u8]) -> Result<Vec<u8>, UrsaCryptoError> {
+        digest(DigestAlgorithm::Sha2_256, data).map_err(|e| UrsaCryptoError::InvalidStructure(e.to_string()))
+    }
+
+    pub fn add(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn + &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sub(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn - &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sqr(&self, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &self.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mul(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_mul(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        //TODO: Use montgomery reduction
+        let res = (&self.bn * &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_sub(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = (&self.bn - &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn div(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn / &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn add_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn += w;
+        Ok(self)
+    }
+
+    pub fn sub_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn -= w;
+        Ok(self)
+    }
+
+    pub fn mul_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn *= w;
+        Ok(self)
+    }
+
+    pub fn div_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn /= w;
+        Ok(self)
+    }
+
+    pub fn mod_exp(&self, a: &BigNumber, b: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if a.is_negative() {
+            let res = self.inverse(&b, _ctx)?;
+            let a = a.set_negative(false)?;
+            Ok(BigNumber{ bn: res.bn.modpow(&a.bn, &b.bn) })
+        } else {
+            let res = self.bn.modpow(&a.bn, &b.bn);
+            Ok(BigNumber { bn: res })
+        }
+    }
+
+    pub fn modulus(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn % &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn exp(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if self.bn.bits() == 0 {
+            return Ok(BigNumber::default())
+        } else if a.bn.is_one() {
+            return Ok(self.clone()?)
+        }
+
+        match a.bn.to_u64() {
+            Some(num) => Ok(BigNumber { bn: self.bn.pow(num) }),
+            None => Err(UrsaCryptoError::InvalidStructure(""'a' cannot be help in u64"".to_string()))
+        }
+    }
+
+    pub fn inverse(&self, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if n.bn.is_one() ||
+           n.bn.is_zero() {
+            return Err(UrsaCryptoError::InvalidStructure(""Invalid modulus"".to_string()))
+        }
+
+        // Euclid's extended algorithm, Bzout coefficient of `n` is not needed
+        //n is either prime or coprime
+        //
+        //function inverse(a, n)
+        //    t := 0;     newt := 1;
+        //    r := n;     newr := a;
+        //    while newr  0
+        //        quotient := r div newr
+        //        (t, newt) := (newt, t - quotient * newt)
+        //        (r, newr) := (newr, r - quotient * newr)
+        //    if r > 1 then return ""a is not invertible""
+        //    if t < 0 then t := t + n
+        //    return t
+        //
+        let (mut t, mut new_t) = (BigInt::zero(), BigInt::one());
+        let (mut r, mut new_r) = (n.bn.clone(), self.bn.clone());
+
+        while !new_r.is_zero() {
+            let quotient = &r / &new_r;
+            let temp_t = t.clone();
+            let temp_new_t = new_t.clone();
+
+            t = temp_new_t.clone();
+            new_t = temp_t - &quotient * temp_new_t;
+
+            let temp_r = r.clone();
+            let temp_new_r = new_r.clone();
+
+            r = temp_new_r.clone();
+            new_r = temp_r - quotient * temp_new_r;
+        }
+        if r > BigInt::one() {
+            return Err(UrsaCryptoError::InvalidStructure(""Not invertible"".to_string()));
+        } else if t < BigInt::zero() {
+            t += n.bn.clone()
+        }
+
+        Ok(BigNumber { bn: t })
+    }
+
+    pub fn set_negative(&self, negative: bool) -> Result<BigNumber, UrsaCryptoError> {
+        match (self.bn < BigInt::zero(), negative) {
+            (true, true) => Ok(BigNumber { bn: self.bn.clone() }),
+            (false, false) => Ok(BigNumber { bn: self.bn.clone() }),
+            (true, false) => Ok(BigNumber { bn: -self.bn.clone() }),
+            (false, true) => Ok(BigNumber { bn: -self.bn.clone() }),
+        }
+    }
+
+    pub fn is_negative(&self) -> bool {
+        self.bn.is_negative()
+    }
+
+    pub fn increment(&self) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: &self.bn + 1 })
+    }
+
+    pub fn decrement(&self) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: &self.bn - 1 })
+    }
+
+    pub fn lshift1(&self) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: &self.bn << 1 })
+    }
+
+    pub fn rshift1(&self) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: &self.bn >> 1 })
+    }
+
+    pub fn rshift(&self, n: i32) -> Result<BigNumber, UrsaCryptoError> {
+        let n = n as usize;",361,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249003617,https://github.com/hyperledger/ursa/pull/8#discussion_r249003617,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,"`p` can be negative, better to add the negative check in `modulus` and use the method.",68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 11:01:02,249003832,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from_bytes_be(Sign::Plus, bytes) })
+    }
+
+    pub fn to_dec(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(10))
+    }
+
+    pub fn to_hex(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(16).to_uppercase())
+    }
+
+    pub fn to_bytes(&self) -> Result<Vec<u8>, UrsaCryptoError> {
+        let (_, res) = self.bn.to_bytes_be();
+        Ok(res)
+    }
+
+    pub fn hash(data: &[u8]) -> Result<Vec<u8>, UrsaCryptoError> {
+        digest(DigestAlgorithm::Sha2_256, data).map_err(|e| UrsaCryptoError::InvalidStructure(e.to_string()))
+    }
+
+    pub fn add(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn + &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sub(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn - &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sqr(&self, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &self.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mul(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_mul(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        //TODO: Use montgomery reduction
+        let res = (&self.bn * &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_sub(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = (&self.bn - &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn div(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn / &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn add_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn += w;
+        Ok(self)
+    }
+
+    pub fn sub_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn -= w;
+        Ok(self)
+    }
+
+    pub fn mul_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn *= w;
+        Ok(self)
+    }
+
+    pub fn div_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn /= w;
+        Ok(self)
+    }
+
+    pub fn mod_exp(&self, a: &BigNumber, b: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if a.is_negative() {
+            let res = self.inverse(&b, _ctx)?;
+            let a = a.set_negative(false)?;
+            Ok(BigNumber{ bn: res.bn.modpow(&a.bn, &b.bn) })
+        } else {
+            let res = self.bn.modpow(&a.bn, &b.bn);
+            Ok(BigNumber { bn: res })
+        }
+    }
+
+    pub fn modulus(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn % &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn exp(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if self.bn.bits() == 0 {
+            return Ok(BigNumber::default())
+        } else if a.bn.is_one() {
+            return Ok(self.clone()?)
+        }
+
+        match a.bn.to_u64() {
+            Some(num) => Ok(BigNumber { bn: self.bn.pow(num) }),
+            None => Err(UrsaCryptoError::InvalidStructure(""'a' cannot be help in u64"".to_string()))
+        }
+    }
+
+    pub fn inverse(&self, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if n.bn.is_one() ||
+           n.bn.is_zero() {
+            return Err(UrsaCryptoError::InvalidStructure(""Invalid modulus"".to_string()))
+        }
+
+        // Euclid's extended algorithm, Bzout coefficient of `n` is not needed
+        //n is either prime or coprime
+        //
+        //function inverse(a, n)
+        //    t := 0;     newt := 1;
+        //    r := n;     newr := a;
+        //    while newr  0
+        //        quotient := r div newr
+        //        (t, newt) := (newt, t - quotient * newt)
+        //        (r, newr) := (newr, r - quotient * newr)
+        //    if r > 1 then return ""a is not invertible""
+        //    if t < 0 then t := t + n
+        //    return t
+        //
+        let (mut t, mut new_t) = (BigInt::zero(), BigInt::one());
+        let (mut r, mut new_r) = (n.bn.clone(), self.bn.clone());
+
+        while !new_r.is_zero() {
+            let quotient = &r / &new_r;
+            let temp_t = t.clone();
+            let temp_new_t = new_t.clone();
+
+            t = temp_new_t.clone();
+            new_t = temp_t - &quotient * temp_new_t;
+
+            let temp_r = r.clone();
+            let temp_new_r = new_r.clone();
+
+            r = temp_new_r.clone();
+            new_r = temp_r - quotient * temp_new_r;
+        }
+        if r > BigInt::one() {
+            return Err(UrsaCryptoError::InvalidStructure(""Not invertible"".to_string()));
+        } else if t < BigInt::zero() {
+            t += n.bn.clone()
+        }
+
+        Ok(BigNumber { bn: t })
+    }
+
+    pub fn set_negative(&self, negative: bool) -> Result<BigNumber, UrsaCryptoError> {
+        match (self.bn < BigInt::zero(), negative) {
+            (true, true) => Ok(BigNumber { bn: self.bn.clone() }),
+            (false, false) => Ok(BigNumber { bn: self.bn.clone() }),
+            (true, false) => Ok(BigNumber { bn: -self.bn.clone() }),
+            (false, true) => Ok(BigNumber { bn: -self.bn.clone() }),
+        }
+    }
+
+    pub fn is_negative(&self) -> bool {
+        self.bn.is_negative()
+    }
+
+    pub fn increment(&self) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: &self.bn + 1 })
+    }
+
+    pub fn decrement(&self) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: &self.bn - 1 })
+    }
+
+    pub fn lshift1(&self) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: &self.bn << 1 })
+    }
+
+    pub fn rshift1(&self) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: &self.bn >> 1 })
+    }
+
+    pub fn rshift(&self, n: i32) -> Result<BigNumber, UrsaCryptoError> {
+        let n = n as usize;
+        Ok(BigNumber { bn: &self.bn >> n })
+    }
+
+    pub fn mod_div(&self, b: &BigNumber, p: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        //(a * (1/b mod p) mod p)
+        let res = (&self.bn * b.inverse(p, _ctx)?.bn) % &p.bn;",,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249003832,https://github.com/hyperledger/ursa/pull/8#discussion_r249003832,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,Error message seems odd,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 11:07:20,249005526,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from_bytes_be(Sign::Plus, bytes) })
+    }
+
+    pub fn to_dec(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(10))
+    }
+
+    pub fn to_hex(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(16).to_uppercase())
+    }
+
+    pub fn to_bytes(&self) -> Result<Vec<u8>, UrsaCryptoError> {
+        let (_, res) = self.bn.to_bytes_be();
+        Ok(res)
+    }
+
+    pub fn hash(data: &[u8]) -> Result<Vec<u8>, UrsaCryptoError> {
+        digest(DigestAlgorithm::Sha2_256, data).map_err(|e| UrsaCryptoError::InvalidStructure(e.to_string()))
+    }
+
+    pub fn add(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn + &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sub(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn - &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sqr(&self, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &self.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mul(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_mul(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        //TODO: Use montgomery reduction
+        let res = (&self.bn * &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_sub(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = (&self.bn - &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn div(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn / &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn add_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn += w;
+        Ok(self)
+    }
+
+    pub fn sub_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn -= w;
+        Ok(self)
+    }
+
+    pub fn mul_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn *= w;
+        Ok(self)
+    }
+
+    pub fn div_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn /= w;
+        Ok(self)
+    }
+
+    pub fn mod_exp(&self, a: &BigNumber, b: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if a.is_negative() {
+            let res = self.inverse(&b, _ctx)?;
+            let a = a.set_negative(false)?;
+            Ok(BigNumber{ bn: res.bn.modpow(&a.bn, &b.bn) })
+        } else {
+            let res = self.bn.modpow(&a.bn, &b.bn);
+            Ok(BigNumber { bn: res })
+        }
+    }
+
+    pub fn modulus(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn % &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn exp(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if self.bn.bits() == 0 {
+            return Ok(BigNumber::default())
+        } else if a.bn.is_one() {
+            return Ok(self.clone()?)
+        }
+
+        match a.bn.to_u64() {
+            Some(num) => Ok(BigNumber { bn: self.bn.pow(num) }),
+            None => Err(UrsaCryptoError::InvalidStructure(""'a' cannot be help in u64"".to_string()))",,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249005526,https://github.com/hyperledger/ursa/pull/8#discussion_r249005526,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,Check for `a` != 0,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 11:11:58,249006788,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from_bytes_be(Sign::Plus, bytes) })
+    }
+
+    pub fn to_dec(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(10))
+    }
+
+    pub fn to_hex(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(16).to_uppercase())
+    }
+
+    pub fn to_bytes(&self) -> Result<Vec<u8>, UrsaCryptoError> {
+        let (_, res) = self.bn.to_bytes_be();
+        Ok(res)
+    }
+
+    pub fn hash(data: &[u8]) -> Result<Vec<u8>, UrsaCryptoError> {
+        digest(DigestAlgorithm::Sha2_256, data).map_err(|e| UrsaCryptoError::InvalidStructure(e.to_string()))
+    }
+
+    pub fn add(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn + &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sub(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn - &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sqr(&self, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &self.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mul(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_mul(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        //TODO: Use montgomery reduction
+        let res = (&self.bn * &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_sub(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = (&self.bn - &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn div(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn / &a.bn;",,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249006788,https://github.com/hyperledger/ursa/pull/8#discussion_r249006788,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,"Why the comment about ""Bzout coefficient""? Do you intend to have separate method when `n` is coprime to `self`",68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 12:14:36,249022699,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from_bytes_be(Sign::Plus, bytes) })
+    }
+
+    pub fn to_dec(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(10))
+    }
+
+    pub fn to_hex(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(16).to_uppercase())
+    }
+
+    pub fn to_bytes(&self) -> Result<Vec<u8>, UrsaCryptoError> {
+        let (_, res) = self.bn.to_bytes_be();
+        Ok(res)
+    }
+
+    pub fn hash(data: &[u8]) -> Result<Vec<u8>, UrsaCryptoError> {
+        digest(DigestAlgorithm::Sha2_256, data).map_err(|e| UrsaCryptoError::InvalidStructure(e.to_string()))
+    }
+
+    pub fn add(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn + &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sub(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn - &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sqr(&self, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &self.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mul(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_mul(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        //TODO: Use montgomery reduction
+        let res = (&self.bn * &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_sub(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = (&self.bn - &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn div(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn / &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn add_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn += w;
+        Ok(self)
+    }
+
+    pub fn sub_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn -= w;
+        Ok(self)
+    }
+
+    pub fn mul_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn *= w;
+        Ok(self)
+    }
+
+    pub fn div_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn /= w;
+        Ok(self)
+    }
+
+    pub fn mod_exp(&self, a: &BigNumber, b: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if a.is_negative() {
+            let res = self.inverse(&b, _ctx)?;
+            let a = a.set_negative(false)?;
+            Ok(BigNumber{ bn: res.bn.modpow(&a.bn, &b.bn) })
+        } else {
+            let res = self.bn.modpow(&a.bn, &b.bn);
+            Ok(BigNumber { bn: res })
+        }
+    }
+
+    pub fn modulus(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn % &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn exp(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if self.bn.bits() == 0 {
+            return Ok(BigNumber::default())
+        } else if a.bn.is_one() {
+            return Ok(self.clone()?)
+        }
+
+        match a.bn.to_u64() {
+            Some(num) => Ok(BigNumber { bn: self.bn.pow(num) }),
+            None => Err(UrsaCryptoError::InvalidStructure(""'a' cannot be help in u64"".to_string()))
+        }
+    }
+
+    pub fn inverse(&self, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if n.bn.is_one() ||
+           n.bn.is_zero() {
+            return Err(UrsaCryptoError::InvalidStructure(""Invalid modulus"".to_string()))
+        }
+
+        // Euclid's extended algorithm, Bzout coefficient of `n` is not needed",291,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249022699,https://github.com/hyperledger/ursa/pull/8#discussion_r249022699,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,`_ctx` is unused,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 12:21:50,249024493,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from_bytes_be(Sign::Plus, bytes) })
+    }
+
+    pub fn to_dec(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(10))
+    }
+
+    pub fn to_hex(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(16).to_uppercase())
+    }
+
+    pub fn to_bytes(&self) -> Result<Vec<u8>, UrsaCryptoError> {
+        let (_, res) = self.bn.to_bytes_be();
+        Ok(res)
+    }
+
+    pub fn hash(data: &[u8]) -> Result<Vec<u8>, UrsaCryptoError> {
+        digest(DigestAlgorithm::Sha2_256, data).map_err(|e| UrsaCryptoError::InvalidStructure(e.to_string()))
+    }
+
+    pub fn add(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn + &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sub(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn - &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sqr(&self, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &self.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mul(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_mul(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        //TODO: Use montgomery reduction
+        let res = (&self.bn * &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_sub(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = (&self.bn - &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn div(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn / &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn add_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn += w;
+        Ok(self)
+    }
+
+    pub fn sub_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn -= w;
+        Ok(self)
+    }
+
+    pub fn mul_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn *= w;
+        Ok(self)
+    }
+
+    pub fn div_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn /= w;
+        Ok(self)
+    }
+
+    pub fn mod_exp(&self, a: &BigNumber, b: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if a.is_negative() {
+            let res = self.inverse(&b, _ctx)?;
+            let a = a.set_negative(false)?;
+            Ok(BigNumber{ bn: res.bn.modpow(&a.bn, &b.bn) })
+        } else {
+            let res = self.bn.modpow(&a.bn, &b.bn);
+            Ok(BigNumber { bn: res })
+        }
+    }
+
+    pub fn modulus(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn % &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn exp(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if self.bn.bits() == 0 {
+            return Ok(BigNumber::default())
+        } else if a.bn.is_one() {
+            return Ok(self.clone()?)
+        }
+
+        match a.bn.to_u64() {
+            Some(num) => Ok(BigNumber { bn: self.bn.pow(num) }),
+            None => Err(UrsaCryptoError::InvalidStructure(""'a' cannot be help in u64"".to_string()))
+        }
+    }
+
+    pub fn inverse(&self, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {",284,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249024493,https://github.com/hyperledger/ursa/pull/8#discussion_r249024493,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,`_ctx` is unused.,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 12:48:08,249030910,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {",105,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249030910,https://github.com/hyperledger/ursa/pull/8#discussion_r249030910,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,`_ctx` is unused.,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 12:48:17,249030934,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {",109,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249030934,https://github.com/hyperledger/ursa/pull/8#discussion_r249030934,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,`_ctx` is unused in above methods,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 12:49:31,249031266,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from_bytes_be(Sign::Plus, bytes) })
+    }
+
+    pub fn to_dec(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(10))
+    }
+
+    pub fn to_hex(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(16).to_uppercase())
+    }
+
+    pub fn to_bytes(&self) -> Result<Vec<u8>, UrsaCryptoError> {
+        let (_, res) = self.bn.to_bytes_be();
+        Ok(res)
+    }
+
+    pub fn hash(data: &[u8]) -> Result<Vec<u8>, UrsaCryptoError> {
+        digest(DigestAlgorithm::Sha2_256, data).map_err(|e| UrsaCryptoError::InvalidStructure(e.to_string()))
+    }
+
+    pub fn add(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn + &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sub(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn - &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sqr(&self, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &self.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mul(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_mul(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        //TODO: Use montgomery reduction
+        let res = (&self.bn * &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_sub(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = (&self.bn - &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn div(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn / &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+",215,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249031266,https://github.com/hyperledger/ursa/pull/8#discussion_r249031266,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,Big Primes have the highest two bits set and the lowest bits set. The mask sets those bits.,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 15:22:32,249080178,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();",,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249080178,https://github.com/hyperledger/ursa/pull/8#discussion_r249080178,mikelodder7
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,"Yes but like openssl it will handle the negative case too if the number starts with ""-""",68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 15:44:08,249088086,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {",157,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249088086,https://github.com/hyperledger/ursa/pull/8#discussion_r249088086,mikelodder7
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,Later but not now.,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 15:44:22,249088178,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from_bytes_be(Sign::Plus, bytes) })
+    }
+
+    pub fn to_dec(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(10))
+    }
+
+    pub fn to_hex(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(16).to_uppercase())
+    }
+
+    pub fn to_bytes(&self) -> Result<Vec<u8>, UrsaCryptoError> {
+        let (_, res) = self.bn.to_bytes_be();
+        Ok(res)
+    }
+
+    pub fn hash(data: &[u8]) -> Result<Vec<u8>, UrsaCryptoError> {",174,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249088178,https://github.com/hyperledger/ursa/pull/8#discussion_r249088178,mikelodder7
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,Ideally we should remove this and call the hash module.,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 15:48:13,249089657,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from_bytes_be(Sign::Plus, bytes) })
+    }
+
+    pub fn to_dec(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(10))
+    }
+
+    pub fn to_hex(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(16).to_uppercase())
+    }
+
+    pub fn to_bytes(&self) -> Result<Vec<u8>, UrsaCryptoError> {
+        let (_, res) = self.bn.to_bytes_be();
+        Ok(res)
+    }
+
+    pub fn hash(data: &[u8]) -> Result<Vec<u8>, UrsaCryptoError> {",174,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249089657,https://github.com/hyperledger/ursa/pull/8#discussion_r249089657,mikelodder7
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,"To be clear about the method. If we didn't have to handle coprime modulus then we could use other tricks modexp(base, modulus - 2, modulus)",68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 18:25:43,249141073,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from_bytes_be(Sign::Plus, bytes) })
+    }
+
+    pub fn to_dec(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(10))
+    }
+
+    pub fn to_hex(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(16).to_uppercase())
+    }
+
+    pub fn to_bytes(&self) -> Result<Vec<u8>, UrsaCryptoError> {
+        let (_, res) = self.bn.to_bytes_be();
+        Ok(res)
+    }
+
+    pub fn hash(data: &[u8]) -> Result<Vec<u8>, UrsaCryptoError> {
+        digest(DigestAlgorithm::Sha2_256, data).map_err(|e| UrsaCryptoError::InvalidStructure(e.to_string()))
+    }
+
+    pub fn add(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn + &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sub(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn - &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sqr(&self, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &self.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mul(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_mul(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        //TODO: Use montgomery reduction
+        let res = (&self.bn * &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_sub(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = (&self.bn - &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn div(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn / &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn add_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn += w;
+        Ok(self)
+    }
+
+    pub fn sub_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn -= w;
+        Ok(self)
+    }
+
+    pub fn mul_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn *= w;
+        Ok(self)
+    }
+
+    pub fn div_word(&mut self, w: u32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        self.bn /= w;
+        Ok(self)
+    }
+
+    pub fn mod_exp(&self, a: &BigNumber, b: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if a.is_negative() {
+            let res = self.inverse(&b, _ctx)?;
+            let a = a.set_negative(false)?;
+            Ok(BigNumber{ bn: res.bn.modpow(&a.bn, &b.bn) })
+        } else {
+            let res = self.bn.modpow(&a.bn, &b.bn);
+            Ok(BigNumber { bn: res })
+        }
+    }
+
+    pub fn modulus(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn % &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn exp(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if self.bn.bits() == 0 {
+            return Ok(BigNumber::default())
+        } else if a.bn.is_one() {
+            return Ok(self.clone()?)
+        }
+
+        match a.bn.to_u64() {
+            Some(num) => Ok(BigNumber { bn: self.bn.pow(num) }),
+            None => Err(UrsaCryptoError::InvalidStructure(""'a' cannot be help in u64"".to_string()))
+        }
+    }
+
+    pub fn inverse(&self, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        if n.bn.is_one() ||
+           n.bn.is_zero() {
+            return Err(UrsaCryptoError::InvalidStructure(""Invalid modulus"".to_string()))
+        }
+
+        // Euclid's extended algorithm, Bzout coefficient of `n` is not needed",291,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249141073,https://github.com/hyperledger/ursa/pull/8#discussion_r249141073,mikelodder7
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,Didn't want to change the BigNumber API yet. Future work,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-18 18:26:12,249141215,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from_bytes_be(Sign::Plus, bytes) })
+    }
+
+    pub fn to_dec(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(10))
+    }
+
+    pub fn to_hex(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(16).to_uppercase())
+    }
+
+    pub fn to_bytes(&self) -> Result<Vec<u8>, UrsaCryptoError> {
+        let (_, res) = self.bn.to_bytes_be();
+        Ok(res)
+    }
+
+    pub fn hash(data: &[u8]) -> Result<Vec<u8>, UrsaCryptoError> {
+        digest(DigestAlgorithm::Sha2_256, data).map_err(|e| UrsaCryptoError::InvalidStructure(e.to_string()))
+    }
+
+    pub fn add(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn + &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sub(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn - &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sqr(&self, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &self.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mul(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_mul(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        //TODO: Use montgomery reduction
+        let res = (&self.bn * &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_sub(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = (&self.bn - &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn div(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn / &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+",215,2019-01-18 18:33:45,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249141215,https://github.com/hyperledger/ursa/pull/8#discussion_r249141215,mikelodder7
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,"`BigUint::one()` will create a new `BigUint` each time, why not call it once outside the loop, assign the result to a variable and use the variable inside the loop?",68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-21 06:17:07,249333931,"@@ -0,0 +1,696 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+macro_rules! prime_generation {
+    ($f:ident, $size:ident, $msg:expr) => {
+        match $f::new($size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure($msg.to_string()))
+        }
+    };
+}
+
+macro_rules! prime_check {
+    ($f:ident, $value:expr, $msg:expr) => {
+        if $value.is_negative() {
+            Ok(false)
+        } else {
+            match $value.bn.to_biguint() {
+                Some(bn) => Ok($f::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure($msg.to_string()))
+            }
+        }
+    };
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        prime_generation!(prime, size, ""Unable to generate prime"")
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        prime_generation!(safe_prime, size, ""Unable to generate safe prime"")
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let mut start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let mut end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        if start > end {
+            let temp = start;
+            start = end.clone();
+            end = temp;
+        }
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= BigUint::one();",90,2019-01-21 06:17:07,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249333931,https://github.com/hyperledger/ursa/pull/8#discussion_r249333931,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,When I view the `asm` code using cargo-asm it appears to be optimized and only create it once anyway.,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-21 16:03:18,249504690,"@@ -0,0 +1,696 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+macro_rules! prime_generation {
+    ($f:ident, $size:ident, $msg:expr) => {
+        match $f::new($size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure($msg.to_string()))
+        }
+    };
+}
+
+macro_rules! prime_check {
+    ($f:ident, $value:expr, $msg:expr) => {
+        if $value.is_negative() {
+            Ok(false)
+        } else {
+            match $value.bn.to_biguint() {
+                Some(bn) => Ok($f::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure($msg.to_string()))
+            }
+        }
+    };
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        prime_generation!(prime, size, ""Unable to generate prime"")
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        prime_generation!(safe_prime, size, ""Unable to generate safe prime"")
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let mut start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let mut end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        if start > end {
+            let temp = start;
+            start = end.clone();
+            end = temp;
+        }
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= BigUint::one();",90,2019-01-21 16:03:18,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249504690,https://github.com/hyperledger/ursa/pull/8#discussion_r249504690,mikelodder7
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,Ok,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-21 16:26:34,249513139,"@@ -0,0 +1,632 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime"".to_string()))
+        }
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        match safe_prime::new(size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate safe prime"".to_string()))
+        }
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        let bits = (&end -  &start).bits();
+        let mask = (BigUint::from(3u8) << (bits - 2)) | BigUint::one();
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= &mask;
+
+            if prime::check(&res) {
+                debug!(""Found prime in {} iteration"", iteration);
+                break;
+            }
+            iteration += 1;
+        }
+
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""Unable to generate prime in range"".to_string()))
+        }
+    }
+
+    pub fn is_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.is_negative() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn is_safe_prime(&self, _ctx: Option<&mut BigNumberContext>) -> Result<bool, UrsaCryptoError> {
+        if self.bn < BigInt::zero() {
+            Ok(false)
+        } else {
+            match self.bn.to_biguint() {
+                Some(bn) => Ok(safe_prime::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure(""An error in is_safe_prime"".to_string()))
+            }
+        }
+    }
+
+    pub fn rand(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_biguint(size).to_bigint();
+        Ok(BigNumber { bn: res.unwrap() })
+    }
+
+    pub fn rand_range(&self) -> Result<BigNumber, UrsaCryptoError> {
+        let mut rng = OsRng::new()?;
+        let res = rng.gen_bigint_range(&BigInt::zero(), &self.bn);
+        match res.to_bigint() {
+            Some(bn) => Ok(BigNumber{bn}),
+            None => Err(UrsaCryptoError::InvalidStructure(""An error in rand_range"".to_string()))
+        }
+    }
+
+    pub fn num_bits(&self) -> Result<i32, UrsaCryptoError> {
+        Ok(self.bn.bits() as i32)
+    }
+
+    pub fn is_bit_set(&self, n: i32) -> Result<bool, UrsaCryptoError> {
+        let bits = n as usize;
+        let res = &self.bn >> bits;
+        Ok(res.is_odd())
+    }
+
+    pub fn set_bit(&mut self, n: i32) -> Result<&mut BigNumber, UrsaCryptoError> {
+        let bits = n as usize;
+        let mask = BigInt::one() << bits;
+        self.bn |= mask;
+        Ok(self)
+    }
+
+    pub fn from_u32(n: usize) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from(n) })
+    }
+
+    pub fn from_dec(dec: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(dec, 10)? })
+    }
+
+    pub fn from_hex(hex: &str) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber{ bn: BigInt::from_str_radix(hex, 16)? })
+    }
+
+    pub fn from_bytes(bytes: &[u8]) -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber { bn: BigInt::from_bytes_be(Sign::Plus, bytes) })
+    }
+
+    pub fn to_dec(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(10))
+    }
+
+    pub fn to_hex(&self) -> Result<String, UrsaCryptoError> {
+        Ok(self.bn.to_str_radix(16).to_uppercase())
+    }
+
+    pub fn to_bytes(&self) -> Result<Vec<u8>, UrsaCryptoError> {
+        let (_, res) = self.bn.to_bytes_be();
+        Ok(res)
+    }
+
+    pub fn hash(data: &[u8]) -> Result<Vec<u8>, UrsaCryptoError> {
+        digest(DigestAlgorithm::Sha2_256, data).map_err(|e| UrsaCryptoError::InvalidStructure(e.to_string()))
+    }
+
+    pub fn add(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn + &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sub(&self, a: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn - &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn sqr(&self, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &self.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mul(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn * &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_mul(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        //TODO: Use montgomery reduction
+        let res = (&self.bn * &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn mod_sub(&self, a: &BigNumber, n: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = (&self.bn - &a.bn) % &n.bn;
+        Ok(BigNumber { bn: res })
+    }
+
+    pub fn div(&self, a: &BigNumber, _ctx: Option<&mut BigNumberContext>) -> Result<BigNumber, UrsaCryptoError> {
+        let res = &self.bn / &a.bn;
+        Ok(BigNumber { bn: res })
+    }
+",215,2019-01-21 16:26:35,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249513139,https://github.com/hyperledger/ursa/pull/8#discussion_r249513139,lovesh
https://github.com/hyperledger/ursa/pull/8,https://github.com/hyperledger/ursa/pull/8,Ok. I would still prefer to not rely on compiler optimisation in this case as this version does not offer readability benefit but it seems manuchia.,68c9e859a91d88ef2e5f8f7201b54c6cb98383f9,2019-01-21 16:28:51,249514126,"@@ -0,0 +1,696 @@
+use errors::UrsaCryptoError;
+
+use hash::{digest, DigestAlgorithm, Digest, sha2};
+use num_bigint::{BigInt, BigUint, RandBigInt, ToBigInt, Sign};
+use num_integer::Integer;
+use num_traits::identities::{One, Zero};
+use num_traits::{Num, Signed, ToPrimitive, Pow};
+use glass_pumpkin::{prime, safe_prime};
+use rand::rngs::OsRng;
+
+#[cfg(feature = ""serialization"")]
+use serde::ser::{Serialize, Serializer, Error as SError};
+
+#[cfg(feature = ""serialization"")]
+use serde::de::{Deserialize, Deserializer, Visitor, Error as DError};
+
+use std::error::Error;
+use std::fmt;
+use std::cmp::Ord;
+use std::cmp::Ordering;
+
+pub struct BigNumberContext;
+
+pub struct BigNumber {
+    bn: BigInt
+}
+
+macro_rules! prime_generation {
+    ($f:ident, $size:ident, $msg:expr) => {
+        match $f::new($size)?.to_bigint() {
+            Some(bn) => Ok(BigNumber { bn }),
+            None => Err(UrsaCryptoError::InvalidStructure($msg.to_string()))
+        }
+    };
+}
+
+macro_rules! prime_check {
+    ($f:ident, $value:expr, $msg:expr) => {
+        if $value.is_negative() {
+            Ok(false)
+        } else {
+            match $value.bn.to_biguint() {
+                Some(bn) => Ok($f::check(&bn)),
+                None => Err(UrsaCryptoError::InvalidStructure($msg.to_string()))
+            }
+        }
+    };
+}
+
+impl BigNumber {
+    pub fn new_context() -> Result<BigNumberContext, UrsaCryptoError> {
+        Ok(BigNumberContext{})
+    }
+
+    pub fn new() -> Result<BigNumber, UrsaCryptoError> {
+        Ok(BigNumber {
+            bn: BigInt::zero()
+        })
+    }
+
+    pub fn generate_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        prime_generation!(prime, size, ""Unable to generate prime"")
+    }
+
+    pub fn generate_safe_prime(size: usize) -> Result<BigNumber, UrsaCryptoError> {
+        prime_generation!(safe_prime, size, ""Unable to generate safe prime"")
+    }
+
+    pub fn generate_prime_in_range(start: &BigNumber, end: &BigNumber) -> Result<BigNumber, UrsaCryptoError> {
+        let mut res;
+        let mut iteration = 0;
+        let mut rng = OsRng::new()?;
+        let mut start = match start.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'start': {:?}"", start)))
+        };
+        let mut end = match end.bn.to_biguint() {
+            Some(bn) => bn,
+            None => return Err(UrsaCryptoError::InvalidStructure(format!(""Invalid number for 'end': {:?}"", end)))
+        };
+
+        if start > end {
+            let temp = start;
+            start = end.clone();
+            end = temp;
+        }
+
+        loop {
+            res = rng.gen_biguint_range(&start, &end);
+            res |= BigUint::one();",90,2019-01-21 16:28:51,https://api.github.com/repos/hyperledger/ursa/pulls/comments/249514126,https://github.com/hyperledger/ursa/pull/8#discussion_r249514126,lovesh
https://github.com/hyperledger/ursa/pull/7,https://github.com/hyperledger/ursa/pull/7,Is this sufficient to ensure a good enough version? 0.9 was published back in February 2018. I just want to make sure that 0.10.0 uses a new enough version of OpenSSL.,36728c3beb6be5abe126195bf2623d8cf08a53e3,2019-01-11 19:28:26,247229502,"@@ -47,7 +47,7 @@ sha3 = ""0.7.3""
 time = ""0.1.36""
 env_logger = ""0.5.10""
 blake2b_simd = ""0.3.1""
-openssl = { version = ""=0.10.12"", optional = true }
+openssl = { version = ""0.10"", optional = true }",14,2019-01-11 19:33:02,https://api.github.com/repos/hyperledger/ursa/pulls/comments/247229502,https://github.com/hyperledger/ursa/pull/7#discussion_r247229502,dhuseby
https://github.com/hyperledger/ursa/pull/6,https://github.com/hyperledger/ursa/pull/6,Should AMCL be listed here?,91bb0932b340a283f696e2e41db10360737fee20,2018-12-18 20:01:39,242685333,"@@ -1,103 +1,232 @@
-## Before you Continue
+# Hyperledger Ursa
 
-If you haven't done so already, please visit the main resource for all things ""Indy"" to get acquainted with the code base, helpful resources, and up-to-date information: [Hyperledger Wiki-Indy](https://wiki.hyperledger.org/projects/indy).
+Ursa was created because people in the Hyperledger community realized that it would save time and effort and improve security if we all collaborated on our cryptographic code. Since cryptographic APIs are relatively straightforward to define, it would be possible for many different projects to utilize the same code without too much difficulty.
 
-# Indy Crypto
+First and foremost, we hope in the long run that Ursa provides open-source blockchain developers with reliable, secure, easy-to-use, and pluggable cryptographic implementations.
 
-This is the shared crypto library for [Hyperledger Indy](https://www.hyperledger.org/projects) components.
+The major artifacts of Ursa are:
+- C-callable library interface
+- Rust crate
 
-[Hyperledger Indy](https://www.hyperledger.org/projects) provides a distributed-ledger-based foundation for [self-sovereign identity](https://sovrin.org).
+All bugs, stories, and backlog for this project are managed through Hyperledger's Jira in project IS (note that regular Ursa tickets are in the URSA project). Also, join us on [Hyperledger Rocket.Chat](https://chat.hyperledger.org) at #ursa to discuss. The ursa group also meets biweekly on Wednesday's at 7 AM PST at https://zoom.us/my/hyperledger.community. The meeting notes are available [here](https://docs.google.com/document/d/1Z_8o8k_PFRM4XfZyv9jH1_-IyN0CsCMI2JlrGsCX378/edit).
 
-The major artifacts of the Indy Crypto are:
+Major modifications to ursa are submitted as RFCs to the [Ursa RFC repo](https://github.com/hyperledger/ursa-rfcs). 
 
-* -callable library interface
-* Rust rate
-* Python wrapper
+Ursa is divided into two sub libraries: Libursa and Z-Mix.
 
-All bugs, stories, and backlog for this project are managed through [Hyperledger's Jira](https://jira.hyperledger.org)
-in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
-us on [Jira's Rocket.Chat](chat.hyperledger.org) at #indy-sdk to discuss.
+Libursa is designed for cryptographic primitives like simple digital signatures, encryption schemes, and key exchange.
 
-## Building Indy Crypto
+Z-Mix offers a generic way to create zero-knowledge proofs, proving statements about multiple cryptographic building blocks, containing signatures, commitments, and verifiable encryption. Z-Mix uses many of the building blocks found in Libursa.
 
-## Ubuntu 16.04
+## Dependencies
 
-1. Install Rust and rustup (https://www.rust-lang.org/install.html).
-1. Install pre-requirements:
+Ursa and Z-Mix use the following external dependencies:
 
-    *For Ubuntu 16.04*
+- libsodium 1.0.14 (Written in C)
+- openssl 1.1.0j or newer (Written in C)
+- libsecp256k1 (Written in C)
 ",45,2018-12-21 15:32:54,https://api.github.com/repos/hyperledger/ursa/pulls/comments/242685333,https://github.com/hyperledger/ursa/pull/6#discussion_r242685333,dcmiddle
https://github.com/hyperledger/ursa/pull/6,https://github.com/hyperledger/ursa/pull/6,Should we cite the audit claims?,91bb0932b340a283f696e2e41db10360737fee20,2018-12-18 20:11:56,242688828,"@@ -1,103 +1,232 @@
-## Before you Continue
+# Hyperledger Ursa
 
-If you haven't done so already, please visit the main resource for all things ""Indy"" to get acquainted with the code base, helpful resources, and up-to-date information: [Hyperledger Wiki-Indy](https://wiki.hyperledger.org/projects/indy).
+Ursa was created because people in the Hyperledger community realized that it would save time and effort and improve security if we all collaborated on our cryptographic code. Since cryptographic APIs are relatively straightforward to define, it would be possible for many different projects to utilize the same code without too much difficulty.
 
-# Indy Crypto
+First and foremost, we hope in the long run that Ursa provides open-source blockchain developers with reliable, secure, easy-to-use, and pluggable cryptographic implementations.
 
-This is the shared crypto library for [Hyperledger Indy](https://www.hyperledger.org/projects) components.
+The major artifacts of Ursa are:
+- C-callable library interface
+- Rust crate
 
-[Hyperledger Indy](https://www.hyperledger.org/projects) provides a distributed-ledger-based foundation for [self-sovereign identity](https://sovrin.org).
+All bugs, stories, and backlog for this project are managed through Hyperledger's Jira in project IS (note that regular Ursa tickets are in the URSA project). Also, join us on [Hyperledger Rocket.Chat](https://chat.hyperledger.org) at #ursa to discuss. The ursa group also meets biweekly on Wednesday's at 7 AM PST at https://zoom.us/my/hyperledger.community. The meeting notes are available [here](https://docs.google.com/document/d/1Z_8o8k_PFRM4XfZyv9jH1_-IyN0CsCMI2JlrGsCX378/edit).
 
-The major artifacts of the Indy Crypto are:
+Major modifications to ursa are submitted as RFCs to the [Ursa RFC repo](https://github.com/hyperledger/ursa-rfcs). 
 
-* -callable library interface
-* Rust rate
-* Python wrapper
+Ursa is divided into two sub libraries: Libursa and Z-Mix.
 
-All bugs, stories, and backlog for this project are managed through [Hyperledger's Jira](https://jira.hyperledger.org)
-in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
-us on [Jira's Rocket.Chat](chat.hyperledger.org) at #indy-sdk to discuss.
+Libursa is designed for cryptographic primitives like simple digital signatures, encryption schemes, and key exchange.
 
-## Building Indy Crypto
+Z-Mix offers a generic way to create zero-knowledge proofs, proving statements about multiple cryptographic building blocks, containing signatures, commitments, and verifiable encryption. Z-Mix uses many of the building blocks found in Libursa.
 
-## Ubuntu 16.04
+## Dependencies
 
-1. Install Rust and rustup (https://www.rust-lang.org/install.html).
-1. Install pre-requirements:
+Ursa and Z-Mix use the following external dependencies:
 
-    *For Ubuntu 16.04*
+- libsodium 1.0.14 (Written in C)
+- openssl 1.1.0j or newer (Written in C)
+- libsecp256k1 (Written in C)
 
-    ```bash
-    apt-get update && \
-    apt-get install -y \
-    build-essential \
-    pkg-config \
-    cmake \
-    libssl-dev
-    ```
+These dependencies are used when building in the default secure mode. These libraries have been audited by external security firms.",,2018-12-21 15:32:54,https://api.github.com/repos/hyperledger/ursa/pulls/comments/242688828,https://github.com/hyperledger/ursa/pull/6#discussion_r242688828,dcmiddle
https://github.com/hyperledger/ursa/pull/6,https://github.com/hyperledger/ursa/pull/6,No because its written in Rust.,91bb0932b340a283f696e2e41db10360737fee20,2018-12-18 21:23:46,242710634,"@@ -1,103 +1,232 @@
-## Before you Continue
+# Hyperledger Ursa
 
-If you haven't done so already, please visit the main resource for all things ""Indy"" to get acquainted with the code base, helpful resources, and up-to-date information: [Hyperledger Wiki-Indy](https://wiki.hyperledger.org/projects/indy).
+Ursa was created because people in the Hyperledger community realized that it would save time and effort and improve security if we all collaborated on our cryptographic code. Since cryptographic APIs are relatively straightforward to define, it would be possible for many different projects to utilize the same code without too much difficulty.
 
-# Indy Crypto
+First and foremost, we hope in the long run that Ursa provides open-source blockchain developers with reliable, secure, easy-to-use, and pluggable cryptographic implementations.
 
-This is the shared crypto library for [Hyperledger Indy](https://www.hyperledger.org/projects) components.
+The major artifacts of Ursa are:
+- C-callable library interface
+- Rust crate
 
-[Hyperledger Indy](https://www.hyperledger.org/projects) provides a distributed-ledger-based foundation for [self-sovereign identity](https://sovrin.org).
+All bugs, stories, and backlog for this project are managed through Hyperledger's Jira in project IS (note that regular Ursa tickets are in the URSA project). Also, join us on [Hyperledger Rocket.Chat](https://chat.hyperledger.org) at #ursa to discuss. The ursa group also meets biweekly on Wednesday's at 7 AM PST at https://zoom.us/my/hyperledger.community. The meeting notes are available [here](https://docs.google.com/document/d/1Z_8o8k_PFRM4XfZyv9jH1_-IyN0CsCMI2JlrGsCX378/edit).
 
-The major artifacts of the Indy Crypto are:
+Major modifications to ursa are submitted as RFCs to the [Ursa RFC repo](https://github.com/hyperledger/ursa-rfcs). 
 
-* -callable library interface
-* Rust rate
-* Python wrapper
+Ursa is divided into two sub libraries: Libursa and Z-Mix.
 
-All bugs, stories, and backlog for this project are managed through [Hyperledger's Jira](https://jira.hyperledger.org)
-in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
-us on [Jira's Rocket.Chat](chat.hyperledger.org) at #indy-sdk to discuss.
+Libursa is designed for cryptographic primitives like simple digital signatures, encryption schemes, and key exchange.
 
-## Building Indy Crypto
+Z-Mix offers a generic way to create zero-knowledge proofs, proving statements about multiple cryptographic building blocks, containing signatures, commitments, and verifiable encryption. Z-Mix uses many of the building blocks found in Libursa.
 
-## Ubuntu 16.04
+## Dependencies
 
-1. Install Rust and rustup (https://www.rust-lang.org/install.html).
-1. Install pre-requirements:
+Ursa and Z-Mix use the following external dependencies:
 
-    *For Ubuntu 16.04*
+- libsodium 1.0.14 (Written in C)
+- openssl 1.1.0j or newer (Written in C)
+- libsecp256k1 (Written in C)
 ",45,2018-12-21 15:32:54,https://api.github.com/repos/hyperledger/ursa/pulls/comments/242710634,https://github.com/hyperledger/ursa/pull/6#discussion_r242710634,mikelodder7
https://github.com/hyperledger/ursa/pull/6,https://github.com/hyperledger/ursa/pull/6,I thought about doing that. If you want me to I will.,91bb0932b340a283f696e2e41db10360737fee20,2018-12-18 21:24:34,242710898,"@@ -1,103 +1,232 @@
-## Before you Continue
+# Hyperledger Ursa
 
-If you haven't done so already, please visit the main resource for all things ""Indy"" to get acquainted with the code base, helpful resources, and up-to-date information: [Hyperledger Wiki-Indy](https://wiki.hyperledger.org/projects/indy).
+Ursa was created because people in the Hyperledger community realized that it would save time and effort and improve security if we all collaborated on our cryptographic code. Since cryptographic APIs are relatively straightforward to define, it would be possible for many different projects to utilize the same code without too much difficulty.
 
-# Indy Crypto
+First and foremost, we hope in the long run that Ursa provides open-source blockchain developers with reliable, secure, easy-to-use, and pluggable cryptographic implementations.
 
-This is the shared crypto library for [Hyperledger Indy](https://www.hyperledger.org/projects) components.
+The major artifacts of Ursa are:
+- C-callable library interface
+- Rust crate
 
-[Hyperledger Indy](https://www.hyperledger.org/projects) provides a distributed-ledger-based foundation for [self-sovereign identity](https://sovrin.org).
+All bugs, stories, and backlog for this project are managed through Hyperledger's Jira in project IS (note that regular Ursa tickets are in the URSA project). Also, join us on [Hyperledger Rocket.Chat](https://chat.hyperledger.org) at #ursa to discuss. The ursa group also meets biweekly on Wednesday's at 7 AM PST at https://zoom.us/my/hyperledger.community. The meeting notes are available [here](https://docs.google.com/document/d/1Z_8o8k_PFRM4XfZyv9jH1_-IyN0CsCMI2JlrGsCX378/edit).
 
-The major artifacts of the Indy Crypto are:
+Major modifications to ursa are submitted as RFCs to the [Ursa RFC repo](https://github.com/hyperledger/ursa-rfcs). 
 
-* -callable library interface
-* Rust rate
-* Python wrapper
+Ursa is divided into two sub libraries: Libursa and Z-Mix.
 
-All bugs, stories, and backlog for this project are managed through [Hyperledger's Jira](https://jira.hyperledger.org)
-in project IS (note that regular Indy tickets are in the INDY project instead...). Also, join
-us on [Jira's Rocket.Chat](chat.hyperledger.org) at #indy-sdk to discuss.
+Libursa is designed for cryptographic primitives like simple digital signatures, encryption schemes, and key exchange.
 
-## Building Indy Crypto
+Z-Mix offers a generic way to create zero-knowledge proofs, proving statements about multiple cryptographic building blocks, containing signatures, commitments, and verifiable encryption. Z-Mix uses many of the building blocks found in Libursa.
 
-## Ubuntu 16.04
+## Dependencies
 
-1. Install Rust and rustup (https://www.rust-lang.org/install.html).
-1. Install pre-requirements:
+Ursa and Z-Mix use the following external dependencies:
 
-    *For Ubuntu 16.04*
+- libsodium 1.0.14 (Written in C)
+- openssl 1.1.0j or newer (Written in C)
+- libsecp256k1 (Written in C)
 
-    ```bash
-    apt-get update && \
-    apt-get install -y \
-    build-essential \
-    pkg-config \
-    cmake \
-    libssl-dev
-    ```
+These dependencies are used when building in the default secure mode. These libraries have been audited by external security firms.",,2018-12-21 15:32:54,https://api.github.com/repos/hyperledger/ursa/pulls/comments/242710898,https://github.com/hyperledger/ursa/pull/6#discussion_r242710898,mikelodder7
https://github.com/hyperledger/ursa/pull/6,https://github.com/hyperledger/ursa/pull/6,"@mikelodder7 Python wrapper around IndyCrypto was major artifact for HL/IndyNode and ~IndyCrypto~HL/Plenum. Will we have this wrapper around libursa?
",91bb0932b340a283f696e2e41db10360737fee20,2018-12-18 22:11:29,242724959,"@@ -1,103 +1,232 @@
-## Before you Continue
+# Hyperledger Ursa
 
-If you haven't done so already, please visit the main resource for all things ""Indy"" to get acquainted with the code base, helpful resources, and up-to-date information: [Hyperledger Wiki-Indy](https://wiki.hyperledger.org/projects/indy).
+Ursa was created because people in the Hyperledger community realized that it would save time and effort and improve security if we all collaborated on our cryptographic code. Since cryptographic APIs are relatively straightforward to define, it would be possible for many different projects to utilize the same code without too much difficulty.
 
-# Indy Crypto
+First and foremost, we hope in the long run that Ursa provides open-source blockchain developers with reliable, secure, easy-to-use, and pluggable cryptographic implementations.
 
-This is the shared crypto library for [Hyperledger Indy](https://www.hyperledger.org/projects) components.
+The major artifacts of Ursa are:
+- C-callable library interface
+- Rust crate
 
-[Hyperledger Indy](https://www.hyperledger.org/projects) provides a distributed-ledger-based foundation for [self-sovereign identity](https://sovrin.org).
+All bugs, stories, and backlog for this project are managed through Hyperledger's Jira in project IS (note that regular Ursa tickets are in the URSA project). Also, join us on [Hyperledger Rocket.Chat](https://chat.hyperledger.org) at #ursa to discuss. The ursa group also meets biweekly on Wednesday's at 7 AM PST at https://zoom.us/my/hyperledger.community. The meeting notes are available [here](https://docs.google.com/document/d/1Z_8o8k_PFRM4XfZyv9jH1_-IyN0CsCMI2JlrGsCX378/edit).
 
-The major artifacts of the Indy Crypto are:
+Major modifications to ursa are submitted as RFCs to the [Ursa RFC repo](https://github.com/hyperledger/ursa-rfcs). 
 
-* -callable library interface
-* Rust rate
-* Python wrapper",23,2018-12-21 15:32:54,https://api.github.com/repos/hyperledger/ursa/pulls/comments/242724959,https://github.com/hyperledger/ursa/pull/6#discussion_r242724959,jovfer
https://github.com/hyperledger/ursa/pull/6,https://github.com/hyperledger/ursa/pull/6,Separate PR and needs to be an RFC.,91bb0932b340a283f696e2e41db10360737fee20,2018-12-18 23:00:13,242737931,"@@ -1,103 +1,232 @@
-## Before you Continue
+# Hyperledger Ursa
 
-If you haven't done so already, please visit the main resource for all things ""Indy"" to get acquainted with the code base, helpful resources, and up-to-date information: [Hyperledger Wiki-Indy](https://wiki.hyperledger.org/projects/indy).
+Ursa was created because people in the Hyperledger community realized that it would save time and effort and improve security if we all collaborated on our cryptographic code. Since cryptographic APIs are relatively straightforward to define, it would be possible for many different projects to utilize the same code without too much difficulty.
 
-# Indy Crypto
+First and foremost, we hope in the long run that Ursa provides open-source blockchain developers with reliable, secure, easy-to-use, and pluggable cryptographic implementations.
 
-This is the shared crypto library for [Hyperledger Indy](https://www.hyperledger.org/projects) components.
+The major artifacts of Ursa are:
+- C-callable library interface
+- Rust crate
 
-[Hyperledger Indy](https://www.hyperledger.org/projects) provides a distributed-ledger-based foundation for [self-sovereign identity](https://sovrin.org).
+All bugs, stories, and backlog for this project are managed through Hyperledger's Jira in project IS (note that regular Ursa tickets are in the URSA project). Also, join us on [Hyperledger Rocket.Chat](https://chat.hyperledger.org) at #ursa to discuss. The ursa group also meets biweekly on Wednesday's at 7 AM PST at https://zoom.us/my/hyperledger.community. The meeting notes are available [here](https://docs.google.com/document/d/1Z_8o8k_PFRM4XfZyv9jH1_-IyN0CsCMI2JlrGsCX378/edit).
 
-The major artifacts of the Indy Crypto are:
+Major modifications to ursa are submitted as RFCs to the [Ursa RFC repo](https://github.com/hyperledger/ursa-rfcs). 
 
-* -callable library interface
-* Rust rate
-* Python wrapper",23,2018-12-21 15:32:54,https://api.github.com/repos/hyperledger/ursa/pulls/comments/242737931,https://github.com/hyperledger/ursa/pull/6#discussion_r242737931,mikelodder7
https://github.com/hyperledger/ursa/pull/6,https://github.com/hyperledger/ursa/pull/6,Minor point:  we have decided to call it zmix instead of z-mix.  A simple ctrl + f should fix this.,91bb0932b340a283f696e2e41db10360737fee20,2018-12-21 13:17:27,243578291,"@@ -1,103 +1,232 @@
-## Before you Continue
+# Hyperledger Ursa
 
-If you haven't done so already, please visit the main resource for all things ""Indy"" to get acquainted with the code base, helpful resources, and up-to-date information: [Hyperledger Wiki-Indy](https://wiki.hyperledger.org/projects/indy).
+Ursa was created because people in the Hyperledger community realized that it would save time and effort and improve security if we all collaborated on our cryptographic code. Since cryptographic APIs are relatively straightforward to define, it would be possible for many different projects to utilize the same code without too much difficulty.
 
-# Indy Crypto
+First and foremost, we hope in the long run that Ursa provides open-source blockchain developers with reliable, secure, easy-to-use, and pluggable cryptographic implementations.
 
-This is the shared crypto library for [Hyperledger Indy](https://www.hyperledger.org/projects) components.
+The major artifacts of Ursa are:
+- C-callable library interface
+- Rust crate
 
-[Hyperledger Indy](https://www.hyperledger.org/projects) provides a distributed-ledger-based foundation for [self-sovereign identity](https://sovrin.org).
+All bugs, stories, and backlog for this project are managed through Hyperledger's Jira in project IS (note that regular Ursa tickets are in the URSA project). Also, join us on [Hyperledger Rocket.Chat](https://chat.hyperledger.org) at #ursa to discuss. The ursa group also meets biweekly on Wednesday's at 7 AM PST at https://zoom.us/my/hyperledger.community. The meeting notes are available [here](https://docs.google.com/document/d/1Z_8o8k_PFRM4XfZyv9jH1_-IyN0CsCMI2JlrGsCX378/edit).
 
-The major artifacts of the Indy Crypto are:
+Major modifications to ursa are submitted as RFCs to the [Ursa RFC repo](https://github.com/hyperledger/ursa-rfcs). 
 
-* -callable library interface
-* Rust rate
-* Python wrapper",23,2018-12-21 15:32:54,https://api.github.com/repos/hyperledger/ursa/pulls/comments/243578291,https://github.com/hyperledger/ursa/pull/6#discussion_r243578291,hartm
https://github.com/hyperledger/ursa/pull/3,https://github.com/hyperledger/ursa/pull/3,"@mikelodder7 Is it the final decision to copy-paste origin AMCL to HL/URSA? May be we should use https://github.com/milagro-crypto/amcl/tree/master/version3/rust ?
",2e8ad96c13a282eb84d921e06d3d963d8b84de8c,2018-12-14 12:08:09,241734295,"@@ -0,0 +1,628 @@
+/*",1,2018-12-14 21:15:13,https://api.github.com/repos/hyperledger/ursa/pulls/comments/241734295,https://github.com/hyperledger/ursa/pull/3#discussion_r241734295,jovfer
https://github.com/hyperledger/ursa/pull/3,https://github.com/hyperledger/ursa/pull/3,"There are a lot duplication of similar (same?) logic between different curves. Are we really need in this duplication?
As far as I remember, in original rust codebase there is no such duplication.",2e8ad96c13a282eb84d921e06d3d963d8b84de8c,2018-12-14 12:11:46,241735181,"@@ -0,0 +1,1055 @@
+/*
+Licensed to the Apache Software Foundation (ASF) under one
+or more contributor license agreements.  See the NOTICE file
+distributed with this work for additional information
+regarding copyright ownership.  The ASF licenses this file
+to you under the Apache License, Version 2.0 (the
+""License""); you may not use this file except in compliance
+with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing,
+software distributed under the License is distributed on an
+""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+KIND, either express or implied.  See the License for the
+specific language governing permissions and limitations
+under the License.
+*/
+
+use arch;
+use arch::Chunk;
+
+//#[cfg(D32)]
+use arch::DChunk;
+
+use bls381::dbig::DBIG;
+use rand::RAND;
+
+pub const MODBYTES:usize = 48;
+pub const BASEBITS:usize = 58;
+
+pub const NLEN: usize = (1+((8*MODBYTES-1)/BASEBITS));
+pub const DNLEN: usize = 2*NLEN;
+pub const BMASK: Chunk= ((1<<BASEBITS)-1);
+pub const HBITS: usize=(BASEBITS/2);
+pub const HMASK: Chunk= ((1<<HBITS)-1);
+pub const NEXCESS:isize = (1<<((arch::CHUNK)-BASEBITS-1));
+pub const BIGBITS:usize = (MODBYTES*8);
+
+
+#[derive(Copy)]
+pub struct BIG {",42,2018-12-14 21:15:13,https://api.github.com/repos/hyperledger/ursa/pulls/comments/241735181,https://github.com/hyperledger/ursa/pull/3#discussion_r241735181,jovfer
https://github.com/hyperledger/ursa/pull/3,https://github.com/hyperledger/ursa/pull/3,What is the source of this list?,2e8ad96c13a282eb84d921e06d3d963d8b84de8c,2018-12-14 12:23:30,241737934,"@@ -1,103 +1,129 @@
+# Lab Name
+crypto-lib
+
+# Short Description
+A lab for experimentation on creating shared cryptography modules for cross-project collaboration
+
+# Scope of Lab
+The purpose of this lab is to serve as an initial launching point for what will hopefully become a shared Hyperledger cryptography library.  We aim to use this lab to set up a code base and experiment with integrating cryptographic protocols between projects.
+
+See:  https://docs.google.com/document/d/1JtFT5L-82egj6shgGXzTsNAg6_UHuMheKfsst6NS_Xo/edit?usp=sharing
+for more details.
+
+# Initial Committers",,2018-12-14 21:15:13,https://api.github.com/repos/hyperledger/ursa/pulls/comments/241737934,https://github.com/hyperledger/ursa/pull/3#discussion_r241737934,jovfer
https://github.com/hyperledger/ursa/pull/3,https://github.com/hyperledger/ursa/pull/3,@mikelodder7 For amcl v3 Nikita K made PR that allows to avoid copy/paste of curves code and easily consume it as a crate. See https://github.com/milagro-crypto/amcl/pull/60 There is an agreement that it will be accepted soon. After this we plan to publish it in crates.io.,2e8ad96c13a282eb84d921e06d3d963d8b84de8c,2018-12-14 13:12:14,241749858,"@@ -0,0 +1,1055 @@
+/*
+Licensed to the Apache Software Foundation (ASF) under one
+or more contributor license agreements.  See the NOTICE file
+distributed with this work for additional information
+regarding copyright ownership.  The ASF licenses this file
+to you under the Apache License, Version 2.0 (the
+""License""); you may not use this file except in compliance
+with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing,
+software distributed under the License is distributed on an
+""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+KIND, either express or implied.  See the License for the
+specific language governing permissions and limitations
+under the License.
+*/
+
+use arch;
+use arch::Chunk;
+
+//#[cfg(D32)]
+use arch::DChunk;
+
+use bls381::dbig::DBIG;
+use rand::RAND;
+
+pub const MODBYTES:usize = 48;
+pub const BASEBITS:usize = 58;
+
+pub const NLEN: usize = (1+((8*MODBYTES-1)/BASEBITS));
+pub const DNLEN: usize = 2*NLEN;
+pub const BMASK: Chunk= ((1<<BASEBITS)-1);
+pub const HBITS: usize=(BASEBITS/2);
+pub const HMASK: Chunk= ((1<<HBITS)-1);
+pub const NEXCESS:isize = (1<<((arch::CHUNK)-BASEBITS-1));
+pub const BIGBITS:usize = (MODBYTES*8);
+
+
+#[derive(Copy)]
+pub struct BIG {",42,2018-12-14 21:15:13,https://api.github.com/repos/hyperledger/ursa/pulls/comments/241749858,https://github.com/hyperledger/ursa/pull/3#discussion_r241749858,vimmerru
https://github.com/hyperledger/ursa/pull/3,https://github.com/hyperledger/ursa/pull/3,The key idea to avoid duplication is in https://github.com/milagro-crypto/amcl/pull/60/files#diff-860ff95753813540aca3b511fcc27a65,2e8ad96c13a282eb84d921e06d3d963d8b84de8c,2018-12-14 13:44:52,241758335,"@@ -0,0 +1,1055 @@
+/*
+Licensed to the Apache Software Foundation (ASF) under one
+or more contributor license agreements.  See the NOTICE file
+distributed with this work for additional information
+regarding copyright ownership.  The ASF licenses this file
+to you under the Apache License, Version 2.0 (the
+""License""); you may not use this file except in compliance
+with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing,
+software distributed under the License is distributed on an
+""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+KIND, either express or implied.  See the License for the
+specific language governing permissions and limitations
+under the License.
+*/
+
+use arch;
+use arch::Chunk;
+
+//#[cfg(D32)]
+use arch::DChunk;
+
+use bls381::dbig::DBIG;
+use rand::RAND;
+
+pub const MODBYTES:usize = 48;
+pub const BASEBITS:usize = 58;
+
+pub const NLEN: usize = (1+((8*MODBYTES-1)/BASEBITS));
+pub const DNLEN: usize = 2*NLEN;
+pub const BMASK: Chunk= ((1<<BASEBITS)-1);
+pub const HBITS: usize=(BASEBITS/2);
+pub const HMASK: Chunk= ((1<<HBITS)-1);
+pub const NEXCESS:isize = (1<<((arch::CHUNK)-BASEBITS-1));
+pub const BIGBITS:usize = (MODBYTES*8);
+
+
+#[derive(Copy)]
+pub struct BIG {",42,2018-12-14 21:15:13,https://api.github.com/repos/hyperledger/ursa/pulls/comments/241758335,https://github.com/hyperledger/ursa/pull/3#discussion_r241758335,jovfer
https://github.com/hyperledger/ursa/pull/3,https://github.com/hyperledger/ursa/pull/3,Which list?  The initial committers list?  I believe it came from the crypto-lib lab.  It looks like the entire section of that document is currently just the readme from the crypto-lib lab.,2e8ad96c13a282eb84d921e06d3d963d8b84de8c,2018-12-14 14:00:14,241762853,"@@ -1,103 +1,129 @@
+# Lab Name
+crypto-lib
+
+# Short Description
+A lab for experimentation on creating shared cryptography modules for cross-project collaboration
+
+# Scope of Lab
+The purpose of this lab is to serve as an initial launching point for what will hopefully become a shared Hyperledger cryptography library.  We aim to use this lab to set up a code base and experiment with integrating cryptographic protocols between projects.
+
+See:  https://docs.google.com/document/d/1JtFT5L-82egj6shgGXzTsNAg6_UHuMheKfsst6NS_Xo/edit?usp=sharing
+for more details.
+
+# Initial Committers",,2018-12-14 21:15:13,https://api.github.com/repos/hyperledger/ursa/pulls/comments/241762853,https://github.com/hyperledger/ursa/pull/3#discussion_r241762853,hartm
https://github.com/hyperledger/ursa/pull/3,https://github.com/hyperledger/ursa/pull/3,@hartm As i understand significant amount of codebase is copy\paste from indy-crypto and there is no any author of indy-crypto mentioned.,2e8ad96c13a282eb84d921e06d3d963d8b84de8c,2018-12-14 14:16:50,241767838,"@@ -1,103 +1,129 @@
+# Lab Name
+crypto-lib
+
+# Short Description
+A lab for experimentation on creating shared cryptography modules for cross-project collaboration
+
+# Scope of Lab
+The purpose of this lab is to serve as an initial launching point for what will hopefully become a shared Hyperledger cryptography library.  We aim to use this lab to set up a code base and experiment with integrating cryptographic protocols between projects.
+
+See:  https://docs.google.com/document/d/1JtFT5L-82egj6shgGXzTsNAg6_UHuMheKfsst6NS_Xo/edit?usp=sharing
+for more details.
+
+# Initial Committers",,2018-12-14 21:15:13,https://api.github.com/repos/hyperledger/ursa/pulls/comments/241767838,https://github.com/hyperledger/ursa/pull/3#discussion_r241767838,vimmerru
https://github.com/hyperledger/ursa/pull/3,https://github.com/hyperledger/ursa/pull/3,"@vimmerru The readme part of the pull request appears to have portions copied from the Hyperledger labs crypto-lib readme.  

Yes, we can take out the initial committers/sponsors stuff that are from the Hyperledger labs requirements.",2e8ad96c13a282eb84d921e06d3d963d8b84de8c,2018-12-14 14:19:47,241768684,"@@ -1,103 +1,129 @@
+# Lab Name
+crypto-lib
+
+# Short Description
+A lab for experimentation on creating shared cryptography modules for cross-project collaboration
+
+# Scope of Lab
+The purpose of this lab is to serve as an initial launching point for what will hopefully become a shared Hyperledger cryptography library.  We aim to use this lab to set up a code base and experiment with integrating cryptographic protocols between projects.
+
+See:  https://docs.google.com/document/d/1JtFT5L-82egj6shgGXzTsNAg6_UHuMheKfsst6NS_Xo/edit?usp=sharing
+for more details.
+
+# Initial Committers",,2018-12-14 21:15:13,https://api.github.com/repos/hyperledger/ursa/pulls/comments/241768684,https://github.com/hyperledger/ursa/pull/3#discussion_r241768684,hartm
https://github.com/hyperledger/ursa/pull/3,https://github.com/hyperledger/ursa/pull/3,"No, it will be an iterative process. The next PR I make will fix this as z-mix also has amcl, so we need to dedup it. I wouldn't block this PR for this reason. I'll let you know about it when I raise the next PR.",2e8ad96c13a282eb84d921e06d3d963d8b84de8c,2018-12-14 21:11:18,241892522,"@@ -0,0 +1,628 @@
+/*",1,2018-12-14 21:15:13,https://api.github.com/repos/hyperledger/ursa/pulls/comments/241892522,https://github.com/hyperledger/ursa/pull/3#discussion_r241892522,mikelodder7
https://github.com/hyperledger/ursa/pull/3,https://github.com/hyperledger/ursa/pull/3,Agreed. But that's not the point of this PR. This PR is purely to merge crypto-lib here. I'll let you know about the next one which is on standby as soon as this one is merged.,2e8ad96c13a282eb84d921e06d3d963d8b84de8c,2018-12-14 21:12:06,241892707,"@@ -0,0 +1,1055 @@
+/*
+Licensed to the Apache Software Foundation (ASF) under one
+or more contributor license agreements.  See the NOTICE file
+distributed with this work for additional information
+regarding copyright ownership.  The ASF licenses this file
+to you under the Apache License, Version 2.0 (the
+""License""); you may not use this file except in compliance
+with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing,
+software distributed under the License is distributed on an
+""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+KIND, either express or implied.  See the License for the
+specific language governing permissions and limitations
+under the License.
+*/
+
+use arch;
+use arch::Chunk;
+
+//#[cfg(D32)]
+use arch::DChunk;
+
+use bls381::dbig::DBIG;
+use rand::RAND;
+
+pub const MODBYTES:usize = 48;
+pub const BASEBITS:usize = 58;
+
+pub const NLEN: usize = (1+((8*MODBYTES-1)/BASEBITS));
+pub const DNLEN: usize = 2*NLEN;
+pub const BMASK: Chunk= ((1<<BASEBITS)-1);
+pub const HBITS: usize=(BASEBITS/2);
+pub const HMASK: Chunk= ((1<<HBITS)-1);
+pub const NEXCESS:isize = (1<<((arch::CHUNK)-BASEBITS-1));
+pub const BIGBITS:usize = (MODBYTES*8);
+
+
+#[derive(Copy)]
+pub struct BIG {",42,2018-12-14 21:15:13,https://api.github.com/repos/hyperledger/ursa/pulls/comments/241892707,https://github.com/hyperledger/ursa/pull/3#discussion_r241892707,mikelodder7
https://github.com/hyperledger/ursa/pull/3,https://github.com/hyperledger/ursa/pull/3,I'll take them out.,2e8ad96c13a282eb84d921e06d3d963d8b84de8c,2018-12-14 21:12:22,241892774,"@@ -1,103 +1,129 @@
+# Lab Name
+crypto-lib
+
+# Short Description
+A lab for experimentation on creating shared cryptography modules for cross-project collaboration
+
+# Scope of Lab
+The purpose of this lab is to serve as an initial launching point for what will hopefully become a shared Hyperledger cryptography library.  We aim to use this lab to set up a code base and experiment with integrating cryptographic protocols between projects.
+
+See:  https://docs.google.com/document/d/1JtFT5L-82egj6shgGXzTsNAg6_UHuMheKfsst6NS_Xo/edit?usp=sharing
+for more details.
+
+# Initial Committers",,2018-12-14 21:15:13,https://api.github.com/repos/hyperledger/ursa/pulls/comments/241892774,https://github.com/hyperledger/ursa/pull/3#discussion_r241892774,mikelodder7
https://github.com/hyperledger/ursa/pull/3,https://github.com/hyperledger/ursa/pull/3,See my branch [here](https://github.com/mikelodder7/ursa/tree/z-mix),2e8ad96c13a282eb84d921e06d3d963d8b84de8c,2018-12-14 21:17:01,241893838,"@@ -0,0 +1,628 @@
+/*",1,2018-12-14 21:17:02,https://api.github.com/repos/hyperledger/ursa/pulls/comments/241893838,https://github.com/hyperledger/ursa/pull/3#discussion_r241893838,mikelodder7
