url issues,url_api comment,url_html comment,user create comment,body,created_at,updated_at
https://api.github.com/repos/hyperledger/indy-hipe/issues/111,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/479056631,https://github.com/hyperledger/indy-hipe/pull/111#issuecomment-479056631,dbluhm,[rendered text](https://github.com/dbluhm/indy-hipe/blob/testing-messages/text/testing-messages/README.md),2019-04-02 15:38:20,2019-04-02 15:38:20
https://api.github.com/repos/hyperledger/indy-hipe/issues/108,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/478164904,https://github.com/hyperledger/indy-hipe/pull/108#issuecomment-478164904,dhh1128,"Merging after approval from @swcurran and @mikelodder7 , and after previous discussions with @TelegramSam and @nage .",2019-03-29 22:10:51,2019-03-29 22:10:51
https://api.github.com/repos/hyperledger/indy-hipe/issues/107,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475483204,https://github.com/hyperledger/indy-hipe/pull/107#issuecomment-475483204,dhh1128,"Per previous approval from multiple maintainers on rocket chat, I am going to go ahead and merge this change.",2019-03-22 03:38:02,2019-03-22 03:38:02
https://api.github.com/repos/hyperledger/indy-hipe/issues/107,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475484598,https://github.com/hyperledger/indy-hipe/pull/107#issuecomment-475484598,dhh1128,This change was discussed and approved here: https://chat.hyperledger.org/channel/indy-agent?msg=Xes3cnmr4TvpgFjRC,2019-03-22 03:47:30,2019-03-22 03:47:30
https://api.github.com/repos/hyperledger/indy-hipe/issues/105,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475438659,https://github.com/hyperledger/indy-hipe/pull/105#issuecomment-475438659,dhh1128,"@Artemkaaas , is your change here compatible with the change that @lovesh is recommending in this PR against indy-sdk? https://github.com/hyperledger/indy-sdk/pull/1537",2019-03-21 23:17:54,2019-03-21 23:17:54
https://api.github.com/repos/hyperledger/indy-hipe/issues/105,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475501667,https://github.com/hyperledger/indy-hipe/pull/105#issuecomment-475501667,Artemkaaas,"@dhh1128, it's a different level. @lovesh suggested changes inside libindy `pack` function (how JSON object is built). ",2019-03-22 05:46:15,2019-03-22 05:46:15
https://api.github.com/repos/hyperledger/indy-hipe/issues/105,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475613670,https://github.com/hyperledger/indy-hipe/pull/105#issuecomment-475613670,jovfer,"@dhh1128 this PR is just for clarification current approach and probably for minimal instant changes in codebase.

BTW I expect large update from @lovesh and large discussion around topic ""is it required and how to avoid re-encryption and re-base64 data while multiply rounds of pack and fwd""",2019-03-22 13:06:00,2019-03-22 13:06:28
https://api.github.com/repos/hyperledger/indy-hipe/issues/105,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475774412,https://github.com/hyperledger/indy-hipe/pull/105#issuecomment-475774412,TelegramSam,"Can we update this to clarify that the msg is not a string but the json object? IE we want this: 
`""msg"": { ""protected"": ""..."", ... }`
and not this:
`""msg"": ""{ \""protected\"": \""....\"", .... }""`
",2019-03-22 20:39:34,2019-03-22 20:39:34
https://api.github.com/repos/hyperledger/indy-hipe/issues/105,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/479665564,https://github.com/hyperledger/indy-hipe/pull/105#issuecomment-479665564,dhh1128,@TelegramSam I am thinking this is ready to merge. Do you agree?,2019-04-03 21:27:50,2019-04-03 21:27:50
https://api.github.com/repos/hyperledger/indy-hipe/issues/100,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/471100812,https://github.com/hyperledger/indy-hipe/pull/100#issuecomment-471100812,kdenhartog,"Thanks for adding this documentation. An important premise that I realized when discussing this with members in the community is that repudiable integrity of data as the default maps very well to the real world. 

For example, when I'm in public I don't have a microphone following me around recording my every conversation and then using that to prove I said something. Only in very specific instances do we put things ""on the record"" so to say. In instances like public interviews, signing documents, and legal testimonies it's useful. However, we don't have an expectation that every conversation is recorded (ignoring the fact that I carry a cell phone with me), so it make sense that our technologies extend that paradigm.",2019-03-08 22:39:24,2019-03-08 22:39:24
https://api.github.com/repos/hyperledger/indy-hipe/issues/99,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/478109138,https://github.com/hyperledger/indy-hipe/pull/99#issuecomment-478109138,swcurran,"This question should be finalized on the next Indy Maintainers call:

> Is ""DIDComm"" the accepted term going forward?

If so, this should be merged immediately. ",2019-03-29 18:46:42,2019-03-29 18:46:42
https://api.github.com/repos/hyperledger/indy-hipe/issues/98,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/477242428,https://github.com/hyperledger/indy-hipe/pull/98#issuecomment-477242428,TelegramSam,I feel like this is ready for FCP. It doesn't answer all questions but is a fine foundation that can be amended through future HIPEs and PRs. ,2019-03-27 16:34:49,2019-03-27 16:34:49
https://api.github.com/repos/hyperledger/indy-hipe/issues/95,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/467916956,https://github.com/hyperledger/indy-hipe/pull/95#issuecomment-467916956,TelegramSam,"I'd like to drill down into why a connection may not be desired. Not contesting it yet, but I think we can learn a bit by the discussion.",2019-02-27 15:53:27,2019-02-27 15:53:27
https://api.github.com/repos/hyperledger/indy-hipe/issues/95,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/467921755,https://github.com/hyperledger/indy-hipe/pull/95#issuecomment-467921755,swcurran,"I think it is necessary based the number of connections that a person has - the volume of connections.  I have about 800 entries in my lastpass repo, so that is at least how many legit connections that a person might have, never mind trips to the liquor store, and pubs.",2019-02-27 16:05:06,2019-02-27 16:05:06
https://api.github.com/repos/hyperledger/indy-hipe/issues/95,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/468115575,https://github.com/hyperledger/indy-hipe/pull/95#issuecomment-468115575,tmarkovski,"A connection makes this challenge flow obsolete, as it is authentication in itself, with it's own challenge/response flow (connection protocol). I think the intention with this hipe's flow is to reduce the friction of connection establishment and allow transient authentication without establishing permanent connection. I think there are a lot of applications for ephemeral challenge, especially over offline networks (NFC, Bluetooth, etc).
@swcurran makes a good point, we don't want a connection entry for every authentication endpoint unless it's necessary for credential exchange, not just presentation.",2019-02-28 02:47:51,2019-02-28 02:47:51
https://api.github.com/repos/hyperledger/indy-hipe/issues/95,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/476234709,https://github.com/hyperledger/indy-hipe/pull/95#issuecomment-476234709,dhh1128,"After reading this HIPE draft, I am feeling like I need a better definition of the problem this protocol is solving.

What do we mean by ""ephemeral"" here? ""Connectionless""? If so, we should use ""connectionless"". Ephemeral means transitory or temporary, not connectionless.

I also don't know what we mean by ""challenge."" Are we imagining many different types of challenge can be plugged in? If so, how does that work? The only example I am seeing is a challenge for a proof request. So I am wondering if this is really the connectionless proof request protocol, and not the ephemeral challenge protocol.",2019-03-25 14:58:27,2019-03-25 14:58:27
https://api.github.com/repos/hyperledger/indy-hipe/issues/95,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/479124049,https://github.com/hyperledger/indy-hipe/pull/95#issuecomment-479124049,tplooker,"@dhh1128 Sorry I totally missed the comment on this. 

I called the protocol ephemeral challenge as it is an ""instantaneous"" challenge protocol (i.e no prior connection needed to host the protocol and no commitment passed responding to the challenge).

My thinking about why I called it a ""challenge"" protocol rather than a ""proof request"" protocol is that yes, I think in the very near future, even though I have not articulated this yet in the HIPE (hence it is only a draft) that there will be other forms of challenges. The most notable could be a pairwise challenge for example the challenger generates a challenge signed with their public did, a challenge responder receives and identifies the public did is linked to a peerwise connection they have in their wallet and responds with a challenge response that identifies them to the challenger. Although in the second challenge scenario I have outlined, a connection is required. This is not an artifact of the protocol it self rather the specific type of challenge creating that requirement.

Its important to note that this protocol has a large overlap with did-auth and I am still assessing its overlap.

In general what I am hoping to accomplish with this protocol is a general purpose challenge request-response protocol.",2019-04-02 18:03:48,2019-04-02 18:03:48
https://api.github.com/repos/hyperledger/indy-hipe/issues/95,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/479316767,https://github.com/hyperledger/indy-hipe/pull/95#issuecomment-479316767,tplooker,"@dhh1128 and any other interested parties, please take a look at the updated HIPE this is still a draft mainly designed to promote discussion around the concept. I have added an early example as to how a `proof of pairwise connection` could work.",2019-04-03 03:14:11,2019-04-03 03:14:11
https://api.github.com/repos/hyperledger/indy-hipe/issues/94,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/468315034,https://github.com/hyperledger/indy-hipe/pull/94#issuecomment-468315034,kdenhartog,"What's the extent of error handling that we want to cover with the transport layer. For example, would a misformatted wire message return a 4XX status code? I'd think that it wouldn't make sense to use the status code to push this error back.  On the other hand, what about a message that is posted to the wrong endpoint? I would think that it would be acceptable to return a 4XX status code.

Also, given that we support IoT devices I think it's only fair to support the 418 status code if we're interacting with a teapot. ",2019-02-28 15:27:32,2019-02-28 15:27:32
https://api.github.com/repos/hyperledger/indy-hipe/issues/94,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/469291775,https://github.com/hyperledger/indy-hipe/pull/94#issuecomment-469291775,TelegramSam,"> What's the extent of error handling that we want to cover with the transport layer. For example, would a misformatted wire message return a 4XX status code? I'd think that it wouldn't make sense to use the status code to push this error back. On the other hand, what about a message that is posted to the wrong endpoint? I would think that it would be acceptable to return a 4XX status code.

I do think we need to be careful here to not step into full message processing. Errors related to message _receipt_ might be acceptable though.

> Also, given that we support IoT devices I think it's only fair to support the 418 status code if we're interacting with a teapot.

Definitely need to work out the particulars of this one. :)
",2019-03-04 15:22:39,2019-03-04 15:22:39
https://api.github.com/repos/hyperledger/indy-hipe/issues/94,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475440328,https://github.com/hyperledger/indy-hipe/pull/94#issuecomment-475440328,dhh1128,"Aside from the comments I left, my other point of feedback is just that I think we need discussion of a few more issues and transports before we merge this. For example:

1. How are different transports tested?
2. How mediators and relays relate to transports (need hyperlinks to that HIPE)
3. How message trust contexts might be affected by transports (or not).
4. How to standardize handling of a new transport. (By raising a PR against this doc? If so, what questions would the PR have to answer?)
5. Which transports have known implementations.",2019-03-21 23:25:40,2019-03-21 23:25:40
https://api.github.com/repos/hyperledger/indy-hipe/issues/93,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475476992,https://github.com/hyperledger/indy-hipe/pull/93#issuecomment-475476992,kdenhartog,Closing this right now to focus on other HIPEs. We can revisit this later.,2019-03-22 02:58:05,2019-03-22 02:58:05
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/461889567,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-461889567,TelegramSam,"I'm wondering what value the attachment approach brings, as opposed to just including the contents as an attribute?",2019-02-08 17:55:32,2019-02-08 17:55:32
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/461924899,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-461924899,tplooker,"@TelegramSam I agree, my immediate thought was what happens when we add support for attachments i.e media in credentials and proofs? @KitHat was this driven by the need to have a generic credential exchange messages that spans multiple formats the W3VC space?",2019-02-08 19:49:14,2019-02-08 19:49:14
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/462309881,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-462309881,KitHat,"@TelegramSam @tplooker as one of the reasons -- yes. It will be easier to become compliant with W3C credential format if we will keep it as attachment. Moreover, if libindy decides to evolve its format somehow it wont break this format.",2019-02-11 12:25:36,2019-02-11 12:25:36
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/462478745,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-462478745,tplooker,"@Kithat ok thanks for the clarification, any comment on how we would handle media in credentials? 

My concern with pushing the credential into an attachment is where do we then define the indy credential attachment format  some where that is visible as a message spec for someone to add support for? My thinking is message families are meant to be this source of definition and also support versioning so therefore we shouldn't be pushing this message definition into an attachment.",2019-02-11 20:18:38,2019-02-11 20:18:38
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/462763931,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-462763931,KitHat,"@tplooker what is the problem with media in credential? It is supported in libindy right now, if you can map it to integer to support ZKP-related math (hash it, for example)

What about format, right now it is defined this format on libindy level. If someone wants to use it somehow, they have two options:
* Use libindy to work with them
* Make their own library that will work with these formats.

Maybe libindy is not the best place to define this format, and it is mentioned in HIPE that it might be created as a MIME type in W3C. I think that @dhh1128 is the best person to discuss it.",2019-02-12 13:43:53,2019-02-12 13:44:05
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/463008013,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-463008013,tplooker,"@KitHat the only way I see how we can currently support media in credentials/proofs is by including the entire contents of media in a raw form as a credential attribute value. However couldn't that become burdensome especially with larger media items, wouldn't a reference like a hash (I realize the current indy-sdk doesnt support this yet) be a better solution? In that case we would need the attachments region for attachment of the actual media as a link to the hash. 

Personally I think if we are trying to create a generic credential exchange family, perhaps we should be using W3VC as the standard and continuing the effort for indy to become compatible with that format and in the mean time have a credential exchange family for indy based credentials that gets deprecated later?",2019-02-13 00:53:46,2019-02-13 00:53:46
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/463120130,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-463120130,jovfer,"> wouldn't a reference like a hash (I realize the current indy-sdk doesnt support this yet) be a better solution?

@tplooker Could you explain ""doesnt support"" more explicitly? I don't see any blockers for indy users (applications on all (issuer, proover, verifier sides) to create schema with attribute like ""personal_photo_hash_ref"" and use it.",2019-02-13 09:15:48,2019-02-13 09:15:59
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/463120463,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-463120463,jovfer,"@tplooker BTW this topic more related to attachment content in some messages of proposed family, so it's related to this topic but a bit out of scope this HIPE I think. isn't it?
And in general there is long-term plan to support format o W3VC credentials in indy ecosystem, but I think it's the next step. @dhh1128 could you share your thoughts please?",2019-02-13 09:16:44,2019-02-13 09:16:44
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/463268316,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-463268316,TelegramSam,"It seems like the main reason for utilizing attachments is to differentiate between the format of the message and the format of data carried inside the message. This makes sense when the encoding is entirely different but carries an unnecessarily high overhead when the format of the internal data is JSON. I believe json-ld shows us a better example here, where the type of an internal block of data can be independent of the type of the outer message. I believe we should adopt that pattern here as well, and include the appropriate `@type` inside the internal JSON data format. This allows movement of the internal type without requiring a message family update. 

Thoughts?",2019-02-13 16:31:45,2019-02-13 16:31:45
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/463296357,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-463296357,tplooker,"@TelegramSam I agree if, we want the credential exchange message family to be generic but want to preserve versioning and updating of the internal indy based credential messages we would need that support.

@jovfer if we are sending say a libindy-proof that discloses a `personal_photo_hash_ref` from a credential, how can we include the actual photo in the same message? Because the libindy-proof would be sent as an attachment to the to the presentation message, the photo couldn't also be sent as an attachment?",2019-02-13 17:45:21,2019-02-13 17:45:21
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/464178867,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-464178867,TelegramSam,Can you provide examples of what the contents of the attachments look like?,2019-02-15 19:55:07,2019-02-15 19:55:07
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/468350765,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-468350765,TelegramSam,"Feedback from the connectathon: It seems only the credential artifacts themselves should be presented as a block of data. Requests and other flow items would be useful directly as message attributes, not as attachments.",2019-02-28 16:58:07,2019-02-28 16:58:07
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/468760810,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-468760810,jovfer,@tplooker are you agree with @TelegramSam 's summary or would like to add more items?,2019-03-01 18:21:06,2019-03-01 18:21:06
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/468761996,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-468761996,jovfer,"@TelegramSam @tplooker FYI 
Me and @dhh1128 have some doubts about steps in credential issuance flow.
I think there is a chance that some messages will have to has both direct attributes and attachment. Like there is a math data about key correctness proof.",2019-03-01 18:24:49,2019-03-01 18:24:49
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/468820170,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-468820170,tplooker,@jovfer what @TelegramSam said yes that was my impression from the connectathon. Can you elaborate some more about your and @dhh1128 concerns?,2019-03-01 21:36:35,2019-03-01 21:36:35
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/469779541,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-469779541,TelegramSam,"> @TelegramSam @tplooker FYI
> Me and @dhh1128 have some doubts about steps in credential issuance flow.
> I think there is a chance that some messages will have to has both direct attributes and attachment. Like there is a math data about key correctness proof.

I have zero problems with both attachment and attributes being used.",2019-03-05 17:42:44,2019-03-05 17:42:44
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/474663106,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-474663106,kdenhartog,"I'd like to see a `credential_format` attribute added. For one, this would allow this message family to be decoupled from the specific format making it a general credential exchange protocol. Second, it allows Indy agents to support issuing multiple credential formats (e.g. JWS, JSON-LD sigs, etc) and can be extended (e.g. threshold ABC credentials) without requiring changes to the protocol.",2019-03-20 02:48:54,2019-03-20 02:48:54
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475037806,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-475037806,swcurran,"@KitHat -

The indy-agent call focused on this HIPE today.  Here is a list of the changes requested to this HIPE from the call.  It would be great if you could make the changes as soon as is reasonable, so we can continue the discussion:

* Add `credential-proposal` (name may change) message when `credential-offer` doesn’t match needs of the prover (rather than using `credential-request` for that purpose).
     * Loop Offer/Proposal till Prover is satisfied and sends `credential-request` message.
     * Remove `credential-preview` from `credential-request` message
     * Update diagram accordingly - BTW - big kudos on the call about the diagrams!!
     * Same concept for the credential-presentation flow
* `credential-offer` changes
     * “offers” as attribute, with array of JSON-LD typed structs.
     * Make a comparable update to the libindy data structs in all of the messages - credential issuance and presentation.
* Parent Threading paragraph needs correction/clarification in this context. What is described is when you want to start another protocol separate from this one and then return to this one, you should use a pthid.  If you are just responding to a message on this thread, you keep the same thid, and adjust the thread parameters as appropriate.
     * Should threading be added explicitly to every message past offer?
* Rename the “credential” message to “credential-issue”
* Remove the `credential-ack` and `credential-reject` messages in favor of adopting standard messages.
      * In doing that, identify the error codes that would be expected in the Problem Report message.
* Remove references in HIPE to payment until it’s a more baked concept.  That can go into a separate version of the HIPE.",2019-03-20 21:35:10,2019-03-20 21:42:04
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/477128489,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-477128489,KitHat,"@swcurran Could you give some clarification on your requests?
What do you mean by
> * “offers” as attribute, with array of JSON-LD typed structs.

Are you asking to move to attributes `libindy_offer` attachment? This is inner libindy structure that does not have any use for A2A messaging. We can copy some attributes that may have usage to the level of message but we should keep the attachment -- it has cryptographic primitives in it that will just burden the message without any use of it.
The values of offered credential are already stored in `credential_preview` field.

> * Remove the `credential-ack` and `credential-reject` messages in favor of adopting standard messages.

Standard messages are described in #65, right? If so, I can't see any information provided about `ack` messages.",2019-03-27 12:25:56,2019-03-27 15:46:08
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/478088062,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-478088062,swcurran,"Some more feedback from the most recent Indy Agent (March 27) call about this HIPE:

* For the libindy returned entities, suggestion is to use an embedded attachment construct rather than an inline one (see the [attachments HIPE](https://github.com/hyperledger/indy-hipe/pull/78) - e.g. `offer~attach` vs. current `~attach`).
* The intention of the array of embedded offers is to enable the protocol to be useful in the case the issuer can provide the claims in different credential formats - e.g. Indy, uPort, Veres-1, etc. Via the credential-request, the holder/prover can specify which of the offered formats is wanted.  Thus, the libindy-offer is just one of the credential formats that can be offered - and for now, the only one.  Is that sufficient clarification?
* The `cred_def_id` attribute outside of the libindy attachment should be removed. It is Indy-specific, so if needed for reference, would be pulled from the libindy attachment.
* The `credential-proposal` should have a comment attribute.

We also discussed the format of the libindy data in the attachment - should it be base64, the stringified JSON returned by libindy (e.g. with escaped quotes) or JSON.  I don't recall if we landed on an answer. In talking about for the 0.1 spec, the devs thought that the stringified JSON would be the best balance as it is easier for some languages we planned on using to not to have to convert it unless necessary.

Again -for others on the call - please note if I have missed or misrepresented anything.

Thanks!",2019-03-29 17:42:05,2019-03-29 17:42:05
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/478163887,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-478163887,swcurran,"This has no impact on this HIPE, but was a topic that came up in the Agent Call. I've put in a [JIRA](https://jira.hyperledger.org/browse/IS-1224) to note that the ""prover_did"" field that is currently required on the  prover.create_credential_request is (very likely) not needed and should be note accordingly - either in the docs or by eliminating it from the call.

We suspect it is a carryover from earlier thinking on the credential exchange handling.",2019-03-29 22:05:41,2019-03-29 22:05:41
https://api.github.com/repos/hyperledger/indy-hipe/issues/89,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/478184634,https://github.com/hyperledger/indy-hipe/pull/89#issuecomment-478184634,swcurran,"One of the important patterns that we have found in implementing VON is the that a service offering a credential may have pre-requisites that must be proven before it issues the credential. For example, a company must prove they are a registered entity with a legal name before they can be issued a permit (credential) for a restaurant.

A typical pattern we expect to see is an entity will apply for a credential (a permit or license) by submitting proof of the prerequisite claims plus some additional service specific information. This is the same as the current ""real-world"" process we know as the ""application"", say for insurance or college admission, or for a bank loan.

Should the Issue Credential protocol include a ""prerequisite"" message/attribute that is a presentation-request for which the holder/prover must provide a presentation?  That would enable some workflow automation such as we have done with [Greenlight](https://dev-greenlight.orgbook.gov.bc.ca/) (try City of Surrey in the demo) - where we recursively query the Issuer to find out their prerequisites to build a graph of the needed credentials to accomplish some goal.

I'd like us to at least consider extending the issuance process to cover this common pattern.",2019-03-30 00:07:17,2019-03-30 00:07:17
https://api.github.com/repos/hyperledger/indy-hipe/issues/88,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/462474667,https://github.com/hyperledger/indy-hipe/pull/88#issuecomment-462474667,swcurran,"Could we get some more business context around this message?  Notably - why would I want to use this protocol, and once I have the signed answer, how would I use it in a audit situation?  On that latter question - that would be from both a business context (an example of why/how an audit might come about) and from a technical context - how would I use it in audit scenario with another party?",2019-02-11 20:06:27,2019-02-11 20:06:27
https://api.github.com/repos/hyperledger/indy-hipe/issues/88,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/463301412,https://github.com/hyperledger/indy-hipe/pull/88#issuecomment-463301412,tplooker,"@glowkey if we were to say have the responder/answer sign not only the response but also the original question, could this bare some use for anywise relationships. I.e I ask a party a question and they respond with a commited answer that anyone else in the anywise relationship could trust? Plus this might also yield benefit for certain parties in an audit, i.e being able to link the response to the question in an irrefutable way?",2019-02-13 17:58:56,2019-02-13 17:58:56
https://api.github.com/repos/hyperledger/indy-hipe/issues/88,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/463398804,https://github.com/hyperledger/indy-hipe/pull/88#issuecomment-463398804,glowkey,"@tplooker, I think that's a valid use-case but outside the scope of this particular protocol. I'm attempting to keep it as locked to a single 2-party ""question/answer"" non-repudiable use case as possible. 

I originally thought about signing the actual answer text (rather than its corresponding nonce) but felt like allowing for internationalization was more important.",2019-02-13 22:19:29,2019-02-13 22:19:29
https://api.github.com/repos/hyperledger/indy-hipe/issues/88,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/463399255,https://github.com/hyperledger/indy-hipe/pull/88#issuecomment-463399255,glowkey,@swcurran I will add some more detail around business context.,2019-02-13 22:21:02,2019-02-13 22:21:02
https://api.github.com/repos/hyperledger/indy-hipe/issues/88,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/479474760,https://github.com/hyperledger/indy-hipe/pull/88#issuecomment-479474760,TelegramSam,"I LOVE this HIPE, with one exception: I think there is value in this protocol not requiring a signed response. The same protocol can then be used for non-critical things like an office lunch poll. I realize that the name of the protocol would need to be changed, but It seems ridiculous to have two parallel protocols, with one requiring a signature and one not.

If the initial message indicates that a signature is required, then the response can be signed. Otherwise, it isn't. Thoughts?",2019-04-03 12:49:42,2019-04-03 12:49:42
https://api.github.com/repos/hyperledger/indy-hipe/issues/88,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/479568873,https://github.com/hyperledger/indy-hipe/pull/88#issuecomment-479568873,glowkey,"Whether or not Faber requests a signature, Alice can choose for herself to sign the answer or not. It's then up to Faber to decide whether Alice's response is what it wants. If it's not signed then Faber can ask again or accept it unsigned. Thoughts?",2019-04-03 16:45:24,2019-04-03 16:45:24
https://api.github.com/repos/hyperledger/indy-hipe/issues/87,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/462369871,https://github.com/hyperledger/indy-hipe/pull/87#issuecomment-462369871,mikelodder7,"> @mikelodder7 I think this looks fine. My one question is: what happens as Ursa grows richer, in terms of the way it might impose an indirect burden on Indy as far as dependencies are concerned? For example, if Ursa picks up support for Goldilocks because some other HL project wants it, is there a way that Indy can avoid incurring an indirect dependency on a Goldilocks library? We want a foundation with lots of features, but we don't want it to cause all consuming layers to incur unnecessary dependencies.

Just like any library, we plan to version it. Indy can target a specific version and when they wish to move forward to a newer version they can update any APIs that might have changed.

To address the dependency issue, Ursa plans to have features that are plug and play. If Indy does not want an indirect dependency on say Goldilocks, they can just pick the features they want and not select the rest. This is a nice feature of Rust. Dave Huseby and I are writing an RFC for how this should work but I believe it will work like this. Indy's Cargo.toml file would indicate ursa = { version = ""..."" features=[""BBS+"", ""Ed25519""]. This means only include those listed features and everything else will be removed.",2019-02-11 15:30:08,2019-02-11 15:30:08
https://api.github.com/repos/hyperledger/indy-hipe/issues/87,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/462424319,https://github.com/hyperledger/indy-hipe/pull/87#issuecomment-462424319,swcurran,Agree that this should be moved forward.,2019-02-11 17:47:09,2019-02-11 17:47:09
https://api.github.com/repos/hyperledger/indy-hipe/issues/87,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/462690663,https://github.com/hyperledger/indy-hipe/pull/87#issuecomment-462690663,jovfer,"@mikelodder7 @dhh1128 Should this HIPE cover details about artifacts distribution and/or movement CI/CD pipelines from Evernym/Sovrin infrastructure to somewhere else?
Missed CI/CD in general is a blocker to switch other Indy projects to URSA (in my mind)",2019-02-12 09:47:50,2019-02-12 09:48:47
https://api.github.com/repos/hyperledger/indy-hipe/issues/87,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/462911938,https://github.com/hyperledger/indy-hipe/pull/87#issuecomment-462911938,mikelodder7,"> @mikelodder7 @dhh1128 Should this HIPE cover details about artifacts distribution and/or movement CI/CD pipelines from Evernym/Sovrin infrastructure to somewhere else?
> Missed CI/CD in general is a blocker to switch other Indy projects to URSA (in my mind)

I added a section about this.",2019-02-12 20:00:56,2019-02-12 20:00:56
https://api.github.com/repos/hyperledger/indy-hipe/issues/86,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/459771167,https://github.com/hyperledger/indy-hipe/pull/86#issuecomment-459771167,TelegramSam,"Daniel, this is excellent high level work. I've added a few comments, but overall this is excellent.",2019-02-01 15:59:59,2019-02-01 15:59:59
https://api.github.com/repos/hyperledger/indy-hipe/issues/86,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/459786454,https://github.com/hyperledger/indy-hipe/pull/86#issuecomment-459786454,mwherman2000,"1. Checkout this taxonomy chart: https://hyperonomy.com/2019/02/01/architecture-driven-taxonomy-for-ssi-agents/ (You already have)
2. IoT things are mentioned but non-fungible entities (NFEs) aka Things are not ...can create an implication in most readers minds that things are excluded.  Please mention Things or NFEs wherever IoT things are mentioned - 2 places?
3. [[Essential Characteristics](https://github.com/hyperledger/indy-hipe/blob/8388429d437f99378b7d72aff9a36d78aa9db5c0/text/0002-agents/README.md#essential-characteristics)] In the Lightweight Agent scenario (https://hyperonomy.files.wordpress.com/2019/02/hbb-ssi-agents-v0.4.png), bullet 2 doesn't apply. #sorry
4. [[Canonical Examples](https://github.com/hyperledger/indy-hipe/blob/8388429d437f99378b7d72aff9a36d78aa9db5c0/text/0002-agents/README.md#canonical-examples)] Can you give each of these scenarios a name?  e.g. in order, Full Function Agent, Relay Agent, Advanced Function Agent. 
5. [[How Agents Talk](https://github.com/hyperledger/indy-hipe/blob/8388429d437f99378b7d72aff9a36d78aa9db5c0/text/0002-agents/README.md#how-agents-talk)] I know the goal is to stay somewhat high-level but my first question when I read this section is how does one _discover_ how to setup and initiate a conversion?  A sentence is needed in this section. [The steps are described near the end of the [General Patterns](https://github.com/hyperledger/indy-hipe/blob/8388429d437f99378b7d72aff9a36d78aa9db5c0/text/0002-agents/README.md#general-patterns) section ...we just need a sentence earlier about discoverability.]
6. [[General Patterns](https://github.com/hyperledger/indy-hipe/blob/8388429d437f99378b7d72aff9a36d78aa9db5c0/text/0002-agents/README.md#general-patterns)] Please add subsections for each pattern so that github will create hyperlinks for each pattern.
7. Change ""ralized"" to ""realized"" in https://github.com/hyperledger/indy-hipe/blob/8388429d437f99378b7d72aff9a36d78aa9db5c0/text/0002-agents/README.md#by-location
8. Change ""has to talk"" to ""have to talk"" in https://github.com/hyperledger/indy-hipe/blob/8388429d437f99378b7d72aff9a36d78aa9db5c0/text/0002-agents/README.md#the-agent-ness-continuum
9. and ""speaks"" to ""talks"" in the same section
10. Smile.  Great job!",2019-02-01 16:44:05,2019-02-01 16:49:06
https://api.github.com/repos/hyperledger/indy-hipe/issues/86,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/459811996,https://github.com/hyperledger/indy-hipe/pull/86#issuecomment-459811996,dhh1128,"@mwherman2000 : Thanks for the detailed comment. I have addressed the items as follows:

2: Agreed. Adjusted verbiage. I am not using the term ""NFE"", but I have used ""thing"" in its broader sense and given examples, and I have stopped being so IoT-centric.
3: You can't participate in the agent ecosystem without keys. It is a universal requirement. You *can* hold a key without a wallet (e.g., in a config file). This is how static agents were defined. You can't get so lightweight that you don't use keys. An entity that doesn't hold keys can call an agent to get its work done, but is not in and of itself an agent.
4. I am very reluctant to apply an authoritative name, because there are several valid ways to name them. However, I changed the scenarios to be numbered, and then added a paragraph discussing appropriate names for each one. See what you think.
5. Agreed. Added some sentences about discoverability and connection in the middle of ""How Agents Talk"".
6. Done. Good idea.
7. Done.
8. Done.
9. Done.",2019-02-01 18:02:36,2019-02-01 18:02:36
https://api.github.com/repos/hyperledger/indy-hipe/issues/86,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/459812936,https://github.com/hyperledger/indy-hipe/pull/86#issuecomment-459812936,swcurran,"Awesome document with great writing.  It's technically helpful and correct, and the style and writing is extremely accessible.

I'm a little worried that for it's intended audience - a developer wanting to get started on developing SSI code - the Reference section raises way more question than it answers.  There are a ton of very subtle points raised in that section that could overwhelm someone new, and I don't think help a new developer.  Perhaps replace it with a link to another document with a note - ""yes, there be dragons, and once you know  enough, this will help you"".

I would consider adding some more to the general patterns section, focusing specifically on the two scenarios - Alice's agents and Faber's issuing agent.

- how agents connect - person to person, person to enterprise
- pairwise DIDs and where the ledger comes into play - always a question from new devs
- how Alice's two agents work together
- a bit more on how a Faber issuer might behave - this is partially covered but nice to have separated
- message families/protocols

Adding those in the same style would be awesome.  Great work!",2019-02-01 18:05:26,2019-02-01 18:05:26
https://api.github.com/repos/hyperledger/indy-hipe/issues/86,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/459979036,https://github.com/hyperledger/indy-hipe/pull/86#issuecomment-459979036,mwherman2000,"@dhh1128, unpacking your reply to 3...
> You can't participate in the agent ecosystem without keys. It is a universal requirement. 

Agree ...for self-sovereign identities ...but this document is specifically about agents, characteristics of agents, and type of agents.

> You can hold a key without a wallet (e.g., in a config file). This is how static agents were defined. 

Agree.  Updated https://hyperonomy.com/2019/02/01/architecture-driven-taxonomy-for-ssi-agents/ to reflect this.  Missed the _small print_ at the top of the Complexity diagram in the document.

> You can't get so lightweight that you don't use keys. 

Agree ...for self-sovereign identities ...but this document is specifically about agents, characteristics of agents, and type of agents (repeated from above).

> An entity that doesn't hold keys can call an agent to get its work done, but is not in and of itself an agent.

[What do you mean, specifically, by _entity_?]

Disagree ... and this is an important distinction for developers/builders.  Lightweight apps/clients/nodes typically have no local state (or virtually no local state).  In the context of the SSI Lightweight Agent, I'm assuming this to be true as well ...that the Lightweight Agent has no local state: no local wallet and no local configuration state (related specifically to the management of identities).  Lightweight Agents rely on a Cloud-located Agent for its wallet functionality. @dhh1128 I think we differ on this. ...here's v0.5 of the chart (significantly improved because of your comments related to point 3).

![#iDIDit: An Architecture-driven Taxonomy for SSI Agents v0.5](https://hyperonomy.files.wordpress.com/2019/02/hbb-ssi-agents-v0.5.png)

Reference: https://hyperonomy.com/2019/02/01/architecture-driven-taxonomy-for-ssi-agents/

Thoughts? Feedback?",2019-02-02 16:37:36,2019-02-02 16:58:32
https://api.github.com/repos/hyperledger/indy-hipe/issues/86,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/461147976,https://github.com/hyperledger/indy-hipe/pull/86#issuecomment-461147976,dhh1128,"@swcurran Agreed. I will move the ""here be dragons"" stuff into a separate doc.",2019-02-06 19:09:01,2019-02-06 19:09:01
https://api.github.com/repos/hyperledger/indy-hipe/issues/86,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/461238922,https://github.com/hyperledger/indy-hipe/pull/86#issuecomment-461238922,dhh1128,"@mwherman2000 The Indy community has chosen to define an agent using the 3 characteristics that I listed. This is not controversial; it has been settled for a long time. We know that ""agent"" has other definitions in other circles; in the intelligence community, they think about James Bond when they hear that word. In Archimate, there may be a different definition as well. But this is an SSI ecosystem, not a general-purpose enterprise software ecosystem. This is why an early paragraph of the doc says `When we use the term ""agent"" in the SSI community, we more properly mean ""an agent of self-sovereign identity."" This means something more specific than just a ""user agent"" or a ""software agent.""`

The reason why we chose our definition is that cryptographic keys are central to many constructs in the ecosystem. Keys are the unit of control and delegation for DIDs. They are also the unit of revocation for cred defs and agents. They are the unit of addressing and encryption when a message is packaged for one or more destinations. Keys govern credential issuance. Keys are the unit of signing. We want agents to align with these constructs, not span them in unhelpful ways.

Agents can't prove they hold delegated authority (my characteristic #1) without keys. So if you say that keys are not a defining characteristic of agents, you also eliminate delegation as a formally programmable/testable property. Furthermore, non-key-holding entitites can't participate in protocols either (except as an unknowable, invisible, unidentifiable entity fronted by something that *does* have keys), since all protocols depend on knowable participants, and knowable participants depend on encryption, which requires keys. So without keys, you can't have characteristic 3, either.

An app that doesn't hold keys cannot be held accountable for its own actions as a discrete participant in A2A interactions. An unaccountable piece of software is one that cannot be certified to comply with a trust framework and cannot be audited (e.g., to show that it generated a proof or sent a message). From A2A's perspective, it *isn't* a participant in interactions at the level of the protocol.

There is NO problem with building software that doesn't hold keys. Such software can add tons of business value and can act on the digital landscape. I'm sure there will be lots of stuff that works that way. But that stuff won't be an agent. We can't call it that, without completely reinventing a mental model that has huge momentum.

The thing you are calling a lightweight agent on a mobile device, I would call a tool or app or UI, but only half of an agent in the sense that our ecosystem expects. The agent is the combination of the front end on mobile, and the back end on cloud; together it exposes one discrete interaction surface to other participants, and its boundaries do not have to match hardware boundaries.

Static agents, which you placed in the ""lightweight"" bucket, DO hold keys. They just hold a statically configured set of them, and they don't negotiate new relationships. It is the staticness that defines them, not lack of keys.",2019-02-07 00:06:47,2019-02-07 00:06:47
https://api.github.com/repos/hyperledger/indy-hipe/issues/86,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/461632073,https://github.com/hyperledger/indy-hipe/pull/86#issuecomment-461632073,mwherman2000,"@dhh1128 Apologies for triggering a lengthy reply.  Based on your reply, what do you think of this?

![image](https://user-images.githubusercontent.com/6101736/52450352-dc21c480-2af7-11e9-90b4-b189e76e6de3.png)

",2019-02-07 23:18:39,2019-02-07 23:46:09
https://api.github.com/repos/hyperledger/indy-hipe/issues/86,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/461638157,https://github.com/hyperledger/indy-hipe/pull/86#issuecomment-461638157,mwherman2000,"Idea/Suggestion for re-crafting the Complexities section: After working through various versions of the above model, I'm wondering if it makes sense to craft the Complexity section using a Capabilities based model.  For example, the list of capabilities that an Agent can assume might include:
- UsesLocalWallet or HasLocalWallet
- UsesLocalConfig
- UsesLocalLedger
- IsRelay
- IsMediatorAgent

- EdgeLocated
- CloudLocated

etc. etc. etc.",2019-02-07 23:44:28,2019-02-08 01:03:24
https://api.github.com/repos/hyperledger/indy-hipe/issues/86,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/461645317,https://github.com/hyperledger/indy-hipe/pull/86#issuecomment-461645317,dhh1128,"@mwherman2000 Yes, I think that new diagram is great. The only things I would change are:

1. I think client apps could have local config. Not a local wallet, but local config.
2. I don't think relays have to be agents, because they don't need keys. Mediators *are* agents, but relays either could be or could not be.",2019-02-08 00:18:46,2019-02-08 00:21:08
https://api.github.com/repos/hyperledger/indy-hipe/issues/86,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/461648899,https://github.com/hyperledger/indy-hipe/pull/86#issuecomment-461648899,mwherman2000,"> 1. I think client apps could have local config. Not a local wallet, but local config.

I was envisioning Client Apps to be the front-end thingy in your first reply @dhh1128 : ""The agent is the combination of the front end on mobile, and the back end on cloud; together it exposes one discrete interaction surface to other participants, and its boundaries do not have to match hardware boundaries.""

![image](https://user-images.githubusercontent.com/6101736/52452166-3a9e7100-2aff-11e9-9c3c-dfdcab81d598.png)
",2019-02-08 00:36:43,2019-02-08 00:38:57
https://api.github.com/repos/hyperledger/indy-hipe/issues/83,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/469055917,https://github.com/hyperledger/indy-hipe/pull/83#issuecomment-469055917,tplooker,"@dhh1128 I think as a community we should chat about what we formally rename the A2A protocol to, personally i think `Didcomms` is too broad as there could be a variety of different ways two dids could communicate, my preference would be to qualify it further to something like `DidMessaging` or an even  less general term",2019-03-03 19:36:35,2019-03-03 19:36:35
https://api.github.com/repos/hyperledger/indy-hipe/issues/82,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/458267586,https://github.com/hyperledger/indy-hipe/pull/82#issuecomment-458267586,kdenhartog,"After reading through this, I'm thinking that we may be prematurely standardizing. My thinking is that this architecture pattern will naturally emerge and to jump on standardizing this message family too early will pigeonhole us. 

I realize that this will affect your implementation of the Python agent, so my suggestion is that we place this on hold until we've had time to see how this pattern overlaps with a few other primary/replica patterns. In the meantime, go ahead and implement something for your use case and we can use your implementation and learnings to guide the standardization later.",2019-01-28 19:27:27,2019-01-28 19:27:27
https://api.github.com/repos/hyperledger/indy-hipe/issues/82,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/458288657,https://github.com/hyperledger/indy-hipe/pull/82#issuecomment-458288657,blhagadorn,"@kdenhartog I think that's a good idea, the premature standardization process might start when we try to align too closely with the rest of the HIPE's in my opinion, however for a base discussion and the reference agent, this might be a good foundational document.  I'm not nearly as familiar with all of the HIPE's as I should be, but could we maybe make a list of HIPE's that would help dictate this one or at least help shape the aforementioned architecture for the final HIPE and in the meantime the reference agent? 

- ACKS: https://github.com/hyperledger/indy-hipe/pull/77 (as mentioned previously **EDIT: SOME** of these admin messages could be lumped into ACKS)
- Trust Ping Protocol: https://github.com/hyperledger/indy-hipe/pull/67 (one of the message types proposed here)
- What else am I forgetting? I'll edit as need be",2019-01-28 20:27:46,2019-01-30 20:53:28
https://api.github.com/repos/hyperledger/indy-hipe/issues/82,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/458960629,https://github.com/hyperledger/indy-hipe/pull/82#issuecomment-458960629,TelegramSam,"@blhagadorn Not ALL these admin messages can be converted to ACKs, just some of them.

The specific messages mentioned in this HIPE were intended as examples of what types of Admin Messages would be useful. If created, Admin Messages for those Message Families would need to be defined somewhere else.",2019-01-30 14:20:46,2019-01-30 14:20:46
https://api.github.com/repos/hyperledger/indy-hipe/issues/82,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/460893752,https://github.com/hyperledger/indy-hipe/pull/82#issuecomment-460893752,blhagadorn,"Hi all, @dbluhm briliiantly drew a diagram for me earlier on a whiteboard (hopefully I got it right) that I think could help frame understanding and improvement of Admin Message Families.  Definitely looking for feedback and hope to make a few with more flow around the arrows for BasicMessage and TrustPing examples and for those that might be visually inclined.
![image](https://user-images.githubusercontent.com/4451303/52319778-29375680-2991-11e9-872c-1047c6e3c690.png)
",2019-02-06 03:59:53,2019-02-06 04:00:54
https://api.github.com/repos/hyperledger/indy-hipe/issues/82,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/461280865,https://github.com/hyperledger/indy-hipe/pull/82#issuecomment-461280865,dbluhm,"> Hi all, @dbluhm briliiantly drew a diagram for me earlier on a whiteboard (hopefully I got it right) that I think could help frame understanding and improvement of Admin Message Families. Definitely looking for feedback and hope to make a few with more flow around the arrows for BasicMessage and TrustPing examples and for those that might be visually inclined.

@blhagadorn as a side note, we're pretty close to implementing a JS version of pack and unpack to encrypt and authorize even the admin messages. Just noticed in your diagram that whether the message was encrypted was a distinguishing characteristic of the kind of message but hopefully everything will be encrypted soon :slightly_smiling_face: ",2019-02-07 04:01:45,2019-02-07 04:01:45
https://api.github.com/repos/hyperledger/indy-hipe/issues/82,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/461283333,https://github.com/hyperledger/indy-hipe/pull/82#issuecomment-461283333,dbluhm,"> After reading through this, I'm thinking that we may be prematurely standardizing. My thinking is that this architecture pattern will naturally emerge and to jump on standardizing this message family too early will pigeonhole us.
> 
> I realize that this will affect your implementation of the Python agent, so my suggestion is that we place this on hold until we've had time to see how this pattern overlaps with a few other primary/replica patterns. In the meantime, go ahead and implement something for your use case and we can use your implementation and learnings to guide the standardization later.

@kdenhartog I think it's reasonable for us to continue using this concept without standardizing the messages and the format if that is ultimately what is needed; that being said, didn't we include versioning in the message types so we could iterate on our ideas? I don't think the question here is whether we're in danger of prematurely standardizing or pigeon-holing ourselves.",2019-02-07 04:20:48,2019-02-07 04:20:48
https://api.github.com/repos/hyperledger/indy-hipe/issues/81,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/455204351,https://github.com/hyperledger/indy-hipe/pull/81#issuecomment-455204351,TelegramSam,"> I think it would be useful to declare this a message type (one instance of a message family) so that we can use the HIPE update process to add the out of scope message types over time.
> 
> outside of that, I think this works, is clean, and gets the job done. Let's FCP this before scope creep comes in. 😎

I think it should be a whole new message family for full-featured solutions. I think the full-featured families are likely to change more rapidly and having just a simple message family be independent of those will serve as a fallback option if needed.",2019-01-17 15:06:35,2019-01-17 15:06:35
https://api.github.com/repos/hyperledger/indy-hipe/issues/81,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/458268160,https://github.com/hyperledger/indy-hipe/pull/81#issuecomment-458268160,kdenhartog,What's the advantage of having separate message family rather than one giant message family for generalized text-based messaging?,2019-01-28 19:28:55,2019-01-28 19:28:55
https://api.github.com/repos/hyperledger/indy-hipe/issues/81,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/458720507,https://github.com/hyperledger/indy-hipe/pull/81#issuecomment-458720507,dbluhm,"> What's the advantage of having separate message family rather than one giant message family for generalized text-based messaging?

My personal thinking (to this point at least) is that message families provide a nice grouping of messages that can be easily used to communicate the capabilities of any given agent. However, I don't think this means that we can't communicate partial support for message types within a message family. At the same time, I think a separation between the BasicMessage and other more fully featured messaging protocols would be cleaner.",2019-01-29 21:48:58,2019-01-29 21:48:58
https://api.github.com/repos/hyperledger/indy-hipe/issues/81,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/461280063,https://github.com/hyperledger/indy-hipe/pull/81#issuecomment-461280063,dhh1128,"I vote to merge this HIPE. However, I'd like to suggest one simple change: can we call this ""PrimitiveMessage"" instead of ""BasicMessage? This name seems more in harmony with the bare-bones target we are striving for, whereas BasicMessage sounds like something we would extend.

Even if this suggestion is not accepted, I am still okay with merging the HIPE.",2019-02-07 03:55:39,2019-02-07 03:55:39
https://api.github.com/repos/hyperledger/indy-hipe/issues/80,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/454567248,https://github.com/hyperledger/indy-hipe/pull/80#issuecomment-454567248,TelegramSam,"@dhh1128, I'm curious why you felt the need to add this?",2019-01-15 21:57:21,2019-01-15 21:57:21
https://api.github.com/repos/hyperledger/indy-hipe/issues/80,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/454876984,https://github.com/hyperledger/indy-hipe/pull/80#issuecomment-454876984,dhh1128,"@TelegramSam In internal Evernym discussions, we were using the term ""Agent Message"" in a number of design docs, and also in informal conversations, and we were confusing one another. When we dug into it, we realized that in many cases we intended the concept of a Native Object format for a message, but lacked a word for it. Once we created a term for the concept, a lot of the confusion evaporated. So I'm just suggesting that this concept needs to be formally described and labeled. I'm not wedded to the label, and I'm also not wedded to placing the description in this HIPE (which is, after all, about file formats, NOT about Native Object format). But this was the best home for it that I could think of.",2019-01-16 17:57:08,2019-01-16 17:57:08
https://api.github.com/repos/hyperledger/indy-hipe/issues/79,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/452748523,https://github.com/hyperledger/indy-hipe/pull/79#issuecomment-452748523,swcurran,"This is like the ""attachments"" HIPE in that it makes sense, but it would be great to have some use cases as to where this would be used.

I'm also intrigued as to using this with anoncrypt vs. using authcrypt.  Could I get the same impact (same business function) of authcrypt by using anoncrypt and adding the signature decorator on the ciphertext field?  I'm guessing not... :-)",2019-01-09 15:58:29,2019-01-09 15:58:29
https://api.github.com/repos/hyperledger/indy-hipe/issues/79,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/452842165,https://github.com/hyperledger/indy-hipe/pull/79#issuecomment-452842165,tplooker,"Great HIPE, once this has matured further I might modify #75 to use this functionality to provide proof of ownership of a routing identifier.",2019-01-09 20:18:31,2019-01-09 20:18:31
https://api.github.com/repos/hyperledger/indy-hipe/issues/79,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/452885497,https://github.com/hyperledger/indy-hipe/pull/79#issuecomment-452885497,kdenhartog,"> This is like the ""attachments"" HIPE in that it makes sense, but it would be great to have some use cases as to where this would be used.
> 
> I'm also intrigued as to using this with anoncrypt vs. using authcrypt. Could I get the same impact (same business function) of authcrypt by using anoncrypt and adding the signature decorator on the ciphertext field? I'm guessing not... :-)

I agree, I think a perfect first use case is with @tplooker PR #75 and we'll eventually need it for credentials as well.

With regards to the anoncrypt w/ signature decorator there is a slight difference. The difference being that with Authcrypt, repudiable authentication is used, where as with the suggestion you included it's non-repudiable authentication. These properties have subtle difference that will affect privacy which is why we've defaulted to using authcrypt with the option of adding non-repudiable signatures for authentication.",2019-01-09 22:02:53,2019-01-09 22:02:53
https://api.github.com/repos/hyperledger/indy-hipe/issues/79,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/453557589,https://github.com/hyperledger/indy-hipe/pull/79#issuecomment-453557589,TelegramSam,"> have some use cases as to where this would be used.

Connection protocol (and later maintenance) needs this.",2019-01-11 15:39:06,2019-01-11 15:39:06
https://api.github.com/repos/hyperledger/indy-hipe/issues/79,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/453558618,https://github.com/hyperledger/indy-hipe/pull/79#issuecomment-453558618,TelegramSam,"As I see it, these signatures can be processed by a receiving agent prior to presenting the data to a message handler. Then the handler can access the verified signature metadata and the signed data easily.

as an alternative, convenience functions can be used to access signed data inside the handler, to simplify the processing of these signatures.

Some quick text describing that intent could be helpful in the HIPE to help explain how the complexity of using these signatures can be mitigated. ",2019-01-11 15:42:11,2019-01-11 15:42:11
https://api.github.com/repos/hyperledger/indy-hipe/issues/79,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/462078041,https://github.com/hyperledger/indy-hipe/pull/79#issuecomment-462078041,cywolf,"I could use some detail on the timestamp representation, ""append timestamp as 8 bytes to the front of the message data"". Is that a big-endian unsigned (long) int?",2019-02-09 20:47:23,2019-02-09 20:47:23
https://api.github.com/repos/hyperledger/indy-hipe/issues/79,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/464971318,https://github.com/hyperledger/indy-hipe/pull/79#issuecomment-464971318,mikelodder7,"> I could use some detail on the timestamp representation, ""append timestamp as 8 bytes to the front of the message data"". Is that a big-endian unsigned (long) int?

That's what I thought it was. I agree it should be clarified to state ""This timestamp field is a 64-bit unsigned big-endian integer. It records the number of seconds elapsed between January 1, 1970 UTC and the time the token was created.""",2019-02-19 03:53:55,2019-02-19 03:53:55
https://api.github.com/repos/hyperledger/indy-hipe/issues/79,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/464997054,https://github.com/hyperledger/indy-hipe/pull/79#issuecomment-464997054,kdenhartog,"> > I could use some detail on the timestamp representation, ""append timestamp as 8 bytes to the front of the message data"". Is that a big-endian unsigned (long) int?
> 
> That's what I thought it was. I agree it should be clarified to state ""This timestamp field is a 64-bit unsigned big-endian integer. It records the number of seconds elapsed between January 1, 1970 UTC and the time the token was created.""

Thank you for clarifying. I hadn't gotten around to looking up what was being used in the standard. I'll add this detail to the HIPE.",2019-02-19 06:04:17,2019-02-19 06:04:17
https://api.github.com/repos/hyperledger/indy-hipe/issues/79,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475477403,https://github.com/hyperledger/indy-hipe/pull/79#issuecomment-475477403,kdenhartog,What's our consensus on moving this towards JWS? I'm in favor at this point.,2019-03-22 03:00:35,2019-03-22 03:00:35
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/451469091,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-451469091,TelegramSam,"I think this HIPE contains great thinking but lacks application examples necessary to evaluate its applicability as a decorator. 

I'm wondering if we need a way within the HIPE process to group 'future thinking' or 'tabled ideas' so that we don't have to lose them from the community conversation, but don't yet have to accept something that we don't yet have enough experience or information to evaluate.",2019-01-04 15:07:01,2019-01-04 15:07:01
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/452422850,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-452422850,kdenhartog,"> I think this HIPE contains great thinking but lacks application examples necessary to evaluate its applicability as a decorator.

I would say a perfect example of this will be with the driver's license use case for credential exchange. When the Department of Transportation wants to issue a digital driver's license they'll need to issue a picture along with the credential. In this use case, this would be a perfect decorator to use... once we convert credential exchange to an A2A message family.
",2019-01-08 19:30:26,2019-01-08 19:30:26
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/452741971,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-452741971,swcurran,"Not sure this would be a good example for what @kdenhartog references.  It's absolutely a real use case, but the picture will be a field in the driver's licence Credential, not a decorator on a Message.",2019-01-09 15:41:56,2019-01-09 15:41:56
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/454219798,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-454219798,kdenhartog,"In that example, I'm making the assumption that credentials will be converted to a message family which would then make use of the decorator. Without making this assumption though, I could think of another use case.

When a bank is issuing a loan in the beginning, they'll support both digital and paper documents. The digital form will use credentials, but may also require an image of the document which has been physically signed. In this case, the message for the loan protocol would need to support a message type which includes both credential data and the image of the signed document. This idea could be extrapolated for any image which requires provenance.

Additionally, this allows for two identity owners to be certain that they are viewing the same content that exists behind a dynamic link. This is advantageous to build more complex protocols that relate to some digital content.

These are just two examples where this decorator would be useful. I'm sure there are more, leading me to believe that a general solution would be adequately used in message family designs. ",2019-01-15 00:36:24,2019-01-15 00:36:24
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/454501183,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-454501183,kdenhartog,This work is similar to the one hashlink work that just came through the W3C-CCG as a work item. Should we be aligning this HIPE with the hashlink spec in any way? Here's a link to the spec. https://tools.ietf.org/html/draft-sporny-hashlink-02,2019-01-15 18:34:12,2019-01-15 18:34:12
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475654073,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-475654073,TelegramSam,"Love the new additions.

Should inline attachments use the `~attach` attribute suffix? as in `someattribute~attach` when the value is an inline attachment? This signals that the value is able to be processed as an attachment structure.

I think the attachment block could benefit from an optional `description` attribute. If I get a message from my tax service with a variety of attachments, each could contain their own description.

Also relevant to the discussion is the forward message, which contains a message to forward.",2019-03-22 14:59:59,2019-03-22 14:59:59
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475681693,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-475681693,dhh1128,"@TelegramSam Do you mean *embedded* attachments? They do use the attachment structure, whereas the *inline* attachments do not.

Agreed on the `description` attribute.

Thanks for pointing out the `forward` message. I had forgotten that. I'll look for a place to mention it.",2019-03-22 16:12:50,2019-03-22 16:12:50
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475699122,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-475699122,TelegramSam,"Yes, I meant embedded.",2019-03-22 17:00:37,2019-03-22 17:00:37
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475758982,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-475758982,mwherman2000,"Especially in the _appending_ scenario (e.g. https://github.com/hyperledger/indy-hipe/blob/bd48bae3712e659c34d88c6dea839ccf5a0f0701/text/attachments/README.md#appending), I think it would be use to have an `id` attribute to support the ability to directly reference at particular attachment, n'est pas ...using a mechanism similar to _DID Resolution_ (i.e. notationally but not specifically).

By extension, I think this (the `id` attribute) also makes sense for the other two scenarios: _inlining_ and _embedding_.",2019-03-22 19:53:48,2019-03-22 19:53:48
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475789353,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-475789353,swcurran,"A minor whine about the use of JSON pictures instead of just using GitHub code highlighting.  Yes, the picture is (slightly) clearer, but when, for example, looking at the raw MD diffs to see what changed, we can't see the JSON at all.  Further, it's more difficult to do a subsequent PR that changes the JSON. I assume there are directions about how the pictures are generated?

My recommendation is that we stick to Github JSON code highlighting.",2019-03-22 21:28:04,2019-03-22 21:28:04
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475819460,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-475819460,dhh1128,"@swcurran You have brought this up before, and I've answered it before. I'm wondering if I didn't make it clear enough, so let me try again and see if I can alleviate the concern. If not, maybe I should abandon the strategy.

The README.md references images like this:
`[![alt text](img.png)](x.json)`

What this means is that every image is linked to a JSON file (in the example, x.json) that shows the diff.  If you click on any of the images, you get json that you can copy and paste. There will be line-item diffs any time the JSON in an image changes; they just won't be in the main README.

If I embed the JSON directly, then I lose the ability to use callouts, arrows, and other annotations. I'm doing that in the images here. Images are generated by viewing the related .json file in a text editor, screenshotting, and then drawing the related annotations atop the .png that results.

Did that resolve your concern, or does it still feel like it's not worth it to you?",2019-03-22 23:59:27,2019-03-23 00:16:31
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475821401,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-475821401,dhh1128,"@mwherman2000 Thanks for the review! What you are asking for is what the `nickname` attribute is doing. `nickname` was chosen as the name because in email attachments, being able to refer to them in a human-friendly way is useful. We could rename it `id`... I know that's what you've become used to because of your exposure to `id` in DID Docs. However, DID Docs are schizophrenic, because JSON-LD actually uses (and mandates!) `@id` in some places, not `id`. Apparently the usage of `id` vs. `@id` in JSON-LD circles has changed over time. See point 4 in this comment: https://github.com/w3c-ccg/did-method-registry/pull/33#pullrequestreview-217908493

We are currently using JSON-LD's `@id` to identify messages, so if you really want this field name to change, my inclination would be to vote for `@id` (already permitted and defined by JSON-LD) instead of `id`. How strongly do you prefer `id`?",2019-03-23 00:14:08,2019-03-23 00:14:08
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475821859,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-475821859,dhh1128,"@TelegramSam What do you think about @mwherman2000's suggestion to rename `nickname`? I don't have that strong of an opinion either way, but just want to do what several people vote for.
",2019-03-23 00:18:09,2019-03-23 00:18:09
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475839580,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-475839580,mwherman2000,"@dhh1128 @TelegramSam The rationale for maintaining a consistent name for the ""`id`"" attribute will become clear by the end of the weekend.  I'm preparing a new specification, the _Decentralized Identifier URL Specification (`did-url-spec`)_, that separates out the `did-url` grammar in such away that the ABNF notation for a `did-url` can become shared technology across every possible usage scenario -- and not just _DID Resolution_.  

To read the Purpose and Status of the specification, click [here](https://github.com/mwherman2000/did-url-spec/blob/master/README.md#purpose).

The Indy _feature discovery_ and _attachments_ HIPEs helped to shed a very bright light on the need for this shared `did-url` specification, grammar, and parser reference implementation. ...and in doing so, I have been able to easily accommodate the ""DID needs"" of these 2 HIPEs as well as the following additional (primary) application scenarios (aka _High-level use case documents_):

- [W3C Decentralized Identifier specification](https://github.com/w3c-ccg/did-spec)
- DID Resolvers and [DID Resolution](https://github.com/w3c-ccg/did-resolution)
- Agent-to-Agent (A2) Communications services in the Hyperledger Indy Agent framework - for example,
   - the [Indy draft feature-discovery 1.0 HIPE](https://github.com/dhh1128/indy-hipe/blob/9c7722d208cfe0a336cb67a626cbbb192ae73f8c/text/feature-discovery/README.md), and
   - the [Indy draft attachments HIPE](https://github.com/hyperledger/indy-hipe/blob/bd48bae3712e659c34d88c6dea839ccf5a0f0701/text/attachments/README.md#hipe-00-attachments).

A draft of the `did-uri-spec` presentation can be found here: https://github.com/mwherman2000/did-uri-spec/tree/master/src

...but I encourage you to wait until Monday morning to watch the YouTube webcast of this presentation.",2019-03-23 04:56:27,2019-03-28 13:23:12
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/477268278,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-477268278,TelegramSam,"I don't love nickname, but don't love id as it conflicts with @id. Does json-ld allow for the @id to be relative to the outside message? So...
```
{
""@type"":""..."",
""@id"":""234567890"",
""image~attach"": {
  ""@id"": ""image5"",
  ...
}
}
```
And the image attachment could be referred to as `234567890/image5`?

Rough thought, but based on this from the jsonld spec: 

> JSON-LD allows IRIs to be specified in a relative form which is resolved against the document base
",2019-03-27 17:29:03,2019-03-27 17:29:20
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/477276896,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-477276896,mwherman2000,"That might be workable too.  I'm uploading the webcast now.  Will post the URL later this afternoon (3 hour upload time).

So let me ask, should the `did-spec` also consider using `@id` instead of just `id` as the name of the ""id"" attribute in a DID Document?

I like the composition idea a lot.  Some care/guidelines would be needed to ensure the composite identifiers are still valid ""whatever"" specific type of identifiers ...for example, what if the value of both `@id` attributes were both `did-url`s ...then the composition wouldn't be a valid `did-url`?",2019-03-27 17:48:05,2019-03-27 17:48:25
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/477599601,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-477599601,mwherman2000,"This video is available here (first in the playlist):
_Hyperonomy Universal Decentralized Identifier URI Specification (did-uri-spec) v0.14_ (https://www.youtube.com/playlist?list=PLU-rWqHm5p45c9jFftlYcr4XIWcZb0yCv).

The PPT itself can be found here: https://github.com/mwherman2000/did-uri-spec/tree/master/src",2019-03-28 13:41:50,2019-03-28 13:41:50
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/477640512,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-477640512,dhh1128,"I'm really liking @id as a relative rather than absolute identifier, when not at the root level of message.",2019-03-28 15:17:57,2019-03-28 15:17:57
https://api.github.com/repos/hyperledger/indy-hipe/issues/78,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/477788747,https://github.com/hyperledger/indy-hipe/pull/78#issuecomment-477788747,dhh1128,@TelegramSam and @mwherman2000 I have updated the HIPE to use `@id` instead of `nickname`,2019-03-28 22:06:18,2019-03-28 22:06:18
https://api.github.com/repos/hyperledger/indy-hipe/issues/77,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/450525708,https://github.com/hyperledger/indy-hipe/pull/77#issuecomment-450525708,swcurran,"My challenge with this proposed HIPE is how this kind of cross-cutting message type will be used. This feels like an optimization/refactoring of code that has not yet been written. It might be a good idea, but until we have working code and experience using that code, we don't really know.  

I can't see many developers embracing ACKs when building the first few message families vs. putting in explicit ACK message types within a Family where they make sense.  I think those first message families will try to be inclusive - encapsulating all of the context of the goal interaction (e.g. issue/receive Credential, proof request/proof, etc.).  If so, an independent ACK will be a challenge (non-intuitive) to integrate, since it is handled by a different message family but needs access to the context of the instance of the goal interaction message family to form a reply.  My guess is that in order to really support generalized ACKs, each message family will have to expose an ""ACK"" handling method. Since that means each message family has to implement ACK handling - why not just let ACK be an explicit part of message families? It's less abstract to build and maintain - all the message types and context are in the same message family spec.

But that's where the potential refactoring comes in. Maybe it will be easier/better to have an independent ACK message type and to structure the message families to be callable for handling the ""interaction specific"" logic of the ACK without duplicating the rest of the ACK handling code.  For example, each message family must define what ""Outcome"" means in the context of a specific transaction (obviously a single global ACK handler can't) and so the message family could expose ""Outcome"" details, and the ACK message type could handle the rest of the interaction.

A separate aside: It seems to me that this proposal does lead us to a conversation about how an Agent message handler should be constructed. Given we have message families, threads, state and cross-cutting message types (Ack, Problem Report) - what is the best way to structure an agent?",2018-12-29 22:42:56,2018-12-29 22:42:56
https://api.github.com/repos/hyperledger/indy-hipe/issues/77,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/451465716,https://github.com/hyperledger/indy-hipe/pull/77#issuecomment-451465716,TelegramSam,"Two things:

1. I think the utility of a 'message received ack' is very useful. This can be processed in a message pre-processor to make this consistent across all received messages. Using a decorator to request this type of ack is I think a good idea.

2. The rest of this HIPE deals with much more complicated situations, including requesting an ack for a previously sent message and ack of internal protocol state. I think we are far too young as an ecosystem to be discussing this level of standardization between message families. I recommend that this deeper discussion be tabled until we have developed examples of such complex needs.",2019-01-04 14:55:14,2019-01-04 14:55:14
https://api.github.com/repos/hyperledger/indy-hipe/issues/77,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/461278492,https://github.com/hyperledger/indy-hipe/pull/77#issuecomment-461278492,dhh1128,"@swcurran and @TelegramSam : I have moved the fancy stuff about acks for messages other than the current one, and about outcomes and so forth, into an ""experimental"" section to make clear that it is not a required part of the 1.0 protocol. I also added a note about how to adopt acks into other message families. I hope this resolves the concern about routing that Stephen noted above, and about premature standardization.",2019-02-07 03:44:44,2019-02-07 03:44:44
https://api.github.com/repos/hyperledger/indy-hipe/issues/77,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/479481892,https://github.com/hyperledger/indy-hipe/pull/77#issuecomment-479481892,TelegramSam,"There are two open TODO sections on this HIPE, but I believe both can be removed and saved for a future update with more advanced use cases. With those removed, I believe this is a candidate for FCP.",2019-04-03 13:09:29,2019-04-03 13:09:29
https://api.github.com/repos/hyperledger/indy-hipe/issues/77,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/479576520,https://github.com/hyperledger/indy-hipe/pull/77#issuecomment-479576520,dhh1128,"> There are two open TODO sections on this HIPE, but I believe both can be removed and saved for a future update with more advanced use cases. With those removed, I believe this is a candidate for FCP.

@TelegramSam Which are the two open TODO items? My previous comment (""I have moved the fancy stuff"") addressed what I thought were the TODOs, so I am wondering if I missed something.",2019-04-03 17:06:39,2019-04-03 17:06:39
https://api.github.com/repos/hyperledger/indy-hipe/issues/74,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/448716354,https://github.com/hyperledger/indy-hipe/pull/74#issuecomment-448716354,swcurran,"Looks great. I like the format of the HIPEs in this repo better - the improvement in the use of the header hierarchy.

Is there a test instance of the generated RTD docs that we could look at?  I notice there are a number of ones on readthedocs already.  That would be the litmus test for this.

That said, it would be good to get this accepted and to give a bit of guidance to all those with inflight HIPEs on what they need to do to align them with this model.  Most importantly - we need to get the fixes into the ""template"" Readme, so that new proposed HIPEs don't have to be fixed.

IMHO - The sooner this is merged, the better.

Nice work!",2018-12-19 19:30:48,2018-12-19 19:30:48
https://api.github.com/repos/hyperledger/indy-hipe/issues/74,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/449764681,https://github.com/hyperledger/indy-hipe/pull/74#issuecomment-449764681,michaeldboyd,"> Looks great. I like the format of the HIPEs in this repo better - the improvement in the use of the header hierarchy.
> 
> Is there a test instance of the generated RTD docs that we could look at? I notice there are a number of ones on readthedocs already. That would be the litmus test for this.
> 
> That said, it would be good to get this accepted and to give a bit of guidance to all those with inflight HIPEs on what they need to do to align them with this model. Most importantly - we need to get the fixes into the ""template"" Readme, so that new proposed HIPEs don't have to be fixed.
> 
> IMHO - The sooner this is merged, the better.
> 
> Nice work!

Here is the test instance: https://indy.readthedocs.io/projects/hipe/en/latest/text/index.html",2018-12-24 19:12:50,2018-12-24 19:12:50
https://api.github.com/repos/hyperledger/indy-hipe/issues/74,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/458719129,https://github.com/hyperledger/indy-hipe/pull/74#issuecomment-458719129,michaeldboyd,"@dhh1128 @nage are there any other changes to implement before this can be merged?
",2019-01-29 21:44:38,2019-01-29 21:44:38
https://api.github.com/repos/hyperledger/indy-hipe/issues/73,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/450452496,https://github.com/hyperledger/indy-hipe/pull/73#issuecomment-450452496,dhh1128,I will be updating this HIPE to bring it into conformance with the PR about how to define protocols (#69 ).,2018-12-29 01:26:56,2018-12-29 01:26:56
https://api.github.com/repos/hyperledger/indy-hipe/issues/73,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/477239437,https://github.com/hyperledger/indy-hipe/pull/73#issuecomment-477239437,TelegramSam,"I've added a few inline comments. Aside from those minor suggestions, my only reservation is the fairly early definition of roles in protocols. I don't want to wait though, and as it's an optional field I think we are nearly ready for FCP on this HIPE.",2019-03-27 16:28:38,2019-03-27 16:28:38
https://api.github.com/repos/hyperledger/indy-hipe/issues/73,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/477364424,https://github.com/hyperledger/indy-hipe/pull/73#issuecomment-477364424,dhh1128,"@TelegramSam I believe all outstanding issues have been resolved. The PR needs to be renamed to call it the ""protocol discovery"" PR instead of the ""feature discovery"" PR.",2019-03-27 22:02:15,2019-03-27 22:02:15
https://api.github.com/repos/hyperledger/indy-hipe/issues/73,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/478095789,https://github.com/hyperledger/indy-hipe/pull/73#issuecomment-478095789,swcurran,Looks good!  Let's move it forward.,2019-03-29 18:05:36,2019-03-29 18:05:36
https://api.github.com/repos/hyperledger/indy-hipe/issues/73,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/478124685,https://github.com/hyperledger/indy-hipe/pull/73#issuecomment-478124685,dhh1128,"@TelegramSam and @swcurran I wonder if we need to provide a way to find out which decorators an agent will support? Obviously, it must support any that are required by a protocol--but would it be important to know whether it supports ~timing.expiration_time, for example? Or ~please_ack? Or...",2019-03-29 19:38:12,2019-03-29 19:38:12
https://api.github.com/repos/hyperledger/indy-hipe/issues/73,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/479478838,https://github.com/hyperledger/indy-hipe/pull/73#issuecomment-479478838,TelegramSam,"> @TelegramSam and @swcurran I wonder if we need to provide a way to find out which decorators an agent will support? Obviously, it must support any that are required by a protocol--but would it be important to know whether it supports ~timing.expiration_time, for example? Or ~please_ack? Or...

Heh. I just left this comment on the message tracing proposed HIPE. I do think that is valuable, but maybe not necessary for this initial HIPE.",2019-04-03 13:01:09,2019-04-03 13:01:09
https://api.github.com/repos/hyperledger/indy-hipe/issues/73,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/479480118,https://github.com/hyperledger/indy-hipe/pull/73#issuecomment-479480118,TelegramSam,"So, if we provide a docs link to each decorator like we do for message families, they become automatically applied to this discovery process. Seems worth discussing over in the decorator HIPE.",2019-04-03 13:04:40,2019-04-03 13:04:40
https://api.github.com/repos/hyperledger/indy-hipe/issues/72,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/447901514,https://github.com/hyperledger/indy-hipe/pull/72#issuecomment-447901514,TelegramSam,"I am very convinced of the need for this behavior for institutional agents, and the argument that institutional agents are often squashed onto a single box.

The best use case for this behavior is institutions that want to allow 'api style' access to their agents via static agents. This helps with internal integration with existing systems, and could also allow outside developers access via the same mechanism.

I'm not convinced that we need this feature for any transport other than HTTP.

Given the narrow need for this using HTTP in static agent cases, I wonder if we should define this behavior in a document that describes the HTTP agent transport.

Also, I anticipate that this behavior will be mostly applied to specific message families that are prepared to return responses immediately. In that case, a general decorator may not be needed.",2018-12-17 16:13:27,2018-12-17 16:13:27
https://api.github.com/repos/hyperledger/indy-hipe/issues/72,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/459385726,https://github.com/hyperledger/indy-hipe/pull/72#issuecomment-459385726,TelegramSam,"On a new read of this, I have new thoughts. We have not discussed as a community how A2A messaging applies to various transports such as HTTP, websockets, email, or bluetooth. Each of these transports will have properties or mechanisms that should be considered. 

The issues proposed here relate specifically to HTTP as a transport.

Also relevant to this topic is return message routing options for agents unable to offer an inbound route. Do they poll for responses? How do they express that desire?",2019-01-31 15:27:27,2019-01-31 15:27:27
https://api.github.com/repos/hyperledger/indy-hipe/issues/72,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/460000845,https://github.com/hyperledger/indy-hipe/pull/72#issuecomment-460000845,peacekeeper,"This HIPE reminds me of something we did in XDI, see this PR: https://github.com/dhh1128/indy-hipe/pull/7",2019-02-02 21:32:01,2019-02-02 21:32:01
https://api.github.com/repos/hyperledger/indy-hipe/issues/72,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/461278765,https://github.com/hyperledger/indy-hipe/pull/72#issuecomment-461278765,dhh1128,@peacekeeper Thanks for the pointer! Love it. Added.,2019-02-07 03:46:36,2019-02-07 03:46:36
https://api.github.com/repos/hyperledger/indy-hipe/issues/72,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/462528782,https://github.com/hyperledger/indy-hipe/pull/72#issuecomment-462528782,swcurran,"Reread this and I still don't understand how this manifests into an implementation.  Suppose I say I want a message to be sync rather than async.  Does that mean the A2A message will be treated like a request and answered with a response (""200"", ""404"", etc.), rather than a new message being created in response to the first?

If so, does that means only certain messages/message families could use sync, and they would need to say what a response would mean for each request. Further, as I think is noted in the HIPE, the message family would also have to define a message type with a response for when async is used.

I can't see how this would be any better than a threaded message that is the response to a request message with a suggested/required response time.

Help! :-)",2019-02-11 22:57:15,2019-02-11 22:57:15
https://api.github.com/repos/hyperledger/indy-hipe/issues/69,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/450451952,https://github.com/hyperledger/indy-hipe/pull/69#issuecomment-450451952,dhh1128,"I have revised this HIPE significantly. The content about Tic Tac Toe is mostly unmodified, but there is now a main README that discusses what protocols are and how they should be defined and documented by a HIPE. The Tic Tac Toe HIPE is then presented as a hyperlinked example.",2018-12-29 01:19:15,2018-12-29 01:19:15
https://api.github.com/repos/hyperledger/indy-hipe/issues/67,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/447422200,https://github.com/hyperledger/indy-hipe/pull/67#issuecomment-447422200,devin-fisher,"I think the protocol needs at least an optional nonce.  I think it should be required but those with better crypto chops could convince me that the overhead is not needed sometimes. 

[Cryptographic Nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce)",2018-12-14 19:02:00,2018-12-14 19:02:00
https://api.github.com/repos/hyperledger/indy-hipe/issues/67,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/447423763,https://github.com/hyperledger/indy-hipe/pull/67#issuecomment-447423763,devin-fisher,"I'm confused, if the `@id` is not required for the `ping` but the `@thread` is required for the pong and the `@thread` really requires an `thid` that is based on the `@id` of the ping. How could this logically work without an `@id`?",2018-12-14 19:07:12,2018-12-14 19:07:12
https://api.github.com/repos/hyperledger/indy-hipe/issues/65,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/458560925,https://github.com/hyperledger/indy-hipe/pull/65#issuecomment-458560925,TelegramSam,"I feel like there should be an error code field. There is a code for the human-readable error, but not necessarily a top-level attribute with a code that can be specified in a message family and matched when processing the error message.",2019-01-29 14:31:51,2019-01-29 14:31:51
https://api.github.com/repos/hyperledger/indy-hipe/issues/64,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443407372,https://github.com/hyperledger/indy-hipe/pull/64#issuecomment-443407372,swcurran,"First cut is I really like this.  This overlaps (overlays?) with the schemas and overlays work, as a key use case of that is localization specifically as it relates to schema. This is more general, but still complementary.  With VON, we've already experienced the same challenge. Our first cut had been the traditional approach you mention - the UI software presenting the data does the localization, which does not scale to our many Issuers.  The Issuers to be able to convey to the Holder the localization data about what is being issued. 

The only concern I have with this is whether there is a need to focus on the trustworthiness of the catalog.  I think the catalog is necessary.  Is there a concern that the translations mechanism can be used to confuse users - e.g. translate ""Yes"" to ""No"" and vice-versa for an important transaction.  Or is my tinfoil hat on too tight?",2018-12-01 07:41:40,2018-12-01 07:41:40
https://api.github.com/repos/hyperledger/indy-hipe/issues/64,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443784369,https://github.com/hyperledger/indy-hipe/pull/64#issuecomment-443784369,TelegramSam,"Ideas: 
1. Declare the locale at the message level. Then all strings can be assumed to be that locale unless otherwise specified. At a minimum, this allows machine translation in the absence of more localization detail.
3. Use the attribute string itself as a reference to the string in the msg_catalog. This works well with short strings.
2. Include localization detail with sibling attributes, not manipulation of the main attribute. 
Example:
```json
{
  //... normal message stuff
  ""@locale"":""en"",
  ""@msg_catalog"": ""<catalog uri>"",
  ""some_string_attribute"":""This is a test"",
  ""some_string_attribute_loc"": {
    ""code"": ""this_is_a_test"",
    ""es"": ""<translation of 'this is a test'>""
  }
}
```
Example Notes:
Even without the .._loc attribute, you can look up  ""This is a test"" in the catalog.
The sibling ..._loc attribute makes it easier for schema parsers. They will ignore it if they are not expecting it.
These changes allows the localization to be 'additive' in that you can add localization without modifying the existing attribute structures. This removes barriers to making something localized when it wasn't to start out.",2018-12-03 16:58:32,2018-12-03 16:58:32
https://api.github.com/repos/hyperledger/indy-hipe/issues/64,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445111567,https://github.com/hyperledger/indy-hipe/pull/64#issuecomment-445111567,dhh1128,"> 1. Declare the locale at the message level.

Good improvement. I'll update.

> 2. Use the attribute string itself as a reference to the string in the msg_catalog. This works well with short strings.

I thought about this. I know it's sometimes done, but there are two drawbacks: you can't change the value of a string without invalidating its lookup in a catalog, and you have ambiguities where the same text means two different things (e.g., ""control"" as a verb in one place, and as a noun is another). I don't know if either of these are a big deal, but that's why I said the code was required. Maybe we make the code optional, so either lookup key could be used?

> 3. Include localization detail with sibling attributes, not manipulation of the main attribute.
> The sibling ..._loc attribute makes it easier for schema parsers. They will ignore it if they are not expecting it.
> These changes allows the localization to be 'additive' in that you can add localization without modifying the existing attribute structures. This removes barriers to making something localized when it wasn't to start out.

These are good points. However, if we do this, then it is no longer possible to look at a field and realize by its naming convention that it is localizable. You only know it is localizable if it has a sibling attribute. And since I expect most people who write localizable messages will make no effort to localize them (e.g., they values of the attributes will be generated dynamically), we'd end either with no clues of which attributes to localize, or with a lot of stuff that looks like this:

```JSON
""some_string_attribute"":""This is a test"",
""some_string_attribute_loc"": {}
```
I am also dubious about the utility of making something localized when it wasn't to start out. My experience has been that if you weren't thinking about localization from the beginning, you usually have bigger problems than schema adjustments.

I don't know what to do about this, though--because even though I feel pretty strongly about my own reasoning, the other points raised by @TelegramSam are equally good. Is there some way we can have our cake and eat it too?",2018-12-07 03:31:06,2018-12-07 03:31:27
https://api.github.com/repos/hyperledger/indy-hipe/issues/64,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445112052,https://github.com/hyperledger/indy-hipe/pull/64#issuecomment-445112052,dhh1128,"> focus on the trustworthiness of the catalog

This is a really important point, @swcurran . I'll add some text about it. Can you think of any ways to strengthen the security around it? An obvious way would be to publish the hash of the catalog so it couldn't be tampered with--but that feels like tedious, kludgey overkill... Yet the risk of hacking via the catalog is real...",2018-12-07 03:34:26,2018-12-07 03:34:26
https://api.github.com/repos/hyperledger/indy-hipe/issues/64,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445113442,https://github.com/hyperledger/indy-hipe/pull/64#issuecomment-445113442,dhh1128,"@TelegramSam:

> Is there some way we can have our cake and eat it too?

What if we said that messages purporting to belong to a schema with required attribute ""some_string_attribute"", but lacking that field, could still be valid if a field named ""some_string_attribute_ltxt"" is present. If it is, then the latter attribute is the localized variant of ""some_string_attribute"" and should be interpreted as satisfying that field's place in the schema. In this way, messages could gain localization support without doing violence to a schema.

I dunno. I don't love it. Requires a parser/validator to do something quirky.",2018-12-07 03:44:11,2018-12-07 03:44:11
https://api.github.com/repos/hyperledger/indy-hipe/issues/64,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445125736,https://github.com/hyperledger/indy-hipe/pull/64#issuecomment-445125736,dhh1128,"@swcurran and @TelegramSam : I updated the HIPE to address all your comments. There's a security warning and best practices around the catalog hacking issue. The _ltxt field now has a sibling field instead of being a dict. (I used `_l10n` instead of `_loc` for the suffix, because `_loc` is likely to be used as a short form of `_location` in many schemas.) The HIPE now describes how to do a lookup on a string value if no `code` is given. And I have also included a note about how schemas that declare a field without the `_ltxt` suffix can upgrade to localization support--not automatically, but by noting this feature in their message family definition docs.

@swcurran Can you make the corresponding changes in the problem_report HIPE, such that `friendly_ltxt` (which I've noted in a separate comment should be renamed to `explain_ltxt` has a simple string value and sibling field `explain_l10n`, instead of having a value that's a dict?",2018-12-07 05:19:01,2018-12-07 05:19:01
https://api.github.com/repos/hyperledger/indy-hipe/issues/64,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445263453,https://github.com/hyperledger/indy-hipe/pull/64#issuecomment-445263453,swcurran,"> > focus on the trustworthiness of the catalog
> 
> This is a really important point, @swcurran . I'll add some text about it. Can you think of any ways to strengthen the security around it? An obvious way would be to publish the hash of the catalog so it couldn't be tampered with--but that feels like tedious, kludgey overkill... Yet the risk of hacking via the catalog is real...

I think there are a couple of pieces of thoughts related to prior art to look at here.

In the open source world, ""catalogs"" (as we are calling them here) evolve over time through community contributions. For example, many open source applications have releases that consist only of new translations done by community contributors. I think in this case, we have to expect the same model and we should design a system to support that. For example, a decentralized way to extend and rate (approve?) of a translation.

The Schemas and Overlays group are planning to have Schema Overlays (metadata associated with a Schema) that (in some cases) are for localization on the ledger.  I don't know how far along that plan is to reality - and whether the indy-node team is comfortable with that.  While the catalogs we are discussing are tied to messages vs. schema - would it be worthwhile to have them on the ledger - or at least immutable?  Then the message receiver could be notified of what immutable message overlays are available and which ones should be used.  I think it's doable, but it's complicated and adds a bunch of state for agents to track...

AFIAIK with say, python applications, given a catalog (in the case of an app,, that's in the codebase), all strings to be presented are first checked for a mapping to the localized string in the requested locale.  With Sam's proposal of the catalog and locale in the message, and a user providing the desired locale to present, that should be pretty easy. Further, with the catalog and `code` field that should be easy as well - the code field would be used as the neutral form of the text.",2018-12-07 15:16:13,2018-12-07 15:16:13
https://api.github.com/repos/hyperledger/indy-hipe/issues/64,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/446025185,https://github.com/hyperledger/indy-hipe/pull/64#issuecomment-446025185,dhh1128,"@swcurran: regarding the relation to schemas and overlays, and publishing on the ledger, I would say that that's a very interesting idea, but I don't want to hold up this HIPE for it. Let's keep a bookmark in it and circle back to it when the progress there makes the link to their work easier. (Note as well that W3C just decided to change the name of the ""identifier registry"" in the VC spec to ""verifiable data registry"", exactly to accommodate stuff like this, where you must have a provably correct version of something. We don't necessarily need to publish on the ledger; we could publish anywhere if the hash of the message catalog were included in the message. But we can work that out later.)",2018-12-11 00:19:45,2018-12-11 00:19:45
https://api.github.com/repos/hyperledger/indy-hipe/issues/64,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/446353587,https://github.com/hyperledger/indy-hipe/pull/64#issuecomment-446353587,TelegramSam,"I love the _l10n suffix for a sibling decorator.

I wonder if the locale and catalog would be better organized under a structure like this:
```json
""@l10n"": {
""locale"": ""en"",
""catalog"": ""<did ref>""
}
```
This feels simpler, and the @l10n matches the _l10n. This would be the first block form @annotation, which makes me a little nervous, but feels better than both a @locale and a @msg_catalog.


My remaining issue is knowing which fields _can_ be localized. It is fairly important that we articulate why not just any string should be localized because of the security risk of accidentally sending a secure secret to a translation service.
Already articulated are a few options:
- Message Family Documentation: This one seems bad at the onset, but I don't think it's harmful at all. There are NO expectations of an unknown message family being processed. During development, the list of fields would need to be provided to the Message class to allow automatic localization. Now this is done by hand, but in the future could be automated via formalized message family docs.
- Field Suffix: This is Daniel's favorite, but not mine. I feel like the cases where the field suffix would be used without a sibling field would be fairly rare in the advanced case, and the simple case likely isn't going to declare the suffix at all. This also requires a breaking change to add localization if the message family wasn't designed that way to begin with.
- Sibling Field: I think this is a better explicit option, and will likely be the most common in advanced uses due to the need for a code.
- In Message Field List: If we use the @l10n block I suggested, we could include a list of fields in there.

We certainly shouldn't allow all of these options due to the resulting complexity.

It occurs to me that there is a progression of localization maturity:

0. None at all.
1. Stated locale. Allows machine translation. Assumes discovery (or develop time encoding) of localizable fields.
2. Stated locale and catalog. Lookup via full field values.
3. Stated locale and catalog, fields have explicit catalog codes in sibling fields.

The inline localizations fit in with 2 and 3 as an alternative or addition to a catalog.

I'm going to guess that many families will be prototyped and tested at level 0 or 1. If breaking changes are required to progress up the levels of localization it would cause a Major version update to the message family, which may or may not be a desirable quality.


On catalog attack prevention: Can we sign the catalog with the key in the DID doc used to reference the catalog? Just an idea, we should handle this in a future HIPE.",2018-12-11 20:39:44,2018-12-11 20:40:23
https://api.github.com/repos/hyperledger/indy-hipe/issues/64,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/447669867,https://github.com/hyperledger/indy-hipe/pull/64#issuecomment-447669867,swcurran,"> @swcurran: regarding the relation to schemas and overlays, and publishing on the ledger, I would say that that's a very interesting idea, but I don't want to hold up this HIPE for it. Let's keep a bookmark in it and circle back to it when the progress there makes the link to their work easier. (Note as well that W3C just decided to change the name of the ""identifier registry"" in the VC spec to ""verifiable data registry"", exactly to accommodate stuff like this, where you must have a provably correct version of something. We don't necessarily need to publish on the ledger; we could publish anywhere if the hash of the message catalog were included in the message. But we can work that out later.)

Agreed - that's the right approach.",2018-12-16 19:41:06,2018-12-16 19:41:06
https://api.github.com/repos/hyperledger/indy-hipe/issues/64,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/448308182,https://github.com/hyperledger/indy-hipe/pull/64#issuecomment-448308182,TelegramSam,"@dhh1128 Your work on this HIPE is incredible. Thank you for your effort. 

The only changes I can see that are needed is the cleanup of the last section and filling out the complex example.",2018-12-18 17:46:31,2018-12-18 17:46:31
https://api.github.com/repos/hyperledger/indy-hipe/issues/63,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443330412,https://github.com/hyperledger/indy-hipe/pull/63#issuecomment-443330412,pknowl,"Beautiful work, Michael! I look forward to adding some documentation form the # indy-semantics WG over the coming weeks/months. A fabulous start.",2018-11-30 20:31:17,2018-11-30 20:31:17
https://api.github.com/repos/hyperledger/indy-hipe/issues/63,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/444947099,https://github.com/hyperledger/indy-hipe/pull/63#issuecomment-444947099,michaeldboyd,"I propose we move this to FCP, unless there is any other feedback on the current draft.",2018-12-06 16:59:25,2018-12-06 16:59:25
https://api.github.com/repos/hyperledger/indy-hipe/issues/63,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/444947630,https://github.com/hyperledger/indy-hipe/pull/63#issuecomment-444947630,kdenhartog,"Second this proposal. These docs are looking great!

On Thu, Dec 6, 2018, 9:59 AM Michael Boyd <notifications@github.com wrote:

> I propose we move this to FCP, unless there is any other feedback on the
> current draft.
>
> —
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> <https://github.com/hyperledger/indy-hipe/pull/63#issuecomment-444947099>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AWDcQ0ui0fmF5AMiMdooPJ25S45ueA2Lks5u2UzvgaJpZM4Y4fuq>
> .
>
",2018-12-06 17:00:49,2018-12-06 17:00:49
https://api.github.com/repos/hyperledger/indy-hipe/issues/63,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445148023,https://github.com/hyperledger/indy-hipe/pull/63#issuecomment-445148023,dhh1128,"I am not feeling good about the proposal to enforce one &lt;h1&gt; per HIPE doc. There are many HIPEs where that will be problematic. You can't just indent headers one more level, as many of them use &lt;h1&gt;, &lt;h3&gt;, &lt;h5&gt;, and &lt;h7&gt; today. Maybe we should talk about that?",2018-12-07 07:34:35,2018-12-07 07:35:25
https://api.github.com/repos/hyperledger/indy-hipe/issues/63,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445163207,https://github.com/hyperledger/indy-hipe/pull/63#issuecomment-445163207,swcurran,"> I am not feeling good about the proposal to enforce one `<h1>` per HIPE doc. There are many HIPEs where that will be problematic. You can't just indent headers one more level, as many of them use `<h1>, <h3>, <h5>, and <h7>` today. Maybe we should talk about that?

Based on @michaeldboyd's work - this is a constraint of RTDs and I think we are more than happy with the benefits we get from that vs. this constraint.  If this can be resolved within the construct of RTDs, without creating multiple pages per HIPE (which I think is doubtful), I'm good with that, but if not - we just live with it.",2018-12-07 08:46:15,2018-12-07 08:47:13
https://api.github.com/repos/hyperledger/indy-hipe/issues/63,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445165657,https://github.com/hyperledger/indy-hipe/pull/63#issuecomment-445165657,swcurran,"The thing I'm not seeing in this is the use of sphinx/RTDs to extract and publish the external interface (API/Methods, etc.) documentation from directly code. That's where we started with RTDs and it's been super valuable. (see https://von-anchor.readthedocs.io/en/latest/modules.html).

Presumably, this would be another HIPE, but I think we would want this mentioned as a goal - that we strive to make developers aware of the protocols for inline external interface code documentation that can be extracted and published using RTD.  This is a huge help for the users of a library such as indy-sdk - providing not only useful documentation of the interface for a library, but also links to the associated code.  Powerful stuff!",2018-12-07 08:56:34,2018-12-07 08:56:34
https://api.github.com/repos/hyperledger/indy-hipe/issues/63,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445324283,https://github.com/hyperledger/indy-hipe/pull/63#issuecomment-445324283,michaeldboyd,"@dhh1128 
> I am not feeling good about the proposal to enforce one `<h1>` per HIPE doc. There are many HIPEs where that will be problematic. You can't just indent headers one more level, as many of them use `<h1>`, `<h3>`,` <h5>`, and `<h7>` today. Maybe we should talk about that?

I don't love it either... the only other option I've found would be to edit the parsing code within the RTD recommonmark parsing library, and that would be much more intensive.

 I've taken the initiative to fix the current hipes and the template so they only have 1 `<h1>` header. Here's what it will look like when complete: https://indy.readthedocs.io/projects/hipe/en/latest/index.html

Are even numbered headers off limits for some reason? I can edit the currently proposed HIPEs moving forward. After those are resolved, the template and readme can make sure future HIPEs work by default. ",2018-12-07 18:34:49,2018-12-07 18:43:27
https://api.github.com/repos/hyperledger/indy-hipe/issues/63,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/446276386,https://github.com/hyperledger/indy-hipe/pull/63#issuecomment-446276386,michaeldboyd,How do the maintainers feel about this PR currently?,2018-12-11 16:53:36,2018-12-11 16:53:36
https://api.github.com/repos/hyperledger/indy-hipe/issues/61,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/438457069,https://github.com/hyperledger/indy-hipe/pull/61#issuecomment-438457069,kdenhartog,"Looks good to me. One question that came up for me is how might an *.ap message fit inside a *.aw message. For example, if I'm transporting a message over multiple transport protocols, on some it may be possible (and easier) to just parse JSON. Where as, if I'm using IPFS, it would make sense to list this as a *.aw file rather than a *.json. However, once I've decoded the .aw file (assuming it's not just being passed as a giant string of Base64 text), would I then have a byte format of .ap inside the AW? I assumed because it was JSON string that the format would be .JSON file if it needed to be a file.

Also, as a side point, I'd like to bikeshed the naming convention of ""star dot a dub"" to ""star dot a dubya"" cause I always found it funny when I'd hear people say ""W"" that way.",2018-11-13 22:08:54,2018-11-13 22:08:54
https://api.github.com/repos/hyperledger/indy-hipe/issues/61,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/438474863,https://github.com/hyperledger/indy-hipe/pull/61#issuecomment-438474863,dhh1128,Re how an .ap message fits inside an .aw: I imagine that the .ap would be a base64-encoded attribute inside the .aw. Any .aw is going to have an .ap inside it to be useful--but the .ap content won't look like JSON when inspecting the outer wrapper.,2018-11-13 23:15:18,2018-11-14 02:12:21
https://api.github.com/repos/hyperledger/indy-hipe/issues/61,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/438650911,https://github.com/hyperledger/indy-hipe/pull/61#issuecomment-438650911,TelegramSam,"I'm wondering if the right companion to Agent Wire is Agent Plaintext, not Application Plaintext. I of agent messages as either 'core' or 'application' levels, 'core' being standard level agent business like connection and relationship management. Agent would nicely contain both of these.",2018-11-14 12:50:23,2018-11-14 12:50:23
https://api.github.com/repos/hyperledger/indy-hipe/issues/61,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/438652044,https://github.com/hyperledger/indy-hipe/pull/61#issuecomment-438652044,TelegramSam,"> Re how an .ap message fits inside an .aw: I imagine that the .ap would be a base64-encoded attribute inside the .aw. Any .aw is going to have an .ap inside it to be useful--but the .ap content won't look like JSON when inspecting the outer wrapper.

Won't the .ap file be the decrypted ciphertext inside the wire level format message in the .aw?

I thought the idea was to have a 1-1 mapping between wire level message format and the .aw file contents, and the agent message format (same as decrypted ciphertext in wire level message format) and the .ap file.",2018-11-14 12:54:37,2018-11-14 12:54:37
https://api.github.com/repos/hyperledger/indy-hipe/issues/61,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/438795753,https://github.com/hyperledger/indy-hipe/pull/61#issuecomment-438795753,dhh1128,"> I'm wondering if the right companion to Agent Wire is Agent Plaintext, not Application Plaintext. I of agent messages as either 'core' or 'application' levels, 'core' being standard level agent business like connection and relationship management. Agent would nicely contain both of these.

I am not opposed to this. It has a nice consistency. We were calling messages ""Application Messages"" to emphasize the fact that they target application-level logic rather than low-level plumbing. I think @swcurran might have an opinion.",2018-11-14 19:52:53,2018-11-14 19:52:53
https://api.github.com/repos/hyperledger/indy-hipe/issues/61,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/438796219,https://github.com/hyperledger/indy-hipe/pull/61#issuecomment-438796219,dhh1128,"> Won't the .ap file be the decrypted ciphertext inside the wire level format message in the .aw?

Yes.

> I thought the idea was to have a 1-1 mapping between wire level message format and the .aw file contents, and the agent message format (same as decrypted ciphertext in wire level message format) and the .ap file.

Yes.

You just said it better than I did. If that wasn't the impression that my answer gave, then let's erase my answer and use Sam's.

",2018-11-14 19:54:21,2018-11-14 19:54:21
https://api.github.com/repos/hyperledger/indy-hipe/issues/61,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/438798477,https://github.com/hyperledger/indy-hipe/pull/61#issuecomment-438798477,kdenhartog,"This makes sense. My hope would be to not see .ap files SHOULD NOT (using my RFC style writing 😄) on disk directly, therefore data at rest remains protected. I'm thinking this is in line with everyone else's thinking, but I want to double check.",2018-11-14 20:01:10,2018-11-14 20:01:10
https://api.github.com/repos/hyperledger/indy-hipe/issues/61,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/440085498,https://github.com/hyperledger/indy-hipe/pull/61#issuecomment-440085498,dhh1128,">.ap files SHOULD NOT be seen on disk directly

@kdenhartog I understand why you said this. Makes sense from a security perspective. However, some .ap files will be examples (as, for instance, all the files that attach to a HIPE documenting a message family). I imagine text editors will also want to implement .ap file support, and so will debuggers. The real rule is probably something like, ""As a general rule, agent messages that are truly sent in A2A communication should be stored in encrypted form at rest."" -- thus exempting stuff that's not actually transmitted anywhere. Or something like that. ",2018-11-19 23:55:58,2018-11-19 23:55:58
https://api.github.com/repos/hyperledger/indy-hipe/issues/61,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/441715533,https://github.com/hyperledger/indy-hipe/pull/61#issuecomment-441715533,TelegramSam,"@dhh1128 If you add the warning text about encryption, I believe this is ready for FCP. We talked about it on the Agent call, and had only that one concern.",2018-11-26 17:00:19,2018-11-26 17:00:19
https://api.github.com/repos/hyperledger/indy-hipe/issues/61,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443354315,https://github.com/hyperledger/indy-hipe/pull/61#issuecomment-443354315,dhh1128,@TelegramSam I accepted @kdenhartog 's suggested paragraph about that topic.,2018-11-30 22:07:30,2018-11-30 22:07:30
https://api.github.com/repos/hyperledger/indy-hipe/issues/61,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445167232,https://github.com/hyperledger/indy-hipe/pull/61#issuecomment-445167232,swcurran,"> > I'm wondering if the right companion to Agent Wire is Agent Plaintext, not Application Plaintext. I of agent messages as either 'core' or 'application' levels, 'core' being standard level agent business like connection and relationship management. Agent would nicely contain both of these.
> 
> I am not opposed to this. It has a nice consistency. We were calling messages ""Application Messages"" to emphasize the fact that they target application-level logic rather than low-level plumbing. I think @swcurran might have an opinion.

In reading that section of the HIPE and the usage examples in the text (""This file is in Application Plaintext Format""), I think using Agent Plaintext might be better.  If this is only ever used in the Agent sub-context, I would agree on the ""Application"", but given the more broader visibility, I lean towards the use of ""Agent"".  It is subtle :-).
",2018-12-07 09:03:09,2018-12-07 09:03:09
https://api.github.com/repos/hyperledger/indy-hipe/issues/61,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/446023471,https://github.com/hyperledger/indy-hipe/pull/61#issuecomment-446023471,dhh1128,"I have updated the PR to match @swcurran's suggestion about ""Agent Plaintext"" instead of ""Application Plaintext"".",2018-12-11 00:11:08,2018-12-11 00:11:08
https://api.github.com/repos/hyperledger/indy-hipe/issues/60,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/438237580,https://github.com/hyperledger/indy-hipe/pull/60#issuecomment-438237580,khagesh,"General comment: IMO we should be utilizing open source standards to do tracing in systems. One good example for such standard is opentracing. Lots of people will immediately understand what to do and implement it easily. We already have good tools on top of standards such as zipkin, jaeger, etc. We also have lots of documentation and tutorials available in different programming languages and one less new thing to learn.",2018-11-13 11:44:19,2018-11-13 12:09:14
https://api.github.com/repos/hyperledger/indy-hipe/issues/60,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/438517227,https://github.com/hyperledger/indy-hipe/pull/60#issuecomment-438517227,dhh1128,"@khagesh -- Regarding the use of opentracing, I would say that this is an interesting idea. However, I am not sure it applies completely. Opentracing spans are about capturing units of *execution* -- that's why there are spans that overlap, and names of operations that need to be done. The goal in opentracing's world view is to follow how logic gets executed in a distributed application. You record the logic as it executes.

Here, we are talking about something that may cross application boundaries. When a credential is issued, some of the work that happens is done by a distributed application on the issuer's side, and some of it is done by one or more distributed applications on the holder's side. What we are trying to trace is not so much *execution within an app* -- it is more *how messages get sent and received* across a context bigger than one application controlled by one user or one stack.

I don't think opentracing offers a solution for a workflow that crosses from software run and configured by company A, to software run and configured by company B, to an agent operated by user C, and back again. Am I wrong?

We could perhaps use opentracing despite this mismatch. I would welcome suggestions about how to apply its principles to this slightly different problem.",2018-11-14 02:42:43,2018-11-14 02:45:54
https://api.github.com/repos/hyperledger/indy-hipe/issues/60,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/438641097,https://github.com/hyperledger/indy-hipe/pull/60#issuecomment-438641097,khagesh,"@dhh1128 I think opentracing also works in similar way that we are proposing here. They have a server which is listening for messages and that endpoint is used by all services, apps or clients and send trace/span data to server url. Span can be used for both performance monitoring and tracing a message from one service to another or to another edge to edge, these clients needs to report using same message ID.
If we see zipkin, then they provide a nice UI as well to visualize this incoming data and we can filter out on message ID or application/service",2018-11-14 12:11:23,2018-11-14 12:11:23
https://api.github.com/repos/hyperledger/indy-hipe/issues/60,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/438657489,https://github.com/hyperledger/indy-hipe/pull/60#issuecomment-438657489,TelegramSam,"I am also feeling a mismatch between the goals of opentracing and what is being proposed here. Opentracing feels very much focused on the operations within a system, including what language is being used. This is mostly concerned with the routing of messages between systems. Though the basic form is similar (submit trace report to a server), the goals appear very different.

I would also love more information about any misconceptions I have. Perhaps a screenshare/quick demo would help.",2018-11-14 13:14:47,2018-11-14 13:14:47
https://api.github.com/repos/hyperledger/indy-hipe/issues/60,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/438797629,https://github.com/hyperledger/indy-hipe/pull/60#issuecomment-438797629,dhh1128,"@khagesh The difference in thinking shows up in the assumptions about how the mechanism is configured to begin with. In opentracing, you have to instrument your code. They distribute libraries in 9 languages to help with this intrumentation. I believe the developer goes into all the functions that they want to be traceable, and add calls to the tracing function.

What I am proposing here requires no code instrumentation and no prior agreement or configuration. We simply agree that *message* (not *code path*) tracing can be requested in a particular way, and if parties support it, they honor the trace requests. They don't do this by scattering trace statements all through their code; they simply go into the one place in code where messages are received and sent, and implement tracing once, there.

Perhaps that one place of implementation could use opentracing concepts? I like Sam's idea of a demo or screenshare. Do you want to set one up?",2018-11-14 19:58:40,2018-11-14 19:58:40
https://api.github.com/repos/hyperledger/indy-hipe/issues/60,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/438913126,https://github.com/hyperledger/indy-hipe/pull/60#issuecomment-438913126,khagesh,Would it be fine if I schedule something on Monday or maybe send an offline demo by tomorrow?,2018-11-15 04:26:28,2018-11-15 04:26:28
https://api.github.com/repos/hyperledger/indy-hipe/issues/60,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/440085803,https://github.com/hyperledger/indy-hipe/pull/60#issuecomment-440085803,dhh1128,"> Would it be fine if I schedule something on Monday or maybe send an offline demo by tomorrow?

Yes, let's set something up, possibly on Tue.",2018-11-19 23:57:28,2018-11-19 23:57:28
https://api.github.com/repos/hyperledger/indy-hipe/issues/60,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/479477918,https://github.com/hyperledger/indy-hipe/pull/60#issuecomment-479477918,TelegramSam,How would the protocol-discovery protocol discover support for tracing? Is that valuable?,2019-04-03 12:58:49,2019-04-03 12:58:49
https://api.github.com/repos/hyperledger/indy-hipe/issues/60,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/479578661,https://github.com/hyperledger/indy-hipe/pull/60#issuecomment-479578661,dhh1128,"> How would the protocol-discovery protocol discover support for tracing? Is that valuable?

@TelegramSam That's why I originally named the protocol the ""feature discovery"" protocol instead of the ""protocol discovery"" protocol--because I thought we might need to discover whether agents supported decorators, not just message families.

Another way to analyze tracing is to say that the decorator asks for the recipient to initiate a single-state protocol (emit a notification). Since the party interested in tracing is never going to interact with the other party directly, it simply signals its interest and waits to see if the protocol starts. It can't tell the difference between the other party supporting a protocol but not wanting to engage, and the other party not supporting the protocol at all.

This pattern manifests with tracing, but also with ACKs, with problem reports, etc. And interestingly, all of these are part of a ""notifications"" message family. All of them are triggered by something other than an initial message by the interested party.",2019-04-03 17:12:54,2019-04-03 17:12:54
https://api.github.com/repos/hyperledger/indy-hipe/issues/59,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/438141884,https://github.com/hyperledger/indy-hipe/pull/59#issuecomment-438141884,dhh1128,This PR got contaminated with some other edits. Closing. PR #60 replaces.,2018-11-13 05:29:34,2018-11-13 05:29:34
https://api.github.com/repos/hyperledger/indy-hipe/issues/56,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/437171364,https://github.com/hyperledger/indy-hipe/pull/56#issuecomment-437171364,dbluhm,"I agree that GitHub's concept of PR's is not an ideal solution to the HIPE process but I think the fact that this is how many other open source communities operate is significant and perhaps understated. This is the sort of structure I would expect to see when I am getting to know a new (large) open source project.

I think it's also beneficial to consider who the consumers and creators of HIPEs are. If the primary creators are not technically trained, the PR process is definitely a burden and other systems may be preferable. Same with consumers. But in general I think these HIPEs are intended to be read and consumed by maintainers and the technical contributors of the community. That being said, another system could still be conducive to those groups.",2018-11-08 21:59:32,2018-11-08 21:59:52
https://api.github.com/repos/hyperledger/indy-hipe/issues/56,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/437205200,https://github.com/hyperledger/indy-hipe/pull/56#issuecomment-437205200,jljordan42,I'm pretty technical but I find that I can't easily see HIPEs and therefore I don't look at them really. I don't have time to relearn GitHub tasks over and over again and so if it isn't a click ... I'm out!,2018-11-09 00:21:59,2018-11-09 00:21:59
https://api.github.com/repos/hyperledger/indy-hipe/issues/56,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/437427308,https://github.com/hyperledger/indy-hipe/pull/56#issuecomment-437427308,dhh1128,"Generally, I love this. Let's make it happen. See my notes about a couple subtleties.",2018-11-09 17:09:19,2018-11-09 17:09:19
https://api.github.com/repos/hyperledger/indy-hipe/issues/56,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/437458675,https://github.com/hyperledger/indy-hipe/pull/56#issuecomment-437458675,swcurran,"> I think it's also beneficial to consider who the consumers and creators of HIPEs are. If the primary creators are not technically trained, the PR process is definitely a burden and other systems may be preferable. Same with consumers. But in general I think these HIPEs are intended to be read and consumed by maintainers and the technical contributors of the community. That being said, another system could still be conducive to those groups.

I think this is why we want to do this. If those with a quasi-technical bent that base some of the discussion on, for example, business value vs. technical purity are excluded from the conversation, the viability of the project is reduced.  I've seen this tons of times in Open Source projects that think the only audience is the technical contributors.",2018-11-09 18:52:38,2018-11-09 18:52:38
https://api.github.com/repos/hyperledger/indy-hipe/issues/56,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/437775073,https://github.com/hyperledger/indy-hipe/pull/56#issuecomment-437775073,kdenhartog,"I'm in favor of giving this a shot if it accomplishes these two goals.

1. it's easier and faster for **current** maintainers and contributors to accurately discuss improvements to the project.

2. This helps to get _high quality_ code merged and In production faster. 

I believe this HIPE process can assist with # 1 and nudge us towards # 2, so I'm in favor.

With regards to the concern about commenting, I think it's worth trying to use GitHub issues to asynchronously track ongoing discussion about proposed HIPEs. We can use tagging to specify the HIPE being discussed and it's status.

I'd also like to point out the somewhat obvious, but sometimes overlooked point, that as our community grows we may find this process lacks certain qualities at scale. Just like we may find this happening with the technical solutions proposed in our HIPEs. If that occurs then we can address those issues in the future rather than wasting time bikeshedding on them now. With that said let's keep charging forward on making our work the easiest to use, most secure, and most privacy preserving identity system available to work with.",2018-11-12 06:51:26,2018-11-12 06:56:34
https://api.github.com/repos/hyperledger/indy-hipe/issues/56,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/437916290,https://github.com/hyperledger/indy-hipe/pull/56#issuecomment-437916290,TelegramSam,"Is there a benefit to changing the document name away from README.md in the hipe folder? I like the consistency/dry nature of the way it is, but open to that change if it brings benefit.",2018-11-12 15:11:56,2018-11-12 15:11:56
https://api.github.com/repos/hyperledger/indy-hipe/issues/56,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/437935519,https://github.com/hyperledger/indy-hipe/pull/56#issuecomment-437935519,swcurran,">           Is there a benefit to changing the document name away from README.md in the hipe folder? I like the consistency/dry nature of the way it is, but open to that change if it brings benefit.

Good point - I've changed the reference in the text.  I just realized I also need to change the name of the file I've been editing and will do that.",2018-11-12 16:04:43,2018-11-12 16:04:43
https://api.github.com/repos/hyperledger/indy-hipe/issues/56,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/438316744,https://github.com/hyperledger/indy-hipe/pull/56#issuecomment-438316744,nage,"I'm hoping we can keep our process in sync with what is generally used for the Rust RFC process here in Indy as well as in Sawtooth and now Hyperledger Ursa.  As such, I posted this PR to #sawtooth-core-dev and asked for feedback and got this, ""my initial thought is that the feedback mechanism would be worse with the proposed change and since the entire point is to gather feedback and respond to it, probably not worth the trade-off"".  I am opposed to a change that would make our process alien to folks familiar with how Rust or Sawtooth operate, though I think we can support some deviation.  I like the changes proposed to add status folders for tracking the files in the repo and allowing PRs to propose renaming files to the new status, but would like to preserve some relationship with the PR and review process.",2018-11-13 15:52:26,2018-11-13 15:52:26
https://api.github.com/repos/hyperledger/indy-hipe/issues/56,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/438353998,https://github.com/hyperledger/indy-hipe/pull/56#issuecomment-438353998,jljordan42,"I think the question here isn't the mechanical merits of one process or another as that basically boils down to preference.

An important question I think that needs to be answered is who is the core audience of the HIPEs? 

A perhaps relatively small group of developer types or a potentially large audience of technical/business people that are trying to understand and may adopt Indy technology, others?

I think that considering that adoption of Indy technology by a global community is a goal .. there should be some way for non-developers to do some digging into HIPEs .. I know in my time in telecom that I would refer to RFCs from time to time.

My opinion is that developers will be more able to adopt to modest differences in these processes and perhaps this approach will be adopted by the other projects even .. who is to say that we can't have ideas that are adopted by other.

Alternatively .. if there was a way with a script or something that could tell more business oriented folks what HIPEs are the approved, pending, etc, and have links that take them to the comments and the current latest version then that could work as well ... I don't know GitHub enough if such a thing is possible .. something like a HIPE status page ... 

HIPE (with link to latest), Status, Comments ... with links etc

(added a bit later) ... for example could we do a Jekyll based site that pulls this info an puts it into a nice format for the largely view based audience?

",2018-11-13 17:13:20,2018-11-13 21:07:01
https://api.github.com/repos/hyperledger/indy-hipe/issues/56,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443032912,https://github.com/hyperledger/indy-hipe/pull/56#issuecomment-443032912,dhh1128,"I recently came across the analog to HIPEs in the Ethereum Classic community. It is still PR-centric, but it does have 2 nice features that coincide with what Stephen has suggested here:

1. There is a nice way to discover everything that's in process, and what its official status is. (The main README.md for the repo is kept up to date with a list of in-process items and their statuses.)
2. Numbering happens immediately, not when the decision is made to merge.

I wonder if we should consider keeping PRs but adopting these two improvements. Of course, the answer to this question depends on how much pain they alleviate versus how much effort they require. For me, it's not the PRs and branches that are problematic; it's the lack of discoverability and the lack of formal status reporting. So a simple change to adopt the ETC conventions would make me happy at low cost. But I am not opposed to this more significant change, if the rest of the community likes it.

Reference: https://github.com/ethereumproject/ecips",2018-11-29 23:29:21,2018-11-29 23:29:21
https://api.github.com/repos/hyperledger/indy-hipe/issues/56,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443122093,https://github.com/hyperledger/indy-hipe/pull/56#issuecomment-443122093,swcurran,"I don't think that adding a roadmap document would be that helpful.  Rather than decreasing the admin overhead of managing the HIPEs, this would increase the admin role to maintain the README as PRs are received and merges are done.  Or the README would be communally managed, which increases the complexity of branch management (edit the HIPE in a branch, edit the global README in master). I don't think the numbering change is particularly significant - nice to have, but does not meet the goal of making collaboration easier.

We've had a couple of people weigh in with split support, but I'm not sure how we get this moved to a terminal state.  Unlike other HIPEs, this affects everyone, so it should not be moved forward without the view of the team.

I don't find compelling the argument of doing it like others have done in the past, nor to be consistent with others who aren't part of the project want.  To me it comes down to the simple question of doing we think we will get more and better input with the existing approach or the proposed one.",2018-11-30 07:58:09,2018-11-30 07:58:09
https://api.github.com/repos/hyperledger/indy-hipe/issues/56,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443229476,https://github.com/hyperledger/indy-hipe/pull/56#issuecomment-443229476,dbluhm,"I'm not convinced that the proposed changes would provide an appropriate means of commenting on HIPEs. What is proposed here would appear to result in comments being spread out among issues, comments on commits, and in PRs against the repo (please correct me if I'm wrong). I agree still that the PR process isn't ideal but I'm not sure the alternative suggested here would really improve on the current system. I do really like the idea of a Jekyll site for the repo; I think that provides some interesting opportunities no matter what system we end up with.",2018-11-30 15:00:17,2018-11-30 15:00:17
https://api.github.com/repos/hyperledger/indy-hipe/issues/56,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443239477,https://github.com/hyperledger/indy-hipe/pull/56#issuecomment-443239477,dbluhm,"There is a new feature in GitHub (still in beta?) that allows people commenting on PRs to suggest changes that the PR Author can then merge as a new commit to the PR. This, I think, addresses some of the pains you've mentioned here.",2018-11-30 15:30:29,2018-11-30 15:30:29
https://api.github.com/repos/hyperledger/indy-hipe/issues/56,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443251218,https://github.com/hyperledger/indy-hipe/pull/56#issuecomment-443251218,swcurran,"The beta feature that Daniel mentioned: https://help.github.com/articles/incorporating-feedback-in-your-pull-request/  - give it a try in this PR so I can try to incorporate the changes.

That would certainly be a help.",2018-11-30 16:05:04,2018-11-30 16:05:04
https://api.github.com/repos/hyperledger/indy-hipe/issues/56,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443302305,https://github.com/hyperledger/indy-hipe/pull/56#issuecomment-443302305,dbluhm,Looks like for the suggestion feature the DCO sign-off is not automatically added. This could make it a little less convenient.,2018-11-30 18:52:24,2018-11-30 18:52:24
https://api.github.com/repos/hyperledger/indy-hipe/issues/56,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/452011120,https://github.com/hyperledger/indy-hipe/pull/56#issuecomment-452011120,swcurran,:-(,2019-01-07 17:20:26,2019-01-07 17:20:26
https://api.github.com/repos/hyperledger/indy-hipe/issues/55,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443361061,https://github.com/hyperledger/indy-hipe/pull/55#issuecomment-443361061,dhh1128,"Based on a discussion in our last indy-agent call, it appears that we are going to have to modify crypto and some additional logic in libindy before this HIPE can be implemented. The reason is that as described here, the issued credential could be used by *either* an issuer or a holder to prove things. Today, that is not the case--issuance is an asymmetric operation where only the holder's link secret is embedded in a credential, and only the issuer has the right to revoke.

The idea of a 2-way contract, modeled as a credential, but conferring holder status on both parties, could maybe be addressed as follows (credit to @lovesh for the idea):

```

1. Assume a contract credential with 2 participants and 3 attributes and we are using Coconut threshold credentials. Here both participants will act as issuers and both will act as holders too
2. The schema will have 3 attributes a1, a2 and a3. 
3. Both participants p1 and p2 have a master secret, m1 and m2 respectively
4. Each of them creates a cred def with 5 fields (3 attributes + 2 link secrets).  
5. Each of them creates a verifiable encryption (Elgamal) of their link secret with a proof of encryption.
6. Each of them shares the ciphertext and the proof with another. Ciphertext of m1 is c1 and ciphertext of m2 is c2. 
(Both c1 and c2 are 2 group elements each like Elgamal ciphertext. Each element can be represented by its compressed point, c1=>(c1', c1''), c2=>(c2', c2''))
7. Each of them verifies the proof given by another.
8. They jointly arrive at a credential that contains the 3 attributes and 2 ciphertexts. This is how:
    a. p1 creates credential, X1 with attributes (a1, a2, a3, c1, c2), signs it and shares with p2.
    b. p2 creates credential, X2 with attributes (a1, a2, a3, c1, c2), signs it and shares with p1.
    c. Both p1 and p2 can independently combine the 2 credentials X1 and X2.
9. Now when p1 can act as a holder it proves knowledge of plaintext behind c1 (m1). Similarly for p2.

```

A drawback of this approach is that it doesn't preserve privacy in quite the same way that our normal ZKP behaviors do. However, perhaps 2-way contracts should not have the same privacy guarantees?",2018-11-30 22:38:25,2018-12-04 04:47:32
https://api.github.com/repos/hyperledger/indy-hipe/issues/55,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443366324,https://github.com/hyperledger/indy-hipe/pull/55#issuecomment-443366324,kdenhartog,"I'm commenting to offer my -1 for issuers being able to prove things with the credential. This could become an incentive to issuers to only use this method which at best allows for this new functionality, but at worst allows a large system to be undermined. Is there a way we can achieve consent receipts without having to give issuers the ability to prove as well? As an extension question, can we make it possible where the issuer get's consent, but gets no access to the data even?",2018-11-30 23:03:58,2018-11-30 23:11:48
https://api.github.com/repos/hyperledger/indy-hipe/issues/55,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443775208,https://github.com/hyperledger/indy-hipe/pull/55#issuecomment-443775208,JanLin,"I would like to point out that there are two different consent receipts, between a private individual and an institution and between two different institutions. The 2nd example, two different institutions, would benefit from the 2-way contract. So the issue of privacy guarantee may not necessarily be negative. Agree that in some circumstances it is important to have privacy guarantee. In the call last week there was discussion of having a 2nd credential between private individual and institution, the roles in this case become reversed. Isn't this an alternative for full privacy?

I will add as part of the HIPE the proposal with the 2-way contract. I may have other comments as I make the update.",2018-12-03 16:34:05,2018-12-03 16:34:05
https://api.github.com/repos/hyperledger/indy-hipe/issues/55,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443969934,https://github.com/hyperledger/indy-hipe/pull/55#issuecomment-443969934,lovesh,To clarify last comment from @dhh1128 the privacy guarantee we lose is that multiple presentations to the same verifier can be linked.,2018-12-04 04:46:29,2018-12-04 04:46:29
https://api.github.com/repos/hyperledger/indy-hipe/issues/54,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/452394457,https://github.com/hyperledger/indy-hipe/pull/54#issuecomment-452394457,swcurran,"I read through this connection protocol while on a flight today and think that we can move this to be peer-to-peer based DIDs vs. the current ""public DIDs"" only.  I was offline so only have the sequence of steps and the key variations we need to support.  If there is merit, I can do a PR to this:

https://hackmd.io/s/rJhj68zfV

The assumption in this is that we can support peer-to-peer DIDs today without indy-sdk support. That assumes the following are true:

A wallet can hold a non-public Ledger DID. In other words, an agent can construct a DID and use the Indy-SDK to store it and extract it from the wallet, without ever publishing it to an instance of the Ledger.

Likewise, an Agent can receive a DID from another Agent (with no keypair) and store it in their own wallet.

@dhh1128 @TelegramSam @tplooker",2019-01-08 18:03:09,2019-01-08 18:03:09
https://api.github.com/repos/hyperledger/indy-hipe/issues/54,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/452418114,https://github.com/hyperledger/indy-hipe/pull/54#issuecomment-452418114,dhh1128,"@swcurran I believe both of your assumptions are true, because Evernym built a product that required those two assumptions... and it worked. :-) However, there may be some nuances that I'm not noticing.",2019-01-08 19:15:45,2019-01-08 19:15:45
https://api.github.com/repos/hyperledger/indy-hipe/issues/54,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/453171400,https://github.com/hyperledger/indy-hipe/pull/54#issuecomment-453171400,devin-fisher,"When connecting without a public DID, I don't see the purpose of making an extremely short-lived DID. It seems that this DID only lives for one message, the `request` message and is abandoned and replaced on the `response` message. Seems like it would be simpler to just provide an ephemeral verkey that is treated as a one-time key for the `request` message. Then a DID is provided in the `response` instead of rotated.
@TelegramSam @dhh1128 ",2019-01-10 16:59:43,2019-01-10 16:59:43
https://api.github.com/repos/hyperledger/indy-hipe/issues/54,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/453192619,https://github.com/hyperledger/indy-hipe/pull/54#issuecomment-453192619,swcurran,"> When connecting without a public DID, I don't see the purpose of making an extremely short-lived DID. It seems that this DID only lives for one message, the `request` message and is abandoned and replaced on the `response` message. Seems like it would be simpler to just provide an ephemeral verkey that is treated as a one-time key for the `request` message. Then a DID is provided in the `response` instead of rotated.
> @TelegramSam @dhh1128

@devin-fisher - what's the difference between creating a local DID and a keypair?  I think the majority of the time in either is creating the keypair, so the ""make it a local DID"" extra effort is minimal.  The user still has to persist the keypair so that it can receive and process the response and putting it into the wallet as a DID seems easier then having a separate mechanism to store/retrieve a keypair.

I'm not sure about the ""rotate"" vs. create new for the ""Connection Response"" message.  But if we have it as a DID, that would use the same process as any other key-in-a-DID rotation process.",2019-01-10 17:58:42,2019-01-10 17:58:42
https://api.github.com/repos/hyperledger/indy-hipe/issues/54,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/453233237,https://github.com/hyperledger/indy-hipe/pull/54#issuecomment-453233237,TelegramSam,"> When connecting without a public DID, I don't see the purpose of making an extremely short-lived DID. It seems that this DID only lives for one message, the `request` message and is abandoned and replaced on the `response` message. Seems like it would be simpler to just provide an ephemeral verkey that is treated as a one-time key for the `request` message. Then a DID is provided in the `response` instead of rotated.
> @TelegramSam @dhh1128

The peer DID can be one of two things: a peer DID created specifically for the invitee, or an invitation peer DID shared with some audience. In the first case, there is no need to replace the DID with a new one. In the second case, it won't necessarily be a short lived DID. Replacing the DID used in the invitation is ony needed when it was shared with more than one invitee.

Does that make sense?",2019-01-10 19:59:54,2019-01-10 19:59:54
https://api.github.com/repos/hyperledger/indy-hipe/issues/54,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/453233649,https://github.com/hyperledger/indy-hipe/pull/54#issuecomment-453233649,TelegramSam,"> When connecting without a public DID, I don't see the purpose of making an extremely short-lived DID. It seems that this DID only lives for one message, the `request` message and is abandoned and replaced on the `response` message. Seems like it would be simpler to just provide an ephemeral verkey that is treated as a one-time key for the `request` message. Then a DID is provided in the `response` instead of rotated.
> @TelegramSam @dhh1128

Additionally, not having a DID only works if we don't use DIDs for routing.",2019-01-10 20:01:08,2019-01-10 20:01:08
https://api.github.com/repos/hyperledger/indy-hipe/issues/54,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/453241689,https://github.com/hyperledger/indy-hipe/pull/54#issuecomment-453241689,swcurran,"> > When connecting without a public DID, I don't see the purpose of making an extremely short-lived DID. It seems that this DID only lives for one message, the `request` message and is abandoned and replaced on the `response` message. Seems like it would be simpler to just provide an ephemeral verkey that is treated as a one-time key for the `request` message. Then a DID is provided in the `response` instead of rotated.
> > @TelegramSam @dhh1128
> 
> Additionally, not having a DID only works if we don't use DIDs for routing.

I'm pretty convinced that we want to do routing with the verkey extracted from the header (if any) of an embedded message JWE - e.g. decrypt the Wire Message, and then look for a verkey in the ciphertext header to see where to route the message.  That was briefly brought up yesterday on the call.  This will likely be talked about in Tobias' routing HIPE and a change that I expect to make to the Cross-Domain messaging HIPE.  I think it will greatly simplify routing while at the same time making routing more flexible (e.g. eliminating the three-deep wrap requirement).",2019-01-10 20:27:38,2019-01-10 20:27:38
https://api.github.com/repos/hyperledger/indy-hipe/issues/54,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/453258282,https://github.com/hyperledger/indy-hipe/pull/54#issuecomment-453258282,devin-fisher,"verkeys and DID are not a one-to-one relationship. Everyone will have many more verkeys than they will have DID. So we can not rely on the DID to be the key you use to look up a verkey. (It might be this way in the code right now, I'd have to look, but that is an unscalable simplification). 

In my mind, creating a DID for the peer spec would require setting up a fair bit of infrastructure (mostly around relationship state and it's microledger). I don't think it would be cheap.

Additionally, we would need to create a process for changing the DID that we don't have. I think that would be on par complexity wise to haveing the ability to deal with ephemeral verkeys.",2019-01-10 21:21:11,2019-01-10 21:21:11
https://api.github.com/repos/hyperledger/indy-hipe/issues/54,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/453274595,https://github.com/hyperledger/indy-hipe/pull/54#issuecomment-453274595,dbluhm,@devin-fisher that is definitely how it is in the code right now. See `did.key_for_did` and `did.key_for_local_did`.,2019-01-10 22:12:21,2019-01-10 22:12:21
https://api.github.com/repos/hyperledger/indy-hipe/issues/54,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/453276120,https://github.com/hyperledger/indy-hipe/pull/54#issuecomment-453276120,dbluhm,"> When connecting without a public DID, I don't see the purpose of making an extremely short-lived DID. It seems that this DID only lives for one message, the `request` message and is abandoned and replaced on the `response` message. Seems like it would be simpler to just provide an ephemeral verkey that is treated as a one-time key for the `request` message. Then a DID is provided in the `response` instead of rotated.
> @TelegramSam @dhh1128

In both cases, I consider the inability to actually delete keys or DIDs no longer in use from the wallet a problem.",2019-01-10 22:17:06,2019-01-10 22:17:06
https://api.github.com/repos/hyperledger/indy-hipe/issues/53,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/441840904,https://github.com/hyperledger/indy-hipe/pull/53#issuecomment-441840904,kdenhartog,"Propose to merge this. It's stale after 26 days. If we want to stay strict to the FCP procedure, I suggest we keep this short.",2018-11-26 23:32:57,2018-11-26 23:32:57
https://api.github.com/repos/hyperledger/indy-hipe/issues/53,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443354908,https://github.com/hyperledger/indy-hipe/pull/53#issuecomment-443354908,dhh1128,We don't have to go through a new FCP period for HIPES that have already been merged and that are just getting clarifying tweaks. I'm going to go ahead and merge it.,2018-11-30 22:10:09,2018-11-30 22:10:09
https://api.github.com/repos/hyperledger/indy-hipe/issues/50,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/432421254,https://github.com/hyperledger/indy-hipe/pull/50#issuecomment-432421254,lovesh,@dhh1128 Renamed to `key-types`,2018-10-23 21:11:10,2018-10-23 21:11:10
https://api.github.com/repos/hyperledger/indy-hipe/issues/50,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/432696451,https://github.com/hyperledger/indy-hipe/pull/50#issuecomment-432696451,vimmerru,I am ok too. Indy SDK already supports key prefixes in described way.,2018-10-24 15:03:13,2018-10-24 15:03:13
https://api.github.com/repos/hyperledger/indy-hipe/issues/50,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/432844535,https://github.com/hyperledger/indy-hipe/pull/50#issuecomment-432844535,lovesh,@dhh1128 @vimmerru Thanks. I will wait for review from @ashcherbakov ,2018-10-24 22:05:46,2018-10-24 22:05:46
https://api.github.com/repos/hyperledger/indy-hipe/issues/50,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/441841776,https://github.com/hyperledger/indy-hipe/pull/50#issuecomment-441841776,kdenhartog,looks like @lovesh might have to follow up with @ashcherbakov before we move this to FCP.,2018-11-26 23:37:30,2018-11-26 23:37:30
https://api.github.com/repos/hyperledger/indy-hipe/issues/50,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443922882,https://github.com/hyperledger/indy-hipe/pull/50#issuecomment-443922882,lovesh,@mikelodder7 The 7 bytes is to cover key types like ed25519 and cv25519. It does not come from any ISO. The HIPE does mention the reason for choosing 7 bytes though,2018-12-04 00:27:43,2018-12-04 00:27:43
https://api.github.com/repos/hyperledger/indy-hipe/issues/50,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/466349828,https://github.com/hyperledger/indy-hipe/pull/50#issuecomment-466349828,vimmerru,"@lovesh @dhh1128 @ashcherbakov 

Sorry. It was comment for PR 48

```
I have the following concerns:

1. I don't like idea of creation of custom transactions related to authorization/endpoints rules definition . All this authorization/endpoints staff is just part of DID Doc. Better alternative from my point of view is just define 2 transactions: 
    - To create DID Doc
    - To update DID Doc using delta

They can be just extended version of existing NYM transaction.

2. I don't like idea of definition any key identifiers/references that are against w3c spec. Each key in DID Doc already has identifier according to w3c spec. Why we don't use it. 

3. w3c spec suggests to use authorizations field to define authorizations rules. Why we don't use it? We can just add key role as additional field to authorization record and be completely w3c spec compatible. 

I suggest to look to this PR https://github.com/hyperledger/indy-sdk/pull/1487/files that describes alternative approach.
```",2019-02-22 10:26:04,2019-02-22 10:45:38
https://api.github.com/repos/hyperledger/indy-hipe/issues/50,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/466511138,https://github.com/hyperledger/indy-hipe/pull/50#issuecomment-466511138,dhh1128,"Conversations on the topic of DID Doc support and microledgers are unfolding in several different places -- rocket.chat, slack, google docs, jira. Not all of the same people are in each place, and I didn't want to copy and paste a lot of text all over. So I put some thoughts in a doc. Please have a look, and please forward this on to other people if you think they should be aware:

https://docs.google.com/document/d/17qzu5jm2CIA32oArG4cRp7g0D_20cwUqB4sX4LIkodc/edit#",2019-02-22 19:09:11,2019-02-22 19:09:11
https://api.github.com/repos/hyperledger/indy-hipe/issues/49,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/432934704,https://github.com/hyperledger/indy-hipe/pull/49#issuecomment-432934704,vimmerru,"Hi, In general i like the idea of providing better example for plugged wallet storage and corresponded test harness, but in details this HIPE and corresponded PR to indy-sdk repo (https://github.com/hyperledger/indy-sdk/pull/1175) breaks some our fundamental assumptions:

1. Libindy tests suite is intended to tests libindy (include pluggin interfaces), but isn't intended to test plugins or to be plugins test harness:
  - Plugin test harness must be targeted to test wallet storage functionality, but it may be just 2-3% of our test cases
 - Plugin test harness should guide plugin developer that ins't the case for very big libindy tests suite.
 - Libindy test suite was designed to provide reproducible results for some git commit and can rely on default storage and nullpay internals.
2. Libindy can't be responsible for loading plugins. How to link and load plugins is responsibility of an application. Each plugin just provides init function that calls corresponded register method in linked libindy. In a lot of supported platforms like iOS and Android libraries loading in runtime is impossible at all or have a lot of limitations.

I suggest you to consider my alternative proposal about this:

1. Wallet storage test harness should be dedicated native library with one method ```test_wallet_storage(storage_type, options)```
2. ```test_wallet_storage``` executes the short list of well documented test cases and generates report
3. Wallet storage test links libindy, test harness lib and wallet storage in the way he needs. Calls ```init``` function of storage and  ```test_wallet_storage``` after it. ",2018-10-25 06:48:52,2018-10-25 06:48:52
https://api.github.com/repos/hyperledger/indy-hipe/issues/49,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/433186380,https://github.com/hyperledger/indy-hipe/pull/49#issuecomment-433186380,ianco,"Thanks for your feedback!

For plug-in testing the reason I took the approach I did was that the unit tests were already available, and they covered exactly the level of testing provided to the default storage plug-in.  The only concerns I have with your suggested approach is that we'd wind up with a separate codebase that would need to be maintained, and may not be exactly in sync with what is being provided for the default wallet.

This is the same concern that is identified in tiket IS-881 (difference in behaviour between the default wallet and plug-in) - using the same set of unit tests for both the default and plug-in behaviour would alleviate that problem to some extent.  Note that when I ran the libindy wallet tests against the postgres plug-in it identified errors in the libindy plug-in module (see updates in https://github.com/hyperledger/indy-sdk/pull/1247/files#diff-3ef068287d272575d182d10ff4517073) as well as a gap in the functionality provided to marshall/un-marshall the search query between libindy and the plug-in (see new method in https://github.com/ianco/indy-sdk/blob/postgres_plugin/samples/storage/storage-postgres/src/postgres_storage/language.rs#L172).  Both of these would have been a challenge to solve without leveraging the libindy unit tests.

Maybe an approach is to do as you suggest (separate wallet test harness), but have this harness incorporate the libindy test suite somehow.

Overall I think the plug-in test suite needs to provide a ""robust"" set of functionality, consistent with the level of tests that we have available for the default wallet, and it should be maintained, so that any improvements to the default wallet testing (or bug fixes etc.) are also reflected in the plug-in test harness.  I agree that one purpose of the test harness is to guide developers, but another is to make sure that the plug-in acutally works.  Since all plug-ins should support the same set of functionality (and it should be the same as the default wallet), using one common test suite makes sense to me.
",2018-10-25 20:02:51,2018-10-25 20:02:51
https://api.github.com/repos/hyperledger/indy-hipe/issues/49,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/433187131,https://github.com/hyperledger/indy-hipe/pull/49#issuecomment-433187131,ianco,"Question regarding the rust wrapper - is this what we should be using for external rust applications (such as the CLI or storage plug-ins) to access libindy?  Are there some examples or documentation available?  I thought I saw somewhere that it was considered ""experimental"" so not sure if we should be incorporating this yet or not ...
",2018-10-25 20:05:23,2018-10-25 20:05:23
https://api.github.com/repos/hyperledger/indy-hipe/issues/49,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/433739580,https://github.com/hyperledger/indy-hipe/pull/49#issuecomment-433739580,ianco,"There is a lot covered in this HIPE and the related PR 1247, so I've created JIRA's for each topic/issue so that they can be addressed individually.  I can create separate PR's if necessary.

The higher priorities are the issues with the SDK (IS-1045, 1048) and duplicated/shared code (1046, 1047) that prevent us from deploying into production (we are currently running against our own indy-sdk fork).

Lower priority issues are those that will provide value to the community but don't block us right now.

Jira Issue(s):
    - IS-1045 - plugged wallet return error codes (related - IS-804?)
    - IS-1046 - marshall/un-marshall for query arguements for wallet storage search
    - IS-1047 - shared code for plugged wallets (rust)
    - IS-1048 - add register_wallet_storage to python wrapper
    - IS-1049 - update CLI to be able to register/load new plugged wallet types (related IS-1041?, IS-947 for VCX)
    - IS-1050 - re-factor in-mem plugged storage example to shared library
    - IS-1051 - test harness for plugged wallets (e.g. unit test ""shim"", stand-alone test harness, CLI integration) (related - IS-881)
    - IS-1052 - document how to build plugged wallet (libindy api, rust wrapper, shared code, etc.) (related IS-1037, IS-1032, IS-1031, IS-1030?)
    - IS-1053 - implement plugged storage for Postgres database

",2018-10-28 20:41:50,2018-10-28 20:41:50
https://api.github.com/repos/hyperledger/indy-hipe/issues/49,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/434344474,https://github.com/hyperledger/indy-hipe/pull/49#issuecomment-434344474,ianco,"Re IS-1047 I've added a suggestion to the JIRA ticket, I'll update the README in the HIPE.
",2018-10-30 15:21:36,2018-10-30 15:21:36
https://api.github.com/repos/hyperledger/indy-hipe/issues/49,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/437171792,https://github.com/hyperledger/indy-hipe/pull/49#issuecomment-437171792,ianco,"Updated to include reference to common (shared) code between libindy and wallet storage plug-in(s).
",2018-11-08 22:01:02,2018-11-08 22:01:02
https://api.github.com/repos/hyperledger/indy-hipe/issues/49,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/439844328,https://github.com/hyperledger/indy-hipe/pull/49#issuecomment-439844328,vimmerru,"@ianco 

> Question regarding the rust wrapper - is this what we should be using for external rust applications (such as the CLI or storage plug-ins) to access libindy? Are there some examples or documentation available? I thought I saw somewhere that it was considered ""experimental"" so not sure if we should be incorporating this yet or not ...

Rust wrapper is intended to write libindy based applications in Rust. It isn't directly intended to write libindy plugins, but we plan to use wrapper to write some plugin tests. Also we don't force to use Rust as programming language for plugins. You can use C, C++, D and etc...  

",2018-11-19 10:26:05,2018-11-19 10:26:05
https://api.github.com/repos/hyperledger/indy-hipe/issues/49,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/439845264,https://github.com/hyperledger/indy-hipe/pull/49#issuecomment-439845264,vimmerru,"> Updated to include reference to common (shared) code between libindy and wallet storage plug-in(s).
> In addition there are dependencies on some Indy-sdk code, these have been re-factored into a separate shared common library:

I spend some time for thinking and now i am not sure that introduction of libindy-common this way will help us a lot:

1. Interfaces inside of libindy-common are non-public. They can be very dynamic and often part of refactoring. For example, we plan to switch to more modern error handling approach soon.
2. Moving them to local shared crate will make them public and cause that any libindy refactoring will affect all dependent projects. I don't want to break samples during any refactoring of libindy.
3. Only storage plugins samples are main consumers of proposed shared crate now will consume only smart part of shared interfaces.
4. It can make vision that you have to use Rust to write libindy plugins.
5. It will be hard to consume libindy-common outside of libindy repo for creation of 3d party plugins. It will cause copy\paste anyway.
6. It will significantly change libindy development ergonomics. You will need to open separate project in IDE and maintain proper versioning.

As a result i suggest to copy paste minimum functionality you need and remove libindy-common at all.",2018-11-19 10:29:15,2018-11-19 10:29:15
https://api.github.com/repos/hyperledger/indy-hipe/issues/49,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/439846303,https://github.com/hyperledger/indy-hipe/pull/49#issuecomment-439846303,vimmerru,"@ianco 

We can consider creation of separate repo called something like libindy-wallet-storage-boilerplate and make them as community maintained project if you still really want to avoid any copy-paste.",2018-11-19 10:32:38,2018-11-19 10:32:38
https://api.github.com/repos/hyperledger/indy-hipe/issues/49,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/439848312,https://github.com/hyperledger/indy-hipe/pull/49#issuecomment-439848312,vimmerru,"@ianco 

I have feeling that having both ""in-memory"" and ""postgress"" plugins as a samples is a bit too much as we need to support more code in core project. Also ""in-memory"" plugin was designed as a test tool only and it isn't a good example from my point of view. It doesn't implement full wql and breaks some core assumptions about wallet persistence. I suggest the following:

1. Keep ""in-memory"" inside of libindy/tests as we have it now. 
2. Use only ""postgress"" plugin as a sample. 

Ideally i want to have ""postgress"" plugin in a dedicated repo maintained and published by community member outside of the core team. Libindy can have the link to this repo in the root Readme.md
",2018-11-19 10:39:36,2018-11-19 10:39:36
https://api.github.com/repos/hyperledger/indy-hipe/issues/49,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/439879679,https://github.com/hyperledger/indy-hipe/pull/49#issuecomment-439879679,vimmerru,"@ianco 

> As described above, a new command has been added to the CLI to register a new plug-in storage. Once registered, this can be used to create and open a new wallet, and supports all wallet functions.

CLI already supports loading any king of wallet storage plugins. You don't need to provide anything new. How it is designed to work:

1. Each libindy plugin should provide only one public function without params. Usually it is called *{plugin_name}_init()*. This function internally calls register_wallet_storage_type or register_payment_method. Corresponded callbacks usually mangled and doesn't available for direct call.
2. Application calls *{plugin_name}_init()* at the beginning and starts usage of registered storage types or payment methods.
3. cli provides command

```
indy> load-plugin library=<library-name> initializer=<init-func-name>
```

Corresponded design is here: https://github.com/hyperledger/indy-sdk/tree/master/doc/design/006-cli-plugins

For example of implementation you can look to libnullpay",2018-11-19 12:40:04,2018-11-19 12:40:04
https://api.github.com/repos/hyperledger/indy-hipe/issues/49,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/439889140,https://github.com/hyperledger/indy-hipe/pull/49#issuecomment-439889140,vimmerru,"@ianco 

> Sharing database connections in a multi-threaded environment - Postgres connections cannot be shared between threads (in rust), so in the Postgres plug-in they are wrapped in a connection pool. This has not been fully tested, and there are potential stability issues (testing is on-going)

libindy uses one execution thread to handle all storage operation and in the future it will be at least one thread per storage. As a result you can remove the most of mutexes and implement lazy fetching of records without big problems.",2018-11-19 13:17:04,2018-11-19 13:17:04
https://api.github.com/repos/hyperledger/indy-hipe/issues/48,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/432329272,https://github.com/hyperledger/indy-hipe/pull/48#issuecomment-432329272,lovesh,"@dhh1128 I have resolved the spelling and grammatical errors. Apologies, there were too many ",2018-10-23 16:51:48,2018-10-23 16:51:48
https://api.github.com/repos/hyperledger/indy-hipe/issues/48,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/447671971,https://github.com/hyperledger/indy-hipe/pull/48#issuecomment-447671971,swcurran,"Sam Smith did a really interesting talk at the Fall 2018 IIW about a good way of handling key rotation. Notably, when creating a new key, generate two keypairs, one as the current key, a second as the ""rotation"" key. Then, when a rotation (update) is done, the ""rotation"" key becomes the current key (it's never been used before), and the new key is the new ""rotation"" key - not used until the next rotation.  The benefit is that if the current key is compromised without loss of the wallet, the attacker cannot rotation the key - they don't have the private key of the the ""rotation"" key.  Evidently this technique is used by others.  Check with Sam for a reference.

Might be worth considering if we are going to be updating the key handling anyway.",2018-12-16 20:11:11,2018-12-16 20:11:11
https://api.github.com/repos/hyperledger/indy-hipe/issues/48,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/448105044,https://github.com/hyperledger/indy-hipe/pull/48#issuecomment-448105044,lovesh,"> Sam Smith did a really interesting talk at the Fall 2018 IIW about a good way of handling key rotation. Notably, when creating a new key, generate two keypairs, one as the current key, a second as the ""rotation"" key. Then, when a rotation (update) is done, the ""rotation"" key becomes the current key (it's never been used before), and the new key is the new ""rotation"" key - not used until the next rotation. The benefit is that if the current key is compromised without loss of the wallet, the attacker cannot rotation the key - they don't have the private key of the the ""rotation"" key. Evidently this technique is used by others. Check with Sam for a reference.
> 
> Might be worth considering if we are going to be updating the key handling anyway.

If i understand correctly, the DID doc will specify the ""rotation key"", eg. while creating a new DID doc, i generate 2 keys `k1` and `k2` and put both in the DID doc. Here `k1` will be my current key and `k2` will be my key after rotation. The DID doc registry (ledger, etc) will ensure that my next key is `k2` and nothing else. This is problematic as nobody can change my keys unless he holds my wallet. Currently it is proposed to give priviledges to others for key change which will be difficult with such a scheme.
Secondly key compromise without wallet seems less common since keys never leave the wallet so it was either a flaw in the cryptographic scheme (signature/ciphertext reveals key) or a side-channel.",2018-12-18 05:51:27,2018-12-18 05:51:27
https://api.github.com/repos/hyperledger/indy-hipe/issues/48,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/466354016,https://github.com/hyperledger/indy-hipe/pull/48#issuecomment-466354016,vimmerru,"@lovesh @dhh1128 @ashcherbakov 

I have the following concerns:

1. I don't like idea of creation of custom transactions related to authorization/endpoints rules definition . All this authorization/endpoints staff is just part of DID Doc. Better alternative from my point of view is just define 2 transactions: 
    - To create DID Doc
    - To update DID Doc using delta

They can be just extended version of existing NYM transaction.

2. I don't like idea of definition any key identifiers/references that are against w3c spec. Each key in DID Doc already has identifier according to w3c spec. Why we don't use it. 

3. w3c spec suggests to use authorizations field to define authorizations rules. Why we don't use it? We can just add key role as additional field to authorization record and be completely w3c spec compatible. 

I suggest to look to this PR https://github.com/hyperledger/indy-sdk/pull/1487/files that describes alternative approach.",2019-02-22 10:41:00,2019-02-22 10:41:00
https://api.github.com/repos/hyperledger/indy-hipe/issues/48,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/466354394,https://github.com/hyperledger/indy-hipe/pull/48#issuecomment-466354394,ashcherbakov,"I agree with Slava.
The only thing is that I would prefer not to modify existing NYM, but just add two new txns: DID_DOC (creation of new DID and corresponding did doc) and DID_DOC_DELTA (update of existing did doc).",2019-02-22 10:42:29,2019-02-22 10:42:29
https://api.github.com/repos/hyperledger/indy-hipe/issues/48,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/466511306,https://github.com/hyperledger/indy-hipe/pull/48#issuecomment-466511306,dhh1128,"Conversations on the topic of DID Doc support and microledgers are unfolding in several different places -- rocket.chat, slack, google docs, jira. Not all of the same people are in each place, and I didn't want to copy and paste a lot of text all over. So I put some thoughts in a doc. Please have a look, and please forward this on to other people if you think they should be aware:

https://docs.google.com/document/d/17qzu5jm2CIA32oArG4cRp7g0D_20cwUqB4sX4LIkodc/edit#",2019-02-22 19:09:40,2019-02-22 19:09:40
https://api.github.com/repos/hyperledger/indy-hipe/issues/47,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/430551055,https://github.com/hyperledger/indy-hipe/pull/47#issuecomment-430551055,vimmerru,"In my vision SCHEMA should be the main source for the correct interpretation of parameters in credential, but not parameter value in credential. We don't have just strings and numbers, but usually we have names, lengths, colors, temperatures. 

Ideally application should understand temperature in Fahrenheit and Celsius systems as well as a length in meters and foots, and make business decisions based on this values.

As a result i suggest to have encoding information as a part of SCHEMA together with units and domain field bindings. Your proposal can be simpler to implement, but it opens the door for solutions that will be incompatible with future decisions.",2018-10-17 09:09:33,2018-10-17 09:09:33
https://api.github.com/repos/hyperledger/indy-hipe/issues/47,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/430690372,https://github.com/hyperledger/indy-hipe/pull/47#issuecomment-430690372,sklump,"But these are semantics on the original values, orthogonal to the encoding regimen.",2018-10-17 16:09:01,2018-10-17 16:09:01
https://api.github.com/repos/hyperledger/indy-hipe/issues/47,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/431974940,https://github.com/hyperledger/indy-hipe/pull/47#issuecomment-431974940,dhh1128,"This feels like an incomplete solution to me. It's trivial to say we'll encode complex numbers as strings in such-and-such a form--but this gains us almost nothing. We can't do zero-knowledge proofs on the values unless we encode them as 256-bit integers. So punting and saying ""we'll just encode everything except integers as a string"" is equivalent to saying ""we'll just stop supporting zero-knowledge proving on anything except integers"".

We need more flexibility and power than that.

Am I missing something?",2018-10-22 20:36:18,2018-10-22 20:36:18
https://api.github.com/repos/hyperledger/indy-hipe/issues/47,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/432011933,https://github.com/hyperledger/indy-hipe/pull/47#issuecomment-432011933,sklump,"The current API takes a JSON-dump (string)
```
{
    ""attr0"": {
        ""raw"": ""..."", # must be a string or else indy-sdk raises exception
        ""encoded"": ""..."" # numeric decimal string
    },
    ""attr1"": {
        ""raw"": ""..."",  # must be a string or else indy-sdk raises exception
        ""encoded"": ""..."" # numeric decimal string
    },
    ...
}
```
without specifying how to build the encoding, except that 32-bit integers must encoded to their natural  numeric (decimal) strings. What this HIPE discusses is to whether to standardize the encoding process, taking the responsibility into the indy-sdk, and how to build the encoding.

Since JSON encoding does not support complex numbers natively (among many other types), and they're not booleans, nulls, objects, nor arrays, they would encode as strings as it stands today anyway, hence the complex number discussion is equally applicable to today's API.

There may already be a future enhancement to this end that I don't know about.",2018-10-22 22:22:40,2018-10-22 22:25:43
https://api.github.com/repos/hyperledger/indy-hipe/issues/47,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/435235396,https://github.com/hyperledger/indy-hipe/pull/47#issuecomment-435235396,swcurran,"> This feels like an incomplete solution to me. It's trivial to say we'll encode complex numbers as strings in such-and-such a form--but this gains us almost nothing. We can't do zero-knowledge proofs on the values unless we encode them as 256-bit integers. So punting and saying ""we'll just encode everything except integers as a string"" is equivalent to saying ""we'll just stop supporting zero-knowledge proving on anything except integers"".
> 
> We need more flexibility and power than that.
> 
> Am I missing something?

@dhh1128 - added a comment to the related JIRA about this, but adding it here for completeness.  

The answer to Daniel's question on the HIPE is that we have nothing now so we have no chance at interoperability - every Dev is making up their own solution (as Stephen and Axel have both done). Using Stephen's solution would give Devs an appropriate API (encode with only raw data input, and decode) to use going forward, and we can add what's needed to make the encoding ZKP-friendlier in the future.  I think (not certain) Stephen put in a ""version"" mechanism in the encode so that we should be able to improve the capability later.  I'm guessing the more useful capabilities would require enhancements to the schema object - adding in claim metadata to make improved ZKP opportunities possible.",2018-11-02 00:50:02,2018-11-02 00:50:02
https://api.github.com/repos/hyperledger/indy-hipe/issues/47,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/456159411,https://github.com/hyperledger/indy-hipe/pull/47#issuecomment-456159411,jovfer,"+1 for part of Slava's feedback:
The encoding metadata inside each attributes value seems strange for me too.

At the moment (or before) of issuance the new credential by Issuer for the particular Proover, the Issuer should define the way how to represent existing raw values in integer form. And Verifier should know this method from some trusted source.
Encoding is a part of credential: how Issuer has matched raw values to integers before signing.
For me it sounds like this information may be a part of Credential Definition.",2019-01-21 18:11:27,2019-01-22 10:04:21
https://api.github.com/repos/hyperledger/indy-hipe/issues/47,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/472690648,https://github.com/hyperledger/indy-hipe/pull/47#issuecomment-472690648,TelegramSam,"@sklump @jovfer There are questions without responses here. Are these resolved elsewhere, or are there things that still need to be discussed?",2019-03-14 03:27:39,2019-03-14 03:27:39
https://api.github.com/repos/hyperledger/indy-hipe/issues/47,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/472723171,https://github.com/hyperledger/indy-hipe/pull/47#issuecomment-472723171,sklump,"Encoding algorithms must be specified for interop somewhere, but this universal approach is not the way to do it. ",2019-03-14 06:39:18,2019-03-14 06:39:18
https://api.github.com/repos/hyperledger/indy-hipe/issues/47,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/474812222,https://github.com/hyperledger/indy-hipe/pull/47#issuecomment-474812222,jovfer,"@sklump please take a look on my comments above. I got the point that this pr is only about some universal approach and not about particular encoding, but still have unresolved questions",2019-03-20 12:42:12,2019-03-20 12:42:12
https://api.github.com/repos/hyperledger/indy-hipe/issues/47,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/475180914,https://github.com/hyperledger/indy-hipe/pull/47#issuecomment-475180914,sklump,"> 
> 
> @sklump please take a look on my comments above. I got the point that this pr is only about some universal approach and not about particular encoding, but still have unresolved questions

The metadata in the encoding allowed for decoding back to original data types (e.g., 0.05, None, True instead of ""0.05"", """", ""1""). This turns out not to be a requirement and so we can discard the whole tactic.",2019-03-21 10:37:56,2019-03-21 10:37:56
https://api.github.com/repos/hyperledger/indy-hipe/issues/46,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/429366871,https://github.com/hyperledger/indy-hipe/pull/46#issuecomment-429366871,dbluhm,"It seems as though it might make sense to leave ""new"" off the front of each of the message types. It feels a little redundant but I don't feel strongly about this if you think it should stay that way.",2018-10-12 15:33:52,2018-10-12 15:33:52
https://api.github.com/repos/hyperledger/indy-hipe/issues/46,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/429369470,https://github.com/hyperledger/indy-hipe/pull/46#issuecomment-429369470,mikelodder7,"> It seems as though it might make sense to leave ""new"" off the front of each of the message types. It feels a little redundant but I don't feel strongly about this if you think it should stay that way.

Done",2018-10-12 15:41:38,2018-10-12 15:41:38
https://api.github.com/repos/hyperledger/indy-hipe/issues/46,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/429370696,https://github.com/hyperledger/indy-hipe/pull/46#issuecomment-429370696,dbluhm,"Another minor comment regarding the types: I think we might want to make `connection` the message family and move that from off the front of the type.

So, this `""@type"": ""did:sov:1234567890;spec/messagefamily/1.0/connectionofferunencrypted""` would become `""@type"": ""did:sov:1234567890;spec/connection/1.0/offerunencrypted""`.",2018-10-12 15:45:22,2018-10-12 15:45:22
https://api.github.com/repos/hyperledger/indy-hipe/issues/46,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/430747564,https://github.com/hyperledger/indy-hipe/pull/46#issuecomment-430747564,swcurran,"Since the intention of the connection request (and response) is to establish a pairwise relationship with the other party, I think the exchanged data for these messages should not be a public key but rather a DID and DIDDoc. I would think the other party would also need to know what key entry it should be using to respond, so as that the response would be sent to the correct agent. The connection being established is (I believe) between two domains, not just two agents (based on the requirements in the Cross-Domain and DIDDoc Convention HIPEs) and so this protocol should account for that.

In saying that, I'm assuming that the ""message"" is just a piece of verification text being exchanged - correct?

That implies this HIPE blurs into the Relationship State Machine HIPE/protocol. My preference is that the RSM is an internal implementation (not exposed at the cross-domain level) and so other than knowing that somehow the set of agents that make up the domain have to manage the RSM, it has little impact on this HIPE - other than the requirement that the implementation provide a DID and DIDDoc for these messages to send.
",2018-10-17 18:55:42,2018-10-17 18:55:42
https://api.github.com/repos/hyperledger/indy-hipe/issues/46,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/430747671,https://github.com/hyperledger/indy-hipe/pull/46#issuecomment-430747671,swcurran,"We've come across a couple of use cases recently where an introduction mechanism might be useful from a user experience perspective. An ""introduction"" in this case would be where two identities have a relationship, and one (Alice) wants to introduce the other (Bob) to a third party (Carol). Alice and Bob, and Alice and Carol already have relationships and the goal is for Bob and Carol to have a relationship (that doesn't include Alice). It seems that the use of unencrypted communications and public DIDs might be able to be avoided if a temporary public key can flow from Bob through Alice to Carol in place of the ""out of band connection"". I think it might make sense to standardize, could reduce correlation opportunities and could improve user experience. Risk is that it be able to be abused, so that needs to be considered.

Has this been considered? Good/bad idea?",2018-10-17 18:55:58,2018-10-17 18:55:58
https://api.github.com/repos/hyperledger/indy-hipe/issues/46,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/430796185,https://github.com/hyperledger/indy-hipe/pull/46#issuecomment-430796185,mikelodder7,So this protocol uses “temporary” keys. The public key here is an ephemeral key so no correlation is created. It also adds forward secrecy. This does not handle routing I’m assuming that is handled at a lower level. By doing introductions this way you either have 0-RTT with public DIDs and 1-RTT otherwise.,2018-10-17 21:28:34,2018-10-17 21:28:50
https://api.github.com/repos/hyperledger/indy-hipe/issues/46,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/430811385,https://github.com/hyperledger/indy-hipe/pull/46#issuecomment-430811385,dbluhm,"> The public key here is an ephemeral key

The HIPE does contain this information in the sequence diagram. It would probably be beneficial to additionally include this in the ""Message Types"" section to further clarify.",2018-10-17 22:27:14,2018-10-17 22:27:14
https://api.github.com/repos/hyperledger/indy-hipe/issues/46,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/430843522,https://github.com/hyperledger/indy-hipe/pull/46#issuecomment-430843522,swcurran,"> So this protocol uses “temporary” keys. The public key here is an ephemeral key so no correlation is created. It also adds forward secrecy. This does not handle routing I’m assuming that is handled at a lower level. By doing introductions this way you either have 0-RTT with public DIDs and 1-RTT otherwise.

@mikelodder7 - did you intend the comment above as a reply to my note about DIDDocs?  If so, it doesn't address the issue that I'm saying is needed - that at the end of the connection process, we have a pairwise relationship that we can use for other Agent messaging.  The purpose of this Message Family is (I think) to achieve this state.

Re: lower level routing - there is not a lower level to do routing when we are talking about the Establish Connection message family. The purpose of the family is to create the shared data so that we can do that routing with future messages - e.g. the exchanged DIDDoc data.

",2018-10-18 01:25:37,2018-10-18 01:26:34
https://api.github.com/repos/hyperledger/indy-hipe/issues/46,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/430860501,https://github.com/hyperledger/indy-hipe/pull/46#issuecomment-430860501,dbluhm,"@swcurran I added some details which might address your concerns. What this protocol is really trying to establish is not *what* needs to be sent to establish the pairwise relationship but *how* that information is sent. In place of the DID and Verification key in the connection message, we could just as easily put just a DID to be looked up on the ledger or a DIDDoc.

Our focus at the moment is to establish connections with what we have today (for a functional demo at IIW) which, unfortunately, means that we won't be sending a full DIDDoc because we don't have DIDDoc support in Indy-sdk yet. Additionally, before introducing the complexities of routing through domains, we want to demonstrate the basics of messaging. As we see things like Microledger and DIDDoc support hit the SDK, I think we can start to have more HIPEs (or update this one) addressing exactly what content is sent as part of a connection establishment *that works with currently available code*.

By keeping the scope of this HIPE narrow, we can focus on the mechanics and crypto of the exchange itself.",2018-10-18 03:10:19,2018-10-18 03:14:11
https://api.github.com/repos/hyperledger/indy-hipe/issues/46,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/430860879,https://github.com/hyperledger/indy-hipe/pull/46#issuecomment-430860879,dbluhm,"Feel free to correct me if I'm off, @mikelodder7 ",2018-10-18 03:12:39,2018-10-18 03:12:39
https://api.github.com/repos/hyperledger/indy-hipe/issues/46,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/430868097,https://github.com/hyperledger/indy-hipe/pull/46#issuecomment-430868097,swcurran,"Hey @dbluhm, reasonable I guess, but I don't think HIPEs should be written to deal with short term deliverables.  I think it's great that your team is working on an immediate deliverable (can't wait to see it!), but I don't think a HIPE should be constrained by that deliverable.  HIPEs (and **especially** this HIPE IMHO) should be driving what core indy-sdk functionality needs to be implemented, so work can be prioritized on that.  HIPEs shouldn't propose unrealistic ""cool, but ain't never gonna happen"" approaches, but they shouldn't be limited to what can be done today.

I'd prefer to see a complete HIPE for Establishing Connections, with perhaps a ""Current Status"" section that deals with what can be implemented in the short term.  Ideally, there should also be a ""Dependent On"" section that points to other HIPEs/features needed.

It's not clear my suggestion is right (although it is how I understand the HIPE process).  I think if we do go with the more pragmatic approach you are proposing, then we should back off on several of the other HIPEs that have been proposed - especially the Cross-Domain and DIDDoc Conventions ones, as they are contradictory to this HIPE - and this one has code.

Finally - I would add that this to me shows the urgency of getting DIDDoc support in at least indy-sdk and likely indy-node.",2018-10-18 04:02:11,2018-10-18 04:02:11
https://api.github.com/repos/hyperledger/indy-hipe/issues/46,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/430876951,https://github.com/hyperledger/indy-hipe/pull/46#issuecomment-430876951,mikelodder7,"> Hey @dbluhm, reasonable I guess, but I don't think HIPEs should be written to deal with short term deliverables. I think it's great that your team is working on an immediate deliverable (can't wait to see it!), but I don't think a HIPE should be constrained by that deliverable. HIPEs (and **especially** this HIPE IMHO) should be driving what core indy-sdk functionality needs to be implemented, so work can be prioritized on that. HIPEs shouldn't propose unrealistic ""cool, but ain't never gonna happen"" approaches, but they shouldn't be limited to what can be done today.

That's not the goal of this HIPE. The goal here is to have the introduction messages. This only shows the minimum required fields. The contents of *message* can be whatever is necessary to complete the setup. The problem is we haven't define exactly what this is. So this should be the ""Dependent On"" section that you suggest.
> 
> I'd prefer to see a complete HIPE for Establishing Connections, with perhaps a ""Current Status"" section that deals with what can be implemented in the short term. Ideally, there should also be a ""Dependent On"" section that points to other HIPEs/features needed.
> 
> It's not clear my suggestion is right (although it is how I understand the HIPE process). I think if we do go with the more pragmatic approach you are proposing, then we should back off on several of the other HIPEs that have been proposed - especially the Cross-Domain and DIDDoc Conventions ones, as they are contradictory to this HIPE - and this one has code.

Cross-Domain should work in conjunction with this HIPE. This HIPE does not cover how routing and discovery are made. Just the interactions needed to complete the setup for a new relationship in a secure forward secret manner.
> 
> Finally - I would add that this to me shows the urgency of getting DIDDoc support in at least indy-sdk and likely indy-node.

Agreed.",2018-10-18 05:09:39,2018-10-18 05:09:39
https://api.github.com/repos/hyperledger/indy-hipe/issues/46,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/431074729,https://github.com/hyperledger/indy-hipe/pull/46#issuecomment-431074729,swcurran,"Ah - so the message field is not just a challenge/response verification, but can be what is needed for set up - e.g. a DIDDoc once that is fleshed out.  That should definitely be clarified - it might have been since my last read yesterday afternoon.

The HIPE can be what the community accepts.  Not my favourite approach to have an interim definition (as I think this still is - perhaps not), but that's just me.

",2018-10-18 16:26:41,2018-10-18 16:26:41
https://api.github.com/repos/hyperledger/indy-hipe/issues/45,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/425235189,https://github.com/hyperledger/indy-hipe/pull/45#issuecomment-425235189,devin-fisher,"Seems that the weak link is the config txn that configures this policy. Some description of how this will work is important. I assume that only Trustees can submit config TXNs. Is that right? Secondly, how many Trustees will be required to change the config TXN? 

If the policy is that it takes three trustees to add a trustee but it only takes one trustee to change the number of trustees it takes to add a trustee, then, in fact, it only takes one trustee to add a trustee.",2018-09-27 20:41:17,2018-09-27 20:41:17
https://api.github.com/repos/hyperledger/indy-hipe/issues/45,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/425235220,https://github.com/hyperledger/indy-hipe/pull/45#issuecomment-425235220,devin-fisher,"
It would seem that adding trustee would always have to require the most signers, otherwise, all other actions reduce to this number. For example, if I wanted to upgrade the ledger to a new version (a bad version with a backdoor). But I only have two trustees colluding with me and the update txn requires three trustees. But adding a trustee requires only two. I could quickly add a new trustee and then I would have the required three and I could then issue the upgrade txn.",2018-09-27 20:41:23,2018-09-27 20:41:23
https://api.github.com/repos/hyperledger/indy-hipe/issues/45,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/425933260,https://github.com/hyperledger/indy-hipe/pull/45#issuecomment-425933260,sergey-shilov,"> Seems that the weak link is the config txn that configures this policy. Some description of how this will work is important. I assume that only Trustees can submit config TXNs. Is that right? Secondly, how many Trustees will be required to change the config TXN?
> If the policy is that it takes three trustees to add a trustee but it only takes one trustee to change the number of trustees it takes to add a trustee, then, in fact, it only takes one trustee to add a trustee.

It's a question of genesis transactions for config ledger. Concrete values of quorums is a question for discussion and agreement of stakeholders. We can define the lowest thresholds as a constants in the indy-node code base, but I don't think that it is right solution as we want to have it configurable.",2018-10-01 14:42:13,2018-10-01 14:42:13
https://api.github.com/repos/hyperledger/indy-hipe/issues/45,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/425934483,https://github.com/hyperledger/indy-hipe/pull/45#issuecomment-425934483,sergey-shilov,"> It would seem that adding trustee would always have to require the most signers, otherwise, all other actions reduce to this number.

Yes, sure.",2018-10-01 14:45:38,2018-10-01 14:45:38
https://api.github.com/repos/hyperledger/indy-hipe/issues/45,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/426007889,https://github.com/hyperledger/indy-hipe/pull/45#issuecomment-426007889,TelegramSam,"Is the method of transferring between trustees out of scope for the doc? 
`Then Trustee1 transfers the JSON to Trustee2` appears in muliple places, but that transmission method is never discussed.",2018-10-01 18:12:34,2018-10-01 18:12:34
https://api.github.com/repos/hyperledger/indy-hipe/issues/45,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/426224625,https://github.com/hyperledger/indy-hipe/pull/45#issuecomment-426224625,sergey-shilov,"> Is the method of transferring between trustees out of scope for the doc?
> `Then Trustee1 transfers the JSON to Trustee2` appears in muliple places, but that transmission method is never discussed.

Right, this doc is mostly about the Ledger. Transaction transmission between client applications is out of scope of this doc, and may be it's a topic for another HIPE.",2018-10-02 10:25:42,2018-10-02 10:25:42
https://api.github.com/repos/hyperledger/indy-hipe/issues/45,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/428776100,https://github.com/hyperledger/indy-hipe/pull/45#issuecomment-428776100,swcurran,"The challenge of this is definitely on the application side - creating the transaction.  I would recommend figuring out:

* What the transaction needs to look like, and hence
* How the transaction will be created on the application side.

My guess is that this will largely be created manually in chunks and then assembled.  For example:

* Originator creates and signs the transaction - IndySDK CLI Call 1 (no call to ledger)
* Sends (emails, slack) the transaction to the others to sign - IndySDK CLI Call 2 (no call to ledger)
* Originator receives back the signatures (emails, slack), reassembles and issues indy-node call - CLI Call 3

It would be good to have these types of details reviewed with the indy-sdk team and the work go on in parallel.

Agree this is very much needed.",2018-10-11 00:23:38,2018-10-11 00:23:38
https://api.github.com/repos/hyperledger/indy-hipe/issues/45,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/437952753,https://github.com/hyperledger/indy-hipe/pull/45#issuecomment-437952753,ashcherbakov,"@swcurran 
I believe exact steps (and calls) for libindy are provided in Tutorial section: https://github.com/hyperledger/indy-hipe/blob/10fc1f46631de4c86c95717cfa15446f67f42646/text/multi-sig-actions/README.md#tutorial

Is it enough?",2018-11-12 16:53:16,2018-11-12 16:53:16
https://api.github.com/repos/hyperledger/indy-hipe/issues/45,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/437954103,https://github.com/hyperledger/indy-hipe/pull/45#issuecomment-437954103,ashcherbakov,"@devin-fisher @sergey-shilov 
> I assume that only Trustees can submit config TXNs. Is that right? 

I think yes.

> Secondly, how many Trustees will be required to change the config TXN?

I believe we can use other strategies (hard-coded in config percent-based or constant-based number of Trustees required) for the first txn to config ledger. After this we can use the current config txn value for the update.
",2018-11-12 16:56:54,2018-11-12 16:57:10
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/423238851,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-423238851,mikelodder7,Here is the [rendered text](https://github.com/kdenhartog/indy-hipe/tree/AMES/AMES),2018-09-20 16:01:53,2018-09-20 16:01:53
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/423249634,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-423249634,mikelodder7,So how is the entire message protected? I didn't see any method to protect the confidentiality and integrity of the headers? Is this done with authcrypt or anon crypt or using the Signal protocol?,2018-09-20 16:34:10,2018-09-20 16:34:10
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/423294430,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-423294430,kdenhartog,@mikelodder7 this is a refactor I haven't gone back in and implemented. I expect this to be handled by the function itself similar to how authcrypt handles all of this as well under the hood. This will need to be implemented before it's accepted.,2018-09-20 18:54:43,2018-09-20 18:54:43
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/428280388,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-428280388,mikelodder7,"So this is acceptable for integrity mitigation for the sender because Alice knows Bob's ver key so Mallory would not learn Alice's public key and Alice could detect if Mallory is messing with it, but not for Bob. Mallory could change the message entirely for Bob and he wouldn't know it but it would be obvious to Alice. This would only be a problem during an introductory phase. Once Bob knows Alice's ver key this isn't a problem. Implementers should keep in mind that this doesn't address forward secrecy, which can be accomplished if the ver key's are only used once.",2018-10-09 17:29:49,2018-10-09 17:29:49
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/428291839,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-428291839,kdenhartog,"> So this is acceptable for integrity mitigation for the sender because Alice knows Bob's ver key so Mallory would not learn Alice's public key and Alice could detect if Mallory is messing with it, but not for Bob. Mallory could change the message entirely for Bob and he wouldn't know it but it would be obvious to Alice. This would only be a problem during an introductory phase. Once Bob knows Alice's ver key this isn't a problem. Implementers should keep in mind that this doesn't address forward secrecy, which can be accomplished if the ver key's are only used once.

I agree, with this concern. My thinking was that once microledgers are built in the messages would verify keys exist in the microledger. Would this be adequate for the described issue? Alternatively, is there another solution that I could implement before microledgers that I haven't noticed yet?",2018-10-09 18:04:47,2018-10-09 18:04:47
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/428345133,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-428345133,mikelodder7,"For an introduction message, forward secrecy could be achieved by just doing a Diffie Hellman exchange as part of the sequence. 

A -> B: One-Time-Public Key (OTK-A), Reverse-URL
B -> A: One-Time-Public Key (OTK-B), Enc(K, DID, Identity Key)
A -> B: Enc(K, DID, Identity Key)

K is computed by B using OTK-A and his private material and
A using OTK-B and her private material.

This wouldn't provide mutual authentication and is subject to MITM but so is every introduction handshake. If this exchange happens offline (QR code scanning, code typing) then this is very unlikely to be the case. Microledgers could also be included as part of this exchange. Other data can be exchanged as well but the point is that we don't need authcrypt or anoncrypt for the intro handshake. 

If party B has a well known public key say in their DID Doc on the ledger, then A can authenticate B.",2018-10-09 20:45:48,2018-10-09 20:46:41
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/428382992,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-428382992,kdenhartog,introduction falls under the connection protocol HIPE. This should be used as the the pipes for everything after.,2018-10-09 23:06:13,2018-10-09 23:06:13
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/428399266,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-428399266,mikelodder7,Okay I cross posted there. If that is the case then this format could be used in conjunction with the forward secrecy HIPE ,2018-10-10 00:40:12,2018-10-10 00:40:12
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/429066155,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-429066155,mikelodder7,"I don't think the field ""enc"" is needed. The encryption algorithm should be implied by the version.
Also is ""iv"" used to encrypt the cipher text? if so authcrypt and anoncrypt do not provide this to you. I do not think ""iv"" or ""cek_nonce"" are needed. Those are all wrapped in authcrypt and anoncrypt. If you want a message nonce you should rename this to message_id or message_nonce.

Also as it stands the entire message does not provide any integrity checking. Another user could change the recipients without changing the message and it wouldn't be known.

You need to have integrity checks via a MAC to make sure the nonce of this message is not changed. Its not clear if that happens outside of this message by a wrapping envelope or it should happen in this message directly.
The problem is its unclear how to create the MAC since no key exchange has happened. This is necessary to prove to recipients that nothing was changed. So each end recipient would have to know a key to check this. (I suggest this would be a separate HIPE for the group key lifecycle management).

Another attack could happen here since the ""ver"" field is also not protected by a MAC. If a vulnerability is discovered in 1.0 then an attacker could change the message version from a future version back to version 1.0 without changing anything else.",2018-10-11 18:22:04,2018-10-11 18:23:01
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/429082819,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-429082819,kdenhartog,"@mikelodder7

As far as the ""IV"" and ""cek_nonce"" stuff I wanted to include this so that other implementations can use different architectures. For example, if this were to be rebuilt with tweetNacl calls a nonce would be needed to make the API calls, so appending it to the ciphertext would cause problems for them. Within Indy, this doesn't affect people because they don't have to worry about it. I'll rename ""IV"" to ""msg_nonce"" which isn't a big deal. 

thanks for catching the HMAC documentation missing. I realized I didn't highlight the change about going from encrypt_detached to encrypt which adds the HMAC to the end. I'll document this so that people are aware of it. It is documented in the ""enc_from"" header description. 

I'm not sure I understand your second point about creating the MAC. This is being handled by Sodium Oxide for us, so I'm not as worried about it. If you're thinking about how to generalize this further than just using Nacl libraries, I intentionally put that out of scope, because at that point it would be better for us to use JWE serialization and libraries. I wanted to build something specific to our needs which is what AMES are intended to do.

As for the third point about ""ver"" not being protected by a MAC, I don't find this necessary. The only thing ver is being used for is to allow JSON structure changes without causing breaking changes. protecting this with a MAC wouldn't help other than to identify tampering. However, because the ver just describes how to process the message, the outcome of changing the ""ver"" would be that the message can't be processed correctly, so it wouldn't allow the message to be decrypted.",2018-10-11 19:11:11,2018-10-11 19:11:11
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/429087220,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-429087220,mikelodder7,"By adding in the IV you still need to protect these with MACs. Yes the cipher text won't decrypt but there is nothing protecting me from changing everything. The point is you can't detect any changes to the IV, versions, etc. 

I disagree with you about the third point. Suppose a newer version includes extra fields for protection or information. Since its not protected I can downgrade to a weaker version.
Not all attackers are naive. This could be someone already in the ecosystem that is a legitimate user that could tamper with it.",2018-10-11 19:26:14,2018-10-11 19:26:14
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/429090559,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-429090559,mikelodder7,"A simple solution is to have ""ver"" be included as the AD as part of the encrypted message.",2018-10-11 19:36:57,2018-10-11 19:36:57
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/429114079,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-429114079,kdenhartog,"@mikelodder7 
If you change everything, why couldn't you also just change the MAC protecting the IV? Wouldn't this  make it not possible to detect the changes either. Also, to the point about not being able to detect any changes, not being able to decrypt the message is a pretty good way to detect tampering in my opinion. Is there an attack where a person could be fooled to believe that a decryptable message was from a sender when it was actually generated by a MITM? I can't think of how this is possible.",2018-10-11 20:51:32,2018-10-11 21:05:10
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/434535722,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-434535722,tplooker,"Hi Guys,

Can anyone confirm that this HIPE doesn't conflict with HIPE #35 in regards to message routing? It is mentioned near the beginning of this HIPE that it aids with routing, can anyone shed any light on that?",2018-10-31 02:08:23,2018-10-31 02:08:23
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/436075445,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-436075445,kdenhartog,"@tplooker This won't conflict with HIPE #35. When I originally was working on this, I had the intention of coupling the forward messages and the routing table all together. Through discussions with people in the community on the Indy agent calls, we decided that it would be better to decouple these layers. This HIPE hasn't been updated to reflect these changes.  After this HIPE is updated it will focus specifically on the encryption of messages in a standard way. Message routing will be handled (as I'm currently thinking, still needs community consensus) through a to be outlined routing table HIPE and through the use of the Forward Message outlined in HIPE #35. 

To give an example of how these all tie together, an agent will receive a AMES message and decrypt it. This will provide a standard message, which is defined in [HIPE-0021](https://github.com/hyperledger/indy-hipe/tree/master/text/0021-message-types), inside which may be a forward message or a message of a different message family. If it's a forward message, the agent should look at the receiving DID, lookup the service endpoint and key used to encrypt the message for the next hop in a locally stored route table, prepare and encrypt the message for the next hop, and send it to the service endpoint. Much of the details I'm glossing over will be outlined in the forthcoming HIPE once this one is completed and accepted since it's largely dependent on this work. ",2018-11-05 23:31:55,2018-11-05 23:31:55
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/436402430,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-436402430,tplooker,"@kdenhartog thanks, I originally thought separating these two was a good idea too, but since the AMES defines the recipient(s) doesn't that meaning routing should almost be dependent on this? For example a routing agent has a routing table consisting of a mapping between recipient identifier (i.e the to field in a recipient object in the message) to a service endpoint (the next network hop)?

Otherwise we are perhaps going to have unnecessary nesting, where a recipient un-packs a message to find another forward message they then have to un-pack? 

Also are these messages sent over the wire in plain text i.e as a JWM or will the message be encrypted for each network hop, for example I send a message to you via your domain endpoint (using language from #35) and as the final layer of encryption before transmitting the message I take the JWM and encrypt it with the verkey of your domain endpoint, so that only the domain endpoint can decrypt? The domain endpoint would then use its routing table to find the intended recipient(s) in the recipient list and re-encrypt the message for the next network hop(s) based on the routing configuration?",2018-11-06 20:46:12,2018-11-06 20:47:27
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/438059422,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-438059422,kdenhartog,"@tplooker hopefully the new additions answer your questions above. If some aspect is still confusing please let me know and I'll add some details.

@swcurran Can you give this a read and see if I incorporated the details of PR #36 as you would have? The one notable piece I left out was the descriptions around Domains because I plan to take that detail and add it to the route table HIPE which I saved in a hackmd doc and will build out once this work is finished.

@TelegramSam and @mikelodder7 can you make sure this aligns with the work you described in your Hackmd doc? Note, I moved the recipients into the protected section as this will solve the concern about not being able to use AEAD functions with TweetNacl-js libraries to build the webshim.

Also, this is just a first pass at merging the 3 docs. There's some sections I still need to move around, some APIs I need to update, and most notably the algorithms need a fresh look now that the new formats are added.",2018-11-12 22:58:58,2018-11-12 23:05:48
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/439006823,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-439006823,vimmerru,"@kdenhartog 

1. Where is Wire message concept is defined? Do we have corresponded HIPE that exactly shares your vision about this?
2. Could you provide complete sequence diagram that will contain exact calls for sending a message from Alice to Bob?
3.  How Bob should determine what key he should pass to unpack message after receiving of some wire message on agent endpoint? As i understand the list if recipients are placed inside of wire message.
4. What is format of ""encrypted message""? ",2018-11-15 11:19:39,2018-11-15 11:19:39
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/439009004,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-439009004,vimmerru,"@kdenhartog 

5. Also i don't understand how i can get information about message sender after calling unpack. Cloud you explain?",2018-11-15 11:28:18,2018-11-15 11:28:18
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/439009618,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-439009618,vimmerru,"@kdenhartog 

6. You allow to use recipients as DIDs, not as keys. How i can achieve this through provided API?
7. Do you use multiple recipients to send multiple messages or to send one message to multiple agents of one identity owner?",2018-11-15 11:30:47,2018-11-15 11:30:47
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/439014065,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-439014065,vimmerru,"@dhh1128 @kdenhartog @mikelodder7 

8. I have feeling that it is hard to understand non-contradiction concept of A2A messages by reading multiple related HIPEs that we have here. Do we have any ""root"" HIPE about this?  ",2018-11-15 11:49:07,2018-11-15 11:49:07
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/439190147,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-439190147,kdenhartog,"1. It should now be defined in this HIPE. [This](https://github.com/kdenhartog/indy-hipe/tree/AMES/text/AMES#wire-messages) section is supposed to cover it. 

2. This one is a bit tougher because it depends on the path that is going to be taken. For example, if Alice's agent is directly communicating over http with Bob's agent, then she would auth_pack and then http POST the output to bob's agent. Bob would then call unpack and get the message and the key she used to pack it. However, in many different scenarios, it could be different. Would adding that example into the HIPE help?

3. In the simplest form, we brute force lookup keys that are listed in the recipients header. There's probably a more efficient way than this, but that's the easiest to implement and has O(m*n) time complexity. In this, m represents the lookup time complexity of the database used (probably log(num_of_keys)) and n represents the number of keys in the received message.

4. It's nearly a JWE which can be found [here](https://github.com/kdenhartog/indy-hipe/tree/AMES/text/AMES#indy_anon_pack_message-output-format) and [here](https://github.com/kdenhartog/indy-hipe/tree/AMES/text/AMES#auth_pack_message-api-and-output-format)

5. Good catch, I hadn't updated this part in the doc yet. I'll add an update to the document outlining this stuff, but essentially, if anon_pack was used an empty string is returned. If auth_pack was used, the senders key will be returned similar to how authcrypt does it now.

6. This is not possible at this point. I think the thinking on it (came from @TelegramSam and @mikelodder7 paper) was that this functionality will be built in either with microledgers or in the future, so we should include it in the HIPE.

7. The second option is what I had in mind. This is something that I don't believe the thinking is crisp enough yet, because we've not gotten a chance to think about many transport layers outside of HTTP.

8. I agree that it can be confusing this way. Originally @swcurran proposed this work all together in one HIPE and then we agreed to split it up to allow the layers to be approved independently. Maybe once we've got the majority of the layers agreed upon we can recombine them through an overview document.


",2018-11-15 21:06:49,2018-11-15 21:13:23
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443372576,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-443372576,kdenhartog,"My intention for this HIPE was to replace HIPE #36 . I've included the information I thought would be relevant, but if there's more information that I should include can you let me know? If there's no additional information I should include then I'd propose closing the HIPE.",2018-11-30 23:38:44,2018-11-30 23:38:44
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445169141,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-445169141,swcurran,"Shouldn't all references to AMES be removed?  That has never really caught on, and if we're renaming the HIPE, we should change the references.",2018-12-07 09:10:50,2018-12-07 09:10:50
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445169585,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-445169585,swcurran,Just wondering - the line about working with Mike Jones was first added quite a while ago. Any progress on those discussions?  Has he reviewed/blessed this HIPE?,2018-12-07 09:12:33,2018-12-07 09:12:33
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445172379,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-445172379,swcurran,"I suggest that the unpack output should also be specified.  I think the recipient needs to now more than just the message, right?  Not sure where that got left.",2018-12-07 09:23:27,2018-12-07 09:23:27
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445172690,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-445172690,swcurran,"While the ""Unresolved Questions"" are accurate, it would be nice to have a summary of how each of those will be handled.  I think the answers are known, so a summary of that information would be helpful.",2018-12-07 09:24:41,2018-12-07 09:24:41
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445264950,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-445264950,kdenhartog,"I've considered all the changes and added/changed things where necessary.

On Fri, Dec 7, 2018 at 2:26 AM Stephen Curran <notifications@github.com>
wrote:

> *@swcurran* approved this pull request.
>
> Looks good!
>
> Would like a tweak to the first paragraph - ""At the highest level are
> Agent Messages - messages sent between Identities *(Sender, Receiver)* to
> accomplish..."" - would help clarify that paragraph and the next.
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/hyperledger/indy-hipe/pull/43#pullrequestreview-182608994>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AWDcQ3-1VODtVOGGJ3K_fX2Hv1hjpd4-ks5u2jRFgaJpZM4Ws9GC>
> .
>
",2018-12-07 15:20:53,2018-12-07 15:20:53
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/452416708,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-452416708,kdenhartog,A message pack dependency crept in from building off the authcrypt code in libindy. Please hold off on approving this HIPE until I've found a way to remove this dependency while remaining in alignment with the libindy work.,2019-01-08 19:11:17,2019-01-08 19:11:17
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/452726599,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-452726599,swcurran,"While this shouldn't hold up moving this HIPE forward (and definitely not the code!), I think there should be more precise examples of the pack() and unpack() interface.  What happens in between is important to the code implementers (and is well covered in the HIPE). However, for the users of the capabilities - they really just want to know what they have to pass in to each function, and what is going to be returned.

On that topic - a question I have is about unpack - does it just return the message (like the example in ""Code for this might look like the following:"" shows), or does it return other necessary information that might be needed routing - notably the verkey?  BTW - that example is wrong for the received message - the ""tmsg"" and ""jwe"" are both used for the same data element.,

Related question - does the fact that the verkey of the receiver is in the header mean that the ""forward"" message type is no longer needed?  The receiver of a Wire Message could always just get back the verkey of any embedded JWE, and from that, infer (based on routing tables) where the message is to go next.  It seems like ""Forward"" is redundant now that the information is in the JWE.",2019-01-09 15:00:28,2019-01-09 15:00:28
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/452894759,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-452894759,kdenhartog,"> While this shouldn't hold up moving this HIPE forward (and definitely not the code!), I think there should be more precise examples of the pack() and unpack() interface. What happens in between is important to the code implementers (and is well covered in the HIPE). However, for the users of the capabilities - they really just want to know what they have to pass in to each function, and what is going to be returned.

I can add this easily. It's documented in the APIs code, but I'll move it to the HIPE as well, so it's easier for others to implement if they wanted to without looking at the code. Thanks for the suggestion.

> On that topic - a question I have is about unpack - does it just return the message (like the example in ""Code for this might look like the following:"" shows), or does it return other necessary information that might be needed routing - notably the verkey? BTW - that example is wrong for the received message - the ""tmsg"" and ""jwe"" are both used for the same data element.,

I'll message you to get the details about the specific example if I can't find it. With regards to the return value, it will return a JSON object that includes a verkey if it's authcrypted. I'll include this in the details that I provide from above.

> Related question - does the fact that the verkey of the receiver is in the header mean that the ""forward"" message type is no longer needed? The receiver of a Wire Message could always just get back the verkey of any embedded JWE, and from that, infer (based on routing tables) where the message is to go next. It seems like ""Forward"" is redundant now that the information is in the JWE.

I do believe that Forward could be redundant at this point because the verkeys are listed in the recipients header and are publicly viewable. The one advantage that a forward message would have over the verkey's would be the use of DIDs, where as with the wire message we chose not to use DIDs to prevent DID resolution issues from popping up. Instead we think it would be better to build some code on top later that will consume pack/unpack and will handle DID resolution seperately. If done right, forward messages could be removed. Given that the wallet doesn't have a built in verkey -> DID solution right now though, I think it's fine to support forwards without causing future breaking changes.",2019-01-09 22:34:06,2019-01-09 22:34:33
https://api.github.com/repos/hyperledger/indy-hipe/issues/43,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/457769629,https://github.com/hyperledger/indy-hipe/pull/43#issuecomment-457769629,dhh1128,HIPE has been at FCP for quite a while. Implementation was merged into Indy SDK today.,2019-01-25 23:26:20,2019-01-25 23:26:20
https://api.github.com/repos/hyperledger/indy-hipe/issues/38,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/418870494,https://github.com/hyperledger/indy-hipe/pull/38#issuecomment-418870494,dbluhm,[rendered text](https://github.com/mikelodder7/indy-hipe/tree/master/text/a2a-forward-secrecy),2018-09-05 20:29:15,2018-09-05 20:29:15
https://api.github.com/repos/hyperledger/indy-hipe/issues/38,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/419012956,https://github.com/hyperledger/indy-hipe/pull/38#issuecomment-419012956,vimmerru,"I have few questions:

1. Edge-2-Edge pairwise communication is only part of communication types supported by Indy. We have also at least:
 - Public DIDs published on the ledger with DIDDoc
 - Communication with agencies
 - Communication between edge agent and supplementary (cloud) agents 
 - Communication between (cloud) agents 

Supporting of Signal between each chain link seems overkill and doesn't possible for some links. Do you think we need to make Signal optional or use Signal only for Edge-2-Edge messages?

2. Can we just use continuous key rotation in microledgers to achieve some kind of forward security instead?



",2018-09-06 08:38:47,2018-09-06 08:38:47
https://api.github.com/repos/hyperledger/indy-hipe/issues/38,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/419019135,https://github.com/hyperledger/indy-hipe/pull/38#issuecomment-419019135,vimmerru,@mikelodder7 Could you also clarify how this approach can be integrated with DIDDoc spec and agent domains? As i understand existing Signal implementation binds ratchet to one edge-device and it is impossible to receive messages on different edge-devices.,2018-09-06 08:59:12,2018-09-06 08:59:12
https://api.github.com/repos/hyperledger/indy-hipe/issues/38,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/419085984,https://github.com/hyperledger/indy-hipe/pull/38#issuecomment-419085984,mikelodder7,"I’m intending this to be between edge agents whether in domain or out of domain.

I don’t want to have to rotate the micro ledger keys after every message. The transactions for the micro ledger would become very big if we did that and would bloat messaging as with each message you send you would also have to send the signed transaction to enforce the new key",2018-09-06 13:06:40,2018-09-06 13:06:40
https://api.github.com/repos/hyperledger/indy-hipe/issues/38,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/419087093,https://github.com/hyperledger/indy-hipe/pull/38#issuecomment-419087093,mikelodder7,"This protocol would not be used to talk to the ledger. That would be overkill and the ledger would have to maintain state for it which we don’t need to do.

To talk to agencies and the ledger which are online, I envision we can just use TLS with forward secret ciphers. So cloud agent 1 can use TLS to send a message to cloud agent 2. Whenever we have synchronous messaging it makes sense to just use TLS",2018-09-06 13:10:13,2018-09-06 13:10:13
https://api.github.com/repos/hyperledger/indy-hipe/issues/38,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/419087520,https://github.com/hyperledger/indy-hipe/pull/38#issuecomment-419087520,mikelodder7,"@vimmerru as I understand it, we already have to maintain keys for each edge agent for every relationship. This would just employ the signal protocol also.",2018-09-06 13:11:38,2018-09-06 13:11:38
https://api.github.com/repos/hyperledger/indy-hipe/issues/38,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/419102181,https://github.com/hyperledger/indy-hipe/pull/38#issuecomment-419102181,mikelodder7,You raise good points so I will add clarity text to reflect it,2018-09-06 13:54:35,2018-09-06 13:54:35
https://api.github.com/repos/hyperledger/indy-hipe/issues/38,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/419171167,https://github.com/hyperledger/indy-hipe/pull/38#issuecomment-419171167,mikelodder7,Added sections to reflect @vimmerru's questions,2018-09-06 17:10:26,2018-09-06 17:10:26
https://api.github.com/repos/hyperledger/indy-hipe/issues/38,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/420743630,https://github.com/hyperledger/indy-hipe/pull/38#issuecomment-420743630,TelegramSam,"""The microledger maintains transactions forever"" -- Does it though? I think microledgers can agree to choose a newer message as the new genesis transaction, and it could prune all the history?",2018-09-12 18:05:05,2018-09-12 18:05:05
https://api.github.com/repos/hyperledger/indy-hipe/issues/38,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/420751097,https://github.com/hyperledger/indy-hipe/pull/38#issuecomment-420751097,TelegramSam,"Also, I'm curious if message by message rotation every single time is what provides the forward secrecy, or if 'frequent' rotation is what provides it. Can you elaborate on that?",2018-09-12 18:28:24,2018-09-12 18:28:24
https://api.github.com/repos/hyperledger/indy-hipe/issues/38,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/420810428,https://github.com/hyperledger/indy-hipe/pull/38#issuecomment-420810428,mikelodder7,"We haven't defined when micro ledger transactions should be deleted so until we do I assume all transaction from the dawn of time. I'm hoping we could prune transactions but nevertheless we don't want rotating the keys for the micro ledger with every transaction because that is essentially recreating the Signal protocol but Signal has been vetted and this hasn't. I also believe it wouldn't be as secure as Signal to rotate with every transaction because we are signing a transaction, encrypting it, hoping the previous key still works and hasn't been subject to man-in-the-middle. Signal is resistant to man-in-the-middle and only vulnerable during channel establishment.",2018-09-12 21:53:06,2018-09-12 21:53:06
https://api.github.com/repos/hyperledger/indy-hipe/issues/38,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/420811006,https://github.com/hyperledger/indy-hipe/pull/38#issuecomment-420811006,mikelodder7,"Forward secrecy is provided by using the message key once. If the long term identity keys are compromised then one cannot derive the session keys and decrypt the messages. Even if they discover a single message key, its only helpful for that message and not going **forward**.",2018-09-12 21:55:27,2018-09-12 21:55:27
https://api.github.com/repos/hyperledger/indy-hipe/issues/37,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/414003921,https://github.com/hyperledger/indy-hipe/pull/37#issuecomment-414003921,swcurran,"@peacekeeper - I think you mentioned in the call today that the DID Spec provides mechanism to indicate the purpose of a key.  I'm not clear from going through the spec how that is done.  Would really appreciate your review of this HIPE and what aspects of the DID Spec that we are NOT using to convey information between identities that we should be using.

Thanks!",2018-08-17 22:30:10,2018-08-17 22:30:10
https://api.github.com/repos/hyperledger/indy-hipe/issues/37,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/414033436,https://github.com/hyperledger/indy-hipe/pull/37#issuecomment-414033436,peacekeeper,"I meant the `authentication` objects of a DID document (https://w3c-ccg.github.io/did-spec/#authentication). From various community conversations I remember that generally you should never just ""try all keys in a DID document"", but rather look e.g. for the `authentication` entry (that's the ""purpose""), which then references the key(s) you should use in this case. Also keep in mind that DID documents can contain keys which are not owned by the DID subject.",2018-08-18 05:22:35,2018-08-18 05:22:35
https://api.github.com/repos/hyperledger/indy-hipe/issues/37,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/414057429,https://github.com/hyperledger/indy-hipe/pull/37#issuecomment-414057429,swcurran,"I had thought that the authentication section in a DIDDoc was what the owner used to prove that they were the owner when making an update to the DIDDoc.  I did not think it was for the purpose that we were discussing - eg. for another Identity to use to know how to encrypt a message for a particular device/agent/hub of the DIDDoc's owner.

What I don't understand is that in a DIDDoc as somone reading/using the DIDDoc, I have a set of keys that the owner put into the DIDDoc, but as I understand it, no mechanism to understand what each key is for (other than the authentication one if my assumption above is correct). In the Agent2Agent protocol, we are assuming that one key will be for the ""Routing Agent"", and the all the keys are potential targets for communication. Are there other mechanisms in the DID Spec to add to that knowledge?

Further - there is no association between a service_endpoint and a key. That also seems odd to me. Is that expected - that those are independent?  In the protocol we are planning to use, that doesn't matter because we will use a DID for the only endpoint we need, but that seems odd.",2018-08-18 13:20:10,2018-08-18 13:20:10
https://api.github.com/repos/hyperledger/indy-hipe/issues/37,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/414847377,https://github.com/hyperledger/indy-hipe/pull/37#issuecomment-414847377,kdenhartog,"@swcurran From what I interpret of the DID Spec Section 4.3 rule 3 would allow us to define additional parameters in our method spec or the agent service type spec (I'm not sure where it should be defined yet). One of these could be to define associated keys with a service endpoint.

Additionally, after talking through this a bit with Daniel, I don't think that it's a safe to make any additional assumptions about keys that are in or not in the authentication section outside of whether they are used for authentication or not. 

I think the best way to indicate this right now would be to use the key fragment idea which you proposed in the wire protocol. This also falls in line with how the DID spec defines how the id parameter of the publicKeys section should be used.",2018-08-21 22:53:57,2018-08-21 23:22:25
https://api.github.com/repos/hyperledger/indy-hipe/issues/37,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/414939913,https://github.com/hyperledger/indy-hipe/pull/37#issuecomment-414939913,peacekeeper,"@swcurran sorry I'm a bit late with my response..

The `authentication` section is definitely not only for updating the DID document. In fact, whether or not this is used for authorizing updates/revocation of the DID document is method-specific. Some methods like Veres One use the DID document heavily to describe who can update the DID document, but other methods may have completely different ways to figure out who can update it. In the Veres One case, I believe the DID document can even contain public keys that are not owned by the DID subject.

The `authentication` section or other sections should be used to specify how to interact with the DID subject, including via agent protocols, and an `authentication` object can reference a `publicKey`.

Regarding the association between service endpoint and keys, this has been discussed several times, and I believe it's an open issue whether and how exactly to add this to the DID spec.",2018-08-22 07:33:39,2018-08-22 07:33:39
https://api.github.com/repos/hyperledger/indy-hipe/issues/37,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/415487767,https://github.com/hyperledger/indy-hipe/pull/37#issuecomment-415487767,swcurran,"HIPE Updated based on the comments above, with resolutions outlined in the comments.  Done as a single commit - hope that is OK.  Also addressed the MUST/SHOULD handling.",2018-08-23 16:48:42,2018-08-23 16:48:42
https://api.github.com/repos/hyperledger/indy-hipe/issues/37,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/432330523,https://github.com/hyperledger/indy-hipe/pull/37#issuecomment-432330523,lovesh,@kdenhartog @swcurran There have been additional changes proposed for supporting multiple keys and endpoints for a DID in https://github.com/hyperledger/indy-hipe/pull/48,2018-10-23 16:55:06,2018-10-23 16:55:06
https://api.github.com/repos/hyperledger/indy-hipe/issues/36,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/415505301,https://github.com/hyperledger/indy-hipe/pull/36#issuecomment-415505301,swcurran,"Updated HIPE per comments and checked use of MUST/SHOULD, etc.",2018-08-23 17:37:46,2018-08-23 17:37:46
https://api.github.com/repos/hyperledger/indy-hipe/issues/36,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443372396,https://github.com/hyperledger/indy-hipe/pull/36#issuecomment-443372396,kdenhartog,"My intention for the AMES HIPE #43 is to replace this HIPE. I've included the information I thought would be relevant, but if there's more information that I should include can you let me know? If there's no additional information I should include then I'd propose closing this PR.",2018-11-30 23:37:41,2018-11-30 23:37:41
https://api.github.com/repos/hyperledger/indy-hipe/issues/36,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443404412,https://github.com/hyperledger/indy-hipe/pull/36#issuecomment-443404412,swcurran,Agree that this one should be closed.  It's work is done...rip.,2018-12-01 06:39:23,2018-12-01 06:39:23
https://api.github.com/repos/hyperledger/indy-hipe/issues/35,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/415582333,https://github.com/hyperledger/indy-hipe/pull/35#issuecomment-415582333,swcurran,"Updated the HIPE to address the comments and adjusted as necessary any ""MUST"" and ""SHOULD"" references.",2018-08-23 21:49:20,2018-08-23 21:49:20
https://api.github.com/repos/hyperledger/indy-hipe/issues/35,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/426045662,https://github.com/hyperledger/indy-hipe/pull/35#issuecomment-426045662,kdenhartog,Can we move this to FCP? The JSON structure of this (Forward message) hasn't change any at this point. We can go back and change other stuff once it's accepted so we can start implementing this stuff.,2018-10-01 20:10:20,2018-10-01 20:10:20
https://api.github.com/repos/hyperledger/indy-hipe/issues/32,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/429911295,https://github.com/hyperledger/indy-hipe/pull/32#issuecomment-429911295,TelegramSam,I plan to change this to an update to the Message Types HIPE (PR 19). Don't approve.,2018-10-15 15:56:28,2018-10-15 15:56:28
https://api.github.com/repos/hyperledger/indy-hipe/issues/32,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/434683374,https://github.com/hyperledger/indy-hipe/pull/32#issuecomment-434683374,TelegramSam,will rewrite these as an update to an existing hipe,2018-10-31 13:19:30,2018-10-31 13:19:30
https://api.github.com/repos/hyperledger/indy-hipe/issues/31,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/416738975,https://github.com/hyperledger/indy-hipe/pull/31#issuecomment-416738975,swcurran,"I see the issues behind this HIPE as being a significant roadblock to making progress with A2A.  What do we need to do to break the blockage?  The issues I see:

1. Indy-SDK (at least, perhaps Indy-Node as well) does not support the elements of a DIDDoc - multiple keys, multiple endpoints, multiple authorizations, and endpoints that are URIs.  In theory we can use ATTRIBs for that (no Indy-Node change), but it means a bunch of agreements across Agent implementations vs. one implementation in the Indy-SDK.  Can we get a HIPE that is independent of this HIPE aimed at defining and quickly implementing that?

This is the biggest roadblock to building Agents that follow the A2A HIPEs we are defining.  Is there a way to proceed without this being in place?

2. I think this document is too loose for a HIPE.  Conceptually it makes sense, but it really needs to be tightened from speculation to firm design/specification. Do we leave this HIPE like this as an approach, but then add additional HIPEs that address the details - concepts like:

* Agent permissions (indirectly important for this but a much bigger topic),
* responsibility (is this an Indy-SDK or Agent implementation?),
* Agent Messages
* Do we need features like Before/After provability now?
* _(I'm sure there are others...)_

I do think there are potentially a number of HIPEs in here that can be implemented independently.

3. I think consideration should be given to DID Method interoperability, so there is a chance that we can use microledgers with other DID Methods. Alternatively, we could, in addition to supporting events as documented here, also support getting/putting entire current state DIDDocs.

4. It seems to me that the same Agent/Indy-SDK methods should be used for updating DIDDocs on the public ledger.  Is that planned?

5. Should a microledger implementation be at the Indy-SDK level or at the Agent level?

6. Could/should a DIDDoc be implemented (perhaps just initially) using a simpler model - a versioned/timestamped document sent from the owner to the replicas?

Not sure how to get this further, but it really feels to me like a stumbling block for Agent building progress.  I'm definitely open to ideas on how we can proceed on A2A with minimal progress on this.

Thanks!",2018-08-28 21:01:07,2018-08-28 21:01:07
https://api.github.com/repos/hyperledger/indy-hipe/issues/31,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/432420336,https://github.com/hyperledger/indy-hipe/pull/31#issuecomment-432420336,lovesh,@swcurran HIPE for changes in DID doc on ledger https://github.com/hyperledger/indy-hipe/pull/48,2018-10-23 21:08:19,2018-10-23 21:08:19
https://api.github.com/repos/hyperledger/indy-hipe/issues/30,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410399907,https://github.com/hyperledger/indy-hipe/pull/30#issuecomment-410399907,dbluhm,[Rendered Text](https://github.com/dbluhm/indy-hipe/blob/message-threading/text/message-threading/README.md),2018-08-03 23:21:47,2018-08-03 23:21:47
https://api.github.com/repos/hyperledger/indy-hipe/issues/30,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410712721,https://github.com/hyperledger/indy-hipe/pull/30#issuecomment-410712721,swcurran,"Looks good!

My first thought in reading this were that ""mid"" messages were correlated - request/response - but that is not right?  I could send multiple messages (mid 1, 2 and 3) without the other side responding, right?

Should there be any error handling?  For example, I get a message 3 from the other side without getting the message 2?  I'm guessing that should be at the higher level, but perhaps there should be an explicit thread-family message (vs. a decorator) that says ""Hey, I didn't get message 2"".

There should be some cleanup (I think) of the JSON - the @thread aligned with the @type and the fields indented and aligned with each other?",2018-08-06 13:44:29,2018-08-06 13:44:29
https://api.github.com/repos/hyperledger/indy-hipe/issues/30,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410827786,https://github.com/hyperledger/indy-hipe/pull/30#issuecomment-410827786,dbluhm,"@swcurran Thanks for bringing up the indentation issue.

Yes, I believe it is intended that the `mid`s of both sides are not dependent on each other. So you could have several messages sent from one side (1, 2, 3) without response.

As far as error handling goes, I think we would want to leave that to higher levels. For instance, there might be some contexts where a single dropped message isn't significant enough to warrant emitting an error or can be safely ignored. It seems like the message family will have to define whether it should emit an error on a dropped message. Doing it that way also allows the message family to dictate the type and attributes of that message which would probably be more helpful than a generic message thread error.

That being said, I'm glad to hear other peoples thoughts on error handling.",2018-08-06 19:36:34,2018-08-06 19:36:34
https://api.github.com/repos/hyperledger/indy-hipe/issues/30,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/414496424,https://github.com/hyperledger/indy-hipe/pull/30#issuecomment-414496424,dhh1128,"This is related to @swcurran 's question about error handling. What happens if A expects B to say something at a certain point, and B is silent? A begins to wonder what B is up to, and if B needs a nudge. A wants to send a messaging saying (effectively), ""Hey, here's how far we got in our interaction, as far as I can tell. Did you say something while you had your mute button on? If so, can you please resend beginning after your message id X""? Now, this ""yoohoo, I'm waiting; please (re)send"" message is probably not something we need to document in this HIPE--but when B receives such a message, how are the resent messages numbered? If messages 4-6 had been sent before, but never received, and B resends, are they still numbered 4-6? Or are they numbered 7-9, but marked as replacements for messages 4-6? I think maybe the latter, but that means there's another possible field in @thread. Maybe ""resend-of-mid""? Or maybe we have a field called ""send-attempt"" and reuse the message ids, but mark a resent as ""send-attempt: 2"" or similar?

This makes me wonder if we need the ability to prune/orphan part of a conversation (e.g., message 7-8 occur based on certain assumptions about the other party's state; then the other party's state changes, and we want to abandon what we said in messages 7-8. Imagine a negotiation where we want to abandon an earlier offer once we know more about what the other party values; we don't want them, late in the game, to go back to an earlier offer and suddenly accept it when we've evolved way past it). Not sure how this relates to threading, but I've got a vague worry that it creates message trees instead of threads...",2018-08-20 23:26:52,2018-08-20 23:27:24
https://api.github.com/repos/hyperledger/indy-hipe/issues/30,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/414496673,https://github.com/hyperledger/indy-hipe/pull/30#issuecomment-414496673,dhh1128,"Regarding my last comment, this may be a place to do some research about message threading in chat protocols...",2018-08-20 23:28:12,2018-08-20 23:28:12
https://api.github.com/repos/hyperledger/indy-hipe/issues/30,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/415995870,https://github.com/hyperledger/indy-hipe/pull/30#issuecomment-415995870,swcurran,"I like the idea of including the optional ""send-attempt"" (if not sent assume ""1"").  I think that could be used as well for the ""are you on mute"" message. A participant that has not heard from the other conversant in a while doesn't send an error, but rather resends their last message (same mid) with the ""send-attempt"" sent to one higher.

I'd say we leave the vague worry alone for now and not worry about it until we have some concrete examples of what we need.",2018-08-25 20:53:14,2018-08-25 20:53:14
https://api.github.com/repos/hyperledger/indy-hipe/issues/30,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445101410,https://github.com/hyperledger/indy-hipe/pull/30#issuecomment-445101410,dhh1128,"A late-breaking comment: because `seqnum` is 0-based, would we be better off calling it `idx`?",2018-12-07 02:29:00,2018-12-07 02:29:00
https://api.github.com/repos/hyperledger/indy-hipe/issues/30,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445107594,https://github.com/hyperledger/indy-hipe/pull/30#issuecomment-445107594,dhh1128,"I just realized that, despite having worked on this HIPE myself and having thought very carefully about it, I was using the `seqnum` construct wrong in another HIPE I'm working on. Aargh. It is an easy mental error, because it's SO natural to assume that seqnum is not sender-specific but rather a sequence number with the thread as a whole. Because of this, I am feeling more opinionated about renaming `seqnum`. As I suggested in my previous comment, something with ""idx"" in it would fit with the zero-based semantics. But now I also want the name to clarify its sender-specific nature. So how about `myidx`?",2018-12-07 03:05:27,2018-12-07 03:05:53
https://api.github.com/repos/hyperledger/indy-hipe/issues/30,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/447574078,https://github.com/hyperledger/indy-hipe/pull/30#issuecomment-447574078,TelegramSam,"I'm not sure `idx` is any less confusing (in different ways, possibly) than `seqnum`. Not opposed to a rename, but I don't think we have it yet.",2018-12-15 14:54:13,2018-12-15 14:54:13
https://api.github.com/repos/hyperledger/indy-hipe/issues/30,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/447912828,https://github.com/hyperledger/indy-hipe/pull/30#issuecomment-447912828,TelegramSam,@dhh1128 What about `senderseqnum` as a replacement for `seqnum`? Or perhaps `myseqnum`? Moving to `myidx` feels like we are trading one confusion for another.,2018-12-17 16:43:56,2018-12-17 16:43:56
https://api.github.com/repos/hyperledger/indy-hipe/issues/30,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/447969809,https://github.com/hyperledger/indy-hipe/pull/30#issuecomment-447969809,swcurran,"> @dhh1128 What about `senderseqnum` as a replacement for `seqnum`? Or perhaps `myseqnum`? Moving to `myidx` feels like we are trading one confusion for another.

I like ""myseqnum"". Makes it pretty obvious - more so than the other suggestions.  ""senderseqnum"" would also be fine.  I don't get ""idx"" at all (index?  if so, use ""index"" :-) ), and even so, it would need the ""my"" or ""sender"" prefix to be useful.",2018-12-17 19:33:10,2018-12-17 19:33:10
https://api.github.com/repos/hyperledger/indy-hipe/issues/30,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/449164390,https://github.com/hyperledger/indy-hipe/pull/30#issuecomment-449164390,dhh1128,"I like ""myseqnum"" moderately well. I like ""myseqindex"" or even just ""myindex"" better, because they *also* are better for my start-counting-at-zero concern. But at this point, any of the field names that have ""my"" would pass my part for merging the HIPE. So @dbluhm, I say pick one and let's get it merged.",2018-12-20 23:04:24,2018-12-20 23:04:24
https://api.github.com/repos/hyperledger/indy-hipe/issues/30,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/450109149,https://github.com/hyperledger/indy-hipe/pull/30#issuecomment-450109149,dhh1128,"@dbluhm and @swcurran and @TelegramSam : I have raised a PR against Daniel's fork that, if accepted, would update this HIPE proposal as follows:

1. Change `seqnum` to `myindex` (this turned out to involve more lines of changes than I expected)
2. Remove the idea of `lrec` that can have 2 different forms (one singular, one plural). Instead, standardize on plural `lrecs`. I did this because I think it will be better for JSON libraries to convert JSON to native object form in a consistent way.

My PR is here: https://github.com/dbluhm/indy-hipe/pull/4",2018-12-27 09:05:22,2018-12-27 09:09:07
https://api.github.com/repos/hyperledger/indy-hipe/issues/30,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/451982367,https://github.com/hyperledger/indy-hipe/pull/30#issuecomment-451982367,TelegramSam,"I love lrecs being standardized.

I'm not quite settled on myindex. I didn't have a problem with seqnum, but as long as we are looking to change it, I wouldn't mind there being better naming similarity between the seqnum/myindex and lrecs, the former being the message numbers, the latter being the last ones seen.",2019-01-07 15:58:00,2019-01-07 15:58:00
https://api.github.com/repos/hyperledger/indy-hipe/issues/29,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410342506,https://github.com/hyperledger/indy-hipe/pull/29#issuecomment-410342506,dbluhm,[Rendered Text](https://github.com/keichiri/indy-hipe/blob/libvcx_integration/text/libvcx_integration/README.md),2018-08-03 18:44:14,2018-08-03 18:44:14
https://api.github.com/repos/hyperledger/indy-hipe/issues/29,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410343621,https://github.com/hyperledger/indy-hipe/pull/29#issuecomment-410343621,dbluhm,"I'm not an Indy-SDK maintainer,  but, as a consumer and concerned party, it would be helpful to have the HIPE explaining what libVCX is and why it is being merged with Indy-SDK before being asked to make comment on the integration process.",2018-08-03 18:48:38,2018-08-03 18:48:38
https://api.github.com/repos/hyperledger/indy-hipe/issues/29,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410343871,https://github.com/hyperledger/indy-hipe/pull/29#issuecomment-410343871,esplinr,The code is available in the repository mentioned in the HIPE. We recorded a demo on LibVCX in the last Indy Working Group call. We are working on providing additional documentation.,2018-08-03 18:49:40,2018-08-03 18:49:40
https://api.github.com/repos/hyperledger/indy-hipe/issues/29,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410377038,https://github.com/hyperledger/indy-hipe/pull/29#issuecomment-410377038,burdettadam,"This is a great HIPE and I am excited to use libvcx. 
I have made a [pull request](https://github.com/keichiri/indy-hipe/pull/2) to this HIPE with an added alternative. 
- libvcx could live in a directory with a reference agent inside indy-agent repository. This would provide a working example of how libvcx can be used and allow public scrutiny and drive active community improvement of the indy-sdk. This would also support indy communities agreement of test-driven protocol development and remove any protocol bias libvcx may present by being inside indy-sdk.

Moving libvcx into indy-sdk presents a bias to accept libvcx processes for agent interoperability protocol. I feel this counteracts the communities decision to use indy-agent test suite to establish interoperability protocol and should be addressed before placing libvcx inside indy-sdk. The proposed alternative would help establish a pipeline for opensource contributors to add to indy-sdk and promote indy community.  ",2018-08-03 21:09:02,2018-08-03 21:09:02
https://api.github.com/repos/hyperledger/indy-hipe/issues/29,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410728248,https://github.com/hyperledger/indy-hipe/pull/29#issuecomment-410728248,esplinr,"Thank you @burdettadam for raising an interesting alternative approach. Here are my thoughts for discussion:
* We recognize that the claims exchange protocol is not finalized and will evolve with community feedback. We feel like the best way to progress that effort is to add libvcx to Indy SDK so that there is a tangible implementation that can be improved with community contributions.
* Indy SDK should be the one-stop-shop for everything developers need to work within the Indy ecosystem. We should be pushing into Indy SDK everything necessary for standard communication between different agents where it will be recognized as a mandatory apart of every implementation in our ecosystem. In my opinion this includes some of the agent standardization work that is currently part of the Indy Agent discussion. The Indy Agent repository should contain implementations for specific agents.
* Evernym has a team immediately available to assist with this effort. We want to move quickly so that this team can be productive or they will be reassigned.",2018-08-06 14:31:03,2018-08-06 14:31:03
https://api.github.com/repos/hyperledger/indy-hipe/issues/29,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410799620,https://github.com/hyperledger/indy-hipe/pull/29#issuecomment-410799620,donqui,@keichiri I would remove the Tutorial section.,2018-08-06 18:08:42,2018-08-06 18:08:42
https://api.github.com/repos/hyperledger/indy-hipe/issues/29,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/412528240,https://github.com/hyperledger/indy-hipe/pull/29#issuecomment-412528240,pimotte,"Let me preface my comments with the remark that I am looking forward to libVCX, and would drop the [layer we've been developing](https://github.com/Quintor/quindy) in a heartbeat for a community version with wrappers for all languages.

I would like to echo the concerns regarding the order of operations here. As I gathered from the demo in the WG call, there is not really a way to use libVCX without the Evernym agency. I would see this as a blocker for merging into indy-sdk, as it would mean there is a directory full of code causing questions in #indy-sdk, with the answer being ""you can't actually use this, because you don't have an agency"". In addition, the explanation ""what is libVCX"" should also be a condition of merging the code into indy-sdk.

On the integration itself, it seems like having it as a subfolder in indy-sdk is just partial integration. Was any consideration given to merging it into the libindy code base itself? (say, in libindy/src/vcx)?


",2018-08-13 14:00:55,2018-08-13 14:00:55
https://api.github.com/repos/hyperledger/indy-hipe/issues/29,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/413464002,https://github.com/hyperledger/indy-hipe/pull/29#issuecomment-413464002,vimmerru,"@dkulic Could you add one additional option to alternatives section. We can keep indy-sdk repo only as starting point that will contain documentation, tutorials and links to repos with components. So there can be the following repos structure:

- indy-sdk // docs, tutorials, links, tickets and etc...
- libindy // libindy and tier 1 wrappers
- libvcx // libvcx and wrappers
- indy-cli // indy-cli
- libnullpay

In this case we can use SemVer based binary dependencies between libindy and vcx and mostly independent development process. Also it will cause simplification of CD pipelines and reduce indy-sdk CI time form 2 hours to something like 30 min.",2018-08-16 08:16:07,2018-08-16 08:16:07
https://api.github.com/repos/hyperledger/indy-hipe/issues/29,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/414082943,https://github.com/hyperledger/indy-hipe/pull/29#issuecomment-414082943,esplinr,"@pimotte, thank you for engaging with this Pull Request.

In the last Indy Maintainers meeting we discussed these types of concerns. We concluded as a group that it was better to merge the library to increase visibility and then work in public to improve it before releasing it. We agreed that this course of action is the shortest path to help people to understand the concepts in the library and encourage others to join in the effort of improving it.

We also discussed the trade-offs between merging it into LibIndy and keeping it as a separate library. We concluded that keeping it as a separate library provides a separation of concerns which will reduce learning needed and reduce the time developers spend waiting for builds. @dkulic : we should add this rationale to the HIPE.

We included a draft overview of VCX here:
https://github.com/evernym/sdk/blob/master/vcx/docs/vcx_arch.md)

And will continue working on the documentation (IS-850), as well as remove dependency on the Evernym Agency (IS-871).

@burdettadam who raised the above concerns was in the meeting and agreed with the decision.",2018-08-18 20:01:28,2018-08-18 20:01:28
https://api.github.com/repos/hyperledger/indy-hipe/issues/26,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410317978,https://github.com/hyperledger/indy-hipe/pull/26#issuecomment-410317978,burdettadam,[ rendered repo_hipe ](https://github.com/devin-fisher/indy-hipe/blob/repo_hipe/text/indy-git-repos/README.md),2018-08-03 17:11:08,2018-08-03 17:11:08
https://api.github.com/repos/hyperledger/indy-hipe/issues/26,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410326148,https://github.com/hyperledger/indy-hipe/pull/26#issuecomment-410326148,burdettadam,"This is a great HIPE and well needed. 
I would like to propose:
 - a different [description](https://github.com/burdettadam/indy-hipe/tree/repo_hipe/text/indy-git-repos#description-2), in the provided link, for indy-sdk. I particularly thought ""[and other artifacts](https://github.com/devin-fisher/indy-hipe/blob/repo_hipe/text/indy-git-repos/README.md#description-2)"" in indy-sdk description was ambiguous and not well fitting. 
- a different [description](https://github.com/burdettadam/indy-hipe/tree/repo_hipe/text/indy-git-repos#description-5) and [maintenance](https://github.com/burdettadam/indy-hipe/tree/repo_hipe/text/indy-git-repos#maintenance-5), in the provided links, for indy-agent. I only added information about the test suite. 
-  an indy-doc [entry](https://github.com/burdettadam/indy-hipe/tree/repo_hipe/text/indy-git-repos#indy-doc) to support [this](https://github.com/hyperledger/indy-hipe/pull/24) HIPE.

All of my suggestion can be found in my [pull request](https://github.com/devin-fisher/indy-hipe/pull/1) to this HIPE.",2018-08-03 17:42:03,2018-08-03 17:42:03
https://api.github.com/repos/hyperledger/indy-hipe/issues/26,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410342702,https://github.com/hyperledger/indy-hipe/pull/26#issuecomment-410342702,devin-fisher,@burdettadam Your PR is out of sync. Can you fix the merge issues in you PR so I can eval and merge it?,2018-08-03 18:45:02,2018-08-03 18:45:02
https://api.github.com/repos/hyperledger/indy-hipe/issues/26,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410354869,https://github.com/hyperledger/indy-hipe/pull/26#issuecomment-410354869,burdettadam,"@devin-fisher, Done. ",2018-08-03 19:35:21,2018-08-03 19:35:21
https://api.github.com/repos/hyperledger/indy-hipe/issues/26,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410756317,https://github.com/hyperledger/indy-hipe/pull/26#issuecomment-410756317,nage,All repos should have MAINTAINTERS.md files that are referenced instead of listing them inline (per the maintainers conversation).,2018-08-06 15:52:52,2018-08-06 15:52:52
https://api.github.com/repos/hyperledger/indy-hipe/issues/26,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/411170816,https://github.com/hyperledger/indy-hipe/pull/26#issuecomment-411170816,donqui,"I've made some changes to the HIPE in the following PR: https://github.com/devin-fisher/indy-hipe/pull/3.

I changed some of the typos and repo descriptions along with changing the structure of the document to make it more readable (for me).

This is the summary of the changes:
- General structure of the HIPE document changed
- HISTORY sections removed
- Maintainance made into a separate section to avoid repetition
- Descriptions of certain repos changed
- Typos fixed

Take a look and tell me what you think
",2018-08-07 19:18:09,2018-08-07 19:19:55
https://api.github.com/repos/hyperledger/indy-hipe/issues/26,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/411181050,https://github.com/hyperledger/indy-hipe/pull/26#issuecomment-411181050,donqui,I've made some additional modifications as per @devin-fisher comments.,2018-08-07 19:54:43,2018-08-07 19:54:43
https://api.github.com/repos/hyperledger/indy-hipe/issues/25,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410755590,https://github.com/hyperledger/indy-hipe/pull/25#issuecomment-410755590,swcurran,Typo in the first line - please correct.,2018-08-06 15:50:37,2018-08-06 15:50:50
https://api.github.com/repos/hyperledger/indy-hipe/issues/25,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/414350944,https://github.com/hyperledger/indy-hipe/pull/25#issuecomment-414350944,dhh1128,"Merging. This is uncontroversial and is repo metadata, not a HIPE.",2018-08-20 15:08:43,2018-08-20 15:08:43
https://api.github.com/repos/hyperledger/indy-hipe/issues/24,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410754072,https://github.com/hyperledger/indy-hipe/pull/24#issuecomment-410754072,nage,This HIPE doesn't talk about where each doc lives.  We would rather not centralize this content into one github repo.  Please explain how the content is pulled into the github.io page.,2018-08-06 15:46:09,2018-08-06 15:46:09
https://api.github.com/repos/hyperledger/indy-hipe/issues/24,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410756285,https://github.com/hyperledger/indy-hipe/pull/24#issuecomment-410756285,dhh1128,I would like this HIPE to talk a bit about release formalities: how do docs get updated in conjunction with a formal release of a particular repo? How are they labeled? How is the version of the docs discovered and matched to the version of the code? Etc?,2018-08-06 15:52:45,2018-08-06 15:52:45
https://api.github.com/repos/hyperledger/indy-hipe/issues/24,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/411105699,https://github.com/hyperledger/indy-hipe/pull/24#issuecomment-411105699,mjmckean,"Thank you for the feedback!

@nage after some discussion, we revised the HIPE to focus on a Read The Docs hosting. The process of pulling the content is now described more clearly in the [tutorial](https://github.com/mjmckean/indy-hipe/tree/master/text/indy-docs-repo#tutorial). 

A good topic for discussion is whether or not to have this content centralized in one repo. We did briefly elaborate on some [drawbacks](https://github.com/mjmckean/indy-hipe/tree/master/text/indy-docs-repo#drawbacks) for both situations; however, this topic may still have much to be discussed.

@dhh1128 we added a [versioning section](https://github.com/mjmckean/indy-hipe/tree/master/text/indy-docs-repo#versioning) to address your questions. Open to any and all discussion.",2018-08-07 15:50:51,2018-08-07 15:50:51
https://api.github.com/repos/hyperledger/indy-hipe/issues/24,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/411854697,https://github.com/hyperledger/indy-hipe/pull/24#issuecomment-411854697,TechWritingWhiz,"I think moving to the Read the Docs is a great solution. Hyperledger Fabric does it as mentioned. There are drawbacks. However, the logic seems binary. If Hyperledger Indy wants to have the reputation of easy onboarding, less confusion about the docs and known for having things up-to-date, then moving to Read the Docs will need to be done. 

A previous solution proposed was to pull the ""onboarding"" type documentation into Read the Docs and to then leave the ""grittier"" developer docs within the doc folder of each repo it pertains to.

Regardless of which solution is chosen, it seems that Read the Docs is the best solution to move forward with and efforts should be made toward that end. It may cause pain initially, but once it's done, it's done, outside of maintenance of course. 

If the end goal is to reach a place where Indy documentation is as consistent as for example, Fabric's (and in keeping in continuance with the Hyperledger brand), then moving to Read the Docs must be done.

**Recommendations for scaling the work:**

- 1 maintainer = moving ""onboarding"" docs to Read the Docs first
- 2 maintainers = moving Release Notes along with ""onboarding"" docs
- 3 maintainers = the above + cleaning up the docs folder in each repo along with adding a reference link to the new Read the Docs location at each README in all the repos.
- 4 maintainers = all of the above plus coordinating the move of each repo specific doc folder to Read the Docs if that is what is decided to do.

",2018-08-09 18:34:14,2018-08-09 18:34:14
https://api.github.com/repos/hyperledger/indy-hipe/issues/24,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/422454975,https://github.com/hyperledger/indy-hipe/pull/24#issuecomment-422454975,burdettadam,status update: mjmckean and I are addressing concerns from the community and working on a demonstration for this hipe.,2018-09-18 16:11:12,2018-09-18 16:11:12
https://api.github.com/repos/hyperledger/indy-hipe/issues/24,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/445904556,https://github.com/hyperledger/indy-hipe/pull/24#issuecomment-445904556,michaeldboyd,This PR can be closed in favor of https://github.com/hyperledger/indy-hipe/pull/63,2018-12-10 17:40:52,2018-12-10 17:40:52
https://api.github.com/repos/hyperledger/indy-hipe/issues/24,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/448292865,https://github.com/hyperledger/indy-hipe/pull/24#issuecomment-448292865,TelegramSam,Closed in favor of already merged #63 ,2018-12-18 17:00:02,2018-12-18 17:00:02
https://api.github.com/repos/hyperledger/indy-hipe/issues/23,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/407873802,https://github.com/hyperledger/indy-hipe/pull/23#issuecomment-407873802,burdettadam,[rendered](https://github.com/burdettadam/indy-hipe/blob/maintainer-procedures/text/maintainer-procedures/README.md),2018-07-25 19:49:30,2018-07-25 19:49:30
https://api.github.com/repos/hyperledger/indy-hipe/issues/23,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/409744682,https://github.com/hyperledger/indy-hipe/pull/23#issuecomment-409744682,dhh1128,I endorse this PR and don't have any changes to request. I did send some materials to Adam that might be interesting as links to prior art or similar--but that's minor details. I vote that we put this HIPE into the 2-week FCP.,2018-08-01 22:24:18,2018-08-01 22:24:18
https://api.github.com/repos/hyperledger/indy-hipe/issues/23,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410876577,https://github.com/hyperledger/indy-hipe/pull/23#issuecomment-410876577,burdettadam,I just updated this HIPE with suggestions from maintainers meeting. ,2018-08-06 22:46:18,2018-08-06 22:46:18
https://api.github.com/repos/hyperledger/indy-hipe/issues/22,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/404809906,https://github.com/hyperledger/indy-hipe/pull/22#issuecomment-404809906,dhh1128,I'm just noting that I read the HIPE and feel good about it.,2018-07-13 11:46:00,2018-07-13 11:46:00
https://api.github.com/repos/hyperledger/indy-hipe/issues/22,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/405639240,https://github.com/hyperledger/indy-hipe/pull/22#issuecomment-405639240,dbluhm,I also think this is a great addition to our documents here.,2018-07-17 16:12:45,2018-07-17 16:12:45
https://api.github.com/repos/hyperledger/indy-hipe/issues/22,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/406342046,https://github.com/hyperledger/indy-hipe/pull/22#issuecomment-406342046,kdenhartog,Keys used in step 4 for we're reversed. I just made a commit that switches them around.,2018-07-19 16:45:45,2018-07-19 16:45:45
https://api.github.com/repos/hyperledger/indy-hipe/issues/22,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410734752,https://github.com/hyperledger/indy-hipe/pull/22#issuecomment-410734752,swcurran,Ah...nice!  Just saw this - glad to see if covered!,2018-08-06 14:50:17,2018-08-06 14:50:17
https://api.github.com/repos/hyperledger/indy-hipe/issues/22,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/422089133,https://github.com/hyperledger/indy-hipe/pull/22#issuecomment-422089133,dhh1128,"This PR was approved for merging in today's maintainers call. However, it mingles authcrypt/anoncrypt description with some modifications of another HIPE about wire messages. That HIPE is not ready to merge yet.

To get the core ideas merged from this PR, I created a new PR that includes just Kyle's writing, not the back history on the wire protocol. That is PR #42, which I just merged. I am therefore closing this PR.",2018-09-17 16:49:27,2018-09-17 16:49:27
https://api.github.com/repos/hyperledger/indy-hipe/issues/21,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/404449663,https://github.com/hyperledger/indy-hipe/pull/21#issuecomment-404449663,dhh1128,"I left detailed comments on Rocket.Chat, here: https://chat.hyperledger.org/channel/indy-agent?msg=WdSes8rDAtKDbmD9G. I am copying them here for ease of reference.

I don't buy the strong form of the Sender Anonymity or Receiver Anonymity requirement. I'm not sure how these got entrenched in our thinking, because I agree with you that the community seems to have begun articulating these as fundamental--but I think we've gone a bit too far. If you think about sovereign nations in the non-digital world, and about heads of state communicating with one another, it is certainly true that one head of state need not know all the people and processes used by another head of state when dropping off a message at the other kingdom's borders. But I think *some* knowledge may be reasonable (e.g., ""I can give this to the postmaster and ask it to be couriered directly to the palace without passing through the hands of the ambassador. It is for the king's eyes only."" Such a statement implies a little knowledge about the internals of the other monarch's kingdom). Similarly, I think it is reasonable for one sovereign identity owner to know a little bit about the internals of another sovereign domain--enough to know which keys are considered closely held by the identity owner (at the edge) versus loosely held (in the cloud). The microledger spec further imagines that identity owners would tell one another what permissions are ascribed to each key that they intend to use in the relationship, so they can cooperate to enforce access. If Monarch A gets a letter purporting to represent the wishes of Monarch B, but it is only signed by Monarch B's postmaster, Monarch A needs to know whether B wishes the postmaster to be taken seriously....

The ""Transport DID (TDID)"" section lost me a bit. Are you intending to say that there is a DID and a key at which mail will be delivered for a sovereign domain, and that this DID+key is conceptually distinct from the other keys associated with the domain? In other words, that you may deliver to an endpoint which is serviced by a DID and key that are not in and of themselves ""members"" of the sovereign domain? (If so, then I am feeling fine about it.)

Why are we introducing DIDs instead of the lower level construct of keys as the operational input needed for wire messages? This would require every agent within a domain to have a DID. Instead, can we say that wire messages are sent to and from *keys*, not assuming that DIDs are necessarily involved? In a similar vein, do we always have to provide a DID as the target for a ""forward"" message, or could we just provide a key? (I have been assuming that agents within a sovereign domain have a locally unique name, but not a DID. There are some deep reasons for this that we could discuss in a separate conversation.)

We have to assume that message responses are asynchronous; to do otherwise eliminates many transport protocols. However, we could define a ""synchronous mode"" that would be supported by transports that allow it, whereby the deliverer of the message awaits a response and transmits it back immediately (e.g., without closing the port first). This would be great for http and would not be hard to build, probably.

""The choice of whether to use anoncrypt or authcrypt is based on the state of the known DIDs"" -- I think this is only partly true. Even if it is possible to authcrypt, it must be a choice to anoncrypt instead. This allows Alice to send Bob anonymous love letters even if Alice and Bob know each other from work. (Whether Bob's agents are programmed to accept anonymous letters is another question.)

Your paragraph that begins ""ASIDE: this is where"": There is only one endpoint for a pairwise DID--the endpoint where mail can be delivered. I *think* that's what you're calling a TDID (though I don't understand why ""DID"" is in its name or its definition; I was thinking of it as an endpoint with a key, not an endpoint with a DID...). Anyway, It appears that you're imagining another DID and another endpoint here, which raised my eyebrows. So this is something I want to learn more about.

Application Level Error Handling: I think it may be desirable to provide a ""reply-to"" property with a message, that would allow errors to be reported. The problem is that, done wrong, this is a way to spam an unsuspecting third party with error messages. So we need to think about that. How do we detect transmission errors in physical post? We usually don't, unless we use a ""return receipt requested"" feature of some kind...",2018-07-12 09:25:57,2018-07-13 02:18:50
https://api.github.com/repos/hyperledger/indy-hipe/issues/21,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/404627725,https://github.com/hyperledger/indy-hipe/pull/21#issuecomment-404627725,ryanwest6,"Overall this looks like a great start, and I agree with most of what has been said in the document. Some initial comments:

The TDID section lost me somewhat as well. Is this TDID only to be used for inter-agency communication? How is it different from an endpoint, with its corresponding verkey and public DID?

The DID vs key issue that @dhh1128 noted seems to be something worth discussing more, since we will be dealing with multiple edge/cloud agents for each user. I don't know a lot about that but I'd love to hear more about the reasoning behind it.

Same with error handling, a discussion here of possible solutions would be good. We could potentially have the ""reply-to"" property as an optional attribute but I don't think it should be required. It may be necessary to assume that there was an error unless some sort of acknowledgement was received.
",2018-07-12 19:41:18,2018-07-17 16:17:22
https://api.github.com/repos/hyperledger/indy-hipe/issues/21,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/404659607,https://github.com/hyperledger/indy-hipe/pull/21#issuecomment-404659607,swcurran,"Updated the document to add some clarifications - particularly around the layering motivation of this HIPE and the why of the concept of TDIDs.  I left in this concept of using DIDs for ""TDIDs"" instead of making them simply endpoints/keys and am glad to have the discussion of the pros and cons.",2018-07-12 21:40:43,2018-07-12 21:41:05
https://api.github.com/repos/hyperledger/indy-hipe/issues/21,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/405637560,https://github.com/hyperledger/indy-hipe/pull/21#issuecomment-405637560,dbluhm,[Rendered Text](https://github.com/swcurran/indy-hipe/blob/master/text/transport-layer-messaging/README.md),2018-07-17 16:07:21,2018-07-17 16:07:21
https://api.github.com/repos/hyperledger/indy-hipe/issues/21,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/405701186,https://github.com/hyperledger/indy-hipe/pull/21#issuecomment-405701186,kdenhartog,"I'm hesitant to the idea that we're calling domain design implementor's specific. I think this violates almost all [7 of the Privacy by Design principles](https://www.ryerson.ca/pbdce/certification/seven-foundational-principles-of-privacy-by-design/) and conflicts with [principles 2 and 10 of the Self-Sovereign Identity](https://github.com/ChristopherA/self-sovereign-identity/blob/master/self-sovereign-identity-principles.md). More specifically, I am also going to strongly challenge the notion that encapsulation is an absolute must for this protocol, but privacy is not because I don't think any of us believe it is. Am I correct that it is our jobs as protocol designers to account for both of these or have my principles completely diverged from the rest of the groups? As a secondary reference to some of the arguments that have been made against privacy, I'd strongly encourage people to go take a look at the self sovereign privacy by design document [here](https://github.com/sovrin-foundation/protocol/blob/master/self_sovereign_privacy_by_design_v1.md). If there are principles in this document which we don't agree with, I think we need to address those first, so that we can design with similar principles in mind.",2018-07-17 19:32:40,2018-07-17 20:54:15
https://api.github.com/repos/hyperledger/indy-hipe/issues/21,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/405740744,https://github.com/hyperledger/indy-hipe/pull/21#issuecomment-405740744,swcurran,"Kyle - I don't know what you are reading in the HIPE that is in conflict with any of Privacy by Design or SSI Principles 2 and 10. Clearly I have not been able to convey what I was trying to achieve. This is where doing this via PR is ineffective.  We need a white board.  I've thought about this a lot and it might not be the right solution, but I know it doesn't violate those principles.",2018-07-17 21:54:02,2018-07-17 21:54:02
https://api.github.com/repos/hyperledger/indy-hipe/issues/21,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/405796418,https://github.com/hyperledger/indy-hipe/pull/21#issuecomment-405796418,swcurran,"Kyle, I'm baffled with how to respond to your comments about privacy/SSI Principles.  I don't think we want to start every document with a treatise on each aspect that makes SSI a good model.

I recommend adding the text you feel is needed in the motivation and then, (and I think, more importantly) identify specific changes to the HIPE that you feel are weak in privacy.  

My feeling is that this HIPE makes no changes to privacy or SSI principles - it simply tries to codify how different parties can use of the primitives available to independently build products. I'd even go so far as to say the proposal specifically tries to limit information exposed about an identity to only what another identity needs to know to collaborate on a shared transaction.",2018-07-18 03:20:29,2018-07-18 03:20:29
https://api.github.com/repos/hyperledger/indy-hipe/issues/21,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/405977090,https://github.com/hyperledger/indy-hipe/pull/21#issuecomment-405977090,dhh1128,"@kdenhartog , I think all of us want the strong privacy guarantees, and we all think it's good to be concerned about that issue and to watch for places where we lose something important. But I don't see privacy gaps in the HIPE right now. Do you see anything specific? If so, the best way to improve the HIPE would be to follow @swcurran's suggestion to propose some extra verbiage. Maybe we should work on resolving this concern to everybody's satisfaction at the upcoming summit at the end of July?",2018-07-18 15:41:58,2018-07-18 15:47:40
https://api.github.com/repos/hyperledger/indy-hipe/issues/21,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/406344576,https://github.com/hyperledger/indy-hipe/pull/21#issuecomment-406344576,kdenhartog,"After discussion on today's call I feel much more comfortable with this proposal. I do think there's things that we can do at a technical level (in the application layer) within the protocol that can help prevent cloud agent impersonation (when a cloud agent hasn't been authorized to perform some action). @nage succinctly covered this issue at the end, so I feel satisfied with the direction we're heading with this and no long feel like we're enabling privacy violations. Along with this, I think that what @mhailstone said about adding recommendations in the description would be helpful. I'll submit some examples of them to get us started.",2018-07-19 16:54:28,2018-07-19 16:54:28
https://api.github.com/repos/hyperledger/indy-hipe/issues/21,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/406389566,https://github.com/hyperledger/indy-hipe/pull/21#issuecomment-406389566,dhh1128,@swcurran I have proposed some changes to your HIPE by raising a PR against your own fork. See https://github.com/swcurran/indy-hipe/pull/1,2018-07-19 19:34:17,2018-07-19 19:34:17
https://api.github.com/repos/hyperledger/indy-hipe/issues/21,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410830772,https://github.com/hyperledger/indy-hipe/pull/21#issuecomment-410830772,kdenhartog,"Thanks for adding the JOSE Header format in. I see no problems with it as a first provision. I'll add the ""typ"" field into the JWE implementation, so we can be compliant too.",2018-08-06 19:47:11,2018-08-06 19:47:11
https://api.github.com/repos/hyperledger/indy-hipe/issues/21,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/413999667,https://github.com/hyperledger/indy-hipe/pull/21#issuecomment-413999667,swcurran,Cancelling this PR - will open separate PRs for three HIPEs that fell out of this HIPE.,2018-08-17 22:05:16,2018-08-17 22:05:16
https://api.github.com/repos/hyperledger/indy-hipe/issues/19,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/403165464,https://github.com/hyperledger/indy-hipe/pull/19#issuecomment-403165464,swcurran,"To confirm - this format would be the literal value used for the value of the ""type"" field in a the Core Message Structure (per that [HIPE](https://github.com/hyperledger/indy-hipe/pull/17)) - is that correct?  Might be worth combining the two HIPEs as they are pretty intertwined.  Or not :-)

I'm fine with the format and don't have strong opinions on the drawback questions about the context/subproject usage.",2018-07-06 22:53:31,2018-07-06 22:53:31
https://api.github.com/repos/hyperledger/indy-hipe/issues/19,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/403176085,https://github.com/hyperledger/indy-hipe/pull/19#issuecomment-403176085,dbluhm,"@swcurran Thanks for your comments! They are definitely closely intertwined lol. Initially at least, it felt different enough to propose the two separately.  Thinking again now I still think there is some value in being able to standardize a discrete piece of the standard, especially where other topics are more controversial.
Thoughts from others?
",2018-07-07 00:32:39,2018-07-07 00:32:39
https://api.github.com/repos/hyperledger/indy-hipe/issues/19,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/403709000,https://github.com/hyperledger/indy-hipe/pull/19#issuecomment-403709000,dhh1128,"I'm not sure we want to build a URN hierarchy that puts <project> and <subproject> in such a root position. If Indy or Sovrin manages to get buyin from some other project or org to use their approach, will this other project want to brand itself under the Indy/Sovrin banner? I am wondering if instead we should begin with message_type:message_family, and if we want to distinguish something that's specific to a particular audience, we just include that in the name of the message family.",2018-07-10 05:55:18,2018-07-10 05:55:18
https://api.github.com/repos/hyperledger/indy-hipe/issues/19,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/403982731,https://github.com/hyperledger/indy-hipe/pull/19#issuecomment-403982731,mhailstone,"@dhh1128 From your comment, I think this should at least be brought up in the SSI protocol discussions and be defined and discussed there as well. The hope was that we use the URN approach as is discussed in https://tools.ietf.org/html/rfc8141. We (Indy/Sovrin) would define our own message types, but whichever SSI system is used, the process could know how to identify and resolve the URN to the system and designate/route how to parse the message.",2018-07-10 22:12:11,2018-07-10 22:13:04
https://api.github.com/repos/hyperledger/indy-hipe/issues/19,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/407150064,https://github.com/hyperledger/indy-hipe/pull/19#issuecomment-407150064,TelegramSam,"I think it's valuable to talk about the purposes/uses for the type string.

The type string will be used to direct processing of a message within an agent. Every message in a particular family, for example, may be passed to a code package designed to handle that family of messages. The primary automated consumer of the type string is an agent. The primary human consumer of the type string is an agent developer. An agent developer who encounters an unknown type of message will try and figure out the message's purpose and locate documentation.

Types indicate quite a bit about the contents of the message and should be considered as a high correlation risk. It is recommended that type strings be enclosed in the encrypted portion of a message.

The domain portion 'example.com' is used as the namespace of the message family. Common namespaces will likely be sovrin.org and identity.foundation.

It is important that the domain portion allow for custom message types for any developer. This allows for experimentation and development of message families. Some message families will be promoted for broad adoption. Other families may be designed for localized use, which could include use within an organization (like a university) or niche group (like underwater basketweaving enthusiasts)

The domain portion can be any value which easily disambiguates similarly named message families. Using domains carries the drawback of relying upon a non-chain system. DIDs have been proposed as a replacement for using a domain, which itself carries two drawbacks: DIDs are neither human recognizable and are typically long.

It is possible for us to support both formats, or even a new future one, within the same type string specification.",2018-07-23 18:08:59,2018-07-23 18:08:59
https://api.github.com/repos/hyperledger/indy-hipe/issues/19,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/409979035,https://github.com/hyperledger/indy-hipe/pull/19#issuecomment-409979035,dbluhm,I'll revise this HIPE to reflect our discussion at the Agent 2 Agent Workshop.,2018-08-02 16:02:51,2018-08-02 16:02:51
https://api.github.com/repos/hyperledger/indy-hipe/issues/19,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410445314,https://github.com/hyperledger/indy-hipe/pull/19#issuecomment-410445314,TelegramSam,"Looking awesome with the updates. I think we should remove the ""Service Selection by Type"" section, and just designate that an ID must be used. Since this can be any id (not just spec), I think it's flexible enough without supporting type selection. This will make it easier to parse when necessary.",2018-08-04 12:12:26,2018-08-04 12:12:26
https://api.github.com/repos/hyperledger/indy-hipe/issues/19,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/411481470,https://github.com/hyperledger/indy-hipe/pull/19#issuecomment-411481470,swcurran,"Sorry to be a pain, but I'm not a fan having detailed technical information repeated in multiple places. At least the ABNF for a DID that is in this document and appears to be copied from the DID Spec should be removed in favour of a reference/link.  Not sure if there are other things in the doc that are the same.

If the information clarifies this document, put a version here - for example, the DID Doc specific to this use of a DID Doc.  But information that may become out of sync with it's source should be referenced and not copied.

I'm tempted, but not entirely convinced, to combine this PR with the Agent Messages HIPE.  What do other people think?",2018-08-08 17:09:56,2018-08-08 17:09:56
https://api.github.com/repos/hyperledger/indy-hipe/issues/19,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/411505078,https://github.com/hyperledger/indy-hipe/pull/19#issuecomment-411505078,dbluhm,"@swcurran not at all, thanks for your comments. As far as I know, the information supplied here is not yet in the DID spec. I'll try to confirm that. If we can pull it out and just link to it, that's fine with me.

As far as combining this with the agent messages HIPE, I'd rather keep things in smaller bite-size pieces for now. It makes it easier to agree on the content contained in the HIPE and officially move it to approved status. If we feel strongly later on that we want this HIPE and the Agent Message HIPE to be combined then I don't see a problem with that.",2018-08-08 18:25:41,2018-08-08 18:25:41
https://api.github.com/repos/hyperledger/indy-hipe/issues/19,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/411508378,https://github.com/hyperledger/indy-hipe/pull/19#issuecomment-411508378,nage,"We want to account for at least two kinds of resolution for message types.
1) some DID owns the message type and you resolve the did document, service and under that is the message identifier that can return some data
2) be able to publish the message type spec or schema to the ledger directly to indicate that it is usable by everyone (the ledger would ensure the identifier was unique, probably by just using the ledger sequence number or similar).

We don't need to support method 2 right now, but I think it is important that the addressing scheme is capable of it, because as schemas get more capable I expect there will be more and more overlap between schemas for credentials and schemas for messages and message families.",2018-08-08 18:35:54,2018-08-08 18:35:54
https://api.github.com/repos/hyperledger/indy-hipe/issues/19,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/411513863,https://github.com/hyperledger/indy-hipe/pull/19#issuecomment-411513863,dbluhm,"@swcurran Here is the github issue tracking the DID Spec changes we (perhaps prematurely) included in this HIPE: https://github.com/w3c-ccg/did-spec/issues/85

And the PR that I believe will add this: https://github.com/w3c-ccg/did-spec/pull/95",2018-08-08 18:53:31,2018-08-08 18:53:31
https://api.github.com/repos/hyperledger/indy-hipe/issues/19,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/411810221,https://github.com/hyperledger/indy-hipe/pull/19#issuecomment-411810221,swcurran,"I think that you should just reference the DID-Spec, not those specific PRs.  By definition, we'll use what is in the DID-Spec. Assuming the precise feature we need catches up, we'll use it, but otherwise, we'll still use the mechanism.   

If I'm reading this right, the feature for assembling the concrete URL for the DID URI fragment and service endpoint is not yet in the DID-Spec.  @nage - I think this should be a reminder for those working on the DID-Spec to push that PR forward.",2018-08-09 16:04:44,2018-08-09 16:04:44
https://api.github.com/repos/hyperledger/indy-hipe/issues/19,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/411811608,https://github.com/hyperledger/indy-hipe/pull/19#issuecomment-411811608,dbluhm,"My point was that it isn't in the DID spec yet. I'd love to just provide a link to the DID spec and provide the same information but as it isn't there yet, I felt it pertinent to leave in for now -- if only for our reference. As soon as the PR to the DID spec is merged, let's remove any repeated information and provide that link to the DID spec.",2018-08-09 16:09:00,2018-08-09 16:09:41
https://api.github.com/repos/hyperledger/indy-hipe/issues/18,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/403533367,https://github.com/hyperledger/indy-hipe/pull/18#issuecomment-403533367,saholman,"So the question we need to answer is whether or not we need a `request_nonce`.  If we get rid of the `request_nonce`, then we will use the `my_did` for routing the `connection_response` where as most all other messages will use the `their_did`.  As @ryanwest6 pointed out, I don't know that the `request_nonce` is adding any real security.  ",2018-07-09 16:10:51,2018-07-09 16:10:51
https://api.github.com/repos/hyperledger/indy-hipe/issues/18,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/403568020,https://github.com/hyperledger/indy-hipe/pull/18#issuecomment-403568020,dbluhm,"As per discussion in the Indy Maintainers call this morning, we're going to rework this HIPE to exclude any details on transport. These details will instead be included in a separate HIPE on transport messages. @swcurran has volunteered to write up that HIPE.",2018-07-09 18:02:39,2018-07-09 18:02:39
https://api.github.com/repos/hyperledger/indy-hipe/issues/18,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/404914303,https://github.com/hyperledger/indy-hipe/pull/18#issuecomment-404914303,ryanwest6,Updated this HIPE by removing transport layer details (such as `id`/`to`). They will be covered in the other HIPE instead. Also removed references to anoncrypt and authcrypt ,2018-07-13 18:22:52,2018-07-13 18:22:52
https://api.github.com/repos/hyperledger/indy-hipe/issues/18,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/406376785,https://github.com/hyperledger/indy-hipe/pull/18#issuecomment-406376785,dbluhm,"As suggested by @dhh1128, I think using terminology that can be easily generalized such as the ""negotiate message flow"" would be a valid and valuable change here -- especially if its usage becomes more widespread across other SSI platforms.",2018-07-19 18:46:05,2018-07-19 18:46:05
https://api.github.com/repos/hyperledger/indy-hipe/issues/18,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410418819,https://github.com/hyperledger/indy-hipe/pull/18#issuecomment-410418819,dhh1128,"I wanted to share a spreadsheet that I worked up, that analyzes connections as a state machine. I think it is largely compatible with Ryan's vision, but there are some subtleties worth discussing. Specifically: I have eliminated the ACK and ACK ACK. This is because I think any messages that flow after the connection is made accomplish the same purpose, without us allocating a special message type and special message send for them (e.g., if I immediately sent a proof request after establishing a connection, the same knowledge would be gained). Also, I think the ACKs tell us less than we'd suppose, since any connection can decay as soon as a message is sent. Also, I'm assuming the notion of negotiation back-and-forth (request and offer and request and offer...) until both parties are satisfied, even though I don't imagine most connections will negotiate much. And I'm accepting the reality that each party may have a different view of the connection's state, so I'm only trying to model the view on one side.

Maybe we can discuss in next week's agent meeting, or I can record a 10-min video where I walk through my thinking...

https://docs.google.com/spreadsheets/d/1RLJhhlWCUBYpKn18S5BGi7HH9MfGiZdHBxKjsJavoMs/edit?usp=sharing",2018-08-04 03:15:15,2018-08-04 03:15:15
https://api.github.com/repos/hyperledger/indy-hipe/issues/18,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410806965,https://github.com/hyperledger/indy-hipe/pull/18#issuecomment-410806965,dhh1128,I recorded an explanation of what I intended with the spreadsheet:  http://bit.ly/2nhQMRC. When can we discuss interactively?,2018-08-06 18:31:05,2018-08-06 18:31:05
https://api.github.com/repos/hyperledger/indy-hipe/issues/18,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410820195,https://github.com/hyperledger/indy-hipe/pull/18#issuecomment-410820195,dbluhm,"I posted this on Rocket.Chat as well:

@dhh1128  I'm looking through your spreadsheet about connections and watching your accompanying video as well. Thanks for putting those together. You focused more on the transitions from one state to the next rather than what is transmitted with each step so I wanted to paraphrase what I interpreted and get your feedback to make sure I was on the same page:

#### Alice initiates a connection with Bob:
1. Alice sends an out of band invitation to Bob.
2. Bob accepts the invitation, proposing a DID and key to be used. (I'm not sure I understood this correctly but that is what I interpreted from your assumption: ""The invitation phase ends when the initiating (inviting) party is contacted and is able to transmit a Connection Request that is A2A encrypted with the DID+key they propose to use."")
3. Alice sends a Connection Request to Bob using the information provided by Bob when he accepted the invitation.
4. Bob sends a ""Connection Outcome"" to Alice, notifying of acceptance or rejection. (Is anything else transmitted here?)",2018-08-06 19:10:13,2018-08-06 19:10:13
https://api.github.com/repos/hyperledger/indy-hipe/issues/18,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/422530820,https://github.com/hyperledger/indy-hipe/pull/18#issuecomment-422530820,smithbk,"In thinking of the connection, issuance, and verification flows as state machines. I'd like to suggest the creation of generic CRUD type messages.  I don't think this is very different, but does make the message types more canonical and so reusable for other flows.  For example, here is the puml for what I was thinking of with regard to create and update messages.   Note that a ""create"" message is always used to begin a conversation and so to create the initial state of a flow, and an ""update"" message is used to transition to the next state.   Although I don't show it below, a ""delete"" message could transition to a final state and would be the way for Alice or Bob to tell the other that they are ending their relationship.

```
@startuml

actor Alice as A #white
actor Bob as B #white


rnote over A #white
{
    ""type"": ""create"",
    ""object"": ""connection"",
    ""id"": ""<connection-id/nonce>"",
    ""state"": ""offer"",
    ""offer"": {
        ""endpoint"": {
            ""did"": A.endpoint.did
             — or —
            ""uri"": A.endpoint.uri
            ""verkey"": A.endpoint.vk
        }
    }
}
end note

A -> B: **1.** A sends **Connection Offer** in\nperson or securely over internet
||35||


rnote over B #white
{
    ""type"": ""update"",
    ""object"": ""connection"",
    ""id"": ""<connection-id/nonce>"",
    ""state"": ""request"",
    ""request"": {
        ""did"": B.did@B:A
        ""verkey"": B.vk@B:A
        ""endpoint"": B.endpoint
    }
}
end note

B -> A: **2.** B sends **Connection Request** message
||35||


rnote over A #white
{
    ""type"": ""update"",
    ""object"": ""connection"",
    ""id"": ""<connection-id/nonce>"",
    ""state"": ""response"",
    ""response"": {
            ""did"": A.did@A:B,
            ""verkey"": A.vk@A:B
    }
}
end note

A -> B: **3.** A sends **Connection Response** message
||35||


rnote over B #white
{
    ""type"": ""update"",
    ""object"": ""connection"",
    ""id"": ""<connection-id/nonce>"",
    ""state"": ""connected""
}
end note

B -> A: **4.** B sends **Connection Acknowledgement** 
||35||


rnote over A #white
{
    ""type"": ""update"",
    ""object"": ""connection"",
    ""id"": ""<connection-id/nonce>"",
    ""state"": ""connected""
}
end note

A -> B: **5.** A sends **Connection Acknowledgement** 
||35||


A <-> B: A & B can now send auth-encrypted messages

@enduml
```",2018-09-18 20:00:10,2018-09-19 12:57:31
https://api.github.com/repos/hyperledger/indy-hipe/issues/18,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/428354964,https://github.com/hyperledger/indy-hipe/pull/18#issuecomment-428354964,mikelodder7,"For an introduction message, forward secrecy could be achieved by just doing a Diffie Hellman exchange as part of the sequence. Why can't we simplify the connection protocol to just be:

A -> B: One-Time-Public Key (OTK-A), Reverse-URL
B -> A: One-Time-Public Key (OTK-B), Enc(K, DID, Identity Key)
A -> B: Enc(K, DID, Identity Key)

K is computed by B using OTK-A and his private material and
A using OTK-B and her private material.

This wouldn't provide mutual authentication and is subject to MITM but so is every introduction handshake. If this exchange happens offline (QR code scanning, code typing) then this is very unlikely to be the case. Microledgers could also be included as part of this exchange. Other data can be exchanged as well but the point is that we don't need authcrypt or anoncrypt for the intro handshake.

If party B has a well known public key say in their DID Doc on the ledger, then A can authenticate B.

The only information sent in the clear in the first message is the public key, the reverse url, and message type like offer. The second message encrypts everything but the public key.
The third message is all encrypted. You could just use regular vanilla encryption using any algorithm.",2018-10-09 21:14:59,2018-10-09 21:14:59
https://api.github.com/repos/hyperledger/indy-hipe/issues/18,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/429367477,https://github.com/hyperledger/indy-hipe/pull/18#issuecomment-429367477,dbluhm,I propose we close this HIPE in favor of the simplified and more secure protocol proposed by @mikelodder7 #46.,2018-10-12 15:35:38,2018-10-12 15:35:38
https://api.github.com/repos/hyperledger/indy-hipe/issues/18,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/439441011,https://github.com/hyperledger/indy-hipe/pull/18#issuecomment-439441011,brentzundel,Has this HIPE been superseded by #54 ?,2018-11-16 16:05:52,2018-11-16 16:05:52
https://api.github.com/repos/hyperledger/indy-hipe/issues/18,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/443356593,https://github.com/hyperledger/indy-hipe/pull/18#issuecomment-443356593,dhh1128,"Closing this PR. It contains many good ideas, but it is being superseded by PR #54 .",2018-11-30 22:18:09,2018-11-30 22:18:09
https://api.github.com/repos/hyperledger/indy-hipe/issues/17,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/400294194,https://github.com/hyperledger/indy-hipe/pull/17#issuecomment-400294194,dbluhm,[Rendered text](https://github.com/dbluhm/indy-hipe/tree/core-message-structure/text/agent-message-structure),2018-06-26 12:44:34,2018-09-05 21:42:08
https://api.github.com/repos/hyperledger/indy-hipe/issues/17,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/403171722,https://github.com/hyperledger/indy-hipe/pull/17#issuecomment-403171722,saholman,"Sorry to come late to the game, but I don't think we can get rid of the `id` field.  The agency needs a single field to look at in order to route the message, because otherwise the agency has to know about every message type and how to route messages of that type.  I think that we keep the previous message structure of

```
{
    id: 
    type: 
    message: 
}
```

and the type indicates what fields are contained in the message field.",2018-07-06 23:47:18,2018-07-06 23:48:31
https://api.github.com/repos/hyperledger/indy-hipe/issues/17,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/403172154,https://github.com/hyperledger/indy-hipe/pull/17#issuecomment-403172154,saholman,"We can call the `message` field `content` or `payload` or whatever, but its important to keep the payload of the message separate from the id used for routing and the type used so the agent knows where to send the message.  The data contained in the `message` field is what is sent to the handler of the message for a specific type.",2018-07-06 23:50:54,2018-07-06 23:50:54
https://api.github.com/repos/hyperledger/indy-hipe/issues/17,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/403174622,https://github.com/hyperledger/indy-hipe/pull/17#issuecomment-403174622,dbluhm,"@saholman I agree that some type of identifier will absolutely necessary for nearly all communications. If we let the type dictate all other attributes in a message, though, it allows attribute names that may be more intuitive for a given type. For instance, using ""to"" or ""aud"" or whatever in the place of ""id"" when the identifier is used to route to another agent.

The necessity of these identifiers and their names will be defined as message types are defined.",2018-07-07 00:14:22,2018-07-07 00:14:22
https://api.github.com/repos/hyperledger/indy-hipe/issues/17,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/403510108,https://github.com/hyperledger/indy-hipe/pull/17#issuecomment-403510108,saholman,"@dbluhm If the type indicates which field contains the routing information, then the agency would have to know about every possible type of message in order to route them.  Having a standard `id` field in the outer message allows the agency to look in a single place for the routing identifier, and the `to` or `aud` attributes can be inside the encrypted `content` section if they are still needed by the message handler.  ",2018-07-09 15:01:58,2018-07-09 15:01:58
https://api.github.com/repos/hyperledger/indy-hipe/issues/17,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/403534865,https://github.com/hyperledger/indy-hipe/pull/17#issuecomment-403534865,saholman,"After the connection, it seems like every other message could use the `their_did` for routing messages.  This is convenient because the `their_did` is the same DID used to look up a pairwise in indy-sdk.  Thoughts?  If that were the case, then the standard could say that the only thing that would be in the `id` field (or whatever we want to call it) after the connection would be the `their_did` regardless of the message type.  ",2018-07-09 16:15:34,2018-07-09 16:15:34
https://api.github.com/repos/hyperledger/indy-hipe/issues/17,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/404812291,https://github.com/hyperledger/indy-hipe/pull/17#issuecomment-404812291,dhh1128,"I think we need to distinguish between the need to describe the type of a message in two different contexts:

- describe the type from *within* the message
- describe the type from *outside* the message

The type that's visible inside a message is guaranteed to be there even if we divorce the message from its transport or context and save just the raw bytes of the message to disk. It is important to have this, so that messages can be self-contained. This is why JPEG files have an internal header that identifies them as JPEGs, PDF files have an internal header that identifies them as PDFs, and so forth.

However, a type declared internally is of no use to something that sees a message payload only as an encrypted blob of bytes. So we also need to declare type in a way that's external to the message itself, such that things that are processing the message (or routing it to other things to process) have the option of learning something about what they are handling.

The current proposal feels to me like it conflates these two concerns, placing a type declaration outside the message content but inside some other container that must unify the two.

The original A2A design called for a type declaration to be a message type of its own. You could take any other message and make it a payload of a type message. This is very close to what this proposal recommends, except that in the original view, the thing you were looking about when you were done wasn't a message of arbitrary type but guaranteed to have type as a field--but rather a ""type"" message that had another message as its payload. If we could think about it that way, I think we'd be better off.",2018-07-13 11:58:09,2018-07-13 11:58:09
https://api.github.com/repos/hyperledger/indy-hipe/issues/17,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/413158446,https://github.com/hyperledger/indy-hipe/pull/17#issuecomment-413158446,TelegramSam,"This could use two minor changes:
1. Specify that attributes with an @ prefix are reserved.
2. Use `@type` instead of `type`",2018-08-15 10:32:08,2018-08-15 10:32:08
https://api.github.com/repos/hyperledger/indy-hipe/issues/16,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/394522168,https://github.com/hyperledger/indy-hipe/pull/16#issuecomment-394522168,dbluhm,[Rendered text](https://github.com/vimmerru/indy-rfc/tree/feature/concurrency-improvment/text/concurrency-improvement),2018-06-04 22:35:35,2018-06-04 22:35:35
https://api.github.com/repos/hyperledger/indy-hipe/issues/16,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/396349648,https://github.com/hyperledger/indy-hipe/pull/16#issuecomment-396349648,dhh1128,"I am uneasy about this proposal. We are assuming a lot of responsibility for concurrency inside libindy, and making libindy fairly complex as a result. Some of the core things that libindy does are inherently asynchronous, such as interacting with a remote ledger. But I feel like crypto calls are inherently synchronous and should not be using a command object and a dispatch thread at all. By modeling such things as asynchronous, we are requiring consumers of crypto to model these synchronous operations as asynchronous with callbacks, and we are taking away from application code the ability to parallelize or serialize per its preference. In addition, I fear that the way we provide the concurrency inside libindy may limit its usefulness in certain embedded environments or on certain mobile platforms where concurrency assumptions may not fit the ones we've picked as our least common denominator.

There are two counter arguments to my worry, that I think are important:

1. If we don't do keep interfaces the same and build all the concurrency support into libindy in the way Slava proposes, we will have a lot of rewrite work. Slava makes this point in the HIPE, and I agree with it--but I don't think it ends all discussion. If we really are doing the wrong thing with the current interface, then we'd be far better off to rewrite now, before massive codebases get built on a flawed foundation, than to perpetuate a mistake. I think that the rewrite costs, while painful, would be bearable today. In a year, not so much.

2. Far more compelling in my mind is this counter-argument: Although crypto might be an example of inherently synchronous stuff in libindy, and although we might come up with a few other synchronous things as well, we might expect such functionality to rarely be consumed by itself. That is, most of the time we expect to be combining crypto and async comm. If this is true, that combining such calls is nearly always how the functionality is consumed, then keeping the crypto purely synchronous doesn't buy anybody a lot.",2018-06-11 18:58:25,2018-06-11 18:58:25
https://api.github.com/repos/hyperledger/indy-hipe/issues/16,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/396465774,https://github.com/hyperledger/indy-hipe/pull/16#issuecomment-396465774,vimmerru,"In general idea of synchronous crypto looks ok for me too, but there is significant factor that makes our crypto endpoints very similar to pool requests endpoints. We don’t have just crypto. All crypto calls involves wallet and causes long file reading/writing or waiting on network sockets. So they are blocking io/cpu intensive operations. Modelling calls like this in a blocking API way will significantly complicate the most of applications. 

I am a bit sceptic about the point that it will simplify libindy. Usually providing blocking thread-safe API wihtout dispatcher thread is more complex task than providing non-blocking API. Main cause of this is a shared state. Parallel calls will need the access to the same wallet and configuration files. SQLite documentation obviously says that it is a bad practice to access database from multiple threads and it is allowed only for specific sqlite build configuration. As result we will still need dispatcher thread that handles sqlite io. For plugged storage it will be also obvious complication and cause usage of thread pool and complex synchronyzation logic. As a result this approach doesn’t solve problem 3 completely. It just masks it, but still requires complex threading code from libindy, from pluggins and from application. 

If some endpoint can’t be called inside of UI/NodeJS/Django/Akka and etc... event loop it is obvious candidate to be asynchronous. Otherwise we need document that it MUST be wrapped to something asynchronous on application level.

",2018-06-12 04:57:50,2018-06-12 08:34:59
https://api.github.com/repos/hyperledger/indy-hipe/issues/16,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/398923804,https://github.com/hyperledger/indy-hipe/pull/16#issuecomment-398923804,dhh1128,"That's a good response, Slava. Thank you for thinking about my concerns. I would love hear what other people think about this topic. Are there members of the indy-sdk team, or coders out there in the community, that feel able to chime in?",2018-06-20 22:59:25,2018-06-20 22:59:25
https://api.github.com/repos/hyperledger/indy-hipe/issues/16,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/399491964,https://github.com/hyperledger/indy-hipe/pull/16#issuecomment-399491964,nage,As discussed in the Maintainers call and the WG call we had a call on this topic today and the consensus was we are ready to move forward on this HIPE after a week comment period which starts today.  Please comment on this PR if you have blocking issues or feedback you'd like to see incorporated.,2018-06-22 15:59:51,2018-06-22 16:00:09
https://api.github.com/repos/hyperledger/indy-hipe/issues/16,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/399495285,https://github.com/hyperledger/indy-hipe/pull/16#issuecomment-399495285,dhh1128,"Some of the Indy maintainers got together to discuss this interactively. We acknowledged that there's a tension here. If we take the approach advocated in this HIPE, almost nothing has to change in the APIs or wrappers, and client code only has to decide how big of a thread pool it wants. Libindy will become more capable of taking advantage of whatever concurrency is allowed by its host platform. And application developers will get certain concurrency benefits without thinking about them very much. Those are all good things. It would mean, for example, that TOB's use case where they're issuing 1.5M credentials will run drastically faster and will not block other indy operations.

On the other hand, this approach introduces some internal complexity into libindy that will have a carrying cost, and it requires that libindy run only on platforms that are capable of supporting sophisticated threading concepts. This may eliminate IoT things with embedded OSes, for example. Also, this approach is not very friendly to applications that want to be written for, and run as, synchronous processes. Libindy is taking responsibility for a concern that might belong more correctly to application layers. (I say ""might belong"" because it's actually a very muddy question; some parts of what libindy does would be wonderful to abstract away from applications, such as awaiting responses from the ledger. Other parts are less ideal matches for that profile, such as awaiting a DB for the second time in a 7-part sequence of actions.)

After a lot of discussion, we concluded that the benefits outweigh the drawbacks, so we will vote in favor of the HIPE. However, we want to do some research about what a synchronous API might look like because it may be desirable to wrap async libindy with a thin veneer that makes it friendly to synchronous use. That research is not a dependency of merging the HIPE, but should still be scheduled. Also, we concluded that for the benefit of the embedded/IoT use case (which relates to so-called ""static agents""), we are probably going to have to commit to an ultra-simple library sharing some DNA with libindy, but lacking support for the ledger or wallets (the main things that must be asynchronous). This library would be synchronous and would probably have just the functions needed to package and encrypt messages, and to unpackage and decrypt them. Perhaps it would be indy-crypto, or perhaps something different...

We'll now move this HIPE to a final comment period.",2018-06-22 16:09:31,2018-06-22 16:12:23
https://api.github.com/repos/hyperledger/indy-hipe/issues/16,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/409963836,https://github.com/hyperledger/indy-hipe/pull/16#issuecomment-409963836,nage,"Waiting period announced in Maintainers meeting has elapsed, please handle further issues as new PRs against this HIPE.",2018-08-02 15:18:07,2018-08-02 15:18:07
https://api.github.com/repos/hyperledger/indy-hipe/issues/15,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/393342456,https://github.com/hyperledger/indy-hipe/pull/15#issuecomment-393342456,devin-fisher,@dhh1128 Some edits and fixes to the table of contents that were broken when we switched to HIPE.,2018-05-30 22:39:47,2018-05-30 22:39:47
https://api.github.com/repos/hyperledger/indy-hipe/issues/13,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/391379811,https://github.com/hyperledger/indy-hipe/pull/13#issuecomment-391379811,dhh1128,Reviewed and approved on #indy-maintainers on Rocket.Chat.,2018-05-23 15:00:16,2018-05-23 15:00:16
https://api.github.com/repos/hyperledger/indy-hipe/issues/12,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/397104635,https://github.com/hyperledger/indy-hipe/pull/12#issuecomment-397104635,devin-fisher,[Rendered Text](https://github.com/dhh1128/indy-hipe/blob/agent-test-suite/text/agent-test-suite-interface/README.md),2018-06-13 22:13:23,2018-06-13 22:13:23
https://api.github.com/repos/hyperledger/indy-hipe/issues/12,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410719706,https://github.com/hyperledger/indy-hipe/pull/12#issuecomment-410719706,swcurran,"This looks very good and I think it should be accepted.

I do think the challenge will definitely be in the details and the evolution (interface, content) should occur as code, including documentation generated from code, and not via the HIPE process.  The concepts are excellent starting points, but I think developers, starting from here and driven by user stories, should define what's doable and what's the best way to achieve the vision.",2018-08-06 14:06:04,2018-08-06 14:06:04
https://api.github.com/repos/hyperledger/indy-hipe/issues/12,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410744955,https://github.com/hyperledger/indy-hipe/pull/12#issuecomment-410744955,nage,I have read the PR and am happy with the general proposals here.,2018-08-06 15:19:25,2018-08-06 15:19:25
https://api.github.com/repos/hyperledger/indy-hipe/issues/11,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/390710946,https://github.com/hyperledger/indy-hipe/pull/11#issuecomment-390710946,dhh1128,I'm going to close this PR and re-raise it to solve the DCO problem.,2018-05-21 16:41:49,2018-05-21 16:41:49
https://api.github.com/repos/hyperledger/indy-hipe/issues/11,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/390809048,https://github.com/hyperledger/indy-hipe/pull/11#issuecomment-390809048,dhh1128,"This PR has been superseded by https://github.com/hyperledger/indy-rfc/pull/12
",2018-05-21 23:05:56,2018-05-21 23:05:56
https://api.github.com/repos/hyperledger/indy-hipe/issues/9,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/403560790,https://github.com/hyperledger/indy-hipe/pull/9#issuecomment-403560790,swcurran,"@dhh1128 - I like this and definitely think it should be promoted.  I feel like the DIDDoc concept is missing and might simplify things. However, not quite sure where it should go - how much does it replace?  When I thought that a DID in Indy could only have one key and one endpoint, I thought it would be really useful (a DID implied that).

The other potential missing piece is where a DID is a microledger vs. a public ledger DID.  I'm not sure that's other than an implementation detail. A DID - micro- or public-ledger - can be resolved by those that need to resolve it, so where it is doesn't really matter. Either way, that resolution can fail - either because the Agent doesn't have access to the microledger or the DID doesn't exist - and that has to be handled.",2018-07-09 17:40:59,2018-07-09 17:40:59
https://api.github.com/repos/hyperledger/indy-hipe/issues/9,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/409970605,https://github.com/hyperledger/indy-hipe/pull/9#issuecomment-409970605,nage,"Without any further comments, I propose we merge this proposal, and will do so after the next maintainer call if no objections are raised.",2018-08-02 15:37:53,2018-08-02 15:37:53
https://api.github.com/repos/hyperledger/indy-hipe/issues/9,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410733844,https://github.com/hyperledger/indy-hipe/pull/9#issuecomment-410733844,swcurran,"I find the discussion that occurred in the comments about Anon/Auth is very useful and think it should be somewhere - add it to this or elsewhere?  Seems too specific to be a Notation spec. Or do I just save the URL to this PR :-) ?

As noted earlier, I think we should be including the concept of and using DIDDocs as a short form of encapsulating a lot of data about a relationship. For example, it encapsulates what is in a microledger.",2018-08-06 14:47:44,2018-08-06 14:47:44
https://api.github.com/repos/hyperledger/indy-hipe/issues/9,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/410868058,https://github.com/hyperledger/indy-hipe/pull/9#issuecomment-410868058,dhh1128,"@swcurran I added a section about DID Docs. I feel this is ready to be merged now, though I'm sure we'll continue to find minor tweaks that we like, once we begin using the notation more broadly.",2018-08-06 22:05:38,2018-08-06 22:05:38
https://api.github.com/repos/hyperledger/indy-hipe/issues/9,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/411476715,https://github.com/hyperledger/indy-hipe/pull/9#issuecomment-411476715,swcurran,I've reviewed the recent changes and am good with this being merged.,2018-08-08 16:54:50,2018-08-08 16:54:50
https://api.github.com/repos/hyperledger/indy-hipe/issues/8,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/399517222,https://github.com/hyperledger/indy-hipe/pull/8#issuecomment-399517222,swcurran,We (BC Gov) endorse this HIPE.,2018-06-22 17:21:54,2018-06-22 17:21:54
https://api.github.com/repos/hyperledger/indy-hipe/issues/8,https://api.github.com/repos/hyperledger/indy-hipe/issues/comments/404451649,https://github.com/hyperledger/indy-hipe/pull/8#issuecomment-404451649,dhh1128,"Approved for merging by Indy maintainers on Mon, Jul 9, 2018.",2018-07-12 09:32:54,2018-07-12 09:32:54
