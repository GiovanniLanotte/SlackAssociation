pull request url html,pull request url,body,commit_id,create at,id,diff_hunk,position,update at,url,html url,user
https://github.com/hyperledger/burrow/pull/1081,https://github.com/hyperledger/burrow/pull/1081,Why are you reverting these? I personally think it's a lot cleaner.,138ac223092093483c0bd24c92db20e950a0991e,2019-04-02 10:21:34,271231163,"@@ -119,23 +107,37 @@ func LoadKernelFromConfig(conf *config.BurrowConfig) (*Kernel, error) {
 		return nil, fmt.Errorf(""could not create initial kernel: %v"", err)
 	}
 
-	if err = kern.LoadLoggerFromConfig(conf.Logging); err != nil {
+	err = kern.LoadLoggerFromConfig(conf.Logging)",,2019-04-04 11:09:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/271231163,https://github.com/hyperledger/burrow/pull/1081#discussion_r271231163,gregdhill
https://github.com/hyperledger/burrow/pull/1081,https://github.com/hyperledger/burrow/pull/1081,"This should be `BurrowDir` now

```suggestion
   BurrowDir = "".burrow""
```",138ac223092093483c0bd24c92db20e950a0991e,2019-04-02 10:26:54,271233102,"@@ -7,6 +7,7 @@
   TendermintRoot = "".burrow""",,2019-04-04 11:09:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/271233102,https://github.com/hyperledger/burrow/pull/1081#discussion_r271233102,gregdhill
https://github.com/hyperledger/burrow/pull/1081,https://github.com/hyperledger/burrow/pull/1081,If you want to simplify this even further I guess you only need to set `checkTx` and possibly `kern.Blockchain` if in consensus mode.,138ac223092093483c0bd24c92db20e950a0991e,2019-04-02 10:36:50,271236903,"@@ -228,38 +243,26 @@ func (kern *Kernel) LoadTransactor() (err error) {
 	nameRegState := kern.State
 	kern.Service = rpc.NewService(accountState, nameRegState, kern.Blockchain, kern.State, nodeView, kern.Logger)
 
+	// If no Tendermint node is configured load a no-consensus Transactor that bypasses Tendermint
 	if kern.Node == nil {
-		checkTx := func(tx tmTypes.Tx, cb func(*abciTypes.Response)) error {
-			exec := abci.NewTxExecutor(kern.nodeInfo, kern.exeChecker, kern.exeCommitter, kern.txCodec, kern.Logger.WithScope(""CheckTx""))
-			ctr := exec.CheckTx(tx)
-			dtr := exec.DeliverTx(tx)
-			appHash, err := kern.exeCommitter.Commit(nil)
-			if err != nil {
-				return err
-			}
-
-			if err := kern.Blockchain.CommitBlock(time.Now(), nil, appHash); err != nil {
-				return err
-			}
-
-			cb(abciTypes.ToResponseCheckTx(ctr))
-			cb(abciTypes.ToResponseDeliverTx(dtr))
-			cb(abciTypes.ToResponseCommit(abciTypes.ResponseCommit{
-				Data: appHash,
-			}))
-
-			return nil
-		}
-
-		kern.Transactor = execution.NewTransactor(kern.Blockchain, kern.Emitter,
-			execution.NewAccounts(kern.exeChecker, kern.keyClient, AccountsRingMutexCount),
-			checkTx, kern.txCodec, kern.Logger)
-	} else {
-		kern.Blockchain.SetBlockStore(bcm.NewBlockStore(nodeView.BlockStore()))
-		kern.Transactor = execution.NewTransactor(kern.Blockchain, kern.Emitter,
-			execution.NewAccounts(kern.exeChecker, kern.keyClient, AccountsRingMutexCount),
-			kern.Node.MempoolReactor().Mempool.CheckTx, kern.txCodec, kern.Logger)
+		// Provide execution accounts against backend state since we will commit immediately
+		accounts := execution.NewAccounts(kern.checker, kern.keyClient, AccountsRingMutexCount)
+		// Elide consensus and use a CheckTx function that immediately commits any valid transaction
+		checkTx := abci.TxCommitter(kern.checker, kern.committer, kern.Blockchain, kern.txCodec,
+			time.Duration(kern.timeoutFactor*float64(time.Second)))
+		kern.Transactor = execution.NewTransactor(kern.Blockchain, kern.Emitter, accounts, checkTx, kern.txCodec,
+			kern.Logger)
+		return nil
 	}
+
+	// Use the Tendermint blockstore
+	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(nodeView.BlockStore()))
+	// Provide execution accounts against checker state so that we can assign sequence numbers
+	accounts := execution.NewAccounts(kern.checker, kern.keyClient, AccountsRingMutexCount)
+	// Pass transactions to Tendermint's CheckTx function for broadcast and consensus
+	checkTx := kern.Node.MempoolReactor().Mempool.CheckTx
+	kern.Transactor = execution.NewTransactor(kern.Blockchain, kern.Emitter, accounts, checkTx, kern.txCodec,",,2019-04-04 11:09:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/271236903,https://github.com/hyperledger/burrow/pull/1081#discussion_r271236903,gregdhill
https://github.com/hyperledger/burrow/pull/1081,https://github.com/hyperledger/burrow/pull/1081,"Why are logging ""Execution succcess"" just after logging ""Execution error""?",138ac223092093483c0bd24c92db20e950a0991e,2019-04-02 15:01:34,271351641,"@@ -192,90 +181,52 @@ func (app *App) checkValidatorMatches(ours validator.Reader, v abciTypes.Validat
 	return nil
 }
 
-func (app *App) CheckTx(txBytes []byte) abciTypes.ResponseCheckTx {
+func (app *App) CheckTx(txBytes []byte) types.ResponseCheckTx {
+	const logHeader = ""CheckTx""
 	defer func() {
 		if r := recover(); r != nil {
 			app.panicFunc(fmt.Errorf(""panic occurred in abci.App/CheckTx: %v\n%s"", r, debug.Stack()))
 		}
 	}()
-	return app.TxExecutor.CheckTx(txBytes)
+
+	checkTx := ExecuteTx(logHeader, app.checker, app.txDecoder, txBytes)
+
+	logger := WithTags(app.logger, checkTx.Tags)
+
+	if checkTx.Code != codes.TxExecutionSuccessCode {
+		logger.InfoMsg(""Execution error"",
+			""code"", checkTx.Code,
+			""log"", checkTx.Log)
+	}
+
+	logger.InfoMsg(""Execution success"")
+	return checkTx
 }
 
-func (app *App) DeliverTx(txBytes []byte) abciTypes.ResponseDeliverTx {
+func (app *App) DeliverTx(txBytes []byte) types.ResponseDeliverTx {
+	const logHeader = ""DeliverTx""
 	defer func() {
 		if r := recover(); r != nil {
 			app.panicFunc(fmt.Errorf(""panic occurred in abci.App/DeliverTx: %v\n%s"", r, debug.Stack()))
 		}
 	}()
-	return app.TxExecutor.DeliverTx(txBytes)
-}
 
-func (txx TxExecutor) CheckTx(txBytes []byte) abciTypes.ResponseCheckTx {
-	return txx.execute(""CheckTx"", txx.checker, txBytes)
-}
+	checkTx := ExecuteTx(logHeader, app.committer, app.txDecoder, txBytes)
 
-func (txx TxExecutor) DeliverTx(txBytes []byte) abciTypes.ResponseDeliverTx {
-	ctr := txx.execute(""DeliverTx"", txx.committer, txBytes)
-	// Currently these message types are identical, if they are ever different can map between
-	return abciTypes.ResponseDeliverTx{
-		Code:      ctr.Code,
-		Log:       ctr.Log,
-		Data:      ctr.Data,
-		Tags:      ctr.Tags,
-		GasUsed:   ctr.GasUsed,
-		GasWanted: ctr.GasWanted,
-		Info:      ctr.Info,
-	}
-}
+	logger := WithTags(app.logger, checkTx.Tags)
 
-func (txx TxExecutor) execute(name string, executor execution.BatchExecutor, txBytes []byte) abciTypes.ResponseCheckTx {
-	logf := func(format string, args ...interface{}) string {
-		return fmt.Sprintf(""%s: ""+format, append([]interface{}{name}, args...)...)
-	}
-
-	txEnv, err := txx.txDecoder.DecodeTx(txBytes)
-	if err != nil {
-		txx.logger.InfoMsg(""Decoding error"",
-			structure.ErrorKey, err)
-		return abciTypes.ResponseCheckTx{
-			Code: codes.EncodingErrorCode,
-			Log:  logf(""Encoding error: %s"", err),
-		}
-	}
-
-	txe, err := executor.Execute(txEnv)
-	if err != nil {
-		ex := errors.AsException(err)
-		txx.logger.InfoMsg(""Execution error"",
-			structure.ErrorKey, err,
-			""tx_hash"", txEnv.Tx.Hash())
-		return abciTypes.ResponseCheckTx{
-			Code: codes.TxExecutionErrorCode,
-			Log:  logf(""Could not execute transaction: %s, error: %v"", txEnv, ex.Exception),
-		}
-	}
-
-	bs, err := txe.Receipt.Encode()
-	if err != nil {
-		return abciTypes.ResponseCheckTx{
-			Code: codes.EncodingErrorCode,
-			Log:  logf(""Could not serialise receipt: %s"", err),
-		}
-	}
-	txx.logger.InfoMsg(""Execution success"",
-		""tx_hash"", txe.TxHash,
-		""contract_address"", txe.Receipt.ContractAddress,
-		""creates_contract"", txe.Receipt.CreatesContract)
-	return abciTypes.ResponseCheckTx{
-		Code: codes.TxExecutionSuccessCode,
-		Log:  logf(""Execution success - TxExecution in data""),
-		Data: bs,
+	if checkTx.Code != codes.TxExecutionSuccessCode {
+		logger.InfoMsg(""Execution error"",
+			""code"", checkTx.Code,
+			""log"", checkTx.Log)
 	}
 
+	logger.InfoMsg(""Execution success"")",,2019-04-04 11:09:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/271351641,https://github.com/hyperledger/burrow/pull/1081#discussion_r271351641,seanyoung
https://github.com/hyperledger/burrow/pull/1081,https://github.com/hyperledger/burrow/pull/1081,same here,138ac223092093483c0bd24c92db20e950a0991e,2019-04-02 15:02:04,271351890,"@@ -192,90 +181,52 @@ func (app *App) checkValidatorMatches(ours validator.Reader, v abciTypes.Validat
 	return nil
 }
 
-func (app *App) CheckTx(txBytes []byte) abciTypes.ResponseCheckTx {
+func (app *App) CheckTx(txBytes []byte) types.ResponseCheckTx {
+	const logHeader = ""CheckTx""
 	defer func() {
 		if r := recover(); r != nil {
 			app.panicFunc(fmt.Errorf(""panic occurred in abci.App/CheckTx: %v\n%s"", r, debug.Stack()))
 		}
 	}()
-	return app.TxExecutor.CheckTx(txBytes)
+
+	checkTx := ExecuteTx(logHeader, app.checker, app.txDecoder, txBytes)
+
+	logger := WithTags(app.logger, checkTx.Tags)
+
+	if checkTx.Code != codes.TxExecutionSuccessCode {
+		logger.InfoMsg(""Execution error"",
+			""code"", checkTx.Code,
+			""log"", checkTx.Log)
+	}
+
+	logger.InfoMsg(""Execution success"")",,2019-04-04 11:09:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/271351890,https://github.com/hyperledger/burrow/pull/1081#discussion_r271351890,seanyoung
https://github.com/hyperledger/burrow/pull/1079,https://github.com/hyperledger/burrow/pull/1079,"```suggestion
 	logger.TraceMsg(""Current height is"",
```",d5599abf2a0d7271dbbd62c21801a5cb79e9bd72,2019-04-03 14:37:07,271775172,"@@ -134,19 +134,21 @@ func PreProcess(toProcess string, do *def.DeployArgs, script *def.Playbook, clie
 	return toProcess, nil
 }
 
-func replaceBlockVariable(toReplace string, client *def.Client) (string, error) {
-	log.WithFields(log.Fields{
-		""var"": toReplace,
-	}).Debug(""Correcting $block variable"")
-	blockHeight, err := GetBlockHeight(client)
+func replaceBlockVariable(toReplace string, client *def.Client, logger *logging.Logger) (string, error) {
+	logger.TraceMsg(""Correcting $block variable"",
+		""var"", toReplace)
+
+	blockHeight, err := GetBlockHeight(client, logger)
 	block := itoaU64(blockHeight)
-	log.WithField(""=>"", block).Debug(""Current height is"")
+	logger.TraceMsg(""Currnt height is"",",,2019-04-03 16:04:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/271775172,https://github.com/hyperledger/burrow/pull/1079#discussion_r271775172,gregdhill
https://github.com/hyperledger/burrow/pull/1079,https://github.com/hyperledger/burrow/pull/1079,"I think maybe it would be better to set the default as an empty array, then length check to give a helpful error message?",d5599abf2a0d7271dbbd62c21801a5cb79e9bd72,2019-04-03 14:43:05,271778071,"@@ -31,10 +31,10 @@ func Deploy(output Output) func(cmd *cli.Cmd) {
 		pathOpt := cmd.StringOpt(""i dir"", """", ""root directory of app (will use pwd by default)"")
 
 		defaultOutputOpt := cmd.StringOpt(""o output"", def.DefaultOutputFile,
-			""filename for jobs output file. by default, this name will reflect the name passed in on the optional [--file]"")
+			""filename for playbook output file. by default, this name will reflect the playbook passed"")
 
-		yamlPathOpt := cmd.StringOpt(""f file"", ""deploy.yaml"",
-			""path to package file which jobs should use. if also using the --dir flag, give the relative path to jobs file, which should be in the same directory"")
+		playbooksOpt := cmd.StringsArg(""FILE"", []string{""deploy.yaml""},",,2019-04-03 16:04:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/271778071,https://github.com/hyperledger/burrow/pull/1079#discussion_r271778071,gregdhill
https://github.com/hyperledger/burrow/pull/1079,https://github.com/hyperledger/burrow/pull/1079,Fixed,d5599abf2a0d7271dbbd62c21801a5cb79e9bd72,2019-04-03 16:12:11,271820895,"@@ -134,19 +134,21 @@ func PreProcess(toProcess string, do *def.DeployArgs, script *def.Playbook, clie
 	return toProcess, nil
 }
 
-func replaceBlockVariable(toReplace string, client *def.Client) (string, error) {
-	log.WithFields(log.Fields{
-		""var"": toReplace,
-	}).Debug(""Correcting $block variable"")
-	blockHeight, err := GetBlockHeight(client)
+func replaceBlockVariable(toReplace string, client *def.Client, logger *logging.Logger) (string, error) {
+	logger.TraceMsg(""Correcting $block variable"",
+		""var"", toReplace)
+
+	blockHeight, err := GetBlockHeight(client, logger)
 	block := itoaU64(blockHeight)
-	log.WithField(""=>"", block).Debug(""Current height is"")
+	logger.TraceMsg(""Currnt height is"",",,2019-04-03 16:12:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/271820895,https://github.com/hyperledger/burrow/pull/1079#discussion_r271820895,seanyoung
https://github.com/hyperledger/burrow/pull/1079,https://github.com/hyperledger/burrow/pull/1079,"Good point, thank you. Now the yaml file is a required argument.",d5599abf2a0d7271dbbd62c21801a5cb79e9bd72,2019-04-03 16:12:27,271821001,"@@ -31,10 +31,10 @@ func Deploy(output Output) func(cmd *cli.Cmd) {
 		pathOpt := cmd.StringOpt(""i dir"", """", ""root directory of app (will use pwd by default)"")
 
 		defaultOutputOpt := cmd.StringOpt(""o output"", def.DefaultOutputFile,
-			""filename for jobs output file. by default, this name will reflect the name passed in on the optional [--file]"")
+			""filename for playbook output file. by default, this name will reflect the playbook passed"")
 
-		yamlPathOpt := cmd.StringOpt(""f file"", ""deploy.yaml"",
-			""path to package file which jobs should use. if also using the --dir flag, give the relative path to jobs file, which should be in the same directory"")
+		playbooksOpt := cmd.StringsArg(""FILE"", []string{""deploy.yaml""},",,2019-04-03 16:12:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/271821001,https://github.com/hyperledger/burrow/pull/1079#discussion_r271821001,seanyoung
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,This should be part of `UseTendermint`,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-15 13:09:42,265972901,"@@ -72,292 +62,197 @@ const (
 // Kernel is the root structure of Burrow
 type Kernel struct {
 	// Expose these public-facing interfaces to allow programmatic extension of the Kernel by other projects
-	Emitter    event.Emitter
-	Service    *rpc.Service
-	Launchers  []process.Launcher
-	State      *state.State
-	Blockchain *bcm.Blockchain
-	Node       *tendermint.Node
-	Transactor *execution.Transactor
-	// Time-based UUID randomly generated each time Burrow is started
-	RunID          simpleuuid.UUID
+	Emitter        event.Emitter
+	Service        *rpc.Service
+	Launchers      []process.Launcher
+	State          *state.State
+	Blockchain     *bcm.Blockchain
+	View           *tendermint.NodeView
+	Transactor     *execution.Transactor
+	RunID          simpleuuid.UUID // Time-based UUID randomly generated each time Burrow is started
 	Logger         *logging.Logger
+	txCodec        txs.Codec
+	exeChecker     execution.BatchExecutor
+	exeCommitter   execution.BatchCommitter
 	nodeInfo       string
 	processes      map[string]process.Process
 	shutdownNotify chan struct{}
 	shutdownOnce   sync.Once
 }
 
-func NewBurrowDB(dbDir string) dbm.DB {
+func newBurrowDB(dbDir string) dbm.DB {
 	return dbm.NewDB(BurrowDBName, dbm.GoLevelDBBackend, dbDir)
 }
 
-func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTypes.PrivValidator,
-	genesisDoc *genesis.GenesisDoc, tmConf *tmConfig.Config, rpcConfig *rpc.RPCConfig, keyConfig *keys.KeysConfig,
-	keyStore *keys.KeyStore, exeOptions []execution.ExecutionOption, authorizedPeersProvider abci.PeersFilterProvider, restore string, logger *logging.Logger) (*Kernel, error) {
-
-	var err error
+// NewKernel initializes an empty kernel
+func NewKernel() *Kernel {
 	kern := &Kernel{
 		processes:      make(map[string]process.Process),
 		shutdownNotify: make(chan struct{}),
+		txCodec:        txs.NewAminoCodec(),
 	}
-	// Create a random ID based on start time
-	kern.RunID, err = simpleuuid.NewTime(time.Now())
+	return kern
+}
 
-	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey, log.DefaultTimestampUTC,
-		structure.RunId, kern.RunID.String())
-	tmLogger := logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+// SetValidator sets the identity for the kernel
+func (kern *Kernel) SetValidator(privValidator tmTypes.PrivValidator) error {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/265972901,https://github.com/hyperledger/burrow/pull/1065#discussion_r265972901,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,Move this to `NewKernel`,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-15 13:09:58,265972979,"@@ -72,292 +62,197 @@ const (
 // Kernel is the root structure of Burrow
 type Kernel struct {
 	// Expose these public-facing interfaces to allow programmatic extension of the Kernel by other projects
-	Emitter    event.Emitter
-	Service    *rpc.Service
-	Launchers  []process.Launcher
-	State      *state.State
-	Blockchain *bcm.Blockchain
-	Node       *tendermint.Node
-	Transactor *execution.Transactor
-	// Time-based UUID randomly generated each time Burrow is started
-	RunID          simpleuuid.UUID
+	Emitter        event.Emitter
+	Service        *rpc.Service
+	Launchers      []process.Launcher
+	State          *state.State
+	Blockchain     *bcm.Blockchain
+	View           *tendermint.NodeView
+	Transactor     *execution.Transactor
+	RunID          simpleuuid.UUID // Time-based UUID randomly generated each time Burrow is started
 	Logger         *logging.Logger
+	txCodec        txs.Codec
+	exeChecker     execution.BatchExecutor
+	exeCommitter   execution.BatchCommitter
 	nodeInfo       string
 	processes      map[string]process.Process
 	shutdownNotify chan struct{}
 	shutdownOnce   sync.Once
 }
 
-func NewBurrowDB(dbDir string) dbm.DB {
+func newBurrowDB(dbDir string) dbm.DB {
 	return dbm.NewDB(BurrowDBName, dbm.GoLevelDBBackend, dbDir)
 }
 
-func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTypes.PrivValidator,
-	genesisDoc *genesis.GenesisDoc, tmConf *tmConfig.Config, rpcConfig *rpc.RPCConfig, keyConfig *keys.KeysConfig,
-	keyStore *keys.KeyStore, exeOptions []execution.ExecutionOption, authorizedPeersProvider abci.PeersFilterProvider, restore string, logger *logging.Logger) (*Kernel, error) {
-
-	var err error
+// NewKernel initializes an empty kernel
+func NewKernel() *Kernel {
 	kern := &Kernel{
 		processes:      make(map[string]process.Process),
 		shutdownNotify: make(chan struct{}),
+		txCodec:        txs.NewAminoCodec(),
 	}
-	// Create a random ID based on start time
-	kern.RunID, err = simpleuuid.NewTime(time.Now())
+	return kern
+}
 
-	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey, log.DefaultTimestampUTC,
-		structure.RunId, kern.RunID.String())
-	tmLogger := logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+// SetValidator sets the identity for the kernel
+func (kern *Kernel) SetValidator(privValidator tmTypes.PrivValidator) error {
+	var err error
+	kern.RunID, err = simpleuuid.NewTime(time.Now()) // Create a random ID based on start time",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/265972979,https://github.com/hyperledger/burrow/pull/1065#discussion_r265972979,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,This should be absorbed by `SetNode`,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-15 13:11:31,265973516,"@@ -14,31 +14,42 @@ import (
 )
 
 type NodeView struct {
-	tmNode             *Node
-	validatorPublicKey crypto.PublicKey
-	txDecoder          txs.Decoder
-	runID              simpleuuid.UUID
+	tmNode    *Node
+	publicKey crypto.PublicKey
+	txDecoder txs.Decoder
+	runID     simpleuuid.UUID
 }
 
-func NewNodeView(tmNode *Node, txDecoder txs.Decoder, runID simpleuuid.UUID) (*NodeView, error) {
-	publicKey, err := crypto.PublicKeyFromTendermintPubKey(tmNode.PrivValidator().GetPubKey())
-	if err != nil {
-		return nil, err
+func NewNodeView(txDecoder txs.Decoder, runID simpleuuid.UUID) *NodeView {
+	return &NodeView{
+		txDecoder: txDecoder,
+		runID:     runID,
 	}
+}
+
+func (nv *NodeView) SetValidator(privVal types.PrivValidator) error {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/265973516,https://github.com/hyperledger/burrow/pull/1065#discussion_r265973516,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,Use `tmNode.PrivValidator()` to get the validator and extract public key,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-15 13:12:05,265973703,"@@ -14,31 +14,42 @@ import (
 )
 
 type NodeView struct {
-	tmNode             *Node
-	validatorPublicKey crypto.PublicKey
-	txDecoder          txs.Decoder
-	runID              simpleuuid.UUID
+	tmNode    *Node
+	publicKey crypto.PublicKey
+	txDecoder txs.Decoder
+	runID     simpleuuid.UUID
 }
 
-func NewNodeView(tmNode *Node, txDecoder txs.Decoder, runID simpleuuid.UUID) (*NodeView, error) {
-	publicKey, err := crypto.PublicKeyFromTendermintPubKey(tmNode.PrivValidator().GetPubKey())
-	if err != nil {
-		return nil, err
+func NewNodeView(txDecoder txs.Decoder, runID simpleuuid.UUID) *NodeView {
+	return &NodeView{
+		txDecoder: txDecoder,
+		runID:     runID,
 	}
+}
+
+func (nv *NodeView) SetValidator(privVal types.PrivValidator) error {
+	pK, err := crypto.PublicKeyFromTendermintPubKey(privVal.GetPubKey())
+	nv.publicKey = pK
+	return err
+}
+
+func (nv *NodeView) SetNode(tmNode *Node) {
 	tmNode.BlockStore()
-	return &NodeView{
-		validatorPublicKey: publicKey,
-		tmNode:             tmNode,
-		txDecoder:          txDecoder,
-		runID:              runID,
-	}, nil
+	nv.tmNode = tmNode",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/265973703,https://github.com/hyperledger/burrow/pull/1065#discussion_r265973703,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,BTW let's get rid of `context` from the kernel config method it is unused.,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-15 13:13:06,265974056,"@@ -84,8 +86,32 @@ func (conf *BurrowConfig) Kernel(ctx context.Context, restoreDump string) (*core
 		}
 	}
 
-	return core.NewKernel(ctx, keyClient, privValidator, conf.GenesisDoc, conf.Tendermint.TendermintConfig(), conf.RPC,",91,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/265974056,https://github.com/hyperledger/burrow/pull/1065#discussion_r265974056,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,"Hmmm... I'm actually not sure `NodeView` should be instantiated at all without Tendermint. It is meant to be a wrapping of the Tendermint node. The only question is whether we have any use for a validator private key in this non-consensus mode. There are a couple of future places where we _might_ such as for adding the validator's signature to a mempool signed tx. But to be honest the single-node case is kind of out of scope now.

I think we should move this back to constructor.",9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-15 13:16:20,265975157,"@@ -14,31 +14,42 @@ import (
 )
 
 type NodeView struct {
-	tmNode             *Node
-	validatorPublicKey crypto.PublicKey
-	txDecoder          txs.Decoder
-	runID              simpleuuid.UUID
+	tmNode    *Node
+	publicKey crypto.PublicKey
+	txDecoder txs.Decoder
+	runID     simpleuuid.UUID
 }
 
-func NewNodeView(tmNode *Node, txDecoder txs.Decoder, runID simpleuuid.UUID) (*NodeView, error) {
-	publicKey, err := crypto.PublicKeyFromTendermintPubKey(tmNode.PrivValidator().GetPubKey())
-	if err != nil {
-		return nil, err
+func NewNodeView(txDecoder txs.Decoder, runID simpleuuid.UUID) *NodeView {
+	return &NodeView{
+		txDecoder: txDecoder,
+		runID:     runID,
 	}
+}
+
+func (nv *NodeView) SetValidator(privVal types.PrivValidator) error {
+	pK, err := crypto.PublicKeyFromTendermintPubKey(privVal.GetPubKey())
+	nv.publicKey = pK
+	return err
+}
+
+func (nv *NodeView) SetNode(tmNode *Node) {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/265975157,https://github.com/hyperledger/burrow/pull/1065#discussion_r265975157,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,"The idea of the `NodeView` is to hide the node - e.g. to stop the RPC from doing something it shouldn't/blocking writes against the Tendermint node. If we are going to allow access to it like this we may as well just embed `Node`, but that is a not insignificant design change.

This should be removed.",9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-15 13:20:13,265976531,"@@ -14,31 +14,42 @@ import (
 )
 
 type NodeView struct {
-	tmNode             *Node
-	validatorPublicKey crypto.PublicKey
-	txDecoder          txs.Decoder
-	runID              simpleuuid.UUID
+	tmNode    *Node
+	publicKey crypto.PublicKey
+	txDecoder txs.Decoder
+	runID     simpleuuid.UUID
 }
 
-func NewNodeView(tmNode *Node, txDecoder txs.Decoder, runID simpleuuid.UUID) (*NodeView, error) {
-	publicKey, err := crypto.PublicKeyFromTendermintPubKey(tmNode.PrivValidator().GetPubKey())
-	if err != nil {
-		return nil, err
+func NewNodeView(txDecoder txs.Decoder, runID simpleuuid.UUID) *NodeView {
+	return &NodeView{
+		txDecoder: txDecoder,
+		runID:     runID,
 	}
+}
+
+func (nv *NodeView) SetValidator(privVal types.PrivValidator) error {
+	pK, err := crypto.PublicKeyFromTendermintPubKey(privVal.GetPubKey())
+	nv.publicKey = pK
+	return err
+}
+
+func (nv *NodeView) SetNode(tmNode *Node) {
 	tmNode.BlockStore()
-	return &NodeView{
-		validatorPublicKey: publicKey,
-		tmNode:             tmNode,
-		txDecoder:          txDecoder,
-		runID:              runID,
-	}, nil
+	nv.tmNode = tmNode
+}
+
+func (nv *NodeView) GetNode() *Node {
+	return nv.tmNode",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/265976531,https://github.com/hyperledger/burrow/pull/1065#discussion_r265976531,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,"So I think the way we should handle this type of thing is being keeping `*NodeView` itself nil so:

```go
if nv == nil {
// return suitable no-op thing
}
```
",9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-15 13:22:11,265977198,"@@ -14,31 +14,42 @@ import (
 )
 
 type NodeView struct {
-	tmNode             *Node
-	validatorPublicKey crypto.PublicKey
-	txDecoder          txs.Decoder
-	runID              simpleuuid.UUID
+	tmNode    *Node
+	publicKey crypto.PublicKey
+	txDecoder txs.Decoder
+	runID     simpleuuid.UUID
 }
 
-func NewNodeView(tmNode *Node, txDecoder txs.Decoder, runID simpleuuid.UUID) (*NodeView, error) {
-	publicKey, err := crypto.PublicKeyFromTendermintPubKey(tmNode.PrivValidator().GetPubKey())
-	if err != nil {
-		return nil, err
+func NewNodeView(txDecoder txs.Decoder, runID simpleuuid.UUID) *NodeView {
+	return &NodeView{
+		txDecoder: txDecoder,
+		runID:     runID,
 	}
+}
+
+func (nv *NodeView) SetValidator(privVal types.PrivValidator) error {
+	pK, err := crypto.PublicKeyFromTendermintPubKey(privVal.GetPubKey())
+	nv.publicKey = pK
+	return err
+}
+
+func (nv *NodeView) SetNode(tmNode *Node) {
 	tmNode.BlockStore()
-	return &NodeView{
-		validatorPublicKey: publicKey,
-		tmNode:             tmNode,
-		txDecoder:          txDecoder,
-		runID:              runID,
-	}, nil
+	nv.tmNode = tmNode
+}
+
+func (nv *NodeView) GetNode() *Node {
+	return nv.tmNode
 }
 
 func (nv *NodeView) ValidatorPublicKey() crypto.PublicKey {
-	return nv.validatorPublicKey
+	return nv.publicKey
 }
 
 func (nv *NodeView) NodeInfo() *NodeInfo {
+	if nv.tmNode == nil {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/265977198,https://github.com/hyperledger/burrow/pull/1065#discussion_r265977198,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,"I think we should probably drop this from being a method of `BurrowConfig` and move it to core in a separate file adjacent to kernel.go as

`ConfigureKernel(conf *BurrowConfig)`",9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-15 13:25:32,265978372,"@@ -50,19 +50,22 @@ func (conf *BurrowConfig) Kernel(ctx context.Context, restoreDump string) (*core
 	if conf.ValidatorAddress == nil {
 		return nil, fmt.Errorf(""no validator address provided, cannot make Kernel"")
 	}
+
 	logger, err := lifecycle.NewLoggerFromLoggingConfig(conf.Logging)",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/265978372,https://github.com/hyperledger/burrow/pull/1065#discussion_r265978372,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,Let's remove the restore flag and make `RestoreDump` it's own function on `Kernel`,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-15 13:26:05,265978556,"@@ -72,292 +62,197 @@ const (
 // Kernel is the root structure of Burrow
 type Kernel struct {
 	// Expose these public-facing interfaces to allow programmatic extension of the Kernel by other projects
-	Emitter    event.Emitter
-	Service    *rpc.Service
-	Launchers  []process.Launcher
-	State      *state.State
-	Blockchain *bcm.Blockchain
-	Node       *tendermint.Node
-	Transactor *execution.Transactor
-	// Time-based UUID randomly generated each time Burrow is started
-	RunID          simpleuuid.UUID
+	Emitter        event.Emitter
+	Service        *rpc.Service
+	Launchers      []process.Launcher
+	State          *state.State
+	Blockchain     *bcm.Blockchain
+	View           *tendermint.NodeView
+	Transactor     *execution.Transactor
+	RunID          simpleuuid.UUID // Time-based UUID randomly generated each time Burrow is started
 	Logger         *logging.Logger
+	txCodec        txs.Codec
+	exeChecker     execution.BatchExecutor
+	exeCommitter   execution.BatchCommitter
 	nodeInfo       string
 	processes      map[string]process.Process
 	shutdownNotify chan struct{}
 	shutdownOnce   sync.Once
 }
 
-func NewBurrowDB(dbDir string) dbm.DB {
+func newBurrowDB(dbDir string) dbm.DB {
 	return dbm.NewDB(BurrowDBName, dbm.GoLevelDBBackend, dbDir)
 }
 
-func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTypes.PrivValidator,
-	genesisDoc *genesis.GenesisDoc, tmConf *tmConfig.Config, rpcConfig *rpc.RPCConfig, keyConfig *keys.KeysConfig,
-	keyStore *keys.KeyStore, exeOptions []execution.ExecutionOption, authorizedPeersProvider abci.PeersFilterProvider, restore string, logger *logging.Logger) (*Kernel, error) {
-
-	var err error
+// NewKernel initializes an empty kernel
+func NewKernel() *Kernel {
 	kern := &Kernel{
 		processes:      make(map[string]process.Process),
 		shutdownNotify: make(chan struct{}),
+		txCodec:        txs.NewAminoCodec(),
 	}
-	// Create a random ID based on start time
-	kern.RunID, err = simpleuuid.NewTime(time.Now())
+	return kern
+}
 
-	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey, log.DefaultTimestampUTC,
-		structure.RunId, kern.RunID.String())
-	tmLogger := logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+// SetValidator sets the identity for the kernel
+func (kern *Kernel) SetValidator(privValidator tmTypes.PrivValidator) error {
+	var err error
+	kern.RunID, err = simpleuuid.NewTime(time.Now()) // Create a random ID based on start time
+	if err != nil {
+		return err
+	}
+	kern.View = tendermint.NewNodeView(kern.txCodec, kern.RunID)
+	err = kern.View.SetValidator(privValidator)
+	return err
+}
+
+// SetLogger initializes the kernel with the provided logger
+func (kern *Kernel) SetLogger(logger *logging.Logger) {
+	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey,
+		log.DefaultTimestampUTC, structure.RunId, kern.RunID.String())
 	kern.Logger = logger.WithInfo(structure.CallerKey, log.Caller(LoggingCallerDepth))
-	stateDB := NewBurrowDB(tmConf.DBDir())
+	kern.Emitter = event.NewEmitter(kern.Logger)
+}
 
+// LoadState starts from scratch or previous chain
+func (kern *Kernel) LoadState(genesisDoc *genesis.GenesisDoc, dbDir, restore string) (err error) {
+	stateDB := newBurrowDB(dbDir)
 	kern.Blockchain, err = bcm.LoadOrNewBlockchain(stateDB, genesisDoc, kern.Logger)
 	if err != nil {
-		return nil, fmt.Errorf(""error creating or loading blockchain state: %v"", err)
+		return fmt.Errorf(""error creating or loading blockchain state: %v"", err)
 	}
+	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(blockchain.NewBlockStore(stateDB)))
 
 	// These should be in sync unless we are at the genesis block
 	if kern.Blockchain.LastBlockHeight() > 0 {
 		kern.Logger.InfoMsg(""Loading application state"")
 		kern.State, err = state.LoadState(stateDB, execution.VersionAtHeight(kern.Blockchain.LastBlockHeight()))
 		if err != nil {
-			return nil, fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
+			return fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
 				kern.Blockchain.AppHashAfterLastBlock(), err)
 		}
 		if !bytes.Equal(kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock()) {
-			return nil, fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
+			return fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
 				""state gives %X, blockchain gives %X"", kern.Blockchain.LastBlockHeight(),
 				kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock())
 		}
 		if restore != """" {
-			return nil, fmt.Errorf(""Cannot restore onto existing chain; don't give --restore-dump argument"")
+			return fmt.Errorf(""Cannot restore onto existing chain; don't give --restore-dump argument"")
 		}
 	} else {
 		kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
 		if err != nil {
-			return nil, fmt.Errorf(""could not build genesis state: %v"", err)
+			return fmt.Errorf(""could not build genesis state: %v"", err)
 		}
 
 		if restore != """" {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/265978556,https://github.com/hyperledger/burrow/pull/1065#discussion_r265978556,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,Done :),9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-19 10:44:32,266824873,"@@ -72,292 +62,197 @@ const (
 // Kernel is the root structure of Burrow
 type Kernel struct {
 	// Expose these public-facing interfaces to allow programmatic extension of the Kernel by other projects
-	Emitter    event.Emitter
-	Service    *rpc.Service
-	Launchers  []process.Launcher
-	State      *state.State
-	Blockchain *bcm.Blockchain
-	Node       *tendermint.Node
-	Transactor *execution.Transactor
-	// Time-based UUID randomly generated each time Burrow is started
-	RunID          simpleuuid.UUID
+	Emitter        event.Emitter
+	Service        *rpc.Service
+	Launchers      []process.Launcher
+	State          *state.State
+	Blockchain     *bcm.Blockchain
+	View           *tendermint.NodeView
+	Transactor     *execution.Transactor
+	RunID          simpleuuid.UUID // Time-based UUID randomly generated each time Burrow is started
 	Logger         *logging.Logger
+	txCodec        txs.Codec
+	exeChecker     execution.BatchExecutor
+	exeCommitter   execution.BatchCommitter
 	nodeInfo       string
 	processes      map[string]process.Process
 	shutdownNotify chan struct{}
 	shutdownOnce   sync.Once
 }
 
-func NewBurrowDB(dbDir string) dbm.DB {
+func newBurrowDB(dbDir string) dbm.DB {
 	return dbm.NewDB(BurrowDBName, dbm.GoLevelDBBackend, dbDir)
 }
 
-func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTypes.PrivValidator,
-	genesisDoc *genesis.GenesisDoc, tmConf *tmConfig.Config, rpcConfig *rpc.RPCConfig, keyConfig *keys.KeysConfig,
-	keyStore *keys.KeyStore, exeOptions []execution.ExecutionOption, authorizedPeersProvider abci.PeersFilterProvider, restore string, logger *logging.Logger) (*Kernel, error) {
-
-	var err error
+// NewKernel initializes an empty kernel
+func NewKernel() *Kernel {
 	kern := &Kernel{
 		processes:      make(map[string]process.Process),
 		shutdownNotify: make(chan struct{}),
+		txCodec:        txs.NewAminoCodec(),
 	}
-	// Create a random ID based on start time
-	kern.RunID, err = simpleuuid.NewTime(time.Now())
+	return kern
+}
 
-	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey, log.DefaultTimestampUTC,
-		structure.RunId, kern.RunID.String())
-	tmLogger := logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+// SetValidator sets the identity for the kernel
+func (kern *Kernel) SetValidator(privValidator tmTypes.PrivValidator) error {
+	var err error
+	kern.RunID, err = simpleuuid.NewTime(time.Now()) // Create a random ID based on start time
+	if err != nil {
+		return err
+	}
+	kern.View = tendermint.NewNodeView(kern.txCodec, kern.RunID)
+	err = kern.View.SetValidator(privValidator)
+	return err
+}
+
+// SetLogger initializes the kernel with the provided logger
+func (kern *Kernel) SetLogger(logger *logging.Logger) {
+	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey,
+		log.DefaultTimestampUTC, structure.RunId, kern.RunID.String())
 	kern.Logger = logger.WithInfo(structure.CallerKey, log.Caller(LoggingCallerDepth))
-	stateDB := NewBurrowDB(tmConf.DBDir())
+	kern.Emitter = event.NewEmitter(kern.Logger)
+}
 
+// LoadState starts from scratch or previous chain
+func (kern *Kernel) LoadState(genesisDoc *genesis.GenesisDoc, dbDir, restore string) (err error) {
+	stateDB := newBurrowDB(dbDir)
 	kern.Blockchain, err = bcm.LoadOrNewBlockchain(stateDB, genesisDoc, kern.Logger)
 	if err != nil {
-		return nil, fmt.Errorf(""error creating or loading blockchain state: %v"", err)
+		return fmt.Errorf(""error creating or loading blockchain state: %v"", err)
 	}
+	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(blockchain.NewBlockStore(stateDB)))
 
 	// These should be in sync unless we are at the genesis block
 	if kern.Blockchain.LastBlockHeight() > 0 {
 		kern.Logger.InfoMsg(""Loading application state"")
 		kern.State, err = state.LoadState(stateDB, execution.VersionAtHeight(kern.Blockchain.LastBlockHeight()))
 		if err != nil {
-			return nil, fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
+			return fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
 				kern.Blockchain.AppHashAfterLastBlock(), err)
 		}
 		if !bytes.Equal(kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock()) {
-			return nil, fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
+			return fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
 				""state gives %X, blockchain gives %X"", kern.Blockchain.LastBlockHeight(),
 				kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock())
 		}
 		if restore != """" {
-			return nil, fmt.Errorf(""Cannot restore onto existing chain; don't give --restore-dump argument"")
+			return fmt.Errorf(""Cannot restore onto existing chain; don't give --restore-dump argument"")
 		}
 	} else {
 		kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
 		if err != nil {
-			return nil, fmt.Errorf(""could not build genesis state: %v"", err)
+			return fmt.Errorf(""could not build genesis state: %v"", err)
 		}
 
 		if restore != """" {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/266824873,https://github.com/hyperledger/burrow/pull/1065#discussion_r266824873,gregdhill
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,Can we rename `restore` to `restoreFile`?,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 10:34:03,267273719,"@@ -73,300 +65,305 @@ const (
 // Kernel is the root structure of Burrow
 type Kernel struct {
 	// Expose these public-facing interfaces to allow programmatic extension of the Kernel by other projects
-	Emitter    event.Emitter
-	Service    *rpc.Service
-	Launchers  []process.Launcher
-	State      *state.State
-	Blockchain *bcm.Blockchain
-	Node       *tendermint.Node
-	Transactor *execution.Transactor
-	// Time-based UUID randomly generated each time Burrow is started
-	RunID          simpleuuid.UUID
+	Emitter        event.Emitter
+	Service        *rpc.Service
+	Launchers      []process.Launcher
+	State          *state.State
+	Blockchain     *bcm.Blockchain
+	Node           *tendermint.Node
+	Transactor     *execution.Transactor
+	RunID          simpleuuid.UUID // Time-based UUID randomly generated each time Burrow is started
 	Logger         *logging.Logger
+	txCodec        txs.Codec
+	exeOptions     []execution.ExecutionOption
+	exeChecker     execution.BatchExecutor
+	exeCommitter   execution.BatchCommitter
+	keyClient      keys.KeyClient
+	keyStore       *keys.KeyStore
 	nodeInfo       string
 	processes      map[string]process.Process
 	shutdownNotify chan struct{}
 	shutdownOnce   sync.Once
 }
 
-func NewBurrowDB(dbDir string) dbm.DB {
+func newBurrowDB(dbDir string) dbm.DB {
 	return dbm.NewDB(BurrowDBName, dbm.GoLevelDBBackend, dbDir)
 }
 
-func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTypes.PrivValidator,
-	genesisDoc *genesis.GenesisDoc, tmConf *tmConfig.Config, rpcConfig *rpc.RPCConfig, keyConfig *keys.KeysConfig,
-	keyStore *keys.KeyStore, exeOptions []execution.ExecutionOption, authorizedPeersProvider abci.PeersFilterProvider, restore string, nodeKey *crypto.PrivateKey, logger *logging.Logger) (*Kernel, error) {
-
-	var err error
-	kern := &Kernel{
+// NewKernel initializes an empty kernel
+func NewKernel() (*Kernel, error) {
+	runID, err := simpleuuid.NewTime(time.Now()) // Create a random ID based on start time
+	if err != nil {
+		return nil, err
+	}
+	return &Kernel{
+		RunID:          runID,
 		processes:      make(map[string]process.Process),
 		shutdownNotify: make(chan struct{}),
-	}
-	// Create a random ID based on start time
-	kern.RunID, err = simpleuuid.NewTime(time.Now())
+		txCodec:        txs.NewAminoCodec(),
+	}, nil
+}
 
-	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey, log.DefaultTimestampUTC,
-		structure.RunId, kern.RunID.String())
-	tendermintLogger := logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+// SetLogger initializes the kernel with the provided logger
+func (kern *Kernel) SetLogger(logger *logging.Logger) {
+	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey,
+		log.DefaultTimestampUTC, structure.RunId, kern.RunID.String())
 	kern.Logger = logger.WithInfo(structure.CallerKey, log.Caller(LoggingCallerDepth))
-	stateDB := NewBurrowDB(tmConf.DBDir())
+	kern.Emitter = event.NewEmitter(kern.Logger)
+}
 
+func (kern *Kernel) LoadBlockchain(genesisDoc *genesis.GenesisDoc, dbDir string) (stateDB dbm.DB, err error) {
+	stateDB = newBurrowDB(dbDir)
 	kern.Blockchain, err = bcm.LoadOrNewBlockchain(stateDB, genesisDoc, kern.Logger)
 	if err != nil {
 		return nil, fmt.Errorf(""error creating or loading blockchain state: %v"", err)
 	}
-
+	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(blockchain.NewBlockStore(stateDB)))
 	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
 	kern.Logger = kern.Logger.With(""height"", heightValuer)
-	tendermintLogger = tendermintLogger.With(""height"", heightValuer)
+	return stateDB, nil
+}
+
+// LoadState starts from scratch or previous chain
+func (kern *Kernel) LoadState(genesisDoc *genesis.GenesisDoc, dbDir string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
+	if err != nil {
+		return err
+	}
 
 	// These should be in sync unless we are at the genesis block
 	if kern.Blockchain.LastBlockHeight() > 0 {
 		kern.Logger.InfoMsg(""Loading application state"")
 		kern.State, err = state.LoadState(stateDB, execution.VersionAtHeight(kern.Blockchain.LastBlockHeight()))
 		if err != nil {
-			return nil, fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
+			return fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
 				kern.Blockchain.AppHashAfterLastBlock(), err)
 		}
 		if !bytes.Equal(kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock()) {
-			return nil, fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
+			return fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
 				""state gives %X, blockchain gives %X"", kern.Blockchain.LastBlockHeight(),
 				kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock())
 		}
-		if restore != """" {
-			return nil, fmt.Errorf(""Cannot restore onto existing chain; don't give --restore-dump argument"")
-		}
 	} else {
 		kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
 		if err != nil {
-			return nil, fmt.Errorf(""could not build genesis state: %v"", err)
+			return fmt.Errorf(""could not build genesis state: %v"", err)
 		}
 
-		if restore != """" {
-			if len(genesisDoc.AppHash) == 0 {
-				return nil, fmt.Errorf(""AppHash is required when restoring chain"")
-			}
+		if err = kern.State.InitialCommit(); err != nil {
+			return err
+		}
+	}
 
-			reader, err := state.NewFileDumpReader(restore)
-			if err != nil {
-				return nil, err
-			}
+	params := execution.ParamsFromGenesis(genesisDoc)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-			err = kern.State.LoadDump(reader)
-			if err != nil {
-				return nil, err
-			}
-		}
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
 
-		err = kern.State.InitialCommit()
-		if err != nil {
-			return nil, err
-		}
+// LoadDump restores chain state from the given dump file
+func (kern *Kernel) LoadDump(genesisDoc *genesis.GenesisDoc, dbDir, restore string) (err error) {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267273719,https://github.com/hyperledger/burrow/pull/1065#discussion_r267273719,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,need to handle error here,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 10:36:47,267274713,"@@ -73,300 +65,305 @@ const (
 // Kernel is the root structure of Burrow
 type Kernel struct {
 	// Expose these public-facing interfaces to allow programmatic extension of the Kernel by other projects
-	Emitter    event.Emitter
-	Service    *rpc.Service
-	Launchers  []process.Launcher
-	State      *state.State
-	Blockchain *bcm.Blockchain
-	Node       *tendermint.Node
-	Transactor *execution.Transactor
-	// Time-based UUID randomly generated each time Burrow is started
-	RunID          simpleuuid.UUID
+	Emitter        event.Emitter
+	Service        *rpc.Service
+	Launchers      []process.Launcher
+	State          *state.State
+	Blockchain     *bcm.Blockchain
+	Node           *tendermint.Node
+	Transactor     *execution.Transactor
+	RunID          simpleuuid.UUID // Time-based UUID randomly generated each time Burrow is started
 	Logger         *logging.Logger
+	txCodec        txs.Codec
+	exeOptions     []execution.ExecutionOption
+	exeChecker     execution.BatchExecutor
+	exeCommitter   execution.BatchCommitter
+	keyClient      keys.KeyClient
+	keyStore       *keys.KeyStore
 	nodeInfo       string
 	processes      map[string]process.Process
 	shutdownNotify chan struct{}
 	shutdownOnce   sync.Once
 }
 
-func NewBurrowDB(dbDir string) dbm.DB {
+func newBurrowDB(dbDir string) dbm.DB {
 	return dbm.NewDB(BurrowDBName, dbm.GoLevelDBBackend, dbDir)
 }
 
-func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTypes.PrivValidator,
-	genesisDoc *genesis.GenesisDoc, tmConf *tmConfig.Config, rpcConfig *rpc.RPCConfig, keyConfig *keys.KeysConfig,
-	keyStore *keys.KeyStore, exeOptions []execution.ExecutionOption, authorizedPeersProvider abci.PeersFilterProvider, restore string, nodeKey *crypto.PrivateKey, logger *logging.Logger) (*Kernel, error) {
-
-	var err error
-	kern := &Kernel{
+// NewKernel initializes an empty kernel
+func NewKernel() (*Kernel, error) {
+	runID, err := simpleuuid.NewTime(time.Now()) // Create a random ID based on start time
+	if err != nil {
+		return nil, err
+	}
+	return &Kernel{
+		RunID:          runID,
 		processes:      make(map[string]process.Process),
 		shutdownNotify: make(chan struct{}),
-	}
-	// Create a random ID based on start time
-	kern.RunID, err = simpleuuid.NewTime(time.Now())
+		txCodec:        txs.NewAminoCodec(),
+	}, nil
+}
 
-	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey, log.DefaultTimestampUTC,
-		structure.RunId, kern.RunID.String())
-	tendermintLogger := logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+// SetLogger initializes the kernel with the provided logger
+func (kern *Kernel) SetLogger(logger *logging.Logger) {
+	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey,
+		log.DefaultTimestampUTC, structure.RunId, kern.RunID.String())
 	kern.Logger = logger.WithInfo(structure.CallerKey, log.Caller(LoggingCallerDepth))
-	stateDB := NewBurrowDB(tmConf.DBDir())
+	kern.Emitter = event.NewEmitter(kern.Logger)
+}
 
+func (kern *Kernel) LoadBlockchain(genesisDoc *genesis.GenesisDoc, dbDir string) (stateDB dbm.DB, err error) {
+	stateDB = newBurrowDB(dbDir)
 	kern.Blockchain, err = bcm.LoadOrNewBlockchain(stateDB, genesisDoc, kern.Logger)
 	if err != nil {
 		return nil, fmt.Errorf(""error creating or loading blockchain state: %v"", err)
 	}
-
+	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(blockchain.NewBlockStore(stateDB)))
 	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
 	kern.Logger = kern.Logger.With(""height"", heightValuer)
-	tendermintLogger = tendermintLogger.With(""height"", heightValuer)
+	return stateDB, nil
+}
+
+// LoadState starts from scratch or previous chain
+func (kern *Kernel) LoadState(genesisDoc *genesis.GenesisDoc, dbDir string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
+	if err != nil {
+		return err
+	}
 
 	// These should be in sync unless we are at the genesis block
 	if kern.Blockchain.LastBlockHeight() > 0 {
 		kern.Logger.InfoMsg(""Loading application state"")
 		kern.State, err = state.LoadState(stateDB, execution.VersionAtHeight(kern.Blockchain.LastBlockHeight()))
 		if err != nil {
-			return nil, fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
+			return fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
 				kern.Blockchain.AppHashAfterLastBlock(), err)
 		}
 		if !bytes.Equal(kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock()) {
-			return nil, fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
+			return fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
 				""state gives %X, blockchain gives %X"", kern.Blockchain.LastBlockHeight(),
 				kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock())
 		}
-		if restore != """" {
-			return nil, fmt.Errorf(""Cannot restore onto existing chain; don't give --restore-dump argument"")
-		}
 	} else {
 		kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
 		if err != nil {
-			return nil, fmt.Errorf(""could not build genesis state: %v"", err)
+			return fmt.Errorf(""could not build genesis state: %v"", err)
 		}
 
-		if restore != """" {
-			if len(genesisDoc.AppHash) == 0 {
-				return nil, fmt.Errorf(""AppHash is required when restoring chain"")
-			}
+		if err = kern.State.InitialCommit(); err != nil {
+			return err
+		}
+	}
 
-			reader, err := state.NewFileDumpReader(restore)
-			if err != nil {
-				return nil, err
-			}
+	params := execution.ParamsFromGenesis(genesisDoc)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-			err = kern.State.LoadDump(reader)
-			if err != nil {
-				return nil, err
-			}
-		}
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
 
-		err = kern.State.InitialCommit()
-		if err != nil {
-			return nil, err
-		}
+// LoadDump restores chain state from the given dump file
+func (kern *Kernel) LoadDump(genesisDoc *genesis.GenesisDoc, dbDir, restore string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
 
-		if len(genesisDoc.AppHash) != 0 {
-			if !bytes.Equal(genesisDoc.AppHash, kern.State.Hash()) {
-				return nil, fmt.Errorf(""AppHash does not match, got AppHash 0x%X expected 0x%s. Is the correct --restore-dump specified?"", kern.State.Hash(), genesisDoc.AppHash.String())
-			}
-		}
+	kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
+	if err != nil {
+		return fmt.Errorf(""could not build genesis state: %v"", err)
 	}
 
-	kern.Logger.InfoMsg(""State loading successful"")
+	if len(kern.Blockchain.GenesisDoc().AppHash) == 0 {
+		return fmt.Errorf(""AppHash is required when restoring chain"")
+	}
+
+	reader, err := state.NewFileDumpReader(restore)
+	if err != nil {
+		return err
+	}
+
+	if err = kern.State.LoadDump(reader); err != nil {
+		return err
+	}
+
+	if err = kern.State.InitialCommit(); err != nil {
+		return err
+	}
 
-	txCodec := txs.NewAminoCodec()
-	tmGenesisDoc := tendermint.DeriveGenesisDoc(genesisDoc)
 	params := execution.ParamsFromGenesis(genesisDoc)
-	checker := execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-	kern.Emitter = event.NewEmitter(kern.Logger)
-	committer := execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, exeOptions...)
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
+
+// GetNodeView builds and returns a wrapper of our tendermint node
+func (kern *Kernel) GetNodeView() (nodeView *tendermint.NodeView, err error) {
+	nodeView, err = tendermint.NewNodeView(kern.Node, kern.txCodec, kern.RunID)
+	return nodeView, err
+}
+
+// AddExecutionOptions extends our execution options
+func (kern *Kernel) AddExecutionOptions(opts ...execution.ExecutionOption) {
+	kern.exeOptions = append(kern.exeOptions, opts...)
+}
+
+// AddProcesses extends the services that we launch at boot
+func (kern *Kernel) AddProcesses(pl ...process.Launcher) {
+	kern.Launchers = append(kern.Launchers, pl...)
+}
+
+func (kern *Kernel) SetKeyClient(client keys.KeyClient) {
+	kern.keyClient = client
+}
+
+func (kern *Kernel) SetKeyStore(store *keys.KeyStore) {
+	kern.keyStore = store
+}
+
+// TendermintFromConfig loads our consensus engine into the kernel
+func (kern *Kernel) TendermintFromConfig(tmConf *tendermint.BurrowTendermintConfig, privVal tmTypes.PrivValidator, validator *crypto.Address) (err error) {
+	if privVal == nil {
+		val, err := keys.AddressableSigner(kern.keyClient, *validator)
+		if err != nil {
+			return fmt.Errorf(""could not get validator addressable from keys client: %v"", err)
+		}
+		signer, err := keys.AddressableSigner(kern.keyClient, val.GetAddress())
+		if err != nil {
+			return err
+		}
+		privVal = tendermint.NewPrivValidatorMemory(val, signer)
+	}
+
+	authorizedPeersProvider := tmConf.DefaultAuthorizedPeersProvider()
 
 	kern.nodeInfo = fmt.Sprintf(""Burrow_%s_%s_ValidatorID:%X"", project.History.CurrentVersion().String(),
-		genesisDoc.ChainID(), privValidator.GetPubKey().Address())
-	app := abci.NewApp(kern.nodeInfo, kern.Blockchain, kern.State, checker, committer, txCodec, authorizedPeersProvider,
-		kern.Panic, logger)
+		kern.Blockchain.ChainID(), privVal.GetPubKey().Address())
+	app := abci.NewApp(kern.nodeInfo, kern.Blockchain, kern.State, kern.exeChecker, kern.exeCommitter, kern.txCodec, authorizedPeersProvider,
+		kern.Panic, kern.Logger)
+
 	// We could use this to provide/register our own metrics (though this will register them with us). Unfortunately
 	// Tendermint currently ignores the metrics passed unless its own server is turned on.
 	metricsProvider := node.DefaultMetricsProvider(&tmConfig.InstrumentationConfig{
 		Prometheus:           false,
 		PrometheusListenAddr: """",
 	})
-	kern.Node, err = tendermint.NewNode(tmConf, privValidator, tmGenesisDoc, app, metricsProvider, nodeKey, tendermintLogger)
-	if err != nil {
-		return nil, err
-	}
 
-	kern.Transactor = execution.NewTransactor(kern.Blockchain, kern.Emitter,
-		execution.NewAccounts(checker, keyClient, AccountsRingMutexCount),
-		kern.Node.MempoolReactor().Mempool.CheckTx, txCodec, kern.Logger)
+	genesisDoc := kern.Blockchain.GenesisDoc()
 
-	nameRegState := kern.State
-	proposalRegState := kern.State
-	accountState := kern.State
-	nodeView, err := tendermint.NewNodeView(kern.Node, txCodec, kern.RunID)
-	if err != nil {
-		return nil, err
+	// find node key
+	var nodeKey *crypto.PrivateKey
+	for _, v := range genesisDoc.Validators {
+		thisAddress, err := crypto.AddressFromHexString(privVal.GetPubKey().Address().String())
+		if err != nil {
+			break
+		}
+		if v.Address == thisAddress && v.NodeAddress != nil {
+			k, err := kern.keyStore.GetKey("""", v.NodeAddress.Bytes())
+			if err == nil {
+				nodeKey = &k.PrivateKey
+			}
+			break
+		}
 	}
-	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(nodeView.BlockStore()))
-	kern.Service = rpc.NewService(accountState, nameRegState, kern.Blockchain, kern.State, nodeView, kern.Logger)
-
-	kern.Launchers = []process.Launcher{
-		{
-			Name:    ""Profiling Server"",
-			Enabled: rpcConfig.Profiler.Enabled,
-			Launch: func() (process.Process, error) {
-				debugServer := &http.Server{
-					Addr: "":6060"",
-				}
-				go func() {
-					err := debugServer.ListenAndServe()
-					if err != nil {
-						kern.Logger.InfoMsg(""Error from pprof debug server"", structure.ErrorKey, err)
-					}
-				}()
-				return debugServer, nil
-			},
-		},
-		{
-			Name:    ""Database"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				// Just close database
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					stateDB.Close()
-					return nil
-				}), nil
-			},
-		},
-		{
-			Name:    ""Tendermint"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				err := kern.Node.Start()
-				if err != nil {
-					return nil, fmt.Errorf(""error starting Tendermint node: %v"", err)
-				}
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					err := kern.Node.Stop()
-					// Close tendermint database connections using our wrapper
-					defer kern.Node.Close()
-					if err != nil {
-						return err
-					}
-					select {
-					case <-ctx.Done():
-						return ctx.Err()
-					case <-kern.Node.Quit():
-						kern.Logger.InfoMsg(""Tendermint Node has quit, closing DB connections..."")
-						return nil
-					}
-					return err
-				}), nil
-			},
-		},
-		// Run announcer after Tendermint so it can get some details
-		{
-			Name:    ""Startup Announcer"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				info := kern.Node.NodeInfo()
-
-				start := time.Now()
-				logger := kern.Logger.With(
-					""launch_time"", start,
-					""burrow_version"", project.FullVersion(),
-					""tendermint_version"", version.TMCoreSemVer,
-					""validator_address"", privValidator.GetPubKey().Address(),
-					""node_id"", string(info.ID()),
-					""net_address"", info.NetAddress().String(),
-					""genesis_app_hash"", genesisDoc.AppHash.String(),
-					""genesis_hash"", hex.EncodeUpperToString(genesisDoc.Hash()),
-				)
-
-				err := logger.InfoMsg(""Burrow is launching. We have marmot-off."", ""announce"", ""startup"")
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					stop := time.Now()
-					return logger.InfoMsg(""Burrow is shutting down. Prepare for re-entrancy."",
-						""announce"", ""shutdown"",
-						""shutdown_time"", stop,
-						""elapsed_run_time"", stop.Sub(start).String())
-				}), err
-			},
-		},
-		{
-			Name:    ""RPC/info"",
-			Enabled: rpcConfig.Info.Enabled,
-			Launch: func() (process.Process, error) {
-				server, err := rpcinfo.StartServer(kern.Service, ""/websocket"", rpcConfig.Info.ListenAddress, kern.Logger)
-				if err != nil {
-					return nil, err
-				}
-				return server, nil
-			},
-		},
-		{
-			Name:    ""RPC/metrics"",
-			Enabled: rpcConfig.Metrics.Enabled,
-			Launch: func() (process.Process, error) {
-				server, err := metrics.StartServer(kern.Service, rpcConfig.Metrics.MetricsPath,
-					rpcConfig.Metrics.ListenAddress, rpcConfig.Metrics.BlockSampleSize, kern.Logger)
-				if err != nil {
-					return nil, err
-				}
-				return server, nil
-			},
-		},
-		{
-			Name:    ""RPC/GRPC"",
-			Enabled: rpcConfig.GRPC.Enabled,
-			Launch: func() (process.Process, error) {
-				listen, err := net.Listen(""tcp"", rpcConfig.GRPC.ListenAddress)
-				if err != nil {
-					return nil, err
-				}
 
-				grpcServer := rpc.NewGRPCServer(kern.Logger)
-				var ks *keys.KeyStore
-				if keyStore != nil {
-					ks = keyStore
-				}
-
-				if keyConfig.GRPCServiceEnabled {
-					if keyStore == nil {
-						ks = keys.NewKeyStore(keyConfig.KeysDirectory, keyConfig.AllowBadFilePermissions)
-					}
-					keys.RegisterKeysServer(grpcServer, ks)
-				}
+	tmGenesisDoc := tendermint.DeriveGenesisDoc(&genesisDoc)
+	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
+	tmLogger := kern.Logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+	tmLogger = tmLogger.With(""height"", heightValuer)
+	kern.Node, err = tendermint.NewNode(tmConf.TendermintConfig(), privVal, tmGenesisDoc, app, metricsProvider, nodeKey, tmLogger)
+	return err
+}
 
-				rpcquery.RegisterQueryServer(grpcServer, rpcquery.NewQueryServer(kern.State, nameRegState, proposalRegState,
-					kern.Blockchain, kern.State, nodeView, kern.Logger))
+func (kern *Kernel) LoadTransactor() (err error) {
+	nodeView, err := kern.GetNodeView()
+	if err != nil {
+		return err
+	}
 
-				rpctransact.RegisterTransactServer(grpcServer, rpctransact.NewTransactServer(kern.Transactor, txCodec))
+	accountState := kern.State
+	nameRegState := kern.State
+	kern.Service = rpc.NewService(accountState, nameRegState, kern.Blockchain, kern.State, nodeView, kern.Logger)
 
-				rpcevents.RegisterExecutionEventsServer(grpcServer, rpcevents.NewExecutionEventsServer(kern.State,
-					kern.Emitter, kern.Blockchain, kern.Logger))
+	if nodeView == nil {
+		checkTx := func(tx tmTypes.Tx, cb func(*abciTypes.Response)) error {
+			ctx := abci.TxExecutor(""CheckTx"", kern.exeChecker, kern.txCodec, kern.Logger.WithScope(""CheckTx""))(tx)
+			dtx := abci.TxExecutor(""DeliverTx"", kern.exeCommitter, kern.txCodec, kern.Logger.WithScope(""DeliverTx""))(tx)
+			appHash, err := kern.exeCommitter.Commit(nil)
+			if err != nil {
+				return err
+			}
+			kern.Blockchain.CommitBlock(time.Now(), nil, appHash)",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267274713,https://github.com/hyperledger/burrow/pull/1065#discussion_r267274713,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,"I'm just wondering if it worth introducing a little type that wraps this up:

```go
type TxExecutor {
	checker execution.BatchExecutor
	deliverer execution.BatchExecutor
	txDecoder txs.Decoder
	logger *logging.Logger
}

func (txx TxExecutor) CheckTx(txBytes []byte) abciTypes.ResponseCheckTx {
	return txx.execute(""CheckTx"", txx.checker, txBytes)
}

func (txx TxExecutor) DeliverTx(txBytes []byte) abciTypes.ResponseDeliverTx {
	ctr := txx.execute(""DeliverTx"", txx.deliverer, txBytes)
	return abciTypes.ResponseDeliverTx{
		Code:      ctr.Code,
		Log:       ctr.Log,
		Data:      ctr.Data,
		Tags:      ctr.Tags,
		GasUsed:   ctr.GasUsed,
		GasWanted: ctr.GasWanted,
		Info:      ctr.Info,
	}
}

func execute(name string, executor execution.BatchExecutor, txBytes []byte) {
...
}
```
Then we can just embed that in `App` and reuse in kernel",9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 11:07:45,267286092,"@@ -73,300 +65,305 @@ const (
 // Kernel is the root structure of Burrow
 type Kernel struct {
 	// Expose these public-facing interfaces to allow programmatic extension of the Kernel by other projects
-	Emitter    event.Emitter
-	Service    *rpc.Service
-	Launchers  []process.Launcher
-	State      *state.State
-	Blockchain *bcm.Blockchain
-	Node       *tendermint.Node
-	Transactor *execution.Transactor
-	// Time-based UUID randomly generated each time Burrow is started
-	RunID          simpleuuid.UUID
+	Emitter        event.Emitter
+	Service        *rpc.Service
+	Launchers      []process.Launcher
+	State          *state.State
+	Blockchain     *bcm.Blockchain
+	Node           *tendermint.Node
+	Transactor     *execution.Transactor
+	RunID          simpleuuid.UUID // Time-based UUID randomly generated each time Burrow is started
 	Logger         *logging.Logger
+	txCodec        txs.Codec
+	exeOptions     []execution.ExecutionOption
+	exeChecker     execution.BatchExecutor
+	exeCommitter   execution.BatchCommitter
+	keyClient      keys.KeyClient
+	keyStore       *keys.KeyStore
 	nodeInfo       string
 	processes      map[string]process.Process
 	shutdownNotify chan struct{}
 	shutdownOnce   sync.Once
 }
 
-func NewBurrowDB(dbDir string) dbm.DB {
+func newBurrowDB(dbDir string) dbm.DB {
 	return dbm.NewDB(BurrowDBName, dbm.GoLevelDBBackend, dbDir)
 }
 
-func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTypes.PrivValidator,
-	genesisDoc *genesis.GenesisDoc, tmConf *tmConfig.Config, rpcConfig *rpc.RPCConfig, keyConfig *keys.KeysConfig,
-	keyStore *keys.KeyStore, exeOptions []execution.ExecutionOption, authorizedPeersProvider abci.PeersFilterProvider, restore string, nodeKey *crypto.PrivateKey, logger *logging.Logger) (*Kernel, error) {
-
-	var err error
-	kern := &Kernel{
+// NewKernel initializes an empty kernel
+func NewKernel() (*Kernel, error) {
+	runID, err := simpleuuid.NewTime(time.Now()) // Create a random ID based on start time
+	if err != nil {
+		return nil, err
+	}
+	return &Kernel{
+		RunID:          runID,
 		processes:      make(map[string]process.Process),
 		shutdownNotify: make(chan struct{}),
-	}
-	// Create a random ID based on start time
-	kern.RunID, err = simpleuuid.NewTime(time.Now())
+		txCodec:        txs.NewAminoCodec(),
+	}, nil
+}
 
-	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey, log.DefaultTimestampUTC,
-		structure.RunId, kern.RunID.String())
-	tendermintLogger := logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+// SetLogger initializes the kernel with the provided logger
+func (kern *Kernel) SetLogger(logger *logging.Logger) {
+	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey,
+		log.DefaultTimestampUTC, structure.RunId, kern.RunID.String())
 	kern.Logger = logger.WithInfo(structure.CallerKey, log.Caller(LoggingCallerDepth))
-	stateDB := NewBurrowDB(tmConf.DBDir())
+	kern.Emitter = event.NewEmitter(kern.Logger)
+}
 
+func (kern *Kernel) LoadBlockchain(genesisDoc *genesis.GenesisDoc, dbDir string) (stateDB dbm.DB, err error) {
+	stateDB = newBurrowDB(dbDir)
 	kern.Blockchain, err = bcm.LoadOrNewBlockchain(stateDB, genesisDoc, kern.Logger)
 	if err != nil {
 		return nil, fmt.Errorf(""error creating or loading blockchain state: %v"", err)
 	}
-
+	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(blockchain.NewBlockStore(stateDB)))
 	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
 	kern.Logger = kern.Logger.With(""height"", heightValuer)
-	tendermintLogger = tendermintLogger.With(""height"", heightValuer)
+	return stateDB, nil
+}
+
+// LoadState starts from scratch or previous chain
+func (kern *Kernel) LoadState(genesisDoc *genesis.GenesisDoc, dbDir string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
+	if err != nil {
+		return err
+	}
 
 	// These should be in sync unless we are at the genesis block
 	if kern.Blockchain.LastBlockHeight() > 0 {
 		kern.Logger.InfoMsg(""Loading application state"")
 		kern.State, err = state.LoadState(stateDB, execution.VersionAtHeight(kern.Blockchain.LastBlockHeight()))
 		if err != nil {
-			return nil, fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
+			return fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
 				kern.Blockchain.AppHashAfterLastBlock(), err)
 		}
 		if !bytes.Equal(kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock()) {
-			return nil, fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
+			return fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
 				""state gives %X, blockchain gives %X"", kern.Blockchain.LastBlockHeight(),
 				kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock())
 		}
-		if restore != """" {
-			return nil, fmt.Errorf(""Cannot restore onto existing chain; don't give --restore-dump argument"")
-		}
 	} else {
 		kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
 		if err != nil {
-			return nil, fmt.Errorf(""could not build genesis state: %v"", err)
+			return fmt.Errorf(""could not build genesis state: %v"", err)
 		}
 
-		if restore != """" {
-			if len(genesisDoc.AppHash) == 0 {
-				return nil, fmt.Errorf(""AppHash is required when restoring chain"")
-			}
+		if err = kern.State.InitialCommit(); err != nil {
+			return err
+		}
+	}
 
-			reader, err := state.NewFileDumpReader(restore)
-			if err != nil {
-				return nil, err
-			}
+	params := execution.ParamsFromGenesis(genesisDoc)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-			err = kern.State.LoadDump(reader)
-			if err != nil {
-				return nil, err
-			}
-		}
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
 
-		err = kern.State.InitialCommit()
-		if err != nil {
-			return nil, err
-		}
+// LoadDump restores chain state from the given dump file
+func (kern *Kernel) LoadDump(genesisDoc *genesis.GenesisDoc, dbDir, restore string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
 
-		if len(genesisDoc.AppHash) != 0 {
-			if !bytes.Equal(genesisDoc.AppHash, kern.State.Hash()) {
-				return nil, fmt.Errorf(""AppHash does not match, got AppHash 0x%X expected 0x%s. Is the correct --restore-dump specified?"", kern.State.Hash(), genesisDoc.AppHash.String())
-			}
-		}
+	kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
+	if err != nil {
+		return fmt.Errorf(""could not build genesis state: %v"", err)
 	}
 
-	kern.Logger.InfoMsg(""State loading successful"")
+	if len(kern.Blockchain.GenesisDoc().AppHash) == 0 {
+		return fmt.Errorf(""AppHash is required when restoring chain"")
+	}
+
+	reader, err := state.NewFileDumpReader(restore)
+	if err != nil {
+		return err
+	}
+
+	if err = kern.State.LoadDump(reader); err != nil {
+		return err
+	}
+
+	if err = kern.State.InitialCommit(); err != nil {
+		return err
+	}
 
-	txCodec := txs.NewAminoCodec()
-	tmGenesisDoc := tendermint.DeriveGenesisDoc(genesisDoc)
 	params := execution.ParamsFromGenesis(genesisDoc)
-	checker := execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-	kern.Emitter = event.NewEmitter(kern.Logger)
-	committer := execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, exeOptions...)
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
+
+// GetNodeView builds and returns a wrapper of our tendermint node
+func (kern *Kernel) GetNodeView() (nodeView *tendermint.NodeView, err error) {
+	nodeView, err = tendermint.NewNodeView(kern.Node, kern.txCodec, kern.RunID)
+	return nodeView, err
+}
+
+// AddExecutionOptions extends our execution options
+func (kern *Kernel) AddExecutionOptions(opts ...execution.ExecutionOption) {
+	kern.exeOptions = append(kern.exeOptions, opts...)
+}
+
+// AddProcesses extends the services that we launch at boot
+func (kern *Kernel) AddProcesses(pl ...process.Launcher) {
+	kern.Launchers = append(kern.Launchers, pl...)
+}
+
+func (kern *Kernel) SetKeyClient(client keys.KeyClient) {
+	kern.keyClient = client
+}
+
+func (kern *Kernel) SetKeyStore(store *keys.KeyStore) {
+	kern.keyStore = store
+}
+
+// TendermintFromConfig loads our consensus engine into the kernel
+func (kern *Kernel) TendermintFromConfig(tmConf *tendermint.BurrowTendermintConfig, privVal tmTypes.PrivValidator, validator *crypto.Address) (err error) {
+	if privVal == nil {
+		val, err := keys.AddressableSigner(kern.keyClient, *validator)
+		if err != nil {
+			return fmt.Errorf(""could not get validator addressable from keys client: %v"", err)
+		}
+		signer, err := keys.AddressableSigner(kern.keyClient, val.GetAddress())
+		if err != nil {
+			return err
+		}
+		privVal = tendermint.NewPrivValidatorMemory(val, signer)
+	}
+
+	authorizedPeersProvider := tmConf.DefaultAuthorizedPeersProvider()
 
 	kern.nodeInfo = fmt.Sprintf(""Burrow_%s_%s_ValidatorID:%X"", project.History.CurrentVersion().String(),
-		genesisDoc.ChainID(), privValidator.GetPubKey().Address())
-	app := abci.NewApp(kern.nodeInfo, kern.Blockchain, kern.State, checker, committer, txCodec, authorizedPeersProvider,
-		kern.Panic, logger)
+		kern.Blockchain.ChainID(), privVal.GetPubKey().Address())
+	app := abci.NewApp(kern.nodeInfo, kern.Blockchain, kern.State, kern.exeChecker, kern.exeCommitter, kern.txCodec, authorizedPeersProvider,
+		kern.Panic, kern.Logger)
+
 	// We could use this to provide/register our own metrics (though this will register them with us). Unfortunately
 	// Tendermint currently ignores the metrics passed unless its own server is turned on.
 	metricsProvider := node.DefaultMetricsProvider(&tmConfig.InstrumentationConfig{
 		Prometheus:           false,
 		PrometheusListenAddr: """",
 	})
-	kern.Node, err = tendermint.NewNode(tmConf, privValidator, tmGenesisDoc, app, metricsProvider, nodeKey, tendermintLogger)
-	if err != nil {
-		return nil, err
-	}
 
-	kern.Transactor = execution.NewTransactor(kern.Blockchain, kern.Emitter,
-		execution.NewAccounts(checker, keyClient, AccountsRingMutexCount),
-		kern.Node.MempoolReactor().Mempool.CheckTx, txCodec, kern.Logger)
+	genesisDoc := kern.Blockchain.GenesisDoc()
 
-	nameRegState := kern.State
-	proposalRegState := kern.State
-	accountState := kern.State
-	nodeView, err := tendermint.NewNodeView(kern.Node, txCodec, kern.RunID)
-	if err != nil {
-		return nil, err
+	// find node key
+	var nodeKey *crypto.PrivateKey
+	for _, v := range genesisDoc.Validators {
+		thisAddress, err := crypto.AddressFromHexString(privVal.GetPubKey().Address().String())
+		if err != nil {
+			break
+		}
+		if v.Address == thisAddress && v.NodeAddress != nil {
+			k, err := kern.keyStore.GetKey("""", v.NodeAddress.Bytes())
+			if err == nil {
+				nodeKey = &k.PrivateKey
+			}
+			break
+		}
 	}
-	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(nodeView.BlockStore()))
-	kern.Service = rpc.NewService(accountState, nameRegState, kern.Blockchain, kern.State, nodeView, kern.Logger)
-
-	kern.Launchers = []process.Launcher{
-		{
-			Name:    ""Profiling Server"",
-			Enabled: rpcConfig.Profiler.Enabled,
-			Launch: func() (process.Process, error) {
-				debugServer := &http.Server{
-					Addr: "":6060"",
-				}
-				go func() {
-					err := debugServer.ListenAndServe()
-					if err != nil {
-						kern.Logger.InfoMsg(""Error from pprof debug server"", structure.ErrorKey, err)
-					}
-				}()
-				return debugServer, nil
-			},
-		},
-		{
-			Name:    ""Database"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				// Just close database
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					stateDB.Close()
-					return nil
-				}), nil
-			},
-		},
-		{
-			Name:    ""Tendermint"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				err := kern.Node.Start()
-				if err != nil {
-					return nil, fmt.Errorf(""error starting Tendermint node: %v"", err)
-				}
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					err := kern.Node.Stop()
-					// Close tendermint database connections using our wrapper
-					defer kern.Node.Close()
-					if err != nil {
-						return err
-					}
-					select {
-					case <-ctx.Done():
-						return ctx.Err()
-					case <-kern.Node.Quit():
-						kern.Logger.InfoMsg(""Tendermint Node has quit, closing DB connections..."")
-						return nil
-					}
-					return err
-				}), nil
-			},
-		},
-		// Run announcer after Tendermint so it can get some details
-		{
-			Name:    ""Startup Announcer"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				info := kern.Node.NodeInfo()
-
-				start := time.Now()
-				logger := kern.Logger.With(
-					""launch_time"", start,
-					""burrow_version"", project.FullVersion(),
-					""tendermint_version"", version.TMCoreSemVer,
-					""validator_address"", privValidator.GetPubKey().Address(),
-					""node_id"", string(info.ID()),
-					""net_address"", info.NetAddress().String(),
-					""genesis_app_hash"", genesisDoc.AppHash.String(),
-					""genesis_hash"", hex.EncodeUpperToString(genesisDoc.Hash()),
-				)
-
-				err := logger.InfoMsg(""Burrow is launching. We have marmot-off."", ""announce"", ""startup"")
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					stop := time.Now()
-					return logger.InfoMsg(""Burrow is shutting down. Prepare for re-entrancy."",
-						""announce"", ""shutdown"",
-						""shutdown_time"", stop,
-						""elapsed_run_time"", stop.Sub(start).String())
-				}), err
-			},
-		},
-		{
-			Name:    ""RPC/info"",
-			Enabled: rpcConfig.Info.Enabled,
-			Launch: func() (process.Process, error) {
-				server, err := rpcinfo.StartServer(kern.Service, ""/websocket"", rpcConfig.Info.ListenAddress, kern.Logger)
-				if err != nil {
-					return nil, err
-				}
-				return server, nil
-			},
-		},
-		{
-			Name:    ""RPC/metrics"",
-			Enabled: rpcConfig.Metrics.Enabled,
-			Launch: func() (process.Process, error) {
-				server, err := metrics.StartServer(kern.Service, rpcConfig.Metrics.MetricsPath,
-					rpcConfig.Metrics.ListenAddress, rpcConfig.Metrics.BlockSampleSize, kern.Logger)
-				if err != nil {
-					return nil, err
-				}
-				return server, nil
-			},
-		},
-		{
-			Name:    ""RPC/GRPC"",
-			Enabled: rpcConfig.GRPC.Enabled,
-			Launch: func() (process.Process, error) {
-				listen, err := net.Listen(""tcp"", rpcConfig.GRPC.ListenAddress)
-				if err != nil {
-					return nil, err
-				}
 
-				grpcServer := rpc.NewGRPCServer(kern.Logger)
-				var ks *keys.KeyStore
-				if keyStore != nil {
-					ks = keyStore
-				}
-
-				if keyConfig.GRPCServiceEnabled {
-					if keyStore == nil {
-						ks = keys.NewKeyStore(keyConfig.KeysDirectory, keyConfig.AllowBadFilePermissions)
-					}
-					keys.RegisterKeysServer(grpcServer, ks)
-				}
+	tmGenesisDoc := tendermint.DeriveGenesisDoc(&genesisDoc)
+	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
+	tmLogger := kern.Logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+	tmLogger = tmLogger.With(""height"", heightValuer)
+	kern.Node, err = tendermint.NewNode(tmConf.TendermintConfig(), privVal, tmGenesisDoc, app, metricsProvider, nodeKey, tmLogger)
+	return err
+}
 
-				rpcquery.RegisterQueryServer(grpcServer, rpcquery.NewQueryServer(kern.State, nameRegState, proposalRegState,
-					kern.Blockchain, kern.State, nodeView, kern.Logger))
+func (kern *Kernel) LoadTransactor() (err error) {
+	nodeView, err := kern.GetNodeView()
+	if err != nil {
+		return err
+	}
 
-				rpctransact.RegisterTransactServer(grpcServer, rpctransact.NewTransactServer(kern.Transactor, txCodec))
+	accountState := kern.State
+	nameRegState := kern.State
+	kern.Service = rpc.NewService(accountState, nameRegState, kern.Blockchain, kern.State, nodeView, kern.Logger)
 
-				rpcevents.RegisterExecutionEventsServer(grpcServer, rpcevents.NewExecutionEventsServer(kern.State,
-					kern.Emitter, kern.Blockchain, kern.Logger))
+	if nodeView == nil {
+		checkTx := func(tx tmTypes.Tx, cb func(*abciTypes.Response)) error {
+			ctx := abci.TxExecutor(""CheckTx"", kern.exeChecker, kern.txCodec, kern.Logger.WithScope(""CheckTx""))(tx)
+			dtx := abci.TxExecutor(""DeliverTx"", kern.exeCommitter, kern.txCodec, kern.Logger.WithScope(""DeliverTx""))(tx)
+			appHash, err := kern.exeCommitter.Commit(nil)
+			if err != nil {
+				return err
+			}
+			kern.Blockchain.CommitBlock(time.Now(), nil, appHash)
+
+			cb(abciTypes.ToResponseCheckTx(ctx))
+			cb(abciTypes.ToResponseDeliverTx(abciTypes.ResponseDeliverTx{",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267286092,https://github.com/hyperledger/burrow/pull/1065#discussion_r267286092,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,Superceded by suggestion above perhaps but let's not use `ctx` it's the idiomatic name for `context.Context` variables,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 11:08:18,267286270,"@@ -73,300 +65,305 @@ const (
 // Kernel is the root structure of Burrow
 type Kernel struct {
 	// Expose these public-facing interfaces to allow programmatic extension of the Kernel by other projects
-	Emitter    event.Emitter
-	Service    *rpc.Service
-	Launchers  []process.Launcher
-	State      *state.State
-	Blockchain *bcm.Blockchain
-	Node       *tendermint.Node
-	Transactor *execution.Transactor
-	// Time-based UUID randomly generated each time Burrow is started
-	RunID          simpleuuid.UUID
+	Emitter        event.Emitter
+	Service        *rpc.Service
+	Launchers      []process.Launcher
+	State          *state.State
+	Blockchain     *bcm.Blockchain
+	Node           *tendermint.Node
+	Transactor     *execution.Transactor
+	RunID          simpleuuid.UUID // Time-based UUID randomly generated each time Burrow is started
 	Logger         *logging.Logger
+	txCodec        txs.Codec
+	exeOptions     []execution.ExecutionOption
+	exeChecker     execution.BatchExecutor
+	exeCommitter   execution.BatchCommitter
+	keyClient      keys.KeyClient
+	keyStore       *keys.KeyStore
 	nodeInfo       string
 	processes      map[string]process.Process
 	shutdownNotify chan struct{}
 	shutdownOnce   sync.Once
 }
 
-func NewBurrowDB(dbDir string) dbm.DB {
+func newBurrowDB(dbDir string) dbm.DB {
 	return dbm.NewDB(BurrowDBName, dbm.GoLevelDBBackend, dbDir)
 }
 
-func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTypes.PrivValidator,
-	genesisDoc *genesis.GenesisDoc, tmConf *tmConfig.Config, rpcConfig *rpc.RPCConfig, keyConfig *keys.KeysConfig,
-	keyStore *keys.KeyStore, exeOptions []execution.ExecutionOption, authorizedPeersProvider abci.PeersFilterProvider, restore string, nodeKey *crypto.PrivateKey, logger *logging.Logger) (*Kernel, error) {
-
-	var err error
-	kern := &Kernel{
+// NewKernel initializes an empty kernel
+func NewKernel() (*Kernel, error) {
+	runID, err := simpleuuid.NewTime(time.Now()) // Create a random ID based on start time
+	if err != nil {
+		return nil, err
+	}
+	return &Kernel{
+		RunID:          runID,
 		processes:      make(map[string]process.Process),
 		shutdownNotify: make(chan struct{}),
-	}
-	// Create a random ID based on start time
-	kern.RunID, err = simpleuuid.NewTime(time.Now())
+		txCodec:        txs.NewAminoCodec(),
+	}, nil
+}
 
-	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey, log.DefaultTimestampUTC,
-		structure.RunId, kern.RunID.String())
-	tendermintLogger := logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+// SetLogger initializes the kernel with the provided logger
+func (kern *Kernel) SetLogger(logger *logging.Logger) {
+	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey,
+		log.DefaultTimestampUTC, structure.RunId, kern.RunID.String())
 	kern.Logger = logger.WithInfo(structure.CallerKey, log.Caller(LoggingCallerDepth))
-	stateDB := NewBurrowDB(tmConf.DBDir())
+	kern.Emitter = event.NewEmitter(kern.Logger)
+}
 
+func (kern *Kernel) LoadBlockchain(genesisDoc *genesis.GenesisDoc, dbDir string) (stateDB dbm.DB, err error) {
+	stateDB = newBurrowDB(dbDir)
 	kern.Blockchain, err = bcm.LoadOrNewBlockchain(stateDB, genesisDoc, kern.Logger)
 	if err != nil {
 		return nil, fmt.Errorf(""error creating or loading blockchain state: %v"", err)
 	}
-
+	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(blockchain.NewBlockStore(stateDB)))
 	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
 	kern.Logger = kern.Logger.With(""height"", heightValuer)
-	tendermintLogger = tendermintLogger.With(""height"", heightValuer)
+	return stateDB, nil
+}
+
+// LoadState starts from scratch or previous chain
+func (kern *Kernel) LoadState(genesisDoc *genesis.GenesisDoc, dbDir string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
+	if err != nil {
+		return err
+	}
 
 	// These should be in sync unless we are at the genesis block
 	if kern.Blockchain.LastBlockHeight() > 0 {
 		kern.Logger.InfoMsg(""Loading application state"")
 		kern.State, err = state.LoadState(stateDB, execution.VersionAtHeight(kern.Blockchain.LastBlockHeight()))
 		if err != nil {
-			return nil, fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
+			return fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
 				kern.Blockchain.AppHashAfterLastBlock(), err)
 		}
 		if !bytes.Equal(kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock()) {
-			return nil, fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
+			return fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
 				""state gives %X, blockchain gives %X"", kern.Blockchain.LastBlockHeight(),
 				kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock())
 		}
-		if restore != """" {
-			return nil, fmt.Errorf(""Cannot restore onto existing chain; don't give --restore-dump argument"")
-		}
 	} else {
 		kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
 		if err != nil {
-			return nil, fmt.Errorf(""could not build genesis state: %v"", err)
+			return fmt.Errorf(""could not build genesis state: %v"", err)
 		}
 
-		if restore != """" {
-			if len(genesisDoc.AppHash) == 0 {
-				return nil, fmt.Errorf(""AppHash is required when restoring chain"")
-			}
+		if err = kern.State.InitialCommit(); err != nil {
+			return err
+		}
+	}
 
-			reader, err := state.NewFileDumpReader(restore)
-			if err != nil {
-				return nil, err
-			}
+	params := execution.ParamsFromGenesis(genesisDoc)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-			err = kern.State.LoadDump(reader)
-			if err != nil {
-				return nil, err
-			}
-		}
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
 
-		err = kern.State.InitialCommit()
-		if err != nil {
-			return nil, err
-		}
+// LoadDump restores chain state from the given dump file
+func (kern *Kernel) LoadDump(genesisDoc *genesis.GenesisDoc, dbDir, restore string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
 
-		if len(genesisDoc.AppHash) != 0 {
-			if !bytes.Equal(genesisDoc.AppHash, kern.State.Hash()) {
-				return nil, fmt.Errorf(""AppHash does not match, got AppHash 0x%X expected 0x%s. Is the correct --restore-dump specified?"", kern.State.Hash(), genesisDoc.AppHash.String())
-			}
-		}
+	kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
+	if err != nil {
+		return fmt.Errorf(""could not build genesis state: %v"", err)
 	}
 
-	kern.Logger.InfoMsg(""State loading successful"")
+	if len(kern.Blockchain.GenesisDoc().AppHash) == 0 {
+		return fmt.Errorf(""AppHash is required when restoring chain"")
+	}
+
+	reader, err := state.NewFileDumpReader(restore)
+	if err != nil {
+		return err
+	}
+
+	if err = kern.State.LoadDump(reader); err != nil {
+		return err
+	}
+
+	if err = kern.State.InitialCommit(); err != nil {
+		return err
+	}
 
-	txCodec := txs.NewAminoCodec()
-	tmGenesisDoc := tendermint.DeriveGenesisDoc(genesisDoc)
 	params := execution.ParamsFromGenesis(genesisDoc)
-	checker := execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-	kern.Emitter = event.NewEmitter(kern.Logger)
-	committer := execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, exeOptions...)
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
+
+// GetNodeView builds and returns a wrapper of our tendermint node
+func (kern *Kernel) GetNodeView() (nodeView *tendermint.NodeView, err error) {
+	nodeView, err = tendermint.NewNodeView(kern.Node, kern.txCodec, kern.RunID)
+	return nodeView, err
+}
+
+// AddExecutionOptions extends our execution options
+func (kern *Kernel) AddExecutionOptions(opts ...execution.ExecutionOption) {
+	kern.exeOptions = append(kern.exeOptions, opts...)
+}
+
+// AddProcesses extends the services that we launch at boot
+func (kern *Kernel) AddProcesses(pl ...process.Launcher) {
+	kern.Launchers = append(kern.Launchers, pl...)
+}
+
+func (kern *Kernel) SetKeyClient(client keys.KeyClient) {
+	kern.keyClient = client
+}
+
+func (kern *Kernel) SetKeyStore(store *keys.KeyStore) {
+	kern.keyStore = store
+}
+
+// TendermintFromConfig loads our consensus engine into the kernel
+func (kern *Kernel) TendermintFromConfig(tmConf *tendermint.BurrowTendermintConfig, privVal tmTypes.PrivValidator, validator *crypto.Address) (err error) {
+	if privVal == nil {
+		val, err := keys.AddressableSigner(kern.keyClient, *validator)
+		if err != nil {
+			return fmt.Errorf(""could not get validator addressable from keys client: %v"", err)
+		}
+		signer, err := keys.AddressableSigner(kern.keyClient, val.GetAddress())
+		if err != nil {
+			return err
+		}
+		privVal = tendermint.NewPrivValidatorMemory(val, signer)
+	}
+
+	authorizedPeersProvider := tmConf.DefaultAuthorizedPeersProvider()
 
 	kern.nodeInfo = fmt.Sprintf(""Burrow_%s_%s_ValidatorID:%X"", project.History.CurrentVersion().String(),
-		genesisDoc.ChainID(), privValidator.GetPubKey().Address())
-	app := abci.NewApp(kern.nodeInfo, kern.Blockchain, kern.State, checker, committer, txCodec, authorizedPeersProvider,
-		kern.Panic, logger)
+		kern.Blockchain.ChainID(), privVal.GetPubKey().Address())
+	app := abci.NewApp(kern.nodeInfo, kern.Blockchain, kern.State, kern.exeChecker, kern.exeCommitter, kern.txCodec, authorizedPeersProvider,
+		kern.Panic, kern.Logger)
+
 	// We could use this to provide/register our own metrics (though this will register them with us). Unfortunately
 	// Tendermint currently ignores the metrics passed unless its own server is turned on.
 	metricsProvider := node.DefaultMetricsProvider(&tmConfig.InstrumentationConfig{
 		Prometheus:           false,
 		PrometheusListenAddr: """",
 	})
-	kern.Node, err = tendermint.NewNode(tmConf, privValidator, tmGenesisDoc, app, metricsProvider, nodeKey, tendermintLogger)
-	if err != nil {
-		return nil, err
-	}
 
-	kern.Transactor = execution.NewTransactor(kern.Blockchain, kern.Emitter,
-		execution.NewAccounts(checker, keyClient, AccountsRingMutexCount),
-		kern.Node.MempoolReactor().Mempool.CheckTx, txCodec, kern.Logger)
+	genesisDoc := kern.Blockchain.GenesisDoc()
 
-	nameRegState := kern.State
-	proposalRegState := kern.State
-	accountState := kern.State
-	nodeView, err := tendermint.NewNodeView(kern.Node, txCodec, kern.RunID)
-	if err != nil {
-		return nil, err
+	// find node key
+	var nodeKey *crypto.PrivateKey
+	for _, v := range genesisDoc.Validators {
+		thisAddress, err := crypto.AddressFromHexString(privVal.GetPubKey().Address().String())
+		if err != nil {
+			break
+		}
+		if v.Address == thisAddress && v.NodeAddress != nil {
+			k, err := kern.keyStore.GetKey("""", v.NodeAddress.Bytes())
+			if err == nil {
+				nodeKey = &k.PrivateKey
+			}
+			break
+		}
 	}
-	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(nodeView.BlockStore()))
-	kern.Service = rpc.NewService(accountState, nameRegState, kern.Blockchain, kern.State, nodeView, kern.Logger)
-
-	kern.Launchers = []process.Launcher{
-		{
-			Name:    ""Profiling Server"",
-			Enabled: rpcConfig.Profiler.Enabled,
-			Launch: func() (process.Process, error) {
-				debugServer := &http.Server{
-					Addr: "":6060"",
-				}
-				go func() {
-					err := debugServer.ListenAndServe()
-					if err != nil {
-						kern.Logger.InfoMsg(""Error from pprof debug server"", structure.ErrorKey, err)
-					}
-				}()
-				return debugServer, nil
-			},
-		},
-		{
-			Name:    ""Database"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				// Just close database
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					stateDB.Close()
-					return nil
-				}), nil
-			},
-		},
-		{
-			Name:    ""Tendermint"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				err := kern.Node.Start()
-				if err != nil {
-					return nil, fmt.Errorf(""error starting Tendermint node: %v"", err)
-				}
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					err := kern.Node.Stop()
-					// Close tendermint database connections using our wrapper
-					defer kern.Node.Close()
-					if err != nil {
-						return err
-					}
-					select {
-					case <-ctx.Done():
-						return ctx.Err()
-					case <-kern.Node.Quit():
-						kern.Logger.InfoMsg(""Tendermint Node has quit, closing DB connections..."")
-						return nil
-					}
-					return err
-				}), nil
-			},
-		},
-		// Run announcer after Tendermint so it can get some details
-		{
-			Name:    ""Startup Announcer"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				info := kern.Node.NodeInfo()
-
-				start := time.Now()
-				logger := kern.Logger.With(
-					""launch_time"", start,
-					""burrow_version"", project.FullVersion(),
-					""tendermint_version"", version.TMCoreSemVer,
-					""validator_address"", privValidator.GetPubKey().Address(),
-					""node_id"", string(info.ID()),
-					""net_address"", info.NetAddress().String(),
-					""genesis_app_hash"", genesisDoc.AppHash.String(),
-					""genesis_hash"", hex.EncodeUpperToString(genesisDoc.Hash()),
-				)
-
-				err := logger.InfoMsg(""Burrow is launching. We have marmot-off."", ""announce"", ""startup"")
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					stop := time.Now()
-					return logger.InfoMsg(""Burrow is shutting down. Prepare for re-entrancy."",
-						""announce"", ""shutdown"",
-						""shutdown_time"", stop,
-						""elapsed_run_time"", stop.Sub(start).String())
-				}), err
-			},
-		},
-		{
-			Name:    ""RPC/info"",
-			Enabled: rpcConfig.Info.Enabled,
-			Launch: func() (process.Process, error) {
-				server, err := rpcinfo.StartServer(kern.Service, ""/websocket"", rpcConfig.Info.ListenAddress, kern.Logger)
-				if err != nil {
-					return nil, err
-				}
-				return server, nil
-			},
-		},
-		{
-			Name:    ""RPC/metrics"",
-			Enabled: rpcConfig.Metrics.Enabled,
-			Launch: func() (process.Process, error) {
-				server, err := metrics.StartServer(kern.Service, rpcConfig.Metrics.MetricsPath,
-					rpcConfig.Metrics.ListenAddress, rpcConfig.Metrics.BlockSampleSize, kern.Logger)
-				if err != nil {
-					return nil, err
-				}
-				return server, nil
-			},
-		},
-		{
-			Name:    ""RPC/GRPC"",
-			Enabled: rpcConfig.GRPC.Enabled,
-			Launch: func() (process.Process, error) {
-				listen, err := net.Listen(""tcp"", rpcConfig.GRPC.ListenAddress)
-				if err != nil {
-					return nil, err
-				}
 
-				grpcServer := rpc.NewGRPCServer(kern.Logger)
-				var ks *keys.KeyStore
-				if keyStore != nil {
-					ks = keyStore
-				}
-
-				if keyConfig.GRPCServiceEnabled {
-					if keyStore == nil {
-						ks = keys.NewKeyStore(keyConfig.KeysDirectory, keyConfig.AllowBadFilePermissions)
-					}
-					keys.RegisterKeysServer(grpcServer, ks)
-				}
+	tmGenesisDoc := tendermint.DeriveGenesisDoc(&genesisDoc)
+	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
+	tmLogger := kern.Logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+	tmLogger = tmLogger.With(""height"", heightValuer)
+	kern.Node, err = tendermint.NewNode(tmConf.TendermintConfig(), privVal, tmGenesisDoc, app, metricsProvider, nodeKey, tmLogger)
+	return err
+}
 
-				rpcquery.RegisterQueryServer(grpcServer, rpcquery.NewQueryServer(kern.State, nameRegState, proposalRegState,
-					kern.Blockchain, kern.State, nodeView, kern.Logger))
+func (kern *Kernel) LoadTransactor() (err error) {
+	nodeView, err := kern.GetNodeView()
+	if err != nil {
+		return err
+	}
 
-				rpctransact.RegisterTransactServer(grpcServer, rpctransact.NewTransactServer(kern.Transactor, txCodec))
+	accountState := kern.State
+	nameRegState := kern.State
+	kern.Service = rpc.NewService(accountState, nameRegState, kern.Blockchain, kern.State, nodeView, kern.Logger)
 
-				rpcevents.RegisterExecutionEventsServer(grpcServer, rpcevents.NewExecutionEventsServer(kern.State,
-					kern.Emitter, kern.Blockchain, kern.Logger))
+	if nodeView == nil {
+		checkTx := func(tx tmTypes.Tx, cb func(*abciTypes.Response)) error {
+			ctx := abci.TxExecutor(""CheckTx"", kern.exeChecker, kern.txCodec, kern.Logger.WithScope(""CheckTx""))(tx)",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267286270,https://github.com/hyperledger/burrow/pull/1065#discussion_r267286270,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,I sort of think `kern.Node == nil` would be a little clearer and more direct,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 11:13:25,267287924,"@@ -73,300 +65,305 @@ const (
 // Kernel is the root structure of Burrow
 type Kernel struct {
 	// Expose these public-facing interfaces to allow programmatic extension of the Kernel by other projects
-	Emitter    event.Emitter
-	Service    *rpc.Service
-	Launchers  []process.Launcher
-	State      *state.State
-	Blockchain *bcm.Blockchain
-	Node       *tendermint.Node
-	Transactor *execution.Transactor
-	// Time-based UUID randomly generated each time Burrow is started
-	RunID          simpleuuid.UUID
+	Emitter        event.Emitter
+	Service        *rpc.Service
+	Launchers      []process.Launcher
+	State          *state.State
+	Blockchain     *bcm.Blockchain
+	Node           *tendermint.Node
+	Transactor     *execution.Transactor
+	RunID          simpleuuid.UUID // Time-based UUID randomly generated each time Burrow is started
 	Logger         *logging.Logger
+	txCodec        txs.Codec
+	exeOptions     []execution.ExecutionOption
+	exeChecker     execution.BatchExecutor
+	exeCommitter   execution.BatchCommitter
+	keyClient      keys.KeyClient
+	keyStore       *keys.KeyStore
 	nodeInfo       string
 	processes      map[string]process.Process
 	shutdownNotify chan struct{}
 	shutdownOnce   sync.Once
 }
 
-func NewBurrowDB(dbDir string) dbm.DB {
+func newBurrowDB(dbDir string) dbm.DB {
 	return dbm.NewDB(BurrowDBName, dbm.GoLevelDBBackend, dbDir)
 }
 
-func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTypes.PrivValidator,
-	genesisDoc *genesis.GenesisDoc, tmConf *tmConfig.Config, rpcConfig *rpc.RPCConfig, keyConfig *keys.KeysConfig,
-	keyStore *keys.KeyStore, exeOptions []execution.ExecutionOption, authorizedPeersProvider abci.PeersFilterProvider, restore string, nodeKey *crypto.PrivateKey, logger *logging.Logger) (*Kernel, error) {
-
-	var err error
-	kern := &Kernel{
+// NewKernel initializes an empty kernel
+func NewKernel() (*Kernel, error) {
+	runID, err := simpleuuid.NewTime(time.Now()) // Create a random ID based on start time
+	if err != nil {
+		return nil, err
+	}
+	return &Kernel{
+		RunID:          runID,
 		processes:      make(map[string]process.Process),
 		shutdownNotify: make(chan struct{}),
-	}
-	// Create a random ID based on start time
-	kern.RunID, err = simpleuuid.NewTime(time.Now())
+		txCodec:        txs.NewAminoCodec(),
+	}, nil
+}
 
-	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey, log.DefaultTimestampUTC,
-		structure.RunId, kern.RunID.String())
-	tendermintLogger := logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+// SetLogger initializes the kernel with the provided logger
+func (kern *Kernel) SetLogger(logger *logging.Logger) {
+	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey,
+		log.DefaultTimestampUTC, structure.RunId, kern.RunID.String())
 	kern.Logger = logger.WithInfo(structure.CallerKey, log.Caller(LoggingCallerDepth))
-	stateDB := NewBurrowDB(tmConf.DBDir())
+	kern.Emitter = event.NewEmitter(kern.Logger)
+}
 
+func (kern *Kernel) LoadBlockchain(genesisDoc *genesis.GenesisDoc, dbDir string) (stateDB dbm.DB, err error) {
+	stateDB = newBurrowDB(dbDir)
 	kern.Blockchain, err = bcm.LoadOrNewBlockchain(stateDB, genesisDoc, kern.Logger)
 	if err != nil {
 		return nil, fmt.Errorf(""error creating or loading blockchain state: %v"", err)
 	}
-
+	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(blockchain.NewBlockStore(stateDB)))
 	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
 	kern.Logger = kern.Logger.With(""height"", heightValuer)
-	tendermintLogger = tendermintLogger.With(""height"", heightValuer)
+	return stateDB, nil
+}
+
+// LoadState starts from scratch or previous chain
+func (kern *Kernel) LoadState(genesisDoc *genesis.GenesisDoc, dbDir string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
+	if err != nil {
+		return err
+	}
 
 	// These should be in sync unless we are at the genesis block
 	if kern.Blockchain.LastBlockHeight() > 0 {
 		kern.Logger.InfoMsg(""Loading application state"")
 		kern.State, err = state.LoadState(stateDB, execution.VersionAtHeight(kern.Blockchain.LastBlockHeight()))
 		if err != nil {
-			return nil, fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
+			return fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
 				kern.Blockchain.AppHashAfterLastBlock(), err)
 		}
 		if !bytes.Equal(kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock()) {
-			return nil, fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
+			return fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
 				""state gives %X, blockchain gives %X"", kern.Blockchain.LastBlockHeight(),
 				kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock())
 		}
-		if restore != """" {
-			return nil, fmt.Errorf(""Cannot restore onto existing chain; don't give --restore-dump argument"")
-		}
 	} else {
 		kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
 		if err != nil {
-			return nil, fmt.Errorf(""could not build genesis state: %v"", err)
+			return fmt.Errorf(""could not build genesis state: %v"", err)
 		}
 
-		if restore != """" {
-			if len(genesisDoc.AppHash) == 0 {
-				return nil, fmt.Errorf(""AppHash is required when restoring chain"")
-			}
+		if err = kern.State.InitialCommit(); err != nil {
+			return err
+		}
+	}
 
-			reader, err := state.NewFileDumpReader(restore)
-			if err != nil {
-				return nil, err
-			}
+	params := execution.ParamsFromGenesis(genesisDoc)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-			err = kern.State.LoadDump(reader)
-			if err != nil {
-				return nil, err
-			}
-		}
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
 
-		err = kern.State.InitialCommit()
-		if err != nil {
-			return nil, err
-		}
+// LoadDump restores chain state from the given dump file
+func (kern *Kernel) LoadDump(genesisDoc *genesis.GenesisDoc, dbDir, restore string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
 
-		if len(genesisDoc.AppHash) != 0 {
-			if !bytes.Equal(genesisDoc.AppHash, kern.State.Hash()) {
-				return nil, fmt.Errorf(""AppHash does not match, got AppHash 0x%X expected 0x%s. Is the correct --restore-dump specified?"", kern.State.Hash(), genesisDoc.AppHash.String())
-			}
-		}
+	kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
+	if err != nil {
+		return fmt.Errorf(""could not build genesis state: %v"", err)
 	}
 
-	kern.Logger.InfoMsg(""State loading successful"")
+	if len(kern.Blockchain.GenesisDoc().AppHash) == 0 {
+		return fmt.Errorf(""AppHash is required when restoring chain"")
+	}
+
+	reader, err := state.NewFileDumpReader(restore)
+	if err != nil {
+		return err
+	}
+
+	if err = kern.State.LoadDump(reader); err != nil {
+		return err
+	}
+
+	if err = kern.State.InitialCommit(); err != nil {
+		return err
+	}
 
-	txCodec := txs.NewAminoCodec()
-	tmGenesisDoc := tendermint.DeriveGenesisDoc(genesisDoc)
 	params := execution.ParamsFromGenesis(genesisDoc)
-	checker := execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-	kern.Emitter = event.NewEmitter(kern.Logger)
-	committer := execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, exeOptions...)
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
+
+// GetNodeView builds and returns a wrapper of our tendermint node
+func (kern *Kernel) GetNodeView() (nodeView *tendermint.NodeView, err error) {
+	nodeView, err = tendermint.NewNodeView(kern.Node, kern.txCodec, kern.RunID)
+	return nodeView, err
+}
+
+// AddExecutionOptions extends our execution options
+func (kern *Kernel) AddExecutionOptions(opts ...execution.ExecutionOption) {
+	kern.exeOptions = append(kern.exeOptions, opts...)
+}
+
+// AddProcesses extends the services that we launch at boot
+func (kern *Kernel) AddProcesses(pl ...process.Launcher) {
+	kern.Launchers = append(kern.Launchers, pl...)
+}
+
+func (kern *Kernel) SetKeyClient(client keys.KeyClient) {
+	kern.keyClient = client
+}
+
+func (kern *Kernel) SetKeyStore(store *keys.KeyStore) {
+	kern.keyStore = store
+}
+
+// TendermintFromConfig loads our consensus engine into the kernel
+func (kern *Kernel) TendermintFromConfig(tmConf *tendermint.BurrowTendermintConfig, privVal tmTypes.PrivValidator, validator *crypto.Address) (err error) {
+	if privVal == nil {
+		val, err := keys.AddressableSigner(kern.keyClient, *validator)
+		if err != nil {
+			return fmt.Errorf(""could not get validator addressable from keys client: %v"", err)
+		}
+		signer, err := keys.AddressableSigner(kern.keyClient, val.GetAddress())
+		if err != nil {
+			return err
+		}
+		privVal = tendermint.NewPrivValidatorMemory(val, signer)
+	}
+
+	authorizedPeersProvider := tmConf.DefaultAuthorizedPeersProvider()
 
 	kern.nodeInfo = fmt.Sprintf(""Burrow_%s_%s_ValidatorID:%X"", project.History.CurrentVersion().String(),
-		genesisDoc.ChainID(), privValidator.GetPubKey().Address())
-	app := abci.NewApp(kern.nodeInfo, kern.Blockchain, kern.State, checker, committer, txCodec, authorizedPeersProvider,
-		kern.Panic, logger)
+		kern.Blockchain.ChainID(), privVal.GetPubKey().Address())
+	app := abci.NewApp(kern.nodeInfo, kern.Blockchain, kern.State, kern.exeChecker, kern.exeCommitter, kern.txCodec, authorizedPeersProvider,
+		kern.Panic, kern.Logger)
+
 	// We could use this to provide/register our own metrics (though this will register them with us). Unfortunately
 	// Tendermint currently ignores the metrics passed unless its own server is turned on.
 	metricsProvider := node.DefaultMetricsProvider(&tmConfig.InstrumentationConfig{
 		Prometheus:           false,
 		PrometheusListenAddr: """",
 	})
-	kern.Node, err = tendermint.NewNode(tmConf, privValidator, tmGenesisDoc, app, metricsProvider, nodeKey, tendermintLogger)
-	if err != nil {
-		return nil, err
-	}
 
-	kern.Transactor = execution.NewTransactor(kern.Blockchain, kern.Emitter,
-		execution.NewAccounts(checker, keyClient, AccountsRingMutexCount),
-		kern.Node.MempoolReactor().Mempool.CheckTx, txCodec, kern.Logger)
+	genesisDoc := kern.Blockchain.GenesisDoc()
 
-	nameRegState := kern.State
-	proposalRegState := kern.State
-	accountState := kern.State
-	nodeView, err := tendermint.NewNodeView(kern.Node, txCodec, kern.RunID)
-	if err != nil {
-		return nil, err
+	// find node key
+	var nodeKey *crypto.PrivateKey
+	for _, v := range genesisDoc.Validators {
+		thisAddress, err := crypto.AddressFromHexString(privVal.GetPubKey().Address().String())
+		if err != nil {
+			break
+		}
+		if v.Address == thisAddress && v.NodeAddress != nil {
+			k, err := kern.keyStore.GetKey("""", v.NodeAddress.Bytes())
+			if err == nil {
+				nodeKey = &k.PrivateKey
+			}
+			break
+		}
 	}
-	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(nodeView.BlockStore()))
-	kern.Service = rpc.NewService(accountState, nameRegState, kern.Blockchain, kern.State, nodeView, kern.Logger)
-
-	kern.Launchers = []process.Launcher{
-		{
-			Name:    ""Profiling Server"",
-			Enabled: rpcConfig.Profiler.Enabled,
-			Launch: func() (process.Process, error) {
-				debugServer := &http.Server{
-					Addr: "":6060"",
-				}
-				go func() {
-					err := debugServer.ListenAndServe()
-					if err != nil {
-						kern.Logger.InfoMsg(""Error from pprof debug server"", structure.ErrorKey, err)
-					}
-				}()
-				return debugServer, nil
-			},
-		},
-		{
-			Name:    ""Database"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				// Just close database
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					stateDB.Close()
-					return nil
-				}), nil
-			},
-		},
-		{
-			Name:    ""Tendermint"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				err := kern.Node.Start()
-				if err != nil {
-					return nil, fmt.Errorf(""error starting Tendermint node: %v"", err)
-				}
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					err := kern.Node.Stop()
-					// Close tendermint database connections using our wrapper
-					defer kern.Node.Close()
-					if err != nil {
-						return err
-					}
-					select {
-					case <-ctx.Done():
-						return ctx.Err()
-					case <-kern.Node.Quit():
-						kern.Logger.InfoMsg(""Tendermint Node has quit, closing DB connections..."")
-						return nil
-					}
-					return err
-				}), nil
-			},
-		},
-		// Run announcer after Tendermint so it can get some details
-		{
-			Name:    ""Startup Announcer"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				info := kern.Node.NodeInfo()
-
-				start := time.Now()
-				logger := kern.Logger.With(
-					""launch_time"", start,
-					""burrow_version"", project.FullVersion(),
-					""tendermint_version"", version.TMCoreSemVer,
-					""validator_address"", privValidator.GetPubKey().Address(),
-					""node_id"", string(info.ID()),
-					""net_address"", info.NetAddress().String(),
-					""genesis_app_hash"", genesisDoc.AppHash.String(),
-					""genesis_hash"", hex.EncodeUpperToString(genesisDoc.Hash()),
-				)
-
-				err := logger.InfoMsg(""Burrow is launching. We have marmot-off."", ""announce"", ""startup"")
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					stop := time.Now()
-					return logger.InfoMsg(""Burrow is shutting down. Prepare for re-entrancy."",
-						""announce"", ""shutdown"",
-						""shutdown_time"", stop,
-						""elapsed_run_time"", stop.Sub(start).String())
-				}), err
-			},
-		},
-		{
-			Name:    ""RPC/info"",
-			Enabled: rpcConfig.Info.Enabled,
-			Launch: func() (process.Process, error) {
-				server, err := rpcinfo.StartServer(kern.Service, ""/websocket"", rpcConfig.Info.ListenAddress, kern.Logger)
-				if err != nil {
-					return nil, err
-				}
-				return server, nil
-			},
-		},
-		{
-			Name:    ""RPC/metrics"",
-			Enabled: rpcConfig.Metrics.Enabled,
-			Launch: func() (process.Process, error) {
-				server, err := metrics.StartServer(kern.Service, rpcConfig.Metrics.MetricsPath,
-					rpcConfig.Metrics.ListenAddress, rpcConfig.Metrics.BlockSampleSize, kern.Logger)
-				if err != nil {
-					return nil, err
-				}
-				return server, nil
-			},
-		},
-		{
-			Name:    ""RPC/GRPC"",
-			Enabled: rpcConfig.GRPC.Enabled,
-			Launch: func() (process.Process, error) {
-				listen, err := net.Listen(""tcp"", rpcConfig.GRPC.ListenAddress)
-				if err != nil {
-					return nil, err
-				}
 
-				grpcServer := rpc.NewGRPCServer(kern.Logger)
-				var ks *keys.KeyStore
-				if keyStore != nil {
-					ks = keyStore
-				}
-
-				if keyConfig.GRPCServiceEnabled {
-					if keyStore == nil {
-						ks = keys.NewKeyStore(keyConfig.KeysDirectory, keyConfig.AllowBadFilePermissions)
-					}
-					keys.RegisterKeysServer(grpcServer, ks)
-				}
+	tmGenesisDoc := tendermint.DeriveGenesisDoc(&genesisDoc)
+	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
+	tmLogger := kern.Logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+	tmLogger = tmLogger.With(""height"", heightValuer)
+	kern.Node, err = tendermint.NewNode(tmConf.TendermintConfig(), privVal, tmGenesisDoc, app, metricsProvider, nodeKey, tmLogger)
+	return err
+}
 
-				rpcquery.RegisterQueryServer(grpcServer, rpcquery.NewQueryServer(kern.State, nameRegState, proposalRegState,
-					kern.Blockchain, kern.State, nodeView, kern.Logger))
+func (kern *Kernel) LoadTransactor() (err error) {
+	nodeView, err := kern.GetNodeView()
+	if err != nil {
+		return err
+	}
 
-				rpctransact.RegisterTransactServer(grpcServer, rpctransact.NewTransactServer(kern.Transactor, txCodec))
+	accountState := kern.State
+	nameRegState := kern.State
+	kern.Service = rpc.NewService(accountState, nameRegState, kern.Blockchain, kern.State, nodeView, kern.Logger)
 
-				rpcevents.RegisterExecutionEventsServer(grpcServer, rpcevents.NewExecutionEventsServer(kern.State,
-					kern.Emitter, kern.Blockchain, kern.Logger))
+	if nodeView == nil {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267287924,https://github.com/hyperledger/burrow/pull/1065#discussion_r267287924,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,I think this should be called `LoadTendermint` since it does not return `Tendermint` and there is no way to load without config.,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 11:17:42,267289392,"@@ -73,300 +65,305 @@ const (
 // Kernel is the root structure of Burrow
 type Kernel struct {
 	// Expose these public-facing interfaces to allow programmatic extension of the Kernel by other projects
-	Emitter    event.Emitter
-	Service    *rpc.Service
-	Launchers  []process.Launcher
-	State      *state.State
-	Blockchain *bcm.Blockchain
-	Node       *tendermint.Node
-	Transactor *execution.Transactor
-	// Time-based UUID randomly generated each time Burrow is started
-	RunID          simpleuuid.UUID
+	Emitter        event.Emitter
+	Service        *rpc.Service
+	Launchers      []process.Launcher
+	State          *state.State
+	Blockchain     *bcm.Blockchain
+	Node           *tendermint.Node
+	Transactor     *execution.Transactor
+	RunID          simpleuuid.UUID // Time-based UUID randomly generated each time Burrow is started
 	Logger         *logging.Logger
+	txCodec        txs.Codec
+	exeOptions     []execution.ExecutionOption
+	exeChecker     execution.BatchExecutor
+	exeCommitter   execution.BatchCommitter
+	keyClient      keys.KeyClient
+	keyStore       *keys.KeyStore
 	nodeInfo       string
 	processes      map[string]process.Process
 	shutdownNotify chan struct{}
 	shutdownOnce   sync.Once
 }
 
-func NewBurrowDB(dbDir string) dbm.DB {
+func newBurrowDB(dbDir string) dbm.DB {
 	return dbm.NewDB(BurrowDBName, dbm.GoLevelDBBackend, dbDir)
 }
 
-func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTypes.PrivValidator,
-	genesisDoc *genesis.GenesisDoc, tmConf *tmConfig.Config, rpcConfig *rpc.RPCConfig, keyConfig *keys.KeysConfig,
-	keyStore *keys.KeyStore, exeOptions []execution.ExecutionOption, authorizedPeersProvider abci.PeersFilterProvider, restore string, nodeKey *crypto.PrivateKey, logger *logging.Logger) (*Kernel, error) {
-
-	var err error
-	kern := &Kernel{
+// NewKernel initializes an empty kernel
+func NewKernel() (*Kernel, error) {
+	runID, err := simpleuuid.NewTime(time.Now()) // Create a random ID based on start time
+	if err != nil {
+		return nil, err
+	}
+	return &Kernel{
+		RunID:          runID,
 		processes:      make(map[string]process.Process),
 		shutdownNotify: make(chan struct{}),
-	}
-	// Create a random ID based on start time
-	kern.RunID, err = simpleuuid.NewTime(time.Now())
+		txCodec:        txs.NewAminoCodec(),
+	}, nil
+}
 
-	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey, log.DefaultTimestampUTC,
-		structure.RunId, kern.RunID.String())
-	tendermintLogger := logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+// SetLogger initializes the kernel with the provided logger
+func (kern *Kernel) SetLogger(logger *logging.Logger) {
+	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey,
+		log.DefaultTimestampUTC, structure.RunId, kern.RunID.String())
 	kern.Logger = logger.WithInfo(structure.CallerKey, log.Caller(LoggingCallerDepth))
-	stateDB := NewBurrowDB(tmConf.DBDir())
+	kern.Emitter = event.NewEmitter(kern.Logger)
+}
 
+func (kern *Kernel) LoadBlockchain(genesisDoc *genesis.GenesisDoc, dbDir string) (stateDB dbm.DB, err error) {
+	stateDB = newBurrowDB(dbDir)
 	kern.Blockchain, err = bcm.LoadOrNewBlockchain(stateDB, genesisDoc, kern.Logger)
 	if err != nil {
 		return nil, fmt.Errorf(""error creating or loading blockchain state: %v"", err)
 	}
-
+	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(blockchain.NewBlockStore(stateDB)))
 	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
 	kern.Logger = kern.Logger.With(""height"", heightValuer)
-	tendermintLogger = tendermintLogger.With(""height"", heightValuer)
+	return stateDB, nil
+}
+
+// LoadState starts from scratch or previous chain
+func (kern *Kernel) LoadState(genesisDoc *genesis.GenesisDoc, dbDir string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
+	if err != nil {
+		return err
+	}
 
 	// These should be in sync unless we are at the genesis block
 	if kern.Blockchain.LastBlockHeight() > 0 {
 		kern.Logger.InfoMsg(""Loading application state"")
 		kern.State, err = state.LoadState(stateDB, execution.VersionAtHeight(kern.Blockchain.LastBlockHeight()))
 		if err != nil {
-			return nil, fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
+			return fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
 				kern.Blockchain.AppHashAfterLastBlock(), err)
 		}
 		if !bytes.Equal(kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock()) {
-			return nil, fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
+			return fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
 				""state gives %X, blockchain gives %X"", kern.Blockchain.LastBlockHeight(),
 				kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock())
 		}
-		if restore != """" {
-			return nil, fmt.Errorf(""Cannot restore onto existing chain; don't give --restore-dump argument"")
-		}
 	} else {
 		kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
 		if err != nil {
-			return nil, fmt.Errorf(""could not build genesis state: %v"", err)
+			return fmt.Errorf(""could not build genesis state: %v"", err)
 		}
 
-		if restore != """" {
-			if len(genesisDoc.AppHash) == 0 {
-				return nil, fmt.Errorf(""AppHash is required when restoring chain"")
-			}
+		if err = kern.State.InitialCommit(); err != nil {
+			return err
+		}
+	}
 
-			reader, err := state.NewFileDumpReader(restore)
-			if err != nil {
-				return nil, err
-			}
+	params := execution.ParamsFromGenesis(genesisDoc)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-			err = kern.State.LoadDump(reader)
-			if err != nil {
-				return nil, err
-			}
-		}
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
 
-		err = kern.State.InitialCommit()
-		if err != nil {
-			return nil, err
-		}
+// LoadDump restores chain state from the given dump file
+func (kern *Kernel) LoadDump(genesisDoc *genesis.GenesisDoc, dbDir, restore string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
 
-		if len(genesisDoc.AppHash) != 0 {
-			if !bytes.Equal(genesisDoc.AppHash, kern.State.Hash()) {
-				return nil, fmt.Errorf(""AppHash does not match, got AppHash 0x%X expected 0x%s. Is the correct --restore-dump specified?"", kern.State.Hash(), genesisDoc.AppHash.String())
-			}
-		}
+	kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
+	if err != nil {
+		return fmt.Errorf(""could not build genesis state: %v"", err)
 	}
 
-	kern.Logger.InfoMsg(""State loading successful"")
+	if len(kern.Blockchain.GenesisDoc().AppHash) == 0 {
+		return fmt.Errorf(""AppHash is required when restoring chain"")
+	}
+
+	reader, err := state.NewFileDumpReader(restore)
+	if err != nil {
+		return err
+	}
+
+	if err = kern.State.LoadDump(reader); err != nil {
+		return err
+	}
+
+	if err = kern.State.InitialCommit(); err != nil {
+		return err
+	}
 
-	txCodec := txs.NewAminoCodec()
-	tmGenesisDoc := tendermint.DeriveGenesisDoc(genesisDoc)
 	params := execution.ParamsFromGenesis(genesisDoc)
-	checker := execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-	kern.Emitter = event.NewEmitter(kern.Logger)
-	committer := execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, exeOptions...)
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
+
+// GetNodeView builds and returns a wrapper of our tendermint node
+func (kern *Kernel) GetNodeView() (nodeView *tendermint.NodeView, err error) {
+	nodeView, err = tendermint.NewNodeView(kern.Node, kern.txCodec, kern.RunID)
+	return nodeView, err
+}
+
+// AddExecutionOptions extends our execution options
+func (kern *Kernel) AddExecutionOptions(opts ...execution.ExecutionOption) {
+	kern.exeOptions = append(kern.exeOptions, opts...)
+}
+
+// AddProcesses extends the services that we launch at boot
+func (kern *Kernel) AddProcesses(pl ...process.Launcher) {
+	kern.Launchers = append(kern.Launchers, pl...)
+}
+
+func (kern *Kernel) SetKeyClient(client keys.KeyClient) {
+	kern.keyClient = client
+}
+
+func (kern *Kernel) SetKeyStore(store *keys.KeyStore) {
+	kern.keyStore = store
+}
+
+// TendermintFromConfig loads our consensus engine into the kernel
+func (kern *Kernel) TendermintFromConfig(tmConf *tendermint.BurrowTendermintConfig, privVal tmTypes.PrivValidator, validator *crypto.Address) (err error) {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267289392,https://github.com/hyperledger/burrow/pull/1065#discussion_r267289392,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,Hm okay I see how the names `FromConfig` line up now. I feel like these all ought to be `LoadXFromConfig` though it is more long-winded since they do return the thing they load. Alternatively `LoadX` but I think i prefer `LoadKeysFromConfig` `LoadLoggerFromConfig`,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 11:19:58,267290206,"@@ -36,16 +33,34 @@ func Start(output Output) func(cmd *cli.Cmd) {
 
 			output.Logf(""Using validator address: %s"", *conf.ValidatorAddress)
 
-			ctx, cancel := context.WithCancel(context.Background())
-			defer cancel()
-
-			kern, err := conf.Kernel(ctx, *restoreDumpOpt)
+			kern, err := core.NewKernel()
 			if err != nil {
 				output.Fatalf(""could not create Burrow kernel: %v"", err)
 			}
 
-			err = kern.Boot()
-			if err != nil {
+			if err = kern.ExecutorFromConfig(conf.Execution); err != nil {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267290206,https://github.com/hyperledger/burrow/pull/1065#discussion_r267290206,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,okay actually `LoadTendermintFromConfig` is good,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 11:20:28,267290370,"@@ -73,300 +65,305 @@ const (
 // Kernel is the root structure of Burrow
 type Kernel struct {
 	// Expose these public-facing interfaces to allow programmatic extension of the Kernel by other projects
-	Emitter    event.Emitter
-	Service    *rpc.Service
-	Launchers  []process.Launcher
-	State      *state.State
-	Blockchain *bcm.Blockchain
-	Node       *tendermint.Node
-	Transactor *execution.Transactor
-	// Time-based UUID randomly generated each time Burrow is started
-	RunID          simpleuuid.UUID
+	Emitter        event.Emitter
+	Service        *rpc.Service
+	Launchers      []process.Launcher
+	State          *state.State
+	Blockchain     *bcm.Blockchain
+	Node           *tendermint.Node
+	Transactor     *execution.Transactor
+	RunID          simpleuuid.UUID // Time-based UUID randomly generated each time Burrow is started
 	Logger         *logging.Logger
+	txCodec        txs.Codec
+	exeOptions     []execution.ExecutionOption
+	exeChecker     execution.BatchExecutor
+	exeCommitter   execution.BatchCommitter
+	keyClient      keys.KeyClient
+	keyStore       *keys.KeyStore
 	nodeInfo       string
 	processes      map[string]process.Process
 	shutdownNotify chan struct{}
 	shutdownOnce   sync.Once
 }
 
-func NewBurrowDB(dbDir string) dbm.DB {
+func newBurrowDB(dbDir string) dbm.DB {
 	return dbm.NewDB(BurrowDBName, dbm.GoLevelDBBackend, dbDir)
 }
 
-func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTypes.PrivValidator,
-	genesisDoc *genesis.GenesisDoc, tmConf *tmConfig.Config, rpcConfig *rpc.RPCConfig, keyConfig *keys.KeysConfig,
-	keyStore *keys.KeyStore, exeOptions []execution.ExecutionOption, authorizedPeersProvider abci.PeersFilterProvider, restore string, nodeKey *crypto.PrivateKey, logger *logging.Logger) (*Kernel, error) {
-
-	var err error
-	kern := &Kernel{
+// NewKernel initializes an empty kernel
+func NewKernel() (*Kernel, error) {
+	runID, err := simpleuuid.NewTime(time.Now()) // Create a random ID based on start time
+	if err != nil {
+		return nil, err
+	}
+	return &Kernel{
+		RunID:          runID,
 		processes:      make(map[string]process.Process),
 		shutdownNotify: make(chan struct{}),
-	}
-	// Create a random ID based on start time
-	kern.RunID, err = simpleuuid.NewTime(time.Now())
+		txCodec:        txs.NewAminoCodec(),
+	}, nil
+}
 
-	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey, log.DefaultTimestampUTC,
-		structure.RunId, kern.RunID.String())
-	tendermintLogger := logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+// SetLogger initializes the kernel with the provided logger
+func (kern *Kernel) SetLogger(logger *logging.Logger) {
+	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey,
+		log.DefaultTimestampUTC, structure.RunId, kern.RunID.String())
 	kern.Logger = logger.WithInfo(structure.CallerKey, log.Caller(LoggingCallerDepth))
-	stateDB := NewBurrowDB(tmConf.DBDir())
+	kern.Emitter = event.NewEmitter(kern.Logger)
+}
 
+func (kern *Kernel) LoadBlockchain(genesisDoc *genesis.GenesisDoc, dbDir string) (stateDB dbm.DB, err error) {
+	stateDB = newBurrowDB(dbDir)
 	kern.Blockchain, err = bcm.LoadOrNewBlockchain(stateDB, genesisDoc, kern.Logger)
 	if err != nil {
 		return nil, fmt.Errorf(""error creating or loading blockchain state: %v"", err)
 	}
-
+	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(blockchain.NewBlockStore(stateDB)))
 	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
 	kern.Logger = kern.Logger.With(""height"", heightValuer)
-	tendermintLogger = tendermintLogger.With(""height"", heightValuer)
+	return stateDB, nil
+}
+
+// LoadState starts from scratch or previous chain
+func (kern *Kernel) LoadState(genesisDoc *genesis.GenesisDoc, dbDir string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
+	if err != nil {
+		return err
+	}
 
 	// These should be in sync unless we are at the genesis block
 	if kern.Blockchain.LastBlockHeight() > 0 {
 		kern.Logger.InfoMsg(""Loading application state"")
 		kern.State, err = state.LoadState(stateDB, execution.VersionAtHeight(kern.Blockchain.LastBlockHeight()))
 		if err != nil {
-			return nil, fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
+			return fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
 				kern.Blockchain.AppHashAfterLastBlock(), err)
 		}
 		if !bytes.Equal(kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock()) {
-			return nil, fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
+			return fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
 				""state gives %X, blockchain gives %X"", kern.Blockchain.LastBlockHeight(),
 				kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock())
 		}
-		if restore != """" {
-			return nil, fmt.Errorf(""Cannot restore onto existing chain; don't give --restore-dump argument"")
-		}
 	} else {
 		kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
 		if err != nil {
-			return nil, fmt.Errorf(""could not build genesis state: %v"", err)
+			return fmt.Errorf(""could not build genesis state: %v"", err)
 		}
 
-		if restore != """" {
-			if len(genesisDoc.AppHash) == 0 {
-				return nil, fmt.Errorf(""AppHash is required when restoring chain"")
-			}
+		if err = kern.State.InitialCommit(); err != nil {
+			return err
+		}
+	}
 
-			reader, err := state.NewFileDumpReader(restore)
-			if err != nil {
-				return nil, err
-			}
+	params := execution.ParamsFromGenesis(genesisDoc)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-			err = kern.State.LoadDump(reader)
-			if err != nil {
-				return nil, err
-			}
-		}
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
 
-		err = kern.State.InitialCommit()
-		if err != nil {
-			return nil, err
-		}
+// LoadDump restores chain state from the given dump file
+func (kern *Kernel) LoadDump(genesisDoc *genesis.GenesisDoc, dbDir, restore string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
 
-		if len(genesisDoc.AppHash) != 0 {
-			if !bytes.Equal(genesisDoc.AppHash, kern.State.Hash()) {
-				return nil, fmt.Errorf(""AppHash does not match, got AppHash 0x%X expected 0x%s. Is the correct --restore-dump specified?"", kern.State.Hash(), genesisDoc.AppHash.String())
-			}
-		}
+	kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
+	if err != nil {
+		return fmt.Errorf(""could not build genesis state: %v"", err)
 	}
 
-	kern.Logger.InfoMsg(""State loading successful"")
+	if len(kern.Blockchain.GenesisDoc().AppHash) == 0 {
+		return fmt.Errorf(""AppHash is required when restoring chain"")
+	}
+
+	reader, err := state.NewFileDumpReader(restore)
+	if err != nil {
+		return err
+	}
+
+	if err = kern.State.LoadDump(reader); err != nil {
+		return err
+	}
+
+	if err = kern.State.InitialCommit(); err != nil {
+		return err
+	}
 
-	txCodec := txs.NewAminoCodec()
-	tmGenesisDoc := tendermint.DeriveGenesisDoc(genesisDoc)
 	params := execution.ParamsFromGenesis(genesisDoc)
-	checker := execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-	kern.Emitter = event.NewEmitter(kern.Logger)
-	committer := execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, exeOptions...)
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
+
+// GetNodeView builds and returns a wrapper of our tendermint node
+func (kern *Kernel) GetNodeView() (nodeView *tendermint.NodeView, err error) {
+	nodeView, err = tendermint.NewNodeView(kern.Node, kern.txCodec, kern.RunID)
+	return nodeView, err
+}
+
+// AddExecutionOptions extends our execution options
+func (kern *Kernel) AddExecutionOptions(opts ...execution.ExecutionOption) {
+	kern.exeOptions = append(kern.exeOptions, opts...)
+}
+
+// AddProcesses extends the services that we launch at boot
+func (kern *Kernel) AddProcesses(pl ...process.Launcher) {
+	kern.Launchers = append(kern.Launchers, pl...)
+}
+
+func (kern *Kernel) SetKeyClient(client keys.KeyClient) {
+	kern.keyClient = client
+}
+
+func (kern *Kernel) SetKeyStore(store *keys.KeyStore) {
+	kern.keyStore = store
+}
+
+// TendermintFromConfig loads our consensus engine into the kernel
+func (kern *Kernel) TendermintFromConfig(tmConf *tendermint.BurrowTendermintConfig, privVal tmTypes.PrivValidator, validator *crypto.Address) (err error) {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267290370,https://github.com/hyperledger/burrow/pull/1065#discussion_r267290370,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,"I do see the logic of just having this wiring up logic in the CLI... However I feel like it might still be good to have a canonical location that shows you how to wire up a kernel.

My suggestion would be that we have a `core/config.go` that has all the `LoadXFromConfig` methods and we add a `LoadKernelFromConfig` which does the lot.",9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 11:26:51,267292375,"@@ -36,16 +33,34 @@ func Start(output Output) func(cmd *cli.Cmd) {
 
 			output.Logf(""Using validator address: %s"", *conf.ValidatorAddress)
 
-			ctx, cancel := context.WithCancel(context.Background())
-			defer cancel()
-
-			kern, err := conf.Kernel(ctx, *restoreDumpOpt)
+			kern, err := core.NewKernel()
 			if err != nil {
 				output.Fatalf(""could not create Burrow kernel: %v"", err)
 			}
 
-			err = kern.Boot()
-			if err != nil {
+			if err = kern.ExecutorFromConfig(conf.Execution); err != nil {
+				output.Fatalf(""could not add execution options: %v"", err)
+			}
+
+			if err = kern.LoggerFromConfig(conf.Logging); err != nil {
+				output.Fatalf(""could not configure logger: %v"", err)
+			}
+
+			if err = kern.KeysFromConfig(conf.Keys); err != nil {
+				output.Fatalf(""could not configure keys: %v"", err)
+			}
+
+			tmConf := conf.Tendermint.TendermintConfig()
+			if err = kern.LoadState(conf.GenesisDoc, tmConf.DBDir()); err != nil {
+				output.Fatalf(""could not load state: %v"", err)
+			}
+
+			if err = kern.TendermintFromConfig(conf.Tendermint, nil, conf.ValidatorAddress); err != nil {
+				output.Fatalf(""could not configure Tendermint: %v"", err)
+			}
+
+			kern.AddProcesses(core.DefaultServices(kern, conf.RPC, conf.Keys)...)
+			if err = kern.Boot(); err != nil {",40,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267292375,https://github.com/hyperledger/burrow/pull/1065#discussion_r267292375,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,"This needs to be part of `NewKernel` - otherwise we do not have a working Kernel just because we haven't set up logger. Actually surprised this has not broken tests...

This means we probably need a `SetLogger` method on `Emitter`. So lets' drop `logger` from the constructor.",9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 11:30:10,267293426,"@@ -73,300 +65,305 @@ const (
 // Kernel is the root structure of Burrow
 type Kernel struct {
 	// Expose these public-facing interfaces to allow programmatic extension of the Kernel by other projects
-	Emitter    event.Emitter
-	Service    *rpc.Service
-	Launchers  []process.Launcher
-	State      *state.State
-	Blockchain *bcm.Blockchain
-	Node       *tendermint.Node
-	Transactor *execution.Transactor
-	// Time-based UUID randomly generated each time Burrow is started
-	RunID          simpleuuid.UUID
+	Emitter        event.Emitter
+	Service        *rpc.Service
+	Launchers      []process.Launcher
+	State          *state.State
+	Blockchain     *bcm.Blockchain
+	Node           *tendermint.Node
+	Transactor     *execution.Transactor
+	RunID          simpleuuid.UUID // Time-based UUID randomly generated each time Burrow is started
 	Logger         *logging.Logger
+	txCodec        txs.Codec
+	exeOptions     []execution.ExecutionOption
+	exeChecker     execution.BatchExecutor
+	exeCommitter   execution.BatchCommitter
+	keyClient      keys.KeyClient
+	keyStore       *keys.KeyStore
 	nodeInfo       string
 	processes      map[string]process.Process
 	shutdownNotify chan struct{}
 	shutdownOnce   sync.Once
 }
 
-func NewBurrowDB(dbDir string) dbm.DB {
+func newBurrowDB(dbDir string) dbm.DB {
 	return dbm.NewDB(BurrowDBName, dbm.GoLevelDBBackend, dbDir)
 }
 
-func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTypes.PrivValidator,
-	genesisDoc *genesis.GenesisDoc, tmConf *tmConfig.Config, rpcConfig *rpc.RPCConfig, keyConfig *keys.KeysConfig,
-	keyStore *keys.KeyStore, exeOptions []execution.ExecutionOption, authorizedPeersProvider abci.PeersFilterProvider, restore string, nodeKey *crypto.PrivateKey, logger *logging.Logger) (*Kernel, error) {
-
-	var err error
-	kern := &Kernel{
+// NewKernel initializes an empty kernel
+func NewKernel() (*Kernel, error) {
+	runID, err := simpleuuid.NewTime(time.Now()) // Create a random ID based on start time
+	if err != nil {
+		return nil, err
+	}
+	return &Kernel{
+		RunID:          runID,
 		processes:      make(map[string]process.Process),
 		shutdownNotify: make(chan struct{}),
-	}
-	// Create a random ID based on start time
-	kern.RunID, err = simpleuuid.NewTime(time.Now())
+		txCodec:        txs.NewAminoCodec(),
+	}, nil
+}
 
-	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey, log.DefaultTimestampUTC,
-		structure.RunId, kern.RunID.String())
-	tendermintLogger := logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+// SetLogger initializes the kernel with the provided logger
+func (kern *Kernel) SetLogger(logger *logging.Logger) {
+	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey,
+		log.DefaultTimestampUTC, structure.RunId, kern.RunID.String())
 	kern.Logger = logger.WithInfo(structure.CallerKey, log.Caller(LoggingCallerDepth))
-	stateDB := NewBurrowDB(tmConf.DBDir())
+	kern.Emitter = event.NewEmitter(kern.Logger)",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267293426,https://github.com/hyperledger/burrow/pull/1065#discussion_r267293426,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,"The way this is now is technically fine, but it looks like we could end up trying to set up `DB` instance on the same directory twice. To avoid it seeming this way, or being refactored so it does in the future only one method should be responsible for setting up the DB. So we may want to pass the `dbm.DB` instance into both `LoadState` and `LoadBlockchain`

Actually no, we should set up the DB in `NewKernel`",9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 11:34:35,267294862,"@@ -73,300 +65,305 @@ const (
 // Kernel is the root structure of Burrow
 type Kernel struct {
 	// Expose these public-facing interfaces to allow programmatic extension of the Kernel by other projects
-	Emitter    event.Emitter
-	Service    *rpc.Service
-	Launchers  []process.Launcher
-	State      *state.State
-	Blockchain *bcm.Blockchain
-	Node       *tendermint.Node
-	Transactor *execution.Transactor
-	// Time-based UUID randomly generated each time Burrow is started
-	RunID          simpleuuid.UUID
+	Emitter        event.Emitter
+	Service        *rpc.Service
+	Launchers      []process.Launcher
+	State          *state.State
+	Blockchain     *bcm.Blockchain
+	Node           *tendermint.Node
+	Transactor     *execution.Transactor
+	RunID          simpleuuid.UUID // Time-based UUID randomly generated each time Burrow is started
 	Logger         *logging.Logger
+	txCodec        txs.Codec
+	exeOptions     []execution.ExecutionOption
+	exeChecker     execution.BatchExecutor
+	exeCommitter   execution.BatchCommitter
+	keyClient      keys.KeyClient
+	keyStore       *keys.KeyStore
 	nodeInfo       string
 	processes      map[string]process.Process
 	shutdownNotify chan struct{}
 	shutdownOnce   sync.Once
 }
 
-func NewBurrowDB(dbDir string) dbm.DB {
+func newBurrowDB(dbDir string) dbm.DB {
 	return dbm.NewDB(BurrowDBName, dbm.GoLevelDBBackend, dbDir)
 }
 
-func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTypes.PrivValidator,
-	genesisDoc *genesis.GenesisDoc, tmConf *tmConfig.Config, rpcConfig *rpc.RPCConfig, keyConfig *keys.KeysConfig,
-	keyStore *keys.KeyStore, exeOptions []execution.ExecutionOption, authorizedPeersProvider abci.PeersFilterProvider, restore string, nodeKey *crypto.PrivateKey, logger *logging.Logger) (*Kernel, error) {
-
-	var err error
-	kern := &Kernel{
+// NewKernel initializes an empty kernel
+func NewKernel() (*Kernel, error) {
+	runID, err := simpleuuid.NewTime(time.Now()) // Create a random ID based on start time
+	if err != nil {
+		return nil, err
+	}
+	return &Kernel{
+		RunID:          runID,
 		processes:      make(map[string]process.Process),
 		shutdownNotify: make(chan struct{}),
-	}
-	// Create a random ID based on start time
-	kern.RunID, err = simpleuuid.NewTime(time.Now())
+		txCodec:        txs.NewAminoCodec(),
+	}, nil
+}
 
-	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey, log.DefaultTimestampUTC,
-		structure.RunId, kern.RunID.String())
-	tendermintLogger := logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+// SetLogger initializes the kernel with the provided logger
+func (kern *Kernel) SetLogger(logger *logging.Logger) {
+	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey,
+		log.DefaultTimestampUTC, structure.RunId, kern.RunID.String())
 	kern.Logger = logger.WithInfo(structure.CallerKey, log.Caller(LoggingCallerDepth))
-	stateDB := NewBurrowDB(tmConf.DBDir())
+	kern.Emitter = event.NewEmitter(kern.Logger)
+}
 
+func (kern *Kernel) LoadBlockchain(genesisDoc *genesis.GenesisDoc, dbDir string) (stateDB dbm.DB, err error) {
+	stateDB = newBurrowDB(dbDir)
 	kern.Blockchain, err = bcm.LoadOrNewBlockchain(stateDB, genesisDoc, kern.Logger)
 	if err != nil {
 		return nil, fmt.Errorf(""error creating or loading blockchain state: %v"", err)
 	}
-
+	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(blockchain.NewBlockStore(stateDB)))
 	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
 	kern.Logger = kern.Logger.With(""height"", heightValuer)
-	tendermintLogger = tendermintLogger.With(""height"", heightValuer)
+	return stateDB, nil
+}
+
+// LoadState starts from scratch or previous chain
+func (kern *Kernel) LoadState(genesisDoc *genesis.GenesisDoc, dbDir string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267294862,https://github.com/hyperledger/burrow/pull/1065#discussion_r267294862,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,Make the base DB part of the `Kernel` struct and move this to `NewKernel`. Methods that need the DB can use it from there and expect it to be non-nil. There's no Burrow without a DB.,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 11:35:19,267295103,"@@ -73,300 +65,305 @@ const (
 // Kernel is the root structure of Burrow
 type Kernel struct {
 	// Expose these public-facing interfaces to allow programmatic extension of the Kernel by other projects
-	Emitter    event.Emitter
-	Service    *rpc.Service
-	Launchers  []process.Launcher
-	State      *state.State
-	Blockchain *bcm.Blockchain
-	Node       *tendermint.Node
-	Transactor *execution.Transactor
-	// Time-based UUID randomly generated each time Burrow is started
-	RunID          simpleuuid.UUID
+	Emitter        event.Emitter
+	Service        *rpc.Service
+	Launchers      []process.Launcher
+	State          *state.State
+	Blockchain     *bcm.Blockchain
+	Node           *tendermint.Node
+	Transactor     *execution.Transactor
+	RunID          simpleuuid.UUID // Time-based UUID randomly generated each time Burrow is started
 	Logger         *logging.Logger
+	txCodec        txs.Codec
+	exeOptions     []execution.ExecutionOption
+	exeChecker     execution.BatchExecutor
+	exeCommitter   execution.BatchCommitter
+	keyClient      keys.KeyClient
+	keyStore       *keys.KeyStore
 	nodeInfo       string
 	processes      map[string]process.Process
 	shutdownNotify chan struct{}
 	shutdownOnce   sync.Once
 }
 
-func NewBurrowDB(dbDir string) dbm.DB {
+func newBurrowDB(dbDir string) dbm.DB {
 	return dbm.NewDB(BurrowDBName, dbm.GoLevelDBBackend, dbDir)
 }
 
-func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTypes.PrivValidator,
-	genesisDoc *genesis.GenesisDoc, tmConf *tmConfig.Config, rpcConfig *rpc.RPCConfig, keyConfig *keys.KeysConfig,
-	keyStore *keys.KeyStore, exeOptions []execution.ExecutionOption, authorizedPeersProvider abci.PeersFilterProvider, restore string, nodeKey *crypto.PrivateKey, logger *logging.Logger) (*Kernel, error) {
-
-	var err error
-	kern := &Kernel{
+// NewKernel initializes an empty kernel
+func NewKernel() (*Kernel, error) {
+	runID, err := simpleuuid.NewTime(time.Now()) // Create a random ID based on start time
+	if err != nil {
+		return nil, err
+	}
+	return &Kernel{
+		RunID:          runID,
 		processes:      make(map[string]process.Process),
 		shutdownNotify: make(chan struct{}),
-	}
-	// Create a random ID based on start time
-	kern.RunID, err = simpleuuid.NewTime(time.Now())
+		txCodec:        txs.NewAminoCodec(),
+	}, nil
+}
 
-	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey, log.DefaultTimestampUTC,
-		structure.RunId, kern.RunID.String())
-	tendermintLogger := logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+// SetLogger initializes the kernel with the provided logger
+func (kern *Kernel) SetLogger(logger *logging.Logger) {
+	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey,
+		log.DefaultTimestampUTC, structure.RunId, kern.RunID.String())
 	kern.Logger = logger.WithInfo(structure.CallerKey, log.Caller(LoggingCallerDepth))
-	stateDB := NewBurrowDB(tmConf.DBDir())
+	kern.Emitter = event.NewEmitter(kern.Logger)
+}
 
+func (kern *Kernel) LoadBlockchain(genesisDoc *genesis.GenesisDoc, dbDir string) (stateDB dbm.DB, err error) {
+	stateDB = newBurrowDB(dbDir)",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267295103,https://github.com/hyperledger/burrow/pull/1065#discussion_r267295103,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,This should be renamed `LoadExecutionOptionsFromConfig`. It is not loading an exector,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 11:42:16,267297311,"@@ -73,300 +65,305 @@ const (
 // Kernel is the root structure of Burrow
 type Kernel struct {
 	// Expose these public-facing interfaces to allow programmatic extension of the Kernel by other projects
-	Emitter    event.Emitter
-	Service    *rpc.Service
-	Launchers  []process.Launcher
-	State      *state.State
-	Blockchain *bcm.Blockchain
-	Node       *tendermint.Node
-	Transactor *execution.Transactor
-	// Time-based UUID randomly generated each time Burrow is started
-	RunID          simpleuuid.UUID
+	Emitter        event.Emitter
+	Service        *rpc.Service
+	Launchers      []process.Launcher
+	State          *state.State
+	Blockchain     *bcm.Blockchain
+	Node           *tendermint.Node
+	Transactor     *execution.Transactor
+	RunID          simpleuuid.UUID // Time-based UUID randomly generated each time Burrow is started
 	Logger         *logging.Logger
+	txCodec        txs.Codec
+	exeOptions     []execution.ExecutionOption
+	exeChecker     execution.BatchExecutor
+	exeCommitter   execution.BatchCommitter
+	keyClient      keys.KeyClient
+	keyStore       *keys.KeyStore
 	nodeInfo       string
 	processes      map[string]process.Process
 	shutdownNotify chan struct{}
 	shutdownOnce   sync.Once
 }
 
-func NewBurrowDB(dbDir string) dbm.DB {
+func newBurrowDB(dbDir string) dbm.DB {
 	return dbm.NewDB(BurrowDBName, dbm.GoLevelDBBackend, dbDir)
 }
 
-func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTypes.PrivValidator,
-	genesisDoc *genesis.GenesisDoc, tmConf *tmConfig.Config, rpcConfig *rpc.RPCConfig, keyConfig *keys.KeysConfig,
-	keyStore *keys.KeyStore, exeOptions []execution.ExecutionOption, authorizedPeersProvider abci.PeersFilterProvider, restore string, nodeKey *crypto.PrivateKey, logger *logging.Logger) (*Kernel, error) {
-
-	var err error
-	kern := &Kernel{
+// NewKernel initializes an empty kernel
+func NewKernel() (*Kernel, error) {
+	runID, err := simpleuuid.NewTime(time.Now()) // Create a random ID based on start time
+	if err != nil {
+		return nil, err
+	}
+	return &Kernel{
+		RunID:          runID,
 		processes:      make(map[string]process.Process),
 		shutdownNotify: make(chan struct{}),
-	}
-	// Create a random ID based on start time
-	kern.RunID, err = simpleuuid.NewTime(time.Now())
+		txCodec:        txs.NewAminoCodec(),
+	}, nil
+}
 
-	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey, log.DefaultTimestampUTC,
-		structure.RunId, kern.RunID.String())
-	tendermintLogger := logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+// SetLogger initializes the kernel with the provided logger
+func (kern *Kernel) SetLogger(logger *logging.Logger) {
+	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey,
+		log.DefaultTimestampUTC, structure.RunId, kern.RunID.String())
 	kern.Logger = logger.WithInfo(structure.CallerKey, log.Caller(LoggingCallerDepth))
-	stateDB := NewBurrowDB(tmConf.DBDir())
+	kern.Emitter = event.NewEmitter(kern.Logger)
+}
 
+func (kern *Kernel) LoadBlockchain(genesisDoc *genesis.GenesisDoc, dbDir string) (stateDB dbm.DB, err error) {
+	stateDB = newBurrowDB(dbDir)
 	kern.Blockchain, err = bcm.LoadOrNewBlockchain(stateDB, genesisDoc, kern.Logger)
 	if err != nil {
 		return nil, fmt.Errorf(""error creating or loading blockchain state: %v"", err)
 	}
-
+	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(blockchain.NewBlockStore(stateDB)))
 	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
 	kern.Logger = kern.Logger.With(""height"", heightValuer)
-	tendermintLogger = tendermintLogger.With(""height"", heightValuer)
+	return stateDB, nil
+}
+
+// LoadState starts from scratch or previous chain
+func (kern *Kernel) LoadState(genesisDoc *genesis.GenesisDoc, dbDir string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
+	if err != nil {
+		return err
+	}
 
 	// These should be in sync unless we are at the genesis block
 	if kern.Blockchain.LastBlockHeight() > 0 {
 		kern.Logger.InfoMsg(""Loading application state"")
 		kern.State, err = state.LoadState(stateDB, execution.VersionAtHeight(kern.Blockchain.LastBlockHeight()))
 		if err != nil {
-			return nil, fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
+			return fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
 				kern.Blockchain.AppHashAfterLastBlock(), err)
 		}
 		if !bytes.Equal(kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock()) {
-			return nil, fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
+			return fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
 				""state gives %X, blockchain gives %X"", kern.Blockchain.LastBlockHeight(),
 				kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock())
 		}
-		if restore != """" {
-			return nil, fmt.Errorf(""Cannot restore onto existing chain; don't give --restore-dump argument"")
-		}
 	} else {
 		kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
 		if err != nil {
-			return nil, fmt.Errorf(""could not build genesis state: %v"", err)
+			return fmt.Errorf(""could not build genesis state: %v"", err)
 		}
 
-		if restore != """" {
-			if len(genesisDoc.AppHash) == 0 {
-				return nil, fmt.Errorf(""AppHash is required when restoring chain"")
-			}
+		if err = kern.State.InitialCommit(); err != nil {
+			return err
+		}
+	}
 
-			reader, err := state.NewFileDumpReader(restore)
-			if err != nil {
-				return nil, err
-			}
+	params := execution.ParamsFromGenesis(genesisDoc)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-			err = kern.State.LoadDump(reader)
-			if err != nil {
-				return nil, err
-			}
-		}
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
 
-		err = kern.State.InitialCommit()
-		if err != nil {
-			return nil, err
-		}
+// LoadDump restores chain state from the given dump file
+func (kern *Kernel) LoadDump(genesisDoc *genesis.GenesisDoc, dbDir, restore string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
 
-		if len(genesisDoc.AppHash) != 0 {
-			if !bytes.Equal(genesisDoc.AppHash, kern.State.Hash()) {
-				return nil, fmt.Errorf(""AppHash does not match, got AppHash 0x%X expected 0x%s. Is the correct --restore-dump specified?"", kern.State.Hash(), genesisDoc.AppHash.String())
-			}
-		}
+	kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
+	if err != nil {
+		return fmt.Errorf(""could not build genesis state: %v"", err)
 	}
 
-	kern.Logger.InfoMsg(""State loading successful"")
+	if len(kern.Blockchain.GenesisDoc().AppHash) == 0 {
+		return fmt.Errorf(""AppHash is required when restoring chain"")
+	}
+
+	reader, err := state.NewFileDumpReader(restore)
+	if err != nil {
+		return err
+	}
+
+	if err = kern.State.LoadDump(reader); err != nil {
+		return err
+	}
+
+	if err = kern.State.InitialCommit(); err != nil {
+		return err
+	}
 
-	txCodec := txs.NewAminoCodec()
-	tmGenesisDoc := tendermint.DeriveGenesisDoc(genesisDoc)
 	params := execution.ParamsFromGenesis(genesisDoc)
-	checker := execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-	kern.Emitter = event.NewEmitter(kern.Logger)
-	committer := execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, exeOptions...)
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
+
+// GetNodeView builds and returns a wrapper of our tendermint node
+func (kern *Kernel) GetNodeView() (nodeView *tendermint.NodeView, err error) {
+	nodeView, err = tendermint.NewNodeView(kern.Node, kern.txCodec, kern.RunID)
+	return nodeView, err
+}
+
+// AddExecutionOptions extends our execution options
+func (kern *Kernel) AddExecutionOptions(opts ...execution.ExecutionOption) {
+	kern.exeOptions = append(kern.exeOptions, opts...)
+}
+
+// AddProcesses extends the services that we launch at boot
+func (kern *Kernel) AddProcesses(pl ...process.Launcher) {
+	kern.Launchers = append(kern.Launchers, pl...)
+}
+
+func (kern *Kernel) SetKeyClient(client keys.KeyClient) {
+	kern.keyClient = client
+}
+
+func (kern *Kernel) SetKeyStore(store *keys.KeyStore) {
+	kern.keyStore = store
+}
+
+// TendermintFromConfig loads our consensus engine into the kernel
+func (kern *Kernel) TendermintFromConfig(tmConf *tendermint.BurrowTendermintConfig, privVal tmTypes.PrivValidator, validator *crypto.Address) (err error) {
+	if privVal == nil {
+		val, err := keys.AddressableSigner(kern.keyClient, *validator)
+		if err != nil {
+			return fmt.Errorf(""could not get validator addressable from keys client: %v"", err)
+		}
+		signer, err := keys.AddressableSigner(kern.keyClient, val.GetAddress())
+		if err != nil {
+			return err
+		}
+		privVal = tendermint.NewPrivValidatorMemory(val, signer)
+	}
+
+	authorizedPeersProvider := tmConf.DefaultAuthorizedPeersProvider()
 
 	kern.nodeInfo = fmt.Sprintf(""Burrow_%s_%s_ValidatorID:%X"", project.History.CurrentVersion().String(),
-		genesisDoc.ChainID(), privValidator.GetPubKey().Address())
-	app := abci.NewApp(kern.nodeInfo, kern.Blockchain, kern.State, checker, committer, txCodec, authorizedPeersProvider,
-		kern.Panic, logger)
+		kern.Blockchain.ChainID(), privVal.GetPubKey().Address())
+	app := abci.NewApp(kern.nodeInfo, kern.Blockchain, kern.State, kern.exeChecker, kern.exeCommitter, kern.txCodec, authorizedPeersProvider,
+		kern.Panic, kern.Logger)
+
 	// We could use this to provide/register our own metrics (though this will register them with us). Unfortunately
 	// Tendermint currently ignores the metrics passed unless its own server is turned on.
 	metricsProvider := node.DefaultMetricsProvider(&tmConfig.InstrumentationConfig{
 		Prometheus:           false,
 		PrometheusListenAddr: """",
 	})
-	kern.Node, err = tendermint.NewNode(tmConf, privValidator, tmGenesisDoc, app, metricsProvider, nodeKey, tendermintLogger)
-	if err != nil {
-		return nil, err
-	}
 
-	kern.Transactor = execution.NewTransactor(kern.Blockchain, kern.Emitter,
-		execution.NewAccounts(checker, keyClient, AccountsRingMutexCount),
-		kern.Node.MempoolReactor().Mempool.CheckTx, txCodec, kern.Logger)
+	genesisDoc := kern.Blockchain.GenesisDoc()
 
-	nameRegState := kern.State
-	proposalRegState := kern.State
-	accountState := kern.State
-	nodeView, err := tendermint.NewNodeView(kern.Node, txCodec, kern.RunID)
-	if err != nil {
-		return nil, err
+	// find node key
+	var nodeKey *crypto.PrivateKey
+	for _, v := range genesisDoc.Validators {
+		thisAddress, err := crypto.AddressFromHexString(privVal.GetPubKey().Address().String())
+		if err != nil {
+			break
+		}
+		if v.Address == thisAddress && v.NodeAddress != nil {
+			k, err := kern.keyStore.GetKey("""", v.NodeAddress.Bytes())
+			if err == nil {
+				nodeKey = &k.PrivateKey
+			}
+			break
+		}
 	}
-	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(nodeView.BlockStore()))
-	kern.Service = rpc.NewService(accountState, nameRegState, kern.Blockchain, kern.State, nodeView, kern.Logger)
-
-	kern.Launchers = []process.Launcher{
-		{
-			Name:    ""Profiling Server"",
-			Enabled: rpcConfig.Profiler.Enabled,
-			Launch: func() (process.Process, error) {
-				debugServer := &http.Server{
-					Addr: "":6060"",
-				}
-				go func() {
-					err := debugServer.ListenAndServe()
-					if err != nil {
-						kern.Logger.InfoMsg(""Error from pprof debug server"", structure.ErrorKey, err)
-					}
-				}()
-				return debugServer, nil
-			},
-		},
-		{
-			Name:    ""Database"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				// Just close database
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					stateDB.Close()
-					return nil
-				}), nil
-			},
-		},
-		{
-			Name:    ""Tendermint"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				err := kern.Node.Start()
-				if err != nil {
-					return nil, fmt.Errorf(""error starting Tendermint node: %v"", err)
-				}
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					err := kern.Node.Stop()
-					// Close tendermint database connections using our wrapper
-					defer kern.Node.Close()
-					if err != nil {
-						return err
-					}
-					select {
-					case <-ctx.Done():
-						return ctx.Err()
-					case <-kern.Node.Quit():
-						kern.Logger.InfoMsg(""Tendermint Node has quit, closing DB connections..."")
-						return nil
-					}
-					return err
-				}), nil
-			},
-		},
-		// Run announcer after Tendermint so it can get some details
-		{
-			Name:    ""Startup Announcer"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				info := kern.Node.NodeInfo()
-
-				start := time.Now()
-				logger := kern.Logger.With(
-					""launch_time"", start,
-					""burrow_version"", project.FullVersion(),
-					""tendermint_version"", version.TMCoreSemVer,
-					""validator_address"", privValidator.GetPubKey().Address(),
-					""node_id"", string(info.ID()),
-					""net_address"", info.NetAddress().String(),
-					""genesis_app_hash"", genesisDoc.AppHash.String(),
-					""genesis_hash"", hex.EncodeUpperToString(genesisDoc.Hash()),
-				)
-
-				err := logger.InfoMsg(""Burrow is launching. We have marmot-off."", ""announce"", ""startup"")
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					stop := time.Now()
-					return logger.InfoMsg(""Burrow is shutting down. Prepare for re-entrancy."",
-						""announce"", ""shutdown"",
-						""shutdown_time"", stop,
-						""elapsed_run_time"", stop.Sub(start).String())
-				}), err
-			},
-		},
-		{
-			Name:    ""RPC/info"",
-			Enabled: rpcConfig.Info.Enabled,
-			Launch: func() (process.Process, error) {
-				server, err := rpcinfo.StartServer(kern.Service, ""/websocket"", rpcConfig.Info.ListenAddress, kern.Logger)
-				if err != nil {
-					return nil, err
-				}
-				return server, nil
-			},
-		},
-		{
-			Name:    ""RPC/metrics"",
-			Enabled: rpcConfig.Metrics.Enabled,
-			Launch: func() (process.Process, error) {
-				server, err := metrics.StartServer(kern.Service, rpcConfig.Metrics.MetricsPath,
-					rpcConfig.Metrics.ListenAddress, rpcConfig.Metrics.BlockSampleSize, kern.Logger)
-				if err != nil {
-					return nil, err
-				}
-				return server, nil
-			},
-		},
-		{
-			Name:    ""RPC/GRPC"",
-			Enabled: rpcConfig.GRPC.Enabled,
-			Launch: func() (process.Process, error) {
-				listen, err := net.Listen(""tcp"", rpcConfig.GRPC.ListenAddress)
-				if err != nil {
-					return nil, err
-				}
 
-				grpcServer := rpc.NewGRPCServer(kern.Logger)
-				var ks *keys.KeyStore
-				if keyStore != nil {
-					ks = keyStore
-				}
-
-				if keyConfig.GRPCServiceEnabled {
-					if keyStore == nil {
-						ks = keys.NewKeyStore(keyConfig.KeysDirectory, keyConfig.AllowBadFilePermissions)
-					}
-					keys.RegisterKeysServer(grpcServer, ks)
-				}
+	tmGenesisDoc := tendermint.DeriveGenesisDoc(&genesisDoc)
+	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
+	tmLogger := kern.Logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+	tmLogger = tmLogger.With(""height"", heightValuer)
+	kern.Node, err = tendermint.NewNode(tmConf.TendermintConfig(), privVal, tmGenesisDoc, app, metricsProvider, nodeKey, tmLogger)
+	return err
+}
 
-				rpcquery.RegisterQueryServer(grpcServer, rpcquery.NewQueryServer(kern.State, nameRegState, proposalRegState,
-					kern.Blockchain, kern.State, nodeView, kern.Logger))
+func (kern *Kernel) LoadTransactor() (err error) {
+	nodeView, err := kern.GetNodeView()
+	if err != nil {
+		return err
+	}
 
-				rpctransact.RegisterTransactServer(grpcServer, rpctransact.NewTransactServer(kern.Transactor, txCodec))
+	accountState := kern.State
+	nameRegState := kern.State
+	kern.Service = rpc.NewService(accountState, nameRegState, kern.Blockchain, kern.State, nodeView, kern.Logger)
 
-				rpcevents.RegisterExecutionEventsServer(grpcServer, rpcevents.NewExecutionEventsServer(kern.State,
-					kern.Emitter, kern.Blockchain, kern.Logger))
+	if nodeView == nil {
+		checkTx := func(tx tmTypes.Tx, cb func(*abciTypes.Response)) error {
+			ctx := abci.TxExecutor(""CheckTx"", kern.exeChecker, kern.txCodec, kern.Logger.WithScope(""CheckTx""))(tx)
+			dtx := abci.TxExecutor(""DeliverTx"", kern.exeCommitter, kern.txCodec, kern.Logger.WithScope(""DeliverTx""))(tx)
+			appHash, err := kern.exeCommitter.Commit(nil)
+			if err != nil {
+				return err
+			}
+			kern.Blockchain.CommitBlock(time.Now(), nil, appHash)
+
+			cb(abciTypes.ToResponseCheckTx(ctx))
+			cb(abciTypes.ToResponseDeliverTx(abciTypes.ResponseDeliverTx{
+				Code:      dtx.Code,
+				Log:       dtx.Log,
+				Data:      dtx.Data,
+				Tags:      dtx.Tags,
+				GasUsed:   dtx.GasUsed,
+				GasWanted: dtx.GasWanted,
+				Info:      dtx.Info,
+			}))
+
+			cb(abciTypes.ToResponseCommit(abciTypes.ResponseCommit{
+				Data: appHash,
+			}))
+
+			return nil
+		}
 
-				rpcdump.RegisterDumpServer(grpcServer, rpcdump.NewDumpServer(kern.State,
-					kern.Blockchain, nodeView, kern.Logger))
+		kern.Transactor = execution.NewTransactor(kern.Blockchain, kern.Emitter,
+			execution.NewAccounts(kern.exeChecker, kern.keyClient, AccountsRingMutexCount),
+			checkTx, kern.txCodec, kern.Logger)
+	} else {
+		kern.Blockchain.SetBlockStore(bcm.NewBlockStore(nodeView.BlockStore()))
+		kern.Transactor = execution.NewTransactor(kern.Blockchain, kern.Emitter,
+			execution.NewAccounts(kern.exeChecker, kern.keyClient, AccountsRingMutexCount),
+			kern.Node.MempoolReactor().Mempool.CheckTx, kern.txCodec, kern.Logger)
+	}
+	return nil
+}
 
-				// Provides metadata about services registered
-				//reflection.Register(grpcServer)
+// KeysFromConfig sets the keyClient & keyStore based on the given config
+func (kern *Kernel) KeysFromConfig(conf *keys.KeysConfig) (err error) {
+	if conf.RemoteAddress != """" {
+		kern.keyClient, err = keys.NewRemoteKeyClient(conf.RemoteAddress, kern.Logger)
+		if err != nil {
+			return err
+		}
+	} else {
+		kern.keyStore = keys.NewKeyStore(conf.KeysDirectory, conf.AllowBadFilePermissions)
+		kern.keyClient = keys.NewLocalKeyClient(kern.keyStore, kern.Logger)
+	}
+	return nil
+}
 
-				go grpcServer.Serve(listen)
+// LoggerFromConfig adds a logging configuration to the kernel
+func (kern *Kernel) LoggerFromConfig(conf *logconfig.LoggingConfig) error {
+	logger, err := lifecycle.NewLoggerFromLoggingConfig(conf)
+	kern.SetLogger(logger)
+	return err
+}
 
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					grpcServer.Stop()
-					// listener is closed for us
-					return nil
-				}), nil
-			},
-		},
+// ExecutorFromConfig builds the execution options for the kernel
+func (kern *Kernel) ExecutorFromConfig(conf *execution.ExecutionConfig) error {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267297311,https://github.com/hyperledger/burrow/pull/1065#discussion_r267297311,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,"I thought we had mentioned that `burrow restore` should not start a chain. So do not load tendermint, do not boot, do not shutdown. Perform the load and exit. Only `burrow start` should load a chain. `burrow restore` should be a one-off run - we dont' want to do it every time a pod rolls over.",9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 11:46:36,267298678,"@@ -0,0 +1,72 @@
+package commands
+
+import (
+	""github.com/hyperledger/burrow/core""
+	cli ""github.com/jawher/mow.cli""
+)
+
+func Restore(output Output) func(cmd *cli.Cmd) {
+	return func(cmd *cli.Cmd) {
+		genesisOpt := cmd.StringOpt(""g genesis"", """",
+			""Use the specified genesis JSON file rather than a key in the main config, use - to read from STDIN"")
+
+		configOpt := cmd.StringOpt(""c config"", """", ""Use the specified burrow config file"")
+
+		filename := cmd.StringArg(""FILE"", """", ""Restore from this dump"")
+
+		cmd.Spec = ""[--config=<config file>] [--genesis=<genesis json file>] [FILE]""
+
+		configOpts := addConfigOptions(cmd)
+
+		cmd.Action = func() {
+			conf, err := obtainBurrowConfig(*configOpt, *genesisOpt)
+			if err != nil {
+				output.Fatalf(""could not obtain config: %v"", err)
+			}
+
+			err = configOpts.configure(conf)
+			if err != nil {
+				output.Fatalf(""could not update burrow config: %v"", err)
+			}
+
+			if conf.ValidatorAddress == nil {
+				output.Fatalf(""could not finalise validator address - please provide one in config or via --validator-address"")
+			}
+
+			output.Logf(""Using validator address: %s"", *conf.ValidatorAddress)
+
+			kern, err := core.NewKernel()
+			if err != nil {
+				output.Fatalf(""could not create Burrow kernel: %v"", err)
+			}
+
+			if err = kern.ExecutorFromConfig(conf.Execution); err != nil {
+				output.Fatalf(""could not add execution options: %v"", err)
+			}
+
+			if err = kern.LoggerFromConfig(conf.Logging); err != nil {
+				output.Fatalf(""could not configure logger: %v"", err)
+			}
+
+			if err = kern.KeysFromConfig(conf.Keys); err != nil {
+				output.Fatalf(""could not configure keys: %v"", err)
+			}
+
+			tmConf := conf.Tendermint.TendermintConfig()
+			if err = kern.LoadDump(conf.GenesisDoc, tmConf.DBDir(), *filename); err != nil {
+				output.Fatalf(""could not load state: %v"", err)
+			}
+
+			if err = kern.TendermintFromConfig(conf.Tendermint, nil, conf.ValidatorAddress); err != nil {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267298678,https://github.com/hyperledger/burrow/pull/1065#discussion_r267298678,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,We don't need keys for a restore - can be removed.,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 11:46:50,267298749,"@@ -0,0 +1,72 @@
+package commands
+
+import (
+	""github.com/hyperledger/burrow/core""
+	cli ""github.com/jawher/mow.cli""
+)
+
+func Restore(output Output) func(cmd *cli.Cmd) {
+	return func(cmd *cli.Cmd) {
+		genesisOpt := cmd.StringOpt(""g genesis"", """",
+			""Use the specified genesis JSON file rather than a key in the main config, use - to read from STDIN"")
+
+		configOpt := cmd.StringOpt(""c config"", """", ""Use the specified burrow config file"")
+
+		filename := cmd.StringArg(""FILE"", """", ""Restore from this dump"")
+
+		cmd.Spec = ""[--config=<config file>] [--genesis=<genesis json file>] [FILE]""
+
+		configOpts := addConfigOptions(cmd)
+
+		cmd.Action = func() {
+			conf, err := obtainBurrowConfig(*configOpt, *genesisOpt)
+			if err != nil {
+				output.Fatalf(""could not obtain config: %v"", err)
+			}
+
+			err = configOpts.configure(conf)
+			if err != nil {
+				output.Fatalf(""could not update burrow config: %v"", err)
+			}
+
+			if conf.ValidatorAddress == nil {
+				output.Fatalf(""could not finalise validator address - please provide one in config or via --validator-address"")
+			}
+
+			output.Logf(""Using validator address: %s"", *conf.ValidatorAddress)
+
+			kern, err := core.NewKernel()
+			if err != nil {
+				output.Fatalf(""could not create Burrow kernel: %v"", err)
+			}
+
+			if err = kern.ExecutorFromConfig(conf.Execution); err != nil {
+				output.Fatalf(""could not add execution options: %v"", err)
+			}
+
+			if err = kern.LoggerFromConfig(conf.Logging); err != nil {
+				output.Fatalf(""could not configure logger: %v"", err)
+			}
+
+			if err = kern.KeysFromConfig(conf.Keys); err != nil {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267298749,https://github.com/hyperledger/burrow/pull/1065#discussion_r267298749,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,Don't need,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 11:48:31,267299244,"@@ -0,0 +1,72 @@
+package commands
+
+import (
+	""github.com/hyperledger/burrow/core""
+	cli ""github.com/jawher/mow.cli""
+)
+
+func Restore(output Output) func(cmd *cli.Cmd) {
+	return func(cmd *cli.Cmd) {
+		genesisOpt := cmd.StringOpt(""g genesis"", """",
+			""Use the specified genesis JSON file rather than a key in the main config, use - to read from STDIN"")
+
+		configOpt := cmd.StringOpt(""c config"", """", ""Use the specified burrow config file"")
+
+		filename := cmd.StringArg(""FILE"", """", ""Restore from this dump"")
+
+		cmd.Spec = ""[--config=<config file>] [--genesis=<genesis json file>] [FILE]""
+
+		configOpts := addConfigOptions(cmd)
+
+		cmd.Action = func() {
+			conf, err := obtainBurrowConfig(*configOpt, *genesisOpt)
+			if err != nil {
+				output.Fatalf(""could not obtain config: %v"", err)
+			}
+
+			err = configOpts.configure(conf)
+			if err != nil {
+				output.Fatalf(""could not update burrow config: %v"", err)
+			}
+
+			if conf.ValidatorAddress == nil {
+				output.Fatalf(""could not finalise validator address - please provide one in config or via --validator-address"")
+			}
+
+			output.Logf(""Using validator address: %s"", *conf.ValidatorAddress)
+
+			kern, err := core.NewKernel()
+			if err != nil {
+				output.Fatalf(""could not create Burrow kernel: %v"", err)
+			}
+
+			if err = kern.ExecutorFromConfig(conf.Execution); err != nil {
+				output.Fatalf(""could not add execution options: %v"", err)
+			}
+
+			if err = kern.LoggerFromConfig(conf.Logging); err != nil {
+				output.Fatalf(""could not configure logger: %v"", err)
+			}
+
+			if err = kern.KeysFromConfig(conf.Keys); err != nil {
+				output.Fatalf(""could not configure keys: %v"", err)
+			}
+
+			tmConf := conf.Tendermint.TendermintConfig()
+			if err = kern.LoadDump(conf.GenesisDoc, tmConf.DBDir(), *filename); err != nil {
+				output.Fatalf(""could not load state: %v"", err)
+			}
+
+			if err = kern.TendermintFromConfig(conf.Tendermint, nil, conf.ValidatorAddress); err != nil {
+				output.Fatalf(""could not configure Tendermint: %v"", err)
+			}
+
+			kern.AddProcesses(core.DefaultServices(kern, conf.RPC, conf.Keys)...)",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267299244,https://github.com/hyperledger/burrow/pull/1065#discussion_r267299244,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,Oops,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 14:48:49,267378234,"@@ -73,300 +65,305 @@ const (
 // Kernel is the root structure of Burrow
 type Kernel struct {
 	// Expose these public-facing interfaces to allow programmatic extension of the Kernel by other projects
-	Emitter    event.Emitter
-	Service    *rpc.Service
-	Launchers  []process.Launcher
-	State      *state.State
-	Blockchain *bcm.Blockchain
-	Node       *tendermint.Node
-	Transactor *execution.Transactor
-	// Time-based UUID randomly generated each time Burrow is started
-	RunID          simpleuuid.UUID
+	Emitter        event.Emitter
+	Service        *rpc.Service
+	Launchers      []process.Launcher
+	State          *state.State
+	Blockchain     *bcm.Blockchain
+	Node           *tendermint.Node
+	Transactor     *execution.Transactor
+	RunID          simpleuuid.UUID // Time-based UUID randomly generated each time Burrow is started
 	Logger         *logging.Logger
+	txCodec        txs.Codec
+	exeOptions     []execution.ExecutionOption
+	exeChecker     execution.BatchExecutor
+	exeCommitter   execution.BatchCommitter
+	keyClient      keys.KeyClient
+	keyStore       *keys.KeyStore
 	nodeInfo       string
 	processes      map[string]process.Process
 	shutdownNotify chan struct{}
 	shutdownOnce   sync.Once
 }
 
-func NewBurrowDB(dbDir string) dbm.DB {
+func newBurrowDB(dbDir string) dbm.DB {
 	return dbm.NewDB(BurrowDBName, dbm.GoLevelDBBackend, dbDir)
 }
 
-func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTypes.PrivValidator,
-	genesisDoc *genesis.GenesisDoc, tmConf *tmConfig.Config, rpcConfig *rpc.RPCConfig, keyConfig *keys.KeysConfig,
-	keyStore *keys.KeyStore, exeOptions []execution.ExecutionOption, authorizedPeersProvider abci.PeersFilterProvider, restore string, nodeKey *crypto.PrivateKey, logger *logging.Logger) (*Kernel, error) {
-
-	var err error
-	kern := &Kernel{
+// NewKernel initializes an empty kernel
+func NewKernel() (*Kernel, error) {
+	runID, err := simpleuuid.NewTime(time.Now()) // Create a random ID based on start time
+	if err != nil {
+		return nil, err
+	}
+	return &Kernel{
+		RunID:          runID,
 		processes:      make(map[string]process.Process),
 		shutdownNotify: make(chan struct{}),
-	}
-	// Create a random ID based on start time
-	kern.RunID, err = simpleuuid.NewTime(time.Now())
+		txCodec:        txs.NewAminoCodec(),
+	}, nil
+}
 
-	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey, log.DefaultTimestampUTC,
-		structure.RunId, kern.RunID.String())
-	tendermintLogger := logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+// SetLogger initializes the kernel with the provided logger
+func (kern *Kernel) SetLogger(logger *logging.Logger) {
+	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey,
+		log.DefaultTimestampUTC, structure.RunId, kern.RunID.String())
 	kern.Logger = logger.WithInfo(structure.CallerKey, log.Caller(LoggingCallerDepth))
-	stateDB := NewBurrowDB(tmConf.DBDir())
+	kern.Emitter = event.NewEmitter(kern.Logger)
+}
 
+func (kern *Kernel) LoadBlockchain(genesisDoc *genesis.GenesisDoc, dbDir string) (stateDB dbm.DB, err error) {
+	stateDB = newBurrowDB(dbDir)
 	kern.Blockchain, err = bcm.LoadOrNewBlockchain(stateDB, genesisDoc, kern.Logger)
 	if err != nil {
 		return nil, fmt.Errorf(""error creating or loading blockchain state: %v"", err)
 	}
-
+	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(blockchain.NewBlockStore(stateDB)))
 	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
 	kern.Logger = kern.Logger.With(""height"", heightValuer)
-	tendermintLogger = tendermintLogger.With(""height"", heightValuer)
+	return stateDB, nil
+}
+
+// LoadState starts from scratch or previous chain
+func (kern *Kernel) LoadState(genesisDoc *genesis.GenesisDoc, dbDir string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
+	if err != nil {
+		return err
+	}
 
 	// These should be in sync unless we are at the genesis block
 	if kern.Blockchain.LastBlockHeight() > 0 {
 		kern.Logger.InfoMsg(""Loading application state"")
 		kern.State, err = state.LoadState(stateDB, execution.VersionAtHeight(kern.Blockchain.LastBlockHeight()))
 		if err != nil {
-			return nil, fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
+			return fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
 				kern.Blockchain.AppHashAfterLastBlock(), err)
 		}
 		if !bytes.Equal(kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock()) {
-			return nil, fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
+			return fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
 				""state gives %X, blockchain gives %X"", kern.Blockchain.LastBlockHeight(),
 				kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock())
 		}
-		if restore != """" {
-			return nil, fmt.Errorf(""Cannot restore onto existing chain; don't give --restore-dump argument"")
-		}
 	} else {
 		kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
 		if err != nil {
-			return nil, fmt.Errorf(""could not build genesis state: %v"", err)
+			return fmt.Errorf(""could not build genesis state: %v"", err)
 		}
 
-		if restore != """" {
-			if len(genesisDoc.AppHash) == 0 {
-				return nil, fmt.Errorf(""AppHash is required when restoring chain"")
-			}
+		if err = kern.State.InitialCommit(); err != nil {
+			return err
+		}
+	}
 
-			reader, err := state.NewFileDumpReader(restore)
-			if err != nil {
-				return nil, err
-			}
+	params := execution.ParamsFromGenesis(genesisDoc)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-			err = kern.State.LoadDump(reader)
-			if err != nil {
-				return nil, err
-			}
-		}
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
 
-		err = kern.State.InitialCommit()
-		if err != nil {
-			return nil, err
-		}
+// LoadDump restores chain state from the given dump file
+func (kern *Kernel) LoadDump(genesisDoc *genesis.GenesisDoc, dbDir, restore string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
 
-		if len(genesisDoc.AppHash) != 0 {
-			if !bytes.Equal(genesisDoc.AppHash, kern.State.Hash()) {
-				return nil, fmt.Errorf(""AppHash does not match, got AppHash 0x%X expected 0x%s. Is the correct --restore-dump specified?"", kern.State.Hash(), genesisDoc.AppHash.String())
-			}
-		}
+	kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
+	if err != nil {
+		return fmt.Errorf(""could not build genesis state: %v"", err)
 	}
 
-	kern.Logger.InfoMsg(""State loading successful"")
+	if len(kern.Blockchain.GenesisDoc().AppHash) == 0 {
+		return fmt.Errorf(""AppHash is required when restoring chain"")
+	}
+
+	reader, err := state.NewFileDumpReader(restore)
+	if err != nil {
+		return err
+	}
+
+	if err = kern.State.LoadDump(reader); err != nil {
+		return err
+	}
+
+	if err = kern.State.InitialCommit(); err != nil {
+		return err
+	}
 
-	txCodec := txs.NewAminoCodec()
-	tmGenesisDoc := tendermint.DeriveGenesisDoc(genesisDoc)
 	params := execution.ParamsFromGenesis(genesisDoc)
-	checker := execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-	kern.Emitter = event.NewEmitter(kern.Logger)
-	committer := execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, exeOptions...)
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
+
+// GetNodeView builds and returns a wrapper of our tendermint node
+func (kern *Kernel) GetNodeView() (nodeView *tendermint.NodeView, err error) {
+	nodeView, err = tendermint.NewNodeView(kern.Node, kern.txCodec, kern.RunID)
+	return nodeView, err
+}
+
+// AddExecutionOptions extends our execution options
+func (kern *Kernel) AddExecutionOptions(opts ...execution.ExecutionOption) {
+	kern.exeOptions = append(kern.exeOptions, opts...)
+}
+
+// AddProcesses extends the services that we launch at boot
+func (kern *Kernel) AddProcesses(pl ...process.Launcher) {
+	kern.Launchers = append(kern.Launchers, pl...)
+}
+
+func (kern *Kernel) SetKeyClient(client keys.KeyClient) {
+	kern.keyClient = client
+}
+
+func (kern *Kernel) SetKeyStore(store *keys.KeyStore) {
+	kern.keyStore = store
+}
+
+// TendermintFromConfig loads our consensus engine into the kernel
+func (kern *Kernel) TendermintFromConfig(tmConf *tendermint.BurrowTendermintConfig, privVal tmTypes.PrivValidator, validator *crypto.Address) (err error) {
+	if privVal == nil {
+		val, err := keys.AddressableSigner(kern.keyClient, *validator)
+		if err != nil {
+			return fmt.Errorf(""could not get validator addressable from keys client: %v"", err)
+		}
+		signer, err := keys.AddressableSigner(kern.keyClient, val.GetAddress())
+		if err != nil {
+			return err
+		}
+		privVal = tendermint.NewPrivValidatorMemory(val, signer)
+	}
+
+	authorizedPeersProvider := tmConf.DefaultAuthorizedPeersProvider()
 
 	kern.nodeInfo = fmt.Sprintf(""Burrow_%s_%s_ValidatorID:%X"", project.History.CurrentVersion().String(),
-		genesisDoc.ChainID(), privValidator.GetPubKey().Address())
-	app := abci.NewApp(kern.nodeInfo, kern.Blockchain, kern.State, checker, committer, txCodec, authorizedPeersProvider,
-		kern.Panic, logger)
+		kern.Blockchain.ChainID(), privVal.GetPubKey().Address())
+	app := abci.NewApp(kern.nodeInfo, kern.Blockchain, kern.State, kern.exeChecker, kern.exeCommitter, kern.txCodec, authorizedPeersProvider,
+		kern.Panic, kern.Logger)
+
 	// We could use this to provide/register our own metrics (though this will register them with us). Unfortunately
 	// Tendermint currently ignores the metrics passed unless its own server is turned on.
 	metricsProvider := node.DefaultMetricsProvider(&tmConfig.InstrumentationConfig{
 		Prometheus:           false,
 		PrometheusListenAddr: """",
 	})
-	kern.Node, err = tendermint.NewNode(tmConf, privValidator, tmGenesisDoc, app, metricsProvider, nodeKey, tendermintLogger)
-	if err != nil {
-		return nil, err
-	}
 
-	kern.Transactor = execution.NewTransactor(kern.Blockchain, kern.Emitter,
-		execution.NewAccounts(checker, keyClient, AccountsRingMutexCount),
-		kern.Node.MempoolReactor().Mempool.CheckTx, txCodec, kern.Logger)
+	genesisDoc := kern.Blockchain.GenesisDoc()
 
-	nameRegState := kern.State
-	proposalRegState := kern.State
-	accountState := kern.State
-	nodeView, err := tendermint.NewNodeView(kern.Node, txCodec, kern.RunID)
-	if err != nil {
-		return nil, err
+	// find node key
+	var nodeKey *crypto.PrivateKey
+	for _, v := range genesisDoc.Validators {
+		thisAddress, err := crypto.AddressFromHexString(privVal.GetPubKey().Address().String())
+		if err != nil {
+			break
+		}
+		if v.Address == thisAddress && v.NodeAddress != nil {
+			k, err := kern.keyStore.GetKey("""", v.NodeAddress.Bytes())
+			if err == nil {
+				nodeKey = &k.PrivateKey
+			}
+			break
+		}
 	}
-	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(nodeView.BlockStore()))
-	kern.Service = rpc.NewService(accountState, nameRegState, kern.Blockchain, kern.State, nodeView, kern.Logger)
-
-	kern.Launchers = []process.Launcher{
-		{
-			Name:    ""Profiling Server"",
-			Enabled: rpcConfig.Profiler.Enabled,
-			Launch: func() (process.Process, error) {
-				debugServer := &http.Server{
-					Addr: "":6060"",
-				}
-				go func() {
-					err := debugServer.ListenAndServe()
-					if err != nil {
-						kern.Logger.InfoMsg(""Error from pprof debug server"", structure.ErrorKey, err)
-					}
-				}()
-				return debugServer, nil
-			},
-		},
-		{
-			Name:    ""Database"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				// Just close database
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					stateDB.Close()
-					return nil
-				}), nil
-			},
-		},
-		{
-			Name:    ""Tendermint"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				err := kern.Node.Start()
-				if err != nil {
-					return nil, fmt.Errorf(""error starting Tendermint node: %v"", err)
-				}
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					err := kern.Node.Stop()
-					// Close tendermint database connections using our wrapper
-					defer kern.Node.Close()
-					if err != nil {
-						return err
-					}
-					select {
-					case <-ctx.Done():
-						return ctx.Err()
-					case <-kern.Node.Quit():
-						kern.Logger.InfoMsg(""Tendermint Node has quit, closing DB connections..."")
-						return nil
-					}
-					return err
-				}), nil
-			},
-		},
-		// Run announcer after Tendermint so it can get some details
-		{
-			Name:    ""Startup Announcer"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				info := kern.Node.NodeInfo()
-
-				start := time.Now()
-				logger := kern.Logger.With(
-					""launch_time"", start,
-					""burrow_version"", project.FullVersion(),
-					""tendermint_version"", version.TMCoreSemVer,
-					""validator_address"", privValidator.GetPubKey().Address(),
-					""node_id"", string(info.ID()),
-					""net_address"", info.NetAddress().String(),
-					""genesis_app_hash"", genesisDoc.AppHash.String(),
-					""genesis_hash"", hex.EncodeUpperToString(genesisDoc.Hash()),
-				)
-
-				err := logger.InfoMsg(""Burrow is launching. We have marmot-off."", ""announce"", ""startup"")
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					stop := time.Now()
-					return logger.InfoMsg(""Burrow is shutting down. Prepare for re-entrancy."",
-						""announce"", ""shutdown"",
-						""shutdown_time"", stop,
-						""elapsed_run_time"", stop.Sub(start).String())
-				}), err
-			},
-		},
-		{
-			Name:    ""RPC/info"",
-			Enabled: rpcConfig.Info.Enabled,
-			Launch: func() (process.Process, error) {
-				server, err := rpcinfo.StartServer(kern.Service, ""/websocket"", rpcConfig.Info.ListenAddress, kern.Logger)
-				if err != nil {
-					return nil, err
-				}
-				return server, nil
-			},
-		},
-		{
-			Name:    ""RPC/metrics"",
-			Enabled: rpcConfig.Metrics.Enabled,
-			Launch: func() (process.Process, error) {
-				server, err := metrics.StartServer(kern.Service, rpcConfig.Metrics.MetricsPath,
-					rpcConfig.Metrics.ListenAddress, rpcConfig.Metrics.BlockSampleSize, kern.Logger)
-				if err != nil {
-					return nil, err
-				}
-				return server, nil
-			},
-		},
-		{
-			Name:    ""RPC/GRPC"",
-			Enabled: rpcConfig.GRPC.Enabled,
-			Launch: func() (process.Process, error) {
-				listen, err := net.Listen(""tcp"", rpcConfig.GRPC.ListenAddress)
-				if err != nil {
-					return nil, err
-				}
 
-				grpcServer := rpc.NewGRPCServer(kern.Logger)
-				var ks *keys.KeyStore
-				if keyStore != nil {
-					ks = keyStore
-				}
-
-				if keyConfig.GRPCServiceEnabled {
-					if keyStore == nil {
-						ks = keys.NewKeyStore(keyConfig.KeysDirectory, keyConfig.AllowBadFilePermissions)
-					}
-					keys.RegisterKeysServer(grpcServer, ks)
-				}
+	tmGenesisDoc := tendermint.DeriveGenesisDoc(&genesisDoc)
+	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
+	tmLogger := kern.Logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+	tmLogger = tmLogger.With(""height"", heightValuer)
+	kern.Node, err = tendermint.NewNode(tmConf.TendermintConfig(), privVal, tmGenesisDoc, app, metricsProvider, nodeKey, tmLogger)
+	return err
+}
 
-				rpcquery.RegisterQueryServer(grpcServer, rpcquery.NewQueryServer(kern.State, nameRegState, proposalRegState,
-					kern.Blockchain, kern.State, nodeView, kern.Logger))
+func (kern *Kernel) LoadTransactor() (err error) {
+	nodeView, err := kern.GetNodeView()
+	if err != nil {
+		return err
+	}
 
-				rpctransact.RegisterTransactServer(grpcServer, rpctransact.NewTransactServer(kern.Transactor, txCodec))
+	accountState := kern.State
+	nameRegState := kern.State
+	kern.Service = rpc.NewService(accountState, nameRegState, kern.Blockchain, kern.State, nodeView, kern.Logger)
 
-				rpcevents.RegisterExecutionEventsServer(grpcServer, rpcevents.NewExecutionEventsServer(kern.State,
-					kern.Emitter, kern.Blockchain, kern.Logger))
+	if nodeView == nil {
+		checkTx := func(tx tmTypes.Tx, cb func(*abciTypes.Response)) error {
+			ctx := abci.TxExecutor(""CheckTx"", kern.exeChecker, kern.txCodec, kern.Logger.WithScope(""CheckTx""))(tx)
+			dtx := abci.TxExecutor(""DeliverTx"", kern.exeCommitter, kern.txCodec, kern.Logger.WithScope(""DeliverTx""))(tx)
+			appHash, err := kern.exeCommitter.Commit(nil)
+			if err != nil {
+				return err
+			}
+			kern.Blockchain.CommitBlock(time.Now(), nil, appHash)",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267378234,https://github.com/hyperledger/burrow/pull/1065#discussion_r267378234,gregdhill
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,I like that :),9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 14:49:22,267378507,"@@ -73,300 +65,305 @@ const (
 // Kernel is the root structure of Burrow
 type Kernel struct {
 	// Expose these public-facing interfaces to allow programmatic extension of the Kernel by other projects
-	Emitter    event.Emitter
-	Service    *rpc.Service
-	Launchers  []process.Launcher
-	State      *state.State
-	Blockchain *bcm.Blockchain
-	Node       *tendermint.Node
-	Transactor *execution.Transactor
-	// Time-based UUID randomly generated each time Burrow is started
-	RunID          simpleuuid.UUID
+	Emitter        event.Emitter
+	Service        *rpc.Service
+	Launchers      []process.Launcher
+	State          *state.State
+	Blockchain     *bcm.Blockchain
+	Node           *tendermint.Node
+	Transactor     *execution.Transactor
+	RunID          simpleuuid.UUID // Time-based UUID randomly generated each time Burrow is started
 	Logger         *logging.Logger
+	txCodec        txs.Codec
+	exeOptions     []execution.ExecutionOption
+	exeChecker     execution.BatchExecutor
+	exeCommitter   execution.BatchCommitter
+	keyClient      keys.KeyClient
+	keyStore       *keys.KeyStore
 	nodeInfo       string
 	processes      map[string]process.Process
 	shutdownNotify chan struct{}
 	shutdownOnce   sync.Once
 }
 
-func NewBurrowDB(dbDir string) dbm.DB {
+func newBurrowDB(dbDir string) dbm.DB {
 	return dbm.NewDB(BurrowDBName, dbm.GoLevelDBBackend, dbDir)
 }
 
-func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTypes.PrivValidator,
-	genesisDoc *genesis.GenesisDoc, tmConf *tmConfig.Config, rpcConfig *rpc.RPCConfig, keyConfig *keys.KeysConfig,
-	keyStore *keys.KeyStore, exeOptions []execution.ExecutionOption, authorizedPeersProvider abci.PeersFilterProvider, restore string, nodeKey *crypto.PrivateKey, logger *logging.Logger) (*Kernel, error) {
-
-	var err error
-	kern := &Kernel{
+// NewKernel initializes an empty kernel
+func NewKernel() (*Kernel, error) {
+	runID, err := simpleuuid.NewTime(time.Now()) // Create a random ID based on start time
+	if err != nil {
+		return nil, err
+	}
+	return &Kernel{
+		RunID:          runID,
 		processes:      make(map[string]process.Process),
 		shutdownNotify: make(chan struct{}),
-	}
-	// Create a random ID based on start time
-	kern.RunID, err = simpleuuid.NewTime(time.Now())
+		txCodec:        txs.NewAminoCodec(),
+	}, nil
+}
 
-	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey, log.DefaultTimestampUTC,
-		structure.RunId, kern.RunID.String())
-	tendermintLogger := logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+// SetLogger initializes the kernel with the provided logger
+func (kern *Kernel) SetLogger(logger *logging.Logger) {
+	logger = logger.WithScope(""NewKernel()"").With(structure.TimeKey,
+		log.DefaultTimestampUTC, structure.RunId, kern.RunID.String())
 	kern.Logger = logger.WithInfo(structure.CallerKey, log.Caller(LoggingCallerDepth))
-	stateDB := NewBurrowDB(tmConf.DBDir())
+	kern.Emitter = event.NewEmitter(kern.Logger)
+}
 
+func (kern *Kernel) LoadBlockchain(genesisDoc *genesis.GenesisDoc, dbDir string) (stateDB dbm.DB, err error) {
+	stateDB = newBurrowDB(dbDir)
 	kern.Blockchain, err = bcm.LoadOrNewBlockchain(stateDB, genesisDoc, kern.Logger)
 	if err != nil {
 		return nil, fmt.Errorf(""error creating or loading blockchain state: %v"", err)
 	}
-
+	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(blockchain.NewBlockStore(stateDB)))
 	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
 	kern.Logger = kern.Logger.With(""height"", heightValuer)
-	tendermintLogger = tendermintLogger.With(""height"", heightValuer)
+	return stateDB, nil
+}
+
+// LoadState starts from scratch or previous chain
+func (kern *Kernel) LoadState(genesisDoc *genesis.GenesisDoc, dbDir string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
+	if err != nil {
+		return err
+	}
 
 	// These should be in sync unless we are at the genesis block
 	if kern.Blockchain.LastBlockHeight() > 0 {
 		kern.Logger.InfoMsg(""Loading application state"")
 		kern.State, err = state.LoadState(stateDB, execution.VersionAtHeight(kern.Blockchain.LastBlockHeight()))
 		if err != nil {
-			return nil, fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
+			return fmt.Errorf(""could not load persisted execution state at hash 0x%X: %v"",
 				kern.Blockchain.AppHashAfterLastBlock(), err)
 		}
 		if !bytes.Equal(kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock()) {
-			return nil, fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
+			return fmt.Errorf(""state and blockchain disagree on hash for block at height %d: ""+
 				""state gives %X, blockchain gives %X"", kern.Blockchain.LastBlockHeight(),
 				kern.State.Hash(), kern.Blockchain.AppHashAfterLastBlock())
 		}
-		if restore != """" {
-			return nil, fmt.Errorf(""Cannot restore onto existing chain; don't give --restore-dump argument"")
-		}
 	} else {
 		kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
 		if err != nil {
-			return nil, fmt.Errorf(""could not build genesis state: %v"", err)
+			return fmt.Errorf(""could not build genesis state: %v"", err)
 		}
 
-		if restore != """" {
-			if len(genesisDoc.AppHash) == 0 {
-				return nil, fmt.Errorf(""AppHash is required when restoring chain"")
-			}
+		if err = kern.State.InitialCommit(); err != nil {
+			return err
+		}
+	}
 
-			reader, err := state.NewFileDumpReader(restore)
-			if err != nil {
-				return nil, err
-			}
+	params := execution.ParamsFromGenesis(genesisDoc)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-			err = kern.State.LoadDump(reader)
-			if err != nil {
-				return nil, err
-			}
-		}
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
 
-		err = kern.State.InitialCommit()
-		if err != nil {
-			return nil, err
-		}
+// LoadDump restores chain state from the given dump file
+func (kern *Kernel) LoadDump(genesisDoc *genesis.GenesisDoc, dbDir, restore string) (err error) {
+	stateDB, err := kern.LoadBlockchain(genesisDoc, dbDir)
 
-		if len(genesisDoc.AppHash) != 0 {
-			if !bytes.Equal(genesisDoc.AppHash, kern.State.Hash()) {
-				return nil, fmt.Errorf(""AppHash does not match, got AppHash 0x%X expected 0x%s. Is the correct --restore-dump specified?"", kern.State.Hash(), genesisDoc.AppHash.String())
-			}
-		}
+	kern.State, err = state.MakeGenesisState(stateDB, genesisDoc)
+	if err != nil {
+		return fmt.Errorf(""could not build genesis state: %v"", err)
 	}
 
-	kern.Logger.InfoMsg(""State loading successful"")
+	if len(kern.Blockchain.GenesisDoc().AppHash) == 0 {
+		return fmt.Errorf(""AppHash is required when restoring chain"")
+	}
+
+	reader, err := state.NewFileDumpReader(restore)
+	if err != nil {
+		return err
+	}
+
+	if err = kern.State.LoadDump(reader); err != nil {
+		return err
+	}
+
+	if err = kern.State.InitialCommit(); err != nil {
+		return err
+	}
 
-	txCodec := txs.NewAminoCodec()
-	tmGenesisDoc := tendermint.DeriveGenesisDoc(genesisDoc)
 	params := execution.ParamsFromGenesis(genesisDoc)
-	checker := execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeChecker = execution.NewBatchChecker(kern.State, params, kern.Blockchain, kern.Logger)
+	kern.exeCommitter = execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, kern.exeOptions...)
 
-	kern.Emitter = event.NewEmitter(kern.Logger)
-	committer := execution.NewBatchCommitter(kern.State, params, kern.Blockchain, kern.Emitter, kern.Logger, exeOptions...)
+	kern.Logger.InfoMsg(""State loading successful"")
+	return nil
+}
+
+// GetNodeView builds and returns a wrapper of our tendermint node
+func (kern *Kernel) GetNodeView() (nodeView *tendermint.NodeView, err error) {
+	nodeView, err = tendermint.NewNodeView(kern.Node, kern.txCodec, kern.RunID)
+	return nodeView, err
+}
+
+// AddExecutionOptions extends our execution options
+func (kern *Kernel) AddExecutionOptions(opts ...execution.ExecutionOption) {
+	kern.exeOptions = append(kern.exeOptions, opts...)
+}
+
+// AddProcesses extends the services that we launch at boot
+func (kern *Kernel) AddProcesses(pl ...process.Launcher) {
+	kern.Launchers = append(kern.Launchers, pl...)
+}
+
+func (kern *Kernel) SetKeyClient(client keys.KeyClient) {
+	kern.keyClient = client
+}
+
+func (kern *Kernel) SetKeyStore(store *keys.KeyStore) {
+	kern.keyStore = store
+}
+
+// TendermintFromConfig loads our consensus engine into the kernel
+func (kern *Kernel) TendermintFromConfig(tmConf *tendermint.BurrowTendermintConfig, privVal tmTypes.PrivValidator, validator *crypto.Address) (err error) {
+	if privVal == nil {
+		val, err := keys.AddressableSigner(kern.keyClient, *validator)
+		if err != nil {
+			return fmt.Errorf(""could not get validator addressable from keys client: %v"", err)
+		}
+		signer, err := keys.AddressableSigner(kern.keyClient, val.GetAddress())
+		if err != nil {
+			return err
+		}
+		privVal = tendermint.NewPrivValidatorMemory(val, signer)
+	}
+
+	authorizedPeersProvider := tmConf.DefaultAuthorizedPeersProvider()
 
 	kern.nodeInfo = fmt.Sprintf(""Burrow_%s_%s_ValidatorID:%X"", project.History.CurrentVersion().String(),
-		genesisDoc.ChainID(), privValidator.GetPubKey().Address())
-	app := abci.NewApp(kern.nodeInfo, kern.Blockchain, kern.State, checker, committer, txCodec, authorizedPeersProvider,
-		kern.Panic, logger)
+		kern.Blockchain.ChainID(), privVal.GetPubKey().Address())
+	app := abci.NewApp(kern.nodeInfo, kern.Blockchain, kern.State, kern.exeChecker, kern.exeCommitter, kern.txCodec, authorizedPeersProvider,
+		kern.Panic, kern.Logger)
+
 	// We could use this to provide/register our own metrics (though this will register them with us). Unfortunately
 	// Tendermint currently ignores the metrics passed unless its own server is turned on.
 	metricsProvider := node.DefaultMetricsProvider(&tmConfig.InstrumentationConfig{
 		Prometheus:           false,
 		PrometheusListenAddr: """",
 	})
-	kern.Node, err = tendermint.NewNode(tmConf, privValidator, tmGenesisDoc, app, metricsProvider, nodeKey, tendermintLogger)
-	if err != nil {
-		return nil, err
-	}
 
-	kern.Transactor = execution.NewTransactor(kern.Blockchain, kern.Emitter,
-		execution.NewAccounts(checker, keyClient, AccountsRingMutexCount),
-		kern.Node.MempoolReactor().Mempool.CheckTx, txCodec, kern.Logger)
+	genesisDoc := kern.Blockchain.GenesisDoc()
 
-	nameRegState := kern.State
-	proposalRegState := kern.State
-	accountState := kern.State
-	nodeView, err := tendermint.NewNodeView(kern.Node, txCodec, kern.RunID)
-	if err != nil {
-		return nil, err
+	// find node key
+	var nodeKey *crypto.PrivateKey
+	for _, v := range genesisDoc.Validators {
+		thisAddress, err := crypto.AddressFromHexString(privVal.GetPubKey().Address().String())
+		if err != nil {
+			break
+		}
+		if v.Address == thisAddress && v.NodeAddress != nil {
+			k, err := kern.keyStore.GetKey("""", v.NodeAddress.Bytes())
+			if err == nil {
+				nodeKey = &k.PrivateKey
+			}
+			break
+		}
 	}
-	kern.Blockchain.SetBlockStore(bcm.NewBlockStore(nodeView.BlockStore()))
-	kern.Service = rpc.NewService(accountState, nameRegState, kern.Blockchain, kern.State, nodeView, kern.Logger)
-
-	kern.Launchers = []process.Launcher{
-		{
-			Name:    ""Profiling Server"",
-			Enabled: rpcConfig.Profiler.Enabled,
-			Launch: func() (process.Process, error) {
-				debugServer := &http.Server{
-					Addr: "":6060"",
-				}
-				go func() {
-					err := debugServer.ListenAndServe()
-					if err != nil {
-						kern.Logger.InfoMsg(""Error from pprof debug server"", structure.ErrorKey, err)
-					}
-				}()
-				return debugServer, nil
-			},
-		},
-		{
-			Name:    ""Database"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				// Just close database
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					stateDB.Close()
-					return nil
-				}), nil
-			},
-		},
-		{
-			Name:    ""Tendermint"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				err := kern.Node.Start()
-				if err != nil {
-					return nil, fmt.Errorf(""error starting Tendermint node: %v"", err)
-				}
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					err := kern.Node.Stop()
-					// Close tendermint database connections using our wrapper
-					defer kern.Node.Close()
-					if err != nil {
-						return err
-					}
-					select {
-					case <-ctx.Done():
-						return ctx.Err()
-					case <-kern.Node.Quit():
-						kern.Logger.InfoMsg(""Tendermint Node has quit, closing DB connections..."")
-						return nil
-					}
-					return err
-				}), nil
-			},
-		},
-		// Run announcer after Tendermint so it can get some details
-		{
-			Name:    ""Startup Announcer"",
-			Enabled: true,
-			Launch: func() (process.Process, error) {
-				info := kern.Node.NodeInfo()
-
-				start := time.Now()
-				logger := kern.Logger.With(
-					""launch_time"", start,
-					""burrow_version"", project.FullVersion(),
-					""tendermint_version"", version.TMCoreSemVer,
-					""validator_address"", privValidator.GetPubKey().Address(),
-					""node_id"", string(info.ID()),
-					""net_address"", info.NetAddress().String(),
-					""genesis_app_hash"", genesisDoc.AppHash.String(),
-					""genesis_hash"", hex.EncodeUpperToString(genesisDoc.Hash()),
-				)
-
-				err := logger.InfoMsg(""Burrow is launching. We have marmot-off."", ""announce"", ""startup"")
-				return process.ShutdownFunc(func(ctx context.Context) error {
-					stop := time.Now()
-					return logger.InfoMsg(""Burrow is shutting down. Prepare for re-entrancy."",
-						""announce"", ""shutdown"",
-						""shutdown_time"", stop,
-						""elapsed_run_time"", stop.Sub(start).String())
-				}), err
-			},
-		},
-		{
-			Name:    ""RPC/info"",
-			Enabled: rpcConfig.Info.Enabled,
-			Launch: func() (process.Process, error) {
-				server, err := rpcinfo.StartServer(kern.Service, ""/websocket"", rpcConfig.Info.ListenAddress, kern.Logger)
-				if err != nil {
-					return nil, err
-				}
-				return server, nil
-			},
-		},
-		{
-			Name:    ""RPC/metrics"",
-			Enabled: rpcConfig.Metrics.Enabled,
-			Launch: func() (process.Process, error) {
-				server, err := metrics.StartServer(kern.Service, rpcConfig.Metrics.MetricsPath,
-					rpcConfig.Metrics.ListenAddress, rpcConfig.Metrics.BlockSampleSize, kern.Logger)
-				if err != nil {
-					return nil, err
-				}
-				return server, nil
-			},
-		},
-		{
-			Name:    ""RPC/GRPC"",
-			Enabled: rpcConfig.GRPC.Enabled,
-			Launch: func() (process.Process, error) {
-				listen, err := net.Listen(""tcp"", rpcConfig.GRPC.ListenAddress)
-				if err != nil {
-					return nil, err
-				}
 
-				grpcServer := rpc.NewGRPCServer(kern.Logger)
-				var ks *keys.KeyStore
-				if keyStore != nil {
-					ks = keyStore
-				}
-
-				if keyConfig.GRPCServiceEnabled {
-					if keyStore == nil {
-						ks = keys.NewKeyStore(keyConfig.KeysDirectory, keyConfig.AllowBadFilePermissions)
-					}
-					keys.RegisterKeysServer(grpcServer, ks)
-				}
+	tmGenesisDoc := tendermint.DeriveGenesisDoc(&genesisDoc)
+	heightValuer := log.Valuer(func() interface{} { return kern.Blockchain.LastBlockHeight() })
+	tmLogger := kern.Logger.With(structure.CallerKey, log.Caller(LoggingCallerDepth+1))
+	tmLogger = tmLogger.With(""height"", heightValuer)
+	kern.Node, err = tendermint.NewNode(tmConf.TendermintConfig(), privVal, tmGenesisDoc, app, metricsProvider, nodeKey, tmLogger)
+	return err
+}
 
-				rpcquery.RegisterQueryServer(grpcServer, rpcquery.NewQueryServer(kern.State, nameRegState, proposalRegState,
-					kern.Blockchain, kern.State, nodeView, kern.Logger))
+func (kern *Kernel) LoadTransactor() (err error) {
+	nodeView, err := kern.GetNodeView()
+	if err != nil {
+		return err
+	}
 
-				rpctransact.RegisterTransactServer(grpcServer, rpctransact.NewTransactServer(kern.Transactor, txCodec))
+	accountState := kern.State
+	nameRegState := kern.State
+	kern.Service = rpc.NewService(accountState, nameRegState, kern.Blockchain, kern.State, nodeView, kern.Logger)
 
-				rpcevents.RegisterExecutionEventsServer(grpcServer, rpcevents.NewExecutionEventsServer(kern.State,
-					kern.Emitter, kern.Blockchain, kern.Logger))
+	if nodeView == nil {
+		checkTx := func(tx tmTypes.Tx, cb func(*abciTypes.Response)) error {
+			ctx := abci.TxExecutor(""CheckTx"", kern.exeChecker, kern.txCodec, kern.Logger.WithScope(""CheckTx""))(tx)
+			dtx := abci.TxExecutor(""DeliverTx"", kern.exeCommitter, kern.txCodec, kern.Logger.WithScope(""DeliverTx""))(tx)
+			appHash, err := kern.exeCommitter.Commit(nil)
+			if err != nil {
+				return err
+			}
+			kern.Blockchain.CommitBlock(time.Now(), nil, appHash)
+
+			cb(abciTypes.ToResponseCheckTx(ctx))
+			cb(abciTypes.ToResponseDeliverTx(abciTypes.ResponseDeliverTx{",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267378507,https://github.com/hyperledger/burrow/pull/1065#discussion_r267378507,gregdhill
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,Yeah I agree,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 14:58:07,267383600,"@@ -36,16 +33,34 @@ func Start(output Output) func(cmd *cli.Cmd) {
 
 			output.Logf(""Using validator address: %s"", *conf.ValidatorAddress)
 
-			ctx, cancel := context.WithCancel(context.Background())
-			defer cancel()
-
-			kern, err := conf.Kernel(ctx, *restoreDumpOpt)
+			kern, err := core.NewKernel()
 			if err != nil {
 				output.Fatalf(""could not create Burrow kernel: %v"", err)
 			}
 
-			err = kern.Boot()
-			if err != nil {
+			if err = kern.ExecutorFromConfig(conf.Execution); err != nil {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267383600,https://github.com/hyperledger/burrow/pull/1065#discussion_r267383600,gregdhill
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,that makes more sense :+1: ,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-20 15:00:13,267384750,"@@ -0,0 +1,72 @@
+package commands
+
+import (
+	""github.com/hyperledger/burrow/core""
+	cli ""github.com/jawher/mow.cli""
+)
+
+func Restore(output Output) func(cmd *cli.Cmd) {
+	return func(cmd *cli.Cmd) {
+		genesisOpt := cmd.StringOpt(""g genesis"", """",
+			""Use the specified genesis JSON file rather than a key in the main config, use - to read from STDIN"")
+
+		configOpt := cmd.StringOpt(""c config"", """", ""Use the specified burrow config file"")
+
+		filename := cmd.StringArg(""FILE"", """", ""Restore from this dump"")
+
+		cmd.Spec = ""[--config=<config file>] [--genesis=<genesis json file>] [FILE]""
+
+		configOpts := addConfigOptions(cmd)
+
+		cmd.Action = func() {
+			conf, err := obtainBurrowConfig(*configOpt, *genesisOpt)
+			if err != nil {
+				output.Fatalf(""could not obtain config: %v"", err)
+			}
+
+			err = configOpts.configure(conf)
+			if err != nil {
+				output.Fatalf(""could not update burrow config: %v"", err)
+			}
+
+			if conf.ValidatorAddress == nil {
+				output.Fatalf(""could not finalise validator address - please provide one in config or via --validator-address"")
+			}
+
+			output.Logf(""Using validator address: %s"", *conf.ValidatorAddress)
+
+			kern, err := core.NewKernel()
+			if err != nil {
+				output.Fatalf(""could not create Burrow kernel: %v"", err)
+			}
+
+			if err = kern.ExecutorFromConfig(conf.Execution); err != nil {
+				output.Fatalf(""could not add execution options: %v"", err)
+			}
+
+			if err = kern.LoggerFromConfig(conf.Logging); err != nil {
+				output.Fatalf(""could not configure logger: %v"", err)
+			}
+
+			if err = kern.KeysFromConfig(conf.Keys); err != nil {
+				output.Fatalf(""could not configure keys: %v"", err)
+			}
+
+			tmConf := conf.Tendermint.TendermintConfig()
+			if err = kern.LoadDump(conf.GenesisDoc, tmConf.DBDir(), *filename); err != nil {
+				output.Fatalf(""could not load state: %v"", err)
+			}
+
+			if err = kern.TendermintFromConfig(conf.Tendermint, nil, conf.ValidatorAddress); err != nil {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267384750,https://github.com/hyperledger/burrow/pull/1065#discussion_r267384750,gregdhill
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,This appears to be unused and unuseful as far as I can see,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-21 16:48:22,267855200,"@@ -69,6 +69,10 @@ func NewTransactor(tip bcm.BlockchainInfo, subscribable event.Subscribable, memp
 	}
 }
 
+func SimCheckTx(tx tmTypes.Tx, cb func(*abciTypes.Response)) error {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267855200,https://github.com/hyperledger/burrow/pull/1065#discussion_r267855200,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,"This was back in my 'interfaces' stage... I don't think it really earns its keep. Not down to you but rather than adding `SetLogger` interface can we just kill this interface, make `emitter` public and return a pointer to that.",9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-21 16:56:36,267859255,"@@ -52,10 +52,15 @@ func (pf PublisherFunc) Publish(ctx context.Context, message interface{}, tags q
 	return pf(ctx, message, tags)
 }
 
+type SetLogger interface {
+	SetLogger(logger *logging.Logger)
+}
+
 type Emitter interface {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/267859255,https://github.com/hyperledger/burrow/pull/1065#discussion_r267859255,silasdavis
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,This was leftover from my initial attempt at the no-consensus transactor,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-22 08:44:19,268077611,"@@ -69,6 +69,10 @@ func NewTransactor(tip bcm.BlockchainInfo, subscribable event.Subscribable, memp
 	}
 }
 
+func SimCheckTx(tx tmTypes.Tx, cb func(*abciTypes.Response)) error {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/268077611,https://github.com/hyperledger/burrow/pull/1065#discussion_r268077611,gregdhill
https://github.com/hyperledger/burrow/pull/1065,https://github.com/hyperledger/burrow/pull/1065,Emitter is now exposed ,9850f80d680b71e8f69c4e8ffcfca4051239583a,2019-03-22 08:44:49,268077774,"@@ -52,10 +52,15 @@ func (pf PublisherFunc) Publish(ctx context.Context, message interface{}, tags q
 	return pf(ctx, message, tags)
 }
 
+type SetLogger interface {
+	SetLogger(logger *logging.Logger)
+}
+
 type Emitter interface {",,2019-03-22 09:39:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/268077774,https://github.com/hyperledger/burrow/pull/1065#discussion_r268077774,gregdhill
https://github.com/hyperledger/burrow/pull/1046,https://github.com/hyperledger/burrow/pull/1046,"This should be ; on windows else ""burrow vent start --abi c:\abis"" is not going to work.",58f5297081c8847b8b7bd7499ab7d3338d4c9a8d,2019-03-01 13:00:50,261593882,"@@ -169,25 +170,27 @@ func LoadPath(abiFileOrDir string) (*AbiSpec, error) {
 
 	specs := make([]*AbiSpec, 0)
 
-	err := filepath.Walk(abiFileOrDir, func(path string, fi os.FileInfo, err error) error {
-		if err != nil {
-			return fmt.Errorf(""error returned while walking abiDir '%s': %v"", abiFileOrDir, err)
-		}
-		ext := filepath.Ext(path)
-		if fi.IsDir() || !(ext == "".bin"" || ext == "".abi"") {
-			return nil
-		}
-		if err == nil {
-			abiSpc, err := ReadAbiSpecFile(path)
+	for _, dir := range strings.Split(abiFileOrDir, "":"") {",,2019-03-01 13:42:40,https://api.github.com/repos/hyperledger/burrow/pulls/comments/261593882,https://github.com/hyperledger/burrow/pull/1046#discussion_r261593882,seanyoung
https://github.com/hyperledger/burrow/pull/1046,https://github.com/hyperledger/burrow/pull/1046,same here,58f5297081c8847b8b7bd7499ab7d3338d4c9a8d,2019-03-01 13:02:41,261594415,"@@ -40,39 +40,41 @@ func NewProjectionFromBytes(bs []byte) (*Projection, error) {
 }
 
 // NewProjectionFromFolder creates a Projection from a folder containing spec files
-func NewProjectionFromFolder(fileOrDir string) (*Projection, error) {
+func NewProjectionFromFolder(specFileOrDir string) (*Projection, error) {
 	eventSpec := types.EventSpec{}
 
 	const errHeader = ""NewProjectionFromFolder():""
 
-	err := filepath.Walk(fileOrDir, func(path string, _ os.FileInfo, err error) error {
-		if err != nil {
-			return fmt.Errorf(""error walking event spec files location '%s': %v"", fileOrDir, err)
-		}
-		if filepath.Ext(path) == "".json"" {
-			bs, err := readFile(path)
+	for _, dir := range strings.Split(specFileOrDir, "":"") {",,2019-03-01 13:42:40,https://api.github.com/repos/hyperledger/burrow/pulls/comments/261594415,https://github.com/hyperledger/burrow/pull/1046#discussion_r261594415,seanyoung
https://github.com/hyperledger/burrow/pull/1046,https://github.com/hyperledger/burrow/pull/1046,Leftover? ^,58f5297081c8847b8b7bd7499ab7d3338d4c9a8d,2019-03-01 15:26:10,261644705,"@@ -689,6 +689,7 @@ func TestRevert(t *testing.T) {
 
 	output, cErr := ourVm.Call(cache, NewNoopEventSink(), account1, account2, bytecode, []byte{}, 0, &gas)
 	assert.Error(t, cErr, ""Expected execution reverted error"")
+	fmt.Println(cErr)",4,2019-03-01 15:41:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/261644705,https://github.com/hyperledger/burrow/pull/1046#discussion_r261644705,gregdhill
https://github.com/hyperledger/burrow/pull/1046,https://github.com/hyperledger/burrow/pull/1046,Leftover comment?,58f5297081c8847b8b7bd7499ab7d3338d4c9a8d,2019-03-01 15:27:19,261645206,"@@ -68,13 +69,14 @@ type params struct {
 type GenesisDoc struct {
 	GenesisTime       time.Time
 	ChainName         string
-	AppHash           string `json:"",omitempty"" toml:"",omitempty""`
-	hash              []byte
-	Params            params `json:"",omitempty"" toml:"",omitempty""`
-	Salt              []byte `json:"",omitempty"" toml:"",omitempty""`
+	AppHash           binary.HexBytes `json:"",omitempty"" toml:"",omitempty""`
+	Params            params          `json:"",omitempty"" toml:"",omitempty""`
+	Salt              []byte          `json:"",omitempty"" toml:"",omitempty""`
 	GlobalPermissions permission.AccountPermissions
 	Accounts          []Account
 	Validators        []Validator
+	// memo",29,2019-03-01 15:41:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/261645206,https://github.com/hyperledger/burrow/pull/1046#discussion_r261645206,gregdhill
https://github.com/hyperledger/burrow/pull/1046,https://github.com/hyperledger/burrow/pull/1046,Is this the correct error message?,58f5297081c8847b8b7bd7499ab7d3338d4c9a8d,2019-03-01 15:39:27,261650268,"@@ -184,6 +184,7 @@ func TestRevert(t *testing.T) {
 	contractAddress := txe.Receipt.ContractAddress
 	txe = rpctest.CallContract(t, tcli, inputAddress, contractAddress, data)
 	assert.Equal(t, errors.ErrorCodeExecutionReverted, txe.Exception.Code)
+	assert.Contains(t, txe.Exception.Error(), ""I have reverted"")",13,2019-03-01 15:41:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/261650268,https://github.com/hyperledger/burrow/pull/1046#discussion_r261650268,gregdhill
https://github.com/hyperledger/burrow/pull/1046,https://github.com/hyperledger/burrow/pull/1046,yep but good spot,58f5297081c8847b8b7bd7499ab7d3338d4c9a8d,2019-03-01 15:50:46,261654595,"@@ -184,6 +184,7 @@ func TestRevert(t *testing.T) {
 	contractAddress := txe.Receipt.ContractAddress
 	txe = rpctest.CallContract(t, tcli, inputAddress, contractAddress, data)
 	assert.Equal(t, errors.ErrorCodeExecutionReverted, txe.Exception.Code)
+	assert.Contains(t, txe.Exception.Error(), ""I have reverted"")",13,2019-03-01 15:50:47,https://api.github.com/repos/hyperledger/burrow/pulls/comments/261654595,https://github.com/hyperledger/burrow/pull/1046#discussion_r261654595,silasdavis
https://github.com/hyperledger/burrow/pull/1039,https://github.com/hyperledger/burrow/pull/1039,debug printf?,314a6d35cbd50600367661ae743fce6344cb7f6e,2019-02-27 12:37:17,260728462,"@@ -286,12 +286,22 @@ func Keys(output Output) func(cmd *cli.Cmd) {
 				if err != nil {
 					output.Fatalf(""failed to hex decode message: %v"", err)
 				}
+				curveType, err := crypto.CurveTypeFromString(*curveTypeOpt)
+				if err != nil {
+					output.Fatalf(""invalid curve type: %v"", err)
+				}
 
-				signature, err := hex.DecodeString(*sig)
+				fmt.Println(len(*sig))",,2019-02-27 12:40:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/260728462,https://github.com/hyperledger/burrow/pull/1039#discussion_r260728462,seanyoung
https://github.com/hyperledger/burrow/pull/1034,https://github.com/hyperledger/burrow/pull/1034,"Oh, whoops. Does this not have a test?",20f2a96f917694e9e8f940cd37dbc3ba57a644b6,2019-02-26 14:30:43,260309618,"@@ -126,7 +126,7 @@ func (ws *writeState) SetStorage(address crypto.Address, key, value binary.Word2
 }
 
 func (s *ReadState) IterateStorage(address crypto.Address, consumer func(key, value binary.Word256) error) error {
-	keyFormat := keys.Storage
+	keyFormat := keys.Storage.Fix(address)",5,2019-02-26 14:30:43,https://api.github.com/repos/hyperledger/burrow/pulls/comments/260309618,https://github.com/hyperledger/burrow/pull/1034#discussion_r260309618,silasdavis
https://github.com/hyperledger/burrow/pull/1029,https://github.com/hyperledger/burrow/pull/1029,`nil` vs `[]string{}` normalisation issue - this was easiest work around for tests,e11706da30d90ac0e5f7564bc05268d73ad37d71,2019-02-22 10:12:36,259282284,"@@ -19,7 +19,7 @@ func TestUnmarshal(t *testing.T) {
     source: foo
     target: bar
     permissions: [foo, bar]
-    roles: []
+    roles: [""foo""]",5,2019-02-22 12:43:24,https://api.github.com/repos/hyperledger/burrow/pulls/comments/259282284,https://github.com/hyperledger/burrow/pull/1029#discussion_r259282284,silasdavis
https://github.com/hyperledger/burrow/pull/1028,https://github.com/hyperledger/burrow/pull/1028,"Can we have a doc comment on this, particularly for what the return values are",07f3200d05ed5b05ddf7a25c021bd7a765e476f6,2019-02-21 08:36:37,258824092,"@@ -1165,7 +1166,7 @@ func (abiSpec *AbiSpec) UnpackWithID(data []byte, args ...interface{}) error {
 	})
 }
 
-func (abiSpec *AbiSpec) Pack(fname string, args ...interface{}) ([]byte, error) {
+func (abiSpec *AbiSpec) Pack(fname string, args ...interface{}) ([]byte, bool, error) {",28,2019-02-21 10:07:40,https://api.github.com/repos/hyperledger/burrow/pulls/comments/258824092,https://github.com/hyperledger/burrow/pull/1028#discussion_r258824092,silasdavis
https://github.com/hyperledger/burrow/pull/1028,https://github.com/hyperledger/burrow/pull/1028,doc comment,07f3200d05ed5b05ddf7a25c021bd7a765e476f6,2019-02-21 08:36:50,258824166,"@@ -27,10 +27,10 @@ func init() {
 
 var RevertAbi *AbiSpec
 
-func ReadAbiFormulateCallFile(abiLocation, binPath, funcName string, args []string) ([]byte, error) {
+func ReadAbiFormulateCallFile(abiLocation, binPath, funcName string, args []string) ([]byte, bool, error) {",,2019-02-21 10:07:40,https://api.github.com/repos/hyperledger/burrow/pulls/comments/258824166,https://github.com/hyperledger/burrow/pull/1028#discussion_r258824166,silasdavis
https://github.com/hyperledger/burrow/pull/1028,https://github.com/hyperledger/burrow/pull/1028,doc comment,07f3200d05ed5b05ddf7a25c021bd7a765e476f6,2019-02-21 08:36:59,258824226,"@@ -41,7 +41,7 @@ func ReadAbiFormulateCallFile(abiLocation, binPath, funcName string, args []stri
 	return Packer(abiSpecBytes, funcName, args...)
 }
 
-func ReadAbiFormulateCall(abiSpecBytes []byte, funcName string, args []string) ([]byte, error) {
+func ReadAbiFormulateCall(abiSpecBytes []byte, funcName string, args []string) ([]byte, bool, error) {",,2019-02-21 10:07:40,https://api.github.com/repos/hyperledger/burrow/pulls/comments/258824226,https://github.com/hyperledger/burrow/pull/1028#discussion_r258824226,silasdavis
https://github.com/hyperledger/burrow/pull/1028,https://github.com/hyperledger/burrow/pull/1028,doc comment,07f3200d05ed5b05ddf7a25c021bd7a765e476f6,2019-02-21 08:37:05,258824260,"@@ -63,30 +63,30 @@ func ReadAndDecodeContractReturn(abiLocation, binPath, funcName string, resultRa
 }
 
 //Convenience Packing Functions
-func Packer(abiData, funcName string, args ...string) ([]byte, error) {
+func Packer(abiData, funcName string, args ...string) ([]byte, bool, error) {",,2019-02-21 10:07:40,https://api.github.com/repos/hyperledger/burrow/pulls/comments/258824260,https://github.com/hyperledger/burrow/pull/1028#discussion_r258824260,silasdavis
https://github.com/hyperledger/burrow/pull/1028,https://github.com/hyperledger/burrow/pull/1028,Add godoc,07f3200d05ed5b05ddf7a25c021bd7a765e476f6,2019-02-21 10:08:45,258859186,"@@ -1165,7 +1166,7 @@ func (abiSpec *AbiSpec) UnpackWithID(data []byte, args ...interface{}) error {
 	})
 }
 
-func (abiSpec *AbiSpec) Pack(fname string, args ...interface{}) ([]byte, error) {
+func (abiSpec *AbiSpec) Pack(fname string, args ...interface{}) ([]byte, bool, error) {",28,2019-02-21 10:08:46,https://api.github.com/repos/hyperledger/burrow/pulls/comments/258859186,https://github.com/hyperledger/burrow/pull/1028#discussion_r258859186,seanyoung
https://github.com/hyperledger/burrow/pull/1028,https://github.com/hyperledger/burrow/pull/1028,Add godoc and give function sensible name,07f3200d05ed5b05ddf7a25c021bd7a765e476f6,2019-02-21 10:09:04,258859303,"@@ -27,10 +27,10 @@ func init() {
 
 var RevertAbi *AbiSpec
 
-func ReadAbiFormulateCallFile(abiLocation, binPath, funcName string, args []string) ([]byte, error) {
+func ReadAbiFormulateCallFile(abiLocation, binPath, funcName string, args []string) ([]byte, bool, error) {",,2019-02-21 10:09:05,https://api.github.com/repos/hyperledger/burrow/pulls/comments/258859303,https://github.com/hyperledger/burrow/pull/1028#discussion_r258859303,seanyoung
https://github.com/hyperledger/burrow/pull/1028,https://github.com/hyperledger/burrow/pull/1028,Add godoc and give function sensible name,07f3200d05ed5b05ddf7a25c021bd7a765e476f6,2019-02-21 10:09:09,258859329,"@@ -41,7 +41,7 @@ func ReadAbiFormulateCallFile(abiLocation, binPath, funcName string, args []stri
 	return Packer(abiSpecBytes, funcName, args...)
 }
 
-func ReadAbiFormulateCall(abiSpecBytes []byte, funcName string, args []string) ([]byte, error) {
+func ReadAbiFormulateCall(abiSpecBytes []byte, funcName string, args []string) ([]byte, bool, error) {",,2019-02-21 10:09:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/258859329,https://github.com/hyperledger/burrow/pull/1028#discussion_r258859329,seanyoung
https://github.com/hyperledger/burrow/pull/1028,https://github.com/hyperledger/burrow/pull/1028,function gone,07f3200d05ed5b05ddf7a25c021bd7a765e476f6,2019-02-21 10:09:20,258859390,"@@ -63,30 +63,30 @@ func ReadAndDecodeContractReturn(abiLocation, binPath, funcName string, resultRa
 }
 
 //Convenience Packing Functions
-func Packer(abiData, funcName string, args ...string) ([]byte, error) {
+func Packer(abiData, funcName string, args ...string) ([]byte, bool, error) {",,2019-02-21 10:09:20,https://api.github.com/repos/hyperledger/burrow/pulls/comments/258859390,https://github.com/hyperledger/burrow/pull/1028#discussion_r258859390,seanyoung
https://github.com/hyperledger/burrow/pull/1013,https://github.com/hyperledger/burrow/pull/1013,"That looks like a an underflow waiting to happen, i.e. if we iterate from block 0 then lastHeightSeen will be -1 and the leveldb reader does not deal with negatives well.",9bc40debd1baaaa35215a42fab18e28ccc4b53de,2019-02-18 16:51:25,257769023,"@@ -193,14 +193,15 @@ func (ees *executionEventsServer) subscribeBlockExecution(ctx context.Context, c
 	return nil
 }
 
-func (ees *executionEventsServer) iterateBlockEvents(start, end uint64, consumer func(*exec.StreamEvent) error) (lastHeightSeen uint64, err error) {
-	err = ees.eventsProvider.IterateStreamEvents(start, end, func(blockEvent *exec.StreamEvent) error {
-		if blockEvent.TxExecution == nil {
-			// nil safe
-			lastHeightSeen = blockEvent.GetEndBlock().GetHeight()
+func (ees *executionEventsServer) iterateBlockEvents(start, end uint64, consumer func(*exec.StreamEvent) error) (uint64, error) {
+	// Assume that we have seen the previous block before start to have ended up here
+	lastHeightSeen := start - 1",13,2019-02-18 17:02:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/257769023,https://github.com/hyperledger/burrow/pull/1013#discussion_r257769023,seanyoung
https://github.com/hyperledger/burrow/pull/1013,https://github.com/hyperledger/burrow/pull/1013,"You are right, I have added a comment that notes this is true but we get away with it in this case.",9bc40debd1baaaa35215a42fab18e28ccc4b53de,2019-02-18 17:04:13,257773104,"@@ -193,14 +193,15 @@ func (ees *executionEventsServer) subscribeBlockExecution(ctx context.Context, c
 	return nil
 }
 
-func (ees *executionEventsServer) iterateBlockEvents(start, end uint64, consumer func(*exec.StreamEvent) error) (lastHeightSeen uint64, err error) {
-	err = ees.eventsProvider.IterateStreamEvents(start, end, func(blockEvent *exec.StreamEvent) error {
-		if blockEvent.TxExecution == nil {
-			// nil safe
-			lastHeightSeen = blockEvent.GetEndBlock().GetHeight()
+func (ees *executionEventsServer) iterateBlockEvents(start, end uint64, consumer func(*exec.StreamEvent) error) (uint64, error) {
+	// Assume that we have seen the previous block before start to have ended up here
+	lastHeightSeen := start - 1",13,2019-02-18 17:04:14,https://api.github.com/repos/hyperledger/burrow/pulls/comments/257773104,https://github.com/hyperledger/burrow/pull/1013#discussion_r257773104,silasdavis
https://github.com/hyperledger/burrow/pull/1010,https://github.com/hyperledger/burrow/pull/1010,"Can we split this into 3 functions: one private one with sig as currently, one as previously, and one with current sig that is public called `MakeGenesisStateFromDump` or similar. ",49c7a4f4cba24456cac9741949201626b8789455,2019-02-07 17:48:11,254796875,"@@ -130,7 +130,7 @@ func NewState(db dbm.DB) *State {
 }
 
 // Make genesis state from GenesisDoc and save to DB
-func MakeGenesisState(db dbm.DB, genesisDoc *genesis.GenesisDoc) (*State, error) {
+func MakeGenesisState(db dbm.DB, genesisDoc *genesis.GenesisDoc, restore DumpReader) (*State, error) {",,2019-02-07 18:10:50,https://api.github.com/repos/hyperledger/burrow/pulls/comments/254796875,https://github.com/hyperledger/burrow/pull/1010#discussion_r254796875,silasdavis
https://github.com/hyperledger/burrow/pull/1010,https://github.com/hyperledger/burrow/pull/1010,sweet,49c7a4f4cba24456cac9741949201626b8789455,2019-02-07 17:53:10,254798696,"@@ -0,0 +1,101 @@
+package state
+
+import (
+	""fmt""
+	""math/rand""
+	""testing""
+
+	""github.com/hyperledger/burrow/acm""
+	""github.com/hyperledger/burrow/genesis""
+	""github.com/stretchr/testify/require""
+	dbm ""github.com/tendermint/tendermint/libs/db""
+
+	""github.com/hyperledger/burrow/binary""
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/dump""
+	""github.com/hyperledger/burrow/execution/exec""
+	""github.com/hyperledger/burrow/execution/names""
+)
+
+type MockDumpReader struct {
+	accounts int
+	storage  int
+	names    int
+	events   int
+}
+
+func (m *MockDumpReader) Next() (*dump.Dump, error) {",27,2019-02-07 18:10:50,https://api.github.com/repos/hyperledger/burrow/pulls/comments/254798696,https://github.com/hyperledger/burrow/pull/1010#discussion_r254798696,silasdavis
https://github.com/hyperledger/burrow/pull/1010,https://github.com/hyperledger/burrow/pull/1010,"If split it in another way, please let me know what you think",49c7a4f4cba24456cac9741949201626b8789455,2019-02-07 18:08:17,254804400,"@@ -130,7 +130,7 @@ func NewState(db dbm.DB) *State {
 }
 
 // Make genesis state from GenesisDoc and save to DB
-func MakeGenesisState(db dbm.DB, genesisDoc *genesis.GenesisDoc) (*State, error) {
+func MakeGenesisState(db dbm.DB, genesisDoc *genesis.GenesisDoc, restore DumpReader) (*State, error) {",,2019-02-07 18:10:50,https://api.github.com/repos/hyperledger/burrow/pulls/comments/254804400,https://github.com/hyperledger/burrow/pull/1010#discussion_r254804400,seanyoung
https://github.com/hyperledger/burrow/pull/1008,https://github.com/hyperledger/burrow/pull/1008,This can also fail on `abi.UnpackEvent` (and there may be other failure branches down this path in future). Do we always want to log the error and carry on in this case? Would it ever be better to fail-stop? Perhaps not. Events are at least local - we have a chance the next event could work. </thinking aloud>,4edd1ea12ce2064f50fd649c422113db10d97523,2019-02-06 10:43:06,254218527,"@@ -217,11 +217,20 @@ func (c *Consumer) Run(parser *sqlsol.Parser, abiSpec *abi.AbiSpec, stream bool)
 								// unpack, decode & build event data
 								eventData, err := buildEventData(spec, parser, event, abiSpec, c.Log)",2,2019-02-06 12:29:00,https://api.github.com/repos/hyperledger/burrow/pulls/comments/254218527,https://github.com/hyperledger/burrow/pull/1008#discussion_r254218527,silasdavis
https://github.com/hyperledger/burrow/pull/1008,https://github.com/hyperledger/burrow/pull/1008,We should have this in the sqlite_adapter too - or find a way to share such code - which shouldn't be difficult because this code is identical,4edd1ea12ce2064f50fd649c422113db10d97523,2019-02-06 10:46:06,254219504,"@@ -458,13 +458,19 @@ func (adapter *PostgresAdapter) CleanDBQueries() types.SQLCleanDBQuery {
 		DELETE FROM %s.%s;`,
 		adapter.Schema, types.SQLLogTableName)
 
+	// errors table
+	deleteErrorsQry := fmt.Sprintf(`",51,2019-02-06 12:29:00,https://api.github.com/repos/hyperledger/burrow/pulls/comments/254219504,https://github.com/hyperledger/burrow/pull/1008#discussion_r254219504,silasdavis
https://github.com/hyperledger/burrow/pull/1008,https://github.com/hyperledger/burrow/pull/1008,Hm not sure why we need duplicate labels for height and txhash here. Message makes sense but let's call it messge,4edd1ea12ce2064f50fd649c422113db10d97523,2019-02-06 11:07:12,254226456,"@@ -61,6 +62,11 @@ const (
 	SQLColumnLabelBurrowVer = ""_burrowversion""
 	SQLColumnLabelChainID   = ""_chainid""
 
+	// errors table
+	SQLColumnLabelErrorsHeight  = ""_height""
+	SQLColumnLabelErrorsTxHash  = ""_txhash""
+	SQLColumnLabelErrorsMessage = ""_result""",15,2019-02-06 12:29:00,https://api.github.com/repos/hyperledger/burrow/pulls/comments/254226456,https://github.com/hyperledger/burrow/pull/1008#discussion_r254226456,silasdavis
https://github.com/hyperledger/burrow/pull/1008,https://github.com/hyperledger/burrow/pull/1008,My view it is better to monitor errors rather than failing on an event decode. I see more problems with the current failure mode than I see advantages. Particularly on extended systems where an operator of vent does not have full control over the network and therefore lacks the ability to control events raised by any smart contracts.,4edd1ea12ce2064f50fd649c422113db10d97523,2019-02-06 11:54:39,254241232,"@@ -217,11 +217,20 @@ func (c *Consumer) Run(parser *sqlsol.Parser, abiSpec *abi.AbiSpec, stream bool)
 								// unpack, decode & build event data
 								eventData, err := buildEventData(spec, parser, event, abiSpec, c.Log)",2,2019-02-06 12:29:00,https://api.github.com/repos/hyperledger/burrow/pulls/comments/254241232,https://github.com/hyperledger/burrow/pull/1008#discussion_r254241232,compleatang
https://github.com/hyperledger/burrow/pull/1008,https://github.com/hyperledger/burrow/pull/1008,:heavy_check_mark: ,4edd1ea12ce2064f50fd649c422113db10d97523,2019-02-06 12:09:37,254245615,"@@ -458,13 +458,19 @@ func (adapter *PostgresAdapter) CleanDBQueries() types.SQLCleanDBQuery {
 		DELETE FROM %s.%s;`,
 		adapter.Schema, types.SQLLogTableName)
 
+	// errors table
+	deleteErrorsQry := fmt.Sprintf(`",51,2019-02-06 12:29:00,https://api.github.com/repos/hyperledger/burrow/pulls/comments/254245615,https://github.com/hyperledger/burrow/pull/1008#discussion_r254245615,compleatang
https://github.com/hyperledger/burrow/pull/1008,https://github.com/hyperledger/burrow/pull/1008,":heavy_check_mark: 
",4edd1ea12ce2064f50fd649c422113db10d97523,2019-02-06 12:09:44,254245648,"@@ -61,6 +62,11 @@ const (
 	SQLColumnLabelBurrowVer = ""_burrowversion""
 	SQLColumnLabelChainID   = ""_chainid""
 
+	// errors table
+	SQLColumnLabelErrorsHeight  = ""_height""
+	SQLColumnLabelErrorsTxHash  = ""_txhash""
+	SQLColumnLabelErrorsMessage = ""_result""",15,2019-02-06 12:29:00,https://api.github.com/repos/hyperledger/burrow/pulls/comments/254245648,https://github.com/hyperledger/burrow/pull/1008#discussion_r254245648,compleatang
https://github.com/hyperledger/burrow/pull/1006,https://github.com/hyperledger/burrow/pull/1006,"Now we have BlockExecution and BlockEvent which both contain TxExecutions.

How about naming BlockEvent -> BlockExecutionStream or StreamingBlockExecution?",309877f0bbcec6fb15ad6e35aa0fadf3840c714d,2019-02-05 11:01:03,253817504,"@@ -19,10 +19,28 @@ option (gogoproto.sizer_all) = true;
 option (gogoproto.goproto_registration) = true;
 option (gogoproto.messagename_all) = true;
 
+message BlockEvent {",,2019-02-05 12:07:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/253817504,https://github.com/hyperledger/burrow/pull/1006#discussion_r253817504,seanyoung
https://github.com/hyperledger/burrow/pull/1003,https://github.com/hyperledger/burrow/pull/1003,"The ""current"" block is not committed so has no hash. Should this be ""blockNumber >= vm.params.BlockHeight""",a9ce3d5887fc2fb70d331b04ee5daa4ebf132509,2019-02-01 15:54:37,253099416,"@@ -617,8 +618,9 @@ func (vm *VM) execute(callState Interface, eventSink EventSink, caller, callee c
 			if blockNumber > vm.params.BlockHeight {",,2019-02-01 17:57:14,https://api.github.com/repos/hyperledger/burrow/pulls/comments/253099416,https://github.com/hyperledger/burrow/pull/1003#discussion_r253099416,seanyoung
https://github.com/hyperledger/burrow/pull/1003,https://github.com/hyperledger/burrow/pull/1003,"This is actually the last block so I think we are good: https://github.com/hyperledger/burrow/blob/develop/execution/contexts/call_context.go#L135

?",a9ce3d5887fc2fb70d331b04ee5daa4ebf132509,2019-02-01 16:22:48,253110462,"@@ -617,8 +618,9 @@ func (vm *VM) execute(callState Interface, eventSink EventSink, caller, callee c
 			if blockNumber > vm.params.BlockHeight {",,2019-02-01 17:57:14,https://api.github.com/repos/hyperledger/burrow/pulls/comments/253110462,https://github.com/hyperledger/burrow/pull/1003#discussion_r253110462,silasdavis
https://github.com/hyperledger/burrow/pull/1003,https://github.com/hyperledger/burrow/pull/1003,I think I agree with you remark - we should be passing the height of the block being applied,a9ce3d5887fc2fb70d331b04ee5daa4ebf132509,2019-02-01 17:58:25,253142902,"@@ -617,8 +618,9 @@ func (vm *VM) execute(callState Interface, eventSink EventSink, caller, callee c
 			if blockNumber > vm.params.BlockHeight {",,2019-02-01 17:58:25,https://api.github.com/repos/hyperledger/burrow/pulls/comments/253142902,https://github.com/hyperledger/burrow/pull/1003#discussion_r253142902,silasdavis
https://github.com/hyperledger/burrow/pull/1000,https://github.com/hyperledger/burrow/pull/1000,Great description and implementation ,43b861d56e1d8c4ccbbbe7f4b2a4b2ae6e8f6a55,2019-01-30 18:37:07,252384110,"@@ -0,0 +1,159 @@
+package storage
+
+import (
+	""fmt""
+
+	dbm ""github.com/tendermint/tendermint/libs/db""
+)
+
+const (
+	commitsPrefix = ""c""
+	treePrefix    = ""t""
+)
+
+type ForestReader interface {
+	Reader(prefix []byte) (KVCallbackIterableReader, error)
+}
+
+// MutableForest is a collection of versioned lazily-loaded RWTrees organised by prefix. It maintains a global state hash
+// by storing CommitIDs in a special commitsTree (you could think of it is a two-layer single tree rather than a forest).
+//
+// The trees (or sub-trees if you prefer) in the forest are RWTrees which wrap an IAVL MutableTree routing writes to the
+// MutableTree and reads to the last saved ImmutableTree. In this way reads act only against committed state and can be
+// lock free (this allows us to avoid blocking commits - particularly for long-running iterations).
+//
+// The trees in the forest are created lazily as required by new writes. There is a cache of most recently used trees
+// and trees that may require a save are marked as such. New writes are only available to read after a Save().
+//
+// Here is an example forest (the output is generated by the Dump() function):
+//  .
+//  ├── balances
+//  │   ├── Caitlin -> 2344
+//  │   ├── Cora -> 654456
+//  │   ├── Edward -> 34
+//  │   └── Lindsay -> 654
+//  └── names
+//      ├── Caitlin -> female
+//      ├── Cora -> female
+//      ├── Edward -> male
+//      └── Lindsay -> unisex
+//
+// Here there are two tree indexed by the prefixes 'balances' and 'names'.
+//
+// To perform reads of the forest we access it in the following way:
+//
+//   tree, err := forest.Reader(""names"")
+//   gender := tree.Get(""Cora"")
+//
+// To perform writes:
+//
+//   tree, err := forest.Writer(""names"")
+//   tree.Set(""Cora"", ""unspecified"")
+//
+// If there is no tree currently stored at the prefix passed then it will be created when the forest is saved:
+//
+//  hash, version, err := forest.Save()
+//
+// where the global version for the forest is returned.
+
+type MutableForest struct {",59,2019-01-31 10:35:20,https://api.github.com/repos/hyperledger/burrow/pulls/comments/252384110,https://github.com/hyperledger/burrow/pull/1000#discussion_r252384110,phymbert
https://github.com/hyperledger/burrow/pull/1000,https://github.com/hyperledger/burrow/pull/1000,could it be restored in this PR?,43b861d56e1d8c4ccbbbe7f4b2a4b2ae6e8f6a55,2019-01-30 18:41:29,252385710,"@@ -1,53 +1,43 @@
 package bcm
 
 import (
-	""fmt""
 	""math/big""
-	""testing""
-	""time""
-
-	""github.com/hyperledger/burrow/genesis""
-	""github.com/hyperledger/burrow/logging/logconfig""
-	""github.com/stretchr/testify/assert""
-	""github.com/stretchr/testify/require""
-	""github.com/tendermint/tendermint/libs/db""
 )
 
 var big0 = big.NewInt(0)
 
-func TestBlockchain_Encode(t *testing.T) {
-	genesisDoc, _, validators := genesis.NewDeterministicGenesis(234).
-		GenesisDoc(5, true, 232, 3, true, 34)
-	bc := NewBlockchain(db.NewMemDB(), genesisDoc)
-	bs, err := bc.Encode()
-	require.NoError(t, err)
-	bcOut, err := DecodeBlockchain(bs)
-	require.True(t, bc.validatorCache.Equal(bcOut.validatorCache))
-	require.Equal(t, bc.genesisDoc.GenesisTime, bcOut.genesisDoc.GenesisTime)
-	assert.Equal(t, logconfig.JSONString(bc.genesisDoc), logconfig.JSONString(bcOut.genesisDoc))
-	require.Equal(t, bc.genesisDoc.Hash(), bcOut.genesisDoc.Hash())
-	power := new(big.Int).SetUint64(genesisDoc.Validators[1].Amount)
-	id1 := validators[1].GetPublicKey()
-	var flow *big.Int
-	for i := 0; i < 100; i++ {
-		power := power.Div(power, big.NewInt(2))
-		flow, err = bc.ValidatorWriter().AlterPower(id1, power)
-		fmt.Println(flow)
-		require.NoError(t, err)
-		_, _, err = bc.CommitBlock(time.Now(), []byte(""blockhash""), []byte(""apphash""))
-		require.NoError(t, err)
-		bs, err = bc.Encode()
-		require.NoError(t, err)
-		bcOut, err = DecodeBlockchain(bs)
-		require.True(t, bc.validatorCache.Equal(bcOut.validatorCache))
-	}
-
-	// Should have exponentially decayed to 0
-	assertZero(t, flow)
-	assertZero(t, bc.validatorCache.Power(id1.GetAddress()))
-}
-
-// Since we have -0 and 0 with big.Int due to its representation with a neg flag
-func assertZero(t testing.TB, i *big.Int) {
-	assert.True(t, big0.Cmp(i) == 0, ""expected 0 but got %v"", i)
-}
+//func TestBlockchain_Encode(t *testing.T) {",,2019-01-31 10:35:20,https://api.github.com/repos/hyperledger/burrow/pulls/comments/252385710,https://github.com/hyperledger/burrow/pull/1000#discussion_r252385710,phymbert
https://github.com/hyperledger/burrow/pull/1000,https://github.com/hyperledger/burrow/pull/1000,Glad you agree... went through a number of indecisions...,43b861d56e1d8c4ccbbbe7f4b2a4b2ae6e8f6a55,2019-01-31 10:10:40,252604818,"@@ -0,0 +1,159 @@
+package storage
+
+import (
+	""fmt""
+
+	dbm ""github.com/tendermint/tendermint/libs/db""
+)
+
+const (
+	commitsPrefix = ""c""
+	treePrefix    = ""t""
+)
+
+type ForestReader interface {
+	Reader(prefix []byte) (KVCallbackIterableReader, error)
+}
+
+// MutableForest is a collection of versioned lazily-loaded RWTrees organised by prefix. It maintains a global state hash
+// by storing CommitIDs in a special commitsTree (you could think of it is a two-layer single tree rather than a forest).
+//
+// The trees (or sub-trees if you prefer) in the forest are RWTrees which wrap an IAVL MutableTree routing writes to the
+// MutableTree and reads to the last saved ImmutableTree. In this way reads act only against committed state and can be
+// lock free (this allows us to avoid blocking commits - particularly for long-running iterations).
+//
+// The trees in the forest are created lazily as required by new writes. There is a cache of most recently used trees
+// and trees that may require a save are marked as such. New writes are only available to read after a Save().
+//
+// Here is an example forest (the output is generated by the Dump() function):
+//  .
+//  ├── balances
+//  │   ├── Caitlin -> 2344
+//  │   ├── Cora -> 654456
+//  │   ├── Edward -> 34
+//  │   └── Lindsay -> 654
+//  └── names
+//      ├── Caitlin -> female
+//      ├── Cora -> female
+//      ├── Edward -> male
+//      └── Lindsay -> unisex
+//
+// Here there are two tree indexed by the prefixes 'balances' and 'names'.
+//
+// To perform reads of the forest we access it in the following way:
+//
+//   tree, err := forest.Reader(""names"")
+//   gender := tree.Get(""Cora"")
+//
+// To perform writes:
+//
+//   tree, err := forest.Writer(""names"")
+//   tree.Set(""Cora"", ""unspecified"")
+//
+// If there is no tree currently stored at the prefix passed then it will be created when the forest is saved:
+//
+//  hash, version, err := forest.Save()
+//
+// where the global version for the forest is returned.
+
+type MutableForest struct {",59,2019-01-31 10:35:20,https://api.github.com/repos/hyperledger/burrow/pulls/comments/252604818,https://github.com/hyperledger/burrow/pull/1000#discussion_r252604818,silasdavis
https://github.com/hyperledger/burrow/pull/1000,https://github.com/hyperledger/burrow/pull/1000,"Thanks didn't notice this first time round, then I was going to port it, but just decided not to - bit of weird development test and I wasn't convinced of value. I'll remove.",43b861d56e1d8c4ccbbbe7f4b2a4b2ae6e8f6a55,2019-01-31 10:11:03,252604977,"@@ -1,53 +1,43 @@
 package bcm
 
 import (
-	""fmt""
 	""math/big""
-	""testing""
-	""time""
-
-	""github.com/hyperledger/burrow/genesis""
-	""github.com/hyperledger/burrow/logging/logconfig""
-	""github.com/stretchr/testify/assert""
-	""github.com/stretchr/testify/require""
-	""github.com/tendermint/tendermint/libs/db""
 )
 
 var big0 = big.NewInt(0)
 
-func TestBlockchain_Encode(t *testing.T) {
-	genesisDoc, _, validators := genesis.NewDeterministicGenesis(234).
-		GenesisDoc(5, true, 232, 3, true, 34)
-	bc := NewBlockchain(db.NewMemDB(), genesisDoc)
-	bs, err := bc.Encode()
-	require.NoError(t, err)
-	bcOut, err := DecodeBlockchain(bs)
-	require.True(t, bc.validatorCache.Equal(bcOut.validatorCache))
-	require.Equal(t, bc.genesisDoc.GenesisTime, bcOut.genesisDoc.GenesisTime)
-	assert.Equal(t, logconfig.JSONString(bc.genesisDoc), logconfig.JSONString(bcOut.genesisDoc))
-	require.Equal(t, bc.genesisDoc.Hash(), bcOut.genesisDoc.Hash())
-	power := new(big.Int).SetUint64(genesisDoc.Validators[1].Amount)
-	id1 := validators[1].GetPublicKey()
-	var flow *big.Int
-	for i := 0; i < 100; i++ {
-		power := power.Div(power, big.NewInt(2))
-		flow, err = bc.ValidatorWriter().AlterPower(id1, power)
-		fmt.Println(flow)
-		require.NoError(t, err)
-		_, _, err = bc.CommitBlock(time.Now(), []byte(""blockhash""), []byte(""apphash""))
-		require.NoError(t, err)
-		bs, err = bc.Encode()
-		require.NoError(t, err)
-		bcOut, err = DecodeBlockchain(bs)
-		require.True(t, bc.validatorCache.Equal(bcOut.validatorCache))
-	}
-
-	// Should have exponentially decayed to 0
-	assertZero(t, flow)
-	assertZero(t, bc.validatorCache.Power(id1.GetAddress()))
-}
-
-// Since we have -0 and 0 with big.Int due to its representation with a neg flag
-func assertZero(t testing.TB, i *big.Int) {
-	assert.True(t, big0.Cmp(i) == 0, ""expected 0 but got %v"", i)
-}
+//func TestBlockchain_Encode(t *testing.T) {",,2019-01-31 10:35:20,https://api.github.com/repos/hyperledger/burrow/pulls/comments/252604977,https://github.com/hyperledger/burrow/pull/1000#discussion_r252604977,silasdavis
https://github.com/hyperledger/burrow/pull/988,https://github.com/hyperledger/burrow/pull/988,"commitKeyFormat changed, this is used during startup to load the correct apphash. How can this be compatible?",c277d03816087ac5b0ba83379c6512d648c8989d,2018-12-19 16:13:16,242978005,"@@ -54,15 +54,18 @@ var (
 	storageKeyFormat  = storage.NewMustKeyFormat(""s"", crypto.AddressLength, binary.Word256Length)
 	nameKeyFormat     = storage.NewMustKeyFormat(""n"", storage.VariadicSegmentLength)
 	proposalKeyFormat = storage.NewMustKeyFormat(""p"", sha256.Size)
+
 	// Keys that reference references
 	blockRefKeyFormat = storage.NewMustKeyFormat(""b"", uint64Length)
 	txRefKeyFormat    = storage.NewMustKeyFormat(""t"", uint64Length, uint64Length)
-	// Reference keys
+
+	// Reference keys (that do not contribute to state hash)
 	// TODO: implement content-addressing of code and optionally blocks (to allow reference to block to be stored in state tree)
 	//codeKeyFormat   = storage.NewMustKeyFormat(""c"", sha256.Size)
 	//blockKeyFormat  = storage.NewMustKeyFormat(""b"", sha256.Size)
-	txKeyFormat     = storage.NewMustKeyFormat(""b"", tmhash.Size)
-	commitKeyFormat = storage.NewMustKeyFormat(""x"", tmhash.Size)
+	txKeyFormat = storage.NewMustKeyFormat(""b"", tmhash.Size)
+	// Binding between apphash and version stto
+	commitKeyFormat = storage.NewMustKeyFormat(""v"", uint64Length)",18,2018-12-19 16:16:44,https://api.github.com/repos/hyperledger/burrow/pulls/comments/242978005,https://github.com/hyperledger/burrow/pull/988#discussion_r242978005,seanyoung
https://github.com/hyperledger/burrow/pull/988,https://github.com/hyperledger/burrow/pull/988,commitID and commitKeyFormat both changed?,c277d03816087ac5b0ba83379c6512d648c8989d,2018-12-19 16:16:05,242979171,"@@ -190,23 +184,37 @@ func LoadState(db dbm.DB, hash []byte) (*State, error) {
 	return s, nil
 }
 
+func (s *State) Version() int64 {
+	return s.tree.Version()
+}
+
+func (s *State) CommitID(version int64) (*CommitID, error) {
+	// Get the version associated with this state hash
+	commitID := new(CommitID)
+	err := s.codec.UnmarshalBinary(s.refs.Get(commitKeyFormat.Key(version)), commitID)",88,2018-12-19 16:16:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/242979171,https://github.com/hyperledger/burrow/pull/988#discussion_r242979171,seanyoung
https://github.com/hyperledger/burrow/pull/988,https://github.com/hyperledger/burrow/pull/988,"yep... it won't be, this will need a fresh sync, would have been worth mentioning ",c277d03816087ac5b0ba83379c6512d648c8989d,2018-12-19 17:43:21,243012200,"@@ -54,15 +54,18 @@ var (
 	storageKeyFormat  = storage.NewMustKeyFormat(""s"", crypto.AddressLength, binary.Word256Length)
 	nameKeyFormat     = storage.NewMustKeyFormat(""n"", storage.VariadicSegmentLength)
 	proposalKeyFormat = storage.NewMustKeyFormat(""p"", sha256.Size)
+
 	// Keys that reference references
 	blockRefKeyFormat = storage.NewMustKeyFormat(""b"", uint64Length)
 	txRefKeyFormat    = storage.NewMustKeyFormat(""t"", uint64Length, uint64Length)
-	// Reference keys
+
+	// Reference keys (that do not contribute to state hash)
 	// TODO: implement content-addressing of code and optionally blocks (to allow reference to block to be stored in state tree)
 	//codeKeyFormat   = storage.NewMustKeyFormat(""c"", sha256.Size)
 	//blockKeyFormat  = storage.NewMustKeyFormat(""b"", sha256.Size)
-	txKeyFormat     = storage.NewMustKeyFormat(""b"", tmhash.Size)
-	commitKeyFormat = storage.NewMustKeyFormat(""x"", tmhash.Size)
+	txKeyFormat = storage.NewMustKeyFormat(""b"", tmhash.Size)
+	// Binding between apphash and version stto
+	commitKeyFormat = storage.NewMustKeyFormat(""v"", uint64Length)",18,2018-12-19 17:43:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/243012200,https://github.com/hyperledger/burrow/pull/988#discussion_r243012200,silasdavis
https://github.com/hyperledger/burrow/pull/980,https://github.com/hyperledger/burrow/pull/980,required twice?,a826df093786690e0305fd46942a2257bbb3e954,2018-12-18 19:13:08,242668488,"@@ -426,7 +421,7 @@ type QueryAccount struct {
 
 func (job *QueryAccount) Validate() error {
 	return validation.ValidateStruct(job,
-		validation.Field(&job.Account, validation.Required, rule.AddressOrPlaceholder),
+		validation.Field(&job.Account, validation.Required, validation.Required),",,2018-12-19 10:50:42,https://api.github.com/repos/hyperledger/burrow/pulls/comments/242668488,https://github.com/hyperledger/burrow/pull/980#discussion_r242668488,silasdavis
https://github.com/hyperledger/burrow/pull/980,https://github.com/hyperledger/burrow/pull/980,`keyAddress`*,a826df093786690e0305fd46942a2257bbb3e954,2018-12-18 19:13:32,242668630,"@@ -85,6 +88,25 @@ func (l *localKeyClient) Generate(keyName string, curveType crypto.CurveType) (k
 	return crypto.AddressFromHexString(resp.GetAddress())
 }
 
+func (l *localKeyClient) GetAddressForKeyName(keyName string) (keyAddres crypto.Address, err error) {
+	keyAddres, err = crypto.AddressFromHexString(keyName)",,2018-12-19 10:50:42,https://api.github.com/repos/hyperledger/burrow/pulls/comments/242668630,https://github.com/hyperledger/burrow/pull/980#discussion_r242668630,silasdavis
https://github.com/hyperledger/burrow/pull/980,https://github.com/hyperledger/burrow/pull/980,Should we allow you to query an unnamed key by its address? I'd suggest the way to do that would be to to first attempt `byname[in.KeyName]` then fall through to trying `in.KeyName` as hex address and looking up by address.,a826df093786690e0305fd46942a2257bbb3e954,2018-12-18 19:18:30,242670492,"@@ -255,15 +255,42 @@ func (k *KeyStore) Import(ctx context.Context, in *ImportRequest) (*ImportRespon
 }
 
 func (k *KeyStore) List(ctx context.Context, in *ListRequest) (*ListResponse, error) {
-	names, err := coreNameList(k.keysDirPath)
+	byname, err := coreNameList(k.keysDirPath)
 	if err != nil {
 		return nil, err
 	}
 
 	var list []*KeyID
 
-	for name, addr := range names {
-		list = append(list, &KeyID{KeyName: name, Address: addr})
+	if in.KeyName != """" {
+		if addr, ok := byname[in.KeyName]; ok {",15,2018-12-19 10:50:42,https://api.github.com/repos/hyperledger/burrow/pulls/comments/242670492,https://github.com/hyperledger/burrow/pull/980#discussion_r242670492,silasdavis
https://github.com/hyperledger/burrow/pull/980,https://github.com/hyperledger/burrow/pull/980,Fixed,a826df093786690e0305fd46942a2257bbb3e954,2018-12-19 10:53:36,242872704,"@@ -426,7 +421,7 @@ type QueryAccount struct {
 
 func (job *QueryAccount) Validate() error {
 	return validation.ValidateStruct(job,
-		validation.Field(&job.Account, validation.Required, rule.AddressOrPlaceholder),
+		validation.Field(&job.Account, validation.Required, validation.Required),",,2018-12-19 10:53:37,https://api.github.com/repos/hyperledger/burrow/pulls/comments/242872704,https://github.com/hyperledger/burrow/pull/980#discussion_r242872704,seanyoung
https://github.com/hyperledger/burrow/pull/980,https://github.com/hyperledger/burrow/pull/980,Fixed,a826df093786690e0305fd46942a2257bbb3e954,2018-12-19 10:53:42,242872738,"@@ -85,6 +88,25 @@ func (l *localKeyClient) Generate(keyName string, curveType crypto.CurveType) (k
 	return crypto.AddressFromHexString(resp.GetAddress())
 }
 
+func (l *localKeyClient) GetAddressForKeyName(keyName string) (keyAddres crypto.Address, err error) {
+	keyAddres, err = crypto.AddressFromHexString(keyName)",,2018-12-19 10:53:42,https://api.github.com/repos/hyperledger/burrow/pulls/comments/242872738,https://github.com/hyperledger/burrow/pull/980#discussion_r242872738,seanyoung
https://github.com/hyperledger/burrow/pull/980,https://github.com/hyperledger/burrow/pull/980,"Now ""burrow keys list"" will print all the names for each key and also allow you to select by address",a826df093786690e0305fd46942a2257bbb3e954,2018-12-19 10:54:35,242873007,"@@ -255,15 +255,42 @@ func (k *KeyStore) Import(ctx context.Context, in *ImportRequest) (*ImportRespon
 }
 
 func (k *KeyStore) List(ctx context.Context, in *ListRequest) (*ListResponse, error) {
-	names, err := coreNameList(k.keysDirPath)
+	byname, err := coreNameList(k.keysDirPath)
 	if err != nil {
 		return nil, err
 	}
 
 	var list []*KeyID
 
-	for name, addr := range names {
-		list = append(list, &KeyID{KeyName: name, Address: addr})
+	if in.KeyName != """" {
+		if addr, ok := byname[in.KeyName]; ok {",15,2018-12-19 10:54:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/242873007,https://github.com/hyperledger/burrow/pull/980#discussion_r242873007,seanyoung
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,Was this breaking mac builds?,aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-21 11:38:48,249417642,"@@ -123,7 +123,7 @@ build_race:	check build_race_db
 build_burrow: commit_hash
 	go build -ldflags ""-extldflags '-static' \
 	-X github.com/hyperledger/burrow/project.commit=$(shell cat commit_hash.txt) \
-	-X github.com/hyperledger/burrow/project.date=$(shell date -I)"" \
+	-X github.com/hyperledger/burrow/project.date=$(shell date '+%Y-%m-%d')"" \",5,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249417642,https://github.com/hyperledger/burrow/pull/977#discussion_r249417642,silasdavis
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,Why the redundancy here between Height message?,aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-21 12:13:24,249427969,"@@ -0,0 +1,51 @@
+syntax = 'proto3';
+
+option go_package = ""github.com/hyperledger/burrow/dump"";
+
+import ""github.com/gogo/protobuf/gogoproto/gogo.proto"";
+
+import ""acm.proto"";
+import ""exec.proto"";
+import ""names.proto"";
+
+package dump;
+
+// Enable custom Marshal method.
+option (gogoproto.marshaler_all) = true;
+// Enable custom Unmarshal method.
+option (gogoproto.unmarshaler_all) = true;
+// Enable custom Size method (Required by Marshal and Unmarshal).
+option (gogoproto.sizer_all) = true;
+// Enable registration with golang/protobuf for the grpc-gateway.
+option (gogoproto.goproto_registration) = true;
+// Enable generation of XXX_MessageName methods for grpc-go/status.
+option (gogoproto.messagename_all) = true;
+
+message Storage {
+    bytes Key = 1 [(gogoproto.customtype) = ""github.com/hyperledger/burrow/binary.Word256"", (gogoproto.nullable) = false];
+    bytes Value = 2 [(gogoproto.customtype) = ""github.com/hyperledger/burrow/binary.Word256"", (gogoproto.nullable) = false];
+}
+
+message AccountStorage {
+    bytes Address = 1 [(gogoproto.customtype) = ""github.com/hyperledger/burrow/crypto.Address"", (gogoproto.nullable) = false];
+    Storage Storage = 2;
+}
+
+message EVMEvent {
+    uint64 Height = 1;",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249427969,https://github.com/hyperledger/burrow/pull/977#discussion_r249427969,silasdavis
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,Does Height need to be its own singleton message? Usually this is because it needs to be an RPC request or response - perhaps this is no longer the case (i.e. GetDumpParam now defined),aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-21 12:14:38,249428354,"@@ -0,0 +1,51 @@
+syntax = 'proto3';
+
+option go_package = ""github.com/hyperledger/burrow/dump"";
+
+import ""github.com/gogo/protobuf/gogoproto/gogo.proto"";
+
+import ""acm.proto"";
+import ""exec.proto"";
+import ""names.proto"";
+
+package dump;
+
+// Enable custom Marshal method.
+option (gogoproto.marshaler_all) = true;
+// Enable custom Unmarshal method.
+option (gogoproto.unmarshaler_all) = true;
+// Enable custom Size method (Required by Marshal and Unmarshal).
+option (gogoproto.sizer_all) = true;
+// Enable registration with golang/protobuf for the grpc-gateway.
+option (gogoproto.goproto_registration) = true;
+// Enable generation of XXX_MessageName methods for grpc-go/status.
+option (gogoproto.messagename_all) = true;
+
+message Storage {
+    bytes Key = 1 [(gogoproto.customtype) = ""github.com/hyperledger/burrow/binary.Word256"", (gogoproto.nullable) = false];
+    bytes Value = 2 [(gogoproto.customtype) = ""github.com/hyperledger/burrow/binary.Word256"", (gogoproto.nullable) = false];
+}
+
+message AccountStorage {
+    bytes Address = 1 [(gogoproto.customtype) = ""github.com/hyperledger/burrow/crypto.Address"", (gogoproto.nullable) = false];
+    Storage Storage = 2;
+}
+
+message EVMEvent {
+    uint64 Height = 1;
+    exec.LogEvent Event = 2;
+}
+
+message Height {
+    uint64 Height = 1;",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249428354,https://github.com/hyperledger/burrow/pull/977#discussion_r249428354,silasdavis
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,Was this intended or a merge? I think I realised that we were not using/needing a RWLock - we just need a write Lock. I think should be just `sync.Mutex`,aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-21 12:21:08,249430144,"@@ -102,27 +107,35 @@ type State struct {
 	height       uint64
 	accountStats state.AccountStats
 	// Values not reassigned
-	sync.Mutex
+	sync.RWMutex",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249430144,https://github.com/hyperledger/burrow/pull/977#discussion_r249430144,silasdavis
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,I see why you have done it this way since you want a RWTree for StateTree. But this RWTree is a broken RWTree with no write part. I think this should just return IAVL.ImmutableTree. I think I'd prefer the name `GetImmutableTree`,aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-21 12:26:09,249431627,"@@ -46,6 +46,17 @@ func (rwt *RWTree) Load(version int64) error {
 	return nil
 }
 
+func (rwt *RWTree) GetImmutableVersion(version int64) (*RWTree, error) {
+	readTree, err := rwt.tree.GetImmutable(version)
+	if err != nil {
+		return nil, fmt.Errorf(""could not load previous version of RWTree to use as read version"")
+	}
+
+	return &RWTree{
+		readTree: readTree,",11,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249431627,https://github.com/hyperledger/burrow/pull/977#discussion_r249431627,silasdavis
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,"hmm, I think I remember us talking about this. It makes sense to extract the read functionality of `*State` so I see why you have done this.

The thing I find a bit funny about it is it wraps a `RWTree` _just_ for the `readTree` contained in it... This means that we need to provide a `RWTree` even though we don't really need one and it leads us to to define a lame RWTree via GetImmutableVersion.

I had a little fiddle to make `StateTree` mirror `writeState`  and reflect the fact it is really the iterable read state, see: https://github.com/seanyoung/burrow/compare/dump...silasdavis:dump-review

I had hoped this would allow us to do `NewReadState(iavl.ImmutableTree)` - annoyingly it doesn't due to some differences in iteration interfaces that RWTree abstracts over. I based `KVIterableReader` on the direction I assumed IAVL would take following this. 

However if you agree with the general idea of allowing us to construct `KVIterableReader` rather than `RWTree` then we can tidy up the other stuff.",aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-21 12:50:18,249438334,"@@ -102,27 +107,35 @@ type State struct {
 	height       uint64
 	accountStats state.AccountStats
 	// Values not reassigned
-	sync.Mutex
+	sync.RWMutex
+	StateTree
 	writeState *writeState
 	db         dbm.DB
 	cacheDB    *storage.CacheDB
-	tree       *storage.RWTree
 	refs       storage.KVStore
 	codec      *amino.Codec
 }
 
+type StateTree struct {",38,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249438334,https://github.com/hyperledger/burrow/pull/977#discussion_r249438334,silasdavis
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,"I recently started using system tmp for these a few reasons (see integration.go):

- Doesn't slow down IDEs with junk
- Avoids ending up with root owned stuff
- Doesn't slow down find / go tool in makefiles

I think keys still puts its scratch in repo so not fully migrated. Then I guess there is an OS issue. We might consider using tmp here - but if it makes it less portable maybe not. I guess windows support is not something we actively maintain in the makefile/tests... Mac I assume will be fine with mktemp?",aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-21 12:54:37,249439520,"@@ -0,0 +1,87 @@
+#! /bin/bash
+
+# Test the dump restore functionality
+# 
+# Steps taken:
+# - Create a chain
+# - Create some code and events
+# - Dump chain
+# - Stop chain and delete
+# - Restore chain from dump
+# - Check all bits are present (account, namereg, code, events)
+#
+
+set -e
+
+tmp_dir=""./dump/test_scratch""",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249439520,https://github.com/hyperledger/burrow/pull/977#discussion_r249439520,silasdavis
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,"I don't like having test fixtures in a top-level dir like this. I feel like we have too much fragmentation in where integration test stuff is.

If we say:
- Go integration tests in ./integration package
- All other integration tests (scripts etc) should go somewhere under ./tests (else what is it for)

At least that limits it. If you agree do you think you could refactor the similar keys integration test under `tests` too?",aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-21 12:58:48,249440745,"@@ -0,0 +1,87 @@
+#! /bin/bash",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249440745,https://github.com/hyperledger/burrow/pull/977#discussion_r249440745,silasdavis
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,"ugh this isn't on this PR but I'd really like to refactor the global permissions address to something other than ZeroAddress, and ideally have a consistent way of thinking about/checking 'registered addresses'.

Could we for the time being introduce a constant in permissions package (which should be initially set to ZeroAddress) for the global permissions address to be clear about what this check is meant to be saying.",aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-21 13:02:29,249441750,"@@ -172,6 +181,84 @@ func MakeGenesisState(db dbm.DB, genesisDoc *genesis.GenesisDoc) (*State, error)
 	return s, nil
 }
 
+func (s *State) LoadDump(filename string, genesisDoc *genesis.GenesisDoc) error {
+	f, err := os.OpenFile(filename, os.O_RDONLY, 0644)
+	if err != nil {
+		return err
+	}
+
+	tx := exec.TxExecution{
+		TxType: payload.TypeCall,
+		TxHash: make([]byte, 32),
+	}
+
+	for {
+		var row dump.Dump
+
+		_, err = cdc.UnmarshalBinaryLengthPrefixedReader(f, &row, 0)
+		if err != nil {
+			break
+		}
+
+		if row.Account != nil {
+			if row.Account.Address == crypto.ZeroAddress {",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249441750,https://github.com/hyperledger/burrow/pull/977#discussion_r249441750,silasdavis
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,"hmm... Can we say 'so not a known account' - we lazily harvest pub keys as we see them, we can't say it's not an account (even if we are clear on what exactly that means)",aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-21 13:04:31,249442309,"@@ -172,6 +181,84 @@ func MakeGenesisState(db dbm.DB, genesisDoc *genesis.GenesisDoc) (*State, error)
 	return s, nil
 }
 
+func (s *State) LoadDump(filename string, genesisDoc *genesis.GenesisDoc) error {
+	f, err := os.OpenFile(filename, os.O_RDONLY, 0644)
+	if err != nil {
+		return err
+	}
+
+	tx := exec.TxExecution{
+		TxType: payload.TypeCall,
+		TxHash: make([]byte, 32),
+	}
+
+	for {
+		var row dump.Dump
+
+		_, err = cdc.UnmarshalBinaryLengthPrefixedReader(f, &row, 0)
+		if err != nil {
+			break
+		}
+
+		if row.Account != nil {
+			if row.Account.Address == crypto.ZeroAddress {
+				if genesisDoc != nil {
+					genesisDoc.GlobalPermissions.Base = row.Account.Permissions.Base
+				}
+				continue
+			}
+
+			s.writeState.UpdateAccount(row.Account)
+
+			if genesisDoc != nil {
+				found := false
+
+				if len(row.Account.PublicKey.PublicKey) == 0 {
+					// no public key, so not an account",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249442309,https://github.com/hyperledger/burrow/pull/977#discussion_r249442309,silasdavis
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,"Hmmm... We are saying here that _every_ account is a genesis account?

The problem with this is that we break the idea that the genesis doc on disk matches the genesis doc in memory. Looking at how you have used this however I don't think it is broken (since you pass nil in kernel)...

So the question is do we want configure to create all accounts in a dump as 'genesis accounts'. This feels a bit wrong to me since providing AppHash should mean give me all of what's in the dump plus I want these explicit accounts. I can see both ways...",aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-21 13:04:56,249442420,"@@ -172,6 +181,84 @@ func MakeGenesisState(db dbm.DB, genesisDoc *genesis.GenesisDoc) (*State, error)
 	return s, nil
 }
 
+func (s *State) LoadDump(filename string, genesisDoc *genesis.GenesisDoc) error {
+	f, err := os.OpenFile(filename, os.O_RDONLY, 0644)
+	if err != nil {
+		return err
+	}
+
+	tx := exec.TxExecution{
+		TxType: payload.TypeCall,
+		TxHash: make([]byte, 32),
+	}
+
+	for {
+		var row dump.Dump
+
+		_, err = cdc.UnmarshalBinaryLengthPrefixedReader(f, &row, 0)
+		if err != nil {
+			break
+		}
+
+		if row.Account != nil {
+			if row.Account.Address == crypto.ZeroAddress {
+				if genesisDoc != nil {
+					genesisDoc.GlobalPermissions.Base = row.Account.Permissions.Base
+				}
+				continue
+			}
+
+			s.writeState.UpdateAccount(row.Account)
+
+			if genesisDoc != nil {
+				found := false
+
+				if len(row.Account.PublicKey.PublicKey) == 0 {
+					// no public key, so not an account
+					continue
+				}
+
+				for _, acc := range genesisDoc.Accounts {
+					if acc.Address == row.Account.Address {
+						found = true
+						break
+					}
+				}
+				if !found {
+					genesisDoc.Accounts = append(genesisDoc.Accounts, genesis.GenesisAccountFromAccount("""", row.Account))",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249442420,https://github.com/hyperledger/burrow/pull/977#discussion_r249442420,silasdavis
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,We are adding the GenesisDoc here... We write to out so I think that is fine - but is it what we want? See my other comment with LoadDump,aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-21 13:16:18,249445758,"@@ -203,6 +207,28 @@ func Configure(output Output) func(cmd *cli.Cmd) {
 				conf.GenesisDoc.ChainName = *chainNameOpt
 			}
 
+			if *restoreDumpOpt != """" {
+				if conf.GenesisDoc == nil {
+					output.Fatalf(""no GenesisDoc/GenesisSpec provided, cannot restore dump"")
+				}
+
+				if len(conf.GenesisDoc.Validators) == 0 {
+					output.Fatalf(""On restore, validators must be provided in GenesisDoc or GenesisSpec"")
+				}
+
+				state, err := execution.MakeGenesisState(db.NewMemDB(), conf.GenesisDoc)
+				if err != nil {
+					output.Fatalf(""could not generate state from genesis: %v"", err)
+				}
+
+				err = state.LoadDump(*restoreDumpOpt, conf.GenesisDoc)",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249445758,https://github.com/hyperledger/burrow/pull/977#discussion_r249445758,silasdavis
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,"Yes, it was. See slack conversation",aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-22 13:21:14,249775569,"@@ -123,7 +123,7 @@ build_race:	check build_race_db
 build_burrow: commit_hash
 	go build -ldflags ""-extldflags '-static' \
 	-X github.com/hyperledger/burrow/project.commit=$(shell cat commit_hash.txt) \
-	-X github.com/hyperledger/burrow/project.date=$(shell date -I)"" \
+	-X github.com/hyperledger/burrow/project.date=$(shell date '+%Y-%m-%d')"" \",5,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249775569,https://github.com/hyperledger/burrow/pull/977#discussion_r249775569,seanyoung
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,As discussed this is now in every dump message,aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-22 13:21:36,249775687,"@@ -0,0 +1,51 @@
+syntax = 'proto3';
+
+option go_package = ""github.com/hyperledger/burrow/dump"";
+
+import ""github.com/gogo/protobuf/gogoproto/gogo.proto"";
+
+import ""acm.proto"";
+import ""exec.proto"";
+import ""names.proto"";
+
+package dump;
+
+// Enable custom Marshal method.
+option (gogoproto.marshaler_all) = true;
+// Enable custom Unmarshal method.
+option (gogoproto.unmarshaler_all) = true;
+// Enable custom Size method (Required by Marshal and Unmarshal).
+option (gogoproto.sizer_all) = true;
+// Enable registration with golang/protobuf for the grpc-gateway.
+option (gogoproto.goproto_registration) = true;
+// Enable generation of XXX_MessageName methods for grpc-go/status.
+option (gogoproto.messagename_all) = true;
+
+message Storage {
+    bytes Key = 1 [(gogoproto.customtype) = ""github.com/hyperledger/burrow/binary.Word256"", (gogoproto.nullable) = false];
+    bytes Value = 2 [(gogoproto.customtype) = ""github.com/hyperledger/burrow/binary.Word256"", (gogoproto.nullable) = false];
+}
+
+message AccountStorage {
+    bytes Address = 1 [(gogoproto.customtype) = ""github.com/hyperledger/burrow/crypto.Address"", (gogoproto.nullable) = false];
+    Storage Storage = 2;
+}
+
+message EVMEvent {
+    uint64 Height = 1;",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249775687,https://github.com/hyperledger/burrow/pull/977#discussion_r249775687,seanyoung
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,As discussed this is now in every dump message,aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-22 13:21:40,249775710,"@@ -0,0 +1,51 @@
+syntax = 'proto3';
+
+option go_package = ""github.com/hyperledger/burrow/dump"";
+
+import ""github.com/gogo/protobuf/gogoproto/gogo.proto"";
+
+import ""acm.proto"";
+import ""exec.proto"";
+import ""names.proto"";
+
+package dump;
+
+// Enable custom Marshal method.
+option (gogoproto.marshaler_all) = true;
+// Enable custom Unmarshal method.
+option (gogoproto.unmarshaler_all) = true;
+// Enable custom Size method (Required by Marshal and Unmarshal).
+option (gogoproto.sizer_all) = true;
+// Enable registration with golang/protobuf for the grpc-gateway.
+option (gogoproto.goproto_registration) = true;
+// Enable generation of XXX_MessageName methods for grpc-go/status.
+option (gogoproto.messagename_all) = true;
+
+message Storage {
+    bytes Key = 1 [(gogoproto.customtype) = ""github.com/hyperledger/burrow/binary.Word256"", (gogoproto.nullable) = false];
+    bytes Value = 2 [(gogoproto.customtype) = ""github.com/hyperledger/burrow/binary.Word256"", (gogoproto.nullable) = false];
+}
+
+message AccountStorage {
+    bytes Address = 1 [(gogoproto.customtype) = ""github.com/hyperledger/burrow/crypto.Address"", (gogoproto.nullable) = false];
+    Storage Storage = 2;
+}
+
+message EVMEvent {
+    uint64 Height = 1;
+    exec.LogEvent Event = 2;
+}
+
+message Height {
+    uint64 Height = 1;",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249775710,https://github.com/hyperledger/burrow/pull/977#discussion_r249775710,seanyoung
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,Thanks for spotting that. Fixed.,aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-22 13:21:56,249775815,"@@ -102,27 +107,35 @@ type State struct {
 	height       uint64
 	accountStats state.AccountStats
 	// Values not reassigned
-	sync.Mutex
+	sync.RWMutex",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249775815,https://github.com/hyperledger/burrow/pull/977#discussion_r249775815,seanyoung
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,As you've pulled in my branch do you want to me to change this?,aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-22 13:22:29,249775990,"@@ -46,6 +46,17 @@ func (rwt *RWTree) Load(version int64) error {
 	return nil
 }
 
+func (rwt *RWTree) GetImmutableVersion(version int64) (*RWTree, error) {
+	readTree, err := rwt.tree.GetImmutable(version)
+	if err != nil {
+		return nil, fmt.Errorf(""could not load previous version of RWTree to use as read version"")
+	}
+
+	return &RWTree{
+		readTree: readTree,",11,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249775990,https://github.com/hyperledger/burrow/pull/977#discussion_r249775990,seanyoung
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,"Absolutely correct, I've fixed this",aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-22 13:22:45,249776073,"@@ -0,0 +1,87 @@
+#! /bin/bash
+
+# Test the dump restore functionality
+# 
+# Steps taken:
+# - Create a chain
+# - Create some code and events
+# - Dump chain
+# - Stop chain and delete
+# - Restore chain from dump
+# - Check all bits are present (account, namereg, code, events)
+#
+
+set -e
+
+tmp_dir=""./dump/test_scratch""",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249776073,https://github.com/hyperledger/burrow/pull/977#discussion_r249776073,seanyoung
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,"As I understand it, you've started on this.",aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-22 13:23:22,249776272,"@@ -102,27 +107,35 @@ type State struct {
 	height       uint64
 	accountStats state.AccountStats
 	// Values not reassigned
-	sync.Mutex
+	sync.RWMutex
+	StateTree
 	writeState *writeState
 	db         dbm.DB
 	cacheDB    *storage.CacheDB
-	tree       *storage.RWTree
 	refs       storage.KVStore
 	codec      *amino.Codec
 }
 
+type StateTree struct {",38,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249776272,https://github.com/hyperledger/burrow/pull/977#discussion_r249776272,seanyoung
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,I've moved this test and the keys test too,aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-22 13:23:40,249776371,"@@ -0,0 +1,87 @@
+#! /bin/bash",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249776371,https://github.com/hyperledger/burrow/pull/977#discussion_r249776371,seanyoung
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,Removed,aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-22 13:24:15,249776547,"@@ -172,6 +181,84 @@ func MakeGenesisState(db dbm.DB, genesisDoc *genesis.GenesisDoc) (*State, error)
 	return s, nil
 }
 
+func (s *State) LoadDump(filename string, genesisDoc *genesis.GenesisDoc) error {
+	f, err := os.OpenFile(filename, os.O_RDONLY, 0644)
+	if err != nil {
+		return err
+	}
+
+	tx := exec.TxExecution{
+		TxType: payload.TypeCall,
+		TxHash: make([]byte, 32),
+	}
+
+	for {
+		var row dump.Dump
+
+		_, err = cdc.UnmarshalBinaryLengthPrefixedReader(f, &row, 0)
+		if err != nil {
+			break
+		}
+
+		if row.Account != nil {
+			if row.Account.Address == crypto.ZeroAddress {
+				if genesisDoc != nil {
+					genesisDoc.GlobalPermissions.Base = row.Account.Permissions.Base
+				}
+				continue
+			}
+
+			s.writeState.UpdateAccount(row.Account)
+
+			if genesisDoc != nil {
+				found := false
+
+				if len(row.Account.PublicKey.PublicKey) == 0 {
+					// no public key, so not an account
+					continue
+				}
+
+				for _, acc := range genesisDoc.Accounts {
+					if acc.Address == row.Account.Address {
+						found = true
+						break
+					}
+				}
+				if !found {
+					genesisDoc.Accounts = append(genesisDoc.Accounts, genesis.GenesisAccountFromAccount("""", row.Account))",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249776547,https://github.com/hyperledger/burrow/pull/977#discussion_r249776547,seanyoung
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,Removed,aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-22 13:24:23,249776595,"@@ -203,6 +207,28 @@ func Configure(output Output) func(cmd *cli.Cmd) {
 				conf.GenesisDoc.ChainName = *chainNameOpt
 			}
 
+			if *restoreDumpOpt != """" {
+				if conf.GenesisDoc == nil {
+					output.Fatalf(""no GenesisDoc/GenesisSpec provided, cannot restore dump"")
+				}
+
+				if len(conf.GenesisDoc.Validators) == 0 {
+					output.Fatalf(""On restore, validators must be provided in GenesisDoc or GenesisSpec"")
+				}
+
+				state, err := execution.MakeGenesisState(db.NewMemDB(), conf.GenesisDoc)
+				if err != nil {
+					output.Fatalf(""could not generate state from genesis: %v"", err)
+				}
+
+				err = state.LoadDump(*restoreDumpOpt, conf.GenesisDoc)",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249776595,https://github.com/hyperledger/burrow/pull/977#discussion_r249776595,seanyoung
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,Removed,aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-22 13:24:35,249776676,"@@ -172,6 +181,84 @@ func MakeGenesisState(db dbm.DB, genesisDoc *genesis.GenesisDoc) (*State, error)
 	return s, nil
 }
 
+func (s *State) LoadDump(filename string, genesisDoc *genesis.GenesisDoc) error {
+	f, err := os.OpenFile(filename, os.O_RDONLY, 0644)
+	if err != nil {
+		return err
+	}
+
+	tx := exec.TxExecution{
+		TxType: payload.TypeCall,
+		TxHash: make([]byte, 32),
+	}
+
+	for {
+		var row dump.Dump
+
+		_, err = cdc.UnmarshalBinaryLengthPrefixedReader(f, &row, 0)
+		if err != nil {
+			break
+		}
+
+		if row.Account != nil {
+			if row.Account.Address == crypto.ZeroAddress {
+				if genesisDoc != nil {
+					genesisDoc.GlobalPermissions.Base = row.Account.Permissions.Base
+				}
+				continue
+			}
+
+			s.writeState.UpdateAccount(row.Account)
+
+			if genesisDoc != nil {
+				found := false
+
+				if len(row.Account.PublicKey.PublicKey) == 0 {
+					// no public key, so not an account",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249776676,https://github.com/hyperledger/burrow/pull/977#discussion_r249776676,seanyoung
https://github.com/hyperledger/burrow/pull/977,https://github.com/hyperledger/burrow/pull/977,Using acm.GlobalPermissionsAddress instead,aa3e97e75e099816479e99995dd54bdd92da47da,2019-01-22 13:51:02,249785896,"@@ -172,6 +181,84 @@ func MakeGenesisState(db dbm.DB, genesisDoc *genesis.GenesisDoc) (*State, error)
 	return s, nil
 }
 
+func (s *State) LoadDump(filename string, genesisDoc *genesis.GenesisDoc) error {
+	f, err := os.OpenFile(filename, os.O_RDONLY, 0644)
+	if err != nil {
+		return err
+	}
+
+	tx := exec.TxExecution{
+		TxType: payload.TypeCall,
+		TxHash: make([]byte, 32),
+	}
+
+	for {
+		var row dump.Dump
+
+		_, err = cdc.UnmarshalBinaryLengthPrefixedReader(f, &row, 0)
+		if err != nil {
+			break
+		}
+
+		if row.Account != nil {
+			if row.Account.Address == crypto.ZeroAddress {",,2019-01-22 14:03:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/249785896,https://github.com/hyperledger/burrow/pull/977#discussion_r249785896,seanyoung
https://github.com/hyperledger/burrow/pull/975,https://github.com/hyperledger/burrow/pull/975,We sure we want to pile this on IterableReader?,0245245e320834d069a84d469d9342f4cec95ba6,2018-12-07 14:29:15,239825271,"@@ -62,6 +71,7 @@ type Iterable interface {
 type IterableReader interface {
 	Iterable
 	Reader
+	AccountStatsGetter",23,2018-12-07 15:50:55,https://api.github.com/repos/hyperledger/burrow/pulls/comments/239825271,https://github.com/hyperledger/burrow/pull/975#discussion_r239825271,silasdavis
https://github.com/hyperledger/burrow/pull/975,https://github.com/hyperledger/burrow/pull/975,"Can't add a comment on the line but we need to add the appropriate metrics into `func AddMetrics()` with something like:

```go
burrowMetrics[""Contracts""] = prometheus.NewDesc(
	prometheus.BuildFQName(""burrow"", ""accounts"", ""contracts""),
	""Current contracts on the chain"",
	[]string{""chain_id"", ""moniker""}, nil,
)
burrowMetrics[""Users""] = prometheus.NewDesc(
	prometheus.BuildFQName(""burrow"", ""accounts"", ""users""),
	""Current users on the chain"",
	[]string{""chain_id"", ""moniker""}, nil,
)
```

and also something in `func (e *Exporter) Collect(ch chan<- prometheus.Metric)` that looks like this:

```go
ch <- prometheus.MustNewConstMetric(
	e.burrowMetrics[""Contracts""],
	prometheus.GaugeValue,
	e.datum.AccountsWithCode,
	e.chainID,
	e.validatorMoniker,
)
ch <- prometheus.MustNewConstMetric(
	e.burrowMetrics[""Users""],
	prometheus.GaugeValue,
	e.datum.AccountsWithoutCode,
	e.chainID,
	e.validatorMoniker,
)
```",0245245e320834d069a84d469d9342f4cec95ba6,2018-12-07 14:59:54,239835724,"@@ -49,6 +49,8 @@ type Datum struct {
 	TxPerBlockBuckets   map[float64]float64
 	TotalTime           float64
 	TimePerBlockBuckets map[float64]float64
+	AccountsWithCode    uint64
+	AccountsWithoutCode uint64",,2018-12-07 15:50:55,https://api.github.com/repos/hyperledger/burrow/pulls/comments/239835724,https://github.com/hyperledger/burrow/pull/975#discussion_r239835724,compleatang
https://github.com/hyperledger/burrow/pull/967,https://github.com/hyperledger/burrow/pull/967,Hm I'm not sure how I feel about patching it in like this. In the short term its nice and simple but it creates an ad hoc coupling between state and blockchain that doesn't pass through the standard constructor or other interfaces. I feel like it degrades our separate a bit. Let me reflect.,797acf201a5cf284489864bb399529498d94c91d,2018-11-16 14:37:31,234225885,"@@ -112,6 +112,7 @@ func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tmTy
 	} else {
 		kern.State, err = execution.MakeGenesisState(stateDB, genesisDoc)
 	}
+	kern.Blockchain.BlockHashProvider = kern.State.GetBlockHash",4,2019-01-31 10:07:31,https://api.github.com/repos/hyperledger/burrow/pulls/comments/234225885,https://github.com/hyperledger/burrow/pull/967#discussion_r234225885,silasdavis
https://github.com/hyperledger/burrow/pull/967,https://github.com/hyperledger/burrow/pull/967,Oh dear so this never worked!,797acf201a5cf284489864bb399529498d94c91d,2018-12-18 09:17:56,242457163,"@@ -348,7 +348,7 @@ func (s *State) GetTx(txHash []byte) (*exec.TxExecution, error) {
 }
 
 func (s *State) GetBlock(height uint64) (*exec.BlockExecution, error) {
-	bs := s.tree.Get(blockRefKeyFormat.Key(height))
+	bs := s.refs.Get(blockRefKeyFormat.Key(height))",,2019-01-31 10:07:31,https://api.github.com/repos/hyperledger/burrow/pulls/comments/242457163,https://github.com/hyperledger/burrow/pull/967#discussion_r242457163,silasdavis
https://github.com/hyperledger/burrow/pull/958,https://github.com/hyperledger/burrow/pull/958,"hmm, does this work? I think we might need:

```shell
    docker tag ${DOCKER_REPO}:${tag#v} ${DOCKER_REPO}:latest
```

",ea4e08cdda4f71acd4602ac4ad9de88ed834d7cc,2018-11-10 17:43:40,232460258,"@@ -9,7 +9,7 @@ function release {
     echo ""Building and releasing $tag...""
     echo ""Pushing docker image...""
     echo ${DOCKER_PASS} | docker login --username ${DOCKER_USER} --password-stdin
-    docker tag ${DOCKER_REPO}:latest
+    docker tag ${DOCKER_REPO} ${DOCKER_REPO}:latest",5,2018-11-10 17:45:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/232460258,https://github.com/hyperledger/burrow/pull/958#discussion_r232460258,silasdavis
https://github.com/hyperledger/burrow/pull/958,https://github.com/hyperledger/burrow/pull/958,"I think you're right actually, closing #958 in favor of #959",ea4e08cdda4f71acd4602ac4ad9de88ed834d7cc,2018-11-10 19:06:07,232462538,"@@ -9,7 +9,7 @@ function release {
     echo ""Building and releasing $tag...""
     echo ""Pushing docker image...""
     echo ${DOCKER_PASS} | docker login --username ${DOCKER_USER} --password-stdin
-    docker tag ${DOCKER_REPO}:latest
+    docker tag ${DOCKER_REPO} ${DOCKER_REPO}:latest",5,2018-11-10 19:06:07,https://api.github.com/repos/hyperledger/burrow/pulls/comments/232462538,https://github.com/hyperledger/burrow/pull/958#discussion_r232462538,gregdhill
https://github.com/hyperledger/burrow/pull/952,https://github.com/hyperledger/burrow/pull/952,`jobs chan *intermediateJob` is unused,e3f511ef29eeef612813d0f8f4bfa689fa98bca6,2018-11-08 19:45:58,232036737,"@@ -0,0 +1,65 @@
+package jobs
+
+import (
+	""fmt""
+
+	""github.com/hyperledger/burrow/deploy/def""
+	""github.com/hyperledger/burrow/deploy/util""
+	""github.com/hyperledger/burrow/txs/payload""
+)
+
+func ProposalJob(prop *def.Proposal, do *def.DeployArgs, client *def.Client, jobs chan *intermediateJob) (string, error) {",,2018-11-09 15:07:15,https://api.github.com/repos/hyperledger/burrow/pulls/comments/232036737,https://github.com/hyperledger/burrow/pull/952#discussion_r232036737,silasdavis
https://github.com/hyperledger/burrow/pull/952,https://github.com/hyperledger/burrow/pull/952,"Hmm... in the case of ProposalTx I don't think we are at risk of BatchTx being mempooled signed anyway since we will only attempt to mempool sign the outer tx (i.e. the ProposalTx): https://github.com/hyperledger/burrow/blob/develop/execution/transactor.go#L168.

Mempool signing for the ProposalTx is fine, for the BatchTx I think we should be using a fixed sequence - but I'm not sure we should be reading this from the chain at all even at formulation time - I _think_ it should probably be explicit.",e3f511ef29eeef612813d0f8f4bfa689fa98bca6,2018-11-08 19:58:04,232040659,"@@ -514,7 +514,7 @@ func (c *Client) TxInput(inputString, amountString, sequenceString string) (*pay
 		amount, err = c.ParseUint64(amountString)
 	}
 	var sequence uint64
-	sequence, err = c.GetSequence(sequenceString, inputAddress)
+	sequence, err = c.getSequence(sequenceString, inputAddress, c.MempoolSigning && allowMempoolSigning)",59,2018-11-09 15:07:15,https://api.github.com/repos/hyperledger/burrow/pulls/comments/232040659,https://github.com/hyperledger/burrow/pull/952#discussion_r232040659,silasdavis
https://github.com/hyperledger/burrow/pull/952,https://github.com/hyperledger/burrow/pull/952,"I think we discussed this, but this is not what what I was thinking. What I thought was:

ProposalTx input == the person proposing - mempool signing whatever
BatchTx inputs == proxy for the sequence number(s) 'of the proposal' - _not_ the same as the above
Txs (of BatchTx) inputs == whatever (but for our usage probably the same as the BatchTx input that is acting as our system account)

So when I think of the sequence number of the BatchTx input I have in mind 'the sequence number of the proposal'. Now maybe it would be clearer for us to just have a sequence number as part of the Proposal but seeing as the Batch ought to have inputs I feel like this makes some kind of sense.

Basically I think that there should be two sequence number inputs to this:

1. An optional sequence number for the ProposalTx (for the proposer) - same as in other jobs, if omitted we can try mempool signing, or we can look it up I forget the exact fallthrough

2. A compulsory sequence number/account for the proposal - that ends up as the input to the batch Tx. I don't think we should provide the option to look this up I think it should be explicit in the yaml because it should mean 'I want to apply this proposal within the context of this particular linear sequence of proposals and if sequence numbers have moved on I want it to fail not look up the sequence number either locally or in mempool.

This will allows us to use a simple single global systems account but it could also allow you to have multiple proposal tracks whereby you do not require freshness of all 'proposal tracking accounts' to submit this.",e3f511ef29eeef612813d0f8f4bfa689fa98bca6,2018-11-08 20:11:51,232044731,"@@ -0,0 +1,65 @@
+package jobs
+
+import (
+	""fmt""
+
+	""github.com/hyperledger/burrow/deploy/def""
+	""github.com/hyperledger/burrow/deploy/util""
+	""github.com/hyperledger/burrow/txs/payload""
+)
+
+func ProposalJob(prop *def.Proposal, do *def.DeployArgs, client *def.Client, jobs chan *intermediateJob) (string, error) {
+	var ProposeBatch payload.BatchTx
+
+	for _, job := range prop.Jobs {
+		load, err := job.Payload()
+		if err != nil {
+			return """", fmt.Errorf(""could not get Job payload: %v"", load)
+		}
+
+		err = util.PreProcessFields(load, do, client)
+		if err != nil {
+			return """", err
+		}
+		// Revalidate with possible replacements
+		err = load.Validate()
+		if err != nil {
+			return """", fmt.Errorf(""error validating job %s after pre-processing variables: %v"", job.Name, err)
+		}
+
+		item := payload.Any{}
+
+		switch load.(type) {
+		case *def.Call:
+			announceProposalJob(job.Name, ""Call"")
+			CallTx, ferr := FormulateCallJob(job.Call, do, client)
+			if ferr != nil {
+				return """", ferr
+			}
+			item.CallTx = CallTx
+			break
+		default:
+			return """", fmt.Errorf(""jobs %s illegal job type for proposal"", job.Name)
+		}
+
+		ProposeBatch.Txs = append(ProposeBatch.Txs, &item)
+	}
+
+	proposal := payload.Proposal{Name: prop.Name, Description: prop.Description, BatchTx: &ProposeBatch}
+
+	input, err := client.TxInput(prop.Source, """", prop.Sequence, false)
+	if err != nil {
+		return """", err
+	}
+	proposal.BatchTx.Inputs = []*payload.TxInput{input}
+
+	txe, err := client.SignAndBroadcast(&payload.ProposalTx{VotingWeight: 1, Input: input, Proposal: &proposal})",64,2018-11-09 15:07:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/232044731,https://github.com/hyperledger/burrow/pull/952#discussion_r232044731,silasdavis
https://github.com/hyperledger/burrow/pull/952,https://github.com/hyperledger/burrow/pull/952,This threshold needs to come from a network parameter,e3f511ef29eeef612813d0f8f4bfa689fa98bca6,2018-11-08 20:15:19,232045722,"@@ -0,0 +1,216 @@
+package contexts
+
+import (
+	""crypto/sha256""
+	""fmt""
+	""unicode""
+
+	""github.com/hyperledger/burrow/acm/state""
+	""github.com/hyperledger/burrow/acm/validator""
+	""github.com/hyperledger/burrow/bcm""
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/execution/errors""
+	""github.com/hyperledger/burrow/execution/evm/sha3""
+	""github.com/hyperledger/burrow/execution/exec""
+	""github.com/hyperledger/burrow/execution/proposal""
+	""github.com/hyperledger/burrow/logging""
+	""github.com/hyperledger/burrow/logging/structure""
+	""github.com/hyperledger/burrow/txs""
+	""github.com/hyperledger/burrow/txs/payload""
+)
+
+type ProposalContext struct {
+	Tip          bcm.BlockchainInfo
+	StateWriter  state.ReaderWriter
+	ValidatorSet validator.Writer
+	ProposalReg  proposal.ReaderWriter
+	Logger       *logging.Logger
+	tx           *payload.ProposalTx
+	Contexts     map[payload.Type]Context
+}
+
+func (ctx *ProposalContext) Execute(txe *exec.TxExecution, p payload.Payload) error {
+	var ok bool
+	ctx.tx, ok = p.(*payload.ProposalTx)
+	if !ok {
+		return fmt.Errorf(""payload must be ProposalTx, but is: %v"", txe.Envelope.Tx.Payload)
+	}
+	// Validate input
+	inAcc, err := ctx.StateWriter.GetAccount(ctx.tx.Input.Address)
+	if err != nil {
+		return err
+	}
+	if inAcc == nil {
+		ctx.Logger.InfoMsg(""Cannot find input account"",
+			""tx_input"", ctx.tx.Input)
+		return errors.ErrorCodeInvalidAddress
+	}
+
+	// check permission
+	if !hasProposalPermission(ctx.StateWriter, inAcc, ctx.Logger) {
+		return fmt.Errorf(""account %s does not have Proposal permission"", ctx.tx.Input.Address)
+	}
+
+	var ballot *payload.Ballot
+	var proposalHash []byte
+
+	if ctx.tx.Proposal == nil {
+		// voting for existing proposal
+		if ctx.tx.ProposalHash == nil || ctx.tx.ProposalHash.Size() != sha256.Size {
+			return errors.ErrorCodeInvalidProposal
+		}
+		ballot, err = ctx.ProposalReg.GetProposal(ctx.tx.ProposalHash.Bytes())
+		if err != nil {
+			return err
+		}
+	} else {
+		if ctx.tx.ProposalHash != nil || ctx.tx.Proposal.BatchTx == nil ||
+			len(ctx.tx.Proposal.BatchTx.Txs) == 0 || len(ctx.tx.Proposal.BatchTx.GetInputs()) == 0 {
+			return errors.ErrorCodeInvalidProposal
+		}
+
+		// validate the input strings
+		if err := validateProposalStrings(ctx.tx.Proposal); err != nil {
+			return err
+		}
+
+		bs, err := ctx.tx.Proposal.Encode()
+		if err != nil {
+			return err
+		}
+
+		proposalHash = sha3.Sha3(bs)
+
+		ballot, err = ctx.ProposalReg.GetProposal(proposalHash)
+		if ballot == nil && err == nil {
+			ballot = &payload.Ballot{
+				Proposal:      ctx.tx.Proposal,
+				ProposalState: payload.Ballot_PROPOSED,
+			}
+		}
+		if err != nil {
+			return err
+		}
+	}
+
+	// count votes for proposal
+	votes := make(map[crypto.Address]int64)
+
+	if ballot.Votes == nil {
+		ballot.Votes = make([]*payload.Vote, 0)
+	}
+
+	for _, v := range ballot.Votes {
+		acc, err := ctx.StateWriter.GetAccount(v.Address)
+		if err != nil {
+			return err
+		}
+		// Belt and braces, should have already been checked
+		if !hasProposalPermission(ctx.StateWriter, acc, ctx.Logger) {
+			return fmt.Errorf(""account %s does not have Proposal permission"", ctx.tx.Input.Address)
+		}
+		votes[v.Address] = v.VotingWeight
+	}
+
+	for _, i := range ballot.Proposal.BatchTx.GetInputs() {
+		// Validate input
+		proposeAcc, err := ctx.StateWriter.GetAccount(i.Address)
+		if err != nil {
+			return err
+		}
+
+		if proposeAcc == nil {
+			ctx.Logger.InfoMsg(""Cannot find input account"",
+				""tx_input"", ctx.tx.Input)
+			return errors.ErrorCodeInvalidAddress
+		}
+
+		if !hasBatchPermission(ctx.StateWriter, proposeAcc, ctx.Logger) {
+			return fmt.Errorf(""account %s does not have batch permission"", i.Address)
+		}
+
+		if proposeAcc.GetSequence()+1 != i.Sequence {
+			return errors.ErrorCodeExpiredProposal
+		}
+
+		// Do we have a record of our own vote
+		if _, ok := votes[i.Address]; !ok {
+			votes[i.Address] = ctx.tx.VotingWeight
+			ballot.Votes = append(ballot.Votes, &payload.Vote{Address: i.Address, VotingWeight: ctx.tx.VotingWeight})
+		}
+	}
+
+	// Count the number of validators; ensure we have at least half the number of validators
+	// This also means that when running with a single validator, a proposal will run straight away
+	power := 0
+	for _, v := range votes {
+		if v > 0 {
+			power++
+		}
+	}
+
+	for _, step := range ballot.Proposal.BatchTx.Txs {
+		txE := txs.EnvelopeFromAny("""", step)
+
+		for _, i := range txE.Tx.GetInputs() {
+			_, err := ctx.StateWriter.GetAccount(i.Address)
+			if err != nil {
+				return err
+			}
+
+			// Do not check sequence numbers of inputs
+		}
+	}
+
+	if power*2 > ctx.Tip.NumValidators() {",,2018-11-09 15:07:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/232045722,https://github.com/hyperledger/burrow/pull/952#discussion_r232045722,silasdavis
https://github.com/hyperledger/burrow/pull/952,https://github.com/hyperledger/burrow/pull/952,Feel like we should probably share code between this and name cache. A cursory look suggests it should be possible then we can just have a thing wrapper that type asserts to the appropriate cached type `Entry` vs `Ballot`,e3f511ef29eeef612813d0f8f4bfa689fa98bca6,2018-11-08 20:55:43,232057295,"@@ -0,0 +1,199 @@
+// Copyright 2017 Monax Industries Limited
+//
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package proposal
+
+import (
+	""bytes""
+	""fmt""
+	""sort""
+	""sync""
+
+	""github.com/hyperledger/burrow/txs/payload""
+	""github.com/tendermint/tendermint/crypto/tmhash""
+)
+
+// The Cache helps prevent unnecessary IAVLTree updates and garbage generation.
+type Cache struct {",28,2018-11-09 15:07:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/232057295,https://github.com/hyperledger/burrow/pull/952#discussion_r232057295,silasdavis
https://github.com/hyperledger/burrow/pull/952,https://github.com/hyperledger/burrow/pull/952,can make this `value interface{}`,e3f511ef29eeef612813d0f8f4bfa689fa98bca6,2018-11-08 20:56:01,232057395,"@@ -0,0 +1,199 @@
+// Copyright 2017 Monax Industries Limited
+//
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package proposal
+
+import (
+	""bytes""
+	""fmt""
+	""sort""
+	""sync""
+
+	""github.com/hyperledger/burrow/txs/payload""
+	""github.com/tendermint/tendermint/crypto/tmhash""
+)
+
+// The Cache helps prevent unnecessary IAVLTree updates and garbage generation.
+type Cache struct {
+	sync.RWMutex
+	backend   Reader
+	proposals map[[tmhash.Size]byte]*proposalInfo
+}
+
+type proposalInfo struct {
+	sync.RWMutex
+	ballot  *payload.Ballot",36,2018-11-09 15:07:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/232057395,https://github.com/hyperledger/burrow/pull/952#discussion_r232057395,silasdavis
https://github.com/hyperledger/burrow/pull/952,https://github.com/hyperledger/burrow/pull/952,"You seem to be suggesting that the sequence number has to be specified in the deploy.yaml which is unworkable.
How would an end user running burrow deploy get the sequence number and put it n the deploy.yaml?",e3f511ef29eeef612813d0f8f4bfa689fa98bca6,2018-11-09 10:23:10,232205489,"@@ -514,7 +514,7 @@ func (c *Client) TxInput(inputString, amountString, sequenceString string) (*pay
 		amount, err = c.ParseUint64(amountString)
 	}
 	var sequence uint64
-	sequence, err = c.GetSequence(sequenceString, inputAddress)
+	sequence, err = c.getSequence(sequenceString, inputAddress, c.MempoolSigning && allowMempoolSigning)",59,2018-11-09 15:07:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/232205489,https://github.com/hyperledger/burrow/pull/952#discussion_r232205489,seanyoung
https://github.com/hyperledger/burrow/pull/952,https://github.com/hyperledger/burrow/pull/952,Fixed.,e3f511ef29eeef612813d0f8f4bfa689fa98bca6,2018-11-09 10:23:17,232205521,"@@ -0,0 +1,65 @@
+package jobs
+
+import (
+	""fmt""
+
+	""github.com/hyperledger/burrow/deploy/def""
+	""github.com/hyperledger/burrow/deploy/util""
+	""github.com/hyperledger/burrow/txs/payload""
+)
+
+func ProposalJob(prop *def.Proposal, do *def.DeployArgs, client *def.Client, jobs chan *intermediateJob) (string, error) {",,2018-11-09 15:07:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/232205521,https://github.com/hyperledger/burrow/pull/952#discussion_r232205521,seanyoung
https://github.com/hyperledger/burrow/pull/952,https://github.com/hyperledger/burrow/pull/952,"It certainly does, the code for that is not ready yet. Adding this later will not change the data file compatbility, as it will default to the same value.",e3f511ef29eeef612813d0f8f4bfa689fa98bca6,2018-11-09 10:24:21,232205787,"@@ -0,0 +1,216 @@
+package contexts
+
+import (
+	""crypto/sha256""
+	""fmt""
+	""unicode""
+
+	""github.com/hyperledger/burrow/acm/state""
+	""github.com/hyperledger/burrow/acm/validator""
+	""github.com/hyperledger/burrow/bcm""
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/execution/errors""
+	""github.com/hyperledger/burrow/execution/evm/sha3""
+	""github.com/hyperledger/burrow/execution/exec""
+	""github.com/hyperledger/burrow/execution/proposal""
+	""github.com/hyperledger/burrow/logging""
+	""github.com/hyperledger/burrow/logging/structure""
+	""github.com/hyperledger/burrow/txs""
+	""github.com/hyperledger/burrow/txs/payload""
+)
+
+type ProposalContext struct {
+	Tip          bcm.BlockchainInfo
+	StateWriter  state.ReaderWriter
+	ValidatorSet validator.Writer
+	ProposalReg  proposal.ReaderWriter
+	Logger       *logging.Logger
+	tx           *payload.ProposalTx
+	Contexts     map[payload.Type]Context
+}
+
+func (ctx *ProposalContext) Execute(txe *exec.TxExecution, p payload.Payload) error {
+	var ok bool
+	ctx.tx, ok = p.(*payload.ProposalTx)
+	if !ok {
+		return fmt.Errorf(""payload must be ProposalTx, but is: %v"", txe.Envelope.Tx.Payload)
+	}
+	// Validate input
+	inAcc, err := ctx.StateWriter.GetAccount(ctx.tx.Input.Address)
+	if err != nil {
+		return err
+	}
+	if inAcc == nil {
+		ctx.Logger.InfoMsg(""Cannot find input account"",
+			""tx_input"", ctx.tx.Input)
+		return errors.ErrorCodeInvalidAddress
+	}
+
+	// check permission
+	if !hasProposalPermission(ctx.StateWriter, inAcc, ctx.Logger) {
+		return fmt.Errorf(""account %s does not have Proposal permission"", ctx.tx.Input.Address)
+	}
+
+	var ballot *payload.Ballot
+	var proposalHash []byte
+
+	if ctx.tx.Proposal == nil {
+		// voting for existing proposal
+		if ctx.tx.ProposalHash == nil || ctx.tx.ProposalHash.Size() != sha256.Size {
+			return errors.ErrorCodeInvalidProposal
+		}
+		ballot, err = ctx.ProposalReg.GetProposal(ctx.tx.ProposalHash.Bytes())
+		if err != nil {
+			return err
+		}
+	} else {
+		if ctx.tx.ProposalHash != nil || ctx.tx.Proposal.BatchTx == nil ||
+			len(ctx.tx.Proposal.BatchTx.Txs) == 0 || len(ctx.tx.Proposal.BatchTx.GetInputs()) == 0 {
+			return errors.ErrorCodeInvalidProposal
+		}
+
+		// validate the input strings
+		if err := validateProposalStrings(ctx.tx.Proposal); err != nil {
+			return err
+		}
+
+		bs, err := ctx.tx.Proposal.Encode()
+		if err != nil {
+			return err
+		}
+
+		proposalHash = sha3.Sha3(bs)
+
+		ballot, err = ctx.ProposalReg.GetProposal(proposalHash)
+		if ballot == nil && err == nil {
+			ballot = &payload.Ballot{
+				Proposal:      ctx.tx.Proposal,
+				ProposalState: payload.Ballot_PROPOSED,
+			}
+		}
+		if err != nil {
+			return err
+		}
+	}
+
+	// count votes for proposal
+	votes := make(map[crypto.Address]int64)
+
+	if ballot.Votes == nil {
+		ballot.Votes = make([]*payload.Vote, 0)
+	}
+
+	for _, v := range ballot.Votes {
+		acc, err := ctx.StateWriter.GetAccount(v.Address)
+		if err != nil {
+			return err
+		}
+		// Belt and braces, should have already been checked
+		if !hasProposalPermission(ctx.StateWriter, acc, ctx.Logger) {
+			return fmt.Errorf(""account %s does not have Proposal permission"", ctx.tx.Input.Address)
+		}
+		votes[v.Address] = v.VotingWeight
+	}
+
+	for _, i := range ballot.Proposal.BatchTx.GetInputs() {
+		// Validate input
+		proposeAcc, err := ctx.StateWriter.GetAccount(i.Address)
+		if err != nil {
+			return err
+		}
+
+		if proposeAcc == nil {
+			ctx.Logger.InfoMsg(""Cannot find input account"",
+				""tx_input"", ctx.tx.Input)
+			return errors.ErrorCodeInvalidAddress
+		}
+
+		if !hasBatchPermission(ctx.StateWriter, proposeAcc, ctx.Logger) {
+			return fmt.Errorf(""account %s does not have batch permission"", i.Address)
+		}
+
+		if proposeAcc.GetSequence()+1 != i.Sequence {
+			return errors.ErrorCodeExpiredProposal
+		}
+
+		// Do we have a record of our own vote
+		if _, ok := votes[i.Address]; !ok {
+			votes[i.Address] = ctx.tx.VotingWeight
+			ballot.Votes = append(ballot.Votes, &payload.Vote{Address: i.Address, VotingWeight: ctx.tx.VotingWeight})
+		}
+	}
+
+	// Count the number of validators; ensure we have at least half the number of validators
+	// This also means that when running with a single validator, a proposal will run straight away
+	power := 0
+	for _, v := range votes {
+		if v > 0 {
+			power++
+		}
+	}
+
+	for _, step := range ballot.Proposal.BatchTx.Txs {
+		txE := txs.EnvelopeFromAny("""", step)
+
+		for _, i := range txE.Tx.GetInputs() {
+			_, err := ctx.StateWriter.GetAccount(i.Address)
+			if err != nil {
+				return err
+			}
+
+			// Do not check sequence numbers of inputs
+		}
+	}
+
+	if power*2 > ctx.Tip.NumValidators() {",,2018-11-09 15:07:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/232205787,https://github.com/hyperledger/burrow/pull/952#discussion_r232205787,seanyoung
https://github.com/hyperledger/burrow/pull/952,https://github.com/hyperledger/burrow/pull/952,"Sorry this is indeed broken, should be different inputs for BatchTx and ProposalTx",e3f511ef29eeef612813d0f8f4bfa689fa98bca6,2018-11-09 10:27:05,232206575,"@@ -0,0 +1,65 @@
+package jobs
+
+import (
+	""fmt""
+
+	""github.com/hyperledger/burrow/deploy/def""
+	""github.com/hyperledger/burrow/deploy/util""
+	""github.com/hyperledger/burrow/txs/payload""
+)
+
+func ProposalJob(prop *def.Proposal, do *def.DeployArgs, client *def.Client, jobs chan *intermediateJob) (string, error) {
+	var ProposeBatch payload.BatchTx
+
+	for _, job := range prop.Jobs {
+		load, err := job.Payload()
+		if err != nil {
+			return """", fmt.Errorf(""could not get Job payload: %v"", load)
+		}
+
+		err = util.PreProcessFields(load, do, client)
+		if err != nil {
+			return """", err
+		}
+		// Revalidate with possible replacements
+		err = load.Validate()
+		if err != nil {
+			return """", fmt.Errorf(""error validating job %s after pre-processing variables: %v"", job.Name, err)
+		}
+
+		item := payload.Any{}
+
+		switch load.(type) {
+		case *def.Call:
+			announceProposalJob(job.Name, ""Call"")
+			CallTx, ferr := FormulateCallJob(job.Call, do, client)
+			if ferr != nil {
+				return """", ferr
+			}
+			item.CallTx = CallTx
+			break
+		default:
+			return """", fmt.Errorf(""jobs %s illegal job type for proposal"", job.Name)
+		}
+
+		ProposeBatch.Txs = append(ProposeBatch.Txs, &item)
+	}
+
+	proposal := payload.Proposal{Name: prop.Name, Description: prop.Description, BatchTx: &ProposeBatch}
+
+	input, err := client.TxInput(prop.Source, """", prop.Sequence, false)
+	if err != nil {
+		return """", err
+	}
+	proposal.BatchTx.Inputs = []*payload.TxInput{input}
+
+	txe, err := client.SignAndBroadcast(&payload.ProposalTx{VotingWeight: 1, Input: input, Proposal: &proposal})",64,2018-11-09 15:07:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/232206575,https://github.com/hyperledger/burrow/pull/952#discussion_r232206575,seanyoung
https://github.com/hyperledger/burrow/pull/952,https://github.com/hyperledger/burrow/pull/952,"Does seem like a good idea. However, ProposalCache maps from []byte to Ballot. Name cache maps from string to names.Entry.
In order for this to work the key would have to be the same type.
We could convert proposalHash to string; however this seems a lot busy work for deduplicating a 100 lines of code.",e3f511ef29eeef612813d0f8f4bfa689fa98bca6,2018-11-09 11:14:37,232219929,"@@ -0,0 +1,199 @@
+// Copyright 2017 Monax Industries Limited
+//
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package proposal
+
+import (
+	""bytes""
+	""fmt""
+	""sort""
+	""sync""
+
+	""github.com/hyperledger/burrow/txs/payload""
+	""github.com/tendermint/tendermint/crypto/tmhash""
+)
+
+// The Cache helps prevent unnecessary IAVLTree updates and garbage generation.
+type Cache struct {",28,2018-11-09 15:07:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/232219929,https://github.com/hyperledger/burrow/pull/952#discussion_r232219929,seanyoung
https://github.com/hyperledger/burrow/pull/952,https://github.com/hyperledger/burrow/pull/952,"Indeed that is the way that would be implemented, see above.",e3f511ef29eeef612813d0f8f4bfa689fa98bca6,2018-11-09 11:15:03,232220048,"@@ -0,0 +1,199 @@
+// Copyright 2017 Monax Industries Limited
+//
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package proposal
+
+import (
+	""bytes""
+	""fmt""
+	""sort""
+	""sync""
+
+	""github.com/hyperledger/burrow/txs/payload""
+	""github.com/tendermint/tendermint/crypto/tmhash""
+)
+
+// The Cache helps prevent unnecessary IAVLTree updates and garbage generation.
+type Cache struct {
+	sync.RWMutex
+	backend   Reader
+	proposals map[[tmhash.Size]byte]*proposalInfo
+}
+
+type proposalInfo struct {
+	sync.RWMutex
+	ballot  *payload.Ballot",36,2018-11-09 15:07:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/232220048,https://github.com/hyperledger/burrow/pull/952#discussion_r232220048,seanyoung
https://github.com/hyperledger/burrow/pull/952,https://github.com/hyperledger/burrow/pull/952,"Could be a future proposal... Not sure if this deserves a separate error or if it's something we should allow. I can't see a good reason for allowing. The only think might be if you wanted to run a series of proposal transactions or something, but seems like you would be better to batch into a single one.

Actually you might specifically want to get your proposal in after a particular on. I think we should maybe allow future proposals. Is this workable? We would obviously want to not apply them until the block. Hm I guess the issue is if we ratify a proposal ahead of time there is not finalising tx to push it over the line.

Okay I think it can probably be considered dangerous to try and stack proposals - you can only know before the proposal you would come after when it is ratified which by definition you wouldn't if this had a future sequence number because at least the one before it would not yet be ratified.

Thanks for listening.",e3f511ef29eeef612813d0f8f4bfa689fa98bca6,2018-11-09 13:07:04,232246322,"@@ -0,0 +1,216 @@
+package contexts
+
+import (
+	""crypto/sha256""
+	""fmt""
+	""unicode""
+
+	""github.com/hyperledger/burrow/acm/state""
+	""github.com/hyperledger/burrow/acm/validator""
+	""github.com/hyperledger/burrow/bcm""
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/execution/errors""
+	""github.com/hyperledger/burrow/execution/evm/sha3""
+	""github.com/hyperledger/burrow/execution/exec""
+	""github.com/hyperledger/burrow/execution/proposal""
+	""github.com/hyperledger/burrow/logging""
+	""github.com/hyperledger/burrow/logging/structure""
+	""github.com/hyperledger/burrow/txs""
+	""github.com/hyperledger/burrow/txs/payload""
+)
+
+type ProposalContext struct {
+	Tip          bcm.BlockchainInfo
+	StateWriter  state.ReaderWriter
+	ValidatorSet validator.Writer
+	ProposalReg  proposal.ReaderWriter
+	Logger       *logging.Logger
+	tx           *payload.ProposalTx
+	Contexts     map[payload.Type]Context
+}
+
+func (ctx *ProposalContext) Execute(txe *exec.TxExecution, p payload.Payload) error {
+	var ok bool
+	ctx.tx, ok = p.(*payload.ProposalTx)
+	if !ok {
+		return fmt.Errorf(""payload must be ProposalTx, but is: %v"", txe.Envelope.Tx.Payload)
+	}
+	// Validate input
+	inAcc, err := ctx.StateWriter.GetAccount(ctx.tx.Input.Address)
+	if err != nil {
+		return err
+	}
+	if inAcc == nil {
+		ctx.Logger.InfoMsg(""Cannot find input account"",
+			""tx_input"", ctx.tx.Input)
+		return errors.ErrorCodeInvalidAddress
+	}
+
+	// check permission
+	if !hasProposalPermission(ctx.StateWriter, inAcc, ctx.Logger) {
+		return fmt.Errorf(""account %s does not have Proposal permission"", ctx.tx.Input.Address)
+	}
+
+	var ballot *payload.Ballot
+	var proposalHash []byte
+
+	if ctx.tx.Proposal == nil {
+		// voting for existing proposal
+		if ctx.tx.ProposalHash == nil || ctx.tx.ProposalHash.Size() != sha256.Size {
+			return errors.ErrorCodeInvalidProposal
+		}
+		ballot, err = ctx.ProposalReg.GetProposal(ctx.tx.ProposalHash.Bytes())
+		if err != nil {
+			return err
+		}
+	} else {
+		if ctx.tx.ProposalHash != nil || ctx.tx.Proposal.BatchTx == nil ||
+			len(ctx.tx.Proposal.BatchTx.Txs) == 0 || len(ctx.tx.Proposal.BatchTx.GetInputs()) == 0 {
+			return errors.ErrorCodeInvalidProposal
+		}
+
+		// validate the input strings
+		if err := validateProposalStrings(ctx.tx.Proposal); err != nil {
+			return err
+		}
+
+		bs, err := ctx.tx.Proposal.Encode()
+		if err != nil {
+			return err
+		}
+
+		proposalHash = sha3.Sha3(bs)
+
+		ballot, err = ctx.ProposalReg.GetProposal(proposalHash)
+		if ballot == nil && err == nil {
+			ballot = &payload.Ballot{
+				Proposal:      ctx.tx.Proposal,
+				ProposalState: payload.Ballot_PROPOSED,
+			}
+		}
+		if err != nil {
+			return err
+		}
+	}
+
+	// count votes for proposal
+	votes := make(map[crypto.Address]int64)
+
+	if ballot.Votes == nil {
+		ballot.Votes = make([]*payload.Vote, 0)
+	}
+
+	for _, v := range ballot.Votes {
+		acc, err := ctx.StateWriter.GetAccount(v.Address)
+		if err != nil {
+			return err
+		}
+		// Belt and braces, should have already been checked
+		if !hasProposalPermission(ctx.StateWriter, acc, ctx.Logger) {
+			return fmt.Errorf(""account %s does not have Proposal permission"", ctx.tx.Input.Address)
+		}
+		votes[v.Address] = v.VotingWeight
+	}
+
+	for _, i := range ballot.Proposal.BatchTx.GetInputs() {
+		// Validate input
+		proposeAcc, err := ctx.StateWriter.GetAccount(i.Address)
+		if err != nil {
+			return err
+		}
+
+		if proposeAcc == nil {
+			ctx.Logger.InfoMsg(""Cannot find input account"",
+				""tx_input"", ctx.tx.Input)
+			return errors.ErrorCodeInvalidAddress
+		}
+
+		if !hasBatchPermission(ctx.StateWriter, proposeAcc, ctx.Logger) {
+			return fmt.Errorf(""account %s does not have batch permission"", i.Address)
+		}
+
+		if proposeAcc.GetSequence() != i.Sequence {
+			return errors.ErrorCodeExpiredProposal",133,2018-11-09 15:07:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/232246322,https://github.com/hyperledger/burrow/pull/952#discussion_r232246322,silasdavis
https://github.com/hyperledger/burrow/pull/952,https://github.com/hyperledger/burrow/pull/952,I think at the very least we will need a genesis-defined value which we ought to add now since it will change all the hashes. Suggest we allow an empty genesis value and then we should fallback to N = 3 if no value in genesis.,e3f511ef29eeef612813d0f8f4bfa689fa98bca6,2018-11-09 13:07:45,232246581,"@@ -0,0 +1,216 @@
+package contexts
+
+import (
+	""crypto/sha256""
+	""fmt""
+	""unicode""
+
+	""github.com/hyperledger/burrow/acm/state""
+	""github.com/hyperledger/burrow/acm/validator""
+	""github.com/hyperledger/burrow/bcm""
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/execution/errors""
+	""github.com/hyperledger/burrow/execution/evm/sha3""
+	""github.com/hyperledger/burrow/execution/exec""
+	""github.com/hyperledger/burrow/execution/proposal""
+	""github.com/hyperledger/burrow/logging""
+	""github.com/hyperledger/burrow/logging/structure""
+	""github.com/hyperledger/burrow/txs""
+	""github.com/hyperledger/burrow/txs/payload""
+)
+
+type ProposalContext struct {
+	Tip          bcm.BlockchainInfo
+	StateWriter  state.ReaderWriter
+	ValidatorSet validator.Writer
+	ProposalReg  proposal.ReaderWriter
+	Logger       *logging.Logger
+	tx           *payload.ProposalTx
+	Contexts     map[payload.Type]Context
+}
+
+func (ctx *ProposalContext) Execute(txe *exec.TxExecution, p payload.Payload) error {
+	var ok bool
+	ctx.tx, ok = p.(*payload.ProposalTx)
+	if !ok {
+		return fmt.Errorf(""payload must be ProposalTx, but is: %v"", txe.Envelope.Tx.Payload)
+	}
+	// Validate input
+	inAcc, err := ctx.StateWriter.GetAccount(ctx.tx.Input.Address)
+	if err != nil {
+		return err
+	}
+	if inAcc == nil {
+		ctx.Logger.InfoMsg(""Cannot find input account"",
+			""tx_input"", ctx.tx.Input)
+		return errors.ErrorCodeInvalidAddress
+	}
+
+	// check permission
+	if !hasProposalPermission(ctx.StateWriter, inAcc, ctx.Logger) {
+		return fmt.Errorf(""account %s does not have Proposal permission"", ctx.tx.Input.Address)
+	}
+
+	var ballot *payload.Ballot
+	var proposalHash []byte
+
+	if ctx.tx.Proposal == nil {
+		// voting for existing proposal
+		if ctx.tx.ProposalHash == nil || ctx.tx.ProposalHash.Size() != sha256.Size {
+			return errors.ErrorCodeInvalidProposal
+		}
+		ballot, err = ctx.ProposalReg.GetProposal(ctx.tx.ProposalHash.Bytes())
+		if err != nil {
+			return err
+		}
+	} else {
+		if ctx.tx.ProposalHash != nil || ctx.tx.Proposal.BatchTx == nil ||
+			len(ctx.tx.Proposal.BatchTx.Txs) == 0 || len(ctx.tx.Proposal.BatchTx.GetInputs()) == 0 {
+			return errors.ErrorCodeInvalidProposal
+		}
+
+		// validate the input strings
+		if err := validateProposalStrings(ctx.tx.Proposal); err != nil {
+			return err
+		}
+
+		bs, err := ctx.tx.Proposal.Encode()
+		if err != nil {
+			return err
+		}
+
+		proposalHash = sha3.Sha3(bs)
+
+		ballot, err = ctx.ProposalReg.GetProposal(proposalHash)
+		if ballot == nil && err == nil {
+			ballot = &payload.Ballot{
+				Proposal:      ctx.tx.Proposal,
+				ProposalState: payload.Ballot_PROPOSED,
+			}
+		}
+		if err != nil {
+			return err
+		}
+	}
+
+	// count votes for proposal
+	votes := make(map[crypto.Address]int64)
+
+	if ballot.Votes == nil {
+		ballot.Votes = make([]*payload.Vote, 0)
+	}
+
+	for _, v := range ballot.Votes {
+		acc, err := ctx.StateWriter.GetAccount(v.Address)
+		if err != nil {
+			return err
+		}
+		// Belt and braces, should have already been checked
+		if !hasProposalPermission(ctx.StateWriter, acc, ctx.Logger) {
+			return fmt.Errorf(""account %s does not have Proposal permission"", ctx.tx.Input.Address)
+		}
+		votes[v.Address] = v.VotingWeight
+	}
+
+	for _, i := range ballot.Proposal.BatchTx.GetInputs() {
+		// Validate input
+		proposeAcc, err := ctx.StateWriter.GetAccount(i.Address)
+		if err != nil {
+			return err
+		}
+
+		if proposeAcc == nil {
+			ctx.Logger.InfoMsg(""Cannot find input account"",
+				""tx_input"", ctx.tx.Input)
+			return errors.ErrorCodeInvalidAddress
+		}
+
+		if !hasBatchPermission(ctx.StateWriter, proposeAcc, ctx.Logger) {
+			return fmt.Errorf(""account %s does not have batch permission"", i.Address)
+		}
+
+		if proposeAcc.GetSequence()+1 != i.Sequence {
+			return errors.ErrorCodeExpiredProposal
+		}
+
+		// Do we have a record of our own vote
+		if _, ok := votes[i.Address]; !ok {
+			votes[i.Address] = ctx.tx.VotingWeight
+			ballot.Votes = append(ballot.Votes, &payload.Vote{Address: i.Address, VotingWeight: ctx.tx.VotingWeight})
+		}
+	}
+
+	// Count the number of validators; ensure we have at least half the number of validators
+	// This also means that when running with a single validator, a proposal will run straight away
+	power := 0
+	for _, v := range votes {
+		if v > 0 {
+			power++
+		}
+	}
+
+	for _, step := range ballot.Proposal.BatchTx.Txs {
+		txE := txs.EnvelopeFromAny("""", step)
+
+		for _, i := range txE.Tx.GetInputs() {
+			_, err := ctx.StateWriter.GetAccount(i.Address)
+			if err != nil {
+				return err
+			}
+
+			// Do not check sequence numbers of inputs
+		}
+	}
+
+	if power*2 > ctx.Tip.NumValidators() {",,2018-11-09 15:07:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/232246581,https://github.com/hyperledger/burrow/pull/952#discussion_r232246581,silasdavis
https://github.com/hyperledger/burrow/pull/952,https://github.com/hyperledger/burrow/pull/952,yeah we can revisit this,e3f511ef29eeef612813d0f8f4bfa689fa98bca6,2018-11-09 13:10:18,232247217,"@@ -0,0 +1,199 @@
+// Copyright 2017 Monax Industries Limited
+//
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package proposal
+
+import (
+	""bytes""
+	""fmt""
+	""sort""
+	""sync""
+
+	""github.com/hyperledger/burrow/txs/payload""
+	""github.com/tendermint/tendermint/crypto/tmhash""
+)
+
+// The Cache helps prevent unnecessary IAVLTree updates and garbage generation.
+type Cache struct {",28,2018-11-09 15:07:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/232247217,https://github.com/hyperledger/burrow/pull/952#discussion_r232247217,silasdavis
https://github.com/hyperledger/burrow/pull/944,https://github.com/hyperledger/burrow/pull/944,I know the comment says what's what - but use constants instead of magic numbers. We have `AddressLength` and `Word256Length`,0db74da2e25b8a89b552965570979e4952324505,2018-12-04 16:45:27,238745034,"@@ -186,3 +187,14 @@ func NewContractAddress(caller Address, nonce []byte) (newAddr Address) {
 	copy(newAddr[:], hasher.Sum(nil))
 	return
 }
+
+func NewContractAddress2(caller Address, nonce []byte, salt [32]byte, initcode []byte) (newAddr Address) {
+	// sha3(0xff ++ caller.Address() ++ salt ++ sha3(init_code))[12:]
+	temp := make([]byte, 1+20+32+32)",,2018-12-04 17:36:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/238745034,https://github.com/hyperledger/burrow/pull/944#discussion_r238745034,silasdavis
https://github.com/hyperledger/burrow/pull/944,https://github.com/hyperledger/burrow/pull/944,Nonce is unused - remove,0db74da2e25b8a89b552965570979e4952324505,2018-12-04 16:50:10,238747048,"@@ -186,3 +187,14 @@ func NewContractAddress(caller Address, nonce []byte) (newAddr Address) {
 	copy(newAddr[:], hasher.Sum(nil))
 	return
 }
+
+func NewContractAddress2(caller Address, nonce []byte, salt [32]byte, initcode []byte) (newAddr Address) {",,2018-12-04 17:36:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/238747048,https://github.com/hyperledger/burrow/pull/944#discussion_r238747048,silasdavis
https://github.com/hyperledger/burrow/pull/944,https://github.com/hyperledger/burrow/pull/944,I was worried that this might not check that this address does not exist but it does via new state interface.,0db74da2e25b8a89b552965570979e4952324505,2018-12-04 17:05:52,238753575,"@@ -733,21 +733,31 @@ func (vm *VM) execute(callState Interface, eventSink EventSink, caller, callee c
 			}))
 			vm.Debugf("" => T:%X D:%X\n"", topics, data)
 
-		case CREATE: // 0xF0
+		case CREATE, CREATE2: // 0xF0, 0xFB
 			returnData = nil
+			var salt Word256
 
 			contractValue := stack.PopU64()
 			offset, size := stack.PopBigInt(), stack.PopBigInt()
 			input := memory.Read(offset, size)
 
+			if op == CREATE2 {
+				salt = stack.Pop()
+			}
+
 			// TODO charge for gas to create account _ the code length * GasCreateByte
 			useGasNegative(gas, GasCreateAccount, callState)
 
 			vm.sequence++
 			nonce := make([]byte, txs.HashLength+uint64Length)
 			copy(nonce, vm.tx.Hash())
 			PutUint64BE(nonce[txs.HashLength:], vm.sequence)
-			newAccount := crypto.NewContractAddress(callee, nonce)
+			var newAccount crypto.Address
+			if op == CREATE {
+				newAccount = crypto.NewContractAddress(callee, nonce)
+			} else if op == CREATE2 {
+				newAccount = crypto.NewContractAddress2(callee, nonce, salt, callState.GetCode(callee))",,2018-12-04 17:36:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/238753575,https://github.com/hyperledger/burrow/pull/944#discussion_r238753575,silasdavis
https://github.com/hyperledger/burrow/pull/944,https://github.com/hyperledger/burrow/pull/944,"Move all the noncense above into the `op == CREATE` branch (hmm including or excluding `vm.sequence++` - can see argument both ways, but it's not necessary to increment given we are aren't using so I thin we probably move it within the `CREATE` branch).

We don't need to do it since we will not be using the nonce.",0db74da2e25b8a89b552965570979e4952324505,2018-12-04 17:11:14,238755538,"@@ -733,21 +733,31 @@ func (vm *VM) execute(callState Interface, eventSink EventSink, caller, callee c
 			}))
 			vm.Debugf("" => T:%X D:%X\n"", topics, data)
 
-		case CREATE: // 0xF0
+		case CREATE, CREATE2: // 0xF0, 0xFB
 			returnData = nil
+			var salt Word256
 
 			contractValue := stack.PopU64()
 			offset, size := stack.PopBigInt(), stack.PopBigInt()
 			input := memory.Read(offset, size)
 
+			if op == CREATE2 {
+				salt = stack.Pop()
+			}
+
 			// TODO charge for gas to create account _ the code length * GasCreateByte
 			useGasNegative(gas, GasCreateAccount, callState)
 
 			vm.sequence++
 			nonce := make([]byte, txs.HashLength+uint64Length)
 			copy(nonce, vm.tx.Hash())
 			PutUint64BE(nonce[txs.HashLength:], vm.sequence)
-			newAccount := crypto.NewContractAddress(callee, nonce)
+			var newAccount crypto.Address
+			if op == CREATE {",32,2018-12-04 17:36:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/238755538,https://github.com/hyperledger/burrow/pull/944#discussion_r238755538,silasdavis
https://github.com/hyperledger/burrow/pull/944,https://github.com/hyperledger/burrow/pull/944,If I'm being a stickler I'd rather do the arithmetic in terms of constants too - all compile time anyway and a bit clearer/less error prone,0db74da2e25b8a89b552965570979e4952324505,2018-12-04 17:14:18,238756691,"@@ -186,3 +187,14 @@ func NewContractAddress(caller Address, nonce []byte) (newAddr Address) {
 	copy(newAddr[:], hasher.Sum(nil))
 	return
 }
+
+func NewContractAddress2(caller Address, nonce []byte, salt [32]byte, initcode []byte) (newAddr Address) {
+	// sha3(0xff ++ caller.Address() ++ salt ++ sha3(init_code))[12:]
+	temp := make([]byte, 1+20+32+32)
+	temp[0] = 0xFF
+	copy(temp[1:], caller[:])
+	copy(temp[22:], salt[:])
+	copy(temp[53:], sha3.Sha3(initcode))
+	copy(newAddr[:], sha3.Sha3(temp)[12:])",20,2018-12-04 17:36:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/238756691,https://github.com/hyperledger/burrow/pull/944#discussion_r238756691,silasdavis
https://github.com/hyperledger/burrow/pull/944,https://github.com/hyperledger/burrow/pull/944,just `temp := []byte{0xFF}`,0db74da2e25b8a89b552965570979e4952324505,2018-12-04 17:35:09,238764577,"@@ -186,3 +187,14 @@ func NewContractAddress(caller Address, nonce []byte) (newAddr Address) {
 	copy(newAddr[:], hasher.Sum(nil))
 	return
 }
+
+func NewContractAddress2(caller Address, salt [32]byte, initcode []byte) (newAddr Address) {
+	// sha3(0xff ++ caller.Address() ++ salt ++ sha3(init_code))[12:]
+	var temp []byte
+	temp = append(temp, []byte{0xFF}...)",16,2018-12-04 17:36:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/238764577,https://github.com/hyperledger/burrow/pull/944#discussion_r238764577,silasdavis
https://github.com/hyperledger/burrow/pull/938,https://github.com/hyperledger/burrow/pull/938,"Can we add something like ""Is your contract an abstract interface? You may not have unintentionally not implemented all abstracted inherited methods.""",b0636f5d549386c2f75445f82ebfdf6f7911ad61,2018-10-17 15:11:49,225973355,"@@ -125,6 +125,9 @@ func DeployJob(deploy *def.Deploy, do *def.DeployArgs, client *def.Client, resp
 		if binaryResponse.Error != """" {
 			return """", fmt.Errorf(""Something went wrong when you were trying to link your binaries: %v"", binaryResponse.Error)
 		}
+		if binaryResponse.Binary == """" {
+			return """", fmt.Errorf(""Contract binary code missing"")",,2018-10-17 15:32:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/225973355,https://github.com/hyperledger/burrow/pull/938#discussion_r225973355,silasdavis
https://github.com/hyperledger/burrow/pull/938,https://github.com/hyperledger/burrow/pull/938,maybe share error,b0636f5d549386c2f75445f82ebfdf6f7911ad61,2018-10-17 15:12:01,225973452,"@@ -187,10 +193,14 @@ func DeployJob(deploy *def.Deploy, do *def.DeployArgs, client *def.Client, resp
 				if err != nil {
 					return """", err
 				}
+				deployedCount++
 				if strings.ToLower(response.Objectname) == strings.ToLower(strings.TrimSuffix(filepath.Base(deploy.Contract), filepath.Ext(filepath.Base(deploy.Contract)))) {
 					baseObj = result
 				}
 			}
+			if deployedCount == 0 {
+				return """", fmt.Errorf(""Contract binary code missing"")",,2018-10-17 15:32:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/225973452,https://github.com/hyperledger/burrow/pull/938#discussion_r225973452,silasdavis
https://github.com/hyperledger/burrow/pull/938,https://github.com/hyperledger/burrow/pull/938,"Good point, done",b0636f5d549386c2f75445f82ebfdf6f7911ad61,2018-10-17 15:28:45,225981323,"@@ -125,6 +125,9 @@ func DeployJob(deploy *def.Deploy, do *def.DeployArgs, client *def.Client, resp
 		if binaryResponse.Error != """" {
 			return """", fmt.Errorf(""Something went wrong when you were trying to link your binaries: %v"", binaryResponse.Error)
 		}
+		if binaryResponse.Binary == """" {
+			return """", fmt.Errorf(""Contract binary code missing"")",,2018-10-17 15:32:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/225981323,https://github.com/hyperledger/burrow/pull/938#discussion_r225981323,seanyoung
https://github.com/hyperledger/burrow/pull/938,https://github.com/hyperledger/burrow/pull/938,also true. done,b0636f5d549386c2f75445f82ebfdf6f7911ad61,2018-10-17 15:29:24,225981628,"@@ -187,10 +193,14 @@ func DeployJob(deploy *def.Deploy, do *def.DeployArgs, client *def.Client, resp
 				if err != nil {
 					return """", err
 				}
+				deployedCount++
 				if strings.ToLower(response.Objectname) == strings.ToLower(strings.TrimSuffix(filepath.Base(deploy.Contract), filepath.Ext(filepath.Base(deploy.Contract)))) {
 					baseObj = result
 				}
 			}
+			if deployedCount == 0 {
+				return """", fmt.Errorf(""Contract binary code missing"")",,2018-10-17 15:32:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/225981628,https://github.com/hyperledger/burrow/pull/938#discussion_r225981628,seanyoung
https://github.com/hyperledger/burrow/pull/934,https://github.com/hyperledger/burrow/pull/934,🌸 ,3fb8228836cc706d15b12b0a4605cfe694086fab,2018-10-09 20:59:27,223861675,"@@ -12,6 +12,21 @@ connect to seed nodes once you have received enough addresses, so typically you
 only need them on the first start. The seed node will immediately disconnect
 from you after sending you some addresses.
 
+### Seed mode
+SeedMode can be enabled on a node.
+
+If a node is in seed mode it will accept inbound connections, share its address book, then hang up.
+Seeds modes will do a bit of gossip but not that usefully.
+Any type of node can be referenced as a 'Seeds' in the config, whether or not another node considers this node as a seed is independent of whether this node is in 'seed mode'.
+These are different concepts:
+> You are free to use a non-seed-mode node as a seed.
+
+You do not want to have too many seeds in your network (because they just keep hanging up on other nodes once they've spread their wild oats), but they are useful for accelerating peer exchange (of addresses).",13,2018-10-09 21:00:31,https://api.github.com/repos/hyperledger/burrow/pulls/comments/223861675,https://github.com/hyperledger/burrow/pull/934#discussion_r223861675,compleatang
https://github.com/hyperledger/burrow/pull/931,https://github.com/hyperledger/burrow/pull/931,"```md
Burrow getting started documentation is available in the [docs](docs/README.md) directory and in [GoDocs](https://godoc.org/github.com/hyperledger/burrow).
```",a067e9b8da22fa4d0ce2846dad92455f4274df9c,2018-10-08 10:28:19,223315575,"@@ -20,349 +25,29 @@ Hyperledger Burrow is a permissioned blockchain node that executes smart contrac
 - **Application Binary Interface (ABI):** Transactions need to be formulated in a binary format that can be processed by the blockchain node. Current tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.
 - **API Gateway:** Burrow exposes REST and JSON-RPC endpoints to interact with the blockchain network and the application state through broadcasting transactions, or querying the current state of the application. Websockets allow subscribing to events, which is particularly valuable as the consensus engine and smart contract application can give unambiguously finalised results to transactions within one blocktime of about one second.
 
-## Project documentation and Roadmap
+## Project Roadmap
 
 Project information generally updated on a quarterly basis can be found on the [Hyperledger Burrow Wiki](https://wiki.hyperledger.org/projects/burrow).
 
-## Installation
-
-- [Install go](https://golang.org/doc/install) version 1.10 or above and have `$GOPATH` set
-
-```
-go get github.com/hyperledger/burrow
-cd github.com/hyperledger/burrow
-make build
-```
-
-This will build the `burrow` and `burrow-client` binaries and put them in the `bin/` directory. They can be executed from there or put wherever is convenient.
-
-You can also install `burrow` into `$GOPATH/bin` with `make install_burrow`,
-
-## Usage
-
-The end result will be a `burrow.toml` that will be read in from your current working directory when starting `burrow`.
-
-### Configuration
-
-#### Configure Burrow
-The quick-and-dirty one-liner looks like:
-
-```shell
-# Read spec on stdin
-burrow spec -p1 -f1 | burrow configure -s- > burrow.toml
-```
-
-which translates into:
-
-```shell
-# This is a place we can store config files and burrow's working directory '.burrow'
-mkdir chain_dir && cd chain_dir
-burrow spec --participant-accounts=1 --full-accounts=1 > genesis-spec.json
-burrow configure --genesis-spec=genesis-spec.json > burrow.toml
-```
-#### Run Burrow
-Once the `burrow.toml` has been created, we run:
-
-```
-# To select our validator address by index in the GenesisDoc
-burrow start --validator-index=0
-# Or to select based on address directly (substituting the example address below with your validator's):
-burrow start --validator-address=BE584820DC904A55449D7EB0C97607B40224B96E
-```
-
-and the logs will start streaming through.
-
-If you would like to reset your node, you can just delete its working directory with `rm -rf .burrow`. In the context of a
-multi-node chain it will resync with peers, otherwise it will restart from height 0.
-
-### Logging
-
-Logging is highly configurable through the `burrow.toml` `[logging]` section. Each log line is a list of key-value pairs that flows from the root sink through possible child sinks. Each sink can have an output, a transform, and sinks that it outputs to. Below is a more involved example than the one appearing in the default generated config of what you can configure:
-
-```toml
-# This is a top level config section within the main Burrow config
-[logging]
-  # All log lines are sent to the root sink from all sources
-  [logging.root_sink]
-    # We define two child sinks that each receive all log lines
-    [[logging.root_sink.sinks]]
-      # We send all output to stderr
-      [logging.root_sink.sinks.output]
-        output_type = ""stderr""
-
-    [[logging.root_sink.sinks]]
-      # But for the second sink we define a transform that filters log lines from Tendermint's p2p module
-      [logging.root_sink.sinks.transform]
-        transform_type = ""filter""
-        filter_mode = ""exclude_when_all_match""
-
-        [[logging.root_sink.sinks.transform.predicates]]
-          key_regex = ""module""
-          value_regex = ""p2p""
-
-        [[logging.root_sink.sinks.transform.predicates]]
-          key_regex = ""captured_logging_source""
-          value_regex = ""tendermint_log15""
-
-      # The child sinks of this filter transform sink are syslog and file and will omit log lines originating from p2p
-      [[logging.root_sink.sinks.sinks]]
-        [logging.root_sink.sinks.sinks.output]
-          output_type = ""syslog""
-          url = """"
-          tag = ""Burrow-network""
-
-      [[logging.root_sink.sinks.sinks]]
-        [logging.root_sink.sinks.sinks.output]
-          output_type = ""file""
-          path = ""/var/log/burrow-network.log""
-```
-## Deploy Contracts
-
-Now that the burrow node is running, we can deploy contracts.
-
-For this step, we need two things: one or more solidity contracts, and an `deploy.yaml`.
-
-Let's take a simple example, found in [this directory](tests/jobs_fixtures/app06-deploy_basic_contract_and_different_solc_types_packed_unpacked/).
-
-The `deploy.yaml` should look like:
-
-```
-jobs:
-
-- name: deployStorageK
-  deploy:
-    contract: storage.sol
-
-- name: setStorageBaseBool
-  set:
-    val: ""true""
-
-- name: setStorageBool
-  call:
-    destination: $deployStorageK
-    function: setBool
-    data: [$setStorageBaseBool]
-
-- name: queryStorageBool
-  query-contract:
-    destination: $deployStorageK
-    function: getBool
-
-- name: assertStorageBool
-  assert:
-    key: $queryStorageBool
-    relation: eq
-    val: $setStorageBaseBool
-
-# tests string bools: #71
-- name: setStorageBool2
-  call:
-    destination: $deployStorageK
-    function: setBool2
-    data: [true]
-
-- name: queryStorageBool2
-  query-contract:
-    destination: $deployStorageK
-    function: getBool2
-
-- name: assertStorageBool2
-  assert:
-    key: $queryStorageBool2
-    relation: eq
-    val: ""true""
-
-- name: setStorageBaseInt
-  set:
-    val: 50000
+## Minimum requirements
 
-- name: setStorageInt
-  call:
-    destination: $deployStorageK
-    function: setInt
-    data: [$setStorageBaseInt]
+Requirement|Notes
+---|---
+Go version | Go1.10 or higher
 
-- name: queryStorageInt
-  query-contract:
-    destination: $deployStorageK
-    function: getInt
-
-- name: assertStorageInt
-  assert:
-    key: $queryStorageInt
-    relation: eq
-    val: $setStorageBaseInt
-
-- name: setStorageBaseUint
-  set:
-    val: 9999999
-
-- name: setStorageUint
-  call:
-    destination: $deployStorageK
-    function: setUint
-    data: [$setStorageBaseUint]
-
-- name: queryStorageUint
-  query-contract:
-    destination: $deployStorageK
-    function: getUint
-
-- name: assertStorageUint
-  assert:
-    key: $queryStorageUint
-    relation: eq
-    val: $setStorageBaseUint
-
-- name: setStorageBaseAddress
-  set:
-    val: ""1040E6521541DAB4E7EE57F21226DD17CE9F0FB7""
-
-- name: setStorageAddress
-  call:
-    destination: $deployStorageK
-    function: setAddress
-    data: [$setStorageBaseAddress]
-
-- name: queryStorageAddress
-  query-contract:
-    destination: $deployStorageK
-    function: getAddress
-
-- name: assertStorageAddress
-  assert:
-    key: $queryStorageAddress
-    relation: eq
-    val: $setStorageBaseAddress
-
-- name: setStorageBaseBytes
-  set:
-    val: marmatoshi
-
-- name: setStorageBytes
-  call:
-    destination: $deployStorageK
-    function: setBytes
-    data: [$setStorageBaseBytes]
-
-- name: queryStorageBytes
-  query-contract:
-    destination: $deployStorageK
-    function: getBytes
-
-- name: assertStorageBytes
-  assert:
-    key: $queryStorageBytes
-    relation: eq
-    val: $setStorageBaseBytes
-
-- name: setStorageBaseString
-  set:
-    val: nakaburrow
-
-- name: setStorageString
-  call:
-    destination: $deployStorageK
-    function: setString
-    data: [$setStorageBaseString]
-
-- name: queryStorageString
-  query-contract:
-    destination: $deployStorageK
-    function: getString
-
-- name: assertStorageString
-  assert:
-    key: $queryStorageString
-    relation: eq
-    val: $setStorageBaseString
-```
-
-while our Solidity contract (`storage.sol`) looks like:
-
-```
-pragma solidity >=0.0.0;
-
-contract SimpleStorage {
-  bool storedBool;
-  bool storedBool2;
-  int storedInt;
-  uint storedUint;
-  address storedAddress;
-  bytes32 storedBytes;
-  string storedString;
-
-  function setBool(bool x) {
-    storedBool = x;
-  }
-
-  function getBool() constant returns (bool retBool) {
-    return storedBool;
-  }
-
-  function setBool2(bool x) {
-    storedBool2 = x;
-  }
-
-  function getBool2() constant returns (bool retBool) {
-    return storedBool2;
-  }
-
-  function setInt(int x) {
-    storedInt = x;
-  }
-
-  function getInt() constant returns (int retInt) {
-    return storedInt;
-  }
-
-  function setUint(uint x) {
-    storedUint = x;
-  }
-
-  function getUint() constant returns (uint retUint) {
-    return storedUint;
-  }
-
-  function setAddress(address x) {
-    storedAddress = x;
-  }
-
-  function getAddress() constant returns (address retAddress) {
-    return storedAddress;
-  }
-
-  function setBytes(bytes32 x) {
-    storedBytes = x;
-  }
-
-  function getBytes() constant returns (bytes32 retBytes) {
-    return storedBytes;
-  }
-
-  function setString(string x) {
-    storedString = x;
-  }
-
-  function getString() constant returns (string retString) {
-    return storedString;
-  }
-}
-```
-
-Both files (`deploy.yaml` & `storage.sol`) should be in the same directory with no other yaml or sol files.
-
-From inside that directory, we are ready to deploy.
-
-```
-burrow deploy --address=F71831847564B7008AD30DD56336D9C42787CF63
-```
+## Installation
 
-where you should replace the `--address` field with the `ValidatorAddress` at the top of your `burrow.toml`.
+See the [install instructions](docs/INSTALL.md).
 
-That's it! You've succesfully deployed (and tested) a Soldity contract to a Burrow node.
+## Quick Start
+1. [Single full node](docs/quickstart/single-full-node.md)
+1. [Send transactions](docs/quickstart/send-transactions.md)
+1. [Deploy contracts](docs/quickstart/deploy-contracts.md)
+1. [Multiple validators](docs/quickstart/multiple-validators.md)
+1. [Seed nodes](docs/quickstart/seed-nodes.md)
 
-Note - that to redeploy the burrow chain later, you will need the same genesis-spec.json and burrow.toml files - so keep hold of them!
+## Project documentation
+Burrow documentation is available in the [docs](docs/README.md) directory.",,2018-10-08 19:36:03,https://api.github.com/repos/hyperledger/burrow/pulls/comments/223315575,https://github.com/hyperledger/burrow/pull/931#discussion_r223315575,compleatang
https://github.com/hyperledger/burrow/pull/931,https://github.com/hyperledger/burrow/pull/931,nice additions,a067e9b8da22fa4d0ce2846dad92455f4274df9c,2018-10-08 13:15:00,223358370,"@@ -1,7 +1,12 @@
 # Hyperledger Burrow
 
-|[![GoDoc](https://godoc.org/github.com/burrow?status.png)](https://godoc.org/github.com/hyperledger/burrow) | Linux |
-|---|-------|
+[![version](https://img.shields.io/github/tag/hyperledger/burrow.svg)](https://github.com/hyperledger/burrow/releases/latest)
+[![GoDoc](https://godoc.org/github.com/burrow?status.png)](https://godoc.org/github.com/hyperledger/burrow)
+[![license](https://img.shields.io/github/license/hyperledger/burrow.svg)](LICENSE.md)
+[![LoC](https://tokei.rs/b1/github/hyperledger/burrow?category=lines)](https://github.com/hyperledger/burrow)
+
+Branch    | Linux
+----------|------",11,2018-10-08 19:36:03,https://api.github.com/repos/hyperledger/burrow/pulls/comments/223358370,https://github.com/hyperledger/burrow/pull/931#discussion_r223358370,silasdavis
https://github.com/hyperledger/burrow/pull/931,https://github.com/hyperledger/burrow/pull/931,"It might be nice to include a table of contents into the docs directory. Bullets would be fine with a link and maybe brief strapline. e.g.

```markdown
- [Sending transactions](docs/quickstart/send-transactions.md) - how to communicate with your Burrow chain
```

Admittedly it is another thing to maintain but it probably provides less of a click-it-and-see experience",a067e9b8da22fa4d0ce2846dad92455f4274df9c,2018-10-08 13:19:11,223359772,"@@ -20,349 +25,29 @@ Hyperledger Burrow is a permissioned blockchain node that executes smart contrac
 - **Application Binary Interface (ABI):** Transactions need to be formulated in a binary format that can be processed by the blockchain node. Current tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.
 - **API Gateway:** Burrow exposes REST and JSON-RPC endpoints to interact with the blockchain network and the application state through broadcasting transactions, or querying the current state of the application. Websockets allow subscribing to events, which is particularly valuable as the consensus engine and smart contract application can give unambiguously finalised results to transactions within one blocktime of about one second.
 
-## Project documentation and Roadmap
+## Project Roadmap
 
 Project information generally updated on a quarterly basis can be found on the [Hyperledger Burrow Wiki](https://wiki.hyperledger.org/projects/burrow).
 
-## Installation
-
-- [Install go](https://golang.org/doc/install) version 1.10 or above and have `$GOPATH` set
-
-```
-go get github.com/hyperledger/burrow
-cd github.com/hyperledger/burrow
-make build
-```
-
-This will build the `burrow` and `burrow-client` binaries and put them in the `bin/` directory. They can be executed from there or put wherever is convenient.
-
-You can also install `burrow` into `$GOPATH/bin` with `make install_burrow`,
-
-## Usage
-
-The end result will be a `burrow.toml` that will be read in from your current working directory when starting `burrow`.
-
-### Configuration
-
-#### Configure Burrow
-The quick-and-dirty one-liner looks like:
-
-```shell
-# Read spec on stdin
-burrow spec -p1 -f1 | burrow configure -s- > burrow.toml
-```
-
-which translates into:
-
-```shell
-# This is a place we can store config files and burrow's working directory '.burrow'
-mkdir chain_dir && cd chain_dir
-burrow spec --participant-accounts=1 --full-accounts=1 > genesis-spec.json
-burrow configure --genesis-spec=genesis-spec.json > burrow.toml
-```
-#### Run Burrow
-Once the `burrow.toml` has been created, we run:
-
-```
-# To select our validator address by index in the GenesisDoc
-burrow start --validator-index=0
-# Or to select based on address directly (substituting the example address below with your validator's):
-burrow start --validator-address=BE584820DC904A55449D7EB0C97607B40224B96E
-```
-
-and the logs will start streaming through.
-
-If you would like to reset your node, you can just delete its working directory with `rm -rf .burrow`. In the context of a
-multi-node chain it will resync with peers, otherwise it will restart from height 0.
-
-### Logging
-
-Logging is highly configurable through the `burrow.toml` `[logging]` section. Each log line is a list of key-value pairs that flows from the root sink through possible child sinks. Each sink can have an output, a transform, and sinks that it outputs to. Below is a more involved example than the one appearing in the default generated config of what you can configure:
-
-```toml
-# This is a top level config section within the main Burrow config
-[logging]
-  # All log lines are sent to the root sink from all sources
-  [logging.root_sink]
-    # We define two child sinks that each receive all log lines
-    [[logging.root_sink.sinks]]
-      # We send all output to stderr
-      [logging.root_sink.sinks.output]
-        output_type = ""stderr""
-
-    [[logging.root_sink.sinks]]
-      # But for the second sink we define a transform that filters log lines from Tendermint's p2p module
-      [logging.root_sink.sinks.transform]
-        transform_type = ""filter""
-        filter_mode = ""exclude_when_all_match""
-
-        [[logging.root_sink.sinks.transform.predicates]]
-          key_regex = ""module""
-          value_regex = ""p2p""
-
-        [[logging.root_sink.sinks.transform.predicates]]
-          key_regex = ""captured_logging_source""
-          value_regex = ""tendermint_log15""
-
-      # The child sinks of this filter transform sink are syslog and file and will omit log lines originating from p2p
-      [[logging.root_sink.sinks.sinks]]
-        [logging.root_sink.sinks.sinks.output]
-          output_type = ""syslog""
-          url = """"
-          tag = ""Burrow-network""
-
-      [[logging.root_sink.sinks.sinks]]
-        [logging.root_sink.sinks.sinks.output]
-          output_type = ""file""
-          path = ""/var/log/burrow-network.log""
-```
-## Deploy Contracts
-
-Now that the burrow node is running, we can deploy contracts.
-
-For this step, we need two things: one or more solidity contracts, and an `deploy.yaml`.
-
-Let's take a simple example, found in [this directory](tests/jobs_fixtures/app06-deploy_basic_contract_and_different_solc_types_packed_unpacked/).
-
-The `deploy.yaml` should look like:
-
-```
-jobs:
-
-- name: deployStorageK
-  deploy:
-    contract: storage.sol
-
-- name: setStorageBaseBool
-  set:
-    val: ""true""
-
-- name: setStorageBool
-  call:
-    destination: $deployStorageK
-    function: setBool
-    data: [$setStorageBaseBool]
-
-- name: queryStorageBool
-  query-contract:
-    destination: $deployStorageK
-    function: getBool
-
-- name: assertStorageBool
-  assert:
-    key: $queryStorageBool
-    relation: eq
-    val: $setStorageBaseBool
-
-# tests string bools: #71
-- name: setStorageBool2
-  call:
-    destination: $deployStorageK
-    function: setBool2
-    data: [true]
-
-- name: queryStorageBool2
-  query-contract:
-    destination: $deployStorageK
-    function: getBool2
-
-- name: assertStorageBool2
-  assert:
-    key: $queryStorageBool2
-    relation: eq
-    val: ""true""
-
-- name: setStorageBaseInt
-  set:
-    val: 50000
+## Minimum requirements
 
-- name: setStorageInt
-  call:
-    destination: $deployStorageK
-    function: setInt
-    data: [$setStorageBaseInt]
+Requirement|Notes
+---|---
+Go version | Go1.10 or higher
 
-- name: queryStorageInt
-  query-contract:
-    destination: $deployStorageK
-    function: getInt
-
-- name: assertStorageInt
-  assert:
-    key: $queryStorageInt
-    relation: eq
-    val: $setStorageBaseInt
-
-- name: setStorageBaseUint
-  set:
-    val: 9999999
-
-- name: setStorageUint
-  call:
-    destination: $deployStorageK
-    function: setUint
-    data: [$setStorageBaseUint]
-
-- name: queryStorageUint
-  query-contract:
-    destination: $deployStorageK
-    function: getUint
-
-- name: assertStorageUint
-  assert:
-    key: $queryStorageUint
-    relation: eq
-    val: $setStorageBaseUint
-
-- name: setStorageBaseAddress
-  set:
-    val: ""1040E6521541DAB4E7EE57F21226DD17CE9F0FB7""
-
-- name: setStorageAddress
-  call:
-    destination: $deployStorageK
-    function: setAddress
-    data: [$setStorageBaseAddress]
-
-- name: queryStorageAddress
-  query-contract:
-    destination: $deployStorageK
-    function: getAddress
-
-- name: assertStorageAddress
-  assert:
-    key: $queryStorageAddress
-    relation: eq
-    val: $setStorageBaseAddress
-
-- name: setStorageBaseBytes
-  set:
-    val: marmatoshi
-
-- name: setStorageBytes
-  call:
-    destination: $deployStorageK
-    function: setBytes
-    data: [$setStorageBaseBytes]
-
-- name: queryStorageBytes
-  query-contract:
-    destination: $deployStorageK
-    function: getBytes
-
-- name: assertStorageBytes
-  assert:
-    key: $queryStorageBytes
-    relation: eq
-    val: $setStorageBaseBytes
-
-- name: setStorageBaseString
-  set:
-    val: nakaburrow
-
-- name: setStorageString
-  call:
-    destination: $deployStorageK
-    function: setString
-    data: [$setStorageBaseString]
-
-- name: queryStorageString
-  query-contract:
-    destination: $deployStorageK
-    function: getString
-
-- name: assertStorageString
-  assert:
-    key: $queryStorageString
-    relation: eq
-    val: $setStorageBaseString
-```
-
-while our Solidity contract (`storage.sol`) looks like:
-
-```
-pragma solidity >=0.0.0;
-
-contract SimpleStorage {
-  bool storedBool;
-  bool storedBool2;
-  int storedInt;
-  uint storedUint;
-  address storedAddress;
-  bytes32 storedBytes;
-  string storedString;
-
-  function setBool(bool x) {
-    storedBool = x;
-  }
-
-  function getBool() constant returns (bool retBool) {
-    return storedBool;
-  }
-
-  function setBool2(bool x) {
-    storedBool2 = x;
-  }
-
-  function getBool2() constant returns (bool retBool) {
-    return storedBool2;
-  }
-
-  function setInt(int x) {
-    storedInt = x;
-  }
-
-  function getInt() constant returns (int retInt) {
-    return storedInt;
-  }
-
-  function setUint(uint x) {
-    storedUint = x;
-  }
-
-  function getUint() constant returns (uint retUint) {
-    return storedUint;
-  }
-
-  function setAddress(address x) {
-    storedAddress = x;
-  }
-
-  function getAddress() constant returns (address retAddress) {
-    return storedAddress;
-  }
-
-  function setBytes(bytes32 x) {
-    storedBytes = x;
-  }
-
-  function getBytes() constant returns (bytes32 retBytes) {
-    return storedBytes;
-  }
-
-  function setString(string x) {
-    storedString = x;
-  }
-
-  function getString() constant returns (string retString) {
-    return storedString;
-  }
-}
-```
-
-Both files (`deploy.yaml` & `storage.sol`) should be in the same directory with no other yaml or sol files.
-
-From inside that directory, we are ready to deploy.
-
-```
-burrow deploy --address=F71831847564B7008AD30DD56336D9C42787CF63
-```
+## Installation
 
-where you should replace the `--address` field with the `ValidatorAddress` at the top of your `burrow.toml`.
+See the [install instructions](docs/INSTALL.md).
 
-That's it! You've succesfully deployed (and tested) a Soldity contract to a Burrow node.
+## Quick Start
+1. [Single full node](docs/quickstart/single-full-node.md)
+1. [Send transactions](docs/quickstart/send-transactions.md)
+1. [Deploy contracts](docs/quickstart/deploy-contracts.md)
+1. [Multiple validators](docs/quickstart/multiple-validators.md)
+1. [Seed nodes](docs/quickstart/seed-nodes.md)
 
-Note - that to redeploy the burrow chain later, you will need the same genesis-spec.json and burrow.toml files - so keep hold of them!
+## Project documentation
+Burrow documentation is available in the [docs](docs/README.md) directory.",,2018-10-08 19:36:03,https://api.github.com/repos/hyperledger/burrow/pulls/comments/223359772,https://github.com/hyperledger/burrow/pull/931#discussion_r223359772,silasdavis
https://github.com/hyperledger/burrow/pull/929,https://github.com/hyperledger/burrow/pull/929,"Why are we losing this?

`vm.nestedCallErrors` is used as an accumulator for errors deeper in the stack for a particular outer (i.e. coming into captial c `Call`). If we don't clear it between calls we will end up accumulated errors for unrelated subsequent `Call`s in the case.

BTW this functionality exists because otherwise we may swallow the root cause of an EVM exception when that exception is generated deep in the EVM call stack (Solidity will generate some error-handling code - but that does not expose the Go error messages - and used to be much worse before REVERT).",6258775c2bce7bdef26b45d910fcf7e087e07d95,2018-10-08 13:25:58,223362040,"@@ -164,10 +165,6 @@ func (vm *VM) Call(callState *state.Cache, caller, callee *acm.MutableAccount, c
 			// Copy any state updates from child call frame into current call frame
 			childCallState.Sync(callState)
 		}
-		if vm.stackDepth == 0 {",12,2018-10-09 13:17:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/223362040,https://github.com/hyperledger/burrow/pull/929#discussion_r223362040,silasdavis
https://github.com/hyperledger/burrow/pull/929,https://github.com/hyperledger/burrow/pull/929,"what is this for, shouldn't we just use `go test -v` for this?",6258775c2bce7bdef26b45d910fcf7e087e07d95,2018-10-08 14:17:06,223379977,"@@ -72,6 +72,7 @@ func newAccount(seed ...byte) *acm.MutableAccount {
 
 // Runs a basic loop
 func TestVM(t *testing.T) {
+	fmt.Printf(""%s ---\n"", t.Name())",4,2018-10-09 13:17:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/223379977,https://github.com/hyperledger/burrow/pull/929#discussion_r223379977,silasdavis
https://github.com/hyperledger/burrow/pull/929,https://github.com/hyperledger/burrow/pull/929,"I think it might be better if we ensure no state writes at the state and event sink level. Rather than adding another contextual flag here:

- It will catch any state mutation we may not have thought about
- I think it's cleaner than managing this state in the EVM (with the various checks and resetting that is necessary)
- 'Context is bad' - we already have some but still.

However let's pin this thought (I'll PR some code that illustrates the alternative I have in mind) but there is useful stuff to be done in this PR anyway.",6258775c2bce7bdef26b45d910fcf7e087e07d95,2018-10-09 13:08:20,223692210,"@@ -68,6 +68,7 @@ type VM struct {
 	returnData       []byte
 	debugOpcodes     bool
 	dumpTokens       bool
+	inStaticCall     bool",4,2018-10-09 13:17:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/223692210,https://github.com/hyperledger/burrow/pull/929#discussion_r223692210,silasdavis
https://github.com/hyperledger/burrow/pull/929,https://github.com/hyperledger/burrow/pull/929,"This will panic if the error is not present. The signature of `assert.Error` is not what you think it is. In particular it's not like `assert.Equal` with an expected/actual argument, it just takes an error argument the rest of it is `msgAndArgs... interface{}`.",6258775c2bce7bdef26b45d910fcf7e087e07d95,2018-10-09 13:09:56,223692737,"@@ -709,12 +717,69 @@ func TestSendCall(t *testing.T) {
 	assert.NoError(t, err, ""Expected insufficient gas error"")
 }
 
+// Test to ensure that contracts called with STATICCALL cannot modify state
+func TestStaticCall(t *testing.T) {
+	fmt.Printf(""%s ---\n"", t.Name())
+	inOff, inSize := byte(0x0), byte(0x0) // no call data
+	retOff, retSize := byte(0x0), byte(0x2)
+
+	for _, illegalOp := range []OpCode{SSTORE, LOG0, LOG1, LOG2, LOG3, LOG4, CREATE, CREATE2, SELFDESTRUCT} {
+		cache := state.NewCache(newAppState())
+		ourVm := NewVM(newParams(), crypto.ZeroAddress, nil, logger)
+
+		calleeAccount, calleeAddress := makeAccountWithCode(cache, ""callee"",
+			MustSplice(illegalOp, PUSH1, 0x1, return1()))
+
+		callerAccount, _ := makeAccountWithCode(cache, ""caller"",
+			MustSplice(PUSH1, retSize, PUSH1, retOff, PUSH1, inSize, PUSH1,
+				inOff, PUSH20, calleeAddress, PUSH1, 0x1, GAS, SUB, STATICCALL, returnWord()))
+
+		_, err := runVMWaitError(cache, ourVm, callerAccount, calleeAccount, calleeAddress, callerAccount.Code(), 1000)
+
+		for _, nestedError := range ourVm.nestedCallErrors {
+			err = nil
+			if nestedError.NestedError.ErrorCode() == errors.ErrorCodeIllegalWrite {
+				err = nestedError.NestedError.ErrorCode()
+				break
+			}
+		}
+		assert.Error(t, err, errors.ErrorCodeIllegalWrite, ""Expected static call violation"")",94,2018-10-09 13:17:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/223692737,https://github.com/hyperledger/burrow/pull/929#discussion_r223692737,silasdavis
https://github.com/hyperledger/burrow/pull/929,https://github.com/hyperledger/burrow/pull/929,I _think_ this is okay for the `STATICCALL`,6258775c2bce7bdef26b45d910fcf7e087e07d95,2018-10-09 13:11:42,223693485,"@@ -709,12 +717,69 @@ func TestSendCall(t *testing.T) {
 	assert.NoError(t, err, ""Expected insufficient gas error"")
 }
 
+// Test to ensure that contracts called with STATICCALL cannot modify state
+func TestStaticCall(t *testing.T) {
+	fmt.Printf(""%s ---\n"", t.Name())
+	inOff, inSize := byte(0x0), byte(0x0) // no call data
+	retOff, retSize := byte(0x0), byte(0x2)
+
+	for _, illegalOp := range []OpCode{SSTORE, LOG0, LOG1, LOG2, LOG3, LOG4, CREATE, CREATE2, SELFDESTRUCT} {
+		cache := state.NewCache(newAppState())
+		ourVm := NewVM(newParams(), crypto.ZeroAddress, nil, logger)
+
+		calleeAccount, calleeAddress := makeAccountWithCode(cache, ""callee"",
+			MustSplice(illegalOp, PUSH1, 0x1, return1()))
+
+		callerAccount, _ := makeAccountWithCode(cache, ""caller"",
+			MustSplice(PUSH1, retSize, PUSH1, retOff, PUSH1, inSize, PUSH1,
+				inOff, PUSH20, calleeAddress, PUSH1, 0x1, GAS, SUB, STATICCALL, returnWord()))",83,2018-10-09 13:17:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/223693485,https://github.com/hyperledger/burrow/pull/929#discussion_r223693485,silasdavis
https://github.com/hyperledger/burrow/pull/929,https://github.com/hyperledger/burrow/pull/929,"This in general is not going to be legal solidity. All of the illegal ops take some number of arguments - you'll need to push them onto the stack somewhere otherwise we will just end up with StackUnderflow errors when we try to pop from the stack.

We can fix this by converting your illegal op words into well formed fragments replacing line 726 with something like:

```go
for _, illegalContractCode := range [][]byte{MustSplice(..., SSTORE), ...}
```",6258775c2bce7bdef26b45d910fcf7e087e07d95,2018-10-09 13:13:41,223694196,"@@ -709,12 +717,69 @@ func TestSendCall(t *testing.T) {
 	assert.NoError(t, err, ""Expected insufficient gas error"")
 }
 
+// Test to ensure that contracts called with STATICCALL cannot modify state
+func TestStaticCall(t *testing.T) {
+	fmt.Printf(""%s ---\n"", t.Name())
+	inOff, inSize := byte(0x0), byte(0x0) // no call data
+	retOff, retSize := byte(0x0), byte(0x2)
+
+	for _, illegalOp := range []OpCode{SSTORE, LOG0, LOG1, LOG2, LOG3, LOG4, CREATE, CREATE2, SELFDESTRUCT} {
+		cache := state.NewCache(newAppState())
+		ourVm := NewVM(newParams(), crypto.ZeroAddress, nil, logger)
+
+		calleeAccount, calleeAddress := makeAccountWithCode(cache, ""callee"",
+			MustSplice(illegalOp, PUSH1, 0x1, return1()))",79,2018-10-09 13:17:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/223694196,https://github.com/hyperledger/burrow/pull/929#discussion_r223694196,silasdavis
https://github.com/hyperledger/burrow/pull/929,https://github.com/hyperledger/burrow/pull/929,"Flag checking is done in the first instance for each illegal op's case which automatically returns, so afaik superficially checking state modification ops shouldn't require setting specific stack values. Though I agree its probably better to write legal solidity in the test case.",6258775c2bce7bdef26b45d910fcf7e087e07d95,2018-10-10 16:09:01,224143839,"@@ -709,12 +717,69 @@ func TestSendCall(t *testing.T) {
 	assert.NoError(t, err, ""Expected insufficient gas error"")
 }
 
+// Test to ensure that contracts called with STATICCALL cannot modify state
+func TestStaticCall(t *testing.T) {
+	fmt.Printf(""%s ---\n"", t.Name())
+	inOff, inSize := byte(0x0), byte(0x0) // no call data
+	retOff, retSize := byte(0x0), byte(0x2)
+
+	for _, illegalOp := range []OpCode{SSTORE, LOG0, LOG1, LOG2, LOG3, LOG4, CREATE, CREATE2, SELFDESTRUCT} {
+		cache := state.NewCache(newAppState())
+		ourVm := NewVM(newParams(), crypto.ZeroAddress, nil, logger)
+
+		calleeAccount, calleeAddress := makeAccountWithCode(cache, ""callee"",
+			MustSplice(illegalOp, PUSH1, 0x1, return1()))",79,2018-10-10 16:09:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/224143839,https://github.com/hyperledger/burrow/pull/929#discussion_r224143839,gregdhill
https://github.com/hyperledger/burrow/pull/929,https://github.com/hyperledger/burrow/pull/929,"That was left in from debugging, I'll be sure to remove it in my next commit.",6258775c2bce7bdef26b45d910fcf7e087e07d95,2018-10-10 16:10:21,224144279,"@@ -72,6 +72,7 @@ func newAccount(seed ...byte) *acm.MutableAccount {
 
 // Runs a basic loop
 func TestVM(t *testing.T) {
+	fmt.Printf(""%s ---\n"", t.Name())",4,2018-10-10 16:10:21,https://api.github.com/repos/hyperledger/burrow/pulls/comments/224144279,https://github.com/hyperledger/burrow/pull/929#discussion_r224144279,gregdhill
https://github.com/hyperledger/burrow/pull/929,https://github.com/hyperledger/burrow/pull/929,We'll probably need to talk over this because I'm still not entirely sure how else we would resolve nested errors in the test cases. Surely we don't want to swallow any errors?,6258775c2bce7bdef26b45d910fcf7e087e07d95,2018-10-10 16:12:17,224144949,"@@ -164,10 +165,6 @@ func (vm *VM) Call(callState *state.Cache, caller, callee *acm.MutableAccount, c
 			// Copy any state updates from child call frame into current call frame
 			childCallState.Sync(callState)
 		}
-		if vm.stackDepth == 0 {",12,2018-10-10 16:12:18,https://api.github.com/repos/hyperledger/burrow/pulls/comments/224144949,https://github.com/hyperledger/burrow/pull/929#discussion_r224144949,gregdhill
https://github.com/hyperledger/burrow/pull/926,https://github.com/hyperledger/burrow/pull/926,"This whole function basically looks fine to me, but we are doing basically the same thing here, but in a slightly different way: https://github.com/hyperledger/burrow/blob/develop/execution/evm/memory.go#L111-L142 so might be worth seeing if we could/should be more consistent with that in approach.

Thanks to Go and its type system we can't really reuse the implementation, but I wonder if we might want to borrow a few things from it:

1. It relies on the Go runtime to grow the backing array - this ends up growing exponentially growth like you have here but has a few tweak in particular in grows linearly for small capacities. I can't say that it would make a dramatic difference, but I'd be inclined to piggy-back on Go's runtime which is more heavily optimised (and we get get at by using `append`).

2. There are some overflow checks there that we don't have here.",44f0f8a4d642d96735bb274e0cbf6a547aba76e3,2018-10-09 14:32:00,223726694,"@@ -185,3 +189,29 @@ func Is64BitOverflow(word Word256) bool {
 	}
 	return false
 }
+
+func (st *Stack) tryGrow() bool {
+	stackCap := cap(st.data)
+	hasMaxCap := st.maxCapacity > 0
+	if hasMaxCap && st.maxCapacity == stackCap {
+		return false
+	}
+
+	newCap := stackCap * 2
+	if newCap == 0 {
+		// Initialized with no capacity but stack can grow
+		newCap = 2
+	}
+
+	if hasMaxCap && st.maxCapacity < newCap {
+		// Last attempt to grow
+		newCap = st.maxCapacity
+	}
+
+	// Grow
+	newData := make([]Word256, newCap)
+	copy(newData, st.data)
+	st.data = newData
+
+	return true",,2018-10-16 10:01:25,https://api.github.com/repos/hyperledger/burrow/pulls/comments/223726694,https://github.com/hyperledger/burrow/pull/926#discussion_r223726694,silasdavis
https://github.com/hyperledger/burrow/pull/926,https://github.com/hyperledger/burrow/pull/926,This ends up being 1 MiB which is quite a bit 'minimum chunk'. In memory.go we are just using 32 bytes. So `var zeroWord Word256` would be fine here. In fact we actually already have a constant you can use for this: https://github.com/hyperledger/burrow/blob/develop/binary/word256.go#L27. May as well import that and save the allocation.,44f0f8a4d642d96735bb274e0cbf6a547aba76e3,2018-10-16 10:45:30,225488477,"@@ -21,23 +21,32 @@ import (
 
 	. ""github.com/hyperledger/burrow/binary""
 	""github.com/hyperledger/burrow/execution/errors""
+	""math""
 )
 
+// Change the length of this zero array to tweak the size of the block of zeros
+// written to the backing slice at a time when it is grown. A larger number may
+// lead to fewer calls to append to achieve the desired capacity although it is
+// unlikely to make a lot of difference.
+var zeroWords []Word256 = make([]Word256, 32)",11,2018-10-16 10:52:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/225488477,https://github.com/hyperledger/burrow/pull/926#discussion_r225488477,silasdavis
https://github.com/hyperledger/burrow/pull/896,https://github.com/hyperledger/burrow/pull/896,oh god,cc5fdce119bc9e7cae0cdf2705f6714799cccb57,2018-08-24 14:42:46,212651627,"@@ -277,7 +277,7 @@ func (s *State) GetStorage(address crypto.Address, key binary.Word256) (binary.W
 
 func (ws *writeState) SetStorage(address crypto.Address, key, value binary.Word256) error {
 	if value == binary.Zero256 {
-		ws.state.tree.Remove(key.Bytes())
+		ws.state.tree.Remove(prefixedKey(storagePrefix, address.Bytes(), key.Bytes()))",5,2018-08-24 15:43:47,https://api.github.com/repos/hyperledger/burrow/pulls/comments/212651627,https://github.com/hyperledger/burrow/pull/896#discussion_r212651627,silasdavis
https://github.com/hyperledger/burrow/pull/883,https://github.com/hyperledger/burrow/pull/883,this won't work. can we just remove this file from the commit and use mine? it makes the same changes and adds a bit better hygeine to the image.,7c95563cf8b7c0c596147a3b380ca84265039925,2018-08-20 20:40:59,211400257,"@@ -16,17 +16,17 @@ FROM alpine:3.8
 
 ARG REPO=/go/src/github.com/hyperledger/burrow
 
-ENV USER monax
-ENV MONAX_PATH /home/$USER/.monax
+ENV USER burrow
+ENV BURROW_PATH /home/$USER
 RUN addgroup -g 101 -S $USER && adduser -S -D -u 1000 $USER $USER
-WORKDIR $MONAX_PATH
+WORKDIR $ BURROW_PATH",,2018-08-21 07:59:19,https://api.github.com/repos/hyperledger/burrow/pulls/comments/211400257,https://github.com/hyperledger/burrow/pull/883#discussion_r211400257,compleatang
https://github.com/hyperledger/burrow/pull/883,https://github.com/hyperledger/burrow/pull/883,"docker best practice is...

```bash
echo ${DOCKER_PASS} | docker login --username ${DOCKER_USER} ${DOCKER_REPO} --password-stdin
```",7c95563cf8b7c0c596147a3b380ca84265039925,2018-08-20 20:43:45,211401086,"@@ -2,10 +2,14 @@
 
 version_regex=""^v[0-9]+\.[0-9]+\.[0-9]+$""
 
+set -e
 
 function release {
     notes=""NOTES.md""
     echo ""Building and releasing $tag...""
+    echo ""Pushing docker image...""
+    docker login -u ${DOCKER_USER} -p ${DOCKER_PASS} && docker push ${DOCKER_REPO}",,2018-08-21 07:59:19,https://api.github.com/repos/hyperledger/burrow/pulls/comments/211401086,https://github.com/hyperledger/burrow/pull/883#discussion_r211401086,compleatang
https://github.com/hyperledger/burrow/pull/854,https://github.com/hyperledger/burrow/pull/854,"I know we used breaking changes in the past, but I thought we could just use:

\### Changed

As per: https://keepachangelog.com/en/1.0.0/",2dbfc9546fb4ea683271e2ac9de3c81f1b4db17b,2018-08-15 14:57:04,210297176,"@@ -30,7 +30,11 @@ func FullVersion() string {
 var History relic.ImmutableHistory = relic.NewHistory(""Hyperledger Burrow"", ""https://github.com/hyperledger/burrow"").
 	MustDeclareReleases(
 		"""",
-		`Release our mempool signing lock once transactions have been CheckTx'd' to massively increase throughput, also support mempool signing for BroadcastTxAsync.`,
+		`Release our mempool signing lock once transactions have been CheckTx'd' to massively increase throughput, also support mempool signing for BroadcastTxAsync.
+
+#### Breaking changes",,2018-08-15 18:08:36,https://api.github.com/repos/hyperledger/burrow/pulls/comments/210297176,https://github.com/hyperledger/burrow/pull/854#discussion_r210297176,silasdavis
https://github.com/hyperledger/burrow/pull/854,https://github.com/hyperledger/burrow/pull/854,"Yes, you're right.",2dbfc9546fb4ea683271e2ac9de3c81f1b4db17b,2018-08-15 17:20:40,210341876,"@@ -30,7 +30,11 @@ func FullVersion() string {
 var History relic.ImmutableHistory = relic.NewHistory(""Hyperledger Burrow"", ""https://github.com/hyperledger/burrow"").
 	MustDeclareReleases(
 		"""",
-		`Release our mempool signing lock once transactions have been CheckTx'd' to massively increase throughput, also support mempool signing for BroadcastTxAsync.`,
+		`Release our mempool signing lock once transactions have been CheckTx'd' to massively increase throughput, also support mempool signing for BroadcastTxAsync.
+
+#### Breaking changes",,2018-08-15 18:08:36,https://api.github.com/repos/hyperledger/burrow/pulls/comments/210341876,https://github.com/hyperledger/burrow/pull/854#discussion_r210341876,seanyoung
https://github.com/hyperledger/burrow/pull/854,https://github.com/hyperledger/burrow/pull/854,Now fixed.,2dbfc9546fb4ea683271e2ac9de3c81f1b4db17b,2018-08-15 17:20:49,210341926,"@@ -30,7 +30,11 @@ func FullVersion() string {
 var History relic.ImmutableHistory = relic.NewHistory(""Hyperledger Burrow"", ""https://github.com/hyperledger/burrow"").
 	MustDeclareReleases(
 		"""",
-		`Release our mempool signing lock once transactions have been CheckTx'd' to massively increase throughput, also support mempool signing for BroadcastTxAsync.`,
+		`Release our mempool signing lock once transactions have been CheckTx'd' to massively increase throughput, also support mempool signing for BroadcastTxAsync.
+
+#### Breaking changes",,2018-08-15 18:08:36,https://api.github.com/repos/hyperledger/burrow/pulls/comments/210341926,https://github.com/hyperledger/burrow/pull/854#discussion_r210341926,seanyoung
https://github.com/hyperledger/burrow/pull/854,https://github.com/hyperledger/burrow/pull/854,We had probably better put these back on reflection... It appears to be the style used by product team. It's to distinguish globals from returns. Shadowing is particularly bad in solidity because you tend to declare your returns outside of the body so it may be a little harder to notice.,2dbfc9546fb4ea683271e2ac9de3c81f1b4db17b,2018-08-15 17:32:47,210345763,"@@ -9,62 +10,62 @@ pragma solidity >=0.4.0;
 * @dev Permissions permissions = Permissions(address(keccak256(""Permissions"")));
 */
 contract Permissions {
-  /**
-  * @notice Adds a role to an account
-  * @param _account account address",11,2018-08-15 18:08:36,https://api.github.com/repos/hyperledger/burrow/pulls/comments/210345763,https://github.com/hyperledger/burrow/pull/854#discussion_r210345763,silasdavis
https://github.com/hyperledger/burrow/pull/829,https://github.com/hyperledger/burrow/pull/829,"Not sure about this error, improve?",ae45563e713f1e02b86a508c07cee17b915b1f71,2018-07-10 14:30:54,201365635,"@@ -0,0 +1,164 @@
+package rpctransact
+
+import (
+	""fmt""
+
+	""github.com/hyperledger/burrow/execution""
+	""github.com/hyperledger/burrow/execution/events""
+	""github.com/hyperledger/burrow/txs""
+	""github.com/hyperledger/burrow/txs/payload""
+	""golang.org/x/net/context""
+)
+
+type transactServer struct {
+	transactor *execution.Transactor
+	txCodec    txs.Codec
+}
+
+func NewTransactorServer(transactor *execution.Transactor, txCodec txs.Codec) TransactServer {
+	return &transactServer{
+		transactor: transactor,
+		txCodec:    txCodec,
+	}
+}
+
+func (ts *transactServer) BroadcastTxAsync(ctx context.Context, param *TxEnvelopeParam) (*txs.Receipt, error) {
+	txEnv := param.GetEnvelope(ts.transactor.Tip.ChainID())
+	if txEnv == nil {
+		return nil, fmt.Errorf(""no transaction envelope or payload provided"")
+	}
+	return ts.transactor.BroadcastTxAsync(txEnv)
+}
+
+func (ts *transactServer) BroadcastTxSync(ctx context.Context, param *TxEnvelopeParam) (*TxEvents, error) {
+	txEnv := param.GetEnvelope(ts.transactor.Tip.ChainID())
+	if txEnv == nil {
+		return nil, fmt.Errorf(""no transaction envelope or payload provided"")
+	}
+	evs, receipt, err := ts.transactor.BroadcastTxSync(ctx, txEnv)
+	if err != nil {
+		return nil, err
+	}
+	return &TxEvents{
+		Receipt: receipt,
+		Events:  evs,
+	}, nil
+}
+
+func (ts *transactServer) SignTx(ctx context.Context, param *TxEnvelopeParam) (*TxEnvelope, error) {
+	txEnv := param.GetEnvelope(ts.transactor.Tip.ChainID())
+	if txEnv == nil {
+		return nil, fmt.Errorf(""no transaction envelope or payload provided"")
+	}
+	txEnv, err := ts.transactor.SignTx(txEnv)
+	if err != nil {
+		return nil, err
+	}
+	return &TxEnvelope{
+		Envelope: txEnv,
+	}, nil
+}
+
+func (ts *transactServer) FormulateTx(ctx context.Context, param *PayloadParam) (*TxEnvelope, error) {
+	txEnv := param.Envelope(ts.transactor.Tip.ChainID())
+	if txEnv == nil {
+		return nil, fmt.Errorf(""not payload provide to FormulateTx"")",,2018-07-18 17:16:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/201365635,https://github.com/hyperledger/burrow/pull/829#discussion_r201365635,seanyoung
https://github.com/hyperledger/burrow/pull/829,https://github.com/hyperledger/burrow/pull/829,"Is it possible the tx will never make it to a block (consensus failure, another validator proposed block with tx for same address + same sequence number?) Do we leak stuff?",ae45563e713f1e02b86a508c07cee17b915b1f71,2018-07-10 15:00:37,201377881,"@@ -85,6 +91,31 @@ func SubscribeAccountOutputSendTx(ctx context.Context, subscribable event.Subscr
 	})
 }
 
+// Subscribe to all execution events generated by a particular Tx
+func SubscribeTx(ctx context.Context, subscribable event.Subscribable, txHash []byte, ch chan<- *Event) error {
+	qry := query.NewBuilder().AndEquals(event.TxHashKey, hex.EncodeUpperToString(txHash))
+
+	subscriber, err := event.GenerateSubscriptionID()
+	if err != nil {
+		return err
+	}
+
+	// Acts as a sentinel for the final event
+	confirmationEventID := EventStringTxConfirmation(txHash)
+",,2018-07-18 17:16:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/201377881,https://github.com/hyperledger/burrow/pull/829#discussion_r201377881,seanyoung
https://github.com/hyperledger/burrow/pull/829,https://github.com/hyperledger/burrow/pull/829,tags are gone,ae45563e713f1e02b86a508c07cee17b915b1f71,2018-07-10 15:02:00,201378364,"@@ -10,19 +10,6 @@ import (
 	ptypes ""github.com/hyperledger/burrow/permission/types""
 )
 
-type TemplateAccount struct {
-	// Template accounts sharing a name will be merged when merging genesis specs
-	Name string `json:"",omitempty"" toml:"",omitempty""`
-	// Address  is convenient to have in file for reference, but otherwise ignored since derived from PublicKey
-	Address     *crypto.Address   `json:"",omitempty"" toml:"",omitempty""`
-	NodeAddress *crypto.Address   `json:"",omitempty"" toml:"",omitempty""`
-	PublicKey   *crypto.PublicKey `json:"",omitempty"" toml:"",omitempty""`
-	Amount      *uint64           `json:"",omitempty"" toml:"",omitempty""`
-	Power       *uint64           `json:"",omitempty"" toml:"",omitempty""`
-	Permissions []string          `json:"",omitempty"" toml:"",omitempty""`
-	Roles       []string          `json:"",omitempty"" toml:"",omitempty""`
-}
-",19,2018-07-18 17:16:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/201378364,https://github.com/hyperledger/burrow/pull/829#discussion_r201378364,seanyoung
https://github.com/hyperledger/burrow/pull/829,https://github.com/hyperledger/burrow/pull/829,done,ae45563e713f1e02b86a508c07cee17b915b1f71,2018-07-10 17:35:09,201431405,"@@ -0,0 +1,164 @@
+package rpctransact
+
+import (
+	""fmt""
+
+	""github.com/hyperledger/burrow/execution""
+	""github.com/hyperledger/burrow/execution/events""
+	""github.com/hyperledger/burrow/txs""
+	""github.com/hyperledger/burrow/txs/payload""
+	""golang.org/x/net/context""
+)
+
+type transactServer struct {
+	transactor *execution.Transactor
+	txCodec    txs.Codec
+}
+
+func NewTransactorServer(transactor *execution.Transactor, txCodec txs.Codec) TransactServer {
+	return &transactServer{
+		transactor: transactor,
+		txCodec:    txCodec,
+	}
+}
+
+func (ts *transactServer) BroadcastTxAsync(ctx context.Context, param *TxEnvelopeParam) (*txs.Receipt, error) {
+	txEnv := param.GetEnvelope(ts.transactor.Tip.ChainID())
+	if txEnv == nil {
+		return nil, fmt.Errorf(""no transaction envelope or payload provided"")
+	}
+	return ts.transactor.BroadcastTxAsync(txEnv)
+}
+
+func (ts *transactServer) BroadcastTxSync(ctx context.Context, param *TxEnvelopeParam) (*TxEvents, error) {
+	txEnv := param.GetEnvelope(ts.transactor.Tip.ChainID())
+	if txEnv == nil {
+		return nil, fmt.Errorf(""no transaction envelope or payload provided"")
+	}
+	evs, receipt, err := ts.transactor.BroadcastTxSync(ctx, txEnv)
+	if err != nil {
+		return nil, err
+	}
+	return &TxEvents{
+		Receipt: receipt,
+		Events:  evs,
+	}, nil
+}
+
+func (ts *transactServer) SignTx(ctx context.Context, param *TxEnvelopeParam) (*TxEnvelope, error) {
+	txEnv := param.GetEnvelope(ts.transactor.Tip.ChainID())
+	if txEnv == nil {
+		return nil, fmt.Errorf(""no transaction envelope or payload provided"")
+	}
+	txEnv, err := ts.transactor.SignTx(txEnv)
+	if err != nil {
+		return nil, err
+	}
+	return &TxEnvelope{
+		Envelope: txEnv,
+	}, nil
+}
+
+func (ts *transactServer) FormulateTx(ctx context.Context, param *PayloadParam) (*TxEnvelope, error) {
+	txEnv := param.Envelope(ts.transactor.Tip.ChainID())
+	if txEnv == nil {
+		return nil, fmt.Errorf(""not payload provide to FormulateTx"")",,2018-07-18 17:16:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/201431405,https://github.com/hyperledger/burrow/pull/829#discussion_r201431405,silasdavis
https://github.com/hyperledger/burrow/pull/829,https://github.com/hyperledger/burrow/pull/829,done,ae45563e713f1e02b86a508c07cee17b915b1f71,2018-07-10 17:35:16,201431440,"@@ -10,19 +10,6 @@ import (
 	ptypes ""github.com/hyperledger/burrow/permission/types""
 )
 
-type TemplateAccount struct {
-	// Template accounts sharing a name will be merged when merging genesis specs
-	Name string `json:"",omitempty"" toml:"",omitempty""`
-	// Address  is convenient to have in file for reference, but otherwise ignored since derived from PublicKey
-	Address     *crypto.Address   `json:"",omitempty"" toml:"",omitempty""`
-	NodeAddress *crypto.Address   `json:"",omitempty"" toml:"",omitempty""`
-	PublicKey   *crypto.PublicKey `json:"",omitempty"" toml:"",omitempty""`
-	Amount      *uint64           `json:"",omitempty"" toml:"",omitempty""`
-	Power       *uint64           `json:"",omitempty"" toml:"",omitempty""`
-	Permissions []string          `json:"",omitempty"" toml:"",omitempty""`
-	Roles       []string          `json:"",omitempty"" toml:"",omitempty""`
-}
-",19,2018-07-18 17:16:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/201431440,https://github.com/hyperledger/burrow/pull/829#discussion_r201431440,silasdavis
https://github.com/hyperledger/burrow/pull/829,https://github.com/hyperledger/burrow/pull/829,We don't really want to listen until our grpc services are registered and ready to serve,ae45563e713f1e02b86a508c07cee17b915b1f71,2018-07-19 10:22:10,203675075,"@@ -231,6 +204,7 @@ func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tm_t
 				if err != nil {
 					return nil, err
 				}
+				listen.Addr()",132,2018-07-19 12:58:15,https://api.github.com/repos/hyperledger/burrow/pulls/comments/203675075,https://github.com/hyperledger/burrow/pull/829#discussion_r203675075,seanyoung
https://github.com/hyperledger/burrow/pull/814,https://github.com/hyperledger/burrow/pull/814,"minor but can we put this at end, I like to see most important methods first ",97641a6fb5aabe6589c3271cb4c801fbbb0bb49b,2018-06-21 15:30:57,197178702,"@@ -16,8 +18,23 @@ import (
 	logging_config ""github.com/hyperledger/burrow/logging/config""
 	""github.com/hyperledger/burrow/logging/config/presets""
 	""github.com/jawher/mow.cli""
+	""github.com/tendermint/go-amino""
+	tm_crypto ""github.com/tendermint/go-crypto""
+	""github.com/tendermint/tendermint/p2p""
 )
 
+func processTemplate(pkg *deployment.Config, config *genesis.GenesisDoc, templateIn, templateOut string) error {",,2018-06-21 15:46:40,https://api.github.com/repos/hyperledger/burrow/pulls/comments/197178702,https://github.com/hyperledger/burrow/pull/814#discussion_r197178702,silasdavis
https://github.com/hyperledger/burrow/pull/814,https://github.com/hyperledger/burrow/pull/814,think `config-template-in` `config-out` better reflects semantics,97641a6fb5aabe6589c3271cb4c801fbbb0bb49b,2018-06-21 15:36:25,197180595,"@@ -56,9 +77,11 @@ func Configure(output Output) func(cmd *cli.Cmd) {
 
 		chainNameOpt := cmd.StringOpt(""n chain-name"", """", ""Default chain name"")
 
-		cmd.Spec = ""[--keys-url=<keys URL> | (--generate-keys=<secret keys files> [--keys-template=<text template for each key>])] "" +
+		cmd.Spec = ""[--keys-url=<keys URL> | --keysdir=<keys directory>] "" +
+			""[--config-template-in=<text template> --config-template-out=<output file>]... "" +",,2018-06-21 15:46:40,https://api.github.com/repos/hyperledger/burrow/pulls/comments/197180595,https://github.com/hyperledger/burrow/pull/814#discussion_r197180595,silasdavis
https://github.com/hyperledger/burrow/pull/814,https://github.com/hyperledger/burrow/pull/814,Fixed,97641a6fb5aabe6589c3271cb4c801fbbb0bb49b,2018-06-21 15:55:03,197187414,"@@ -16,8 +18,23 @@ import (
 	logging_config ""github.com/hyperledger/burrow/logging/config""
 	""github.com/hyperledger/burrow/logging/config/presets""
 	""github.com/jawher/mow.cli""
+	""github.com/tendermint/go-amino""
+	tm_crypto ""github.com/tendermint/go-crypto""
+	""github.com/tendermint/tendermint/p2p""
 )
 
+func processTemplate(pkg *deployment.Config, config *genesis.GenesisDoc, templateIn, templateOut string) error {",,2018-06-21 15:55:03,https://api.github.com/repos/hyperledger/burrow/pulls/comments/197187414,https://github.com/hyperledger/burrow/pull/814#discussion_r197187414,seanyoung
https://github.com/hyperledger/burrow/pull/808,https://github.com/hyperledger/burrow/pull/808,"The implicit rule ""%.pb.go: %.proto"" already figures out what proto file is needed to build the .pb.go file.
The dependencies are not explicit here.
Why not make $(PROTO_GO_FILES) a dependency of build and remove these lines:

keys/pbkeys/keys.pb.go: keys/pbkeys/keys.proto

rpc/burrow/burrow.pb.go: rpc/burrow/burrow.proto

execution/events/events.pb.go: execution/events/events.proto
    ",3841e07bfc5b23b36df1a59fb094db7194fab1a6,2018-06-21 09:08:06,197061499,"@@ -67,13 +68,24 @@ megacheck:
 protobuf_deps:
 	@go get -u github.com/golang/protobuf/protoc-gen-go
 
+# Implicit compile rule for GRPC/proto files
+%.pb.go: %.proto
+	protoc -I ${GOPATH}/src ${REPO}/$< --go_out=plugins=grpc:${GOPATH}/src
+
 keys/pbkeys/keys.pb.go: keys/pbkeys/keys.proto
-	@protoc -I ./keys/pbkeys keys/pbkeys/keys.proto --go_out=plugins=grpc:keys/pbkeys
 
-rpc/burrow/burrow.pb.go: rpc/burrow
-	@protoc -I ./rpc/burrow rpc/burrow/burrow.proto --go_out=plugins=grpc:rpc/burrow
-### Dependency management for github.com/hyperledger/burrow
+rpc/burrow/burrow.pb.go: rpc/burrow/burrow.proto
+
+execution/events/events.pb.go: execution/events/events.proto",,2018-06-25 13:46:25,https://api.github.com/repos/hyperledger/burrow/pulls/comments/197061499,https://github.com/hyperledger/burrow/pull/808#discussion_r197061499,seanyoung
https://github.com/hyperledger/burrow/pull/807,https://github.com/hyperledger/burrow/pull/807,:+1: ,1e1360c19d67987de03e9296f5773f40e51d84b2,2018-06-18 22:18:57,196243345,"@@ -12,9 +12,26 @@ burrow_bin=${burrow_bin:-burrow}
 keys_dir=./keys/test_scratch/.keys
 
 echo ""-----------------------------""
+echo ""checking for dependent utilities""
+for UTILITY in jq xxd openssl; do
+        echo -n ""... ""
+        if ! command -v $UTILITY; then
+                echo ""$UTILITY (missing)""
+                missing_utility=$UTILITY
+        fi
+done
+if [ ! -z $missing_utility ]; then
+        echo ""FAILED dependency check: the '$missing_utility' utility is missing""
+        exit 1
+fi
+
 echo ""starting the server""
 $burrow_bin keys server --dir $keys_dir &
 keys_pid=$!
+function kill_burrow_keys {
+        kill -TERM $keys_pid
+}
+trap kill_burrow_keys EXIT",23,2018-06-18 22:19:51,https://api.github.com/repos/hyperledger/burrow/pulls/comments/196243345,https://github.com/hyperledger/burrow/pull/807#discussion_r196243345,silasdavis
https://github.com/hyperledger/burrow/pull/800,https://github.com/hyperledger/burrow/pull/800,yep this is the best way to do things,f4e78f154ce8a499c7bd7dc1206c7bb80d5f3e4e,2018-06-13 10:20:41,195029787,"@@ -92,248 +52,155 @@ type ConcreteAccount struct {
 	Permissions ptypes.AccountPermissions
 }
 
-func NewConcreteAccount(pubKey crypto.PublicKey) ConcreteAccount {
-	return ConcreteAccount{
-		Address:   pubKey.Address(),
-		PublicKey: pubKey,
-		// Since nil slices and maps compare differently to empty ones
-		Code:        Bytecode{},
-		StorageRoot: []byte{},
-		Permissions: ptypes.AccountPermissions{
-			Roles: []string{},
+///---- Constructors
+func NewAccount(pubKey crypto.PublicKey, permissions ptypes.AccountPermissions) *Account {
+	return &Account{
+		data: accountData{
+			Address:     pubKey.Address(),
+			PublicKey:   pubKey,
+			Sequence:    0,
+			Balance:     0,
+			Code:        []byte{},
+			StorageRoot: []byte{},
+			Permissions: permissions,
 		},
 	}
 }
 
-func NewConcreteAccountFromSecret(secret string) ConcreteAccount {
-	return NewConcreteAccount(crypto.PrivateKeyFromSecret(secret, crypto.CurveTypeEd25519).GetPublicKey())
-}
-
-// Return as immutable Account
-func (acc ConcreteAccount) Account() Account {
-	return concreteAccountWrapper{&acc}
-}
-
-// Return as mutable MutableAccount
-func (acc ConcreteAccount) MutableAccount() MutableAccount {
-	return concreteAccountWrapper{&acc}
-}
-
-func (acc *ConcreteAccount) Encode() ([]byte, error) {
-	buf := new(bytes.Buffer)
-	var n int
-	var err error
-	wire.WriteBinary(acc, buf, &n, &err)
-	if err != nil {
-		return nil, err
+func NewContractAccount(address crypto.Address, permissions ptypes.AccountPermissions) *Account {
+	return &Account{
+		data: accountData{
+			Address:     address,
+			PublicKey:   crypto.PublicKey{},
+			Sequence:    0,
+			Balance:     0,
+			Code:        []byte{},
+			StorageRoot: []byte{},
+			Permissions: permissions,
+		},
 	}
-	return buf.Bytes(), nil
 }
 
-func (acc *ConcreteAccount) Copy() *ConcreteAccount {
-	accCopy := *acc
-	return &accCopy
+func NewAccountFromSecret(secret string, permissions ptypes.AccountPermissions) *Account {
+	return NewAccount(crypto.PrivateKeyFromSecret(secret, crypto.CurveTypeEd25519).GetPublicKey(),
+		permissions)
 }
 
-func (acc *ConcreteAccount) String() string {
-	if acc == nil {
-		return ""Account{nil}""
-	}
-
-	return fmt.Sprintf(""Account{Address: %s; Sequence: %v; PublicKey: %v Balance: %v; CodeBytes: %v; StorageRoot: 0x%X; Permissions: %s}"",
-		acc.Address, acc.Sequence, acc.PublicKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
+func NewContractAccountFromSecret(secret string, permissions ptypes.AccountPermissions) *Account {
+	addr := crypto.NewContractAddress(crypto.PrivateKeyFromSecret(secret, crypto.CurveTypeEd25519).GetPublicKey().Address(), 1)
+	return NewContractAccount(addr, permissions)
 }
 
-// ConcreteAccount
-// -------------------------------------------------
-// Conversions
-//
-// Using the naming convention is this package of 'As<Type>' being
-// a conversion from Account to <Type> and 'From<Type>' being conversion
-// from <Type> to Account. Conversions are done by copying
-
-// Returns a mutable, serialisable ConcreteAccount by copying from account
-func AsConcreteAccount(account Account) *ConcreteAccount {
-	if account == nil {
-		return nil
-	}
-	// Avoid a copy
-	if ca, ok := account.(concreteAccountWrapper); ok {
-		return ca.ConcreteAccount
-	}
-	return &ConcreteAccount{
-		Address:     account.Address(),
-		PublicKey:   account.PublicKey(),
-		Balance:     account.Balance(),
-		Code:        account.Code(),
-		Sequence:    account.Sequence(),
-		StorageRoot: account.StorageRoot(),
-		Permissions: account.Permissions(),
-	}
-}
+///---- Getter methods
+func (acc Account) Address() crypto.Address                { return acc.data.Address }
+func (acc Account) PublicKey() crypto.PublicKey            { return acc.data.PublicKey }
+func (acc Account) Balance() uint64                        { return acc.data.Balance }
+func (acc Account) Code() Bytecode                         { return acc.data.Code }
+func (acc Account) Sequence() uint64                       { return acc.data.Sequence }
+func (acc Account) StorageRoot() []byte                    { return acc.data.StorageRoot }
+func (acc Account) Permissions() ptypes.AccountPermissions { return acc.data.Permissions }
 
-// Creates an otherwise zeroed Account from an Addressable and returns it as MutableAccount
-func FromAddressable(addressable Addressable) MutableAccount {
-	return ConcreteAccount{
-		Address:   addressable.Address(),
-		PublicKey: addressable.PublicKey(),
-		// Since nil slices and maps compare differently to empty ones
-		Code:        Bytecode{},
-		StorageRoot: []byte{},
-		Permissions: ptypes.AccountPermissions{
-			Roles: []string{},
-		},
-	}.MutableAccount()
+func (acc Account) String() string {
+	return fmt.Sprintf(""Account{Address: %s; Sequence: %v; PublicKey: %v Balance: %v; CodeBytes: %v; StorageRoot: 0x%X; Permissions: %s}"",
+		acc.Address(), acc.Sequence(), acc.PublicKey(), acc.Balance(), len(acc.Code()), acc.StorageRoot(), acc.Permissions())
 }
 
-// Returns an immutable account by copying from account
-func AsAccount(account Account) Account {
-	if account == nil {
-		return nil
+///---- Mutable methods
+func (acc *Account) SubtractFromBalance(amount uint64) error {
+	if amount > acc.Balance() {
+		return fmt.Errorf(""insufficient funds: attempt to subtract %v from the balance of %s"",
+			amount, acc.Address())
 	}
-	return AsConcreteAccount(account).Account()
+	acc.data.Balance -= amount
+	return nil
 }
 
-// Returns a MutableAccount by copying from account
-func AsMutableAccount(account Account) MutableAccount {
-	if account == nil {
-		return nil
+func (acc *Account) AddToBalance(amount uint64) error {
+	if binary.IsUint64SumOverflow(acc.Balance(), amount) {
+		return fmt.Errorf(""uint64 overflow: attempt to add %v to the balance of %s"",
+			amount, acc.Address())
 	}
-	return AsConcreteAccount(account).MutableAccount()
-}
-
-//----------------------------------------------
-// concreteAccount Wrapper
-
-// concreteAccountWrapper wraps ConcreteAccount to provide a immutable read-only view
-// via its implementation of Account and a mutable implementation via its implementation of
-// MutableAccount
-type concreteAccountWrapper struct {
-	*ConcreteAccount `json:""unwrap""`
-}
-
-var _ Account = concreteAccountWrapper{}
-
-func (caw concreteAccountWrapper) Address() crypto.Address {
-	return caw.ConcreteAccount.Address
+	acc.data.Balance += amount
+	return nil
 }
 
-func (caw concreteAccountWrapper) PublicKey() crypto.PublicKey {
-	return caw.ConcreteAccount.PublicKey
+func (acc *Account) SetCode(code []byte) error {
+	acc.data.Code = code
+	return nil
 }
 
-func (caw concreteAccountWrapper) Balance() uint64 {
-	return caw.ConcreteAccount.Balance
+func (acc *Account) IncSequence() {
+	acc.data.Sequence++
 }
 
-func (caw concreteAccountWrapper) Code() Bytecode {
-	return caw.ConcreteAccount.Code
+func (acc *Account) SetStorageRoot(storageRoot []byte) error {
+	acc.data.StorageRoot = storageRoot
+	return nil
 }
 
-func (caw concreteAccountWrapper) Sequence() uint64 {
-	return caw.ConcreteAccount.Sequence
+func (acc *Account) SetPermissions(permissions ptypes.AccountPermissions) error {
+	acc.data.Permissions = permissions
+	return nil
 }
 
-func (caw concreteAccountWrapper) StorageRoot() []byte {
-	return caw.ConcreteAccount.StorageRoot
+func (acc *Account) MutablePermissions() *ptypes.AccountPermissions {
+	return &acc.data.Permissions
 }
 
-func (caw concreteAccountWrapper) Permissions() ptypes.AccountPermissions {
-	return caw.ConcreteAccount.Permissions
-}
-
-func (caw concreteAccountWrapper) Encode() ([]byte, error) {
-	return caw.ConcreteAccount.Encode()
-}
-
-func (caw concreteAccountWrapper) String() string {
-	return caw.ConcreteAccount.String()
-}
-
-func (caw concreteAccountWrapper) MarshalJSON() ([]byte, error) {
-	return json.Marshal(caw.ConcreteAccount)
-}
-
-// Account mutation via MutableAccount interface
-var _ MutableAccount = concreteAccountWrapper{}
-
-func (caw concreteAccountWrapper) SetPublicKey(pubKey crypto.PublicKey) MutableAccount {
-	caw.ConcreteAccount.PublicKey = pubKey
-	addressFromPubKey := pubKey.Address()
-	// We don't want the wrong public key to take control of an account so we panic here
-	if caw.ConcreteAccount.Address != addressFromPubKey {
-		panic(fmt.Errorf(""attempt to set public key of account %s to %v, ""+
-			""but that public key has address %s"",
-			caw.ConcreteAccount.Address, pubKey, addressFromPubKey))
+///---- Serialisation methods
+//----------------------------------------------
+func (acc Account) validate() bool {
+	if len(acc.data.PublicKey.PublicKey) > 0 {
+		/// Only contracts have Bytecode
+		if len(acc.data.Code) > 0 {
+			return false
+		}
+
+		if acc.data.Address != acc.data.PublicKey.Address() {
+			return false
+		}
 	}
-	return caw
-}
 
-func (caw concreteAccountWrapper) SubtractFromBalance(amount uint64) (MutableAccount, error) {
-	if amount > caw.Balance() {
-		return nil, fmt.Errorf(""insufficient funds: attempt to subtract %v from the balance of %s"",
-			amount, caw.ConcreteAccount)
-	}
-	caw.ConcreteAccount.Balance -= amount
-	return caw, nil
+	return true
 }
 
-func (caw concreteAccountWrapper) AddToBalance(amount uint64) (MutableAccount, error) {
-	if binary.IsUint64SumOverflow(caw.Balance(), amount) {
-		return nil, fmt.Errorf(""uint64 overflow: attempt to add %v to the balance of %s"",
-			amount, caw.ConcreteAccount)
+func (acc Account) Encode() ([]byte, error) {
+	if acc.validate() == false {
+		return nil, fmt.Errorf(""Invalid account "")
 	}
-	caw.ConcreteAccount.Balance += amount
-	return caw, nil
-}
-
-func (caw concreteAccountWrapper) SetCode(code []byte) MutableAccount {
-	caw.ConcreteAccount.Code = code
-	return caw
-}
-
-func (caw concreteAccountWrapper) IncSequence() MutableAccount {
-	caw.ConcreteAccount.Sequence += 1
-	return caw
-}
-
-func (caw concreteAccountWrapper) SetStorageRoot(storageRoot []byte) MutableAccount {
-	caw.ConcreteAccount.StorageRoot = storageRoot
-	return caw
-}
-
-func (caw concreteAccountWrapper) SetPermissions(permissions ptypes.AccountPermissions) MutableAccount {
-	caw.ConcreteAccount.Permissions = permissions
-	return caw
-}
 
-func (caw concreteAccountWrapper) MutablePermissions() *ptypes.AccountPermissions {
-	return &caw.ConcreteAccount.Permissions
-}
+	buf := new(bytes.Buffer)
+	var n int
+	var err error
+	wire.WriteBinary(acc.data, buf, &n, &err)
+	if err != nil {
+		return nil, err
+	}
+	return buf.Bytes(), nil
 
-func (caw concreteAccountWrapper) Copy() MutableAccount {
-	return concreteAccountWrapper{caw.ConcreteAccount.Copy()}
 }
 
-var _ = wire.RegisterInterface(struct{ Account }{}, wire.ConcreteType{concreteAccountWrapper{}, 0x01})
-
-// concreteAccount Wrapper
-//----------------------------------------------
-// Encoding/decoding
-
-func Decode(accBytes []byte) (Account, error) {
-	ca, err := DecodeConcrete(accBytes)
+func Decode(bytes []byte) (*Account, error) {
+	var account Account
+	err := wire.ReadBinaryBytes(bytes, &account.data)
 	if err != nil {
-		return nil, err
+		return nil, fmt.Errorf(""could not convert decoded account: %v"", err)
 	}
-	return ca.Account(), nil
+	return &account, nil
 }
 
-func DecodeConcrete(accBytes []byte) (*ConcreteAccount, error) {
-	ca := new(concreteAccountWrapper)
-	err := wire.ReadBinaryBytes(accBytes, ca)
+func (acc Account) MarshalJSON() ([]byte, error) {
+	if acc.validate() == false {
+		return nil, fmt.Errorf(""Invalid account "")
+	}
+
+	return json.Marshal(acc.data)",,2018-06-14 03:55:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/195029787,https://github.com/hyperledger/burrow/pull/800#discussion_r195029787,silasdavis
https://github.com/hyperledger/burrow/pull/782,https://github.com/hyperledger/burrow/pull/782,feel like this should be a bit longer. `allow-bad-perm` or `ignore-perms` or something like that,f922ab621997227783a22595fdc66a1cd33f1998,2018-06-04 18:25:26,192836808,"@@ -46,9 +48,26 @@ func Keys(output Output) func(cmd *cli.Cmd) {
 
 		cmd.Command(""server"", ""run keys server"", func(cmd *cli.Cmd) {
 			keysDir := cmd.StringOpt(""dir"", keys.DefaultKeysDir, ""specify the location of the directory containing key files"")
+			badPerm := cmd.BoolOpt(""allow"", false, ""Allow unix key file permissions to be readable other than user"")",,2018-06-05 09:19:03,https://api.github.com/repos/hyperledger/burrow/pulls/comments/192836808,https://github.com/hyperledger/burrow/pull/782#discussion_r192836808,silasdavis
https://github.com/hyperledger/burrow/pull/782,https://github.com/hyperledger/burrow/pull/782,"This would be applicable for a `Scope` too but needs `ComponentKey` primarily. So could we have:

```go
logger: logger.With(structure.ComponentKey, ""keys"").WithScope(""NewKeyStore"")
```

Also let's make this initialisation multiline",f922ab621997227783a22595fdc66a1cd33f1998,2018-06-04 18:27:51,192837571,"@@ -99,9 +100,15 @@ func IsValidKeyJson(j []byte) []byte {
 	return nil
 }
 
+func NewKeyStore(dir string, AllowBadFilePermissions bool, logger *logging.Logger) KeyStore {
+	return KeyStore{keysDirPath: dir, AllowBadFilePermissions: AllowBadFilePermissions, logger: logger.WithScope(""KeyStore"")}",,2018-06-05 09:19:03,https://api.github.com/repos/hyperledger/burrow/pulls/comments/192837571,https://github.com/hyperledger/burrow/pull/782#discussion_r192837571,silasdavis
https://github.com/hyperledger/burrow/pull/782,https://github.com/hyperledger/burrow/pull/782,"Oh let's also `os.RemoveAll(testDir)` at beginning of test, ala: https://github.com/hyperledger/burrow/blob/develop/core/integration/test_wrapper.go#L54-L56 so it doesn't build up",f922ab621997227783a22595fdc66a1cd33f1998,2018-06-04 19:20:26,192852292,"@@ -37,7 +38,7 @@ var (
 func init() {
 	failedCh := make(chan error)
 	go func() {
-		err := StartStandAloneServer(DefaultKeysDir, DefaultHost, TestPort)
+		err := StartStandAloneServer(""test_scratch/""+DefaultKeysDir, DefaultHost, TestPort, false, logging.NewNoopLogger())",,2018-06-05 09:19:03,https://api.github.com/repos/hyperledger/burrow/pulls/comments/192852292,https://github.com/hyperledger/burrow/pull/782#discussion_r192852292,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,I think you'll need to include the Apache 2.0 license - ideally stick with it,5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-29 13:19:08,191419580,"@@ -1,176 +1,21 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      ""License"" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      ""Licensor"" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      ""Legal Entity"" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      ""control"" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      ""You"" (or ""Your"") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      ""Source"" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      ""Object"" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      ""Work"" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      ""Derivative Works"" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      ""Contribution"" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, ""submitted""
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as ""Not a Contribution.""
-
-      ""Contributor"" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or",94,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191419580,https://github.com/hyperledger/burrow/pull/780#discussion_r191419580,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"This enables a builder style syntax. Obviously a matter of taste, but better not to make inconsequential changes like this.",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-29 13:20:33,191420033,"@@ -75,23 +75,25 @@ type Account interface {
 type MutableAccount interface {
 	Account
 	// Set public key (needed for lazy initialisation), should also set the dependent address
-	SetPublicKey(pubKey PublicKey) MutableAccount
+	SetPublicKey(pubKey PublicKey)
 	// Subtract amount from account balance (will panic if amount is greater than balance)
-	SubtractFromBalance(amount uint64) (MutableAccount, error)
+	SubtractFromBalance(amount uint64) error
 	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
-	AddToBalance(amount uint64) (MutableAccount, error)
+	AddToBalance(amount uint64) error
 	// Set EVM byte code associated with account
-	SetCode(code []byte) MutableAccount
+	SetCode(code []byte)
 	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
-	IncSequence() MutableAccount",16,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191420033,https://github.com/hyperledger/burrow/pull/780#discussion_r191420033,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,`concreteAccountWrapper` already just holds a reference - what is the reason for giving all these methods a pointer receiver?,5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-29 13:23:27,191420959,"@@ -271,9 +273,9 @@ func (caw concreteAccountWrapper) MarshalJSON() ([]byte, error) {
 }
 
 // Account mutation via MutableAccount interface
-var _ MutableAccount = concreteAccountWrapper{}
+var _ MutableAccount = &concreteAccountWrapper{}
 
-func (caw concreteAccountWrapper) SetPublicKey(pubKey PublicKey) MutableAccount {
+func (caw *concreteAccountWrapper) SetPublicKey(pubKey PublicKey) {",50,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191420959,https://github.com/hyperledger/burrow/pull/780#discussion_r191420959,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,I'm not that keen on this stringly typed way of encoding/decoding. Let's just define a struct that is a model of serialisation and call `json.Marshal` on that. Often we can use the same model of serialisation as model we use in-memory but if we can't I'd say just define one up front that clearly does the same thing on serialisation and deserialisation,5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-29 13:28:00,191422611,"@@ -1,93 +1,187 @@
+// MIT License
+//
+// Copyright (c) 2018 Finterra
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the ""Software""), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+//
+
 package account
 
 import (
+	""encoding/hex""
 	""encoding/json""
+	""fmt""
+	""strconv""
 )
 
 type Validator interface {
 	Addressable
-	// The validator's voting power
-	Power() uint64
-	// Alter the validator's voting power by amount that can be negative or positive.
-	// A power of 0 effectively unbonds the validator
-	WithNewPower(uint64) Validator
-}
 
-// Neither abci_types or tm_types has quite the representation we want
-type ConcreteValidator struct {
-	Address   Address
-	PublicKey PublicKey
-	Power     uint64
+	Power() int64
+	Stake() uint64
+	Sequence() uint64
+	BondingHeight() uint64
+
+	MinimumStakeToUnbond() uint64
+
+	Bytes() ([]byte, error)
+	String() string
 }
 
-type concreteValidatorWrapper struct {
-	*ConcreteValidator `json:""unwrap""`
+type MutableValidator interface {
+	Validator
+
+	AddStake(stake uint64)
+	SubtractStake(stake uint64)
+	IncSequence()
 }
 
-var _ Validator = concreteValidatorWrapper{}
+type validator struct {
+	publicKey     PublicKey
+	stake         uint64
+	bondingHeight uint64
+	sequence      uint64
+}
 
-func AsValidator(account Account) Validator {
-	return ConcreteValidator{
-		Address:   account.Address(),
-		PublicKey: account.PublicKey(),
-		Power:     account.Balance(),
-	}.Validator()
+func NewValidator(publicKey PublicKey, stake, bondingHeight uint64) Validator {
+	return validator{
+		publicKey:     publicKey,
+		stake:         stake,
+		bondingHeight: bondingHeight,
+		sequence:      0,
+	}
 }
 
-func AsConcreteValidator(validator Validator) *ConcreteValidator {
-	if validator == nil {
+func LoadValidator(bytes []byte) Validator {
+	u := map[string]string{}",,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191422611,https://github.com/hyperledger/burrow/pull/780#discussion_r191422611,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,Having said that the approach with a wrapper (providing the interface) and a concrete type providing the serialisation has it's downsides so I am open to alternatives ,5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-29 13:29:50,191423232,"@@ -1,93 +1,187 @@
+// MIT License
+//
+// Copyright (c) 2018 Finterra
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the ""Software""), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+//
+
 package account
 
 import (
+	""encoding/hex""
 	""encoding/json""
+	""fmt""
+	""strconv""
 )
 
 type Validator interface {
 	Addressable
-	// The validator's voting power
-	Power() uint64
-	// Alter the validator's voting power by amount that can be negative or positive.
-	// A power of 0 effectively unbonds the validator
-	WithNewPower(uint64) Validator
-}
 
-// Neither abci_types or tm_types has quite the representation we want
-type ConcreteValidator struct {
-	Address   Address
-	PublicKey PublicKey
-	Power     uint64
+	Power() int64
+	Stake() uint64
+	Sequence() uint64
+	BondingHeight() uint64
+
+	MinimumStakeToUnbond() uint64
+
+	Bytes() ([]byte, error)
+	String() string
 }
 
-type concreteValidatorWrapper struct {
-	*ConcreteValidator `json:""unwrap""`
+type MutableValidator interface {
+	Validator
+
+	AddStake(stake uint64)
+	SubtractStake(stake uint64)
+	IncSequence()
 }
 
-var _ Validator = concreteValidatorWrapper{}
+type validator struct {
+	publicKey     PublicKey
+	stake         uint64
+	bondingHeight uint64
+	sequence      uint64
+}
 
-func AsValidator(account Account) Validator {
-	return ConcreteValidator{
-		Address:   account.Address(),
-		PublicKey: account.PublicKey(),
-		Power:     account.Balance(),
-	}.Validator()
+func NewValidator(publicKey PublicKey, stake, bondingHeight uint64) Validator {
+	return validator{
+		publicKey:     publicKey,
+		stake:         stake,
+		bondingHeight: bondingHeight,
+		sequence:      0,
+	}
 }
 
-func AsConcreteValidator(validator Validator) *ConcreteValidator {
-	if validator == nil {
+func LoadValidator(bytes []byte) Validator {
+	u := map[string]string{}",,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191423232,https://github.com/hyperledger/burrow/pull/780#discussion_r191423232,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,yep makes more sense,5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-29 13:31:07,191423649,"@@ -78,29 +83,25 @@ type tip struct {
 	lastBlockTime         time.Time
 	lastBlockHash         []byte
 	appHashAfterLastBlock []byte
+
+	validatorSet ValidatorSet",37,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191423649,https://github.com/hyperledger/burrow/pull/780#discussion_r191423649,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"Yep as before I don't like this serialisation style much. I think the solution of explicitly defining the `PersistedState` is better, would rather that was reinstated.",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-29 13:32:15,191424018,"@@ -184,10 +204,27 @@ func (bc *blockchain) CommitBlock(blockTime time.Time, blockHash, appHash []byte
 
 func (bc *blockchain) save() error {
 	if bc.db != nil {
-		encodedState, err := bc.Encode()
+		genesisJSON, err := bc.genesisDoc.JSONBytes()
+		if err != nil {
+			return err
+		}
+
+		validatorSetJSON, err := bc.validatorSet.JSONBytes()
+		if err != nil {
+			return err
+		}
+
+		u := map[string]string{}",162,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191424018,https://github.com/hyperledger/burrow/pull/780#discussion_r191424018,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"I suggest `Join`, `Leave`, and `Contains` are better more idiomatic names",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-29 13:34:07,191424690,"@@ -0,0 +1,273 @@
+package blockchain
+
+import (
+	""bytes""
+	""encoding/json""
+	""fmt""
+	""math""
+	""sort""
+	""strconv""
+
+	acm ""github.com/hyperledger/burrow/account""
+	rpc_core ""github.com/tendermint/tendermint/rpc/core""
+	ctypes ""github.com/tendermint/tendermint/rpc/core/types""
+	tm_types ""github.com/tendermint/tendermint/types""
+)
+
+type ValidatorSet interface {
+	TotalPower() int
+	SetMaximumPower(maximumPower int)
+	MaximumPower() int
+	AdjustPower(height int64) error
+	Validators() []acm.Validator
+	SetLeavers() []acm.Validator
+	JoinToTheSet(validator acm.Validator) error
+	LeaveFromTheSet(validator acm.Validator) error
+	IsValidatorInSet(address acm.Address) bool",26,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191424690,https://github.com/hyperledger/burrow/pull/780#discussion_r191424690,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"This looks like a stub, but would prefer constants for the magic numbers at least",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-29 13:34:49,191424908,"@@ -0,0 +1,273 @@
+package blockchain
+
+import (
+	""bytes""
+	""encoding/json""
+	""fmt""
+	""math""
+	""sort""
+	""strconv""
+
+	acm ""github.com/hyperledger/burrow/account""
+	rpc_core ""github.com/tendermint/tendermint/rpc/core""
+	ctypes ""github.com/tendermint/tendermint/rpc/core/types""
+	tm_types ""github.com/tendermint/tendermint/types""
+)
+
+type ValidatorSet interface {
+	TotalPower() int
+	SetMaximumPower(maximumPower int)
+	MaximumPower() int
+	AdjustPower(height int64) error
+	Validators() []acm.Validator
+	SetLeavers() []acm.Validator
+	JoinToTheSet(validator acm.Validator) error
+	LeaveFromTheSet(validator acm.Validator) error
+	IsValidatorInSet(address acm.Address) bool
+	JSONBytes() ([]byte, error)
+}
+
+type validatorListProxy interface {
+	Validators(height int64) (*ctypes.ResultValidators, error)
+}
+
+type _validatorListProxy struct{}
+
+func (vlp _validatorListProxy) Validators(height int64) (*ctypes.ResultValidators, error) {
+	result, err := rpc_core.Validators(&height)
+	if err != nil {
+		return nil, err
+	}
+	return result, nil
+}
+
+type validatorSet struct {
+	maximumPower int
+	validators   []acm.Validator
+	setLeavers   []acm.Validator
+	proxy        validatorListProxy
+}
+
+func newValidatorSet(maximumPower int, validators []acm.Validator) *validatorSet {
+	set := &validatorSet{
+		validators: validators,
+		proxy:      _validatorListProxy{},
+	}
+	set.SetMaximumPower(maximumPower)
+	return set
+}
+
+func (vs *validatorSet) TotalPower() int {
+	return len(vs.validators)
+}
+
+func (vs *validatorSet) SetMaximumPower(maximumPower int) {
+	if maximumPower > 90 {
+		maximumPower = 90",66,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191424908,https://github.com/hyperledger/burrow/pull/780#discussion_r191424908,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"This function could do with some explanatory comments. In particular you are preventing (modulo my comment on the formula below) more than 1/3 `maximumPower` from leaving at a time. I may not be following the entire flow, but I feel like we need to prevent more than 1/3 `vs.TotalPower()` from changing at a time in order to preserve light client functionality. ",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-29 13:42:14,191427617,"@@ -0,0 +1,273 @@
+package blockchain
+
+import (
+	""bytes""
+	""encoding/json""
+	""fmt""
+	""math""
+	""sort""
+	""strconv""
+
+	acm ""github.com/hyperledger/burrow/account""
+	rpc_core ""github.com/tendermint/tendermint/rpc/core""
+	ctypes ""github.com/tendermint/tendermint/rpc/core/types""
+	tm_types ""github.com/tendermint/tendermint/types""
+)
+
+type ValidatorSet interface {
+	TotalPower() int
+	SetMaximumPower(maximumPower int)
+	MaximumPower() int
+	AdjustPower(height int64) error
+	Validators() []acm.Validator
+	SetLeavers() []acm.Validator
+	JoinToTheSet(validator acm.Validator) error
+	LeaveFromTheSet(validator acm.Validator) error
+	IsValidatorInSet(address acm.Address) bool
+	JSONBytes() ([]byte, error)
+}
+
+type validatorListProxy interface {
+	Validators(height int64) (*ctypes.ResultValidators, error)
+}
+
+type _validatorListProxy struct{}
+
+func (vlp _validatorListProxy) Validators(height int64) (*ctypes.ResultValidators, error) {
+	result, err := rpc_core.Validators(&height)
+	if err != nil {
+		return nil, err
+	}
+	return result, nil
+}
+
+type validatorSet struct {
+	maximumPower int
+	validators   []acm.Validator
+	setLeavers   []acm.Validator
+	proxy        validatorListProxy
+}
+
+func newValidatorSet(maximumPower int, validators []acm.Validator) *validatorSet {
+	set := &validatorSet{
+		validators: validators,
+		proxy:      _validatorListProxy{},
+	}
+	set.SetMaximumPower(maximumPower)
+	return set
+}
+
+func (vs *validatorSet) TotalPower() int {
+	return len(vs.validators)
+}
+
+func (vs *validatorSet) SetMaximumPower(maximumPower int) {
+	if maximumPower > 90 {
+		maximumPower = 90
+	}
+
+	if maximumPower < 4 {
+		maximumPower = 4
+	}
+
+	vs.maximumPower = maximumPower
+}
+
+func (vs *validatorSet) MaximumPower() int {
+	return vs.maximumPower
+}
+
+func (vs *validatorSet) AdjustPower(height int64) error {",80,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191427617,https://github.com/hyperledger/burrow/pull/780#discussion_r191427617,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"Currently this line is not doing any float arithmetic, you mean `limit := int(math.Floor(float64(vs.maximumPower)/3)) - 1` but that itself can be simplified to just: `limit := vs.MaximumPower/3 - 1`, and it should be since in float arithmetic is not always deterministic (and the integer version is faster and cleaner).

However I am not convinced this is the value you mean, I think you want `limit := int(math.Ceil(float64(vs.maximumPower)/3)) - 1` since you want to limit `dif` to strictly less than 1/3 of maximum power (I think). So for example 10/3 = 3.33... so 3 is acceptable (< 1/3), whereas your formula would set it to 2 (floor(3.33) -1). Taking the ceiling would give for max power 10: ceil(10/3) - 1 = 3, for max power 9: ceil(9/3) -1 = 2 (which is what we want for strictly less than.

You can/should also compute the ceiling with pure integer arithemtic with `limit := (vs.maximumPower + 2)/3` (the general integer formula is ceil(float64(n)/float64(d)) == (n + d - 1)/d for integers n,d (disregarding overflow))",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-29 14:16:37,191441164,"@@ -0,0 +1,273 @@
+package blockchain
+
+import (
+	""bytes""
+	""encoding/json""
+	""fmt""
+	""math""
+	""sort""
+	""strconv""
+
+	acm ""github.com/hyperledger/burrow/account""
+	rpc_core ""github.com/tendermint/tendermint/rpc/core""
+	ctypes ""github.com/tendermint/tendermint/rpc/core/types""
+	tm_types ""github.com/tendermint/tendermint/types""
+)
+
+type ValidatorSet interface {
+	TotalPower() int
+	SetMaximumPower(maximumPower int)
+	MaximumPower() int
+	AdjustPower(height int64) error
+	Validators() []acm.Validator
+	SetLeavers() []acm.Validator
+	JoinToTheSet(validator acm.Validator) error
+	LeaveFromTheSet(validator acm.Validator) error
+	IsValidatorInSet(address acm.Address) bool
+	JSONBytes() ([]byte, error)
+}
+
+type validatorListProxy interface {
+	Validators(height int64) (*ctypes.ResultValidators, error)
+}
+
+type _validatorListProxy struct{}
+
+func (vlp _validatorListProxy) Validators(height int64) (*ctypes.ResultValidators, error) {
+	result, err := rpc_core.Validators(&height)
+	if err != nil {
+		return nil, err
+	}
+	return result, nil
+}
+
+type validatorSet struct {
+	maximumPower int
+	validators   []acm.Validator
+	setLeavers   []acm.Validator
+	proxy        validatorListProxy
+}
+
+func newValidatorSet(maximumPower int, validators []acm.Validator) *validatorSet {
+	set := &validatorSet{
+		validators: validators,
+		proxy:      _validatorListProxy{},
+	}
+	set.SetMaximumPower(maximumPower)
+	return set
+}
+
+func (vs *validatorSet) TotalPower() int {
+	return len(vs.validators)
+}
+
+func (vs *validatorSet) SetMaximumPower(maximumPower int) {
+	if maximumPower > 90 {
+		maximumPower = 90
+	}
+
+	if maximumPower < 4 {
+		maximumPower = 4
+	}
+
+	vs.maximumPower = maximumPower
+}
+
+func (vs *validatorSet) MaximumPower() int {
+	return vs.maximumPower
+}
+
+func (vs *validatorSet) AdjustPower(height int64) error {
+	/// empty slice
+	vs.setLeavers = vs.setLeavers[:0]
+
+	dif := vs.TotalPower() - vs.maximumPower
+	if dif <= 0 {
+		return nil
+	}
+
+	limit := int(math.Floor(float64(vs.maximumPower*1/3))) - 1",89,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191441164,https://github.com/hyperledger/burrow/pull/780#discussion_r191441164,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,Is this working around the fact we don't have a clean way to get the current validator set from ABCI? This is dubious and probably induces a race conditions. We really need to work against a set of validators and a particular commit height and have all of this happen while we hold the commit lock.,5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-29 14:29:13,191446259,"@@ -0,0 +1,273 @@
+package blockchain
+
+import (
+	""bytes""
+	""encoding/json""
+	""fmt""
+	""math""
+	""sort""
+	""strconv""
+
+	acm ""github.com/hyperledger/burrow/account""
+	rpc_core ""github.com/tendermint/tendermint/rpc/core""
+	ctypes ""github.com/tendermint/tendermint/rpc/core/types""
+	tm_types ""github.com/tendermint/tendermint/types""
+)
+
+type ValidatorSet interface {
+	TotalPower() int
+	SetMaximumPower(maximumPower int)
+	MaximumPower() int
+	AdjustPower(height int64) error
+	Validators() []acm.Validator
+	SetLeavers() []acm.Validator
+	JoinToTheSet(validator acm.Validator) error
+	LeaveFromTheSet(validator acm.Validator) error
+	IsValidatorInSet(address acm.Address) bool
+	JSONBytes() ([]byte, error)
+}
+
+type validatorListProxy interface {
+	Validators(height int64) (*ctypes.ResultValidators, error)",31,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191446259,https://github.com/hyperledger/burrow/pull/780#discussion_r191446259,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,You are right. It was our mistake. I change the license to Apache 2.0.,5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 03:14:19,191632076,"@@ -1,176 +1,21 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      ""License"" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      ""Licensor"" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      ""Legal Entity"" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      ""control"" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      ""You"" (or ""Your"") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      ""Source"" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      ""Object"" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      ""Work"" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      ""Derivative Works"" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      ""Contribution"" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, ""submitted""
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as ""Not a Contribution.""
-
-      ""Contributor"" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or",94,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191632076,https://github.com/hyperledger/burrow/pull/780#discussion_r191632076,b00f
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"No need to return the modified struct (here `MutableAccount` object) when the methods are called by reference (pointer).
 
First of all, it increases the performance; because no need to copy the whole object any time a modification is required. It just changes the internal object. It makes object more encapsulated and robust. 
Also it has better code understanding, `MutableAccount` is the instance of account that can be modified. In the other hand the, the `Account` is just a read-only instance and no modifications is allowed. Any object which needs to modify Account should have `MutableAccount` instance. This policy make the code more safe.
By just returning the error code we can check if the operation have failed or not. No need to have copy of the object again.

Here is the rules that I am following to check if a method should be called by pointer or not:
* if a method doesn't change any struct field (`const` method), it calls without reference (pointer)
* if a method is not a `const` method (it changes the struct fields), it calls by reference (pointer).

```
func (s Struct)ImmutableMethod() err {
...
}

func (s* Struct)MutableMethod() err {
...
}
```",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 03:50:19,191635878,"@@ -75,23 +75,25 @@ type Account interface {
 type MutableAccount interface {
 	Account
 	// Set public key (needed for lazy initialisation), should also set the dependent address
-	SetPublicKey(pubKey PublicKey) MutableAccount
+	SetPublicKey(pubKey PublicKey)
 	// Subtract amount from account balance (will panic if amount is greater than balance)
-	SubtractFromBalance(amount uint64) (MutableAccount, error)
+	SubtractFromBalance(amount uint64) error
 	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
-	AddToBalance(amount uint64) (MutableAccount, error)
+	AddToBalance(amount uint64) error
 	// Set EVM byte code associated with account
-	SetCode(code []byte) MutableAccount
+	SetCode(code []byte)
 	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
-	IncSequence() MutableAccount",16,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191635878,https://github.com/hyperledger/burrow/pull/780#discussion_r191635878,b00f
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780," All methods in `Account` interface are calling without pointer,  however methods in `MutableAccount` interface are calling by pointer.
All methods in `MutableAccount` are changing a field in Account struct. ",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 03:54:20,191636253,"@@ -271,9 +273,9 @@ func (caw concreteAccountWrapper) MarshalJSON() ([]byte, error) {
 }
 
 // Account mutation via MutableAccount interface
-var _ MutableAccount = concreteAccountWrapper{}
+var _ MutableAccount = &concreteAccountWrapper{}
 
-func (caw concreteAccountWrapper) SetPublicKey(pubKey PublicKey) MutableAccount {
+func (caw *concreteAccountWrapper) SetPublicKey(pubKey PublicKey) {",50,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191636253,https://github.com/hyperledger/burrow/pull/780#discussion_r191636253,b00f
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,I am not that keen to define a structure just only for serializing/serializing. You know the `go` is a naive programming language and it's not written to make life easier! What we have is to choose between two pains!,5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 03:57:28,191636556,"@@ -1,93 +1,187 @@
+// MIT License
+//
+// Copyright (c) 2018 Finterra
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the ""Software""), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+//
+
 package account
 
 import (
+	""encoding/hex""
 	""encoding/json""
+	""fmt""
+	""strconv""
 )
 
 type Validator interface {
 	Addressable
-	// The validator's voting power
-	Power() uint64
-	// Alter the validator's voting power by amount that can be negative or positive.
-	// A power of 0 effectively unbonds the validator
-	WithNewPower(uint64) Validator
-}
 
-// Neither abci_types or tm_types has quite the representation we want
-type ConcreteValidator struct {
-	Address   Address
-	PublicKey PublicKey
-	Power     uint64
+	Power() int64
+	Stake() uint64
+	Sequence() uint64
+	BondingHeight() uint64
+
+	MinimumStakeToUnbond() uint64
+
+	Bytes() ([]byte, error)
+	String() string
 }
 
-type concreteValidatorWrapper struct {
-	*ConcreteValidator `json:""unwrap""`
+type MutableValidator interface {
+	Validator
+
+	AddStake(stake uint64)
+	SubtractStake(stake uint64)
+	IncSequence()
 }
 
-var _ Validator = concreteValidatorWrapper{}
+type validator struct {
+	publicKey     PublicKey
+	stake         uint64
+	bondingHeight uint64
+	sequence      uint64
+}
 
-func AsValidator(account Account) Validator {
-	return ConcreteValidator{
-		Address:   account.Address(),
-		PublicKey: account.PublicKey(),
-		Power:     account.Balance(),
-	}.Validator()
+func NewValidator(publicKey PublicKey, stake, bondingHeight uint64) Validator {
+	return validator{
+		publicKey:     publicKey,
+		stake:         stake,
+		bondingHeight: bondingHeight,
+		sequence:      0,
+	}
 }
 
-func AsConcreteValidator(validator Validator) *ConcreteValidator {
-	if validator == nil {
+func LoadValidator(bytes []byte) Validator {
+	u := map[string]string{}",,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191636556,https://github.com/hyperledger/burrow/pull/780#discussion_r191636556,b00f
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,Thanks,5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 03:59:38,191636784,"@@ -0,0 +1,273 @@
+package blockchain
+
+import (
+	""bytes""
+	""encoding/json""
+	""fmt""
+	""math""
+	""sort""
+	""strconv""
+
+	acm ""github.com/hyperledger/burrow/account""
+	rpc_core ""github.com/tendermint/tendermint/rpc/core""
+	ctypes ""github.com/tendermint/tendermint/rpc/core/types""
+	tm_types ""github.com/tendermint/tendermint/types""
+)
+
+type ValidatorSet interface {
+	TotalPower() int
+	SetMaximumPower(maximumPower int)
+	MaximumPower() int
+	AdjustPower(height int64) error
+	Validators() []acm.Validator
+	SetLeavers() []acm.Validator
+	JoinToTheSet(validator acm.Validator) error
+	LeaveFromTheSet(validator acm.Validator) error
+	IsValidatorInSet(address acm.Address) bool",26,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191636784,https://github.com/hyperledger/burrow/pull/780#discussion_r191636784,b00f
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"Thanks. What do you suggest for this cons variable? 
`MaxTendermintNodes` ?
",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 03:59:57,191636811,"@@ -0,0 +1,273 @@
+package blockchain
+
+import (
+	""bytes""
+	""encoding/json""
+	""fmt""
+	""math""
+	""sort""
+	""strconv""
+
+	acm ""github.com/hyperledger/burrow/account""
+	rpc_core ""github.com/tendermint/tendermint/rpc/core""
+	ctypes ""github.com/tendermint/tendermint/rpc/core/types""
+	tm_types ""github.com/tendermint/tendermint/types""
+)
+
+type ValidatorSet interface {
+	TotalPower() int
+	SetMaximumPower(maximumPower int)
+	MaximumPower() int
+	AdjustPower(height int64) error
+	Validators() []acm.Validator
+	SetLeavers() []acm.Validator
+	JoinToTheSet(validator acm.Validator) error
+	LeaveFromTheSet(validator acm.Validator) error
+	IsValidatorInSet(address acm.Address) bool
+	JSONBytes() ([]byte, error)
+}
+
+type validatorListProxy interface {
+	Validators(height int64) (*ctypes.ResultValidators, error)
+}
+
+type _validatorListProxy struct{}
+
+func (vlp _validatorListProxy) Validators(height int64) (*ctypes.ResultValidators, error) {
+	result, err := rpc_core.Validators(&height)
+	if err != nil {
+		return nil, err
+	}
+	return result, nil
+}
+
+type validatorSet struct {
+	maximumPower int
+	validators   []acm.Validator
+	setLeavers   []acm.Validator
+	proxy        validatorListProxy
+}
+
+func newValidatorSet(maximumPower int, validators []acm.Validator) *validatorSet {
+	set := &validatorSet{
+		validators: validators,
+		proxy:      _validatorListProxy{},
+	}
+	set.SetMaximumPower(maximumPower)
+	return set
+}
+
+func (vs *validatorSet) TotalPower() int {
+	return len(vs.validators)
+}
+
+func (vs *validatorSet) SetMaximumPower(maximumPower int) {
+	if maximumPower > 90 {
+		maximumPower = 90",66,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191636811,https://github.com/hyperledger/burrow/pull/780#discussion_r191636811,b00f
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"Let we discuss more about it. Maybe there is third way. `PersistedState` is used just for serializing/deserializing. We can back to `PersistedState`, but don't you think this bring more complexity to the code. ",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 04:07:19,191637452,"@@ -184,10 +204,27 @@ func (bc *blockchain) CommitBlock(blockTime time.Time, blockHash, appHash []byte
 
 func (bc *blockchain) save() error {
 	if bc.db != nil {
-		encodedState, err := bc.Encode()
+		genesisJSON, err := bc.genesisDoc.JSONBytes()
+		if err != nil {
+			return err
+		}
+
+		validatorSetJSON, err := bc.validatorSet.JSONBytes()
+		if err != nil {
+			return err
+		}
+
+		u := map[string]string{}",162,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191637452,https://github.com/hyperledger/burrow/pull/780#discussion_r191637452,b00f
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"You are right. I need to put more comments here. 
This algorithm is a little complicated and I tried to write it as simple as possible. If you look at the code, the main loop it's almost around 40 lines. The main idea behind this algorithm is comparing current validator set with previous sets. Any validator who is in the current set but not in the previous set(s) has joined recently. I try to sort arrays before comparing them, so it helps to compare arrays easier and faster (the performance is `O(n log(n))`)... 
However, this piece of the code is very important in order to keep blockchain alive. Any mistakes here will cause blockchain goes dead.
About 1/3, The chance of changing 1/3 of the nodes in each round is almost zero. To make a blockchain safe and fast enough we figured out that a number between 60 and 80 validators is the best for validator set. (maximum power should be something between 60~80)
Take 60 as an example, It's almost impossible that 20 nodes nominating themselves to enter to the validator set in one round. Almost impossible! Impossible is possible, so we always make sure to not change more than 2/3 of nodes in each round. 
How about any possible attack? It's possible. Let me explain it a little more here.

Consider the VRF method is working fine and the byzantine party have no control over it. (we need to consult with some cryptographers to make sure about its safety. I believe we can make it safe with including some cure parameters into the proof. I am not worried about this part.)
If the VRF itself is safe, the only way to attack the blokchain is generating so many random pair keys and try to find suitable values for sending sortition transaction.
I try to prevent this attack by two changes:
1- The seed for the VRF in each round is almost random and unpredictable; It's previous block hash.
2- There is a gap between first bonding transaction and first sortition transaction.

I figured out that in a live network it might not possible for a node to send a sortition transaction just for entering into the next validation set. It might not be seen by every node at coming round. This transaction should be valid for more than one round, But it can not be valid forever. My suggestion is that the sortition transaction can be valid for just 10 rounds (I am very keen for changing it).
This is the only way an attacker can attack the blockchain. They can start generating valid sortition transaction by using lots of random generated key pairs. Since this sortiton transaction is valid for 10 rounds they can attack the blockchain in between.
The protocol predicts this attack, and we prevented it very simply.
Before a node starts sending a sortition transaction, it should bond some amount. Sortition transaction can only send 10 rounds after bonding transaction. After bonding transaction the node can not send any sortiton for first 10 rounds.
",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 04:57:56,191642381,"@@ -0,0 +1,273 @@
+package blockchain
+
+import (
+	""bytes""
+	""encoding/json""
+	""fmt""
+	""math""
+	""sort""
+	""strconv""
+
+	acm ""github.com/hyperledger/burrow/account""
+	rpc_core ""github.com/tendermint/tendermint/rpc/core""
+	ctypes ""github.com/tendermint/tendermint/rpc/core/types""
+	tm_types ""github.com/tendermint/tendermint/types""
+)
+
+type ValidatorSet interface {
+	TotalPower() int
+	SetMaximumPower(maximumPower int)
+	MaximumPower() int
+	AdjustPower(height int64) error
+	Validators() []acm.Validator
+	SetLeavers() []acm.Validator
+	JoinToTheSet(validator acm.Validator) error
+	LeaveFromTheSet(validator acm.Validator) error
+	IsValidatorInSet(address acm.Address) bool
+	JSONBytes() ([]byte, error)
+}
+
+type validatorListProxy interface {
+	Validators(height int64) (*ctypes.ResultValidators, error)
+}
+
+type _validatorListProxy struct{}
+
+func (vlp _validatorListProxy) Validators(height int64) (*ctypes.ResultValidators, error) {
+	result, err := rpc_core.Validators(&height)
+	if err != nil {
+		return nil, err
+	}
+	return result, nil
+}
+
+type validatorSet struct {
+	maximumPower int
+	validators   []acm.Validator
+	setLeavers   []acm.Validator
+	proxy        validatorListProxy
+}
+
+func newValidatorSet(maximumPower int, validators []acm.Validator) *validatorSet {
+	set := &validatorSet{
+		validators: validators,
+		proxy:      _validatorListProxy{},
+	}
+	set.SetMaximumPower(maximumPower)
+	return set
+}
+
+func (vs *validatorSet) TotalPower() int {
+	return len(vs.validators)
+}
+
+func (vs *validatorSet) SetMaximumPower(maximumPower int) {
+	if maximumPower > 90 {
+		maximumPower = 90
+	}
+
+	if maximumPower < 4 {
+		maximumPower = 4
+	}
+
+	vs.maximumPower = maximumPower
+}
+
+func (vs *validatorSet) MaximumPower() int {
+	return vs.maximumPower
+}
+
+func (vs *validatorSet) AdjustPower(height int64) error {",80,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191642381,https://github.com/hyperledger/burrow/pull/780#discussion_r191642381,b00f
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,The `-1` is mine ;) I just make one node less. The minimum number of nodes in Tenderninst is 4 but in our system is 6. We can drop -1. It's not very important. ,5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 05:25:32,191645292,"@@ -0,0 +1,273 @@
+package blockchain
+
+import (
+	""bytes""
+	""encoding/json""
+	""fmt""
+	""math""
+	""sort""
+	""strconv""
+
+	acm ""github.com/hyperledger/burrow/account""
+	rpc_core ""github.com/tendermint/tendermint/rpc/core""
+	ctypes ""github.com/tendermint/tendermint/rpc/core/types""
+	tm_types ""github.com/tendermint/tendermint/types""
+)
+
+type ValidatorSet interface {
+	TotalPower() int
+	SetMaximumPower(maximumPower int)
+	MaximumPower() int
+	AdjustPower(height int64) error
+	Validators() []acm.Validator
+	SetLeavers() []acm.Validator
+	JoinToTheSet(validator acm.Validator) error
+	LeaveFromTheSet(validator acm.Validator) error
+	IsValidatorInSet(address acm.Address) bool
+	JSONBytes() ([]byte, error)
+}
+
+type validatorListProxy interface {
+	Validators(height int64) (*ctypes.ResultValidators, error)
+}
+
+type _validatorListProxy struct{}
+
+func (vlp _validatorListProxy) Validators(height int64) (*ctypes.ResultValidators, error) {
+	result, err := rpc_core.Validators(&height)
+	if err != nil {
+		return nil, err
+	}
+	return result, nil
+}
+
+type validatorSet struct {
+	maximumPower int
+	validators   []acm.Validator
+	setLeavers   []acm.Validator
+	proxy        validatorListProxy
+}
+
+func newValidatorSet(maximumPower int, validators []acm.Validator) *validatorSet {
+	set := &validatorSet{
+		validators: validators,
+		proxy:      _validatorListProxy{},
+	}
+	set.SetMaximumPower(maximumPower)
+	return set
+}
+
+func (vs *validatorSet) TotalPower() int {
+	return len(vs.validators)
+}
+
+func (vs *validatorSet) SetMaximumPower(maximumPower int) {
+	if maximumPower > 90 {
+		maximumPower = 90
+	}
+
+	if maximumPower < 4 {
+		maximumPower = 4
+	}
+
+	vs.maximumPower = maximumPower
+}
+
+func (vs *validatorSet) MaximumPower() int {
+	return vs.maximumPower
+}
+
+func (vs *validatorSet) AdjustPower(height int64) error {
+	/// empty slice
+	vs.setLeavers = vs.setLeavers[:0]
+
+	dif := vs.TotalPower() - vs.maximumPower
+	if dif <= 0 {
+		return nil
+	}
+
+	limit := int(math.Floor(float64(vs.maximumPower*1/3))) - 1",89,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191645292,https://github.com/hyperledger/burrow/pull/780#discussion_r191645292,b00f
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"For two reasons I defined the proxy interface here:
1- Writing test independently
2- In future we might change the way we get validator list. It may get directly from ABCI. 
",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 05:27:22,191645507,"@@ -0,0 +1,273 @@
+package blockchain
+
+import (
+	""bytes""
+	""encoding/json""
+	""fmt""
+	""math""
+	""sort""
+	""strconv""
+
+	acm ""github.com/hyperledger/burrow/account""
+	rpc_core ""github.com/tendermint/tendermint/rpc/core""
+	ctypes ""github.com/tendermint/tendermint/rpc/core/types""
+	tm_types ""github.com/tendermint/tendermint/types""
+)
+
+type ValidatorSet interface {
+	TotalPower() int
+	SetMaximumPower(maximumPower int)
+	MaximumPower() int
+	AdjustPower(height int64) error
+	Validators() []acm.Validator
+	SetLeavers() []acm.Validator
+	JoinToTheSet(validator acm.Validator) error
+	LeaveFromTheSet(validator acm.Validator) error
+	IsValidatorInSet(address acm.Address) bool
+	JSONBytes() ([]byte, error)
+}
+
+type validatorListProxy interface {
+	Validators(height int64) (*ctypes.ResultValidators, error)",31,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191645507,https://github.com/hyperledger/burrow/pull/780#discussion_r191645507,b00f
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,Great ,5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 09:29:17,191700455,"@@ -1,176 +1,21 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      ""License"" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      ""Licensor"" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      ""Legal Entity"" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      ""control"" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      ""You"" (or ""Your"") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      ""Source"" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      ""Object"" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      ""Work"" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      ""Derivative Works"" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      ""Contribution"" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, ""submitted""
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as ""Not a Contribution.""
-
-      ""Contributor"" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or",94,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191700455,https://github.com/hyperledger/burrow/pull/780#discussion_r191700455,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"> No need to return the modified struct (here MutableAccount object) when the methods are called by reference (pointer).

There is no strict 'need' but it allows a declarative builder syntax like:

```go
acc.IncSequence().AddToBalance(inputAmount).SubtractToBalance(outputAmount)
```
This is why the method returns the bash-in-place object. Now whether you like this builder syntax is a matter of taste. I happen to think it keeps some important operations on a single logically line and prevents accidentally interspersing operations that should be atomic with other calls (that may err for example).

More to the point though really is there is no reason to change this relating to your changes - so when we come to PR as a hope we can soon it either belongs in a separate PR (I know you didn't open this as PR of course :)! ) or should be reverted.

> First of all, it increases the performance; because no need to copy the whole object any time a modification is required. 

This is incorrect. It does not copy the object the return type is an interface which is a pointer type. The performance implications are therefore utterly negligible.

> It just changes the internal object. It makes object more encapsulated and robust.

All these methods just change the internal object. You'll have to explain why this makes them more encapsulated and robust - I don't see it.

> Also it has better code understanding, MutableAccount is the instance of account that can be modified. In the other hand the, the Account is just a read-only instance and no modifications is allowed. Any object which needs to modify Account should have MutableAccount instance. This policy make the code more safe.

This comment applies in its entirety to the current implementation - so I agree!

> By just returning the error code we can check if the operation have failed or not. No need to have copy of the object again.

You can still check the error code in the current implementation. As I have said there is not object copy.

> Here is the rules that I am following to check if a method should be called by pointer or not: [...]

This doesn't seem relevant to the comment at hand",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 09:40:18,191704014,"@@ -75,23 +75,25 @@ type Account interface {
 type MutableAccount interface {
 	Account
 	// Set public key (needed for lazy initialisation), should also set the dependent address
-	SetPublicKey(pubKey PublicKey) MutableAccount
+	SetPublicKey(pubKey PublicKey)
 	// Subtract amount from account balance (will panic if amount is greater than balance)
-	SubtractFromBalance(amount uint64) (MutableAccount, error)
+	SubtractFromBalance(amount uint64) error
 	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
-	AddToBalance(amount uint64) (MutableAccount, error)
+	AddToBalance(amount uint64) error
 	// Set EVM byte code associated with account
-	SetCode(code []byte) MutableAccount
+	SetCode(code []byte)
 	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
-	IncSequence() MutableAccount",16,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191704014,https://github.com/hyperledger/burrow/pull/780#discussion_r191704014,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"`concreteAccountWrapper` just contains a pointer:

```go
type concreteAccountWrapper struct {
	*ConcreteAccount `json:""unwrap""`
}
```
Your change just makes us hold a pointer to a pointer - which buys us nothing. 

This looks like a case of you pattern matching on mutability - but in this case that pattern is wrong. Of course it makes no difference whether we use a pointer or not here - but I prefer the current way and was there first, so let's keep it.",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 09:45:42,191705582,"@@ -271,9 +273,9 @@ func (caw concreteAccountWrapper) MarshalJSON() ([]byte, error) {
 }
 
 // Account mutation via MutableAccount interface
-var _ MutableAccount = concreteAccountWrapper{}
+var _ MutableAccount = &concreteAccountWrapper{}
 
-func (caw concreteAccountWrapper) SetPublicKey(pubKey PublicKey) MutableAccount {
+func (caw *concreteAccountWrapper) SetPublicKey(pubKey PublicKey) {",50,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191705582,https://github.com/hyperledger/burrow/pull/780#discussion_r191705582,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"Strongly disagree on this - I have had to maintain hand spun serialisation logic like this and it is a pain. It's too easy to change a string or change the order of some procedural statements - and crucially map order is *guaranteed* to be non-deterministic (Go randomises the iteration order) which in general we do not want if we are ever hashing serialised objects - which we often want to do.

It is much better to have a single declarative struct that defines how a stored object can be serialiased *and* deserialised in a single location - exported so that other packages are able to handle that serialised object should they need to. Not to mention the fact you can attach documentation to the struct.

Interspersing code with the busywork of serialising integers is a mess. Defining a struct 'just' for serialisation is a great use of a struct. Once again this is also a case of folliowing existing conventions in the codebase if you still don't find the above convincing.",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 09:51:08,191707093,"@@ -1,93 +1,187 @@
+// MIT License
+//
+// Copyright (c) 2018 Finterra
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the ""Software""), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+//
+
 package account
 
 import (
+	""encoding/hex""
 	""encoding/json""
+	""fmt""
+	""strconv""
 )
 
 type Validator interface {
 	Addressable
-	// The validator's voting power
-	Power() uint64
-	// Alter the validator's voting power by amount that can be negative or positive.
-	// A power of 0 effectively unbonds the validator
-	WithNewPower(uint64) Validator
-}
 
-// Neither abci_types or tm_types has quite the representation we want
-type ConcreteValidator struct {
-	Address   Address
-	PublicKey PublicKey
-	Power     uint64
+	Power() int64
+	Stake() uint64
+	Sequence() uint64
+	BondingHeight() uint64
+
+	MinimumStakeToUnbond() uint64
+
+	Bytes() ([]byte, error)
+	String() string
 }
 
-type concreteValidatorWrapper struct {
-	*ConcreteValidator `json:""unwrap""`
+type MutableValidator interface {
+	Validator
+
+	AddStake(stake uint64)
+	SubtractStake(stake uint64)
+	IncSequence()
 }
 
-var _ Validator = concreteValidatorWrapper{}
+type validator struct {
+	publicKey     PublicKey
+	stake         uint64
+	bondingHeight uint64
+	sequence      uint64
+}
 
-func AsValidator(account Account) Validator {
-	return ConcreteValidator{
-		Address:   account.Address(),
-		PublicKey: account.PublicKey(),
-		Power:     account.Balance(),
-	}.Validator()
+func NewValidator(publicKey PublicKey, stake, bondingHeight uint64) Validator {
+	return validator{
+		publicKey:     publicKey,
+		stake:         stake,
+		bondingHeight: bondingHeight,
+		sequence:      0,
+	}
 }
 
-func AsConcreteValidator(validator Validator) *ConcreteValidator {
-	if validator == nil {
+func LoadValidator(bytes []byte) Validator {
+	u := map[string]string{}",,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191707093,https://github.com/hyperledger/burrow/pull/780#discussion_r191707093,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"It is possible to use an in-line anonymous struct for serialisation which would contain it to the method - however this misses out centralising our 'model of serialisation'. I think the implicit model of serialisation defined separately from the model of deserialisation is more complex.

A third way might be to separate our 'models of serialisation' from our 'models of computation' - it sounds to me like this kind of containment/separation might be what you are after. I wouldn't be against having serialisation models moved to the bottom of file, a separate file, or maybe even a sub-package if there were more of them (or if they were used elsewhere). This is comparable to what you might do with protobuf generated structs (also models of serialisation).  For which matter we may transition to at some point - though we would still have the structs.",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 09:57:28,191708996,"@@ -184,10 +204,27 @@ func (bc *blockchain) CommitBlock(blockTime time.Time, blockHash, appHash []byte
 
 func (bc *blockchain) save() error {
 	if bc.db != nil {
-		encodedState, err := bc.Encode()
+		genesisJSON, err := bc.genesisDoc.JSONBytes()
+		if err != nil {
+			return err
+		}
+
+		validatorSetJSON, err := bc.validatorSet.JSONBytes()
+		if err != nil {
+			return err
+		}
+
+		u := map[string]string{}",162,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191708996,https://github.com/hyperledger/burrow/pull/780#discussion_r191708996,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,That's would be good since it reflects your 1 unit of power for each validator design.,5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 09:58:21,191709242,"@@ -0,0 +1,273 @@
+package blockchain
+
+import (
+	""bytes""
+	""encoding/json""
+	""fmt""
+	""math""
+	""sort""
+	""strconv""
+
+	acm ""github.com/hyperledger/burrow/account""
+	rpc_core ""github.com/tendermint/tendermint/rpc/core""
+	ctypes ""github.com/tendermint/tendermint/rpc/core/types""
+	tm_types ""github.com/tendermint/tendermint/types""
+)
+
+type ValidatorSet interface {
+	TotalPower() int
+	SetMaximumPower(maximumPower int)
+	MaximumPower() int
+	AdjustPower(height int64) error
+	Validators() []acm.Validator
+	SetLeavers() []acm.Validator
+	JoinToTheSet(validator acm.Validator) error
+	LeaveFromTheSet(validator acm.Validator) error
+	IsValidatorInSet(address acm.Address) bool
+	JSONBytes() ([]byte, error)
+}
+
+type validatorListProxy interface {
+	Validators(height int64) (*ctypes.ResultValidators, error)
+}
+
+type _validatorListProxy struct{}
+
+func (vlp _validatorListProxy) Validators(height int64) (*ctypes.ResultValidators, error) {
+	result, err := rpc_core.Validators(&height)
+	if err != nil {
+		return nil, err
+	}
+	return result, nil
+}
+
+type validatorSet struct {
+	maximumPower int
+	validators   []acm.Validator
+	setLeavers   []acm.Validator
+	proxy        validatorListProxy
+}
+
+func newValidatorSet(maximumPower int, validators []acm.Validator) *validatorSet {
+	set := &validatorSet{
+		validators: validators,
+		proxy:      _validatorListProxy{},
+	}
+	set.SetMaximumPower(maximumPower)
+	return set
+}
+
+func (vs *validatorSet) TotalPower() int {
+	return len(vs.validators)
+}
+
+func (vs *validatorSet) SetMaximumPower(maximumPower int) {
+	if maximumPower > 90 {
+		maximumPower = 90",66,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191709242,https://github.com/hyperledger/burrow/pull/780#discussion_r191709242,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"@seanyoung and I will be taking some time to study you design paper and look a this. 

I think you are right to identify what is effectively a stake grinding attack. This is how proof of stake protocols can degenerate into proof of work. The usual mitigation for this is to slow down the rate at which stake can move around, which is effectively what I think you are saying if that you have to stake to a key pair before you can know the block hash which would allow you to throw computation at finding a valid sortition address/key.

I like this approach you are taking - but I do think it needs a careful pencil and paper analysis by a computer scientist/cryptographer.",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 10:07:36,191712142,"@@ -0,0 +1,273 @@
+package blockchain
+
+import (
+	""bytes""
+	""encoding/json""
+	""fmt""
+	""math""
+	""sort""
+	""strconv""
+
+	acm ""github.com/hyperledger/burrow/account""
+	rpc_core ""github.com/tendermint/tendermint/rpc/core""
+	ctypes ""github.com/tendermint/tendermint/rpc/core/types""
+	tm_types ""github.com/tendermint/tendermint/types""
+)
+
+type ValidatorSet interface {
+	TotalPower() int
+	SetMaximumPower(maximumPower int)
+	MaximumPower() int
+	AdjustPower(height int64) error
+	Validators() []acm.Validator
+	SetLeavers() []acm.Validator
+	JoinToTheSet(validator acm.Validator) error
+	LeaveFromTheSet(validator acm.Validator) error
+	IsValidatorInSet(address acm.Address) bool
+	JSONBytes() ([]byte, error)
+}
+
+type validatorListProxy interface {
+	Validators(height int64) (*ctypes.ResultValidators, error)
+}
+
+type _validatorListProxy struct{}
+
+func (vlp _validatorListProxy) Validators(height int64) (*ctypes.ResultValidators, error) {
+	result, err := rpc_core.Validators(&height)
+	if err != nil {
+		return nil, err
+	}
+	return result, nil
+}
+
+type validatorSet struct {
+	maximumPower int
+	validators   []acm.Validator
+	setLeavers   []acm.Validator
+	proxy        validatorListProxy
+}
+
+func newValidatorSet(maximumPower int, validators []acm.Validator) *validatorSet {
+	set := &validatorSet{
+		validators: validators,
+		proxy:      _validatorListProxy{},
+	}
+	set.SetMaximumPower(maximumPower)
+	return set
+}
+
+func (vs *validatorSet) TotalPower() int {
+	return len(vs.validators)
+}
+
+func (vs *validatorSet) SetMaximumPower(maximumPower int) {
+	if maximumPower > 90 {
+		maximumPower = 90
+	}
+
+	if maximumPower < 4 {
+		maximumPower = 4
+	}
+
+	vs.maximumPower = maximumPower
+}
+
+func (vs *validatorSet) MaximumPower() int {
+	return vs.maximumPower
+}
+
+func (vs *validatorSet) AdjustPower(height int64) error {",80,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191712142,https://github.com/hyperledger/burrow/pull/780#discussion_r191712142,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"Note you still have an error in the code `float64(vs.maximumPower*1/3)` does nothing because `vs.maximumPower*1/3` has already be integer divided.

You should just use `vs.maxmimPower/3 - 1` - it's simpler, faster, and more correct.",5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 10:09:37,191712640,"@@ -0,0 +1,273 @@
+package blockchain
+
+import (
+	""bytes""
+	""encoding/json""
+	""fmt""
+	""math""
+	""sort""
+	""strconv""
+
+	acm ""github.com/hyperledger/burrow/account""
+	rpc_core ""github.com/tendermint/tendermint/rpc/core""
+	ctypes ""github.com/tendermint/tendermint/rpc/core/types""
+	tm_types ""github.com/tendermint/tendermint/types""
+)
+
+type ValidatorSet interface {
+	TotalPower() int
+	SetMaximumPower(maximumPower int)
+	MaximumPower() int
+	AdjustPower(height int64) error
+	Validators() []acm.Validator
+	SetLeavers() []acm.Validator
+	JoinToTheSet(validator acm.Validator) error
+	LeaveFromTheSet(validator acm.Validator) error
+	IsValidatorInSet(address acm.Address) bool
+	JSONBytes() ([]byte, error)
+}
+
+type validatorListProxy interface {
+	Validators(height int64) (*ctypes.ResultValidators, error)
+}
+
+type _validatorListProxy struct{}
+
+func (vlp _validatorListProxy) Validators(height int64) (*ctypes.ResultValidators, error) {
+	result, err := rpc_core.Validators(&height)
+	if err != nil {
+		return nil, err
+	}
+	return result, nil
+}
+
+type validatorSet struct {
+	maximumPower int
+	validators   []acm.Validator
+	setLeavers   []acm.Validator
+	proxy        validatorListProxy
+}
+
+func newValidatorSet(maximumPower int, validators []acm.Validator) *validatorSet {
+	set := &validatorSet{
+		validators: validators,
+		proxy:      _validatorListProxy{},
+	}
+	set.SetMaximumPower(maximumPower)
+	return set
+}
+
+func (vs *validatorSet) TotalPower() int {
+	return len(vs.validators)
+}
+
+func (vs *validatorSet) SetMaximumPower(maximumPower int) {
+	if maximumPower > 90 {
+		maximumPower = 90
+	}
+
+	if maximumPower < 4 {
+		maximumPower = 4
+	}
+
+	vs.maximumPower = maximumPower
+}
+
+func (vs *validatorSet) MaximumPower() int {
+	return vs.maximumPower
+}
+
+func (vs *validatorSet) AdjustPower(height int64) error {
+	/// empty slice
+	vs.setLeavers = vs.setLeavers[:0]
+
+	dif := vs.TotalPower() - vs.maximumPower
+	if dif <= 0 {
+		return nil
+	}
+
+	limit := int(math.Floor(float64(vs.maximumPower*1/3))) - 1",89,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191712640,https://github.com/hyperledger/burrow/pull/780#discussion_r191712640,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,Yep I just wanted to check that was the case - interface is a good idea but the current implementation through the RPC is problematic and will lead to a race condition - we should definitely be getting this through the ABCI in the future.,5535bb25b12d01e40380cfc0f865af9963edc802,2018-05-30 10:11:01,191712984,"@@ -0,0 +1,273 @@
+package blockchain
+
+import (
+	""bytes""
+	""encoding/json""
+	""fmt""
+	""math""
+	""sort""
+	""strconv""
+
+	acm ""github.com/hyperledger/burrow/account""
+	rpc_core ""github.com/tendermint/tendermint/rpc/core""
+	ctypes ""github.com/tendermint/tendermint/rpc/core/types""
+	tm_types ""github.com/tendermint/tendermint/types""
+)
+
+type ValidatorSet interface {
+	TotalPower() int
+	SetMaximumPower(maximumPower int)
+	MaximumPower() int
+	AdjustPower(height int64) error
+	Validators() []acm.Validator
+	SetLeavers() []acm.Validator
+	JoinToTheSet(validator acm.Validator) error
+	LeaveFromTheSet(validator acm.Validator) error
+	IsValidatorInSet(address acm.Address) bool
+	JSONBytes() ([]byte, error)
+}
+
+type validatorListProxy interface {
+	Validators(height int64) (*ctypes.ResultValidators, error)",31,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191712984,https://github.com/hyperledger/burrow/pull/780#discussion_r191712984,silasdavis
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"Serializing can be done without relying on Go functionality. We can make deterministic serilizable function, (it's our own implementation). 

There is no guarantee of go serializing to be deterministic. So we can have our own implementation. check here: https://stackoverflow.com/questions/44755089/does-serialized-content-strictly-follow-the-order-in-definition-use-encoding-jso",5535bb25b12d01e40380cfc0f865af9963edc802,2018-06-01 04:30:00,192295993,"@@ -1,93 +1,187 @@
+// MIT License
+//
+// Copyright (c) 2018 Finterra
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the ""Software""), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all
+// copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+//
+
 package account
 
 import (
+	""encoding/hex""
 	""encoding/json""
+	""fmt""
+	""strconv""
 )
 
 type Validator interface {
 	Addressable
-	// The validator's voting power
-	Power() uint64
-	// Alter the validator's voting power by amount that can be negative or positive.
-	// A power of 0 effectively unbonds the validator
-	WithNewPower(uint64) Validator
-}
 
-// Neither abci_types or tm_types has quite the representation we want
-type ConcreteValidator struct {
-	Address   Address
-	PublicKey PublicKey
-	Power     uint64
+	Power() int64
+	Stake() uint64
+	Sequence() uint64
+	BondingHeight() uint64
+
+	MinimumStakeToUnbond() uint64
+
+	Bytes() ([]byte, error)
+	String() string
 }
 
-type concreteValidatorWrapper struct {
-	*ConcreteValidator `json:""unwrap""`
+type MutableValidator interface {
+	Validator
+
+	AddStake(stake uint64)
+	SubtractStake(stake uint64)
+	IncSequence()
 }
 
-var _ Validator = concreteValidatorWrapper{}
+type validator struct {
+	publicKey     PublicKey
+	stake         uint64
+	bondingHeight uint64
+	sequence      uint64
+}
 
-func AsValidator(account Account) Validator {
-	return ConcreteValidator{
-		Address:   account.Address(),
-		PublicKey: account.PublicKey(),
-		Power:     account.Balance(),
-	}.Validator()
+func NewValidator(publicKey PublicKey, stake, bondingHeight uint64) Validator {
+	return validator{
+		publicKey:     publicKey,
+		stake:         stake,
+		bondingHeight: bondingHeight,
+		sequence:      0,
+	}
 }
 
-func AsConcreteValidator(validator Validator) *ConcreteValidator {
-	if validator == nil {
+func LoadValidator(bytes []byte) Validator {
+	u := map[string]string{}",,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/192295993,https://github.com/hyperledger/burrow/pull/780#discussion_r192295993,b00f
https://github.com/hyperledger/burrow/pull/780,https://github.com/hyperledger/burrow/pull/780,"I also used rpc_core for checking sortition transaction (in the execution). That part also should change. Thanks 
",5535bb25b12d01e40380cfc0f865af9963edc802,2018-06-01 04:32:18,192296162,"@@ -0,0 +1,273 @@
+package blockchain
+
+import (
+	""bytes""
+	""encoding/json""
+	""fmt""
+	""math""
+	""sort""
+	""strconv""
+
+	acm ""github.com/hyperledger/burrow/account""
+	rpc_core ""github.com/tendermint/tendermint/rpc/core""
+	ctypes ""github.com/tendermint/tendermint/rpc/core/types""
+	tm_types ""github.com/tendermint/tendermint/types""
+)
+
+type ValidatorSet interface {
+	TotalPower() int
+	SetMaximumPower(maximumPower int)
+	MaximumPower() int
+	AdjustPower(height int64) error
+	Validators() []acm.Validator
+	SetLeavers() []acm.Validator
+	JoinToTheSet(validator acm.Validator) error
+	LeaveFromTheSet(validator acm.Validator) error
+	IsValidatorInSet(address acm.Address) bool
+	JSONBytes() ([]byte, error)
+}
+
+type validatorListProxy interface {
+	Validators(height int64) (*ctypes.ResultValidators, error)",31,2018-06-01 14:29:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/192296162,https://github.com/hyperledger/burrow/pull/780#discussion_r192296162,b00f
https://github.com/hyperledger/burrow/pull/778,https://github.com/hyperledger/burrow/pull/778,"I'm starting to feel `Sync` was a poor choice of name - that said I'm not sure i can think of a better one. Perhaps a comment here would be a nice addition:
```go
// Copy any state updates from child call frame into current call frame
```",8bc7a686afb9645ce39374d714f45ed0387c8fb1,2018-05-24 11:29:57,190552561,"@@ -210,6 +210,8 @@ func (vm *VM) Call(caller, callee acm.MutableAccount, code, input []byte, value
 				return nil, fmt.Errorf(""error transferring value %v %s (callee) -> %s (caller)"",
 					value, callee, caller)
 			}
+		} else {
+			childCallState.Sync(callState)",,2018-05-24 18:44:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/190552561,https://github.com/hyperledger/burrow/pull/778#discussion_r190552561,silasdavis
https://github.com/hyperledger/burrow/pull/778,https://github.com/hyperledger/burrow/pull/778,This PR is not changing anything wrt to CREATE2,8bc7a686afb9645ce39374d714f45ed0387c8fb1,2018-05-24 11:42:26,190555565,"@@ -1145,16 +1150,17 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			if errAdd != nil {
 				return nil, firstErr(err, errAdd)
 			}
-			vm.stateWriter.UpdateAccount(receiver)
-			vm.stateWriter.RemoveAccount(callee.Address())
+			callState.UpdateAccount(receiver)
+			callState.RemoveAccount(callee.Address())
 			vm.Debugf("" => (%X) %v\n"", addr[:4], callee.Balance())
 			fallthrough
 
 		case STOP: // 0x00
 			return nil, nil
 
-		case STATICCALL, CREATE2:
+		case STATICCALL:",,2018-05-24 18:44:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/190555565,https://github.com/hyperledger/burrow/pull/778#discussion_r190555565,seanyoung
https://github.com/hyperledger/burrow/pull/778,https://github.com/hyperledger/burrow/pull/778,"leaving create2 causes a merge conflict; hence the ""case staticcall:""",8bc7a686afb9645ce39374d714f45ed0387c8fb1,2018-05-24 14:25:02,190606216,"@@ -1145,16 +1150,17 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			if errAdd != nil {
 				return nil, firstErr(err, errAdd)
 			}
-			vm.stateWriter.UpdateAccount(receiver)
-			vm.stateWriter.RemoveAccount(callee.Address())
+			callState.UpdateAccount(receiver)
+			callState.RemoveAccount(callee.Address())
 			vm.Debugf("" => (%X) %v\n"", addr[:4], callee.Balance())
 			fallthrough
 
 		case STOP: // 0x00
 			return nil, nil
 
-		case STATICCALL, CREATE2:
+		case STATICCALL:",,2018-05-24 18:44:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/190606216,https://github.com/hyperledger/burrow/pull/778#discussion_r190606216,smblucker
https://github.com/hyperledger/burrow/pull/778,https://github.com/hyperledger/burrow/pull/778,This might be because the branch you are merging from is not up to date with origin/develop. It might be better to rename the branch locally and recreate a new branch of develop and push that. I can do that for you if you like.,8bc7a686afb9645ce39374d714f45ed0387c8fb1,2018-05-24 15:46:07,190637358,"@@ -1145,16 +1150,17 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			if errAdd != nil {
 				return nil, firstErr(err, errAdd)
 			}
-			vm.stateWriter.UpdateAccount(receiver)
-			vm.stateWriter.RemoveAccount(callee.Address())
+			callState.UpdateAccount(receiver)
+			callState.RemoveAccount(callee.Address())
 			vm.Debugf("" => (%X) %v\n"", addr[:4], callee.Balance())
 			fallthrough
 
 		case STOP: // 0x00
 			return nil, nil
 
-		case STATICCALL, CREATE2:
+		case STATICCALL:",,2018-05-24 18:44:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/190637358,https://github.com/hyperledger/burrow/pull/778#discussion_r190637358,seanyoung
https://github.com/hyperledger/burrow/pull/778,https://github.com/hyperledger/burrow/pull/778,I made the changes including Silas' request for a comment above.,8bc7a686afb9645ce39374d714f45ed0387c8fb1,2018-05-24 18:46:02,190692329,"@@ -1145,16 +1150,17 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			if errAdd != nil {
 				return nil, firstErr(err, errAdd)
 			}
-			vm.stateWriter.UpdateAccount(receiver)
-			vm.stateWriter.RemoveAccount(callee.Address())
+			callState.UpdateAccount(receiver)
+			callState.RemoveAccount(callee.Address())
 			vm.Debugf("" => (%X) %v\n"", addr[:4], callee.Balance())
 			fallthrough
 
 		case STOP: // 0x00
 			return nil, nil
 
-		case STATICCALL, CREATE2:
+		case STATICCALL:",,2018-05-24 18:46:02,https://api.github.com/repos/hyperledger/burrow/pulls/comments/190692329,https://github.com/hyperledger/burrow/pull/778#discussion_r190692329,smblucker
https://github.com/hyperledger/burrow/pull/778,https://github.com/hyperledger/burrow/pull/778,Some tests are now not passing ,8bc7a686afb9645ce39374d714f45ed0387c8fb1,2018-05-24 18:48:37,190693102,"@@ -1145,16 +1150,17 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			if errAdd != nil {
 				return nil, firstErr(err, errAdd)
 			}
-			vm.stateWriter.UpdateAccount(receiver)
-			vm.stateWriter.RemoveAccount(callee.Address())
+			callState.UpdateAccount(receiver)
+			callState.RemoveAccount(callee.Address())
 			vm.Debugf("" => (%X) %v\n"", addr[:4], callee.Balance())
 			fallthrough
 
 		case STOP: // 0x00
 			return nil, nil
 
-		case STATICCALL, CREATE2:
+		case STATICCALL:",,2018-05-24 18:48:37,https://api.github.com/repos/hyperledger/burrow/pulls/comments/190693102,https://github.com/hyperledger/burrow/pull/778#discussion_r190693102,smblucker
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,I'm not a fan of these globals in `core.go` (I know you didn't add) could we get rid of them entirely and either pass in the URL as a string or package things up in a suitable config struct. It gets rid of some action at a distance and makes things easier to test.,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 11:24:25,191730378,"@@ -0,0 +1,297 @@
+package commands
+
+import (
+	""context""
+	""encoding/hex""
+	""fmt""
+	""io/ioutil""
+	""os""
+
+	""time""
+
+	""github.com/howeyc/gopass""
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/keys""
+	""github.com/hyperledger/burrow/keys/pbkeys""
+	""github.com/jawher/mow.cli""
+	""google.golang.org/grpc""
+)
+
+func grpcKeysClient(output Output) pbkeys.KeysClient {
+	var opts []grpc.DialOption
+	opts = append(opts, grpc.WithInsecure())
+	conn, err := grpc.Dial(keys.KeyHost+"":""+keys.KeyPort, opts...)",,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191730378,https://github.com/hyperledger/burrow/pull/776#discussion_r191730378,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,"Let's replace this with mow.cli's built-in support for env vars, see: https://github.com/hyperledger/burrow/blob/develop/cmd/burrow/commands/start.go#L20-L25

Means you can declare a flag and env var at same time.",37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 11:26:11,191730758,"@@ -0,0 +1,297 @@
+package commands
+
+import (
+	""context""
+	""encoding/hex""
+	""fmt""
+	""io/ioutil""
+	""os""
+
+	""time""
+
+	""github.com/howeyc/gopass""
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/keys""
+	""github.com/hyperledger/burrow/keys/pbkeys""
+	""github.com/jawher/mow.cli""
+	""google.golang.org/grpc""
+)
+
+func grpcKeysClient(output Output) pbkeys.KeysClient {
+	var opts []grpc.DialOption
+	opts = append(opts, grpc.WithInsecure())
+	conn, err := grpc.Dial(keys.KeyHost+"":""+keys.KeyPort, opts...)
+	if err != nil {
+		output.Fatalf(""Failed to connect to grpc server: %v"", err)
+	}
+	return pbkeys.NewKeysClient(conn)
+}
+
+func Keys(output Output) func(cmd *cli.Cmd) {
+	return func(cmd *cli.Cmd) {
+		if keysHost := os.Getenv(""MONAX_KEYS_HOST""); keysHost != """" {",,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191730758,https://github.com/hyperledger/burrow/pull/776#discussion_r191730758,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,Bad globals,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 11:26:34,191730857,"@@ -0,0 +1,297 @@
+package commands
+
+import (
+	""context""
+	""encoding/hex""
+	""fmt""
+	""io/ioutil""
+	""os""
+
+	""time""
+
+	""github.com/howeyc/gopass""
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/keys""
+	""github.com/hyperledger/burrow/keys/pbkeys""
+	""github.com/jawher/mow.cli""
+	""google.golang.org/grpc""
+)
+
+func grpcKeysClient(output Output) pbkeys.KeysClient {
+	var opts []grpc.DialOption
+	opts = append(opts, grpc.WithInsecure())
+	conn, err := grpc.Dial(keys.KeyHost+"":""+keys.KeyPort, opts...)
+	if err != nil {
+		output.Fatalf(""Failed to connect to grpc server: %v"", err)
+	}
+	return pbkeys.NewKeysClient(conn)
+}
+
+func Keys(output Output) func(cmd *cli.Cmd) {
+	return func(cmd *cli.Cmd) {
+		if keysHost := os.Getenv(""MONAX_KEYS_HOST""); keysHost != """" {
+			keys.DefaultHost = keysHost
+		}
+		if keysPort := os.Getenv(""MONAX_KEYS_PORT""); keysPort != """" {
+			keys.DefaultPort = keysPort
+		}
+
+		keys.KeyHost = *cmd.StringOpt(""host"", keys.DefaultHost, ""set the host for talking to the key daemon"")",,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191730857,https://github.com/hyperledger/burrow/pull/776#discussion_r191730857,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,Naughty globals,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 11:26:43,191730897,"@@ -0,0 +1,297 @@
+package commands
+
+import (
+	""context""
+	""encoding/hex""
+	""fmt""
+	""io/ioutil""
+	""os""
+
+	""time""
+
+	""github.com/howeyc/gopass""
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/keys""
+	""github.com/hyperledger/burrow/keys/pbkeys""
+	""github.com/jawher/mow.cli""
+	""google.golang.org/grpc""
+)
+
+func grpcKeysClient(output Output) pbkeys.KeysClient {
+	var opts []grpc.DialOption
+	opts = append(opts, grpc.WithInsecure())
+	conn, err := grpc.Dial(keys.KeyHost+"":""+keys.KeyPort, opts...)
+	if err != nil {
+		output.Fatalf(""Failed to connect to grpc server: %v"", err)
+	}
+	return pbkeys.NewKeysClient(conn)
+}
+
+func Keys(output Output) func(cmd *cli.Cmd) {
+	return func(cmd *cli.Cmd) {
+		if keysHost := os.Getenv(""MONAX_KEYS_HOST""); keysHost != """" {
+			keys.DefaultHost = keysHost
+		}
+		if keysPort := os.Getenv(""MONAX_KEYS_PORT""); keysPort != """" {
+			keys.DefaultPort = keysPort
+		}
+
+		keys.KeyHost = *cmd.StringOpt(""host"", keys.DefaultHost, ""set the host for talking to the key daemon"")
+
+		keys.KeyPort = *cmd.StringOpt(""port"", keys.DefaultPort, ""set the port for key daemon"")",,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191730897,https://github.com/hyperledger/burrow/pull/776#discussion_r191730897,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,OH THE GLOBALS,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 11:27:01,191730982,"@@ -0,0 +1,297 @@
+package commands
+
+import (
+	""context""
+	""encoding/hex""
+	""fmt""
+	""io/ioutil""
+	""os""
+
+	""time""
+
+	""github.com/howeyc/gopass""
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/keys""
+	""github.com/hyperledger/burrow/keys/pbkeys""
+	""github.com/jawher/mow.cli""
+	""google.golang.org/grpc""
+)
+
+func grpcKeysClient(output Output) pbkeys.KeysClient {
+	var opts []grpc.DialOption
+	opts = append(opts, grpc.WithInsecure())
+	conn, err := grpc.Dial(keys.KeyHost+"":""+keys.KeyPort, opts...)
+	if err != nil {
+		output.Fatalf(""Failed to connect to grpc server: %v"", err)
+	}
+	return pbkeys.NewKeysClient(conn)
+}
+
+func Keys(output Output) func(cmd *cli.Cmd) {
+	return func(cmd *cli.Cmd) {
+		if keysHost := os.Getenv(""MONAX_KEYS_HOST""); keysHost != """" {
+			keys.DefaultHost = keysHost
+		}
+		if keysPort := os.Getenv(""MONAX_KEYS_PORT""); keysPort != """" {
+			keys.DefaultPort = keysPort
+		}
+
+		keys.KeyHost = *cmd.StringOpt(""host"", keys.DefaultHost, ""set the host for talking to the key daemon"")
+
+		keys.KeyPort = *cmd.StringOpt(""port"", keys.DefaultPort, ""set the port for key daemon"")
+
+		cmd.Command(""server"", ""run keys server"", func(cmd *cli.Cmd) {
+			keys.KeysDir = *cmd.StringOpt(""dir"", keys.DefaultDir, ""specify the location of the directory containing key files"")",,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191730982,https://github.com/hyperledger/burrow/pull/776#discussion_r191730982,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,"This command really just 'names' a key and should probably be called `name`, see: https://github.com/monax/bosmarmot/blob/master/keys/monax-keys/app.go#L118-L123

It also needs both a name _and_ an address (this is correct in GRPC IDL). Suggest we call the server method/GRPC messages `AddName`/`AddNameRequest` and the remove `RemoveName`/`RemoveNameRequest` to make it clear this cannot add/import a key it is just a naming thing.",37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 11:36:31,191733282,"@@ -0,0 +1,297 @@
+package commands
+
+import (
+	""context""
+	""encoding/hex""
+	""fmt""
+	""io/ioutil""
+	""os""
+
+	""time""
+
+	""github.com/howeyc/gopass""
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/keys""
+	""github.com/hyperledger/burrow/keys/pbkeys""
+	""github.com/jawher/mow.cli""
+	""google.golang.org/grpc""
+)
+
+func grpcKeysClient(output Output) pbkeys.KeysClient {
+	var opts []grpc.DialOption
+	opts = append(opts, grpc.WithInsecure())
+	conn, err := grpc.Dial(keys.KeyHost+"":""+keys.KeyPort, opts...)
+	if err != nil {
+		output.Fatalf(""Failed to connect to grpc server: %v"", err)
+	}
+	return pbkeys.NewKeysClient(conn)
+}
+
+func Keys(output Output) func(cmd *cli.Cmd) {
+	return func(cmd *cli.Cmd) {
+		if keysHost := os.Getenv(""MONAX_KEYS_HOST""); keysHost != """" {
+			keys.DefaultHost = keysHost
+		}
+		if keysPort := os.Getenv(""MONAX_KEYS_PORT""); keysPort != """" {
+			keys.DefaultPort = keysPort
+		}
+
+		keys.KeyHost = *cmd.StringOpt(""host"", keys.DefaultHost, ""set the host for talking to the key daemon"")
+
+		keys.KeyPort = *cmd.StringOpt(""port"", keys.DefaultPort, ""set the port for key daemon"")
+
+		cmd.Command(""server"", ""run keys server"", func(cmd *cli.Cmd) {
+			keys.KeysDir = *cmd.StringOpt(""dir"", keys.DefaultDir, ""specify the location of the directory containing key files"")
+
+			cmd.Action = func() {
+				err := keys.StartStandAloneServer(keys.KeyHost, keys.KeyPort)
+				if err != nil {
+					output.Fatalf(""Failed to start server: %v"", err)
+				}
+			}
+		})
+
+		cmd.Command(""gen"", ""Generates a key using (insert crypto pkgs used)"", func(cmd *cli.Cmd) {
+			noPassword := cmd.BoolOpt(""n no-password"", false, ""don't use a password for this key"")
+
+			keyType := cmd.StringOpt(""t curvetype"", ""ed25519"", ""specify the curve type of key to create. Supports 'secp256k1' (ethereum),  'ed25519' (tendermint)"")
+
+			keyName := cmd.StringOpt(""name"", """", ""name of key to use"")
+
+			cmd.Action = func() {
+				curve, err := crypto.CurveTypeFromString(*keyType)
+				if err != nil {
+					output.Fatalf(""Unrecognised curve type %v"", *keyType)
+				}
+
+				var password string
+				if !*noPassword {
+					fmt.Printf(""Enter Password:"")
+					pwd, err := gopass.GetPasswdMasked()
+					if err != nil {
+						os.Exit(1)
+					}
+					password = string(pwd)
+				}
+
+				c := grpcKeysClient(output)
+				ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
+				defer cancel()
+				resp, err := c.GenerateKey(ctx, &pbkeys.GenRequest{Passphrase: password, Curvetype: curve.String(), Keyname: *keyName})
+				if err != nil {
+					output.Fatalf(""failed to generate key: %v"", err)
+				}
+
+				fmt.Printf(""%v\n"", resp.GetAddress())
+			}
+		})
+
+		cmd.Command(""hash"", ""hash <some data>"", func(cmd *cli.Cmd) {
+			hashType := cmd.StringOpt(""t type"", keys.DefaultHashType, ""specify the hash function to use"")
+
+			hexByte := cmd.BoolOpt(""hex"", false, ""the input should be hex decoded to bytes first"")
+
+			msg := cmd.StringArg(""MSG"", """", ""message to hash"")
+
+			cmd.Action = func() {
+				var message []byte
+				var err error
+				if *hexByte {
+					message, err = hex.DecodeString(*msg)
+					if err != nil {
+						output.Fatalf(""failed to hex decode message: %v"", err)
+					}
+				} else {
+					message = []byte(*msg)
+				}
+
+				c := grpcKeysClient(output)
+				ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
+				defer cancel()
+				resp, err := c.Hash(ctx, &pbkeys.HashRequest{Hashtype: *hashType, Message: message})
+				if err != nil {
+					output.Fatalf(""failed to get public key: %v"", err)
+				}
+
+				fmt.Printf(""%v\n"", resp.GetHash())
+			}
+		})
+
+		cmd.Command(""export"", ""Export a key to tendermint format"", func(cmd *cli.Cmd) {
+			keyName := cmd.StringOpt(""name"", """", ""name of key to use"")
+			keyAddr := cmd.StringOpt(""addr"", """", ""address of key to use"")
+			passphrase := cmd.StringOpt(""passphrase"", """", ""passphrase for encrypted key"")
+
+			cmd.Action = func() {
+				c := grpcKeysClient(output)
+				ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
+				defer cancel()
+				resp, err := c.Export(ctx, &pbkeys.ExportRequest{Passphrase: *passphrase, Name: *keyName, Address: *keyAddr})
+				if err != nil {
+					output.Fatalf(""failed to export key: %v"", err)
+				}
+
+				fmt.Printf(""%s\n"", resp.GetExport())
+			}
+		})
+
+		cmd.Command(""import"", ""import <priv key> | /path/to/keyfile | <key json>"", func(cmd *cli.Cmd) {
+			curveType := cmd.StringOpt(""t curvetype"", ""ed25519"", ""specify the curve type of key to create. Supports 'secp256k1' (ethereum),  'ed25519' (tendermint)"")
+			key := cmd.StringArg(""KEY"", """", ""private key, filename, or raw json"")
+
+			cmd.Action = func() {
+				var privKeyBytes []byte
+				var err error
+				if _, err := os.Stat(*key); err == nil {
+					privKeyBytes, err = ioutil.ReadFile(*key)
+					if err != nil {
+						output.Fatalf(""Failed to read file %s: %v"", *key, err)
+					}
+				}
+
+				c := grpcKeysClient(output)
+				ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
+				defer cancel()
+
+				if (*key)[:1] == ""{"" {
+					resp, err := c.ImportJSON(ctx, &pbkeys.ImportJSONRequest{JSON: *key})
+					if err != nil {
+						output.Fatalf(""failed to import json key: %v"", err)
+					}
+
+					fmt.Printf(""%X\n"", resp.GetAddress())
+				} else {
+					privKeyBytes, err = hex.DecodeString(*key)
+					if err != nil {
+						output.Fatalf(""failed to hex decode key"")
+					}
+					resp, err := c.Import(ctx, &pbkeys.ImportRequest{Keybytes: privKeyBytes, Curvetype: *curveType})
+					if err != nil {
+						output.Fatalf(""failed to import json key: %v"", err)
+					}
+
+					fmt.Printf(""%X\n"", resp.GetAddress())
+
+				}
+			}
+		})
+
+		cmd.Command(""pub"", ""public key"", func(cmd *cli.Cmd) {
+			name := cmd.StringOpt(""name"", """", ""name of key to use"")
+			addr := cmd.StringOpt(""addr"", """", ""address of key to use"")
+
+			cmd.Action = func() {
+				c := grpcKeysClient(output)
+				ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
+				defer cancel()
+				resp, err := c.PublicKey(ctx, &pbkeys.PubRequest{Name: *name, Address: *addr})
+				if err != nil {
+					output.Fatalf(""failed to get public key: %v"", err)
+				}
+
+				fmt.Printf(""%X\n"", resp.GetPub())
+			}
+		})
+
+		cmd.Command(""sign"", ""sign <some data>"", func(cmd *cli.Cmd) {
+			addr := cmd.StringOpt(""addr"", """", ""address of key to use"")
+			msg := cmd.StringArg(""HASH"", """", ""hash to sign"")
+			passphrase := cmd.StringOpt(""passphrase"", """", ""passphrase for encrypted key"")
+
+			cmd.Action = func() {
+				message, err := hex.DecodeString(*msg)
+				if err != nil {
+					output.Fatalf(""failed to hex decode message: %v"", err)
+				}
+
+				c := grpcKeysClient(output)
+				ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
+				defer cancel()
+				resp, err := c.Sign(ctx, &pbkeys.SignRequest{Passphrase: *passphrase, Address: *addr, Hash: message})
+				if err != nil {
+					output.Fatalf(""failed to get public key: %v"", err)
+				}
+				fmt.Printf(""%X\n"", resp.GetSignature())
+			}
+		})
+
+		cmd.Command(""verify"", ""verify <some data> <sig> <pubkey>"", func(cmd *cli.Cmd) {
+			curveType := cmd.StringOpt(""t curvetype"", ""ed25519"", ""specify the curve type of key to create. Supports 'secp256k1' (ethereum),  'ed25519' (tendermint)"")
+
+			msg := cmd.StringArg(""MSG"", """", ""hash/message to check"")
+			sig := cmd.StringArg(""SIG"", """", ""signature"")
+			pub := cmd.StringArg(""PUBLIC"", """", ""public key"")
+
+			cmd.Action = func() {
+				message, err := hex.DecodeString(*msg)
+				if err != nil {
+					output.Fatalf(""failed to hex decode message: %v"", err)
+				}
+
+				signature, err := hex.DecodeString(*sig)
+				if err != nil {
+					output.Fatalf(""failed to hex decode signature: %v"", err)
+				}
+
+				publickey, err := hex.DecodeString(*pub)
+				if err != nil {
+					output.Fatalf(""failed to hex decode publickey: %v"", err)
+				}
+
+				c := grpcKeysClient(output)
+				ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
+				defer cancel()
+				_, err = c.Verify(ctx, &pbkeys.VerifyRequest{Curvetype: *curveType, Pub: publickey, Signature: signature, Hash: message})
+				if err != nil {
+					output.Fatalf(""failed to verify: %v"", err)
+				}
+			}
+		})
+
+		cmd.Command(""add"", ""add key by name or addr"", func(cmd *cli.Cmd) {",,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191733282,https://github.com/hyperledger/burrow/pull/776#discussion_r191733282,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,"I'm with you on this, I know it's not really to do with your changes but can we flip `Disabled` to `Enabled` on `process.Launcher` and on all the RPC configs so they are consistent. We'll just always output both `Enable: ...` and `ListenAddress: ...` on the config.",37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 11:40:29,191734174,"@@ -199,6 +201,26 @@ func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tm_t
 				return serveProcess, nil
 			},
 		},
+		{
+			Name:     ""grpc service"",
+			Disabled: rpcConfig.GRPC.Disabled,",,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191734174,https://github.com/hyperledger/burrow/pull/776#discussion_r191734174,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,Do we need this anymore? I think we can just kill it and use the struct above with default encoding,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 11:41:23,191734430,"@@ -0,0 +1,351 @@
+package crypto
+
+import (
+	""bytes""
+	crand ""crypto/rand""
+	""crypto/sha256""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""io""
+
+	""golang.org/x/crypto/ripemd160""
+
+	""github.com/btcsuite/btcd/btcec""
+	tm_crypto ""github.com/tendermint/go-crypto""
+	""golang.org/x/crypto/ed25519""
+)
+
+type CurveType int8
+
+const (
+	CurveTypeSecp256k1 CurveType = iota
+	CurveTypeEd25519
+)
+
+func (k CurveType) String() string {
+	switch k {
+	case CurveTypeSecp256k1:
+		return ""secp256k1""
+	case CurveTypeEd25519:
+		return ""ed25519""
+	default:
+		return ""unknown""
+	}
+}
+
+func CurveTypeFromString(s string) (CurveType, error) {
+	switch s {
+	case ""secp256k1"":
+		return CurveTypeSecp256k1, nil
+	case ""ed25519"":
+		return CurveTypeEd25519, nil
+	default:
+		var k CurveType
+		return k, ErrInvalidCurve(s)
+	}
+}
+
+type ErrInvalidCurve string
+
+func (err ErrInvalidCurve) Error() string {
+	return fmt.Sprintf(""invalid curve type"")
+}
+
+// The types in this file allow us to control serialisation of keys and signatures, as well as the interface
+// exposed regardless of crypto library
+
+type Signer interface {
+	Sign(msg []byte) (Signature, error)
+}
+
+// PublicKey
+type PublicKey struct {
+	CurveType CurveType
+	PublicKey []byte
+}
+
+type PrivateKey struct {
+	CurveType  CurveType
+	PublicKey  []byte
+	PrivateKey []byte
+}
+
+type PublicKeyJSON struct {",84,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191734430,https://github.com/hyperledger/burrow/pull/776#discussion_r191734430,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,"Minor point but I've already copped a dependency for fast upper case hex encoding: `import ""github.com/tmthrgd/go-hex""` may as well use it everywhere",37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:11:30,191782543,"@@ -0,0 +1,351 @@
+package crypto
+
+import (
+	""bytes""
+	crand ""crypto/rand""
+	""crypto/sha256""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""io""
+
+	""golang.org/x/crypto/ripemd160""
+
+	""github.com/btcsuite/btcd/btcec""
+	tm_crypto ""github.com/tendermint/go-crypto""
+	""golang.org/x/crypto/ed25519""
+)
+
+type CurveType int8
+
+const (
+	CurveTypeSecp256k1 CurveType = iota
+	CurveTypeEd25519
+)
+
+func (k CurveType) String() string {
+	switch k {
+	case CurveTypeSecp256k1:
+		return ""secp256k1""
+	case CurveTypeEd25519:
+		return ""ed25519""
+	default:
+		return ""unknown""
+	}
+}
+
+func CurveTypeFromString(s string) (CurveType, error) {
+	switch s {
+	case ""secp256k1"":
+		return CurveTypeSecp256k1, nil
+	case ""ed25519"":
+		return CurveTypeEd25519, nil
+	default:
+		var k CurveType
+		return k, ErrInvalidCurve(s)
+	}
+}
+
+type ErrInvalidCurve string
+
+func (err ErrInvalidCurve) Error() string {
+	return fmt.Sprintf(""invalid curve type"")
+}
+
+// The types in this file allow us to control serialisation of keys and signatures, as well as the interface
+// exposed regardless of crypto library
+
+type Signer interface {
+	Sign(msg []byte) (Signature, error)
+}
+
+// PublicKey
+type PublicKey struct {
+	CurveType CurveType
+	PublicKey []byte
+}
+
+type PrivateKey struct {
+	CurveType  CurveType
+	PublicKey  []byte
+	PrivateKey []byte
+}
+
+type PublicKeyJSON struct {
+	Type string `json:""type""`
+	Data string `json:""data""`
+}
+
+func (p PublicKey) MarshalJSON() ([]byte, error) {
+	jStruct := PublicKeyJSON{
+		Type: p.CurveType.String(),
+		Data: fmt.Sprintf(""%X"", p.PublicKey),
+	}
+	txt, err := json.Marshal(jStruct)
+	return txt, err
+}
+
+func (p PublicKey) MarshalText() ([]byte, error) {
+	return p.MarshalJSON()
+}
+
+func (p *PublicKey) UnmarshalJSON(text []byte) error {
+	var jStruct PublicKeyJSON
+	err := json.Unmarshal(text, &jStruct)
+	if err != nil {
+		return err
+	}
+	CurveType, err := CurveTypeFromString(jStruct.Type)
+	if err != nil {
+		return err
+	}
+	bs, err := hex.DecodeString(jStruct.Data)
+	if err != nil {
+		return err
+	}
+	p.CurveType = CurveType
+	p.PublicKey = bs
+	return nil
+}
+
+func (p *PublicKey) UnmarshalText(text []byte) error {
+	return p.UnmarshalJSON(text)
+}
+
+func (p PublicKey) IsValid() bool {
+	switch p.CurveType {
+	case CurveTypeEd25519:
+		return len(p.PublicKey) == ed25519.PublicKeySize
+	case CurveTypeSecp256k1:
+		return len(p.PublicKey) == btcec.PubKeyBytesLenCompressed
+	default:
+		return false
+	}
+}
+func (p PublicKey) Verify(msg []byte, signature Signature) bool {
+	switch p.CurveType {
+	case CurveTypeEd25519:
+		return ed25519.Verify(p.PublicKey, msg, signature.Signature[:])
+	case CurveTypeSecp256k1:
+		pub, err := btcec.ParsePubKey(p.PublicKey, btcec.S256())
+		if err != nil {
+			return false
+		}
+		sig, err := btcec.ParseDERSignature(signature.Signature, btcec.S256())
+		if err != nil {
+			return false
+		}
+		return sig.Verify(msg, pub)
+	default:
+		panic(fmt.Sprintf(""invalid curve type""))
+	}
+}
+
+func (p PublicKey) Address() Address {
+	switch p.CurveType {
+	case CurveTypeEd25519:
+		// FIMXE: tendermint go-crypto-0.5.0 uses weird scheme, this is fixed in 0.6.0
+		tmPubKey := new(tm_crypto.PubKeyEd25519)
+		copy(tmPubKey[:], p.PublicKey)
+		addr, _ := AddressFromBytes(tmPubKey.Address())
+		return addr
+	case CurveTypeSecp256k1:
+		sha := sha256.New()
+		sha.Write(p.PublicKey[:])
+
+		hash := ripemd160.New()
+		hash.Write(sha.Sum(nil))
+		addr, _ := AddressFromBytes(hash.Sum(nil))
+		return addr
+	default:
+		panic(fmt.Sprintf(""unknown CurveType %d"", p.CurveType))
+	}
+}
+
+func (p PublicKey) RawBytes() []byte {
+	return p.PublicKey[:]
+}
+
+func (p PublicKey) String() string {
+	return fmt.Sprintf(""%X"", p.PublicKey[:])",,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191782543,https://github.com/hyperledger/burrow/pull/776#discussion_r191782543,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,Can be removed,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:18:27,191785493,"@@ -0,0 +1,48 @@
+package common
+
+import (
+	""os""
+	""path/filepath""
+	""runtime""
+)
+
+var (
+	// Convenience directories.
+	MonaxRoot          = ResolveMonaxRoot()
+	MonaxContainerRoot = ""/home/monax/.monax""",,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191785493,https://github.com/hyperledger/burrow/pull/776#discussion_r191785493,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,"I think for this and all the RPC configs we should define a struct called `ServerConfig` in rpc/config.go then do something like:
```go
type ServerConfig struct {
	Enabled        bool
	ListenAddress string
}

type KeysConfig struct {
	Server        *ServerConfig `json:"",omitempty"" toml:"",omitempty""`
	RemoteAddress string
}",37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:27:25,191789112,"@@ -1,12 +1,14 @@
 package keys
 
 type KeysConfig struct {
-	URL string
+	ServerEnabled bool
+	URL           string
 }
 
 func DefaultKeysConfig() *KeysConfig {
 	return &KeysConfig{
 		// Default Monax keys port
-		URL: ""http://localhost:4767"",
+		ServerEnabled: true,
+		URL:           """",
 	}",,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191789112,https://github.com/hyperledger/burrow/pull/776#discussion_r191789112,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,Can we `const` the defaults and nuke the globals?,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:30:49,191790531,"@@ -0,0 +1,218 @@
+package keys
+
+import (
+	""encoding/hex""
+	""fmt""
+	""io/ioutil""
+	""os""
+	""path""
+	""path/filepath""
+	""strings""
+
+	""github.com/hyperledger/burrow/keys/common""
+
+	tmint_crypto ""github.com/hyperledger/burrow/crypto/helpers""
+	wire ""github.com/tendermint/go-wire""
+)
+
+var (
+	DefaultKeyType  = ""ed25519""
+	DefaultDir      = common.KeysPath
+	DefaultHashType = ""sha256""
+
+	DefaultHost = ""localhost""
+	DefaultPort = ""10997""
+	TestPort    = ""7674""
+	TestAddr    = DefaultHost + "":"" + TestPort
+
+	KeysDir string = "".monax-keys""
+	KeyHost string
+	KeyPort string
+
+	GlobalKeystore KeyStore",,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191790531,https://github.com/hyperledger/burrow/pull/776#discussion_r191790531,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,"I think I prefer `message`... it doesn't have to be a hash, right?",37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:32:24,191791285,"@@ -15,71 +15,186 @@
 package keys
 
 import (
-	""encoding/hex""
+	""context""
 	""fmt""
+	""time""
 
 	acm ""github.com/hyperledger/burrow/account""
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/keys/pbkeys""
 	""github.com/hyperledger/burrow/logging""
+	""google.golang.org/grpc""
 )
 
 type KeyClient interface {
-	// Sign returns the signature bytes for given message signed with the key associated with signAddress
-	Sign(signAddress acm.Address, message []byte) (signature acm.Signature, err error)
+	// Sign returns the signature bytes for given hash signed with the key associated with signAddress
+	Sign(signAddress crypto.Address, hash []byte) (signature crypto.Signature, err error)",,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191791285,https://github.com/hyperledger/burrow/pull/776#discussion_r191791285,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,Also how do we provide the passphrase?,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:33:15,191791653,"@@ -15,71 +15,186 @@
 package keys
 
 import (
-	""encoding/hex""
+	""context""
 	""fmt""
+	""time""
 
 	acm ""github.com/hyperledger/burrow/account""
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/keys/pbkeys""
 	""github.com/hyperledger/burrow/logging""
+	""google.golang.org/grpc""
 )
 
 type KeyClient interface {
-	// Sign returns the signature bytes for given message signed with the key associated with signAddress
-	Sign(signAddress acm.Address, message []byte) (signature acm.Signature, err error)
+	// Sign returns the signature bytes for given hash signed with the key associated with signAddress
+	Sign(signAddress crypto.Address, hash []byte) (signature crypto.Signature, err error)",,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191791653,https://github.com/hyperledger/burrow/pull/776#discussion_r191791653,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,How do we generate with passphrase?,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:33:28,191791738,"@@ -15,71 +15,186 @@
 package keys
 
 import (
-	""encoding/hex""
+	""context""
 	""fmt""
+	""time""
 
 	acm ""github.com/hyperledger/burrow/account""
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/keys/pbkeys""
 	""github.com/hyperledger/burrow/logging""
+	""google.golang.org/grpc""
 )
 
 type KeyClient interface {
-	// Sign returns the signature bytes for given message signed with the key associated with signAddress
-	Sign(signAddress acm.Address, message []byte) (signature acm.Signature, err error)
+	// Sign returns the signature bytes for given hash signed with the key associated with signAddress
+	Sign(signAddress crypto.Address, hash []byte) (signature crypto.Signature, err error)
 
 	// PublicKey returns the public key associated with a given address
-	PublicKey(address acm.Address) (publicKey acm.PublicKey, err error)
+	PublicKey(address crypto.Address) (publicKey crypto.PublicKey, err error)
 
 	// Generate requests that a key be generate within the keys instance and returns the address
-	Generate(keyName string, keyType KeyType) (keyAddress acm.Address, err error)
+	Generate(keyName string, keyType crypto.CurveType) (keyAddress crypto.Address, err error)",27,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191791738,https://github.com/hyperledger/burrow/pull/776#discussion_r191791738,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,Ah did I forget - did we decide to leave this latent for now - as in not exposing passphrase through `KeyClient`?,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:34:45,191792266,"@@ -0,0 +1,76 @@
+package keys
+
+import (
+	""github.com/hyperledger/burrow/crypto""
+)
+
+type Key struct {
+	CurveType  crypto.CurveType
+	Address    crypto.Address
+	PublicKey  crypto.PublicKey
+	PrivateKey crypto.PrivateKey
+}
+
+func NewKey(typ crypto.CurveType) (*Key, error) {
+	privKey, err := crypto.GeneratePrivateKey(nil, typ)
+	if err != nil {
+		return nil, err
+	}
+	pubKey := privKey.GetPublicKey()
+	return &Key{
+		CurveType:  typ,
+		PublicKey:  pubKey,
+		Address:    pubKey.Address(),
+		PrivateKey: privKey,
+	}, nil
+}
+
+func (k *Key) Pubkey() []byte {
+	return k.PublicKey.RawBytes()
+}
+
+func NewKeyFromPub(curveType crypto.CurveType, PubKeyBytes []byte) (*Key, error) {
+	pubKey, err := crypto.PublicKeyFromBytes(PubKeyBytes, curveType)
+	if err != nil {
+		return nil, err
+	}
+
+	return &Key{
+		CurveType: curveType,
+		PublicKey: pubKey,
+		Address:   pubKey.Address(),
+	}, nil
+}
+
+func NewKeyFromPriv(curveType crypto.CurveType, PrivKeyBytes []byte) (*Key, error) {
+	privKey, err := crypto.PrivateKeyFromRawBytes(PrivKeyBytes, curveType)
+
+	if err != nil {
+		return nil, err
+	}
+
+	pubKey := privKey.GetPublicKey()
+
+	return &Key{
+		CurveType:  curveType,
+		Address:    pubKey.Address(),
+		PublicKey:  pubKey,
+		PrivateKey: privKey,
+	}, nil
+}
+
+type KeyStore interface {
+	GenerateKey(passphrase string, curveType crypto.CurveType) (*Key, error)",,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191792266,https://github.com/hyperledger/burrow/pull/776#discussion_r191792266,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,"Can we make `""none""` an exported constant?",37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:36:17,191792847,"@@ -0,0 +1,298 @@
+package keys
+
+import (
+	""crypto/aes""
+	""crypto/cipher""
+	""crypto/rand""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""io/ioutil""
+	""os""
+	""path""
+	""strings""
+	""sync""
+
+	""github.com/hyperledger/burrow/crypto""
+
+	""golang.org/x/crypto/scrypt""
+)
+
+const (
+	scryptN     = 1 << 18
+	scryptr     = 8
+	scryptp     = 1
+	scryptdkLen = 32
+)
+
+//-----------------------------------------------------------------------------
+// json encodings
+
+// addresses should be hex encoded
+
+type keyJSON struct {
+	CurveType   string
+	Address     string
+	PublicKey   []byte
+	AddressHash string
+	PrivateKey  privateKeyJSON
+}
+
+type privateKeyJSON struct {
+	Crypto     string
+	Plain      []byte `json:"",omitempty""`
+	Salt       []byte `json:"",omitempty""`
+	Nonce      []byte `json:"",omitempty""`
+	CipherText []byte `json:"",omitempty""`
+}
+
+func (k *Key) MarshalJSON() (j []byte, err error) {
+	jStruct := keyJSON{
+		k.CurveType.String(),
+		fmt.Sprintf(""%X"", k.Address),
+		k.Pubkey(),
+		""go-crypto-0.5.0"",
+		privateKeyJSON{Crypto: ""none"", Plain: k.PrivateKey.RawBytes()},",,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191792847,https://github.com/hyperledger/burrow/pull/776#discussion_r191792847,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,hex library,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:36:32,191792951,"@@ -0,0 +1,298 @@
+package keys
+
+import (
+	""crypto/aes""
+	""crypto/cipher""
+	""crypto/rand""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""io/ioutil""
+	""os""
+	""path""
+	""strings""
+	""sync""
+
+	""github.com/hyperledger/burrow/crypto""
+
+	""golang.org/x/crypto/scrypt""
+)
+
+const (
+	scryptN     = 1 << 18
+	scryptr     = 8
+	scryptp     = 1
+	scryptdkLen = 32
+)
+
+//-----------------------------------------------------------------------------
+// json encodings
+
+// addresses should be hex encoded
+
+type keyJSON struct {
+	CurveType   string
+	Address     string
+	PublicKey   []byte
+	AddressHash string
+	PrivateKey  privateKeyJSON
+}
+
+type privateKeyJSON struct {
+	Crypto     string
+	Plain      []byte `json:"",omitempty""`
+	Salt       []byte `json:"",omitempty""`
+	Nonce      []byte `json:"",omitempty""`
+	CipherText []byte `json:"",omitempty""`
+}
+
+func (k *Key) MarshalJSON() (j []byte, err error) {
+	jStruct := keyJSON{
+		k.CurveType.String(),
+		fmt.Sprintf(""%X"", k.Address),",,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191792951,https://github.com/hyperledger/burrow/pull/776#discussion_r191792951,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,Can we use name parameters in the initialisation,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:38:16,191793661,"@@ -0,0 +1,298 @@
+package keys
+
+import (
+	""crypto/aes""
+	""crypto/cipher""
+	""crypto/rand""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""io/ioutil""
+	""os""
+	""path""
+	""strings""
+	""sync""
+
+	""github.com/hyperledger/burrow/crypto""
+
+	""golang.org/x/crypto/scrypt""
+)
+
+const (
+	scryptN     = 1 << 18
+	scryptr     = 8
+	scryptp     = 1
+	scryptdkLen = 32
+)
+
+//-----------------------------------------------------------------------------
+// json encodings
+
+// addresses should be hex encoded
+
+type keyJSON struct {
+	CurveType   string
+	Address     string
+	PublicKey   []byte
+	AddressHash string
+	PrivateKey  privateKeyJSON
+}
+
+type privateKeyJSON struct {
+	Crypto     string
+	Plain      []byte `json:"",omitempty""`
+	Salt       []byte `json:"",omitempty""`
+	Nonce      []byte `json:"",omitempty""`
+	CipherText []byte `json:"",omitempty""`
+}
+
+func (k *Key) MarshalJSON() (j []byte, err error) {
+	jStruct := keyJSON{",54,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191793661,https://github.com/hyperledger/burrow/pull/776#discussion_r191793661,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,export const,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:38:39,191793818,"@@ -0,0 +1,298 @@
+package keys
+
+import (
+	""crypto/aes""
+	""crypto/cipher""
+	""crypto/rand""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""io/ioutil""
+	""os""
+	""path""
+	""strings""
+	""sync""
+
+	""github.com/hyperledger/burrow/crypto""
+
+	""golang.org/x/crypto/scrypt""
+)
+
+const (
+	scryptN     = 1 << 18
+	scryptr     = 8
+	scryptp     = 1
+	scryptdkLen = 32
+)
+
+//-----------------------------------------------------------------------------
+// json encodings
+
+// addresses should be hex encoded
+
+type keyJSON struct {
+	CurveType   string
+	Address     string
+	PublicKey   []byte
+	AddressHash string
+	PrivateKey  privateKeyJSON
+}
+
+type privateKeyJSON struct {
+	Crypto     string
+	Plain      []byte `json:"",omitempty""`
+	Salt       []byte `json:"",omitempty""`
+	Nonce      []byte `json:"",omitempty""`
+	CipherText []byte `json:"",omitempty""`
+}
+
+func (k *Key) MarshalJSON() (j []byte, err error) {
+	jStruct := keyJSON{
+		k.CurveType.String(),
+		fmt.Sprintf(""%X"", k.Address),
+		k.Pubkey(),
+		""go-crypto-0.5.0"",",,2018-06-01 13:37:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191793818,https://github.com/hyperledger/burrow/pull/776#discussion_r191793818,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,?,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:39:17,191794079,"@@ -0,0 +1,298 @@
+package keys
+
+import (
+	""crypto/aes""
+	""crypto/cipher""
+	""crypto/rand""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""io/ioutil""
+	""os""
+	""path""
+	""strings""
+	""sync""
+
+	""github.com/hyperledger/burrow/crypto""
+
+	""golang.org/x/crypto/scrypt""
+)
+
+const (
+	scryptN     = 1 << 18
+	scryptr     = 8
+	scryptp     = 1
+	scryptdkLen = 32
+)
+
+//-----------------------------------------------------------------------------
+// json encodings
+
+// addresses should be hex encoded
+
+type keyJSON struct {
+	CurveType   string
+	Address     string
+	PublicKey   []byte
+	AddressHash string
+	PrivateKey  privateKeyJSON
+}
+
+type privateKeyJSON struct {
+	Crypto     string
+	Plain      []byte `json:"",omitempty""`
+	Salt       []byte `json:"",omitempty""`
+	Nonce      []byte `json:"",omitempty""`
+	CipherText []byte `json:"",omitempty""`
+}
+
+func (k *Key) MarshalJSON() (j []byte, err error) {
+	jStruct := keyJSON{
+		k.CurveType.String(),
+		fmt.Sprintf(""%X"", k.Address),
+		k.Pubkey(),
+		""go-crypto-0.5.0"",
+		privateKeyJSON{Crypto: ""none"", Plain: k.PrivateKey.RawBytes()},
+	}
+	j, err = json.Marshal(jStruct)
+	return j, err
+}
+
+func (k *Key) UnmarshalJSON(j []byte) (err error) {
+	keyJ := new(keyJSON)
+	err = json.Unmarshal(j, &keyJ)
+	if err != nil {
+		return err
+	}
+	// TODO: remove this",,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191794079,https://github.com/hyperledger/burrow/pull/776#discussion_r191794079,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,name initialisers + constant,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:41:13,191794891,"@@ -0,0 +1,298 @@
+package keys
+
+import (
+	""crypto/aes""
+	""crypto/cipher""
+	""crypto/rand""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""io/ioutil""
+	""os""
+	""path""
+	""strings""
+	""sync""
+
+	""github.com/hyperledger/burrow/crypto""
+
+	""golang.org/x/crypto/scrypt""
+)
+
+const (
+	scryptN     = 1 << 18
+	scryptr     = 8
+	scryptp     = 1
+	scryptdkLen = 32
+)
+
+//-----------------------------------------------------------------------------
+// json encodings
+
+// addresses should be hex encoded
+
+type keyJSON struct {
+	CurveType   string
+	Address     string
+	PublicKey   []byte
+	AddressHash string
+	PrivateKey  privateKeyJSON
+}
+
+type privateKeyJSON struct {
+	Crypto     string
+	Plain      []byte `json:"",omitempty""`
+	Salt       []byte `json:"",omitempty""`
+	Nonce      []byte `json:"",omitempty""`
+	CipherText []byte `json:"",omitempty""`
+}
+
+func (k *Key) MarshalJSON() (j []byte, err error) {
+	jStruct := keyJSON{
+		k.CurveType.String(),
+		fmt.Sprintf(""%X"", k.Address),
+		k.Pubkey(),
+		""go-crypto-0.5.0"",
+		privateKeyJSON{Crypto: ""none"", Plain: k.PrivateKey.RawBytes()},
+	}
+	j, err = json.Marshal(jStruct)
+	return j, err
+}
+
+func (k *Key) UnmarshalJSON(j []byte) (err error) {
+	keyJ := new(keyJSON)
+	err = json.Unmarshal(j, &keyJ)
+	if err != nil {
+		return err
+	}
+	// TODO: remove this
+	if len(keyJ.PrivateKey.Plain) == 0 {
+		return fmt.Errorf(""no private key"")
+	}
+	curveType, err := crypto.CurveTypeFromString(keyJ.CurveType)
+	if err != nil {
+		curveType = crypto.CurveTypeEd25519
+	}
+	k2, err := NewKeyFromPriv(curveType, keyJ.PrivateKey.Plain)
+	if err != nil {
+		return err
+	}
+
+	k.Address = k2.Address
+	k.CurveType = curveType
+	k.PublicKey = k2.PrivateKey.GetPublicKey()
+	k.PrivateKey = k2.PrivateKey
+
+	return nil
+}
+
+// returns the address if valid, nil otherwise
+func IsValidKeyJson(j []byte) []byte {
+	j1 := new(keyJSON)
+	e1 := json.Unmarshal(j, &j1)
+	if e1 == nil {
+		addr, _ := hex.DecodeString(j1.Address)
+		return addr
+	}
+	return nil
+}
+
+type keyStoreFile struct {
+	sync.Mutex
+	keysDirPath string
+}
+
+func NewKeyStoreFile(path string) KeyStore {
+	return &keyStoreFile{keysDirPath: path}
+}
+
+func (ks keyStoreFile) GenerateKey(passphrase string, curveType crypto.CurveType) (key *Key, err error) {
+	defer func() {
+		if r := recover(); r != nil {
+			err = fmt.Errorf(""GenerateNewKey error: %v"", r)
+		}
+	}()
+	key, err = NewKey(curveType)
+	if err != nil {
+		return nil, err
+	}
+	err = ks.StoreKey(passphrase, key)
+	return key, err
+}
+
+func (ks keyStoreFile) GetKey(passphrase string, keyAddr []byte) (*Key, error) {
+	ks.Lock()
+	defer ks.Unlock()
+	fileContent, err := GetKeyFile(ks.keysDirPath, keyAddr)
+	if err != nil {
+		return nil, err
+	}
+	key := new(keyJSON)
+	if err = json.Unmarshal(fileContent, key); err != nil {
+		return nil, err
+	}
+
+	if len(key.PrivateKey.CipherText) > 0 {
+		return DecryptKey(passphrase, key)
+	} else {
+		key := new(Key)
+		err = key.UnmarshalJSON(fileContent)
+		return key, err
+	}
+}
+
+func DecryptKey(passphrase string, keyProtected *keyJSON) (*Key, error) {
+	salt := keyProtected.PrivateKey.Salt
+	nonce := keyProtected.PrivateKey.Nonce
+	cipherText := keyProtected.PrivateKey.CipherText
+
+	curveType, err := crypto.CurveTypeFromString(keyProtected.CurveType)
+	if err != nil {
+		return nil, err
+	}
+	authArray := []byte(passphrase)
+	derivedKey, err := scrypt.Key(authArray, salt, scryptN, scryptr, scryptp, scryptdkLen)
+	if err != nil {
+		return nil, err
+	}
+	aesBlock, err := aes.NewCipher(derivedKey)
+	if err != nil {
+		return nil, err
+	}
+	gcm, err := cipher.NewGCM(aesBlock)
+	if err != nil {
+		return nil, err
+	}
+	plainText, err := gcm.Open(nil, nonce, cipherText, nil)
+	if err != nil {
+		pkey, _ := NewKeyFromPub(curveType, keyProtected.PublicKey)
+		return pkey, err
+	}
+	address, err := crypto.AddressFromHexString(keyProtected.Address)
+	if err != nil {
+		return nil, err
+	}
+	k, err := NewKeyFromPriv(curveType, plainText)
+	if err != nil {
+		return nil, err
+	}
+	if address != k.Address {
+		return nil, fmt.Errorf(""address does not match"")
+	}
+	return k, nil
+}
+
+func (ks keyStoreFile) GetAllAddresses() (addresses [][]byte, err error) {
+	ks.Lock()
+	defer ks.Unlock()
+	return GetAllAddresses(ks.keysDirPath)
+}
+
+func (ks keyStoreFile) StoreKey(passphrase string, key *Key) error {
+	ks.Lock()
+	defer ks.Unlock()
+	if passphrase != """" {
+		return ks.StoreKeyEncrypted(passphrase, key)
+	} else {
+		return ks.StoreKeyPlain(key)
+	}
+}
+
+func (ks keyStoreFile) StoreKeyPlain(key *Key) (err error) {
+	keyJSON, err := json.Marshal(key)
+	if err != nil {
+		return err
+	}
+	err = WriteKeyFile(key.Address[:], ks.keysDirPath, keyJSON)
+	return err
+}
+
+func (ks keyStoreFile) StoreKeyEncrypted(passphrase string, key *Key) error {
+	authArray := []byte(passphrase)
+	salt := make([]byte, 32)
+	_, err := rand.Read(salt)
+	if err != nil {
+		return err
+	}
+
+	derivedKey, err := scrypt.Key(authArray, salt, scryptN, scryptr, scryptp, scryptdkLen)
+	if err != nil {
+		return err
+	}
+
+	toEncrypt := key.PrivateKey.RawBytes()
+
+	AES256Block, err := aes.NewCipher(derivedKey)
+	if err != nil {
+		return err
+	}
+
+	gcm, err := cipher.NewGCM(AES256Block)
+	if err != nil {
+		return err
+	}
+
+	// XXX: a GCM nonce may only be used once per key ever!
+	nonce := make([]byte, gcm.NonceSize())
+	_, err = rand.Read(nonce)
+	if err != nil {
+		return err
+	}
+
+	// (dst, nonce, plaintext, extradata)
+	cipherText := gcm.Seal(nil, nonce, toEncrypt, nil)
+
+	cipherStruct := privateKeyJSON{
+		Crypto: ""scrypt-aes-gcm"", Salt: salt, Nonce: nonce, CipherText: cipherText,
+	}
+	keyStruct := keyJSON{
+		key.CurveType.String(),
+		strings.ToUpper(hex.EncodeToString(key.Address[:])),
+		key.Pubkey(),
+		""go-crypto-0.5.0"",
+		cipherStruct,
+	}",,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191794891,https://github.com/hyperledger/burrow/pull/776#discussion_r191794891,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,AddNameRequest,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:42:45,191795632,"@@ -0,0 +1,112 @@
+syntax = ""proto3"";
+
+package pbkeys;
+
+service Keys {
+    rpc GenerateKey(GenRequest) returns (GenResponse);
+    rpc PublicKey(PubRequest) returns (PubResponse);
+    rpc Sign(SignRequest) returns (SignResponse);
+    rpc Verify(VerifyRequest) returns (Empty);
+    rpc Import(ImportRequest) returns (ImportResponse);
+    rpc ImportJSON(ImportJSONRequest) returns (ImportResponse);
+    rpc Export(ExportRequest) returns (ExportResponse);
+    rpc Hash(HashRequest) returns (HashResponse);
+    rpc Remove(Name) returns (Empty);
+    rpc List(Name) returns (ListResponse);
+    rpc Add(AddRequest) returns (Empty);
+}
+
+message Name {
+    string keyname = 1;
+}
+
+message Empty {
+
+}
+
+message GenRequest {
+    string passphrase = 1;
+    string curvetype = 2;
+    string keyname = 3;
+}
+
+message GenResponse {
+    string address = 1;
+}
+
+message PubRequest {
+    string address = 1;
+    string name = 2;
+} 
+
+message PubResponse {
+    bytes pub = 1;
+    string curvetype = 2;
+}
+
+message ImportJSONRequest {
+    string passphrase = 1;
+    string JSON = 2;
+}
+
+message ImportResponse {
+    string address = 1;
+}
+
+message ImportRequest {
+    string passphrase = 1;
+    string name = 2;
+    string curvetype = 3;
+    bytes keybytes = 4;
+}
+
+message ExportRequest {
+    string passphrase = 1;
+    string name = 2;
+    string address = 3;
+}
+
+message ExportResponse {
+    string export = 1;
+}
+
+message SignRequest {
+    string passphrase = 1;
+    string address = 2;
+    bytes hash = 3;
+}
+
+message SignResponse {
+    bytes signature = 1;
+    string curvetype = 2;
+}
+
+message VerifyRequest {
+    string curvetype = 1;
+    bytes pub = 2;
+    bytes hash = 3;
+    bytes signature = 4;
+}
+
+message HashRequest {
+    string hashtype = 1;
+    bytes message = 2;
+}
+
+message HashResponse {
+    string hash = 1;
+}
+
+message Key {
+    string address = 1;
+    string keyname = 2;
+}
+
+message ListResponse {
+    repeated Key key = 1;
+}
+
+message AddRequest {",,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191795632,https://github.com/hyperledger/burrow/pull/776#discussion_r191795632,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,`RemoveNameRequest`?,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:47:00,191797401,"@@ -0,0 +1,112 @@
+syntax = ""proto3"";
+
+package pbkeys;
+
+service Keys {
+    rpc GenerateKey(GenRequest) returns (GenResponse);
+    rpc PublicKey(PubRequest) returns (PubResponse);
+    rpc Sign(SignRequest) returns (SignResponse);
+    rpc Verify(VerifyRequest) returns (Empty);
+    rpc Import(ImportRequest) returns (ImportResponse);
+    rpc ImportJSON(ImportJSONRequest) returns (ImportResponse);
+    rpc Export(ExportRequest) returns (ExportResponse);
+    rpc Hash(HashRequest) returns (HashResponse);
+    rpc Remove(Name) returns (Empty);
+    rpc List(Name) returns (ListResponse);
+    rpc Add(AddRequest) returns (Empty);
+}
+
+message Name {",,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191797401,https://github.com/hyperledger/burrow/pull/776#discussion_r191797401,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,Can we nuke this global and have this passed in as an argument where needed. This obfuscated dependencies and breaks encapsulation,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:56:26,191801510,"@@ -0,0 +1,261 @@
+package keys
+
+import (
+	""context""
+	""crypto/sha256""
+	""fmt""
+	""hash""
+	""net""
+	""strings""
+
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/keys/pbkeys""
+	""golang.org/x/crypto/ripemd160""
+	""google.golang.org/grpc""
+)
+
+//------------------------------------------------------------------------
+// all cli commands pass through the http server
+// the server process also maintains the unlocked accounts
+
+type server struct{}
+
+var GlobalKeyServer server",,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191801510,https://github.com/hyperledger/burrow/pull/776#discussion_r191801510,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,Same as above...,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:57:42,191802032,"@@ -0,0 +1,261 @@
+package keys
+
+import (
+	""context""
+	""crypto/sha256""
+	""fmt""
+	""hash""
+	""net""
+	""strings""
+
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/keys/pbkeys""
+	""golang.org/x/crypto/ripemd160""
+	""google.golang.org/grpc""
+)
+
+//------------------------------------------------------------------------
+// all cli commands pass through the http server
+// the server process also maintains the unlocked accounts
+
+type server struct{}
+
+var GlobalKeyServer server
+
+func startServer() error {
+	if GlobalKeystore == nil {",,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191802032,https://github.com/hyperledger/burrow/pull/776#discussion_r191802032,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,I feel like this should be called something else like `NewServer` and should return the `server` instance containing the `keyStore`,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:57:43,191802043,"@@ -0,0 +1,261 @@
+package keys
+
+import (
+	""context""
+	""crypto/sha256""
+	""fmt""
+	""hash""
+	""net""
+	""strings""
+
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/keys/pbkeys""
+	""golang.org/x/crypto/ripemd160""
+	""google.golang.org/grpc""
+)
+
+//------------------------------------------------------------------------
+// all cli commands pass through the http server
+// the server process also maintains the unlocked accounts
+
+type server struct{}
+
+var GlobalKeyServer server
+
+func startServer() error {
+	if GlobalKeystore == nil {
+		ks, err := newKeyStore()
+		if err != nil {
+			return err
+		}
+
+		GlobalKeystore = ks
+	}
+	GlobalKeyServer = server{}
+
+	return nil
+}
+
+func StartGRPCServer(grpcserver *grpc.Server, keyConfig *KeysConfig) error {",,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191802043,https://github.com/hyperledger/burrow/pull/776#discussion_r191802043,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,"As it stands these methods could all be static - i.e. no receiver, but see below I think they should have an object and that should contain a reference to key store rather than global",37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:58:52,191802630,"@@ -0,0 +1,261 @@
+package keys
+
+import (
+	""context""
+	""crypto/sha256""
+	""fmt""
+	""hash""
+	""net""
+	""strings""
+
+	""github.com/hyperledger/burrow/crypto""
+	""github.com/hyperledger/burrow/keys/pbkeys""
+	""golang.org/x/crypto/ripemd160""
+	""google.golang.org/grpc""
+)
+
+//------------------------------------------------------------------------
+// all cli commands pass through the http server
+// the server process also maintains the unlocked accounts
+
+type server struct{}",,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191802630,https://github.com/hyperledger/burrow/pull/776#discussion_r191802630,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,Are we running this through Makfile?,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 14:59:56,191803094,"@@ -0,0 +1,143 @@
+#! /bin/bash
+set -e
+",,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191803094,https://github.com/hyperledger/burrow/pull/776#discussion_r191803094,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,This file can be deleted,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 15:00:17,191803224,"@@ -0,0 +1,58 @@
+#!/usr/bin/env bash
+# ----------------------------------------------------------
+# PURPOSE
+
+# This is the build script for the monax stack. It will
+# build the tool into docker containers in a reliable and
+# predicatable manner.
+
+# ----------------------------------------------------------
+# REQUIREMENTS
+
+# docker installed locally
+
+# ----------------------------------------------------------
+# USAGE
+
+# build_tool.sh
+
+# ----------------------------------------------------------
+
+TARGET=monax-keys
+IMAGE=quay.io/monax/keys",,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191803224,https://github.com/hyperledger/burrow/pull/776#discussion_r191803224,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,As comment above I think we can probably collapse these into a `ServerConfig` in `rpc/config.go`,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 15:01:40,191803754,"@@ -23,13 +24,20 @@ type ProfilerConfig struct {
 	ListenAddress string
 }
 
+type GRPCConfig struct {",,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191803754,https://github.com/hyperledger/burrow/pull/776#discussion_r191803754,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,We should possibly use `grpcServer.Stop()` here and wrap it as a `Process`,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 15:15:44,191808955,"@@ -199,6 +201,26 @@ func NewKernel(ctx context.Context, keyClient keys.KeyClient, privValidator tm_t
 				return serveProcess, nil
 			},
 		},
+		{
+			Name:     ""grpc service"",
+			Disabled: rpcConfig.GRPC.Disabled,
+			Launch: func() (process.Process, error) {
+				listen, err := net.Listen(""tcp"", rpcConfig.GRPC.ListenAddress)
+				if err != nil {
+					return nil, err
+				}
+
+				grpcServer := grpc.NewServer()
+				err = keys.StartGRPCServer(grpcServer, keyConfig)
+				if err != nil {
+					return nil, err
+				}
+
+				go grpcServer.Serve(listen)
+
+				return process.FromListeners(listen), nil",,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191808955,https://github.com/hyperledger/burrow/pull/776#discussion_r191808955,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,"In the burrow.toml we have:
  [[GenesisDoc.Accounts]]
    Address = ""D9131F3B458DAA2B7721AE51A25557A091B18DC1""
    PublicKey = ""{\""type\"":\""ed25519\"",\""data\"":\""AEE60D01DBD6C96A1294A52DCA59D90D2CE0E3FEB4739B56AECBA0ACF4C49F6D\""}""

This would become PublicKey = [1,""base64..==""]
Public keys are usually given hex encoded and the curvetype is not clear at all.",37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 19:30:11,191894266,"@@ -0,0 +1,351 @@
+package crypto
+
+import (
+	""bytes""
+	crand ""crypto/rand""
+	""crypto/sha256""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""io""
+
+	""golang.org/x/crypto/ripemd160""
+
+	""github.com/btcsuite/btcd/btcec""
+	tm_crypto ""github.com/tendermint/go-crypto""
+	""golang.org/x/crypto/ed25519""
+)
+
+type CurveType int8
+
+const (
+	CurveTypeSecp256k1 CurveType = iota
+	CurveTypeEd25519
+)
+
+func (k CurveType) String() string {
+	switch k {
+	case CurveTypeSecp256k1:
+		return ""secp256k1""
+	case CurveTypeEd25519:
+		return ""ed25519""
+	default:
+		return ""unknown""
+	}
+}
+
+func CurveTypeFromString(s string) (CurveType, error) {
+	switch s {
+	case ""secp256k1"":
+		return CurveTypeSecp256k1, nil
+	case ""ed25519"":
+		return CurveTypeEd25519, nil
+	default:
+		var k CurveType
+		return k, ErrInvalidCurve(s)
+	}
+}
+
+type ErrInvalidCurve string
+
+func (err ErrInvalidCurve) Error() string {
+	return fmt.Sprintf(""invalid curve type"")
+}
+
+// The types in this file allow us to control serialisation of keys and signatures, as well as the interface
+// exposed regardless of crypto library
+
+type Signer interface {
+	Sign(msg []byte) (Signature, error)
+}
+
+// PublicKey
+type PublicKey struct {
+	CurveType CurveType
+	PublicKey []byte
+}
+
+type PrivateKey struct {
+	CurveType  CurveType
+	PublicKey  []byte
+	PrivateKey []byte
+}
+
+type PublicKeyJSON struct {",84,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191894266,https://github.com/hyperledger/burrow/pull/776#discussion_r191894266,seanyoung
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,exactly. Using the passphrase with the keys client needs more thought. ,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 20:08:25,191905915,"@@ -0,0 +1,76 @@
+package keys
+
+import (
+	""github.com/hyperledger/burrow/crypto""
+)
+
+type Key struct {
+	CurveType  crypto.CurveType
+	Address    crypto.Address
+	PublicKey  crypto.PublicKey
+	PrivateKey crypto.PrivateKey
+}
+
+func NewKey(typ crypto.CurveType) (*Key, error) {
+	privKey, err := crypto.GeneratePrivateKey(nil, typ)
+	if err != nil {
+		return nil, err
+	}
+	pubKey := privKey.GetPublicKey()
+	return &Key{
+		CurveType:  typ,
+		PublicKey:  pubKey,
+		Address:    pubKey.Address(),
+		PrivateKey: privKey,
+	}, nil
+}
+
+func (k *Key) Pubkey() []byte {
+	return k.PublicKey.RawBytes()
+}
+
+func NewKeyFromPub(curveType crypto.CurveType, PubKeyBytes []byte) (*Key, error) {
+	pubKey, err := crypto.PublicKeyFromBytes(PubKeyBytes, curveType)
+	if err != nil {
+		return nil, err
+	}
+
+	return &Key{
+		CurveType: curveType,
+		PublicKey: pubKey,
+		Address:   pubKey.Address(),
+	}, nil
+}
+
+func NewKeyFromPriv(curveType crypto.CurveType, PrivKeyBytes []byte) (*Key, error) {
+	privKey, err := crypto.PrivateKeyFromRawBytes(PrivKeyBytes, curveType)
+
+	if err != nil {
+		return nil, err
+	}
+
+	pubKey := privKey.GetPublicKey()
+
+	return &Key{
+		CurveType:  curveType,
+		Address:    pubKey.Address(),
+		PublicKey:  pubKey,
+		PrivateKey: privKey,
+	}, nil
+}
+
+type KeyStore interface {
+	GenerateKey(passphrase string, curveType crypto.CurveType) (*Key, error)",,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191905915,https://github.com/hyperledger/burrow/pull/776#discussion_r191905915,seanyoung
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,"We have GRPC server, and the KeysConfig.ServerEnabled sets whether the keys service is registered to the GRPC service. I've renamed it to ""GRPCServiceEnabled"".",37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-30 20:14:08,191907545,"@@ -1,12 +1,14 @@
 package keys
 
 type KeysConfig struct {
-	URL string
+	ServerEnabled bool
+	URL           string
 }
 
 func DefaultKeysConfig() *KeysConfig {
 	return &KeysConfig{
 		// Default Monax keys port
-		URL: ""http://localhost:4767"",
+		ServerEnabled: true,
+		URL:           """",
 	}",,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/191907545,https://github.com/hyperledger/burrow/pull/776#discussion_r191907545,seanyoung
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,"The alternative would be to define:
```go
type KeyBytes []byte

type PrivateKey struct {
	CurveType  CurveType
	PublicKey  KeyBytes
	PrivateKey KeyBytes
}
```

Ane then define `MarshalJSON` and `UnmarshalJSON` for `KeyBytes` and `CurveType` - that we we can get consistent serialisation whereever we use them and we lose the extra struct. I'd also rather stick with ""CurveType"" and ""PublicKey"" instead of ""type"" and ""data"".... but if we drop the struct we get that anyway. We can scrap the marshla methods for public key and it will work for private key.",37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-31 20:55:49,192234646,"@@ -0,0 +1,351 @@
+package crypto
+
+import (
+	""bytes""
+	crand ""crypto/rand""
+	""crypto/sha256""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""io""
+
+	""golang.org/x/crypto/ripemd160""
+
+	""github.com/btcsuite/btcd/btcec""
+	tm_crypto ""github.com/tendermint/go-crypto""
+	""golang.org/x/crypto/ed25519""
+)
+
+type CurveType int8
+
+const (
+	CurveTypeSecp256k1 CurveType = iota
+	CurveTypeEd25519
+)
+
+func (k CurveType) String() string {
+	switch k {
+	case CurveTypeSecp256k1:
+		return ""secp256k1""
+	case CurveTypeEd25519:
+		return ""ed25519""
+	default:
+		return ""unknown""
+	}
+}
+
+func CurveTypeFromString(s string) (CurveType, error) {
+	switch s {
+	case ""secp256k1"":
+		return CurveTypeSecp256k1, nil
+	case ""ed25519"":
+		return CurveTypeEd25519, nil
+	default:
+		var k CurveType
+		return k, ErrInvalidCurve(s)
+	}
+}
+
+type ErrInvalidCurve string
+
+func (err ErrInvalidCurve) Error() string {
+	return fmt.Sprintf(""invalid curve type"")
+}
+
+// The types in this file allow us to control serialisation of keys and signatures, as well as the interface
+// exposed regardless of crypto library
+
+type Signer interface {
+	Sign(msg []byte) (Signature, error)
+}
+
+// PublicKey
+type PublicKey struct {
+	CurveType CurveType
+	PublicKey []byte
+}
+
+type PrivateKey struct {
+	CurveType  CurveType
+	PublicKey  []byte
+	PrivateKey []byte
+}
+
+type PublicKeyJSON struct {",84,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/192234646,https://github.com/hyperledger/burrow/pull/776#discussion_r192234646,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,@seanyoung bump,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-31 20:58:23,192235343,"@@ -0,0 +1,112 @@
+syntax = ""proto3"";
+
+package pbkeys;
+
+service Keys {
+    rpc GenerateKey(GenRequest) returns (GenResponse);
+    rpc PublicKey(PubRequest) returns (PubResponse);
+    rpc Sign(SignRequest) returns (SignResponse);
+    rpc Verify(VerifyRequest) returns (Empty);
+    rpc Import(ImportRequest) returns (ImportResponse);
+    rpc ImportJSON(ImportJSONRequest) returns (ImportResponse);
+    rpc Export(ExportRequest) returns (ExportResponse);
+    rpc Hash(HashRequest) returns (HashResponse);
+    rpc Remove(Name) returns (Empty);
+    rpc List(Name) returns (ListResponse);
+    rpc Add(AddRequest) returns (Empty);
+}
+
+message Name {
+    string keyname = 1;
+}
+
+message Empty {
+
+}
+
+message GenRequest {
+    string passphrase = 1;
+    string curvetype = 2;
+    string keyname = 3;
+}
+
+message GenResponse {
+    string address = 1;
+}
+
+message PubRequest {
+    string address = 1;
+    string name = 2;
+} 
+
+message PubResponse {
+    bytes pub = 1;
+    string curvetype = 2;
+}
+
+message ImportJSONRequest {
+    string passphrase = 1;
+    string JSON = 2;
+}
+
+message ImportResponse {
+    string address = 1;
+}
+
+message ImportRequest {
+    string passphrase = 1;
+    string name = 2;
+    string curvetype = 3;
+    bytes keybytes = 4;
+}
+
+message ExportRequest {
+    string passphrase = 1;
+    string name = 2;
+    string address = 3;
+}
+
+message ExportResponse {
+    string export = 1;
+}
+
+message SignRequest {
+    string passphrase = 1;
+    string address = 2;
+    bytes hash = 3;
+}
+
+message SignResponse {
+    bytes signature = 1;
+    string curvetype = 2;
+}
+
+message VerifyRequest {
+    string curvetype = 1;
+    bytes pub = 2;
+    bytes hash = 3;
+    bytes signature = 4;
+}
+
+message HashRequest {
+    string hashtype = 1;
+    bytes message = 2;
+}
+
+message HashResponse {
+    string hash = 1;
+}
+
+message Key {
+    string address = 1;
+    string keyname = 2;
+}
+
+message ListResponse {
+    repeated Key key = 1;
+}
+
+message AddRequest {",,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/192235343,https://github.com/hyperledger/burrow/pull/776#discussion_r192235343,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,@seanyoung bump,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-05-31 20:58:31,192235384,"@@ -0,0 +1,112 @@
+syntax = ""proto3"";
+
+package pbkeys;
+
+service Keys {
+    rpc GenerateKey(GenRequest) returns (GenResponse);
+    rpc PublicKey(PubRequest) returns (PubResponse);
+    rpc Sign(SignRequest) returns (SignResponse);
+    rpc Verify(VerifyRequest) returns (Empty);
+    rpc Import(ImportRequest) returns (ImportResponse);
+    rpc ImportJSON(ImportJSONRequest) returns (ImportResponse);
+    rpc Export(ExportRequest) returns (ExportResponse);
+    rpc Hash(HashRequest) returns (HashResponse);
+    rpc Remove(Name) returns (Empty);
+    rpc List(Name) returns (ListResponse);
+    rpc Add(AddRequest) returns (Empty);
+}
+
+message Name {",,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/192235384,https://github.com/hyperledger/burrow/pull/776#discussion_r192235384,silasdavis
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,"So with:
```
// PublicKey
type PublicKey struct {
    CurveType CurveType
    PublicKey KeyBytes
}

func (p PublicKey) MarshalText() ([]byte, error) {
    return json.Marshal(p)
}

func (p *PublicKey) UnmarshalText(text []byte) error {
    return json.Unmarshal(text, p)
}
```

We have two problems. I:
MarshalText() gets into an infinite recursion, since json.Marshal() will call MarshallText() on publickey if MarshalJSON() is not defined. The burntsushi toml unmarshaller directly calls MarshalText(), so the only solution I can think of is:
```
func (p *PublicKey) MarshalJSON() ([]byte, error) {
	// Declare anonymous struct, since json.Marshal(p) would end up calling MarshalText()
	return json.Marshal(struct {
		CurveType CurveType
		PublicKey KeyBytes
	}{p.CurveType, p.PublicKey})
}
```
Problem II:
The json unmarshalling code will attempt UnmarshalText() if that is defined (and UnmarshalJSON is not). This will fail since the input is an object, not a string and the decoder will err out with ""json: cannot unmarshal object into Go struct field TxInput.PublicKey of type crypto.PublicKey""
Solution: define a non-recursive UnmarshalJSON():

```
func (p *PublicKey) UnmarshalJSON(text []byte) error {
	// Declare anonymous struct, since json.Marshal(p) would end up calling MarshalText()
	j := struct {
		CurveType CurveType
		PublicKey KeyBytes
	}{}

	err := json.Unmarshal(text, &j)
	if err != nil {
		return err
	}

	p.CurveType = j.CurveType
	p.PublicKey = j.PublicKey

	return nil
}
```
I could not find any other solutions with are less hideous (we could have a PublicKeyJSON struct like the one we had before.

I suggest that we keep code as proposed -- except renaming the Type/Data to CurveType and PublicKey.",37cfa35454942715f5ff54695a43a5e12e35fc97,2018-06-01 13:08:51,192390009,"@@ -0,0 +1,351 @@
+package crypto
+
+import (
+	""bytes""
+	crand ""crypto/rand""
+	""crypto/sha256""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""io""
+
+	""golang.org/x/crypto/ripemd160""
+
+	""github.com/btcsuite/btcd/btcec""
+	tm_crypto ""github.com/tendermint/go-crypto""
+	""golang.org/x/crypto/ed25519""
+)
+
+type CurveType int8
+
+const (
+	CurveTypeSecp256k1 CurveType = iota
+	CurveTypeEd25519
+)
+
+func (k CurveType) String() string {
+	switch k {
+	case CurveTypeSecp256k1:
+		return ""secp256k1""
+	case CurveTypeEd25519:
+		return ""ed25519""
+	default:
+		return ""unknown""
+	}
+}
+
+func CurveTypeFromString(s string) (CurveType, error) {
+	switch s {
+	case ""secp256k1"":
+		return CurveTypeSecp256k1, nil
+	case ""ed25519"":
+		return CurveTypeEd25519, nil
+	default:
+		var k CurveType
+		return k, ErrInvalidCurve(s)
+	}
+}
+
+type ErrInvalidCurve string
+
+func (err ErrInvalidCurve) Error() string {
+	return fmt.Sprintf(""invalid curve type"")
+}
+
+// The types in this file allow us to control serialisation of keys and signatures, as well as the interface
+// exposed regardless of crypto library
+
+type Signer interface {
+	Sign(msg []byte) (Signature, error)
+}
+
+// PublicKey
+type PublicKey struct {
+	CurveType CurveType
+	PublicKey []byte
+}
+
+type PrivateKey struct {
+	CurveType  CurveType
+	PublicKey  []byte
+	PrivateKey []byte
+}
+
+type PublicKeyJSON struct {",84,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/192390009,https://github.com/hyperledger/burrow/pull/776#discussion_r192390009,seanyoung
https://github.com/hyperledger/burrow/pull/776,https://github.com/hyperledger/burrow/pull/776,This is showing the old code. What have I done to make this review so messed up?,37cfa35454942715f5ff54695a43a5e12e35fc97,2018-06-01 13:36:32,192397896,"@@ -0,0 +1,112 @@
+syntax = ""proto3"";
+
+package pbkeys;
+
+service Keys {
+    rpc GenerateKey(GenRequest) returns (GenResponse);
+    rpc PublicKey(PubRequest) returns (PubResponse);
+    rpc Sign(SignRequest) returns (SignResponse);
+    rpc Verify(VerifyRequest) returns (Empty);
+    rpc Import(ImportRequest) returns (ImportResponse);
+    rpc ImportJSON(ImportJSONRequest) returns (ImportResponse);
+    rpc Export(ExportRequest) returns (ExportResponse);
+    rpc Hash(HashRequest) returns (HashResponse);
+    rpc Remove(Name) returns (Empty);
+    rpc List(Name) returns (ListResponse);
+    rpc Add(AddRequest) returns (Empty);
+}
+
+message Name {
+    string keyname = 1;
+}
+
+message Empty {
+
+}
+
+message GenRequest {
+    string passphrase = 1;
+    string curvetype = 2;
+    string keyname = 3;
+}
+
+message GenResponse {
+    string address = 1;
+}
+
+message PubRequest {
+    string address = 1;
+    string name = 2;
+} 
+
+message PubResponse {
+    bytes pub = 1;
+    string curvetype = 2;
+}
+
+message ImportJSONRequest {
+    string passphrase = 1;
+    string JSON = 2;
+}
+
+message ImportResponse {
+    string address = 1;
+}
+
+message ImportRequest {
+    string passphrase = 1;
+    string name = 2;
+    string curvetype = 3;
+    bytes keybytes = 4;
+}
+
+message ExportRequest {
+    string passphrase = 1;
+    string name = 2;
+    string address = 3;
+}
+
+message ExportResponse {
+    string export = 1;
+}
+
+message SignRequest {
+    string passphrase = 1;
+    string address = 2;
+    bytes hash = 3;
+}
+
+message SignResponse {
+    bytes signature = 1;
+    string curvetype = 2;
+}
+
+message VerifyRequest {
+    string curvetype = 1;
+    bytes pub = 2;
+    bytes hash = 3;
+    bytes signature = 4;
+}
+
+message HashRequest {
+    string hashtype = 1;
+    bytes message = 2;
+}
+
+message HashResponse {
+    string hash = 1;
+}
+
+message Key {
+    string address = 1;
+    string keyname = 2;
+}
+
+message ListResponse {
+    repeated Key key = 1;
+}
+
+message AddRequest {",,2018-06-01 13:37:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/192397896,https://github.com/hyperledger/burrow/pull/776#discussion_r192397896,seanyoung
https://github.com/hyperledger/burrow/pull/767,https://github.com/hyperledger/burrow/pull/767,Drop the getter and setter - it is more idiomatic and simpler to for us to reference `returnData` directly,01f71e7a492321c5cc904664691538ae5e165a6c,2018-05-14 11:28:01,187917502,"@@ -145,6 +147,14 @@ func (vm *VM) SetPublisher(publisher event.Publisher) {
 	vm.publisher = publisher
 }
 
+func (vm *VM) setReturnDataBuffer(ret []byte) {",,2018-05-14 19:52:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/187917502,https://github.com/hyperledger/burrow/pull/767#discussion_r187917502,silasdavis
https://github.com/hyperledger/burrow/pull/767,https://github.com/hyperledger/burrow/pull/767,This too,01f71e7a492321c5cc904664691538ae5e165a6c,2018-05-14 11:28:20,187917604,"@@ -145,6 +147,14 @@ func (vm *VM) SetPublisher(publisher event.Publisher) {
 	vm.publisher = publisher
 }
 
+func (vm *VM) setReturnDataBuffer(ret []byte) {
+	vm.returnData = ret
+}
+
+func (vm *VM) getReturnDataBuffer() (ret []byte) {",,2018-05-14 19:52:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/187917604,https://github.com/hyperledger/burrow/pull/767#discussion_r187917604,silasdavis
https://github.com/hyperledger/burrow/pull/767,https://github.com/hyperledger/burrow/pull/767,"When there is an exception After line 912 we need:

```go
vm.returnData = ret
```
since the EIP states:
> As an exception, CREATE and CREATE2 are considered to return the empty buffer in the success case and the failure data in the failure case

I also note that while I think you are following the spec here, geth and eth-cpp appear to always return what CREATE returns. Will mull this over.

However we should be clearing the buffer when we enter `CREATE` on line 879. Also there is no need to create an empty buffer, just use nil:

```go
vm.returnData = nil
```

And remove the clearing of the buffer where you currently have it. Either we will have set the buffer to ret on failure or it will be empty anyway.",01f71e7a492321c5cc904664691538ae5e165a6c,2018-05-14 12:20:51,187932351,"@@ -871,6 +913,8 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			} else {
 				newAccount.SetCode(ret) // Set the code (ret need not be copied as per Call contract)
 				stack.Push(newAccount.Address().Word256())
+				emptyBuffer := []byte{}
+				vm.setReturnDataBuffer(emptyBuffer)",,2018-05-14 19:52:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/187932351,https://github.com/hyperledger/burrow/pull/767#discussion_r187932351,silasdavis
https://github.com/hyperledger/burrow/pull/767,https://github.com/hyperledger/burrow/pull/767,"remove these in favour of setting once after this block. It's simpler and clearer and currently we are not capturing return data from native contracts, which we want to do.",01f71e7a492321c5cc904664691538ae5e165a6c,2018-05-14 12:27:12,187934145,"@@ -955,11 +999,13 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 						return nil, firstErr(callErr, ErrUnknownAddress)
 					}
 					ret, callErr = vm.Call(callee, callee, acc.Code(), args, value, &gasLimit)
+					vm.setReturnDataBuffer(ret)",,2018-05-14 19:52:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/187934145,https://github.com/hyperledger/burrow/pull/767#discussion_r187934145,silasdavis
https://github.com/hyperledger/burrow/pull/767,https://github.com/hyperledger/burrow/pull/767,remove,01f71e7a492321c5cc904664691538ae5e165a6c,2018-05-14 12:27:17,187934174,"@@ -955,11 +999,13 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 						return nil, firstErr(callErr, ErrUnknownAddress)
 					}
 					ret, callErr = vm.Call(callee, callee, acc.Code(), args, value, &gasLimit)
+					vm.setReturnDataBuffer(ret)
 				} else if op == DELEGATECALL {
 					if acc == nil {
 						return nil, firstErr(callErr, ErrUnknownAddress)
 					}
 					ret, callErr = vm.DelegateCall(caller, callee, acc.Code(), args, value, &gasLimit)
+					vm.setReturnDataBuffer(ret)",,2018-05-14 19:52:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/187934174,https://github.com/hyperledger/burrow/pull/767#discussion_r187934174,silasdavis
https://github.com/hyperledger/burrow/pull/767,https://github.com/hyperledger/burrow/pull/767,remove,01f71e7a492321c5cc904664691538ae5e165a6c,2018-05-14 12:27:22,187934199,"@@ -971,6 +1017,7 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 					// add account to the tx cache
 					vm.stateWriter.UpdateAccount(acc)
 					ret, callErr = vm.Call(callee, acc, acc.Code(), args, value, &gasLimit)
+					vm.setReturnDataBuffer(ret)",,2018-05-14 19:52:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/187934199,https://github.com/hyperledger/burrow/pull/767#discussion_r187934199,silasdavis
https://github.com/hyperledger/burrow/pull/767,https://github.com/hyperledger/burrow/pull/767,"Add `vm.returnData = ret` here in place of removed setters above

We also need to clear the buffer on entry to `CALL*` on line 925 with `vm.returnData = nil` (a lot of the time this won't matter, but catches some edges cases on early return and matches the spec more clearly)",01f71e7a492321c5cc904664691538ae5e165a6c,2018-05-14 12:27:33,187934246,"@@ -971,6 +1017,7 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 					// add account to the tx cache
 					vm.stateWriter.UpdateAccount(acc)
 					ret, callErr = vm.Call(callee, acc, acc.Code(), args, value, &gasLimit)
+					vm.setReturnDataBuffer(ret)
 				}
 			}
 			// In case any calls deeper in the stack (particularly SNatives) has altered either of two accounts to which",,2018-05-14 19:52:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/187934246,https://github.com/hyperledger/burrow/pull/767#discussion_r187934246,silasdavis
https://github.com/hyperledger/burrow/pull/767,https://github.com/hyperledger/burrow/pull/767,Use `PopBigInt` here,01f71e7a492321c5cc904664691538ae5e165a6c,2018-05-14 12:29:34,187934757,"@@ -666,6 +676,38 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			}
 			vm.Debugf("" => [%v, %v, %v] %X\n"", memOff, codeOff, length, data)
 
+		case RETURNDATASIZE: // 0x3D
+			stack.Push64(int64(len(vm.getReturnDataBuffer())))
+			vm.Debugf("" => %d\n"", len(vm.getReturnDataBuffer()))
+
+		case RETURNDATACOPY: // 0x3E
+			memOff := stack.PopBigInt()
+			outputOff, popErr := stack.Pop64()",,2018-05-14 19:52:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/187934757,https://github.com/hyperledger/burrow/pull/767#discussion_r187934757,silasdavis
https://github.com/hyperledger/burrow/pull/767,https://github.com/hyperledger/burrow/pull/767,Use `PopBigInt` here too,01f71e7a492321c5cc904664691538ae5e165a6c,2018-05-14 12:29:47,187934820,"@@ -666,6 +676,38 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			}
 			vm.Debugf("" => [%v, %v, %v] %X\n"", memOff, codeOff, length, data)
 
+		case RETURNDATASIZE: // 0x3D
+			stack.Push64(int64(len(vm.getReturnDataBuffer())))
+			vm.Debugf("" => %d\n"", len(vm.getReturnDataBuffer()))
+
+		case RETURNDATACOPY: // 0x3E
+			memOff := stack.PopBigInt()
+			outputOff, popErr := stack.Pop64()
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}
+			length, popErr := stack.Pop64()",,2018-05-14 19:52:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/187934820,https://github.com/hyperledger/burrow/pull/767#discussion_r187934820,silasdavis
https://github.com/hyperledger/burrow/pull/767,https://github.com/hyperledger/burrow/pull/767,"So I don't think this will matter in practice, at least not now, but I think strictly we should clear the `returnData` at the beginning of the frame, i.e. right after `CREATE:`. Doing this also makes us consistent with the other implementations.",01f71e7a492321c5cc904664691538ae5e165a6c,2018-05-14 18:10:10,188047272,"@@ -853,6 +877,8 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 				return nil, firstErr(err, ErrInsufficientBalance)
 			}
 
+			vm.returnData = nil",,2018-05-14 19:52:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/188047272,https://github.com/hyperledger/burrow/pull/767#discussion_r188047272,silasdavis
https://github.com/hyperledger/burrow/pull/767,https://github.com/hyperledger/burrow/pull/767,"here too, I just think it's marginally better immediately once we enter this case block.",01f71e7a492321c5cc904664691538ae5e165a6c,2018-05-14 18:10:38,188047411,"@@ -897,6 +923,8 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 					return nil, firstErr(err, popErr)
 				}
 			}
+
+			vm.returnData = nil",,2018-05-14 19:52:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/188047411,https://github.com/hyperledger/burrow/pull/767#discussion_r188047411,silasdavis
https://github.com/hyperledger/burrow/pull/757,https://github.com/hyperledger/burrow/pull/757,"This has the potential to read as 'an opcode we don't know about', when it means 'abort the execution'. I'd be tempted to suggest: `ErrExecutionAborted = errors.New(""Execution aborted"")`.",a647541dec18c1766e7c2cfc17051c173396f273,2018-05-08 13:31:29,186727129,"@@ -48,6 +48,7 @@ var (
 	ErrDataStackUnderflow     = errors.New(""Data stack underflow"")
 	ErrInvalidContract        = errors.New(""Invalid contract"")
 	ErrNativeContractCodeCopy = errors.New(""Tried to copy native contract code"")
+	ErrInvalidOpcode          = errors.New(""Invalid opcode"")",,2018-05-08 17:39:46,https://api.github.com/repos/hyperledger/burrow/pulls/comments/186727129,https://github.com/hyperledger/burrow/pull/757#discussion_r186727129,silasdavis
https://github.com/hyperledger/burrow/pull/757,https://github.com/hyperledger/burrow/pull/757,"Let's `assert.Equal(t, ErrInvalidOpcode, err)` here seeing as we have declared error values.",a647541dec18c1766e7c2cfc17051c173396f273,2018-05-08 13:32:25,186727414,"@@ -374,6 +374,25 @@ func TestMsgSender(t *testing.T) {
 
 }
 
+func TestInvalid(t *testing.T) {
+	ourVm := NewVM(newAppState(), newParams(), acm.ZeroAddress, nil, logger)
+
+	// Create accounts
+	account1 := newAccount(1)
+	account2 := newAccount(1, 0, 1)
+
+	var gas uint64 = 100000
+
+	bytecode := MustSplice(PUSH32, 0x72, 0x65, 0x76, 0x65, 0x72, 0x74, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61,
+		0x67, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, PUSH1, 0x00, MSTORE, PUSH1, 0x0E, PUSH1, 0x00, INVALID)
+
+	output, err := ourVm.Call(account1, account2, bytecode, []byte{}, 0, &gas)
+	assert.Error(t, err, ""Expected invalid opcode error"")",,2018-05-08 17:39:46,https://api.github.com/repos/hyperledger/burrow/pulls/comments/186727414,https://github.com/hyperledger/burrow/pull/757#discussion_r186727414,silasdavis
https://github.com/hyperledger/burrow/pull/757,https://github.com/hyperledger/burrow/pull/757,:+1:  I prefer 'unknown' here,a647541dec18c1766e7c2cfc17051c173396f273,2018-05-08 13:34:17,186728027,"@@ -1078,8 +1082,8 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 		case STATICCALL, SHL, SHR, SAR, RETURNDATASIZE, RETURNDATACOPY:
 			return nil, fmt.Errorf(""%s not yet implemented"", op.Name())
 		default:
-			vm.Debugf(""(pc) %-3v Invalid opcode %X\n"", pc, op)
-			return nil, fmt.Errorf(""invalid opcode %X"", op)
+			vm.Debugf(""(pc) %-3v Unknown opcode %X\n"", pc, op)",24,2018-05-08 17:39:46,https://api.github.com/repos/hyperledger/burrow/pulls/comments/186728027,https://github.com/hyperledger/burrow/pull/757#discussion_r186728027,silasdavis
https://github.com/hyperledger/burrow/pull/751,https://github.com/hyperledger/burrow/pull/751,"If uint is 32 bit, then this statement truncates. Best to compare shift to 256, and cast to uint on the call to value.Lsh()",e8dafacfa779f94ce21100ba7ff05383791d31ab,2018-05-02 09:34:27,185441080,"@@ -493,6 +493,75 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			stack.Push64(int64(res))
 			vm.Debugf("" => 0x%X\n"", res)
 
+		case SHL: //0x1B
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}
+
+			sh := uint(shift)",,2018-05-07 14:59:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/185441080,https://github.com/hyperledger/burrow/pull/751#discussion_r185441080,seanyoung
https://github.com/hyperledger/burrow/pull/751,https://github.com/hyperledger/burrow/pull/751,Same as before,e8dafacfa779f94ce21100ba7ff05383791d31ab,2018-05-02 09:34:43,185441146,"@@ -493,6 +493,75 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			stack.Push64(int64(res))
 			vm.Debugf("" => 0x%X\n"", res)
 
+		case SHL: //0x1B
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}
+
+			sh := uint(shift)
+
+			value := stack.PopBigInt()
+
+			if sh >= 256 {
+				overFlow := big.NewInt(0)
+				stack.PushBigInt(overFlow)
+				vm.Debugf("" %X << %X = %X\n"", value, sh, overFlow)
+			} else {
+				shiftedValue := value.Lsh(value, sh)
+				stack.PushBigInt(shiftedValue)
+				vm.Debugf("" %X << %X = %X\n"", value, sh, shiftedValue)
+			}
+
+		case SHR: //0x1C
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}
+
+			sh := uint(shift)",,2018-05-07 14:59:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/185441146,https://github.com/hyperledger/burrow/pull/751#discussion_r185441146,seanyoung
https://github.com/hyperledger/burrow/pull/751,https://github.com/hyperledger/burrow/pull/751,"Rather than comparing to zeroInt, just call ""value.Sign() >= 0""",e8dafacfa779f94ce21100ba7ff05383791d31ab,2018-05-02 09:35:20,185441285,"@@ -493,6 +493,75 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			stack.Push64(int64(res))
 			vm.Debugf("" => 0x%X\n"", res)
 
+		case SHL: //0x1B
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}
+
+			sh := uint(shift)
+
+			value := stack.PopBigInt()
+
+			if sh >= 256 {
+				overFlow := big.NewInt(0)
+				stack.PushBigInt(overFlow)
+				vm.Debugf("" %X << %X = %X\n"", value, sh, overFlow)
+			} else {
+				shiftedValue := value.Lsh(value, sh)
+				stack.PushBigInt(shiftedValue)
+				vm.Debugf("" %X << %X = %X\n"", value, sh, shiftedValue)
+			}
+
+		case SHR: //0x1C
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}
+
+			sh := uint(shift)
+
+			value := stack.PopBigInt()
+
+			if sh >= 256 {
+				underFlow := big.NewInt(0)
+				stack.PushBigInt(underFlow)
+				vm.Debugf("" %X << %X = %X\n"", value, sh, underFlow)
+			} else {
+				shiftedValue := value.Rsh(value, sh)
+				stack.PushBigInt(shiftedValue)
+				vm.Debugf("" %X << %X = %X\n"", value, sh, shiftedValue)
+			}
+
+		case SAR: //0x1D
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}
+
+			sh := uint(shift)
+
+			value := stack.PopBigIntSigned()
+			zeroInt := big.NewInt(0)
+
+			if sh >= 256 && value.Cmp(zeroInt) >= 0 {",,2018-05-07 14:59:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/185441285,https://github.com/hyperledger/burrow/pull/751#discussion_r185441285,seanyoung
https://github.com/hyperledger/burrow/pull/751,https://github.com/hyperledger/burrow/pull/751,value.Sign() < 0,e8dafacfa779f94ce21100ba7ff05383791d31ab,2018-05-02 09:35:36,185441343,"@@ -493,6 +493,75 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			stack.Push64(int64(res))
 			vm.Debugf("" => 0x%X\n"", res)
 
+		case SHL: //0x1B
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}
+
+			sh := uint(shift)
+
+			value := stack.PopBigInt()
+
+			if sh >= 256 {
+				overFlow := big.NewInt(0)
+				stack.PushBigInt(overFlow)
+				vm.Debugf("" %X << %X = %X\n"", value, sh, overFlow)
+			} else {
+				shiftedValue := value.Lsh(value, sh)
+				stack.PushBigInt(shiftedValue)
+				vm.Debugf("" %X << %X = %X\n"", value, sh, shiftedValue)
+			}
+
+		case SHR: //0x1C
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}
+
+			sh := uint(shift)
+
+			value := stack.PopBigInt()
+
+			if sh >= 256 {
+				underFlow := big.NewInt(0)
+				stack.PushBigInt(underFlow)
+				vm.Debugf("" %X << %X = %X\n"", value, sh, underFlow)
+			} else {
+				shiftedValue := value.Rsh(value, sh)
+				stack.PushBigInt(shiftedValue)
+				vm.Debugf("" %X << %X = %X\n"", value, sh, shiftedValue)
+			}
+
+		case SAR: //0x1D
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}
+
+			sh := uint(shift)
+
+			value := stack.PopBigIntSigned()
+			zeroInt := big.NewInt(0)
+
+			if sh >= 256 && value.Cmp(zeroInt) >= 0 {
+				reset := big.NewInt(0)
+				stack.PushBigInt(reset)
+				vm.Debugf("" %X << %X = %X\n"", value, sh, reset)
+			}
+			if sh >= 256 && value.Cmp(zeroInt) < 0 {",,2018-05-07 14:59:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/185441343,https://github.com/hyperledger/burrow/pull/751#discussion_r185441343,seanyoung
https://github.com/hyperledger/burrow/pull/751,https://github.com/hyperledger/burrow/pull/751,remove cast here,e8dafacfa779f94ce21100ba7ff05383791d31ab,2018-05-02 09:36:11,185441474,"@@ -493,6 +493,75 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			stack.Push64(int64(res))
 			vm.Debugf("" => 0x%X\n"", res)
 
+		case SHL: //0x1B
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}
+
+			sh := uint(shift)
+
+			value := stack.PopBigInt()
+
+			if sh >= 256 {
+				overFlow := big.NewInt(0)
+				stack.PushBigInt(overFlow)
+				vm.Debugf("" %X << %X = %X\n"", value, sh, overFlow)
+			} else {
+				shiftedValue := value.Lsh(value, sh)
+				stack.PushBigInt(shiftedValue)
+				vm.Debugf("" %X << %X = %X\n"", value, sh, shiftedValue)
+			}
+
+		case SHR: //0x1C
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}
+
+			sh := uint(shift)
+
+			value := stack.PopBigInt()
+
+			if sh >= 256 {
+				underFlow := big.NewInt(0)
+				stack.PushBigInt(underFlow)
+				vm.Debugf("" %X << %X = %X\n"", value, sh, underFlow)
+			} else {
+				shiftedValue := value.Rsh(value, sh)
+				stack.PushBigInt(shiftedValue)
+				vm.Debugf("" %X << %X = %X\n"", value, sh, shiftedValue)
+			}
+
+		case SAR: //0x1D
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}
+
+			sh := uint(shift)",,2018-05-07 14:59:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/185441474,https://github.com/hyperledger/burrow/pull/751#discussion_r185441474,seanyoung
https://github.com/hyperledger/burrow/pull/751,https://github.com/hyperledger/burrow/pull/751,"According to EIP-145, any shift value > 256 should result in 0. This code returns an error if the shift value > 2^64.",e8dafacfa779f94ce21100ba7ff05383791d31ab,2018-05-02 15:29:40,185538755,"@@ -493,6 +493,68 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			stack.Push64(int64(res))
 			vm.Debugf("" => 0x%X\n"", res)
 
+		case SHL: //0x1B
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)",,2018-05-07 14:59:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/185538755,https://github.com/hyperledger/burrow/pull/751#discussion_r185538755,seanyoung
https://github.com/hyperledger/burrow/pull/751,https://github.com/hyperledger/burrow/pull/751,"According to EIP-145, any shift value > 256 should result in 0. This code returns an error if the shift value > 2^64.
",e8dafacfa779f94ce21100ba7ff05383791d31ab,2018-05-02 15:30:03,185538906,"@@ -493,6 +493,68 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			stack.Push64(int64(res))
 			vm.Debugf("" => 0x%X\n"", res)
 
+		case SHL: //0x1B
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}
+
+			value := stack.PopBigInt()
+
+			if shift >= 256 {
+				overFlow := big.NewInt(0)
+				stack.PushBigInt(overFlow)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, overFlow)
+			} else {
+				shiftedValue := value.Lsh(value, uint(shift))
+				stack.PushBigInt(shiftedValue)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, shiftedValue)
+			}
+
+		case SHR: //0x1C
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}",,2018-05-07 14:59:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/185538906,https://github.com/hyperledger/burrow/pull/751#discussion_r185538906,seanyoung
https://github.com/hyperledger/burrow/pull/751,https://github.com/hyperledger/burrow/pull/751,"According to EIP-145, any shift value > 256 should result in 0. This code returns an error if the shift value > 2^64.
",e8dafacfa779f94ce21100ba7ff05383791d31ab,2018-05-02 15:30:13,185538994,"@@ -493,6 +493,68 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			stack.Push64(int64(res))
 			vm.Debugf("" => 0x%X\n"", res)
 
+		case SHL: //0x1B
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}
+
+			value := stack.PopBigInt()
+
+			if shift >= 256 {
+				overFlow := big.NewInt(0)
+				stack.PushBigInt(overFlow)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, overFlow)
+			} else {
+				shiftedValue := value.Lsh(value, uint(shift))
+				stack.PushBigInt(shiftedValue)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, shiftedValue)
+			}
+
+		case SHR: //0x1C
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}
+
+			value := stack.PopBigInt()
+
+			if shift >= 256 {
+				underFlow := big.NewInt(0)
+				stack.PushBigInt(underFlow)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, underFlow)
+			} else {
+				shiftedValue := value.Rsh(value, uint(shift))
+				stack.PushBigInt(shiftedValue)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, shiftedValue)
+			}
+
+		case SAR: //0x1D
+			shift, popErr := stack.PopU64()
+
+			if popErr != nil {
+				return nil, firstErr(err, popErr)
+			}",,2018-05-07 14:59:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/185538994,https://github.com/hyperledger/burrow/pull/751#discussion_r185538994,seanyoung
https://github.com/hyperledger/burrow/pull/751,https://github.com/hyperledger/burrow/pull/751,"It's a minor point, but can we replace `big.NewInt(0)` `big.NewInt(256)` with equivalent constants in binary/integer.go. It avoids unnecessary allocations and reduces the surface area for typos a bit.",e8dafacfa779f94ce21100ba7ff05383791d31ab,2018-05-04 17:27:37,186152357,"@@ -493,6 +493,52 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			stack.Push64(int64(res))
 			vm.Debugf("" => 0x%X\n"", res)
 
+		case SHL: //0x1B
+			shift, value := stack.PopBigInt(), stack.PopBigInt()
+
+			if shift.Cmp(big.NewInt(256)) >= 0 {
+				reset := big.NewInt(0)",,2018-05-07 14:59:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/186152357,https://github.com/hyperledger/burrow/pull/751#discussion_r186152357,silasdavis
https://github.com/hyperledger/burrow/pull/751,https://github.com/hyperledger/burrow/pull/751,We should nest the `value.Sign()` if statement as a simple if-else within `if shift.Cmp(big.NewInt(256)) >= 0` rather than hitting the condition twice.,e8dafacfa779f94ce21100ba7ff05383791d31ab,2018-05-04 17:32:33,186153596,"@@ -493,6 +493,52 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			stack.Push64(int64(res))
 			vm.Debugf("" => 0x%X\n"", res)
 
+		case SHL: //0x1B
+			shift, value := stack.PopBigInt(), stack.PopBigInt()
+
+			if shift.Cmp(big.NewInt(256)) >= 0 {
+				reset := big.NewInt(0)
+				stack.PushBigInt(reset)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, reset)
+			} else {
+				shiftedValue := value.Lsh(value, uint(shift.Uint64()))
+				stack.PushBigInt(shiftedValue)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, shiftedValue)
+			}
+
+		case SHR: //0x1C
+			shift, value := stack.PopBigInt(), stack.PopBigInt()
+
+			if shift.Cmp(big.NewInt(256)) >= 0 {
+				reset := big.NewInt(0)
+				stack.PushBigInt(reset)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, reset)
+			} else {
+				shiftedValue := value.Rsh(value, uint(shift.Uint64()))
+				stack.PushBigInt(shiftedValue)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, shiftedValue)
+			}
+
+		case SAR: //0x1D
+			shift := stack.PopBigInt()
+
+			value := stack.PopBigIntSigned()
+
+			if shift.Cmp(big.NewInt(256)) >= 0 && value.Sign() >= 0 {
+				reset := big.NewInt(0)
+				stack.PushBigInt(reset)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, reset)
+			}
+			if shift.Cmp(big.NewInt(256)) >= 0 && value.Sign() < 0 {",,2018-05-07 14:59:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/186153596,https://github.com/hyperledger/burrow/pull/751#discussion_r186153596,silasdavis
https://github.com/hyperledger/burrow/pull/751,https://github.com/hyperledger/burrow/pull/751,"We don't need reset here we can just use value, and in fact bearing in mind the above comment can just collapse this to: `stack.PushBigInt(value.SetInt64(int64(value.Sign())))`",e8dafacfa779f94ce21100ba7ff05383791d31ab,2018-05-04 17:37:14,186154781,"@@ -493,6 +493,52 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			stack.Push64(int64(res))
 			vm.Debugf("" => 0x%X\n"", res)
 
+		case SHL: //0x1B
+			shift, value := stack.PopBigInt(), stack.PopBigInt()
+
+			if shift.Cmp(big.NewInt(256)) >= 0 {
+				reset := big.NewInt(0)
+				stack.PushBigInt(reset)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, reset)
+			} else {
+				shiftedValue := value.Lsh(value, uint(shift.Uint64()))
+				stack.PushBigInt(shiftedValue)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, shiftedValue)
+			}
+
+		case SHR: //0x1C
+			shift, value := stack.PopBigInt(), stack.PopBigInt()
+
+			if shift.Cmp(big.NewInt(256)) >= 0 {
+				reset := big.NewInt(0)
+				stack.PushBigInt(reset)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, reset)
+			} else {
+				shiftedValue := value.Rsh(value, uint(shift.Uint64()))
+				stack.PushBigInt(shiftedValue)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, shiftedValue)
+			}
+
+		case SAR: //0x1D
+			shift := stack.PopBigInt()
+
+			value := stack.PopBigIntSigned()
+
+			if shift.Cmp(big.NewInt(256)) >= 0 && value.Sign() >= 0 {
+				reset := big.NewInt(0)
+				stack.PushBigInt(reset)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, reset)
+			}
+			if shift.Cmp(big.NewInt(256)) >= 0 && value.Sign() < 0 {
+				reset := big.NewInt(-1)
+				stack.PushBigInt(reset)",,2018-05-07 14:59:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/186154781,https://github.com/hyperledger/burrow/pull/751#discussion_r186154781,silasdavis
https://github.com/hyperledger/burrow/pull/751,https://github.com/hyperledger/burrow/pull/751,"`value` shadows the `value` argument to `call`. Can we change it to something else, I suggest just `x` as used in other arithmetic functions.",e8dafacfa779f94ce21100ba7ff05383791d31ab,2018-05-04 18:39:49,186180407,"@@ -493,6 +493,52 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			stack.Push64(int64(res))
 			vm.Debugf("" => 0x%X\n"", res)
 
+		case SHL: //0x1B
+			shift, value := stack.PopBigInt(), stack.PopBigInt()",,2018-05-07 14:59:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/186180407,https://github.com/hyperledger/burrow/pull/751#discussion_r186180407,silasdavis
https://github.com/hyperledger/burrow/pull/751,https://github.com/hyperledger/burrow/pull/751,We would like to show the integer value rather than the hex here like in other arithemetic methods so these `%X`s shoiuld be `%v`s,e8dafacfa779f94ce21100ba7ff05383791d31ab,2018-05-04 18:42:16,186181035,"@@ -493,6 +493,52 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			stack.Push64(int64(res))
 			vm.Debugf("" => 0x%X\n"", res)
 
+		case SHL: //0x1B
+			shift, value := stack.PopBigInt(), stack.PopBigInt()
+
+			if shift.Cmp(Big256()) >= 0 {
+				reset := big.NewInt(0)
+				stack.PushBigInt(reset)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, reset)
+			} else {
+				shiftedValue := value.Lsh(value, uint(shift.Uint64()))
+				stack.PushBigInt(shiftedValue)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, shiftedValue)",,2018-05-07 14:59:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/186181035,https://github.com/hyperledger/burrow/pull/751#discussion_r186181035,silasdavis
https://github.com/hyperledger/burrow/pull/751,https://github.com/hyperledger/burrow/pull/751,"I'd suggest simplifying what we have here to:

```go
			shift, x := stack.PopBigInt(), stack.PopBigIntSigned()

			if shift.Cmp(big.NewInt(256)) >= 0 {
				reset := big.NewInt(0)
				if x.Sign() < 0 {
					reset.SetInt64(-1)
				}
				stack.PushBigInt(reset)
				vm.Debugf("" %v << %v = %v\n"", x, shift, reset)
			} else {
				shiftedValue := x.Rsh(x, uint(shift.Uint64()))
				stack.PushBigInt(shiftedValue)
				vm.Debugf("" %v << %v = %v\n"", x, shift, shiftedValue)
}
```",e8dafacfa779f94ce21100ba7ff05383791d31ab,2018-05-04 18:43:06,186181266,"@@ -493,6 +493,52 @@ func (vm *VM) call(caller acm.Account, callee acm.MutableAccount, code, input []
 			stack.Push64(int64(res))
 			vm.Debugf("" => 0x%X\n"", res)
 
+		case SHL: //0x1B
+			shift, value := stack.PopBigInt(), stack.PopBigInt()
+
+			if shift.Cmp(Big256()) >= 0 {
+				reset := big.NewInt(0)
+				stack.PushBigInt(reset)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, reset)
+			} else {
+				shiftedValue := value.Lsh(value, uint(shift.Uint64()))
+				stack.PushBigInt(shiftedValue)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, shiftedValue)
+			}
+
+		case SHR: //0x1C
+			shift, value := stack.PopBigInt(), stack.PopBigInt()
+
+			if shift.Cmp(Big256()) >= 0 {
+				reset := big.NewInt(0)
+				stack.PushBigInt(reset)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, reset)
+			} else {
+				shiftedValue := value.Rsh(value, uint(shift.Uint64()))
+				stack.PushBigInt(shiftedValue)
+				vm.Debugf("" %X << %X = %X\n"", value, shift, shiftedValue)
+			}
+
+		case SAR: //0x1D",,2018-05-07 14:59:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/186181266,https://github.com/hyperledger/burrow/pull/751#discussion_r186181266,silasdavis
https://github.com/hyperledger/burrow/pull/751,https://github.com/hyperledger/burrow/pull/751,I know we use `fmt.Printf` elsewhere but it would be preferable to use `t.Logf` that give more metadata and can be redirected to other writers.,e8dafacfa779f94ce21100ba7ff05383791d31ab,2018-05-04 18:44:35,186181608,"@@ -95,6 +95,476 @@ func TestVM(t *testing.T) {
 	}
 }
 
+func TestSHL(t *testing.T) {
+	ourVm := NewVM(newAppState(), newParams(), acm.ZeroAddress, nil, logger)
+	account1 := newAccount(1)
+	account2 := newAccount(1, 0, 1)
+
+	var gas uint64 = 100000
+
+	//Shift left 0
+	bytecode := MustSplice(PUSH1, 0x01, PUSH1, 0x00, SHL, return1())
+	output, err := ourVm.Call(account1, account2, bytecode, []byte{}, 0, &gas)
+	value := []uint8([]byte{0x1})
+	expected := LeftPadBytes(value, 32)
+	assert.Equal(t, expected, output)
+
+	fmt.Printf(""Result: %v == %v\n"", output, expected)",,2018-05-07 14:59:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/186181608,https://github.com/hyperledger/burrow/pull/751#discussion_r186181608,silasdavis
https://github.com/hyperledger/burrow/pull/751,https://github.com/hyperledger/burrow/pull/751,we should just export the one above - ideally we'd like to only allocate once which is achieved by a var initialisation,e8dafacfa779f94ce21100ba7ff05383791d31ab,2018-05-04 20:34:42,186214077,"@@ -100,6 +101,10 @@ func S256(x *big.Int) *big.Int {
 	}
 }
 
+func Big256() *big.Int {",,2018-05-07 14:59:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/186214077,https://github.com/hyperledger/burrow/pull/751#discussion_r186214077,silasdavis
https://github.com/hyperledger/burrow/pull/744,https://github.com/hyperledger/burrow/pull/744,A comment along these lines exists in other places - I thought here too but apparently not. Adding it since it should be remarked.,4a4528b75b321282ac27c26f886759184b0f3d2e,2018-04-20 16:46:59,183108763,"@@ -33,7 +33,7 @@ type StorageGetter interface {
 }
 
 type StorageSetter interface {
-	// Store a 32-byte value at key for the account at address
+	// Store a 32-byte value at key for the account at address, setting to Zero256 removes the key",5,2018-04-20 16:46:59,https://api.github.com/repos/hyperledger/burrow/pulls/comments/183108763,https://github.com/hyperledger/burrow/pull/744#discussion_r183108763,silasdavis
https://github.com/hyperledger/burrow/pull/742,https://github.com/hyperledger/burrow/pull/742,"it's not always correct but I think ""accept interfaces, return structs"" is a reasonable mantra here. An exception would be if we really can't trust the caller with a `*blockchain` - do you think this is the case here? Since `blockchain` is unexported it's really only for the benefit of this package - returning the struct makes it easier to test.

If anything I have been stepping back from my use of 'interfaces defined in same package as struct' in this case I think it is useful to define the `CommitBlock` function centrally but on reflection I'm questioning whether I need the `MutableBlockchain` at all...",e06c84cc93960bab4965abb5b83456b1bd2ddd33,2018-04-17 11:15:00,182036022,"@@ -100,12 +100,12 @@ type PersistedState struct {
 }
 
 func LoadOrNewBlockchain(db dbm.DB, genesisDoc *genesis.GenesisDoc,
-	logger *logging.Logger) (*blockchain, error) {
+	logger *logging.Logger) (MutableBlockchain, error) {",,2018-04-18 09:04:21,https://api.github.com/repos/hyperledger/burrow/pulls/comments/182036022,https://github.com/hyperledger/burrow/pull/742#discussion_r182036022,silasdavis
https://github.com/hyperledger/burrow/pull/742,https://github.com/hyperledger/burrow/pull/742,"This is another issue where I am changed my own leaning (though open to debate on this) towards 'exported by default' rather than 'unexported by default'. In some languages it's common to hide as many functions as possible in service of encapsulation. While I agree that it's a good idea to limit what essentially becomes your 'public API' I think hiding (unexporting) a lot of functions can be an anti-pattern. For example using other libraries in a way perhaps the author didn't anticipate I have been bitten by needlessly unexported functions that are close relatives of ones that are exported. This feels like the case here.

It is unlikely than many people find our `blockchain` type that interesting, but as  a principle I'd rather export. ",e06c84cc93960bab4965abb5b83456b1bd2ddd33,2018-04-17 11:19:14,182036921,"@@ -100,12 +100,12 @@ type PersistedState struct {
 }
 
 func LoadOrNewBlockchain(db dbm.DB, genesisDoc *genesis.GenesisDoc,
-	logger *logging.Logger) (*blockchain, error) {
+	logger *logging.Logger) (MutableBlockchain, error) {
 
 	logger = logger.WithScope(""LoadOrNewBlockchain"")
 	logger.InfoMsg(""Trying to load blockchain state from database"",
 		""database_key"", stateKey)
-	blockchain, err := LoadBlockchain(db)
+	blockchain, err := loadBlockchain(db)",5,2018-04-18 09:04:21,https://api.github.com/repos/hyperledger/burrow/pulls/comments/182036921,https://github.com/hyperledger/burrow/pull/742#discussion_r182036921,silasdavis
https://github.com/hyperledger/burrow/pull/742,https://github.com/hyperledger/burrow/pull/742,Same as above - open to persuasion - but why hide this?,e06c84cc93960bab4965abb5b83456b1bd2ddd33,2018-04-17 11:38:35,182041441,"@@ -120,11 +120,11 @@ func LoadOrNewBlockchain(db dbm.DB, genesisDoc *genesis.GenesisDoc,
 	}
 
 	logger.InfoMsg(""No existing blockchain state found in database, making new blockchain"")
-	return NewBlockchain(db, genesisDoc), nil
+	return newBlockchain(db, genesisDoc), nil
 }
 
 // Pointer to blockchain state initialised from genesis
-func NewBlockchain(db dbm.DB, genesisDoc *genesis.GenesisDoc) *blockchain {
+func newBlockchain(db dbm.DB, genesisDoc *genesis.GenesisDoc) *blockchain {",19,2018-04-18 09:04:21,https://api.github.com/repos/hyperledger/burrow/pulls/comments/182041441,https://github.com/hyperledger/burrow/pull/742#discussion_r182041441,silasdavis
https://github.com/hyperledger/burrow/pull/742,https://github.com/hyperledger/burrow/pull/742,This makes sense,e06c84cc93960bab4965abb5b83456b1bd2ddd33,2018-04-17 11:39:01,182041550,"@@ -127,10 +127,16 @@ func makeUsers(n int) []acm.AddressableSigner {
 	}
 	return users
 }
+func newBlockchain(genesisDoc *genesis.GenesisDoc) bcm.MutableBlockchain {",4,2018-04-18 09:04:21,https://api.github.com/repos/hyperledger/burrow/pulls/comments/182041550,https://github.com/hyperledger/burrow/pull/742#discussion_r182041550,silasdavis
https://github.com/hyperledger/burrow/pull/742,https://github.com/hyperledger/burrow/pull/742,"In case we need to have Immutable-Blockchain, it might helps. I think your idea is better. Better to not make it so complicated. I will revert this change.",e06c84cc93960bab4965abb5b83456b1bd2ddd33,2018-04-17 11:54:07,182045205,"@@ -100,12 +100,12 @@ type PersistedState struct {
 }
 
 func LoadOrNewBlockchain(db dbm.DB, genesisDoc *genesis.GenesisDoc,
-	logger *logging.Logger) (*blockchain, error) {
+	logger *logging.Logger) (MutableBlockchain, error) {",,2018-04-18 09:04:21,https://api.github.com/repos/hyperledger/burrow/pulls/comments/182045205,https://github.com/hyperledger/burrow/pull/742#discussion_r182045205,b00f
https://github.com/hyperledger/burrow/pull/742,https://github.com/hyperledger/burrow/pull/742,"User wants to create a blockchain whenever he runs application. It can be created (first time) or loaded (other times). User shouldn't be involved in how we load/create blockchain. 
I vote for more encapsulation! however i's not a big change. I can also revert it. ",e06c84cc93960bab4965abb5b83456b1bd2ddd33,2018-04-17 11:59:32,182046476,"@@ -100,12 +100,12 @@ type PersistedState struct {
 }
 
 func LoadOrNewBlockchain(db dbm.DB, genesisDoc *genesis.GenesisDoc,
-	logger *logging.Logger) (*blockchain, error) {
+	logger *logging.Logger) (MutableBlockchain, error) {
 
 	logger = logger.WithScope(""LoadOrNewBlockchain"")
 	logger.InfoMsg(""Trying to load blockchain state from database"",
 		""database_key"", stateKey)
-	blockchain, err := LoadBlockchain(db)
+	blockchain, err := loadBlockchain(db)",5,2018-04-18 09:04:21,https://api.github.com/repos/hyperledger/burrow/pulls/comments/182046476,https://github.com/hyperledger/burrow/pull/742#discussion_r182046476,b00f
https://github.com/hyperledger/burrow/pull/742,https://github.com/hyperledger/burrow/pull/742,:+1: ,e06c84cc93960bab4965abb5b83456b1bd2ddd33,2018-04-17 12:07:23,182048391,"@@ -100,12 +100,12 @@ type PersistedState struct {
 }
 
 func LoadOrNewBlockchain(db dbm.DB, genesisDoc *genesis.GenesisDoc,
-	logger *logging.Logger) (*blockchain, error) {
+	logger *logging.Logger) (MutableBlockchain, error) {",,2018-04-18 09:04:21,https://api.github.com/repos/hyperledger/burrow/pulls/comments/182048391,https://github.com/hyperledger/burrow/pull/742#discussion_r182048391,silasdavis
https://github.com/hyperledger/burrow/pull/742,https://github.com/hyperledger/burrow/pull/742,"Okay, I'll take your vote, let's unexport this and `newBlockchain`",e06c84cc93960bab4965abb5b83456b1bd2ddd33,2018-04-17 12:07:53,182048484,"@@ -100,12 +100,12 @@ type PersistedState struct {
 }
 
 func LoadOrNewBlockchain(db dbm.DB, genesisDoc *genesis.GenesisDoc,
-	logger *logging.Logger) (*blockchain, error) {
+	logger *logging.Logger) (MutableBlockchain, error) {
 
 	logger = logger.WithScope(""LoadOrNewBlockchain"")
 	logger.InfoMsg(""Trying to load blockchain state from database"",
 		""database_key"", stateKey)
-	blockchain, err := LoadBlockchain(db)
+	blockchain, err := loadBlockchain(db)",5,2018-04-18 09:04:21,https://api.github.com/repos/hyperledger/burrow/pulls/comments/182048484,https://github.com/hyperledger/burrow/pull/742#discussion_r182048484,silasdavis
https://github.com/hyperledger/burrow/pull/742,https://github.com/hyperledger/burrow/pull/742,Thanks Silas.,e06c84cc93960bab4965abb5b83456b1bd2ddd33,2018-04-18 04:08:16,182303731,"@@ -100,12 +100,12 @@ type PersistedState struct {
 }
 
 func LoadOrNewBlockchain(db dbm.DB, genesisDoc *genesis.GenesisDoc,
-	logger *logging.Logger) (*blockchain, error) {
+	logger *logging.Logger) (MutableBlockchain, error) {
 
 	logger = logger.WithScope(""LoadOrNewBlockchain"")
 	logger.InfoMsg(""Trying to load blockchain state from database"",
 		""database_key"", stateKey)
-	blockchain, err := LoadBlockchain(db)
+	blockchain, err := loadBlockchain(db)",5,2018-04-18 09:04:21,https://api.github.com/repos/hyperledger/burrow/pulls/comments/182303731,https://github.com/hyperledger/burrow/pull/742#discussion_r182303731,b00f
https://github.com/hyperledger/burrow/pull/731,https://github.com/hyperledger/burrow/pull/731,oh shadowing......,0ad7abb77d2e5a0364ae700132ce9f9ef24d0d9e,2018-04-06 09:54:58,179710851,"@@ -127,11 +127,12 @@ func (ta TemplateAccount) RealisePubKeyAndAddress(keyClient keys.KeyClient) (pub
 			return
 		}
 	} else {
-		address := ta.PublicKey.Address()",4,2018-04-06 09:54:58,https://api.github.com/repos/hyperledger/burrow/pulls/comments/179710851,https://github.com/hyperledger/burrow/pull/731#discussion_r179710851,silasdavis
https://github.com/hyperledger/burrow/pull/728,https://github.com/hyperledger/burrow/pull/728,Curious why we're moving `ChainID` from root to tip; its static so not really sure why we are passing it around with each block. Perhaps better safety would be my assumption....?,3135ecf0982cf7086ca94c8d2671d83269fcec6c,2018-04-09 09:39:59,180038827,"@@ -31,15 +31,15 @@ var stateKey = []byte(""BlockchainState"")
 
 // Immutable Root of blockchain
 type Root interface {
-	// ChainID precomputed from GenesisDoc
-	ChainID() string
 	// GenesisHash precomputed from GenesisDoc
 	GenesisHash() []byte
 	GenesisDoc() genesis.GenesisDoc
 }
 
 // Immutable pointer to the current tip of the blockchain
 type Tip interface {
+	// ChainID precomputed from GenesisDoc
+	ChainID() string",14,2018-04-09 18:03:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/180038827,https://github.com/hyperledger/burrow/pull/728#discussion_r180038827,compleatang
https://github.com/hyperledger/burrow/pull/728,https://github.com/hyperledger/burrow/pull/728,"Ah, so we integrate ChainID here in the signer, that's why you've moved it to tip, no?",3135ecf0982cf7086ca94c8d2671d83269fcec6c,2018-04-09 09:52:46,180042389,"@@ -224,17 +185,17 @@ func (trans *transactor) Transact(privKey []byte, address *acm.Address, data []b
 	}
 
 	// Got ourselves a tx.
-	txS, errS := trans.SignTx(tx, []acm.PrivateAccount{pa})
-	if errS != nil {
-		return nil, errS
+	err = tx.Sign(trans.tip.ChainID(), inputAccount)",187,2018-04-09 18:03:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/180042389,https://github.com/hyperledger/burrow/pull/728#discussion_r180042389,compleatang
https://github.com/hyperledger/burrow/pull/728,https://github.com/hyperledger/burrow/pull/728,Curious what this means? ,3135ecf0982cf7086ca94c8d2671d83269fcec6c,2018-04-09 10:03:11,180045096,"@@ -31,22 +27,8 @@ var (
 
 	MaxNameLength = 64
 	MaxDataLength = 1 << 16",14,2018-04-09 18:03:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/180045096,https://github.com/hyperledger/burrow/pull/728#discussion_r180045096,compleatang
https://github.com/hyperledger/burrow/pull/728,https://github.com/hyperledger/burrow/pull/728,Are these bond_tx and rebond_tx actually reimplementing validator changes in preparation for validator_tx or are they just getting back and mocked? ,3135ecf0982cf7086ca94c8d2671d83269fcec6c,2018-04-09 10:04:11,180045335,"@@ -0,0 +1,55 @@
+package txs",1,2018-04-09 18:03:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/180045335,https://github.com/hyperledger/burrow/pull/728#discussion_r180045335,compleatang
https://github.com/hyperledger/burrow/pull/728,https://github.com/hyperledger/burrow/pull/728,"Though you grab tip immutably with `Tip()` so there is a copy when you pull a tip explicitly, but mostly we are just accessing the single instance embedded in `blockchain` - both when accessing values or doing a `Commit()`. Having said that I do agree with you that it seems more logical in `Root` as a static value. The reason I moved it is with the addition of `ChainID` `Transactor` need only ask for a `Tip` rather than a whole `Blockchain`. I could have just added `ChainID` as an argument to `Transactor`. Let me think about that, maybe that is a nicer way to go... A counter-argument is if you want `Tip` to be the chain information you need to sign at a particular height, then it seems like `ChainID` belongs with other tip data.",3135ecf0982cf7086ca94c8d2671d83269fcec6c,2018-04-09 10:18:00,180048618,"@@ -31,15 +31,15 @@ var stateKey = []byte(""BlockchainState"")
 
 // Immutable Root of blockchain
 type Root interface {
-	// ChainID precomputed from GenesisDoc
-	ChainID() string
 	// GenesisHash precomputed from GenesisDoc
 	GenesisHash() []byte
 	GenesisDoc() genesis.GenesisDoc
 }
 
 // Immutable pointer to the current tip of the blockchain
 type Tip interface {
+	// ChainID precomputed from GenesisDoc
+	ChainID() string",14,2018-04-09 18:03:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/180048618,https://github.com/hyperledger/burrow/pull/728#discussion_r180048618,silasdavis
https://github.com/hyperledger/burrow/pull/728,https://github.com/hyperledger/burrow/pull/728,"Well `ChainID` has always been integrated here, see above for why I moved it from `Root`.",3135ecf0982cf7086ca94c8d2671d83269fcec6c,2018-04-09 10:18:33,180048740,"@@ -224,17 +185,17 @@ func (trans *transactor) Transact(privKey []byte, address *acm.Address, data []b
 	}
 
 	// Got ourselves a tx.
-	txS, errS := trans.SignTx(tx, []acm.PrivateAccount{pa})
-	if errS != nil {
-		return nil, errS
+	err = tx.Sign(trans.tip.ChainID(), inputAccount)",187,2018-04-09 18:03:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/180048740,https://github.com/hyperledger/burrow/pull/728#discussion_r180048740,silasdavis
https://github.com/hyperledger/burrow/pull/728,https://github.com/hyperledger/burrow/pull/728,"I did not write this, just copy and paste, but it's just 2^16 == 65536, the operator is a bitwise right shift by 16 binary places. I didn't write this originally, some people like to work in powers of two, not sure if there is a stronger reason than that. Cargo cult around alignment to system level words perhaps. We are storing in a binary tree... hmm nah I think it's just a way of picking a sufficiently large number",3135ecf0982cf7086ca94c8d2671d83269fcec6c,2018-04-09 10:21:47,180049480,"@@ -31,22 +27,8 @@ var (
 
 	MaxNameLength = 64
 	MaxDataLength = 1 << 16",14,2018-04-09 18:03:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/180049480,https://github.com/hyperledger/burrow/pull/728#discussion_r180049480,silasdavis
https://github.com/hyperledger/burrow/pull/728,https://github.com/hyperledger/burrow/pull/728,"I am keeping them around as inspiration for when we do have ValidatorTx, but I expect to rewrite - or possibly leave them once again after the basic pointy stick transaction is implemented to consider whether we can do something smart around multi-token balances represented at the native account level...",3135ecf0982cf7086ca94c8d2671d83269fcec6c,2018-04-09 10:23:18,180049841,"@@ -0,0 +1,55 @@
+package txs",1,2018-04-09 18:03:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/180049841,https://github.com/hyperledger/burrow/pull/728#discussion_r180049841,silasdavis
https://github.com/hyperledger/burrow/pull/728,https://github.com/hyperledger/burrow/pull/728,i thought i remembered it was 2^16. was just weirded out by the go syntax. that's a lot of bytes....,3135ecf0982cf7086ca94c8d2671d83269fcec6c,2018-04-09 13:46:10,180098855,"@@ -31,22 +27,8 @@ var (
 
 	MaxNameLength = 64
 	MaxDataLength = 1 << 16",14,2018-04-09 18:03:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/180098855,https://github.com/hyperledger/burrow/pull/728#discussion_r180098855,compleatang
https://github.com/hyperledger/burrow/pull/728,https://github.com/hyperledger/burrow/pull/728,Thanks. Realized 75% thru the review why.... Should have removed the comment. But always good to learn!,3135ecf0982cf7086ca94c8d2671d83269fcec6c,2018-04-09 13:47:06,180099149,"@@ -31,15 +31,15 @@ var stateKey = []byte(""BlockchainState"")
 
 // Immutable Root of blockchain
 type Root interface {
-	// ChainID precomputed from GenesisDoc
-	ChainID() string
 	// GenesisHash precomputed from GenesisDoc
 	GenesisHash() []byte
 	GenesisDoc() genesis.GenesisDoc
 }
 
 // Immutable pointer to the current tip of the blockchain
 type Tip interface {
+	// ChainID precomputed from GenesisDoc
+	ChainID() string",14,2018-04-09 18:03:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/180099149,https://github.com/hyperledger/burrow/pull/728#discussion_r180099149,compleatang
https://github.com/hyperledger/burrow/pull/728,https://github.com/hyperledger/burrow/pull/728,"cool
",3135ecf0982cf7086ca94c8d2671d83269fcec6c,2018-04-09 13:47:34,180099284,"@@ -0,0 +1,55 @@
+package txs",1,2018-04-09 18:03:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/180099284,https://github.com/hyperledger/burrow/pull/728#discussion_r180099284,compleatang
https://github.com/hyperledger/burrow/pull/728,https://github.com/hyperledger/burrow/pull/728,provieded => provided,3135ecf0982cf7086ca94c8d2671d83269fcec6c,2018-04-09 14:43:47,180118028,"@@ -0,0 +1,55 @@
+package txs
+
+import (
+	""fmt""
+	""io""
+
+	acm ""github.com/hyperledger/burrow/account""
+	""github.com/tendermint/go-wire""
+)
+
+type UnbondTx struct {
+	Address   acm.Address
+	Height    int
+	Signature acm.Signature
+	txHashMemoizer
+}
+
+var _ Tx = &UnbondTx{}
+
+func NewUnbondTx(addr acm.Address, height int) *UnbondTx {
+	return &UnbondTx{
+		Address: addr,
+		Height:  height,
+	}
+}
+
+func (tx *UnbondTx) Sign(chainID string, signingAccounts ...acm.AddressableSigner) error {
+	if len(signingAccounts) != 1 {
+		return fmt.Errorf(""UnbondTx expects a single AddressableSigner for its signature but %v were provieded"",",,2018-04-09 18:03:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/180118028,https://github.com/hyperledger/burrow/pull/728#discussion_r180118028,seanyoung
https://github.com/hyperledger/burrow/pull/728,https://github.com/hyperledger/burrow/pull/728,Add comment about rechecking expected to fail but not observed,3135ecf0982cf7086ca94c8d2671d83269fcec6c,2018-04-09 14:45:32,180118645,"@@ -201,6 +188,14 @@ func (app *abciApp) Commit() abci_types.ResponseCommit {
 		}
 	}
 ",33,2018-04-09 18:03:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/180118645,https://github.com/hyperledger/burrow/pull/728#discussion_r180118645,seanyoung
https://github.com/hyperledger/burrow/pull/728,https://github.com/hyperledger/burrow/pull/728,"address is already a hash, no need to hash again. mutexcount is 100 in current code, so could just be address[0] % mutexcount. That is not generic enough, so maybe ringmutex should be part of Accounts instead (its not much code anyway)",3135ecf0982cf7086ca94c8d2671d83269fcec6c,2018-04-09 14:55:29,180122423,"@@ -0,0 +1,71 @@
+package sync
+
+import (
+	""sync""
+
+	""github.com/OneOfOne/xxhash""
+)
+
+type RingMutex struct {
+	mtxs       []sync.RWMutex
+	hasherPool sync.Pool
+	mutexCount uint64
+}
+
+// Create a RW mutex that provides a pseudo-independent set of mutexes for addresses
+// where the address space is mapped into possibly much smaller set of backing
+// mutexes using the xxhash (non-cryptographic)
+// hash function // modulo size. If some addresses collide modulo size they will be unnecessary
+// contention between those addresses, but you can trade space against contention
+// as desired.
+func NewRingMutex(mutexCount int) *RingMutex {
+	return &RingMutex{
+		// max slice length is bounded by max(int) thus the argument type
+		mtxs: make([]sync.RWMutex, mutexCount, mutexCount),
+		hasherPool: sync.Pool{
+			New: func() interface{} {
+				return xxhash.New64()
+			},
+		},
+		mutexCount: uint64(mutexCount),
+	}
+}
+
+func (mtx *RingMutex) Lock(address []byte) {
+	mtx.Mutex(address).Lock()
+}
+
+func (mtx *RingMutex) Unlock(address []byte) {
+	mtx.Mutex(address).Unlock()
+}
+
+func (mtx *RingMutex) RLock(address []byte) {
+	mtx.Mutex(address).RLock()
+}
+
+func (mtx *RingMutex) RUnlock(address []byte) {
+	mtx.Mutex(address).RUnlock()
+}
+
+// Return the size of the underlying array of mutexes
+func (mtx *RingMutex) MutexCount() uint64 {
+	return mtx.mutexCount
+}
+
+func (mtx *RingMutex) Mutex(address []byte) *sync.RWMutex {
+	return &mtx.mtxs[mtx.index(address)]
+}
+
+func (mtx *RingMutex) index(address []byte) uint64 {
+	return mtx.hash(address) % mtx.mutexCount",91,2018-04-09 18:03:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/180122423,https://github.com/hyperledger/burrow/pull/728#discussion_r180122423,seanyoung
https://github.com/hyperledger/burrow/pull/728,https://github.com/hyperledger/burrow/pull/728,Lock can return both error and be in a locked state,3135ecf0982cf7086ca94c8d2671d83269fcec6c,2018-04-09 15:08:00,180126876,"@@ -0,0 +1,90 @@
+package execution
+
+import (
+	""fmt""
+	""sync""
+
+	acm ""github.com/hyperledger/burrow/account""
+	""github.com/hyperledger/burrow/account/state""
+	""github.com/hyperledger/burrow/keys""
+	burrow_sync ""github.com/hyperledger/burrow/sync""
+)
+
+type Accounts struct {
+	burrow_sync.RingMutex
+	state.Reader
+	keyClient keys.KeyClient
+}
+
+type SigningAccount struct {
+	acm.Account
+	acm.Signer
+}
+
+type SequentialSigningAccount struct {
+	accountLocker sync.Locker
+	getter        func() (*SigningAccount, error)
+}
+
+func NewAccounts(reader state.Reader, keyClient keys.KeyClient, mutexCount int) *Accounts {
+	return &Accounts{
+		RingMutex: *burrow_sync.NewRingMutex(mutexCount),
+		Reader:    reader,
+		keyClient: keyClient,
+	}
+}
+func (accs *Accounts) SigningAccount(address acm.Address, signer acm.Signer) (*SigningAccount, error) {
+	account, err := state.GetMutableAccount(accs.Reader, address)
+	if err != nil {
+		return nil, err
+	}
+	// If the account is unknown to us return a zeroed account
+	if account == nil {
+		account = acm.ConcreteAccount{
+			Address: address,
+		}.MutableAccount()
+	}
+	pubKey, err := accs.keyClient.PublicKey(address)
+	if err != nil {
+		return nil, err
+	}
+	account.SetPublicKey(pubKey)
+	return &SigningAccount{
+		Account: account,
+		Signer:  signer,
+	}, nil
+}
+
+func (accs *Accounts) SequentialSigningAccount(address acm.Address) *SequentialSigningAccount {
+	signer := keys.Signer(accs.keyClient, address)
+	return &SequentialSigningAccount{
+		accountLocker: accs.Mutex(address.Bytes()),
+		getter: func() (*SigningAccount, error) {
+			return accs.SigningAccount(address, signer)
+		},
+	}
+}
+
+func (accs *Accounts) SequentialSigningAccountFromPrivateKey(privateKeyBytes []byte) (*SequentialSigningAccount, error) {
+	if len(privateKeyBytes) != 64 {
+		return nil, fmt.Errorf(""private key is not of the right length: %d\n"", len(privateKeyBytes))
+	}
+	privateAccount, err := acm.GeneratePrivateAccountFromPrivateKeyBytes(privateKeyBytes)
+	if err != nil {
+		return nil, err
+	}
+	return &SequentialSigningAccount{
+		accountLocker: accs.Mutex(privateAccount.Address().Bytes()),
+		getter: func() (*SigningAccount, error) {
+			return accs.SigningAccount(privateAccount.Address(), privateAccount)
+		},
+	}, nil
+}
+
+type UnlockFunc func()
+
+func (ssa *SequentialSigningAccount) Lock() (*SigningAccount, UnlockFunc, error) {
+	ssa.accountLocker.Lock()
+	account, err := ssa.getter()
+	return account, ssa.accountLocker.Unlock, err",,2018-04-09 18:03:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/180126876,https://github.com/hyperledger/burrow/pull/728#discussion_r180126876,seanyoung
https://github.com/hyperledger/burrow/pull/728,https://github.com/hyperledger/burrow/pull/728,err ignored,3135ecf0982cf7086ca94c8d2671d83269fcec6c,2018-04-09 15:08:36,180127086,"@@ -177,43 +160,21 @@ func (trans *transactor) BroadcastTx(tx txs.Tx) (*txs.Receipt, error) {
 }
 
 // Orders calls to BroadcastTx using lock (waits for response from core before releasing)
-func (trans *transactor) Transact(privKey []byte, address *acm.Address, data []byte, gasLimit,
-	fee uint64) (*txs.Receipt, error) {
+func (trans *Transactor) Transact(sequentialSigningAccount *SequentialSigningAccount, address *acm.Address, data []byte,
+	gasLimit, fee uint64) (*txs.Receipt, error) {
+	// Note we rely on back pressure from BroadcastTx when serialising access to from a particular input account while
+	// the mempool rechecks (and so the checker, having just be reset does not yet have the latest sequence numbers
+	// for some accounts). BroadcastTx will block when the mempool is rechecking or during a commit so provided
+	// subsequent Transacts from the same input account block on those ahead of it we are able to stream transactions
+	// continuously with sequential sequence numbers. By taking this lock we ensure this.
+	inputAccount, unlock, err := sequentialSigningAccount.Lock()",148,2018-04-09 18:03:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/180127086,https://github.com/hyperledger/burrow/pull/728#discussion_r180127086,seanyoung
https://github.com/hyperledger/burrow/pull/728,https://github.com/hyperledger/burrow/pull/728,err ignored,3135ecf0982cf7086ca94c8d2671d83269fcec6c,2018-04-09 15:09:29,180127390,"@@ -271,55 +232,30 @@ func (trans *transactor) TransactAndHold(privKey []byte, address *acm.Address, d
 	}
 }
 
-func (trans *transactor) Send(privKey []byte, toAddress acm.Address, amount uint64) (*txs.Receipt, error) {
-	if len(privKey) != 64 {
-		return nil, fmt.Errorf(""Private key is not of the right length: %d\n"",
-			len(privKey))
-	}
-
-	pk := &[64]byte{}
-	copy(pk[:], privKey)
-	trans.txMtx.Lock()
-	defer trans.txMtx.Unlock()
-	pa, err := acm.GeneratePrivateAccountFromPrivateKeyBytes(privKey)
-	if err != nil {
-		return nil, err
-	}
-	cache := trans.state
-	acc, err := cache.GetAccount(pa.Address())
-	if err != nil {
-		return nil, err
-	}
-	sequence := uint64(1)
-	if acc != nil {
-		sequence = acc.Sequence() + uint64(1)
-	}
-
+func (trans *Transactor) Send(sequentialSigningAccount *SequentialSigningAccount, toAddress acm.Address, amount uint64) (*txs.Receipt, error) {
 	tx := txs.NewSendTx()
 
+	inputAccount, unlock, err := sequentialSigningAccount.Lock()
+	defer unlock()",,2018-04-09 18:03:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/180127390,https://github.com/hyperledger/burrow/pull/728#discussion_r180127390,seanyoung
https://github.com/hyperledger/burrow/pull/727,https://github.com/hyperledger/burrow/pull/727,Lot cleaner. ,a4c546f47d8063618ecb3c91e6bf4061ce86f7d2,2018-04-03 20:31:07,178952516,"@@ -41,7 +40,7 @@ type NodeClient interface {
 	ListValidators() (blockHeight uint64, bondedValidators, unbondingValidators []acm.Validator, err error)
 
 	// Logging context for this NodeClient
-	Logger() logging_types.InfoTraceLogger
+	Logger() *logging.Logger",13,2018-04-03 20:55:15,https://api.github.com/repos/hyperledger/burrow/pulls/comments/178952516,https://github.com/hyperledger/burrow/pull/727#discussion_r178952516,compleatang
https://github.com/hyperledger/burrow/pull/727,https://github.com/hyperledger/burrow/pull/727,What's this useful for?,a4c546f47d8063618ecb3c91e6bf4061ce86f7d2,2018-04-03 20:42:29,178955826,"@@ -1128,3 +1124,28 @@ func transfer(from, to acm.MutableAccount, amount uint64) error {
 	}
 	return nil
 }
+
+// Dump the bytecode being sent to the EVM in the current working directory
+func dumpTokens(txHash []byte, caller, callee acm.Account, code []byte) {",736,2018-04-03 20:55:15,https://api.github.com/repos/hyperledger/burrow/pulls/comments/178955826,https://github.com/hyperledger/burrow/pull/727#discussion_r178955826,compleatang
https://github.com/hyperledger/burrow/pull/727,https://github.com/hyperledger/burrow/pull/727,"🐱 
",a4c546f47d8063618ecb3c91e6bf4061ce86f7d2,2018-04-03 20:49:50,178957854,"@@ -73,13 +74,14 @@ func ecrecoverFunc(state State, caller *acm.Account, input []byte, gas *int64) (
 	recovered, err := secp256k1.RecoverPubkey(hash, sig)
 	if err != nil {
 		return nil, err
+OH NO STOCASTIC CAT CODING!!!!",26,2018-04-03 20:55:15,https://api.github.com/repos/hyperledger/burrow/pulls/comments/178957854,https://github.com/hyperledger/burrow/pull/727#discussion_r178957854,compleatang
https://github.com/hyperledger/burrow/pull/727,https://github.com/hyperledger/burrow/pull/727,"Provides human-readable bytecode for each tx that is committed - can be convenient for comparing with other generated bytecode and can be clearer than the line-by-line opcode debugging - which also only prints the path that was executed rather than everything. That also doesn't have the tx and callee so obviously. Ultimately this could be combined/enhanced into a single debug, but I found both of these useful so rather than killing the debug I've made them available via options that seems like a fairly clean way of keeping them in the codebase.",a4c546f47d8063618ecb3c91e6bf4061ce86f7d2,2018-04-03 22:08:05,178976351,"@@ -1128,3 +1124,28 @@ func transfer(from, to acm.MutableAccount, amount uint64) error {
 	}
 	return nil
 }
+
+// Dump the bytecode being sent to the EVM in the current working directory
+func dumpTokens(txHash []byte, caller, callee acm.Account, code []byte) {",736,2018-04-03 22:08:05,https://api.github.com/repos/hyperledger/burrow/pulls/comments/178976351,https://github.com/hyperledger/burrow/pull/727#discussion_r178976351,silasdavis
https://github.com/hyperledger/burrow/pull/727,https://github.com/hyperledger/burrow/pull/727,Lol you know what that was actually an accidental copypasta from a discussion I was having with @dennismckinnon ... occasionally happens via trackpad... So an accidental code addition referring to a class of accidental code additions.,a4c546f47d8063618ecb3c91e6bf4061ce86f7d2,2018-04-03 22:09:41,178976646,"@@ -73,13 +74,14 @@ func ecrecoverFunc(state State, caller *acm.Account, input []byte, gas *int64) (
 	recovered, err := secp256k1.RecoverPubkey(hash, sig)
 	if err != nil {
 		return nil, err
+OH NO STOCASTIC CAT CODING!!!!",26,2018-04-03 22:09:41,https://api.github.com/repos/hyperledger/burrow/pulls/comments/178976646,https://github.com/hyperledger/burrow/pull/727#discussion_r178976646,silasdavis
https://github.com/hyperledger/burrow/pull/721,https://github.com/hyperledger/burrow/pull/721,Relates to Cache which has `IterateAccounts` etc,c38daca22812c3332b7a6783f5aa8315170fba4e,2018-03-22 17:48:10,176513380,"@@ -63,3 +63,11 @@ type StateWriter interface {
 	Updater
 	StorageSetter
 }
+
+type IterableStateWriter interface {",5,2018-03-22 17:48:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/176513380,https://github.com/hyperledger/burrow/pull/721#discussion_r176513380,silasdavis
https://github.com/hyperledger/burrow/pull/721,https://github.com/hyperledger/burrow/pull/721,"we should be exposing this as a genesis config option. not now, but for later. ",c38daca22812c3332b7a6783f5aa8315170fba4e,2018-04-02 20:07:43,178635930,"@@ -32,6 +32,9 @@ import (
 	""github.com/hyperledger/burrow/txs""
 )
 
+// TODO
+const GasLimit = uint64(1000000)",5,2018-04-02 20:10:19,https://api.github.com/repos/hyperledger/burrow/pulls/comments/178635930,https://github.com/hyperledger/burrow/pull/721#discussion_r178635930,compleatang
https://github.com/hyperledger/burrow/pull/721,https://github.com/hyperledger/burrow/pull/721,better name... ,c38daca22812c3332b7a6783f5aa8315170fba4e,2018-04-02 20:07:53,178635964,"@@ -72,7 +72,7 @@ type VM struct {
 	memoryProvider func() Memory
 	params         Params
 	origin         acm.Address
-	txid           []byte
+	txHash         []byte",5,2018-04-02 20:10:19,https://api.github.com/repos/hyperledger/burrow/pulls/comments/178635964,https://github.com/hyperledger/burrow/pull/721#discussion_r178635964,compleatang
https://github.com/hyperledger/burrow/pull/721,https://github.com/hyperledger/burrow/pull/721,"yes, I was planning to address this and other things with the ValidatorTx changes",c38daca22812c3332b7a6783f5aa8315170fba4e,2018-04-03 13:29:18,178823423,"@@ -32,6 +32,9 @@ import (
 	""github.com/hyperledger/burrow/txs""
 )
 
+// TODO
+const GasLimit = uint64(1000000)",5,2018-04-03 13:29:18,https://api.github.com/repos/hyperledger/burrow/pulls/comments/178823423,https://github.com/hyperledger/burrow/pull/721#discussion_r178823423,silasdavis
https://github.com/hyperledger/burrow/pull/720,https://github.com/hyperledger/burrow/pull/720,"We are using drop case on other words elsewhere, omit this and I will accept",d1acde16255f0a4573ef0c86f61ced1386d0102c,2018-03-15 18:34:20,174888383,"@@ -9,14 +9,14 @@ Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node bui
 
 ## Table of Contents
 
-- [What is burrow](#what-is-burrow)
+- [What is Burrow ?](#what-is-burrow-)
 - [Installation](#installation)
-- [For developers](#for-developers)
+- [For Developers](#for-developers)",8,2018-03-15 18:34:20,https://api.github.com/repos/hyperledger/burrow/pulls/comments/174888383,https://github.com/hyperledger/burrow/pull/720#discussion_r174888383,silasdavis
https://github.com/hyperledger/burrow/pull/720,https://github.com/hyperledger/burrow/pull/720,"Do you want to undo, otherwise delete `[For developers](#for-developers)`?",d1acde16255f0a4573ef0c86f61ced1386d0102c,2018-03-16 07:37:32,175014595,"@@ -9,14 +9,14 @@ Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node bui
 
 ## Table of Contents
 
-- [What is burrow](#what-is-burrow)
+- [What is Burrow ?](#what-is-burrow-)
 - [Installation](#installation)
-- [For developers](#for-developers)
+- [For Developers](#for-developers)",8,2018-03-16 07:37:56,https://api.github.com/repos/hyperledger/burrow/pulls/comments/175014595,https://github.com/hyperledger/burrow/pull/720#discussion_r175014595,qpakzk
https://github.com/hyperledger/burrow/pull/720,https://github.com/hyperledger/burrow/pull/720,"@qpakzk see my comment below, and PR #700 ",d1acde16255f0a4573ef0c86f61ced1386d0102c,2018-03-16 07:43:15,175015343,"@@ -9,14 +9,14 @@ Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node bui
 
 ## Table of Contents
 
-- [What is burrow](#what-is-burrow)
+- [What is Burrow ?](#what-is-burrow-)
 - [Installation](#installation)
-- [For developers](#for-developers)
+- [For Developers](#for-developers)",8,2018-03-16 07:43:15,https://api.github.com/repos/hyperledger/burrow/pulls/comments/175015343,https://github.com/hyperledger/burrow/pull/720#discussion_r175015343,zramsay
https://github.com/hyperledger/burrow/pull/704,https://github.com/hyperledger/burrow/pull/704,For now I am wrapping the implementation and using big int as a convenient way to check bounds. ,a38031864da79a3ba09edc378e17e84098177022,2018-03-03 00:09:07,171993760,"@@ -54,10 +58,22 @@ func DefaultDynamicMemoryProvider() Memory {
 // array allocation via a backing slice
 type dynamicMemory struct {
 	slice           []byte
-	maximumCapacity int64
+	maximumCapacity uint64
 }
 
-func (mem *dynamicMemory) Read(offset, length int64) ([]byte, error) {
+func (mem *dynamicMemory) Read(offset, length *big.Int) ([]byte, error) {
+	// Ensures positive and not too wide
+	if !offset.IsUint64() {
+		return nil, fmt.Errorf(""offset %v does not fit inside an unsigned 64-bit integer"", offset)
+	}
+	// Ensures positive and not too wide
+	if !length.IsUint64() {
+		return nil, fmt.Errorf(""length %v does not fit inside an unsigned 64-bit integer"", offset)
+	}
+	return mem.read(offset.Uint64(), length.Uint64())",63,2018-03-03 00:09:08,https://api.github.com/repos/hyperledger/burrow/pulls/comments/171993760,https://github.com/hyperledger/burrow/pull/704#discussion_r171993760,silasdavis
https://github.com/hyperledger/burrow/pull/700,https://github.com/hyperledger/burrow/pull/700,"Change:
>It executes Ethereum smart contract code (Solidity)
To:
> Ethereum EVM smart contract code (usually written in [Solidity](https://solidity.readthedocs.io))",817fa67a805203320caf4e5db4fa489e48b7f002,2018-03-01 12:18:11,171541216,"@@ -1,67 +1,69 @@
-# Hyperledger Burrow v0.16
+# Hyperledger Burrow
 
 |[![GoDoc](https://godoc.org/github.com/burrow?status.png)](https://godoc.org/github.com/hyperledger/burrow) | Linux |
 |---|-------|
 | Master | [![Circle CI](https://circleci.com/gh/hyperledger/burrow/tree/master.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/master) |
 | Develop | [![Circle CI (develop)](https://circleci.com/gh/hyperledger/burrow/tree/develop.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/develop) |
 
-Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake Tendermint consensus engine. For smart contract development most functionality is provided by `monax chains`, exposed through [monax](https://monax.io/docs), the entry point for the Monax Platform.
+Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code (Solidity) on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake [Tendermint](https://tendermint.com) consensus engine.",,2018-03-02 07:10:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/171541216,https://github.com/hyperledger/burrow/pull/700#discussion_r171541216,silasdavis
https://github.com/hyperledger/burrow/pull/700,https://github.com/hyperledger/burrow/pull/700,open to better suggestions but you have seen my comment about not favouring `make install`,817fa67a805203320caf4e5db4fa489e48b7f002,2018-03-01 12:21:31,171541908,"@@ -1,67 +1,69 @@
-# Hyperledger Burrow v0.16
+# Hyperledger Burrow
 
 |[![GoDoc](https://godoc.org/github.com/burrow?status.png)](https://godoc.org/github.com/hyperledger/burrow) | Linux |
 |---|-------|
 | Master | [![Circle CI](https://circleci.com/gh/hyperledger/burrow/tree/master.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/master) |
 | Develop | [![Circle CI (develop)](https://circleci.com/gh/hyperledger/burrow/tree/develop.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/develop) |
 
-Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake Tendermint consensus engine. For smart contract development most functionality is provided by `monax chains`, exposed through [monax](https://monax.io/docs), the entry point for the Monax Platform.
+Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code (Solidity) on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake [Tendermint](https://tendermint.com) consensus engine.
 
-## Table of Contents
+## What is Burrow
 
-- [What is burrow](#what-is-burrow)
-- [Installation](#installation)
-- [For developers](#for-developers)
-- [Usage](#usage)
-- [Configuration](#configuration)
-- [Contribute](#contribute)
-- [License](#license)
-- [Future work](#future-work)
-
-## What is Burrow ?
-
-Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification.  Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway.  More specifically Burrow consists of the following:
+Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification. Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway. More specifically Burrow consists of the following:
 
 - **Consensus Engine:** transactions are ordered and finalised with the Byzantine fault-tolerant Tendermint protocol.  The Tendermint protocol provides high transaction throughput over a set of known validators and prevents the blockchain from forking.
-- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the ABCI. The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
-- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them.  The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
+- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the [ABCI](https://github.com/tendermint/abci). The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
+- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them. The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
 - **Permissioned Ethereum Virtual Machine:** This virtual machine is built to observe the Ethereum operation code specification and additionally asserts the correct permissions have been granted. Permissioning is enforced through secure native functions and underlies all smart contract code. An arbitrary but finite amount of gas is handed out for every execution to ensure a finite execution duration - “You don’t need money to play, when you have permission to play”.
-- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node.  Currently tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.  For proof-of-concept purposes we provide a monax-contracts.js library that automatically mirrors the smart contracts deployed on the chain and to develop middleware solutions against the blockchain network.  Future work on the light client will be aware of the ABI to natively translate calls on the API into signed transactions that can be broadcast on the network.
+- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node. Current tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.
 - **API Gateway:** Burrow exposes REST and JSON-RPC endpoints to interact with the blockchain network and the application state through broadcasting transactions, or querying the current state of the application. Websockets allow to subscribe to events, which is particularly valuable as the consensus engine and smart contract application can give unambiguously finalised results to transactions within one blocktime of about one second.
 
 ## Installation
 
-`burrow` is intended to be used by the `monax chains` command via [monax](https://monax.io/docs). Available commands such as `make | start | stop | logs | inspect | update` are used for chain lifecycle management.
-
-### For Developers
-Dependency management for Burrow is managed with [glide](github.com/Masterminds/glide), and you can build Burrow from source by following
 
-- [Install go](https://golang.org/doc/install)
+- [Install go](https://golang.org/doc/install) and have `$GOPATH` set
 - Ensure you have `gmp` installed (`sudo apt-get install libgmp3-dev || brew install gmp`)
-- and execute following commands in a terminal:
-- `go get github.com/Masterminds/glide`
-- `go get -d github.com/hyperledger/burrow`
-- `REPO=$($GOPATH/src/github.com/hyperledger/burrow)`
-- `cd $REPO && glide install`
-- `cd $REPO/cmd/burrow && go install`
 
+```
+go get github.com/hyperledger/burrow
+cd github.com/hyperledger/burrow
+make build
+```
+
+This will put the the `burrow` and `burrow-client` binaries in ...",,2018-03-02 07:10:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/171541908,https://github.com/hyperledger/burrow/pull/700#discussion_r171541908,silasdavis
https://github.com/hyperledger/burrow/pull/700,https://github.com/hyperledger/burrow/pull/700,s/accounts.json/genesis-spec.json,817fa67a805203320caf4e5db4fa489e48b7f002,2018-03-01 12:21:58,171542020,"@@ -1,67 +1,69 @@
-# Hyperledger Burrow v0.16
+# Hyperledger Burrow
 
 |[![GoDoc](https://godoc.org/github.com/burrow?status.png)](https://godoc.org/github.com/hyperledger/burrow) | Linux |
 |---|-------|
 | Master | [![Circle CI](https://circleci.com/gh/hyperledger/burrow/tree/master.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/master) |
 | Develop | [![Circle CI (develop)](https://circleci.com/gh/hyperledger/burrow/tree/develop.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/develop) |
 
-Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake Tendermint consensus engine. For smart contract development most functionality is provided by `monax chains`, exposed through [monax](https://monax.io/docs), the entry point for the Monax Platform.
+Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code (Solidity) on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake [Tendermint](https://tendermint.com) consensus engine.
 
-## Table of Contents
+## What is Burrow
 
-- [What is burrow](#what-is-burrow)
-- [Installation](#installation)
-- [For developers](#for-developers)
-- [Usage](#usage)
-- [Configuration](#configuration)
-- [Contribute](#contribute)
-- [License](#license)
-- [Future work](#future-work)
-
-## What is Burrow ?
-
-Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification.  Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway.  More specifically Burrow consists of the following:
+Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification. Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway. More specifically Burrow consists of the following:
 
 - **Consensus Engine:** transactions are ordered and finalised with the Byzantine fault-tolerant Tendermint protocol.  The Tendermint protocol provides high transaction throughput over a set of known validators and prevents the blockchain from forking.
-- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the ABCI. The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
-- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them.  The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
+- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the [ABCI](https://github.com/tendermint/abci). The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
+- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them. The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
 - **Permissioned Ethereum Virtual Machine:** This virtual machine is built to observe the Ethereum operation code specification and additionally asserts the correct permissions have been granted. Permissioning is enforced through secure native functions and underlies all smart contract code. An arbitrary but finite amount of gas is handed out for every execution to ensure a finite execution duration - “You don’t need money to play, when you have permission to play”.
-- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node.  Currently tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.  For proof-of-concept purposes we provide a monax-contracts.js library that automatically mirrors the smart contracts deployed on the chain and to develop middleware solutions against the blockchain network.  Future work on the light client will be aware of the ABI to natively translate calls on the API into signed transactions that can be broadcast on the network.
+- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node. Current tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.
 - **API Gateway:** Burrow exposes REST and JSON-RPC endpoints to interact with the blockchain network and the application state through broadcasting transactions, or querying the current state of the application. Websockets allow to subscribe to events, which is particularly valuable as the consensus engine and smart contract application can give unambiguously finalised results to transactions within one blocktime of about one second.
 
 ## Installation
 
-`burrow` is intended to be used by the `monax chains` command via [monax](https://monax.io/docs). Available commands such as `make | start | stop | logs | inspect | update` are used for chain lifecycle management.
-
-### For Developers
-Dependency management for Burrow is managed with [glide](github.com/Masterminds/glide), and you can build Burrow from source by following
 
-- [Install go](https://golang.org/doc/install)
+- [Install go](https://golang.org/doc/install) and have `$GOPATH` set
 - Ensure you have `gmp` installed (`sudo apt-get install libgmp3-dev || brew install gmp`)
-- and execute following commands in a terminal:
-- `go get github.com/Masterminds/glide`
-- `go get -d github.com/hyperledger/burrow`
-- `REPO=$($GOPATH/src/github.com/hyperledger/burrow)`
-- `cd $REPO && glide install`
-- `cd $REPO/cmd/burrow && go install`
 
+```
+go get github.com/hyperledger/burrow
+cd github.com/hyperledger/burrow
+make build
+```
+
+This will put the the `burrow` and `burrow-client` binaries in ...
 
-To run `burrow`, just type `$ burrow serve --work-dir <path to chain directory>`, where the chain directory needs to contain the configuration, genesis file, and private validator file as generated by `monax chains make`.
+## Usage
 
-This will start the node using the provided folder as working dir. If the path is omitted it defaults to `~/.monax`.
+The end result will be a `burrow.toml` that will be read in from your current working directory when starting `burrow`.
 
-For a Vagrant file see [monax-vagrant](https://github.com/monax/monax-vagrant) for drafts or soon this repo for [Vagrant](https://github.com/hyperledger/burrow/issues/514) and Packer files.
+### Configuration
 
-## Usage
+Note: here we'll need `monax-keys` to start the keys server (TODO, where?)
+
+The quick-and-dirty one-liner looks like:
+
+```
+burrow spec -p1 -f1 | burrow configure -s- -v0
+```
+
+which translates into:
+
+```
+burrow spec --participant-accounts=1 --full-accounts=1 > accounts.json",,2018-03-02 07:10:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/171542020,https://github.com/hyperledger/burrow/pull/700#discussion_r171542020,silasdavis
https://github.com/hyperledger/burrow/pull/700,https://github.com/hyperledger/burrow/pull/700,"There are some issues with the UX of this, particulary when splitting apart genesis.json and main config and also overriding values from command line. It might be worth me discussing this with you and making some changes since you have experience in our CLI UX. Let's have a call? ",817fa67a805203320caf4e5db4fa489e48b7f002,2018-03-01 12:23:03,171542239,"@@ -1,67 +1,69 @@
-# Hyperledger Burrow v0.16
+# Hyperledger Burrow
 
 |[![GoDoc](https://godoc.org/github.com/burrow?status.png)](https://godoc.org/github.com/hyperledger/burrow) | Linux |
 |---|-------|
 | Master | [![Circle CI](https://circleci.com/gh/hyperledger/burrow/tree/master.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/master) |
 | Develop | [![Circle CI (develop)](https://circleci.com/gh/hyperledger/burrow/tree/develop.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/develop) |
 
-Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake Tendermint consensus engine. For smart contract development most functionality is provided by `monax chains`, exposed through [monax](https://monax.io/docs), the entry point for the Monax Platform.
+Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code (Solidity) on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake [Tendermint](https://tendermint.com) consensus engine.
 
-## Table of Contents
+## What is Burrow
 
-- [What is burrow](#what-is-burrow)
-- [Installation](#installation)
-- [For developers](#for-developers)
-- [Usage](#usage)
-- [Configuration](#configuration)
-- [Contribute](#contribute)
-- [License](#license)
-- [Future work](#future-work)
-
-## What is Burrow ?
-
-Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification.  Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway.  More specifically Burrow consists of the following:
+Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification. Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway. More specifically Burrow consists of the following:
 
 - **Consensus Engine:** transactions are ordered and finalised with the Byzantine fault-tolerant Tendermint protocol.  The Tendermint protocol provides high transaction throughput over a set of known validators and prevents the blockchain from forking.
-- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the ABCI. The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
-- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them.  The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
+- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the [ABCI](https://github.com/tendermint/abci). The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
+- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them. The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
 - **Permissioned Ethereum Virtual Machine:** This virtual machine is built to observe the Ethereum operation code specification and additionally asserts the correct permissions have been granted. Permissioning is enforced through secure native functions and underlies all smart contract code. An arbitrary but finite amount of gas is handed out for every execution to ensure a finite execution duration - “You don’t need money to play, when you have permission to play”.
-- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node.  Currently tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.  For proof-of-concept purposes we provide a monax-contracts.js library that automatically mirrors the smart contracts deployed on the chain and to develop middleware solutions against the blockchain network.  Future work on the light client will be aware of the ABI to natively translate calls on the API into signed transactions that can be broadcast on the network.
+- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node. Current tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.
 - **API Gateway:** Burrow exposes REST and JSON-RPC endpoints to interact with the blockchain network and the application state through broadcasting transactions, or querying the current state of the application. Websockets allow to subscribe to events, which is particularly valuable as the consensus engine and smart contract application can give unambiguously finalised results to transactions within one blocktime of about one second.
 
 ## Installation
 
-`burrow` is intended to be used by the `monax chains` command via [monax](https://monax.io/docs). Available commands such as `make | start | stop | logs | inspect | update` are used for chain lifecycle management.
-
-### For Developers
-Dependency management for Burrow is managed with [glide](github.com/Masterminds/glide), and you can build Burrow from source by following
 
-- [Install go](https://golang.org/doc/install)
+- [Install go](https://golang.org/doc/install) and have `$GOPATH` set
 - Ensure you have `gmp` installed (`sudo apt-get install libgmp3-dev || brew install gmp`)
-- and execute following commands in a terminal:
-- `go get github.com/Masterminds/glide`
-- `go get -d github.com/hyperledger/burrow`
-- `REPO=$($GOPATH/src/github.com/hyperledger/burrow)`
-- `cd $REPO && glide install`
-- `cd $REPO/cmd/burrow && go install`
 
+```
+go get github.com/hyperledger/burrow
+cd github.com/hyperledger/burrow
+make build
+```
+
+This will put the the `burrow` and `burrow-client` binaries in ...
 
-To run `burrow`, just type `$ burrow serve --work-dir <path to chain directory>`, where the chain directory needs to contain the configuration, genesis file, and private validator file as generated by `monax chains make`.
+## Usage
 
-This will start the node using the provided folder as working dir. If the path is omitted it defaults to `~/.monax`.
+The end result will be a `burrow.toml` that will be read in from your current working directory when starting `burrow`.
 
-For a Vagrant file see [monax-vagrant](https://github.com/monax/monax-vagrant) for drafts or soon this repo for [Vagrant](https://github.com/hyperledger/burrow/issues/514) and Packer files.
+### Configuration
 
-## Usage
+Note: here we'll need `monax-keys` to start the keys server (TODO, where?)
+
+The quick-and-dirty one-liner looks like:
+
+```
+burrow spec -p1 -f1 | burrow configure -s- -v0
+```
+
+which translates into:
+
+```
+burrow spec --participant-accounts=1 --full-accounts=1 > accounts.json
+burrow configure --genesis-spec=accounts.json --validator-index=0 > burrow.toml",,2018-03-02 07:10:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/171542239,https://github.com/hyperledger/burrow/pull/700#discussion_r171542239,silasdavis
https://github.com/hyperledger/burrow/pull/700,https://github.com/hyperledger/burrow/pull/700,"I feel like there are a couple of features that need documenting, namely `burrow configure --logging` (see `burrow configure --describe-logging`). Also I've added the ability to set the output format to a go template like `{{.time}}: {{.message}}`",817fa67a805203320caf4e5db4fa489e48b7f002,2018-03-01 12:25:07,171542670,"@@ -1,67 +1,69 @@
-# Hyperledger Burrow v0.16
+# Hyperledger Burrow
 
 |[![GoDoc](https://godoc.org/github.com/burrow?status.png)](https://godoc.org/github.com/hyperledger/burrow) | Linux |
 |---|-------|
 | Master | [![Circle CI](https://circleci.com/gh/hyperledger/burrow/tree/master.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/master) |
 | Develop | [![Circle CI (develop)](https://circleci.com/gh/hyperledger/burrow/tree/develop.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/develop) |
 
-Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake Tendermint consensus engine. For smart contract development most functionality is provided by `monax chains`, exposed through [monax](https://monax.io/docs), the entry point for the Monax Platform.
+Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code (Solidity) on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake [Tendermint](https://tendermint.com) consensus engine.
 
-## Table of Contents
+## What is Burrow
 
-- [What is burrow](#what-is-burrow)
-- [Installation](#installation)
-- [For developers](#for-developers)
-- [Usage](#usage)
-- [Configuration](#configuration)
-- [Contribute](#contribute)
-- [License](#license)
-- [Future work](#future-work)
-
-## What is Burrow ?
-
-Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification.  Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway.  More specifically Burrow consists of the following:
+Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification. Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway. More specifically Burrow consists of the following:
 
 - **Consensus Engine:** transactions are ordered and finalised with the Byzantine fault-tolerant Tendermint protocol.  The Tendermint protocol provides high transaction throughput over a set of known validators and prevents the blockchain from forking.
-- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the ABCI. The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
-- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them.  The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
+- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the [ABCI](https://github.com/tendermint/abci). The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
+- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them. The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
 - **Permissioned Ethereum Virtual Machine:** This virtual machine is built to observe the Ethereum operation code specification and additionally asserts the correct permissions have been granted. Permissioning is enforced through secure native functions and underlies all smart contract code. An arbitrary but finite amount of gas is handed out for every execution to ensure a finite execution duration - “You don’t need money to play, when you have permission to play”.
-- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node.  Currently tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.  For proof-of-concept purposes we provide a monax-contracts.js library that automatically mirrors the smart contracts deployed on the chain and to develop middleware solutions against the blockchain network.  Future work on the light client will be aware of the ABI to natively translate calls on the API into signed transactions that can be broadcast on the network.
+- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node. Current tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.
 - **API Gateway:** Burrow exposes REST and JSON-RPC endpoints to interact with the blockchain network and the application state through broadcasting transactions, or querying the current state of the application. Websockets allow to subscribe to events, which is particularly valuable as the consensus engine and smart contract application can give unambiguously finalised results to transactions within one blocktime of about one second.
 
 ## Installation
 
-`burrow` is intended to be used by the `monax chains` command via [monax](https://monax.io/docs). Available commands such as `make | start | stop | logs | inspect | update` are used for chain lifecycle management.
-
-### For Developers
-Dependency management for Burrow is managed with [glide](github.com/Masterminds/glide), and you can build Burrow from source by following
 
-- [Install go](https://golang.org/doc/install)
+- [Install go](https://golang.org/doc/install) and have `$GOPATH` set
 - Ensure you have `gmp` installed (`sudo apt-get install libgmp3-dev || brew install gmp`)
-- and execute following commands in a terminal:
-- `go get github.com/Masterminds/glide`
-- `go get -d github.com/hyperledger/burrow`
-- `REPO=$($GOPATH/src/github.com/hyperledger/burrow)`
-- `cd $REPO && glide install`
-- `cd $REPO/cmd/burrow && go install`
 
+```
+go get github.com/hyperledger/burrow
+cd github.com/hyperledger/burrow
+make build
+```
+
+This will put the the `burrow` and `burrow-client` binaries in ...
 
-To run `burrow`, just type `$ burrow serve --work-dir <path to chain directory>`, where the chain directory needs to contain the configuration, genesis file, and private validator file as generated by `monax chains make`.
+## Usage
 
-This will start the node using the provided folder as working dir. If the path is omitted it defaults to `~/.monax`.
+The end result will be a `burrow.toml` that will be read in from your current working directory when starting `burrow`.
 
-For a Vagrant file see [monax-vagrant](https://github.com/monax/monax-vagrant) for drafts or soon this repo for [Vagrant](https://github.com/hyperledger/burrow/issues/514) and Packer files.
+### Configuration
 
-## Usage
+Note: here we'll need `monax-keys` to start the keys server (TODO, where?)
+
+The quick-and-dirty one-liner looks like:
+
+```
+burrow spec -p1 -f1 | burrow configure -s- -v0
+```
+
+which translates into:
+
+```
+burrow spec --participant-accounts=1 --full-accounts=1 > accounts.json
+burrow configure --genesis-spec=accounts.json --validator-index=0 > burrow.toml
+```
 
-Once the server has started, it will begin syncing up with the network. At that point you may begin using it. The preferred way is through our [javascript api](https://github.com/monax/legacy-contracts.js), but it is possible to connect directly via HTTP or websocket.
+Once the `burrow.toml` has been created, we run:
 
-## Configuration
+```
+burrow
+```
 
-A commented template config will be written as part of the `monax chains make` [process](https://monax.io/docs/getting-started) and can be edited prior to the `monax chains start` [process](https://monax.io/docs/getting-started).
+and the logs will start streaming through.
 
 ### Logging
-Logging is highly configurable through the `config.toml` `[logging]` section. Each log line is a list of key-value pairs that flows from the root sink through possible child sinks. Each sink can have an output, a transform, and sinks that it outputs to. Below is a more involved example of than the one appearing in the default generated config of what you can configure: 
+
+Logging is highly configurable through the `burrow.toml` `[logging]` section. Each log line is a list of key-value pairs that flows from the root sink through possible child sinks. Each sink can have an output, a transform, and sinks that it outputs to. Below is a more involved example of than the one appearing in the default generated config of what you can configure: ",103,2018-03-02 07:10:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/171542670,https://github.com/hyperledger/burrow/pull/700#discussion_r171542670,silasdavis
https://github.com/hyperledger/burrow/pull/700,https://github.com/hyperledger/burrow/pull/700,++ Can we add https://lists.hyperledger.org/mailman/listinfo,817fa67a805203320caf4e5db4fa489e48b7f002,2018-03-01 12:26:09,171542864,"@@ -100,19 +102,18 @@ Logging is highly configurable through the `config.toml` `[logging]` section. Ea
           output_type = ""file""
           path = ""/var/log/burrow-network.log""
 ```
+
 ## Contribute
 
-We welcome all contributions and have submitted the code base to the Hyperledger project governance during incubation phase.  As an integral part of this effort we want to invite new contributors, not just to maintain but also to steer the future direction of the code in an active and open process.
+We welcome any and all contributions. Read the [contributing file](.github/CONTRIBUTING.md) for more informaion on making your first Pull Request to Burrow!
 
 You can find us on:
-- [the Marmot Den (slack)](http://slack.monax.io)
-- [here on Github](http://github.com/hyperledger/burrow/issues)
-- [support.monax.io](http://support.monax.io)
-- read the [Contributor file](.github/CONTRIBUTING.md)
+- [Hyperledger Chat](https://chat.hyperledger.org)",122,2018-03-02 07:10:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/171542864,https://github.com/hyperledger/burrow/pull/700#discussion_r171542864,silasdavis
https://github.com/hyperledger/burrow/pull/700,https://github.com/hyperledger/burrow/pull/700,lets.,817fa67a805203320caf4e5db4fa489e48b7f002,2018-03-01 23:31:16,171727359,"@@ -1,67 +1,69 @@
-# Hyperledger Burrow v0.16
+# Hyperledger Burrow
 
 |[![GoDoc](https://godoc.org/github.com/burrow?status.png)](https://godoc.org/github.com/hyperledger/burrow) | Linux |
 |---|-------|
 | Master | [![Circle CI](https://circleci.com/gh/hyperledger/burrow/tree/master.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/master) |
 | Develop | [![Circle CI (develop)](https://circleci.com/gh/hyperledger/burrow/tree/develop.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/develop) |
 
-Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake Tendermint consensus engine. For smart contract development most functionality is provided by `monax chains`, exposed through [monax](https://monax.io/docs), the entry point for the Monax Platform.
+Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code (Solidity) on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake [Tendermint](https://tendermint.com) consensus engine.
 
-## Table of Contents
+## What is Burrow
 
-- [What is burrow](#what-is-burrow)
-- [Installation](#installation)
-- [For developers](#for-developers)
-- [Usage](#usage)
-- [Configuration](#configuration)
-- [Contribute](#contribute)
-- [License](#license)
-- [Future work](#future-work)
-
-## What is Burrow ?
-
-Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification.  Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway.  More specifically Burrow consists of the following:
+Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification. Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway. More specifically Burrow consists of the following:
 
 - **Consensus Engine:** transactions are ordered and finalised with the Byzantine fault-tolerant Tendermint protocol.  The Tendermint protocol provides high transaction throughput over a set of known validators and prevents the blockchain from forking.
-- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the ABCI. The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
-- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them.  The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
+- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the [ABCI](https://github.com/tendermint/abci). The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
+- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them. The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
 - **Permissioned Ethereum Virtual Machine:** This virtual machine is built to observe the Ethereum operation code specification and additionally asserts the correct permissions have been granted. Permissioning is enforced through secure native functions and underlies all smart contract code. An arbitrary but finite amount of gas is handed out for every execution to ensure a finite execution duration - “You don’t need money to play, when you have permission to play”.
-- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node.  Currently tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.  For proof-of-concept purposes we provide a monax-contracts.js library that automatically mirrors the smart contracts deployed on the chain and to develop middleware solutions against the blockchain network.  Future work on the light client will be aware of the ABI to natively translate calls on the API into signed transactions that can be broadcast on the network.
+- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node. Current tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.
 - **API Gateway:** Burrow exposes REST and JSON-RPC endpoints to interact with the blockchain network and the application state through broadcasting transactions, or querying the current state of the application. Websockets allow to subscribe to events, which is particularly valuable as the consensus engine and smart contract application can give unambiguously finalised results to transactions within one blocktime of about one second.
 
 ## Installation
 
-`burrow` is intended to be used by the `monax chains` command via [monax](https://monax.io/docs). Available commands such as `make | start | stop | logs | inspect | update` are used for chain lifecycle management.
-
-### For Developers
-Dependency management for Burrow is managed with [glide](github.com/Masterminds/glide), and you can build Burrow from source by following
 
-- [Install go](https://golang.org/doc/install)
+- [Install go](https://golang.org/doc/install) and have `$GOPATH` set
 - Ensure you have `gmp` installed (`sudo apt-get install libgmp3-dev || brew install gmp`)
-- and execute following commands in a terminal:
-- `go get github.com/Masterminds/glide`
-- `go get -d github.com/hyperledger/burrow`
-- `REPO=$($GOPATH/src/github.com/hyperledger/burrow)`
-- `cd $REPO && glide install`
-- `cd $REPO/cmd/burrow && go install`
 
+```
+go get github.com/hyperledger/burrow
+cd github.com/hyperledger/burrow
+make build
+```
+
+This will put the the `burrow` and `burrow-client` binaries in ...
 
-To run `burrow`, just type `$ burrow serve --work-dir <path to chain directory>`, where the chain directory needs to contain the configuration, genesis file, and private validator file as generated by `monax chains make`.
+## Usage
 
-This will start the node using the provided folder as working dir. If the path is omitted it defaults to `~/.monax`.
+The end result will be a `burrow.toml` that will be read in from your current working directory when starting `burrow`.
 
-For a Vagrant file see [monax-vagrant](https://github.com/monax/monax-vagrant) for drafts or soon this repo for [Vagrant](https://github.com/hyperledger/burrow/issues/514) and Packer files.
+### Configuration
 
-## Usage
+Note: here we'll need `monax-keys` to start the keys server (TODO, where?)
+
+The quick-and-dirty one-liner looks like:
+
+```
+burrow spec -p1 -f1 | burrow configure -s- -v0
+```
+
+which translates into:
+
+```
+burrow spec --participant-accounts=1 --full-accounts=1 > accounts.json
+burrow configure --genesis-spec=accounts.json --validator-index=0 > burrow.toml",,2018-03-02 07:10:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/171727359,https://github.com/hyperledger/burrow/pull/700#discussion_r171727359,zramsay
https://github.com/hyperledger/burrow/pull/700,https://github.com/hyperledger/burrow/pull/700,i haven't played with the logging yet to know enough to write about it,817fa67a805203320caf4e5db4fa489e48b7f002,2018-03-01 23:31:40,171727424,"@@ -1,67 +1,69 @@
-# Hyperledger Burrow v0.16
+# Hyperledger Burrow
 
 |[![GoDoc](https://godoc.org/github.com/burrow?status.png)](https://godoc.org/github.com/hyperledger/burrow) | Linux |
 |---|-------|
 | Master | [![Circle CI](https://circleci.com/gh/hyperledger/burrow/tree/master.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/master) |
 | Develop | [![Circle CI (develop)](https://circleci.com/gh/hyperledger/burrow/tree/develop.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/develop) |
 
-Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake Tendermint consensus engine. For smart contract development most functionality is provided by `monax chains`, exposed through [monax](https://monax.io/docs), the entry point for the Monax Platform.
+Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code (Solidity) on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake [Tendermint](https://tendermint.com) consensus engine.
 
-## Table of Contents
+## What is Burrow
 
-- [What is burrow](#what-is-burrow)
-- [Installation](#installation)
-- [For developers](#for-developers)
-- [Usage](#usage)
-- [Configuration](#configuration)
-- [Contribute](#contribute)
-- [License](#license)
-- [Future work](#future-work)
-
-## What is Burrow ?
-
-Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification.  Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway.  More specifically Burrow consists of the following:
+Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification. Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway. More specifically Burrow consists of the following:
 
 - **Consensus Engine:** transactions are ordered and finalised with the Byzantine fault-tolerant Tendermint protocol.  The Tendermint protocol provides high transaction throughput over a set of known validators and prevents the blockchain from forking.
-- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the ABCI. The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
-- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them.  The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
+- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the [ABCI](https://github.com/tendermint/abci). The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
+- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them. The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
 - **Permissioned Ethereum Virtual Machine:** This virtual machine is built to observe the Ethereum operation code specification and additionally asserts the correct permissions have been granted. Permissioning is enforced through secure native functions and underlies all smart contract code. An arbitrary but finite amount of gas is handed out for every execution to ensure a finite execution duration - “You don’t need money to play, when you have permission to play”.
-- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node.  Currently tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.  For proof-of-concept purposes we provide a monax-contracts.js library that automatically mirrors the smart contracts deployed on the chain and to develop middleware solutions against the blockchain network.  Future work on the light client will be aware of the ABI to natively translate calls on the API into signed transactions that can be broadcast on the network.
+- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node. Current tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.
 - **API Gateway:** Burrow exposes REST and JSON-RPC endpoints to interact with the blockchain network and the application state through broadcasting transactions, or querying the current state of the application. Websockets allow to subscribe to events, which is particularly valuable as the consensus engine and smart contract application can give unambiguously finalised results to transactions within one blocktime of about one second.
 
 ## Installation
 
-`burrow` is intended to be used by the `monax chains` command via [monax](https://monax.io/docs). Available commands such as `make | start | stop | logs | inspect | update` are used for chain lifecycle management.
-
-### For Developers
-Dependency management for Burrow is managed with [glide](github.com/Masterminds/glide), and you can build Burrow from source by following
 
-- [Install go](https://golang.org/doc/install)
+- [Install go](https://golang.org/doc/install) and have `$GOPATH` set
 - Ensure you have `gmp` installed (`sudo apt-get install libgmp3-dev || brew install gmp`)
-- and execute following commands in a terminal:
-- `go get github.com/Masterminds/glide`
-- `go get -d github.com/hyperledger/burrow`
-- `REPO=$($GOPATH/src/github.com/hyperledger/burrow)`
-- `cd $REPO && glide install`
-- `cd $REPO/cmd/burrow && go install`
 
+```
+go get github.com/hyperledger/burrow
+cd github.com/hyperledger/burrow
+make build
+```
+
+This will put the the `burrow` and `burrow-client` binaries in ...
 
-To run `burrow`, just type `$ burrow serve --work-dir <path to chain directory>`, where the chain directory needs to contain the configuration, genesis file, and private validator file as generated by `monax chains make`.
+## Usage
 
-This will start the node using the provided folder as working dir. If the path is omitted it defaults to `~/.monax`.
+The end result will be a `burrow.toml` that will be read in from your current working directory when starting `burrow`.
 
-For a Vagrant file see [monax-vagrant](https://github.com/monax/monax-vagrant) for drafts or soon this repo for [Vagrant](https://github.com/hyperledger/burrow/issues/514) and Packer files.
+### Configuration
 
-## Usage
+Note: here we'll need `monax-keys` to start the keys server (TODO, where?)
+
+The quick-and-dirty one-liner looks like:
+
+```
+burrow spec -p1 -f1 | burrow configure -s- -v0
+```
+
+which translates into:
+
+```
+burrow spec --participant-accounts=1 --full-accounts=1 > accounts.json
+burrow configure --genesis-spec=accounts.json --validator-index=0 > burrow.toml
+```
 
-Once the server has started, it will begin syncing up with the network. At that point you may begin using it. The preferred way is through our [javascript api](https://github.com/monax/legacy-contracts.js), but it is possible to connect directly via HTTP or websocket.
+Once the `burrow.toml` has been created, we run:
 
-## Configuration
+```
+burrow
+```
 
-A commented template config will be written as part of the `monax chains make` [process](https://monax.io/docs/getting-started) and can be edited prior to the `monax chains start` [process](https://monax.io/docs/getting-started).
+and the logs will start streaming through.
 
 ### Logging
-Logging is highly configurable through the `config.toml` `[logging]` section. Each log line is a list of key-value pairs that flows from the root sink through possible child sinks. Each sink can have an output, a transform, and sinks that it outputs to. Below is a more involved example of than the one appearing in the default generated config of what you can configure: 
+
+Logging is highly configurable through the `burrow.toml` `[logging]` section. Each log line is a list of key-value pairs that flows from the root sink through possible child sinks. Each sink can have an output, a transform, and sinks that it outputs to. Below is a more involved example of than the one appearing in the default generated config of what you can configure: ",103,2018-03-02 07:10:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/171727424,https://github.com/hyperledger/burrow/pull/700#discussion_r171727424,zramsay
https://github.com/hyperledger/burrow/pull/700,https://github.com/hyperledger/burrow/pull/700,I was unable to `build` without this. Is `glide install` not required in the latest build process?,817fa67a805203320caf4e5db4fa489e48b7f002,2018-03-02 03:40:56,171758976,"@@ -1,67 +1,69 @@
-# Hyperledger Burrow v0.16
+# Hyperledger Burrow
 
 |[![GoDoc](https://godoc.org/github.com/burrow?status.png)](https://godoc.org/github.com/hyperledger/burrow) | Linux |
 |---|-------|
 | Master | [![Circle CI](https://circleci.com/gh/hyperledger/burrow/tree/master.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/master) |
 | Develop | [![Circle CI (develop)](https://circleci.com/gh/hyperledger/burrow/tree/develop.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/develop) |
 
-Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake Tendermint consensus engine. For smart contract development most functionality is provided by `monax chains`, exposed through [monax](https://monax.io/docs), the entry point for the Monax Platform.
+Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code (Solidity) on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake [Tendermint](https://tendermint.com) consensus engine.
 
-## Table of Contents
+## What is Burrow
 
-- [What is burrow](#what-is-burrow)
-- [Installation](#installation)
-- [For developers](#for-developers)
-- [Usage](#usage)
-- [Configuration](#configuration)
-- [Contribute](#contribute)
-- [License](#license)
-- [Future work](#future-work)
-
-## What is Burrow ?
-
-Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification.  Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway.  More specifically Burrow consists of the following:
+Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification. Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway. More specifically Burrow consists of the following:
 
 - **Consensus Engine:** transactions are ordered and finalised with the Byzantine fault-tolerant Tendermint protocol.  The Tendermint protocol provides high transaction throughput over a set of known validators and prevents the blockchain from forking.
-- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the ABCI. The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
-- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them.  The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
+- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the [ABCI](https://github.com/tendermint/abci). The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
+- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them. The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
 - **Permissioned Ethereum Virtual Machine:** This virtual machine is built to observe the Ethereum operation code specification and additionally asserts the correct permissions have been granted. Permissioning is enforced through secure native functions and underlies all smart contract code. An arbitrary but finite amount of gas is handed out for every execution to ensure a finite execution duration - “You don’t need money to play, when you have permission to play”.
-- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node.  Currently tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.  For proof-of-concept purposes we provide a monax-contracts.js library that automatically mirrors the smart contracts deployed on the chain and to develop middleware solutions against the blockchain network.  Future work on the light client will be aware of the ABI to natively translate calls on the API into signed transactions that can be broadcast on the network.
+- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node. Current tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.
 - **API Gateway:** Burrow exposes REST and JSON-RPC endpoints to interact with the blockchain network and the application state through broadcasting transactions, or querying the current state of the application. Websockets allow to subscribe to events, which is particularly valuable as the consensus engine and smart contract application can give unambiguously finalised results to transactions within one blocktime of about one second.
 
 ## Installation
 
-`burrow` is intended to be used by the `monax chains` command via [monax](https://monax.io/docs). Available commands such as `make | start | stop | logs | inspect | update` are used for chain lifecycle management.
-
-### For Developers
-Dependency management for Burrow is managed with [glide](github.com/Masterminds/glide), and you can build Burrow from source by following
 
-- [Install go](https://golang.org/doc/install)
+- [Install go](https://golang.org/doc/install) and have `$GOPATH` set
 - Ensure you have `gmp` installed (`sudo apt-get install libgmp3-dev || brew install gmp`)
-- and execute following commands in a terminal:
-- `go get github.com/Masterminds/glide`
-- `go get -d github.com/hyperledger/burrow`
-- `REPO=$($GOPATH/src/github.com/hyperledger/burrow)`
-- `cd $REPO && glide install`",53,2018-03-02 07:10:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/171758976,https://github.com/hyperledger/burrow/pull/700#discussion_r171758976,AyushyaChitransh
https://github.com/hyperledger/burrow/pull/700,https://github.com/hyperledger/burrow/pull/700,`glide` has been replaced by the official go tool for dependency management (`dep`) on the #develop branch,817fa67a805203320caf4e5db4fa489e48b7f002,2018-03-02 04:11:39,171761704,"@@ -1,67 +1,69 @@
-# Hyperledger Burrow v0.16
+# Hyperledger Burrow
 
 |[![GoDoc](https://godoc.org/github.com/burrow?status.png)](https://godoc.org/github.com/hyperledger/burrow) | Linux |
 |---|-------|
 | Master | [![Circle CI](https://circleci.com/gh/hyperledger/burrow/tree/master.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/master) |
 | Develop | [![Circle CI (develop)](https://circleci.com/gh/hyperledger/burrow/tree/develop.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/develop) |
 
-Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake Tendermint consensus engine. For smart contract development most functionality is provided by `monax chains`, exposed through [monax](https://monax.io/docs), the entry point for the Monax Platform.
+Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code (Solidity) on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake [Tendermint](https://tendermint.com) consensus engine.
 
-## Table of Contents
+## What is Burrow
 
-- [What is burrow](#what-is-burrow)
-- [Installation](#installation)
-- [For developers](#for-developers)
-- [Usage](#usage)
-- [Configuration](#configuration)
-- [Contribute](#contribute)
-- [License](#license)
-- [Future work](#future-work)
-
-## What is Burrow ?
-
-Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification.  Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway.  More specifically Burrow consists of the following:
+Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification. Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway. More specifically Burrow consists of the following:
 
 - **Consensus Engine:** transactions are ordered and finalised with the Byzantine fault-tolerant Tendermint protocol.  The Tendermint protocol provides high transaction throughput over a set of known validators and prevents the blockchain from forking.
-- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the ABCI. The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
-- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them.  The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
+- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the [ABCI](https://github.com/tendermint/abci). The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
+- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them. The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
 - **Permissioned Ethereum Virtual Machine:** This virtual machine is built to observe the Ethereum operation code specification and additionally asserts the correct permissions have been granted. Permissioning is enforced through secure native functions and underlies all smart contract code. An arbitrary but finite amount of gas is handed out for every execution to ensure a finite execution duration - “You don’t need money to play, when you have permission to play”.
-- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node.  Currently tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.  For proof-of-concept purposes we provide a monax-contracts.js library that automatically mirrors the smart contracts deployed on the chain and to develop middleware solutions against the blockchain network.  Future work on the light client will be aware of the ABI to natively translate calls on the API into signed transactions that can be broadcast on the network.
+- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node. Current tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.
 - **API Gateway:** Burrow exposes REST and JSON-RPC endpoints to interact with the blockchain network and the application state through broadcasting transactions, or querying the current state of the application. Websockets allow to subscribe to events, which is particularly valuable as the consensus engine and smart contract application can give unambiguously finalised results to transactions within one blocktime of about one second.
 
 ## Installation
 
-`burrow` is intended to be used by the `monax chains` command via [monax](https://monax.io/docs). Available commands such as `make | start | stop | logs | inspect | update` are used for chain lifecycle management.
-
-### For Developers
-Dependency management for Burrow is managed with [glide](github.com/Masterminds/glide), and you can build Burrow from source by following
 
-- [Install go](https://golang.org/doc/install)
+- [Install go](https://golang.org/doc/install) and have `$GOPATH` set
 - Ensure you have `gmp` installed (`sudo apt-get install libgmp3-dev || brew install gmp`)
-- and execute following commands in a terminal:
-- `go get github.com/Masterminds/glide`
-- `go get -d github.com/hyperledger/burrow`
-- `REPO=$($GOPATH/src/github.com/hyperledger/burrow)`
-- `cd $REPO && glide install`",53,2018-03-02 07:10:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/171761704,https://github.com/hyperledger/burrow/pull/700#discussion_r171761704,zramsay
https://github.com/hyperledger/burrow/pull/700,https://github.com/hyperledger/burrow/pull/700,#703,817fa67a805203320caf4e5db4fa489e48b7f002,2018-03-02 07:12:27,171776898,"@@ -1,67 +1,69 @@
-# Hyperledger Burrow v0.16
+# Hyperledger Burrow
 
 |[![GoDoc](https://godoc.org/github.com/burrow?status.png)](https://godoc.org/github.com/hyperledger/burrow) | Linux |
 |---|-------|
 | Master | [![Circle CI](https://circleci.com/gh/hyperledger/burrow/tree/master.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/master) |
 | Develop | [![Circle CI (develop)](https://circleci.com/gh/hyperledger/burrow/tree/develop.svg?style=svg)](https://circleci.com/gh/hyperledger/burrow/tree/develop) |
 
-Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake Tendermint consensus engine. For smart contract development most functionality is provided by `monax chains`, exposed through [monax](https://monax.io/docs), the entry point for the Monax Platform.
+Hyperledger Burrow is a permissioned Ethereum smart-contract blockchain node built with <3 by Monax. It executes Ethereum smart contract code (Solidity) on a permissioned virtual machine. Burrow provides transaction finality and high transaction throughput on a proof-of-stake [Tendermint](https://tendermint.com) consensus engine.
 
-## Table of Contents
+## What is Burrow
 
-- [What is burrow](#what-is-burrow)
-- [Installation](#installation)
-- [For developers](#for-developers)
-- [Usage](#usage)
-- [Configuration](#configuration)
-- [Contribute](#contribute)
-- [License](#license)
-- [Future work](#future-work)
-
-## What is Burrow ?
-
-Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification.  Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway.  More specifically Burrow consists of the following:
+Hyperledger Burrow is a permissioned blockchain node that executes smart contract code following the Ethereum specification. Burrow is built for a multi-chain universe with application specific optimization in mind. Burrow as a node is constructed out of three main components; the consensus engine, the permissioned Ethereum virtual machine and the rpc gateway. More specifically Burrow consists of the following:
 
 - **Consensus Engine:** transactions are ordered and finalised with the Byzantine fault-tolerant Tendermint protocol.  The Tendermint protocol provides high transaction throughput over a set of known validators and prevents the blockchain from forking.
-- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the ABCI. The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
-- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them.  The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
+- **Application Blockchain Interface (ABCI):** The smart contract application interfaces with the consensus engine over the [ABCI](https://github.com/tendermint/abci). The ABCI allows for the consensus engine to remain agnostic from the smart contract application.
+- **Smart Contract Application:** transactions are validated and applied to the application state in the order that the consensus engine has finalised them. The application state consists of all accounts, the validator set and the name registry. Accounts in Burrow have permissions and either contain smart contract code or correspond to a public-private key pair. A transaction that calls on the smart contract code in a given account will activate the execution of that account’s code in a permissioned virtual machine.
 - **Permissioned Ethereum Virtual Machine:** This virtual machine is built to observe the Ethereum operation code specification and additionally asserts the correct permissions have been granted. Permissioning is enforced through secure native functions and underlies all smart contract code. An arbitrary but finite amount of gas is handed out for every execution to ensure a finite execution duration - “You don’t need money to play, when you have permission to play”.
-- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node.  Currently tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.  For proof-of-concept purposes we provide a monax-contracts.js library that automatically mirrors the smart contracts deployed on the chain and to develop middleware solutions against the blockchain network.  Future work on the light client will be aware of the ABI to natively translate calls on the API into signed transactions that can be broadcast on the network.
+- **Application Binary Interface (ABI):** transactions need to be formulated in a binary format that can be processed by the blockchain node. Current tooling provides functionality to compile, deploy and link solidity smart contracts and formulate transactions to call smart contracts on the chain.
 - **API Gateway:** Burrow exposes REST and JSON-RPC endpoints to interact with the blockchain network and the application state through broadcasting transactions, or querying the current state of the application. Websockets allow to subscribe to events, which is particularly valuable as the consensus engine and smart contract application can give unambiguously finalised results to transactions within one blocktime of about one second.
 
 ## Installation
 
-`burrow` is intended to be used by the `monax chains` command via [monax](https://monax.io/docs). Available commands such as `make | start | stop | logs | inspect | update` are used for chain lifecycle management.
-
-### For Developers
-Dependency management for Burrow is managed with [glide](github.com/Masterminds/glide), and you can build Burrow from source by following
 
-- [Install go](https://golang.org/doc/install)
+- [Install go](https://golang.org/doc/install) and have `$GOPATH` set
 - Ensure you have `gmp` installed (`sudo apt-get install libgmp3-dev || brew install gmp`)
-- and execute following commands in a terminal:
-- `go get github.com/Masterminds/glide`
-- `go get -d github.com/hyperledger/burrow`
-- `REPO=$($GOPATH/src/github.com/hyperledger/burrow)`
-- `cd $REPO && glide install`
-- `cd $REPO/cmd/burrow && go install`
 
+```
+go get github.com/hyperledger/burrow
+cd github.com/hyperledger/burrow
+make build
+```
+
+This will put the the `burrow` and `burrow-client` binaries in ...
 
-To run `burrow`, just type `$ burrow serve --work-dir <path to chain directory>`, where the chain directory needs to contain the configuration, genesis file, and private validator file as generated by `monax chains make`.
+## Usage
 
-This will start the node using the provided folder as working dir. If the path is omitted it defaults to `~/.monax`.
+The end result will be a `burrow.toml` that will be read in from your current working directory when starting `burrow`.
 
-For a Vagrant file see [monax-vagrant](https://github.com/monax/monax-vagrant) for drafts or soon this repo for [Vagrant](https://github.com/hyperledger/burrow/issues/514) and Packer files.
+### Configuration
 
-## Usage
+Note: here we'll need `monax-keys` to start the keys server (TODO, where?)
+
+The quick-and-dirty one-liner looks like:
+
+```
+burrow spec -p1 -f1 | burrow configure -s- -v0
+```
+
+which translates into:
+
+```
+burrow spec --participant-accounts=1 --full-accounts=1 > accounts.json
+burrow configure --genesis-spec=accounts.json --validator-index=0 > burrow.toml
+```
 
-Once the server has started, it will begin syncing up with the network. At that point you may begin using it. The preferred way is through our [javascript api](https://github.com/monax/legacy-contracts.js), but it is possible to connect directly via HTTP or websocket.
+Once the `burrow.toml` has been created, we run:
 
-## Configuration
+```
+burrow
+```
 
-A commented template config will be written as part of the `monax chains make` [process](https://monax.io/docs/getting-started) and can be edited prior to the `monax chains start` [process](https://monax.io/docs/getting-started).
+and the logs will start streaming through.
 
 ### Logging
-Logging is highly configurable through the `config.toml` `[logging]` section. Each log line is a list of key-value pairs that flows from the root sink through possible child sinks. Each sink can have an output, a transform, and sinks that it outputs to. Below is a more involved example of than the one appearing in the default generated config of what you can configure: 
+
+Logging is highly configurable through the `burrow.toml` `[logging]` section. Each log line is a list of key-value pairs that flows from the root sink through possible child sinks. Each sink can have an output, a transform, and sinks that it outputs to. Below is a more involved example of than the one appearing in the default generated config of what you can configure: ",103,2018-03-02 07:12:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/171776898,https://github.com/hyperledger/burrow/pull/700#discussion_r171776898,zramsay
https://github.com/hyperledger/burrow/pull/699,https://github.com/hyperledger/burrow/pull/699,build_race_clien(t?) did you delete one too many letters?,cdc9cd57c1434455e862bff0248e0989e564483f,2018-02-27 14:29:41,170939129,"@@ -91,27 +94,36 @@ build:	check build_db build_client
 
 # build all targets in github.com/hyperledger/burrow with checks for race conditions
 .PHONY: build_race
-build_race:	check build_race_db build_race_client build_race_keys
+build_race:	check build_race_db build_race_clien",,2018-02-27 14:46:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/170939129,https://github.com/hyperledger/burrow/pull/699#discussion_r170939129,dennismckinnon
https://github.com/hyperledger/burrow/pull/698,https://github.com/hyperledger/burrow/pull/698,"This should be within the block above containing line 914, where the error is checked for readability. Note on develop I have renamed this `err` (which shadows the return value `err`!) to `callErr`, when you rebase against develop (which you need to do) you'll need to change that.",6e40c60da1ed5b17f2219198eb273436a82bd821,2018-03-03 21:07:11,172028750,"@@ -921,6 +926,10 @@ func (vm *VM) call(caller, callee acm.MutableAccount, code, input []byte, value
 				}
 			}
 
+			if err == ErrExecutionReverted {",,2018-03-05 21:55:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/172028750,https://github.com/hyperledger/burrow/pull/698#discussion_r172028750,silasdavis
https://github.com/hyperledger/burrow/pull/698,https://github.com/hyperledger/burrow/pull/698,Cool...  It this bytecode the testcase from the EIP? If so can you add a comment with a link and reference to EIP-140,6e40c60da1ed5b17f2219198eb273436a82bd821,2018-03-03 21:08:22,172028779,"@@ -158,6 +158,26 @@ func TestSubcurrency(t *testing.T) {
 	}
 }
 
+func TestRevert(t *testing.T) {
+	ourVm := NewVM(newAppState(), DefaultDynamicMemoryProvider, newParams(), acm.ZeroAddress, nil, logger)
+
+	// Create accounts
+	account1 := newAccount(1)
+	account2 := newAccount(1, 0, 1)
+
+	var gas uint64 = 100000
+
+	bytecode := MustSplice(PUSH32, 0x72, 0x65, 0x76, 0x65, 0x72, 0x74, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61,",15,2018-03-05 21:55:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/172028779,https://github.com/hyperledger/burrow/pull/698#discussion_r172028779,silasdavis
https://github.com/hyperledger/burrow/pull/698,https://github.com/hyperledger/burrow/pull/698,"This is unnecessary, remove and just return `output` which is the correct slice already (as in `RETURN`)",6e40c60da1ed5b17f2219198eb273436a82bd821,2018-03-03 21:13:06,172028900,"@@ -936,6 +945,19 @@ func (vm *VM) call(caller, callee acm.MutableAccount, code, input []byte, value
 			vm.Debugf("" => [%v, %v] (%d) 0x%X\n"", offset, size, len(output), output)
 			return output, nil
 
+		case REVERT: // 0xFD
+			offset, size := stack.Pop64(), stack.Pop64()
+			output, memErr := memory.Read(offset, size)
+			if memErr != nil {
+				vm.Debugf("" => Memory err: %s"", memErr)
+				return nil, firstErr(err, ErrMemoryOutOfBounds)
+			}
+
+			outputMessage := output[offset:size]",,2018-03-05 21:55:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/172028900,https://github.com/hyperledger/burrow/pull/698#discussion_r172028900,silasdavis
https://github.com/hyperledger/burrow/pull/698,https://github.com/hyperledger/burrow/pull/698,"You renamed err (in entire case definition for CALL, DELEGATECALL, and CALLCODE) to callErr, or you changed ErrExecutionReverted to callErr? Not sure what to do here other than move the above check to block beginning at LN# 914",6e40c60da1ed5b17f2219198eb273436a82bd821,2018-03-05 16:00:00,172235263,"@@ -921,6 +926,10 @@ func (vm *VM) call(caller, callee acm.MutableAccount, code, input []byte, value
 				}
 			}
 
+			if err == ErrExecutionReverted {",,2018-03-05 21:55:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/172235263,https://github.com/hyperledger/burrow/pull/698#discussion_r172235263,smblucker
https://github.com/hyperledger/burrow/pull/698,https://github.com/hyperledger/burrow/pull/698,"I will assume you meant you renamed err and not ErrExecutionReverted and push changes
",6e40c60da1ed5b17f2219198eb273436a82bd821,2018-03-05 16:46:09,172251867,"@@ -921,6 +926,10 @@ func (vm *VM) call(caller, callee acm.MutableAccount, code, input []byte, value
 				}
 			}
 
+			if err == ErrExecutionReverted {",,2018-03-05 21:55:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/172251867,https://github.com/hyperledger/burrow/pull/698#discussion_r172251867,smblucker
https://github.com/hyperledger/burrow/pull/695,https://github.com/hyperledger/burrow/pull/695,++ for using bin,f127426255c34be32494b273e4ba1410c5f40323,2018-02-27 03:08:43,170804378,"@@ -91,27 +94,36 @@ build:	check build_db build_client
 
 # build all targets in github.com/hyperledger/burrow with checks for race conditions
 .PHONY: build_race
-build_race:	check build_race_db build_race_client build_race_keys
+build_race:	check build_race_db build_race_clien
 
 # build burrow
 .PHONY: build_db
 build_db:
-	go build -o ${REPO}/target/burrow-${COMMIT_SHA} ./cmd/burrow
+	go build -o ${REPO}/bin/burrow ./cmd/burrow
 
 # build burrow-client
 .PHONY: build_client
 build_client:
-	go build -o ${REPO}/target/burrow-client-${COMMIT_SHA} ./client/cmd/burrow-client
+	go build -o ${REPO}/bin/burrow-client ./client/cmd/burrow-client",29,2018-02-27 03:08:44,https://api.github.com/repos/hyperledger/burrow/pulls/comments/170804378,https://github.com/hyperledger/burrow/pull/695#discussion_r170804378,zramsay
https://github.com/hyperledger/burrow/pull/695,https://github.com/hyperledger/burrow/pull/695,would be good to have an `make install` target though,f127426255c34be32494b273e4ba1410c5f40323,2018-02-27 03:09:03,170804414,"@@ -91,27 +94,36 @@ build:	check build_db build_client
 
 # build all targets in github.com/hyperledger/burrow with checks for race conditions
 .PHONY: build_race
-build_race:	check build_race_db build_race_client build_race_keys
+build_race:	check build_race_db build_race_clien
 
 # build burrow
 .PHONY: build_db
 build_db:
-	go build -o ${REPO}/target/burrow-${COMMIT_SHA} ./cmd/burrow
+	go build -o ${REPO}/bin/burrow ./cmd/burrow
 
 # build burrow-client
 .PHONY: build_client
 build_client:
-	go build -o ${REPO}/target/burrow-client-${COMMIT_SHA} ./client/cmd/burrow-client
+	go build -o ${REPO}/bin/burrow-client ./client/cmd/burrow-client",29,2018-02-27 03:09:03,https://api.github.com/repos/hyperledger/burrow/pulls/comments/170804414,https://github.com/hyperledger/burrow/pull/695#discussion_r170804414,zramsay
https://github.com/hyperledger/burrow/pull/695,https://github.com/hyperledger/burrow/pull/695,"I did wonder about that, but I sort of feel like either we do OS distribution properly with packages appropriate for each OS/distribution or we don't bother at all. If `make install` is just copying `burrow*` to `/usr/local/bin` then it doesn't provide much value and on the contrary it risks obfuscating the fact that we are dealing with a statically compiled Go binary that you can just run from any location with the same arch.

I think down the line (probably before next release) I'd like to support https://goreleaser.com/. Initially just for cross-compiling, but it does have integration to packaging systems. It's just I don't really want to get (back) into supporting packaging - it's not worth our time. ",f127426255c34be32494b273e4ba1410c5f40323,2018-02-27 10:20:47,170875067,"@@ -91,27 +94,36 @@ build:	check build_db build_client
 
 # build all targets in github.com/hyperledger/burrow with checks for race conditions
 .PHONY: build_race
-build_race:	check build_race_db build_race_client build_race_keys
+build_race:	check build_race_db build_race_clien
 
 # build burrow
 .PHONY: build_db
 build_db:
-	go build -o ${REPO}/target/burrow-${COMMIT_SHA} ./cmd/burrow
+	go build -o ${REPO}/bin/burrow ./cmd/burrow
 
 # build burrow-client
 .PHONY: build_client
 build_client:
-	go build -o ${REPO}/target/burrow-client-${COMMIT_SHA} ./client/cmd/burrow-client
+	go build -o ${REPO}/bin/burrow-client ./client/cmd/burrow-client",29,2018-02-27 10:21:32,https://api.github.com/repos/hyperledger/burrow/pulls/comments/170875067,https://github.com/hyperledger/burrow/pull/695#discussion_r170875067,silasdavis
https://github.com/hyperledger/burrow/pull/695,https://github.com/hyperledger/burrow/pull/695,"oh, i missed (originally) the removal of the `-${COMMIT_SHA}` whichhelps",f127426255c34be32494b273e4ba1410c5f40323,2018-03-01 05:43:50,171467701,"@@ -91,27 +94,36 @@ build:	check build_db build_client
 
 # build all targets in github.com/hyperledger/burrow with checks for race conditions
 .PHONY: build_race
-build_race:	check build_race_db build_race_client build_race_keys
+build_race:	check build_race_db build_race_clien
 
 # build burrow
 .PHONY: build_db
 build_db:
-	go build -o ${REPO}/target/burrow-${COMMIT_SHA} ./cmd/burrow
+	go build -o ${REPO}/bin/burrow ./cmd/burrow
 
 # build burrow-client
 .PHONY: build_client
 build_client:
-	go build -o ${REPO}/target/burrow-client-${COMMIT_SHA} ./client/cmd/burrow-client
+	go build -o ${REPO}/bin/burrow-client ./client/cmd/burrow-client",29,2018-03-01 05:43:50,https://api.github.com/repos/hyperledger/burrow/pulls/comments/171467701,https://github.com/hyperledger/burrow/pull/695#discussion_r171467701,zramsay
https://github.com/hyperledger/burrow/pull/693,https://github.com/hyperledger/burrow/pull/693,"??? Is this supposed to be here?
",f05f34e13b01705963bae8af01222fced41dc127,2018-02-23 14:56:38,170272170,"@@ -1,8 +1,8 @@
-# burrow changelog
-## v0.17.1
+# Bosmarmot Changelog",,2018-02-24 12:40:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/170272170,https://github.com/hyperledger/burrow/pull/693#discussion_r170272170,compleatang
https://github.com/hyperledger/burrow/pull/693,https://github.com/hyperledger/burrow/pull/693,??? shouldn't this be Burrow?,f05f34e13b01705963bae8af01222fced41dc127,2018-02-23 14:58:55,170272861,"@@ -0,0 +1,37 @@
+package release
+
+import (
+	""testing""
+
+	""github.com/stretchr/testify/assert""
+)
+
+func TestChangelogForReleases(t *testing.T) {
+	changelog, err := changelogForReleases(
+		[]Release{
+			{
+				Version: ""0.1.0"",
+				Notes:   `Everything broken`,
+			},
+			{
+				Version: ""0.0.2"",
+				Notes:   `Wonderful things were achieved`,
+			},
+			{
+				Version: ""0.0.1"",
+				Notes:   `Marvelous advances were made`,
+			},
+		})
+	assert.NoError(t, err)
+
+	assert.Equal(t, `# Bosmarmot Changelog",,2018-02-24 12:40:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/170272861,https://github.com/hyperledger/burrow/pull/693#discussion_r170272861,compleatang
https://github.com/hyperledger/burrow/pull/693,https://github.com/hyperledger/burrow/pull/693,lol well spotted COPYPASTA!,f05f34e13b01705963bae8af01222fced41dc127,2018-02-23 15:11:27,170276234,"@@ -1,8 +1,8 @@
-# burrow changelog
-## v0.17.1
+# Bosmarmot Changelog",,2018-02-24 12:40:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/170276234,https://github.com/hyperledger/burrow/pull/693#discussion_r170276234,silasdavis
https://github.com/hyperledger/burrow/pull/693,https://github.com/hyperledger/burrow/pull/693,"This one is just a test, but still",f05f34e13b01705963bae8af01222fced41dc127,2018-02-23 15:11:37,170276272,"@@ -0,0 +1,37 @@
+package release
+
+import (
+	""testing""
+
+	""github.com/stretchr/testify/assert""
+)
+
+func TestChangelogForReleases(t *testing.T) {
+	changelog, err := changelogForReleases(
+		[]Release{
+			{
+				Version: ""0.1.0"",
+				Notes:   `Everything broken`,
+			},
+			{
+				Version: ""0.0.2"",
+				Notes:   `Wonderful things were achieved`,
+			},
+			{
+				Version: ""0.0.1"",
+				Notes:   `Marvelous advances were made`,
+			},
+		})
+	assert.NoError(t, err)
+
+	assert.Equal(t, `# Bosmarmot Changelog",,2018-02-24 12:40:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/170276272,https://github.com/hyperledger/burrow/pull/693#discussion_r170276272,silasdavis
https://github.com/hyperledger/burrow/pull/681,https://github.com/hyperledger/burrow/pull/681,"for pure testing purpose, we probably could directly use **runtime bytecode** instead of **deploy bytecode** here, so that we don't necessarily need to run evm twice.
Also, maybe we should use concatenated string to avoid long line, like other tests in this file?",3d68527c3ea19f9097ef3ea5c9b03e235b3127bc,2018-02-08 06:30:23,166842333,"@@ -286,6 +287,49 @@ func TestMemoryBounds(t *testing.T) {
 	assert.Error(t, err, ""Should hit memory out of bounds"")
 }
 
+func TestMsgSender(t *testing.T) {
+	st := newAppState()
+	account1 := newAccount(1, 2, 3)
+	account2 := newAccount(3, 2, 1)
+	st.accounts[account1.Address()] = account1
+	st.accounts[account2.Address()] = account2
+
+	ourVm := NewVM(st, DefaultDynamicMemoryProvider, newParams(), acm.ZeroAddress, nil, logger)
+
+	var gas uint64 = 100000
+
+	/*
+			pragma solidity ^0.4.0;
+
+			contract SimpleStorage {
+		                function get() public constant returns (address) {
+		        	        return msg.sender;
+		    	        }
+			}
+	*/
+
+	// This bytecode is compiled from Solidity contract above using remix.ethereum.org online compiler
+	code, err := hex.DecodeString(""6060604052341561000f57600080fd5b60ca8061001d6000396000f300606060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680636d4ce63c146044575b600080fd5b3415604e57600080fd5b60546096565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6000339050905600a165627a7a72305820b9ebf49535372094ae88f56d9ad18f2a79c146c8f56e7ef33b9402924045071e0029"")",,2018-02-09 15:39:58,https://api.github.com/repos/hyperledger/burrow/pulls/comments/166842333,https://github.com/hyperledger/burrow/pull/681#discussion_r166842333,guoger
https://github.com/hyperledger/burrow/pull/681,https://github.com/hyperledger/burrow/pull/681,"There's something to be said for using the runtime code, but it does put it one more step removed from the compiled solidity (i.e. to verify external to Burrow you'll need to run a compiler and deploy a contract to get the same bytecode - not a huge deal), but more than that I think I like the fact it documents this aspect of how Ethereum contract deployment works - which is not very widely explained - the fact you came up against this is perhaps evidence of this.

I'll split the lines. I also would like to avoid hex bytecode and use the constant symbols in these tests. For this I need to write a simple lexer. If we have human-readable bytecode we can try and have more tests that are divorced from solidity without being overly simple.",3d68527c3ea19f9097ef3ea5c9b03e235b3127bc,2018-02-09 15:37:55,167260978,"@@ -286,6 +287,49 @@ func TestMemoryBounds(t *testing.T) {
 	assert.Error(t, err, ""Should hit memory out of bounds"")
 }
 
+func TestMsgSender(t *testing.T) {
+	st := newAppState()
+	account1 := newAccount(1, 2, 3)
+	account2 := newAccount(3, 2, 1)
+	st.accounts[account1.Address()] = account1
+	st.accounts[account2.Address()] = account2
+
+	ourVm := NewVM(st, DefaultDynamicMemoryProvider, newParams(), acm.ZeroAddress, nil, logger)
+
+	var gas uint64 = 100000
+
+	/*
+			pragma solidity ^0.4.0;
+
+			contract SimpleStorage {
+		                function get() public constant returns (address) {
+		        	        return msg.sender;
+		    	        }
+			}
+	*/
+
+	// This bytecode is compiled from Solidity contract above using remix.ethereum.org online compiler
+	code, err := hex.DecodeString(""6060604052341561000f57600080fd5b60ca8061001d6000396000f300606060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680636d4ce63c146044575b600080fd5b3415604e57600080fd5b60546096565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6000339050905600a165627a7a72305820b9ebf49535372094ae88f56d9ad18f2a79c146c8f56e7ef33b9402924045071e0029"")",,2018-02-09 15:39:58,https://api.github.com/repos/hyperledger/burrow/pulls/comments/167260978,https://github.com/hyperledger/burrow/pull/681#discussion_r167260978,silasdavis
https://github.com/hyperledger/burrow/pull/676,https://github.com/hyperledger/burrow/pull/676,Now that we're moving more commands into the burrow command this should actually be an `ENTRYPOINT` rather than a `CMD`.,c74eab1b85ba62e1bcb0e7fa3b6af619229bd72f,2018-01-29 20:33:45,164555717,"@@ -33,4 +33,4 @@ EXPOSE 1337
 EXPOSE 46656
 EXPOSE 46657
 
-CMD [ ""burrow"", ""serve"" ]
+CMD [ ""burrow"" ]",18,2018-01-29 21:11:04,https://api.github.com/repos/hyperledger/burrow/pulls/comments/164555717,https://github.com/hyperledger/burrow/pull/676#discussion_r164555717,compleatang
https://github.com/hyperledger/burrow/pull/676,https://github.com/hyperledger/burrow/pull/676,"hmm. why is nameReg being promoted to this level? given that it is largely meant as a singular feature drawing on the snatives framework rather than a first class feature suite, i'm not sure about an implementation that so strongly ties it in. it's a good feature, tho, so I'm more curious than arguing against.",c74eab1b85ba62e1bcb0e7fa3b6af619229bd72f,2018-01-29 20:54:15,164560577,"@@ -81,50 +79,55 @@ type service struct {
 }
 
 var _ Service = &service{}
+var _ event.Subscribable = Service(nil)
 
-func NewService(state acm.StateIterable, eventEmitter event.Emitter, nameReg execution.NameRegIterable,
+func NewService(state acm.StateIterable, nameReg execution.NameRegIterable, eventEmitter event.Emitter,",60,2018-01-29 21:11:04,https://api.github.com/repos/hyperledger/burrow/pulls/comments/164560577,https://github.com/hyperledger/burrow/pull/676#discussion_r164560577,compleatang
https://github.com/hyperledger/burrow/pull/676,https://github.com/hyperledger/burrow/pull/676,RIP `this` :),c74eab1b85ba62e1bcb0e7fa3b6af619229bd72f,2018-01-29 21:05:28,164563623,"@@ -59,14 +59,14 @@ func (this *TCodec) Decode(v interface{}, r io.Reader) error {
 }
 
 // Decode from a byte array.
-func (this *TCodec) DecodeBytes(v interface{}, bts []byte) error {
+func (codec *TCodec) DecodeBytes(v interface{}, bts []byte) error {
 	var err error
 	wire.ReadJSON(v, bts, &err)
 	return err
 }
 
 // Decode from a byte array pointer.
-func (this *TCodec) DecodeBytesPtr(v interface{}, bts []byte) error {
+func (codec *TCodec) DecodeBytesPtr(v interface{}, bts []byte) error {",39,2018-01-29 21:11:04,https://api.github.com/repos/hyperledger/burrow/pulls/comments/164563623,https://github.com/hyperledger/burrow/pull/676#discussion_r164563623,compleatang
https://github.com/hyperledger/burrow/pull/676,https://github.com/hyperledger/burrow/pull/676,assuming since the endpoint is still available that this information can still be pulled? which has been helpful at times in debugging whether a mempool is queueing...,c74eab1b85ba62e1bcb0e7fa3b6af619229bd72f,2018-01-29 21:10:24,164564817,"@@ -114,11 +114,6 @@ type (
 		DecodeTx(txBytes []byte) (Tx, error)
 	}
 
-	// UnconfirmedTxs",4,2018-01-29 21:11:04,https://api.github.com/repos/hyperledger/burrow/pulls/comments/164564817,https://github.com/hyperledger/burrow/pull/676#discussion_r164564817,compleatang
https://github.com/hyperledger/burrow/pull/676,https://github.com/hyperledger/burrow/pull/676,The only thing is we are currently also providing a `burrow-client` binary here. Possibly we shouldn't. This docker file is also not much use on its own without being hydrated with a config. I'm tempted to just release Burrow as many cross-compiled native binaries using goreleaser (like with Hoard) and drop the dockerfile altogether. It's only really useful in the context of an orchestration system. I guess current version is runnable from environment variable. I think I'll leave things for now and return to this to make it a bit more functional.,c74eab1b85ba62e1bcb0e7fa3b6af619229bd72f,2018-01-30 22:13:33,164895618,"@@ -33,4 +33,4 @@ EXPOSE 1337
 EXPOSE 46656
 EXPOSE 46657
 
-CMD [ ""burrow"", ""serve"" ]
+CMD [ ""burrow"" ]",18,2018-01-30 22:13:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/164895618,https://github.com/hyperledger/burrow/pull/676#discussion_r164895618,silasdavis
https://github.com/hyperledger/burrow/pull/676,https://github.com/hyperledger/burrow/pull/676,"It's more that it's being segregated than being elevated. Although it is currently stored in the same underlying state tree I didn't want the name reg interface to be part of the main state interface so it isn't part of the EVM `StateIterable`. I cam quite close to removing it altogether for the Hypermarmot refactor, but decided to do the work to keep it in, but I still see it as a candidate for removal - I don't think it makes sense as a core part of Burrow.",c74eab1b85ba62e1bcb0e7fa3b6af619229bd72f,2018-01-30 22:19:27,164896955,"@@ -81,50 +79,55 @@ type service struct {
 }
 
 var _ Service = &service{}
+var _ event.Subscribable = Service(nil)
 
-func NewService(state acm.StateIterable, eventEmitter event.Emitter, nameReg execution.NameRegIterable,
+func NewService(state acm.StateIterable, nameReg execution.NameRegIterable, eventEmitter event.Emitter,",60,2018-01-30 22:19:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/164896955,https://github.com/hyperledger/burrow/pull/676#discussion_r164896955,silasdavis
https://github.com/hyperledger/burrow/pull/676,https://github.com/hyperledger/burrow/pull/676,"Oh yes it is this, but this in an RPC view model and just didn't belong here - it was unused since refactor but noticed it during these changes.",c74eab1b85ba62e1bcb0e7fa3b6af619229bd72f,2018-01-30 22:21:27,164897418,"@@ -114,11 +114,6 @@ type (
 		DecodeTx(txBytes []byte) (Tx, error)
 	}
 
-	// UnconfirmedTxs",4,2018-01-30 22:21:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/164897418,https://github.com/hyperledger/burrow/pull/676#discussion_r164897418,silasdavis
https://github.com/hyperledger/burrow/pull/676,https://github.com/hyperledger/burrow/pull/676,It's not used enough to be a core feature. it's also very easily implemented in smart contracts. The only advantage is that we can ping DOUG in the nameReg and never need to store a single address to get connect into a system of smart contracts.,c74eab1b85ba62e1bcb0e7fa3b6af619229bd72f,2018-01-30 22:28:19,164899142,"@@ -81,50 +79,55 @@ type service struct {
 }
 
 var _ Service = &service{}
+var _ event.Subscribable = Service(nil)
 
-func NewService(state acm.StateIterable, eventEmitter event.Emitter, nameReg execution.NameRegIterable,
+func NewService(state acm.StateIterable, nameReg execution.NameRegIterable, eventEmitter event.Emitter,",60,2018-01-30 22:28:19,https://api.github.com/repos/hyperledger/burrow/pulls/comments/164899142,https://github.com/hyperledger/burrow/pull/676#discussion_r164899142,compleatang
https://github.com/hyperledger/burrow/pull/676,https://github.com/hyperledger/burrow/pull/676,👍 ,c74eab1b85ba62e1bcb0e7fa3b6af619229bd72f,2018-01-30 22:28:40,164899251,"@@ -114,11 +114,6 @@ type (
 		DecodeTx(txBytes []byte) (Tx, error)
 	}
 
-	// UnconfirmedTxs",4,2018-01-30 22:28:40,https://api.github.com/repos/hyperledger/burrow/pulls/comments/164899251,https://github.com/hyperledger/burrow/pull/676#discussion_r164899251,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"Obviously `uint`'s can't be negative, but why are we `panic`ing here? Unsure of the logic of a node falling over just because a transaction comes in that is too much. Assuming you have a pre-balance check that would mean the panic is only if something has gone drastically wrong in pulling tx's from memPool.",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-16 10:22:35,161714194,"@@ -41,64 +36,319 @@ func SignBytes(chainID string, o Signable) []byte {
 	buf, n, err := new(bytes.Buffer), new(int), new(error)
 	o.WriteSignBytes(chainID, buf, n, err)
 	if *err != nil {
-		sanity.PanicCrisis(err)
+		panic(fmt.Sprintf(""could not write sign bytes for a signable: %s"", *err))
 	}
-
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/161714194,https://github.com/hyperledger/burrow/pull/666#discussion_r161714194,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"We're a very long way from this, but it is not unreasonable that a heavily used account on a long lasting chain would max this value. Eventually we'd need to consider a migration path for the account somehow. ",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-16 10:25:34,161714889,"@@ -41,64 +36,319 @@ func SignBytes(chainID string, o Signable) []byte {
 	buf, n, err := new(bytes.Buffer), new(int), new(error)
 	o.WriteSignBytes(chainID, buf, n, err)
 	if *err != nil {
-		sanity.PanicCrisis(err)
+		panic(fmt.Sprintf(""could not write sign bytes for a signable: %s"", *err))
 	}
-
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/161714889,https://github.com/hyperledger/burrow/pull/666#discussion_r161714889,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"As noted above, I'm not keen on this as a panic... Not sure if there is another way to handle it tho....",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-16 10:31:52,161716422,"@@ -41,64 +36,319 @@ func SignBytes(chainID string, o Signable) []byte {
 	buf, n, err := new(bytes.Buffer), new(int), new(error)
 	o.WriteSignBytes(chainID, buf, n, err)
 	if *err != nil {
-		sanity.PanicCrisis(err)
+		panic(fmt.Sprintf(""could not write sign bytes for a signable: %s"", *err))
 	}
-
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
+}
+
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {
+	Address     Address
+	PublicKey   PublicKey
+	Balance     uint64
+	Code        Bytecode
+	Sequence    uint64
+	StorageRoot []byte
+	Permissions ptypes.AccountPermissions
+}
+
+func NewConcreteAccount(pubKey PublicKey) ConcreteAccount {
+	return ConcreteAccount{
+		Address:   pubKey.Address(),
+		PublicKey: pubKey,
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
+	}
 }
 
-func (acc *Account) Copy() *Account {
+func NewConcreteAccountFromSecret(secret string) ConcreteAccount {
+	return NewConcreteAccount(PublicKeyFromPubKey(PrivateKeyFromSecret(secret).PubKey()))
+}
+
+// Return as immutable Account
+func (acc ConcreteAccount) Account() Account {
+	return concreteAccountWrapper{&acc}
+}
+
+// Return as mutable MutableAccount
+func (acc ConcreteAccount) MutableAccount() MutableAccount {
+	return concreteAccountWrapper{&acc}
+}
+
+func (acc *ConcreteAccount) Encode() []byte {
+	return wire.BinaryBytes(acc)
+}
+
+func (acc *ConcreteAccount) Copy() *ConcreteAccount {
 	accCopy := *acc
 	return &accCopy
 }
 
-func (acc *Account) String() string {
+func (acc *ConcreteAccount) String() string {
 	if acc == nil {
-		return ""nil-Account""
+		return ""Account{nil}""
 	}
-	return fmt.Sprintf(""Account{%X:%v B:%v C:%v S:%X P:%s}"", acc.Address, acc.PubKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
+
+	return fmt.Sprintf(""Account{Address: %s; PublicKey: %v Balance: %v; CodeBytes: %v; StorageRoot: 0x%X; Permissions: %s}"",
+		acc.Address, acc.PublicKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
 }
 
-func AccountEncoder(o interface{}, w io.Writer, n *int, err *error) {
-	wire.WriteBinary(o.(*Account), w, n, err)
+// ConcreteAccount
+// -------------------------------------------------
+// Conversions
+//
+// Using the naming convention is this package of 'As<Type>' being
+// a conversion from Account to <Type> and 'From<Type>' being conversion
+// from <Type> to Account. Conversions are done by copying
+
+// Returns a mutable, serialisable ConcreteAccount by copying from account
+func AsConcreteAccount(account Account) *ConcreteAccount {
+	if account == nil {
+		return nil
+	}
+	if ca, ok := account.(concreteAccountWrapper); ok {
+		return ca.ConcreteAccount
+	}
+	return &ConcreteAccount{
+		Address:     account.Address(),
+		PublicKey:   account.PublicKey(),
+		Balance:     account.Balance(),
+		Code:        account.Code(),
+		Sequence:    account.Sequence(),
+		StorageRoot: account.StorageRoot(),
+		Permissions: account.Permissions(),
+	}
+}
+
+// Creates an otherwise zeroed Account from an Addressable and returns it as MutableAccount
+func FromAddressable(addressable Addressable) MutableAccount {
+	return ConcreteAccount{
+		Address:   addressable.Address(),
+		PublicKey: addressable.PublicKey(),
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
+	}.MutableAccount()
+}
+
+// Returns an immutable account by copying from account
+func AsAccount(account Account) Account {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).Account()
+}
+
+// Returns a MutableAccount by copying from account
+func AsMutableAccount(account Account) MutableAccount {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).MutableAccount()
+}
+
+func GetMutableAccount(getter Getter, address Address) (MutableAccount, error) {
+	acc, err := getter.GetAccount(address)
+	if err != nil {
+		return nil, err
+	}
+	// If we get get our own concreteAccountWrapper back we can save an unnecessary copy and just
+	// return since ConcreteAccount.Account() will have been used to produce it which will already
+	// have copied
+	caw, ok := acc.(concreteAccountWrapper)
+	if ok {
+		return caw, nil
+	}
+	return AsMutableAccount(acc), nil
 }
 
-func AccountDecoder(r io.Reader, n *int, err *error) interface{} {
-	return wire.ReadBinary(&Account{}, r, 0, n, err)
+//----------------------------------------------
+// concreteAccount Wrapper
+
+// concreteAccountWrapper wraps ConcreteAccount to provide a immutable read-only view
+// via its implementation of Account and a mutable implementation via its implementation of
+// MutableAccount
+type concreteAccountWrapper struct {
+	*ConcreteAccount `json:""unwrap""`
+}
+
+var _ Account = concreteAccountWrapper{}
+
+func (caw concreteAccountWrapper) Address() Address {
+	return caw.ConcreteAccount.Address
 }
 
-var AccountCodec = wire.Codec{
-	Encode: AccountEncoder,
-	Decode: AccountDecoder,
+func (caw concreteAccountWrapper) PublicKey() PublicKey {
+	return caw.ConcreteAccount.PublicKey
 }
 
-func EncodeAccount(acc *Account) []byte {
-	w := new(bytes.Buffer)
-	var n int
-	var err error
-	AccountEncoder(acc, w, &n, &err)
-	return w.Bytes()
+func (caw concreteAccountWrapper) Balance() uint64 {
+	return caw.ConcreteAccount.Balance
 }
 
-func DecodeAccount(accBytes []byte) *Account {
-	var n int
-	var err error
-	acc := AccountDecoder(bytes.NewBuffer(accBytes), &n, &err)
-	return acc.(*Account)
+func (caw concreteAccountWrapper) Code() Bytecode {
+	return caw.ConcreteAccount.Code
+}
+
+func (caw concreteAccountWrapper) Sequence() uint64 {
+	return caw.ConcreteAccount.Sequence
+}
+
+func (caw concreteAccountWrapper) StorageRoot() []byte {
+	return caw.ConcreteAccount.StorageRoot
+}
+
+func (caw concreteAccountWrapper) Permissions() ptypes.AccountPermissions {
+	return caw.ConcreteAccount.Permissions
+}
+
+func (caw concreteAccountWrapper) Encode() []byte {
+	return caw.ConcreteAccount.Encode()
+}
+
+func (caw concreteAccountWrapper) MarshalJSON() ([]byte, error) {
+	return json.Marshal(caw.ConcreteAccount)
+}
+
+// Account mutation via MutableAccount interface
+var _ MutableAccount = concreteAccountWrapper{}
+
+func (caw concreteAccountWrapper) SetPublicKey(pubKey PublicKey) MutableAccount {
+	caw.ConcreteAccount.PublicKey = pubKey
+	addressFromPubKey := pubKey.Address()
+	// We don't want the wrong public key to take control of an account so we panic here
+	if caw.ConcreteAccount.Address != addressFromPubKey {
+		panic(fmt.Errorf(""attempt to set public key of account %s to %v, ""+
+			""but that public key has address %s"",
+			caw.ConcreteAccount.Address, pubKey, addressFromPubKey))
+	}
+	return caw
+}
+
+func (caw concreteAccountWrapper) SubtractFromBalance(amount uint64) MutableAccount {
+	if amount > caw.Balance() {
+		panic(fmt.Errorf(""insufficient funds: attempt to subtract %v from the balance of %s"",
+			amount, caw.ConcreteAccount))",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/161716422,https://github.com/hyperledger/burrow/pull/666#discussion_r161716422,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,As with `SubtractFromBalance` why are we panicing? Can we not just throw. This seems like it will cause more network instability than it actually helps.,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-16 10:33:00,161716711,"@@ -41,64 +36,319 @@ func SignBytes(chainID string, o Signable) []byte {
 	buf, n, err := new(bytes.Buffer), new(int), new(error)
 	o.WriteSignBytes(chainID, buf, n, err)
 	if *err != nil {
-		sanity.PanicCrisis(err)
+		panic(fmt.Sprintf(""could not write sign bytes for a signable: %s"", *err))
 	}
-
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
+}
+
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {
+	Address     Address
+	PublicKey   PublicKey
+	Balance     uint64
+	Code        Bytecode
+	Sequence    uint64
+	StorageRoot []byte
+	Permissions ptypes.AccountPermissions
+}
+
+func NewConcreteAccount(pubKey PublicKey) ConcreteAccount {
+	return ConcreteAccount{
+		Address:   pubKey.Address(),
+		PublicKey: pubKey,
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
+	}
 }
 
-func (acc *Account) Copy() *Account {
+func NewConcreteAccountFromSecret(secret string) ConcreteAccount {
+	return NewConcreteAccount(PublicKeyFromPubKey(PrivateKeyFromSecret(secret).PubKey()))
+}
+
+// Return as immutable Account
+func (acc ConcreteAccount) Account() Account {
+	return concreteAccountWrapper{&acc}
+}
+
+// Return as mutable MutableAccount
+func (acc ConcreteAccount) MutableAccount() MutableAccount {
+	return concreteAccountWrapper{&acc}
+}
+
+func (acc *ConcreteAccount) Encode() []byte {
+	return wire.BinaryBytes(acc)
+}
+
+func (acc *ConcreteAccount) Copy() *ConcreteAccount {
 	accCopy := *acc
 	return &accCopy
 }
 
-func (acc *Account) String() string {
+func (acc *ConcreteAccount) String() string {
 	if acc == nil {
-		return ""nil-Account""
+		return ""Account{nil}""
 	}
-	return fmt.Sprintf(""Account{%X:%v B:%v C:%v S:%X P:%s}"", acc.Address, acc.PubKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
+
+	return fmt.Sprintf(""Account{Address: %s; PublicKey: %v Balance: %v; CodeBytes: %v; StorageRoot: 0x%X; Permissions: %s}"",
+		acc.Address, acc.PublicKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
 }
 
-func AccountEncoder(o interface{}, w io.Writer, n *int, err *error) {
-	wire.WriteBinary(o.(*Account), w, n, err)
+// ConcreteAccount
+// -------------------------------------------------
+// Conversions
+//
+// Using the naming convention is this package of 'As<Type>' being
+// a conversion from Account to <Type> and 'From<Type>' being conversion
+// from <Type> to Account. Conversions are done by copying
+
+// Returns a mutable, serialisable ConcreteAccount by copying from account
+func AsConcreteAccount(account Account) *ConcreteAccount {
+	if account == nil {
+		return nil
+	}
+	if ca, ok := account.(concreteAccountWrapper); ok {
+		return ca.ConcreteAccount
+	}
+	return &ConcreteAccount{
+		Address:     account.Address(),
+		PublicKey:   account.PublicKey(),
+		Balance:     account.Balance(),
+		Code:        account.Code(),
+		Sequence:    account.Sequence(),
+		StorageRoot: account.StorageRoot(),
+		Permissions: account.Permissions(),
+	}
+}
+
+// Creates an otherwise zeroed Account from an Addressable and returns it as MutableAccount
+func FromAddressable(addressable Addressable) MutableAccount {
+	return ConcreteAccount{
+		Address:   addressable.Address(),
+		PublicKey: addressable.PublicKey(),
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
+	}.MutableAccount()
+}
+
+// Returns an immutable account by copying from account
+func AsAccount(account Account) Account {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).Account()
+}
+
+// Returns a MutableAccount by copying from account
+func AsMutableAccount(account Account) MutableAccount {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).MutableAccount()
+}
+
+func GetMutableAccount(getter Getter, address Address) (MutableAccount, error) {
+	acc, err := getter.GetAccount(address)
+	if err != nil {
+		return nil, err
+	}
+	// If we get get our own concreteAccountWrapper back we can save an unnecessary copy and just
+	// return since ConcreteAccount.Account() will have been used to produce it which will already
+	// have copied
+	caw, ok := acc.(concreteAccountWrapper)
+	if ok {
+		return caw, nil
+	}
+	return AsMutableAccount(acc), nil
 }
 
-func AccountDecoder(r io.Reader, n *int, err *error) interface{} {
-	return wire.ReadBinary(&Account{}, r, 0, n, err)
+//----------------------------------------------
+// concreteAccount Wrapper
+
+// concreteAccountWrapper wraps ConcreteAccount to provide a immutable read-only view
+// via its implementation of Account and a mutable implementation via its implementation of
+// MutableAccount
+type concreteAccountWrapper struct {
+	*ConcreteAccount `json:""unwrap""`
+}
+
+var _ Account = concreteAccountWrapper{}
+
+func (caw concreteAccountWrapper) Address() Address {
+	return caw.ConcreteAccount.Address
 }
 
-var AccountCodec = wire.Codec{
-	Encode: AccountEncoder,
-	Decode: AccountDecoder,
+func (caw concreteAccountWrapper) PublicKey() PublicKey {
+	return caw.ConcreteAccount.PublicKey
 }
 
-func EncodeAccount(acc *Account) []byte {
-	w := new(bytes.Buffer)
-	var n int
-	var err error
-	AccountEncoder(acc, w, &n, &err)
-	return w.Bytes()
+func (caw concreteAccountWrapper) Balance() uint64 {
+	return caw.ConcreteAccount.Balance
 }
 
-func DecodeAccount(accBytes []byte) *Account {
-	var n int
-	var err error
-	acc := AccountDecoder(bytes.NewBuffer(accBytes), &n, &err)
-	return acc.(*Account)
+func (caw concreteAccountWrapper) Code() Bytecode {
+	return caw.ConcreteAccount.Code
+}
+
+func (caw concreteAccountWrapper) Sequence() uint64 {
+	return caw.ConcreteAccount.Sequence
+}
+
+func (caw concreteAccountWrapper) StorageRoot() []byte {
+	return caw.ConcreteAccount.StorageRoot
+}
+
+func (caw concreteAccountWrapper) Permissions() ptypes.AccountPermissions {
+	return caw.ConcreteAccount.Permissions
+}
+
+func (caw concreteAccountWrapper) Encode() []byte {
+	return caw.ConcreteAccount.Encode()
+}
+
+func (caw concreteAccountWrapper) MarshalJSON() ([]byte, error) {
+	return json.Marshal(caw.ConcreteAccount)
+}
+
+// Account mutation via MutableAccount interface
+var _ MutableAccount = concreteAccountWrapper{}
+
+func (caw concreteAccountWrapper) SetPublicKey(pubKey PublicKey) MutableAccount {
+	caw.ConcreteAccount.PublicKey = pubKey
+	addressFromPubKey := pubKey.Address()
+	// We don't want the wrong public key to take control of an account so we panic here
+	if caw.ConcreteAccount.Address != addressFromPubKey {
+		panic(fmt.Errorf(""attempt to set public key of account %s to %v, ""+
+			""but that public key has address %s"",
+			caw.ConcreteAccount.Address, pubKey, addressFromPubKey))
+	}
+	return caw
+}
+
+func (caw concreteAccountWrapper) SubtractFromBalance(amount uint64) MutableAccount {
+	if amount > caw.Balance() {
+		panic(fmt.Errorf(""insufficient funds: attempt to subtract %v from the balance of %s"",
+			amount, caw.ConcreteAccount))
+	}
+	caw.ConcreteAccount.Balance -= amount
+	return caw
+}
+
+func (caw concreteAccountWrapper) AddToBalance(amount uint64) MutableAccount {
+	if binary.IsUint64SumOverflow(caw.Balance(), amount) {
+		panic(fmt.Errorf(""uint64 overflow: attempt to add %v to the balance of %s"",
+			amount, caw.ConcreteAccount))",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/161716711,https://github.com/hyperledger/burrow/pull/666#discussion_r161716711,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,We probably want to add a check here to make sure that we are not setting a sequence number > MaxUint64,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-16 10:33:42,161716910,"@@ -41,64 +36,319 @@ func SignBytes(chainID string, o Signable) []byte {
 	buf, n, err := new(bytes.Buffer), new(int), new(error)
 	o.WriteSignBytes(chainID, buf, n, err)
 	if *err != nil {
-		sanity.PanicCrisis(err)
+		panic(fmt.Sprintf(""could not write sign bytes for a signable: %s"", *err))
 	}
-
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
+}
+
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {
+	Address     Address
+	PublicKey   PublicKey
+	Balance     uint64
+	Code        Bytecode
+	Sequence    uint64
+	StorageRoot []byte
+	Permissions ptypes.AccountPermissions
+}
+
+func NewConcreteAccount(pubKey PublicKey) ConcreteAccount {
+	return ConcreteAccount{
+		Address:   pubKey.Address(),
+		PublicKey: pubKey,
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
+	}
 }
 
-func (acc *Account) Copy() *Account {
+func NewConcreteAccountFromSecret(secret string) ConcreteAccount {
+	return NewConcreteAccount(PublicKeyFromPubKey(PrivateKeyFromSecret(secret).PubKey()))
+}
+
+// Return as immutable Account
+func (acc ConcreteAccount) Account() Account {
+	return concreteAccountWrapper{&acc}
+}
+
+// Return as mutable MutableAccount
+func (acc ConcreteAccount) MutableAccount() MutableAccount {
+	return concreteAccountWrapper{&acc}
+}
+
+func (acc *ConcreteAccount) Encode() []byte {
+	return wire.BinaryBytes(acc)
+}
+
+func (acc *ConcreteAccount) Copy() *ConcreteAccount {
 	accCopy := *acc
 	return &accCopy
 }
 
-func (acc *Account) String() string {
+func (acc *ConcreteAccount) String() string {
 	if acc == nil {
-		return ""nil-Account""
+		return ""Account{nil}""
 	}
-	return fmt.Sprintf(""Account{%X:%v B:%v C:%v S:%X P:%s}"", acc.Address, acc.PubKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
+
+	return fmt.Sprintf(""Account{Address: %s; PublicKey: %v Balance: %v; CodeBytes: %v; StorageRoot: 0x%X; Permissions: %s}"",
+		acc.Address, acc.PublicKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
 }
 
-func AccountEncoder(o interface{}, w io.Writer, n *int, err *error) {
-	wire.WriteBinary(o.(*Account), w, n, err)
+// ConcreteAccount
+// -------------------------------------------------
+// Conversions
+//
+// Using the naming convention is this package of 'As<Type>' being
+// a conversion from Account to <Type> and 'From<Type>' being conversion
+// from <Type> to Account. Conversions are done by copying
+
+// Returns a mutable, serialisable ConcreteAccount by copying from account
+func AsConcreteAccount(account Account) *ConcreteAccount {
+	if account == nil {
+		return nil
+	}
+	if ca, ok := account.(concreteAccountWrapper); ok {
+		return ca.ConcreteAccount
+	}
+	return &ConcreteAccount{
+		Address:     account.Address(),
+		PublicKey:   account.PublicKey(),
+		Balance:     account.Balance(),
+		Code:        account.Code(),
+		Sequence:    account.Sequence(),
+		StorageRoot: account.StorageRoot(),
+		Permissions: account.Permissions(),
+	}
+}
+
+// Creates an otherwise zeroed Account from an Addressable and returns it as MutableAccount
+func FromAddressable(addressable Addressable) MutableAccount {
+	return ConcreteAccount{
+		Address:   addressable.Address(),
+		PublicKey: addressable.PublicKey(),
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
+	}.MutableAccount()
+}
+
+// Returns an immutable account by copying from account
+func AsAccount(account Account) Account {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).Account()
+}
+
+// Returns a MutableAccount by copying from account
+func AsMutableAccount(account Account) MutableAccount {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).MutableAccount()
+}
+
+func GetMutableAccount(getter Getter, address Address) (MutableAccount, error) {
+	acc, err := getter.GetAccount(address)
+	if err != nil {
+		return nil, err
+	}
+	// If we get get our own concreteAccountWrapper back we can save an unnecessary copy and just
+	// return since ConcreteAccount.Account() will have been used to produce it which will already
+	// have copied
+	caw, ok := acc.(concreteAccountWrapper)
+	if ok {
+		return caw, nil
+	}
+	return AsMutableAccount(acc), nil
 }
 
-func AccountDecoder(r io.Reader, n *int, err *error) interface{} {
-	return wire.ReadBinary(&Account{}, r, 0, n, err)
+//----------------------------------------------
+// concreteAccount Wrapper
+
+// concreteAccountWrapper wraps ConcreteAccount to provide a immutable read-only view
+// via its implementation of Account and a mutable implementation via its implementation of
+// MutableAccount
+type concreteAccountWrapper struct {
+	*ConcreteAccount `json:""unwrap""`
+}
+
+var _ Account = concreteAccountWrapper{}
+
+func (caw concreteAccountWrapper) Address() Address {
+	return caw.ConcreteAccount.Address
 }
 
-var AccountCodec = wire.Codec{
-	Encode: AccountEncoder,
-	Decode: AccountDecoder,
+func (caw concreteAccountWrapper) PublicKey() PublicKey {
+	return caw.ConcreteAccount.PublicKey
 }
 
-func EncodeAccount(acc *Account) []byte {
-	w := new(bytes.Buffer)
-	var n int
-	var err error
-	AccountEncoder(acc, w, &n, &err)
-	return w.Bytes()
+func (caw concreteAccountWrapper) Balance() uint64 {
+	return caw.ConcreteAccount.Balance
 }
 
-func DecodeAccount(accBytes []byte) *Account {
-	var n int
-	var err error
-	acc := AccountDecoder(bytes.NewBuffer(accBytes), &n, &err)
-	return acc.(*Account)
+func (caw concreteAccountWrapper) Code() Bytecode {
+	return caw.ConcreteAccount.Code
+}
+
+func (caw concreteAccountWrapper) Sequence() uint64 {
+	return caw.ConcreteAccount.Sequence
+}
+
+func (caw concreteAccountWrapper) StorageRoot() []byte {
+	return caw.ConcreteAccount.StorageRoot
+}
+
+func (caw concreteAccountWrapper) Permissions() ptypes.AccountPermissions {
+	return caw.ConcreteAccount.Permissions
+}
+
+func (caw concreteAccountWrapper) Encode() []byte {
+	return caw.ConcreteAccount.Encode()
+}
+
+func (caw concreteAccountWrapper) MarshalJSON() ([]byte, error) {
+	return json.Marshal(caw.ConcreteAccount)
+}
+
+// Account mutation via MutableAccount interface
+var _ MutableAccount = concreteAccountWrapper{}
+
+func (caw concreteAccountWrapper) SetPublicKey(pubKey PublicKey) MutableAccount {
+	caw.ConcreteAccount.PublicKey = pubKey
+	addressFromPubKey := pubKey.Address()
+	// We don't want the wrong public key to take control of an account so we panic here
+	if caw.ConcreteAccount.Address != addressFromPubKey {
+		panic(fmt.Errorf(""attempt to set public key of account %s to %v, ""+
+			""but that public key has address %s"",
+			caw.ConcreteAccount.Address, pubKey, addressFromPubKey))
+	}
+	return caw
+}
+
+func (caw concreteAccountWrapper) SubtractFromBalance(amount uint64) MutableAccount {
+	if amount > caw.Balance() {
+		panic(fmt.Errorf(""insufficient funds: attempt to subtract %v from the balance of %s"",
+			amount, caw.ConcreteAccount))
+	}
+	caw.ConcreteAccount.Balance -= amount
+	return caw
+}
+
+func (caw concreteAccountWrapper) AddToBalance(amount uint64) MutableAccount {
+	if binary.IsUint64SumOverflow(caw.Balance(), amount) {
+		panic(fmt.Errorf(""uint64 overflow: attempt to add %v to the balance of %s"",
+			amount, caw.ConcreteAccount))
+	}
+	caw.ConcreteAccount.Balance += amount
+	return caw
+}
+
+func (caw concreteAccountWrapper) SetCode(code []byte) MutableAccount {
+	caw.ConcreteAccount.Code = code
+	return caw
+}
+
+func (caw concreteAccountWrapper) IncSequence() MutableAccount {
+	caw.ConcreteAccount.Sequence += 1",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/161716910,https://github.com/hyperledger/burrow/pull/666#discussion_r161716910,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"Not to throw too much at this refactor, but at some point we need to cut the cord on `ed22519` and move to `secp2k1` if we're going to be able to implement web3 compatibility. Is now that time?",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-16 10:47:57,161720791,"@@ -0,0 +1,136 @@
+// Copyright 2017 Monax Industries Limited
+//
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package account
+
+import (
+	""fmt""
+
+	""github.com/tendermint/ed25519""",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/161720791,https://github.com/hyperledger/burrow/pull/666#discussion_r161720791,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,++ for adding secp2k1,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-16 11:07:17,161725317,"@@ -15,21 +15,48 @@
 package keys
 
 import (
+	""bytes""
 	""encoding/hex""
 	""fmt""
 
+	acm ""github.com/hyperledger/burrow/account""
 	""github.com/hyperledger/burrow/logging""
 	logging_types ""github.com/hyperledger/burrow/logging/types""
+	""github.com/tendermint/go-crypto""
 )
 
 type KeyClient interface {
-	// Sign needs to return the signature bytes for given message to sign
-	// and the address to sign it with.
-	Sign(signBytesString string, signAddress []byte) (signature []byte, err error)
-	// PublicKey needs to return the public key associated with a given address
-	PublicKey(address []byte) (publicKey []byte, err error)
+	// Sign returns the signature bytes for given message signed with the key associated with signAddress
+	Sign(signAddress acm.Address, message []byte) (signature crypto.Signature, err error)
+
+	// PublicKey returns the public key associated with a given address
+	PublicKey(address acm.Address) (publicKey acm.PublicKey, err error)
+
+	// Generate requests that a key be generate within the keys instance and returns the address
+	Generate(keyName string, keyType KeyType) (keyAddress acm.Address, err error)
+
+	// Returns nil if the keys isntance is health, error otherwise
+	HealthCheck() error
+}
+
+// This mirrors ""github.com/monax/keys/crypto/KeyType"" but since we have no use for the struct here it seems simpler
+// to replicate rather than cop an import
+type KeyType string
+
+func (kt KeyType) String() string {
+	return string(kt)
 }
 
+const (",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/161725317,https://github.com/hyperledger/burrow/pull/666#discussion_r161725317,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,RIP `scumbag` :(,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-16 11:10:25,161726072,"@@ -1,89 +0,0 @@
-// Copyright 2017 Monax Industries Limited",1,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/161726072,https://github.com/hyperledger/burrow/pull/666#discussion_r161726072,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,why `randBalance` ...? I'm not sure I follow the logic of that.,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-16 11:14:52,161726981,"@@ -0,0 +1,98 @@
+package genesis
+
+import (
+	""math/rand""
+	""time""
+
+	""fmt""
+
+	acm ""github.com/hyperledger/burrow/account""
+	""github.com/hyperledger/burrow/permission""
+	""github.com/tendermint/ed25519""
+	""github.com/tendermint/go-crypto""
+)
+
+type deterministicGenesis struct {
+	random *rand.Rand
+}
+
+// Generates deterministic pseudo-random genesis state
+func NewDeterministicGenesis(seed int64) *deterministicGenesis {
+	return &deterministicGenesis{
+		random: rand.New(rand.NewSource(seed)),
+	}
+}
+
+func (dg *deterministicGenesis) GenesisDoc(numAccounts int, randBalance bool, minBalance uint64, numValidators int,
+	randBonded bool, minBonded int64) (*GenesisDoc, []acm.PrivateAccount) {
+
+	accounts := make([]Account, numAccounts)
+	privAccounts := make([]acm.PrivateAccount, numAccounts)
+	defaultPerms := permission.DefaultAccountPermissions
+	for i := 0; i < numAccounts; i++ {
+		account, privAccount := dg.Account(randBalance, minBalance)",30,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/161726981,https://github.com/hyperledger/burrow/pull/666#discussion_r161726981,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,We should review the below functions as I'm pretty sure they're redundant with other code or not needed. ,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-16 11:22:41,161728865,"@@ -61,20 +73,252 @@ func NewGenesisValidator(amount int64, name string, unbondToAddress []byte,
 	default:
 		return nil, fmt.Errorf(""Unsupported key type (%s)"", keyType)
 	}
-	newPublicKey, err := crypto.PubKeyFromBytes(typedPublicKeyBytes)
+	newPubKey, err := crypto.PubKeyFromBytes(typedPublicKeyBytes)
 	if err != nil {
 		return nil, err
 	}
 	// ability to unbond to multiple accounts currently unused
 	var unbondTo []BasicAccount
 
-	return &GenesisValidator{
-		PubKey: newPublicKey,
-		Amount: unbondAmount,
-		Name:   name,
+	address, err := acm.AddressFromBytes(newPubKey.Address())
+	if err != nil {
+		return nil, err
+	}
+	return &Validator{
+		BasicAccount: BasicAccount{
+			Address:   address,
+			PublicKey: acm.PublicKeyFromPubKey(newPubKey),
+			Amount:    amount,
+		},
+		Name: name,
 		UnbondTo: append(unbondTo, BasicAccount{
 			Address: unbondToAddress,
 			Amount:  unbondAmount,
 		}),
 	}, nil
 }
+
+//------------------------------------------------------------------------------------
+// interface functions that are consumed by monax tooling
+
+func GenerateKnown(chainName, accountsPathCSV, validatorsPathCSV string) (string, error) {
+	return generateKnownWithTime(chainName, accountsPathCSV, validatorsPathCSV,
+		// set the timestamp for the genesis
+		time.Now())
+}
+
+//------------------------------------------------------------------------------------
+// interface functions that are consumed by monax tooling
+
+func GenerateGenesisFileBytes(chainName string, salt []byte, genesisTime time.Time, genesisAccounts map[string]acm.Account,
+	genesisValidators map[string]acm.Validator) ([]byte, error) {
+
+	genesisDoc := MakeGenesisDocFromAccounts(chainName, salt, genesisTime, genesisAccounts, genesisValidators)
+
+	var err error
+	buf, buf2, n := new(bytes.Buffer), new(bytes.Buffer), new(int)
+	wire.WriteJSON(genesisDoc, buf, n, &err)
+	if err != nil {
+		return nil, err
+	}
+	if err := json.Indent(buf2, buf.Bytes(), """", ""\t""); err != nil {
+		return nil, err
+	}
+
+	return buf2.Bytes(), nil
+}
+
+//------------------------------------------------------------------------------------
+// core functions that provide functionality for monax tooling in v0.16
+
+// GenerateKnownWithTime takes chainName, an accounts and validators CSV filepath
+// and a timestamp to generate the string of `genesis.json`
+// NOTE: [ben] is introduced as technical debt to preserve the signature
+// of GenerateKnown but in order to introduce the timestamp gradually
+// This will be deprecated in v0.17
+func generateKnownWithTime(chainName, accountsPathCSV, validatorsPathCSV string,
+	genesisTime time.Time) (string, error) {
+	var genDoc *GenesisDoc
+
+	// TODO [eb] eliminate reading priv_val ... [zr] where?
+	if accountsPathCSV == """" || validatorsPathCSV == """" {
+		return """", fmt.Errorf(""both accounts.csv and validators.csv is required"")
+	}
+
+	pubkeys, amts, names, perms, setbits, err := parseCsv(validatorsPathCSV)
+	if err != nil {
+		return """", err
+	}
+
+	pubkeysA, amtsA, namesA, permsA, setbitsA, err := parseCsv(accountsPathCSV)
+	if err != nil {
+		return """", err
+	}
+
+	genDoc = newGenDoc(chainName, genesisTime, len(pubkeys), len(pubkeysA))
+	for i, pk := range pubkeys {
+		genDocAddValidator(genDoc, pk, amts[i], names[i], perms[i], setbits[i], i)
+	}
+	for i, pk := range pubkeysA {
+		genDocAddAccount(genDoc, pk, amtsA[i], namesA[i], permsA[i], setbitsA[i], i)
+	}
+
+	buf, buf2, n := new(bytes.Buffer), new(bytes.Buffer), new(int)
+	wire.WriteJSON(genDoc, buf, n, &err)
+	if err != nil {
+		return """", err
+	}
+	if err := json.Indent(buf2, buf.Bytes(), """", ""\t""); err != nil {
+		return """", err
+	}
+
+	return buf2.String(), nil
+}
+
+//-----------------------------------------------------------------------------
+// gendoc convenience functions
+
+func newGenDoc(chainName string, genesisTime time.Time, nVal, nAcc int) *GenesisDoc {
+	genDoc := GenesisDoc{
+		ChainName:   chainName,
+		GenesisTime: genesisTime,
+	}
+	genDoc.Accounts = make([]Account, nAcc)
+	genDoc.Validators = make([]Validator, nVal)
+	return &genDoc
+}
+
+func genDocAddAccount(genDoc *GenesisDoc, pubKey crypto.PubKeyEd25519, amt uint64, name string,
+	perm, setbit ptypes.PermFlag, index int) {
+	addr, _ := acm.AddressFromBytes(pubKey.Address())
+	acc := Account{
+		BasicAccount: BasicAccount{
+			Address: addr,
+			Amount:  amt,
+		},
+		Name: name,
+		Permissions: ptypes.AccountPermissions{
+			Base: ptypes.BasePermissions{
+				Perms:  perm,
+				SetBit: setbit,
+			},
+		},
+	}
+	if index < 0 {
+		genDoc.Accounts = append(genDoc.Accounts, acc)
+	} else {
+		genDoc.Accounts[index] = acc
+	}
+}
+
+func genDocAddValidator(genDoc *GenesisDoc, pubKey crypto.PubKeyEd25519, amt uint64, name string,
+	perm, setbit ptypes.PermFlag, index int) {
+	addr, _ := acm.AddressFromBytes(pubKey.Address())
+	genDoc.Validators[index] = Validator{
+		BasicAccount: BasicAccount{
+			Address:   acm.MustAddressFromBytes(pubKey.Address()),
+			PublicKey: acm.PublicKeyFromPubKey(pubKey.Wrap()),
+			Amount:    amt,
+		},
+		Name: name,
+		UnbondTo: []BasicAccount{
+			{
+				Address: addr,
+				Amount:  amt,
+			},
+		},
+	}
+	// [zr] why no index < 0 like in genDocAddAccount?
+}
+
+//-----------------------------------------------------------------------------
+// util functions",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/161728865,https://github.com/hyperledger/burrow/pull/666#discussion_r161728865,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,We should add root and developer account types here. ,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-16 11:25:32,161729527,"@@ -0,0 +1,74 @@
+package spec
+
+import (
+	""fmt""
+
+	""sort""
+
+	""github.com/hyperledger/burrow/permission""
+)
+
+// Files here can be used as starting points for building various 'chain types' but are otherwise
+// a fairly unprincipled collection of GenesisSpecs that we find useful in testing and development
+",13,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/161729527,https://github.com/hyperledger/burrow/pull/666#discussion_r161729527,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,`NewCallTxWithSequence` for consistency? ,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-16 11:32:11,161730918,"@@ -37,65 +33,73 @@ func NewSendTx() *SendTx {
 	}
 }
 
-func (tx *SendTx) AddInput(st AccountGetter, pubkey crypto.PubKey, amt int64) error {
+func (tx *SendTx) AddInput(st acm.Getter, pubkey acm.PublicKey, amt uint64) error {
 	addr := pubkey.Address()
-	acc := st.GetAccount(addr)
+	acc, err := st.GetAccount(addr)
+	if err != nil {
+		return err
+	}
 	if acc == nil {
-		return fmt.Errorf(""Invalid address %X from pubkey %X"", addr, pubkey)
+		return fmt.Errorf(""invalid address %s from pubkey %s"", addr, pubkey)
 	}
-	return tx.AddInputWithNonce(pubkey, amt, acc.Sequence+1)
+	return tx.AddInputWithNonce(pubkey, amt, acc.Sequence()+1)
 }
 
-func (tx *SendTx) AddInputWithNonce(pubkey crypto.PubKey, amt int64, nonce int) error {
+func (tx *SendTx) AddInputWithNonce(pubkey acm.PublicKey, amt uint64, sequence uint64) error {
 	addr := pubkey.Address()
 	tx.Inputs = append(tx.Inputs, &TxInput{
 		Address:   addr,
 		Amount:    amt,
-		Sequence:  nonce,
-		Signature: crypto.SignatureEd25519{},
+		Sequence:  sequence,
+		Signature: crypto.SignatureEd25519{}.Wrap(),
 		PubKey:    pubkey,
 	})
 	return nil
 }
 
-func (tx *SendTx) AddOutput(addr []byte, amt int64) error {
+func (tx *SendTx) AddOutput(addr acm.Address, amt uint64) error {
 	tx.Outputs = append(tx.Outputs, &TxOutput{
 		Address: addr,
 		Amount:  amt,
 	})
 	return nil
 }
 
-func (tx *SendTx) SignInput(chainID string, i int, privAccount *acm.PrivAccount) error {
+func (tx *SendTx) SignInput(chainID string, i int, privAccount acm.PrivateAccount) error {
 	if i >= len(tx.Inputs) {
 		return fmt.Errorf(""Index %v is greater than number of inputs (%v)"", i, len(tx.Inputs))
 	}
-	tx.Inputs[i].PubKey = privAccount.PubKey
-	tx.Inputs[i].Signature = privAccount.Sign(chainID, tx)
+	tx.Inputs[i].PubKey = privAccount.PublicKey()
+	tx.Inputs[i].Signature = acm.ChainSign(privAccount, chainID, tx)
 	return nil
 }
 
 //----------------------------------------------------------------------------
 // CallTx interface for creating tx
 
-func NewCallTx(st AccountGetter, from crypto.PubKey, to, data []byte, amt, gasLimit, fee int64) (*CallTx, error) {
+func NewCallTx(st acm.Getter, from acm.PublicKey, to *acm.Address, data []byte,
+	amt, gasLimit, fee uint64) (*CallTx, error) {
+
 	addr := from.Address()
-	acc := st.GetAccount(addr)
+	acc, err := st.GetAccount(addr)
+	if err != nil {
+		return nil, err
+	}
 	if acc == nil {
-		return nil, fmt.Errorf(""Invalid address %X from pubkey %X"", addr, from)
+		return nil, fmt.Errorf(""invalid address %s from pubkey %s"", addr, from)
 	}
 
-	nonce := acc.Sequence + 1
+	nonce := acc.Sequence() + 1
 	return NewCallTxWithNonce(from, to, data, amt, gasLimit, fee, nonce), nil
 }
 
-func NewCallTxWithNonce(from crypto.PubKey, to, data []byte, amt, gasLimit, fee int64, nonce int) *CallTx {
-	addr := from.Address()
+func NewCallTxWithNonce(from acm.PublicKey, to *acm.Address, data []byte,",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/161730918,https://github.com/hyperledger/burrow/pull/666#discussion_r161730918,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,Reasonable `help wanted` issue...? ,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-16 11:37:52,161732106,"@@ -0,0 +1,386 @@
+// Copyright 2017 Monax Industries Limited
+//
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package execution
+
+import (
+	""bytes""
+	""fmt""
+	""sort""
+
+	acm ""github.com/hyperledger/burrow/account""
+	. ""github.com/hyperledger/burrow/binary""
+
+	""sync""
+
+	""github.com/tendermint/merkleeyes/iavl""
+	dbm ""github.com/tendermint/tmlibs/db""
+	""github.com/tendermint/tmlibs/merkle""
+)
+
+func makeStorage(db dbm.DB, root []byte) merkle.Tree {
+	storage := iavl.NewIAVLTree(1024, db)
+	storage.Load(root)
+	return storage
+}
+
+var _ acm.StateWriter = &BlockCache{}
+
+var _ acm.StateIterable = &BlockCache{}
+
+// TODO: BlockCache badly needs a rewrite to remove database sharing with State and make it communicate using the",42,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/161732106,https://github.com/hyperledger/burrow/pull/666#discussion_r161732106,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,New `perms` implementation much cleaner and more readable. ++,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-16 11:45:52,161733901,"@@ -0,0 +1,190 @@
+// Copyright 2017 Monax Industries Limited",1,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/161733901,https://github.com/hyperledger/burrow/pull/666#discussion_r161733901,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,I like this more opinionated take on running tm. It will significantly declutter (and de-confuse) our configs. ,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-16 11:48:05,161734310,"@@ -1,177 +1,42 @@
-// Copyright 2017 Monax Industries Limited
-//
-// Licensed under the Apache License, Version 2.0 (the ""License"");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an ""AS IS"" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
 package tendermint
 
 import (
 	""path""
-	""time""
-
-	""github.com/spf13/viper""
-	tendermintConfig ""github.com/tendermint/go-config""
 
-	""github.com/hyperledger/burrow/config""
+	tm_config ""github.com/tendermint/tendermint/config""
 )
 
-// NOTE [ben] Compiler check to ensure TendermintConfig successfully implements
-// tendermint/go-config/config.Config
-var _ tendermintConfig.Config = (*TendermintConfig)(nil)
-
-// Tendermint has a self-rolled configuration type defined
-// in tendermint/go-config but over an interface type, which is implemented
-// by default in tendermint/tendermint/config/tendermint.go
-// However, for burrow purposes we can choose different rules for how to load
-// the tendermint configuration and set the defaults.  Hence we re-implement
-// go-config.Config on a viper subtree of the loaded burrow configuration file.
-type TendermintConfig struct {
-	subTree *viper.Viper
-}
-
-func GetTendermintConfig(loadedConfig *viper.Viper) *TendermintConfig {
-	// ensure we make an explicit copy
-	subTree := new(viper.Viper)
-	*subTree = *loadedConfig
-
-	return &TendermintConfig{
-		subTree: subTree,
+// Burrow's view on Tendermint's config. Since we operate as a Tendermint harness not all configuration values
+// are applicable, we may not allow some values to specified, or we may not allow some to be set independently.
+// So this serves as a layer of indirection over Tendermint's real config that we derive from ours.
+type BurrowTendermintConfig struct {
+	Seeds                string
+	ListenAddress        string
+	Moniker              string
+	TendermintRoot       string
+}
+
+func DefaultBurrowTendermintConfig() *BurrowTendermintConfig {
+	tmDefaultConfig := tm_config.DefaultConfig()
+	return &BurrowTendermintConfig{
+		ListenAddress:        tmDefaultConfig.P2P.ListenAddress,
+		TendermintRoot:       "".burrow"",
 	}
 }
 
-//------------------------------------------------------------------------------
-// Tendermint defaults
-
-//
-// Contract
-//
-
-func (tmintConfig *TendermintConfig) AssertTendermintDefaults(chainId, workDir,",74,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/161734310,https://github.com/hyperledger/burrow/pull/666#discussion_r161734310,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,Does this commit remove support for logging to a file or syslog?,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-16 14:45:15,161777030,"@@ -187,29 +191,6 @@ func StderrOutput() *OutputConfig {
 	}
 }
 
-func SyslogOutput(tag string) *OutputConfig {
-	return RemoteSyslogOutput(tag, """")
-}
-
-func FileOutput(path string) *OutputConfig {
-	return &OutputConfig{
-		OutputType: File,
-		FileConfig: &FileConfig{
-			Path: path,
-		},
-	}
-}
-
-func RemoteSyslogOutput(tag, remoteUrl string) *OutputConfig {
-	return &OutputConfig{
-		OutputType: Syslog,
-		SyslogConfig: &SyslogConfig{
-			Url: remoteUrl,
-			Tag: tag,
-		},
-	}
-}",174,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/161777030,https://github.com/hyperledger/burrow/pull/666#discussion_r161777030,aludvik
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"`AsMutableAccount` depends on same detail, but I agree better to isolate it there",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-23 15:32:08,163279331,"@@ -41,64 +36,319 @@ func SignBytes(chainID string, o Signable) []byte {
 	buf, n, err := new(bytes.Buffer), new(int), new(error)
 	o.WriteSignBytes(chainID, buf, n, err)
 	if *err != nil {
-		sanity.PanicCrisis(err)
+		panic(fmt.Sprintf(""could not write sign bytes for a signable: %s"", *err))
 	}
-
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
+}
+
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {
+	Address     Address
+	PublicKey   PublicKey
+	Balance     uint64
+	Code        Bytecode
+	Sequence    uint64
+	StorageRoot []byte
+	Permissions ptypes.AccountPermissions
+}
+
+func NewConcreteAccount(pubKey PublicKey) ConcreteAccount {
+	return ConcreteAccount{
+		Address:   pubKey.Address(),
+		PublicKey: pubKey,
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
+	}
 }
 
-func (acc *Account) Copy() *Account {
+func NewConcreteAccountFromSecret(secret string) ConcreteAccount {
+	return NewConcreteAccount(PublicKeyFromPubKey(PrivateKeyFromSecret(secret).PubKey()))
+}
+
+// Return as immutable Account
+func (acc ConcreteAccount) Account() Account {
+	return concreteAccountWrapper{&acc}
+}
+
+// Return as mutable MutableAccount
+func (acc ConcreteAccount) MutableAccount() MutableAccount {
+	return concreteAccountWrapper{&acc}
+}
+
+func (acc *ConcreteAccount) Encode() []byte {
+	return wire.BinaryBytes(acc)
+}
+
+func (acc *ConcreteAccount) Copy() *ConcreteAccount {
 	accCopy := *acc
 	return &accCopy
 }
 
-func (acc *Account) String() string {
+func (acc *ConcreteAccount) String() string {
 	if acc == nil {
-		return ""nil-Account""
+		return ""Account{nil}""
 	}
-	return fmt.Sprintf(""Account{%X:%v B:%v C:%v S:%X P:%s}"", acc.Address, acc.PubKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
+
+	return fmt.Sprintf(""Account{Address: %s; PublicKey: %v Balance: %v; CodeBytes: %v; StorageRoot: 0x%X; Permissions: %s}"",
+		acc.Address, acc.PublicKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
 }
 
-func AccountEncoder(o interface{}, w io.Writer, n *int, err *error) {
-	wire.WriteBinary(o.(*Account), w, n, err)
+// ConcreteAccount
+// -------------------------------------------------
+// Conversions
+//
+// Using the naming convention is this package of 'As<Type>' being
+// a conversion from Account to <Type> and 'From<Type>' being conversion
+// from <Type> to Account. Conversions are done by copying
+
+// Returns a mutable, serialisable ConcreteAccount by copying from account
+func AsConcreteAccount(account Account) *ConcreteAccount {
+	if account == nil {
+		return nil
+	}
+	if ca, ok := account.(concreteAccountWrapper); ok {
+		return ca.ConcreteAccount
+	}
+	return &ConcreteAccount{
+		Address:     account.Address(),
+		PublicKey:   account.PublicKey(),
+		Balance:     account.Balance(),
+		Code:        account.Code(),
+		Sequence:    account.Sequence(),
+		StorageRoot: account.StorageRoot(),
+		Permissions: account.Permissions(),
+	}
+}
+
+// Creates an otherwise zeroed Account from an Addressable and returns it as MutableAccount
+func FromAddressable(addressable Addressable) MutableAccount {
+	return ConcreteAccount{
+		Address:   addressable.Address(),
+		PublicKey: addressable.PublicKey(),
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
+	}.MutableAccount()
+}
+
+// Returns an immutable account by copying from account
+func AsAccount(account Account) Account {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).Account()
+}
+
+// Returns a MutableAccount by copying from account
+func AsMutableAccount(account Account) MutableAccount {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).MutableAccount()
+}
+
+func GetMutableAccount(getter Getter, address Address) (MutableAccount, error) {
+	acc, err := getter.GetAccount(address)
+	if err != nil {
+		return nil, err
+	}
+	// If we get get our own concreteAccountWrapper back we can save an unnecessary copy and just
+	// return since ConcreteAccount.Account() will have been used to produce it which will already
+	// have copied",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163279331,https://github.com/hyperledger/burrow/pull/666#discussion_r163279331,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,I agree on the names. I sort of intended the indirection though. I'd like a single place to hook any changes in dependency. Currently it's a simple wrapping but it could be a true mapping. I'm going to hold my nose and favour the full `PrivateKeyFromGoCryptoPrivKey`,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-23 15:37:46,163281242,"@@ -0,0 +1,61 @@
+package account
+
+import ""github.com/tendermint/go-crypto""
+
+// This allows us to control serialisation
+
+type PublicKey struct {
+	crypto.PubKey `json:""unwrap""`
+}
+
+func PublicKeyFromPubKey(pubKey crypto.PubKey) PublicKey {
+	return PublicKey{PubKey: pubKey}
+}
+
+func PrivateKeyFromPrivKey(privKey crypto.PrivKey) PrivateKey {",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163281242,https://github.com/hyperledger/burrow/pull/666#discussion_r163281242,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"It's something of a cascade from having block heights as `uint64`, see my issue here: https://github.com/tendermint/tendermint/issues/731. `int` only takes us to 68 years! Clearly nonce can grow at faster linear rate to this, so makes sense to pull in.",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-23 15:41:28,163282532,"@@ -41,64 +36,319 @@ func SignBytes(chainID string, o Signable) []byte {
 	buf, n, err := new(bytes.Buffer), new(int), new(error)
 	o.WriteSignBytes(chainID, buf, n, err)
 	if *err != nil {
-		sanity.PanicCrisis(err)
+		panic(fmt.Sprintf(""could not write sign bytes for a signable: %s"", *err))
 	}
-
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163282532,https://github.com/hyperledger/burrow/pull/666#discussion_r163282532,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"The logic was that if we get here we have failed other checks and the desire to keep the interface simpler. There are existing panics in execution that mirror this, however, it was the wrong reasoning and I agree with you so I will remove them too.",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-23 15:43:18,163283199,"@@ -41,64 +36,319 @@ func SignBytes(chainID string, o Signable) []byte {
 	buf, n, err := new(bytes.Buffer), new(int), new(error)
 	o.WriteSignBytes(chainID, buf, n, err)
 	if *err != nil {
-		sanity.PanicCrisis(err)
+		panic(fmt.Sprintf(""could not write sign bytes for a signable: %s"", *err))
 	}
-
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163283199,https://github.com/hyperledger/burrow/pull/666#discussion_r163283199,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,We should leave that to a separate PR,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-23 15:57:42,163288358,"@@ -0,0 +1,136 @@
+// Copyright 2017 Monax Industries Limited
+//
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package account
+
+import (
+	""fmt""
+
+	""github.com/tendermint/ed25519""",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163288358,https://github.com/hyperledger/burrow/pull/666#discussion_r163288358,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"Good, I think we will need to expose more configurability, but rather than just checking every possible changing value I'd like us to expose a higher level interface to tuning that works with Burrow",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-23 15:58:55,163288819,"@@ -1,177 +1,42 @@
-// Copyright 2017 Monax Industries Limited
-//
-// Licensed under the Apache License, Version 2.0 (the ""License"");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an ""AS IS"" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
 package tendermint
 
 import (
 	""path""
-	""time""
-
-	""github.com/spf13/viper""
-	tendermintConfig ""github.com/tendermint/go-config""
 
-	""github.com/hyperledger/burrow/config""
+	tm_config ""github.com/tendermint/tendermint/config""
 )
 
-// NOTE [ben] Compiler check to ensure TendermintConfig successfully implements
-// tendermint/go-config/config.Config
-var _ tendermintConfig.Config = (*TendermintConfig)(nil)
-
-// Tendermint has a self-rolled configuration type defined
-// in tendermint/go-config but over an interface type, which is implemented
-// by default in tendermint/tendermint/config/tendermint.go
-// However, for burrow purposes we can choose different rules for how to load
-// the tendermint configuration and set the defaults.  Hence we re-implement
-// go-config.Config on a viper subtree of the loaded burrow configuration file.
-type TendermintConfig struct {
-	subTree *viper.Viper
-}
-
-func GetTendermintConfig(loadedConfig *viper.Viper) *TendermintConfig {
-	// ensure we make an explicit copy
-	subTree := new(viper.Viper)
-	*subTree = *loadedConfig
-
-	return &TendermintConfig{
-		subTree: subTree,
+// Burrow's view on Tendermint's config. Since we operate as a Tendermint harness not all configuration values
+// are applicable, we may not allow some values to specified, or we may not allow some to be set independently.
+// So this serves as a layer of indirection over Tendermint's real config that we derive from ours.
+type BurrowTendermintConfig struct {
+	Seeds                string
+	ListenAddress        string
+	Moniker              string
+	TendermintRoot       string
+}
+
+func DefaultBurrowTendermintConfig() *BurrowTendermintConfig {
+	tmDefaultConfig := tm_config.DefaultConfig()
+	return &BurrowTendermintConfig{
+		ListenAddress:        tmDefaultConfig.P2P.ListenAddress,
+		TendermintRoot:       "".burrow"",
 	}
 }
 
-//------------------------------------------------------------------------------
-// Tendermint defaults
-
-//
-// Contract
-//
-
-func (tmintConfig *TendermintConfig) AssertTendermintDefaults(chainId, workDir,",74,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163288819,https://github.com/hyperledger/burrow/pull/666#discussion_r163288819,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,it's on roadmap yeah,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-23 15:59:06,163288888,"@@ -0,0 +1,386 @@
+// Copyright 2017 Monax Industries Limited
+//
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package execution
+
+import (
+	""bytes""
+	""fmt""
+	""sort""
+
+	acm ""github.com/hyperledger/burrow/account""
+	. ""github.com/hyperledger/burrow/binary""
+
+	""sync""
+
+	""github.com/tendermint/merkleeyes/iavl""
+	dbm ""github.com/tendermint/tmlibs/db""
+	""github.com/tendermint/tmlibs/merkle""
+)
+
+func makeStorage(db dbm.DB, root []byte) merkle.Tree {
+	storage := iavl.NewIAVLTree(1024, db)
+	storage.Load(root)
+	return storage
+}
+
+var _ acm.StateWriter = &BlockCache{}
+
+var _ acm.StateIterable = &BlockCache{}
+
+// TODO: BlockCache badly needs a rewrite to remove database sharing with State and make it communicate using the",42,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163288888,https://github.com/hyperledger/burrow/pull/666#discussion_r163288888,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"it's legacy from where this code was derived. It used to be truly random, I made is deterministically random. Really it doesn't need to be either, you could feasibly use it to do some automated testing over a range of seeds. I wouldn't have written it this way, and I possibly should have cleared it up when I rewrote parts but I wasn't clear on what tests were depending on so I gave option of picking some random values. I don't think it does much harm leaving it in for now.",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-23 16:01:42,163289895,"@@ -0,0 +1,98 @@
+package genesis
+
+import (
+	""math/rand""
+	""time""
+
+	""fmt""
+
+	acm ""github.com/hyperledger/burrow/account""
+	""github.com/hyperledger/burrow/permission""
+	""github.com/tendermint/ed25519""
+	""github.com/tendermint/go-crypto""
+)
+
+type deterministicGenesis struct {
+	random *rand.Rand
+}
+
+// Generates deterministic pseudo-random genesis state
+func NewDeterministicGenesis(seed int64) *deterministicGenesis {
+	return &deterministicGenesis{
+		random: rand.New(rand.NewSource(seed)),
+	}
+}
+
+func (dg *deterministicGenesis) GenesisDoc(numAccounts int, randBalance bool, minBalance uint64, numValidators int,
+	randBonded bool, minBonded int64) (*GenesisDoc, []acm.PrivateAccount) {
+
+	accounts := make([]Account, numAccounts)
+	privAccounts := make([]acm.PrivateAccount, numAccounts)
+	defaultPerms := permission.DefaultAccountPermissions
+	for i := 0; i < numAccounts; i++ {
+		account, privAccount := dg.Account(randBalance, minBalance)",30,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163289895,https://github.com/hyperledger/burrow/pull/666#discussion_r163289895,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"oops yeah that should be deleted, found its way back in during rebase.",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-23 16:02:31,163290162,"@@ -61,20 +73,252 @@ func NewGenesisValidator(amount int64, name string, unbondToAddress []byte,
 	default:
 		return nil, fmt.Errorf(""Unsupported key type (%s)"", keyType)
 	}
-	newPublicKey, err := crypto.PubKeyFromBytes(typedPublicKeyBytes)
+	newPubKey, err := crypto.PubKeyFromBytes(typedPublicKeyBytes)
 	if err != nil {
 		return nil, err
 	}
 	// ability to unbond to multiple accounts currently unused
 	var unbondTo []BasicAccount
 
-	return &GenesisValidator{
-		PubKey: newPublicKey,
-		Amount: unbondAmount,
-		Name:   name,
+	address, err := acm.AddressFromBytes(newPubKey.Address())
+	if err != nil {
+		return nil, err
+	}
+	return &Validator{
+		BasicAccount: BasicAccount{
+			Address:   address,
+			PublicKey: acm.PublicKeyFromPubKey(newPubKey),
+			Amount:    amount,
+		},
+		Name: name,
 		UnbondTo: append(unbondTo, BasicAccount{
 			Address: unbondToAddress,
 			Amount:  unbondAmount,
 		}),
 	}, nil
 }
+
+//------------------------------------------------------------------------------------
+// interface functions that are consumed by monax tooling
+
+func GenerateKnown(chainName, accountsPathCSV, validatorsPathCSV string) (string, error) {
+	return generateKnownWithTime(chainName, accountsPathCSV, validatorsPathCSV,
+		// set the timestamp for the genesis
+		time.Now())
+}
+
+//------------------------------------------------------------------------------------
+// interface functions that are consumed by monax tooling
+
+func GenerateGenesisFileBytes(chainName string, salt []byte, genesisTime time.Time, genesisAccounts map[string]acm.Account,
+	genesisValidators map[string]acm.Validator) ([]byte, error) {
+
+	genesisDoc := MakeGenesisDocFromAccounts(chainName, salt, genesisTime, genesisAccounts, genesisValidators)
+
+	var err error
+	buf, buf2, n := new(bytes.Buffer), new(bytes.Buffer), new(int)
+	wire.WriteJSON(genesisDoc, buf, n, &err)
+	if err != nil {
+		return nil, err
+	}
+	if err := json.Indent(buf2, buf.Bytes(), """", ""\t""); err != nil {
+		return nil, err
+	}
+
+	return buf2.Bytes(), nil
+}
+
+//------------------------------------------------------------------------------------
+// core functions that provide functionality for monax tooling in v0.16
+
+// GenerateKnownWithTime takes chainName, an accounts and validators CSV filepath
+// and a timestamp to generate the string of `genesis.json`
+// NOTE: [ben] is introduced as technical debt to preserve the signature
+// of GenerateKnown but in order to introduce the timestamp gradually
+// This will be deprecated in v0.17
+func generateKnownWithTime(chainName, accountsPathCSV, validatorsPathCSV string,
+	genesisTime time.Time) (string, error) {
+	var genDoc *GenesisDoc
+
+	// TODO [eb] eliminate reading priv_val ... [zr] where?
+	if accountsPathCSV == """" || validatorsPathCSV == """" {
+		return """", fmt.Errorf(""both accounts.csv and validators.csv is required"")
+	}
+
+	pubkeys, amts, names, perms, setbits, err := parseCsv(validatorsPathCSV)
+	if err != nil {
+		return """", err
+	}
+
+	pubkeysA, amtsA, namesA, permsA, setbitsA, err := parseCsv(accountsPathCSV)
+	if err != nil {
+		return """", err
+	}
+
+	genDoc = newGenDoc(chainName, genesisTime, len(pubkeys), len(pubkeysA))
+	for i, pk := range pubkeys {
+		genDocAddValidator(genDoc, pk, amts[i], names[i], perms[i], setbits[i], i)
+	}
+	for i, pk := range pubkeysA {
+		genDocAddAccount(genDoc, pk, amtsA[i], namesA[i], permsA[i], setbitsA[i], i)
+	}
+
+	buf, buf2, n := new(bytes.Buffer), new(bytes.Buffer), new(int)
+	wire.WriteJSON(genDoc, buf, n, &err)
+	if err != nil {
+		return """", err
+	}
+	if err := json.Indent(buf2, buf.Bytes(), """", ""\t""); err != nil {
+		return """", err
+	}
+
+	return buf2.String(), nil
+}
+
+//-----------------------------------------------------------------------------
+// gendoc convenience functions
+
+func newGenDoc(chainName string, genesisTime time.Time, nVal, nAcc int) *GenesisDoc {
+	genDoc := GenesisDoc{
+		ChainName:   chainName,
+		GenesisTime: genesisTime,
+	}
+	genDoc.Accounts = make([]Account, nAcc)
+	genDoc.Validators = make([]Validator, nVal)
+	return &genDoc
+}
+
+func genDocAddAccount(genDoc *GenesisDoc, pubKey crypto.PubKeyEd25519, amt uint64, name string,
+	perm, setbit ptypes.PermFlag, index int) {
+	addr, _ := acm.AddressFromBytes(pubKey.Address())
+	acc := Account{
+		BasicAccount: BasicAccount{
+			Address: addr,
+			Amount:  amt,
+		},
+		Name: name,
+		Permissions: ptypes.AccountPermissions{
+			Base: ptypes.BasePermissions{
+				Perms:  perm,
+				SetBit: setbit,
+			},
+		},
+	}
+	if index < 0 {
+		genDoc.Accounts = append(genDoc.Accounts, acc)
+	} else {
+		genDoc.Accounts[index] = acc
+	}
+}
+
+func genDocAddValidator(genDoc *GenesisDoc, pubKey crypto.PubKeyEd25519, amt uint64, name string,
+	perm, setbit ptypes.PermFlag, index int) {
+	addr, _ := acm.AddressFromBytes(pubKey.Address())
+	genDoc.Validators[index] = Validator{
+		BasicAccount: BasicAccount{
+			Address:   acm.MustAddressFromBytes(pubKey.Address()),
+			PublicKey: acm.PublicKeyFromPubKey(pubKey.Wrap()),
+			Amount:    amt,
+		},
+		Name: name,
+		UnbondTo: []BasicAccount{
+			{
+				Address: addr,
+				Amount:  amt,
+			},
+		},
+	}
+	// [zr] why no index < 0 like in genDocAddAccount?
+}
+
+//-----------------------------------------------------------------------------
+// util functions",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163290162,https://github.com/hyperledger/burrow/pull/666#discussion_r163290162,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"my thinking was that the presets functionality was implemented in structure but still something of a stub, but yeah for parity/completeness I'll add those. Note that we can have any manner of compositional presets with multiple accounts or whatever.",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-23 16:04:09,163290738,"@@ -0,0 +1,74 @@
+package spec
+
+import (
+	""fmt""
+
+	""sort""
+
+	""github.com/hyperledger/burrow/permission""
+)
+
+// Files here can be used as starting points for building various 'chain types' but are otherwise
+// a fairly unprincipled collection of GenesisSpecs that we find useful in testing and development
+",13,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163290738,https://github.com/hyperledger/burrow/pull/666#discussion_r163290738,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,Casey you need to be stopped. Consistency this. Consistency that. It's globalisation gone mad. Go on then... There's a few other usages of nonce I'll change too.,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-23 16:22:35,163297044,"@@ -37,65 +33,73 @@ func NewSendTx() *SendTx {
 	}
 }
 
-func (tx *SendTx) AddInput(st AccountGetter, pubkey crypto.PubKey, amt int64) error {
+func (tx *SendTx) AddInput(st acm.Getter, pubkey acm.PublicKey, amt uint64) error {
 	addr := pubkey.Address()
-	acc := st.GetAccount(addr)
+	acc, err := st.GetAccount(addr)
+	if err != nil {
+		return err
+	}
 	if acc == nil {
-		return fmt.Errorf(""Invalid address %X from pubkey %X"", addr, pubkey)
+		return fmt.Errorf(""invalid address %s from pubkey %s"", addr, pubkey)
 	}
-	return tx.AddInputWithNonce(pubkey, amt, acc.Sequence+1)
+	return tx.AddInputWithNonce(pubkey, amt, acc.Sequence()+1)
 }
 
-func (tx *SendTx) AddInputWithNonce(pubkey crypto.PubKey, amt int64, nonce int) error {
+func (tx *SendTx) AddInputWithNonce(pubkey acm.PublicKey, amt uint64, sequence uint64) error {
 	addr := pubkey.Address()
 	tx.Inputs = append(tx.Inputs, &TxInput{
 		Address:   addr,
 		Amount:    amt,
-		Sequence:  nonce,
-		Signature: crypto.SignatureEd25519{},
+		Sequence:  sequence,
+		Signature: crypto.SignatureEd25519{}.Wrap(),
 		PubKey:    pubkey,
 	})
 	return nil
 }
 
-func (tx *SendTx) AddOutput(addr []byte, amt int64) error {
+func (tx *SendTx) AddOutput(addr acm.Address, amt uint64) error {
 	tx.Outputs = append(tx.Outputs, &TxOutput{
 		Address: addr,
 		Amount:  amt,
 	})
 	return nil
 }
 
-func (tx *SendTx) SignInput(chainID string, i int, privAccount *acm.PrivAccount) error {
+func (tx *SendTx) SignInput(chainID string, i int, privAccount acm.PrivateAccount) error {
 	if i >= len(tx.Inputs) {
 		return fmt.Errorf(""Index %v is greater than number of inputs (%v)"", i, len(tx.Inputs))
 	}
-	tx.Inputs[i].PubKey = privAccount.PubKey
-	tx.Inputs[i].Signature = privAccount.Sign(chainID, tx)
+	tx.Inputs[i].PubKey = privAccount.PublicKey()
+	tx.Inputs[i].Signature = acm.ChainSign(privAccount, chainID, tx)
 	return nil
 }
 
 //----------------------------------------------------------------------------
 // CallTx interface for creating tx
 
-func NewCallTx(st AccountGetter, from crypto.PubKey, to, data []byte, amt, gasLimit, fee int64) (*CallTx, error) {
+func NewCallTx(st acm.Getter, from acm.PublicKey, to *acm.Address, data []byte,
+	amt, gasLimit, fee uint64) (*CallTx, error) {
+
 	addr := from.Address()
-	acc := st.GetAccount(addr)
+	acc, err := st.GetAccount(addr)
+	if err != nil {
+		return nil, err
+	}
 	if acc == nil {
-		return nil, fmt.Errorf(""Invalid address %X from pubkey %X"", addr, from)
+		return nil, fmt.Errorf(""invalid address %s from pubkey %s"", addr, from)
 	}
 
-	nonce := acc.Sequence + 1
+	nonce := acc.Sequence() + 1
 	return NewCallTxWithNonce(from, to, data, amt, gasLimit, fee, nonce), nil
 }
 
-func NewCallTxWithNonce(from crypto.PubKey, to, data []byte, amt, gasLimit, fee int64, nonce int) *CallTx {
-	addr := from.Address()
+func NewCallTxWithNonce(from acm.PublicKey, to *acm.Address, data []byte,",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163297044,https://github.com/hyperledger/burrow/pull/666#discussion_r163297044,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,There is support for this in our 'reference' implementation of keys - I decided to import all these constants here in anticipation of using them at a future date.,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-23 19:45:57,163356307,"@@ -15,21 +15,48 @@
 package keys
 
 import (
+	""bytes""
 	""encoding/hex""
 	""fmt""
 
+	acm ""github.com/hyperledger/burrow/account""
 	""github.com/hyperledger/burrow/logging""
 	logging_types ""github.com/hyperledger/burrow/logging/types""
+	""github.com/tendermint/go-crypto""
 )
 
 type KeyClient interface {
-	// Sign needs to return the signature bytes for given message to sign
-	// and the address to sign it with.
-	Sign(signBytesString string, signAddress []byte) (signature []byte, err error)
-	// PublicKey needs to return the public key associated with a given address
-	PublicKey(address []byte) (publicKey []byte, err error)
+	// Sign returns the signature bytes for given message signed with the key associated with signAddress
+	Sign(signAddress acm.Address, message []byte) (signature crypto.Signature, err error)
+
+	// PublicKey returns the public key associated with a given address
+	PublicKey(address acm.Address) (publicKey acm.PublicKey, err error)
+
+	// Generate requests that a key be generate within the keys instance and returns the address
+	Generate(keyName string, keyType KeyType) (keyAddress acm.Address, err error)
+
+	// Returns nil if the keys isntance is health, error otherwise
+	HealthCheck() error
+}
+
+// This mirrors ""github.com/monax/keys/crypto/KeyType"" but since we have no use for the struct here it seems simpler
+// to replicate rather than cop an import
+type KeyType string
+
+func (kt KeyType) String() string {
+	return string(kt)
 }
 
+const (
+	KeyTypeEd25519Ripemd160         KeyType = ""ed25519,ripemd160""
+	KeyTypeEd25519Ripemd160sha256           = ""ed25519,ripemd160sha256""
+	KeyTypeEd25519Ripemd160sha3             = ""ed25519,sha3""
+	KeyTypeSecp256k1Ripemd160               = ""secp256k1,ripemd160""
+	KeyTypeSecp256k1Ripemd160sha256         = ""secp256k1,ripemd160sha256""
+	KeyTypeSecp256k1Ripemd160sha3           = ""secp256k1,sha3""
+	KeyTypeDefault                          = KeyTypeEd25519Ripemd160",44,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163356307,https://github.com/hyperledger/burrow/pull/666#discussion_r163356307,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"good point, I agree",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-23 19:46:05,163356330,"@@ -50,34 +123,59 @@ func NewBurrowKeyClient(rpcString string, logger logging_types.InfoTraceLogger)
 
 // Monax-keys client Sign requests the signature from BurrowKeysClient over rpc for the given
 // bytes to be signed and the address to sign them with.
-func (monaxKeys *monaxKeyClient) Sign(signBytesString string, signAddress []byte) (signature []byte, err error) {
+func (monaxKeys *monaxKeyClient) Sign(signAddress acm.Address, message []byte) (crypto.Signature, error) {",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163356330,https://github.com/hyperledger/burrow/pull/666#discussion_r163356330,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"It is because we dropped our log15 dependency that was providing this. I would like to reintroduce syslog, but I can put file back in their now.",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-23 20:01:56,163360630,"@@ -187,29 +191,6 @@ func StderrOutput() *OutputConfig {
 	}
 }
 
-func SyslogOutput(tag string) *OutputConfig {
-	return RemoteSyslogOutput(tag, """")
-}
-
-func FileOutput(path string) *OutputConfig {
-	return &OutputConfig{
-		OutputType: File,
-		FileConfig: &FileConfig{
-			Path: path,
-		},
-	}
-}
-
-func RemoteSyslogOutput(tag, remoteUrl string) *OutputConfig {
-	return &OutputConfig{
-		OutputType: Syslog,
-		SyslogConfig: &SyslogConfig{
-			Url: remoteUrl,
-			Tag: tag,
-		},
-	}
-}",174,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163360630,https://github.com/hyperledger/burrow/pull/666#discussion_r163360630,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"I'm not a fan of it either particularly, though at least it's short. I used it because there was a pre-existing usage of it in a few places. Based on the fact previous authors use `dbm` for `go-db`, package `db` I sort of read it as 'database manager' and 'account manager'.

My two reasons for using an alias were:
1. To leave 'account' available for actual accounts - actually this doesn't happen a lot because there are usually `<something>Account`s.
2. Because I don't like `account.Account` as a type name, yet nothing came immediately to mind to replace it.

I don't think these are particularly strong reasons though I'd be tempted to pick another name for the `account` package if I did drop the alias. `state` perhaps, but a bit generic...",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-23 20:05:49,163361578,"@@ -15,21 +15,48 @@
 package keys
 
 import (
+	""bytes""
 	""encoding/hex""
 	""fmt""
 
+	acm ""github.com/hyperledger/burrow/account""",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163361578,https://github.com/hyperledger/burrow/pull/666#discussion_r163361578,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"I'll just drop, we're already in burrow",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-23 20:06:17,163361701,"@@ -39,6 +66,52 @@ type monaxKeyClient struct {
 	logger    logging_types.InfoTraceLogger
 }
 
+type monaxSigner struct {",,2018-01-25 18:20:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163361701,https://github.com/hyperledger/burrow/pull/666#discussion_r163361701,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"FYI I'm going to do something about this, but in future single-purpose PR since it will touch almost every file",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-25 18:25:16,163927216,"@@ -15,21 +15,48 @@
 package keys
 
 import (
+	""bytes""
 	""encoding/hex""
 	""fmt""
 
+	acm ""github.com/hyperledger/burrow/account""",,2018-01-25 18:25:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163927216,https://github.com/hyperledger/burrow/pull/666#discussion_r163927216,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"`BigInt` add unnecessary overhead for now, but at some point we'd need an ability to deal with the overflows ",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-25 20:48:41,163963561,"@@ -41,64 +36,319 @@ func SignBytes(chainID string, o Signable) []byte {
 	buf, n, err := new(bytes.Buffer), new(int), new(error)
 	o.WriteSignBytes(chainID, buf, n, err)
 	if *err != nil {
-		sanity.PanicCrisis(err)
+		panic(fmt.Sprintf(""could not write sign bytes for a signable: %s"", *err))
 	}
-
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64",,2018-01-25 21:11:34,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163963561,https://github.com/hyperledger/burrow/pull/666#discussion_r163963561,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,This commit makes me :) .... much more approachable for newbs that understand distributed systems but not the #blockchain lingo.,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-25 20:50:10,163963880,"@@ -253,11 +253,11 @@ func NewPermissionsTx(st acm.Getter, from acm.PublicKey, args *ptypes.PermArgs)
 		return nil, fmt.Errorf(""Invalid address %s from pubkey %s"", addr, from)
 	}
 
-	nonce := acc.Sequence() + 1
-	return NewPermissionsTxWithNonce(from, args, nonce), nil
+	sequence := acc.Sequence() + 1
+	return NewPermissionsTxWithSequence(from, args, sequence), nil
 }
 
-func NewPermissionsTxWithNonce(from acm.PublicKey, args *ptypes.PermArgs, sequence uint64) *PermissionsTx {
+func NewPermissionsTxWithSequence(from acm.PublicKey, args *ptypes.PermArgs, sequence uint64) *PermissionsTx {
 	input := &TxInput{
 		Address:   from.Address(),
 		Amount:    1, // NOTE: amounts can't be 0 ...",,2018-01-25 21:11:34,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163963880,https://github.com/hyperledger/burrow/pull/666#discussion_r163963880,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,:),0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-25 20:50:53,163964038,"@@ -284,22 +278,22 @@ func (caw concreteAccountWrapper) SetPublicKey(pubKey PublicKey) MutableAccount
 	return caw
 }
 
-func (caw concreteAccountWrapper) SubtractFromBalance(amount uint64) MutableAccount {
+func (caw concreteAccountWrapper) SubtractFromBalance(amount uint64) (MutableAccount, error) {
 	if amount > caw.Balance() {
-		panic(fmt.Errorf(""insufficient funds: attempt to subtract %v from the balance of %s"",
-			amount, caw.ConcreteAccount))
+		return nil, fmt.Errorf(""insufficient funds: attempt to subtract %v from the balance of %s"",
+			amount, caw.ConcreteAccount)",,2018-01-25 21:11:34,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163964038,https://github.com/hyperledger/burrow/pull/666#discussion_r163964038,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"This is longer and less clean from a readability perspective, but significantly cleaner from an execution perspective. ",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-25 20:52:56,163964552,"@@ -781,7 +799,10 @@ func (exe *executor) Execute(tx txs.Tx) error {
 
 		// Good!
 		inAcc.IncSequence()
-		inAcc.SubtractFromBalance(value)
+		inAcc, err = inAcc.SubtractFromBalance(value)
+		if err != nil {
+			return err
+		}",,2018-01-25 21:11:34,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163964552,https://github.com/hyperledger/burrow/pull/666#discussion_r163964552,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,RIP old friend.,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-25 20:54:06,163964839,"@@ -1,324 +0,0 @@
-// Copyright 2017 Monax Industries Limited
-//
-// Licensed under the Apache License, Version 2.0 (the ""License"");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an ""AS IS"" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package genesis
-
-import (
-	""bytes""
-	""encoding/csv""
-	""encoding/hex""
-	""encoding/json""
-	""fmt""
-	""os""
-	""strconv""
-	""time""
-
-	acm ""github.com/hyperledger/burrow/account""
-	""github.com/hyperledger/burrow/permission""
-	ptypes ""github.com/hyperledger/burrow/permission/types""
-	""github.com/hyperledger/burrow/util""
-	""github.com/tendermint/go-crypto""
-	wire ""github.com/tendermint/go-wire""
-)
-
-const (
-	PublicKeyEd25519ByteLength   int = 32
-	PublicKeySecp256k1ByteLength int = 64
-)
-
-// NewGenesisAccount returns a new Account
-func NewGenesisAccount(address acm.Address, amount uint64, name string,
-	permissions *ptypes.AccountPermissions) *Account {
-	return &Account{
-		BasicAccount: BasicAccount{
-			Address: address,
-			Amount:  amount,
-		},
-		Name:        name,
-		Permissions: permissions.Clone(),
-	}
-}
-
-func NewGenesisValidator(amount uint64, name string, unbondToAddress acm.Address,
-	unbondAmount uint64, keyType string, publicKeyBytes []byte) (*Validator, error) {
-	// convert the key bytes into a typed fixed size byte array
-	var typedPublicKeyBytes []byte
-	switch keyType {
-	case ""ed25519"": // ed25519 has type byte 0x01
-		// TODO: [ben] functionality and checks need to be inherit in the type
-		if len(publicKeyBytes) != PublicKeyEd25519ByteLength {
-			return nil, fmt.Errorf(""Invalid length provided for ed25519 public key (%v bytes provided but expected %v bytes)"",
-				len(publicKeyBytes), PublicKeyEd25519ByteLength)
-		}
-		// prepend type byte to public key
-		typedPublicKeyBytes = append([]byte{crypto.TypeEd25519}, publicKeyBytes...)
-	case ""secp256k1"": // secp256k1 has type byte 0x02
-		if len(publicKeyBytes) != PublicKeySecp256k1ByteLength {
-			return nil, fmt.Errorf(""Invalid length provided for secp256k1 public key (%v bytes provided but expected %v bytes)"",
-				len(publicKeyBytes), PublicKeySecp256k1ByteLength)
-		}
-		// prepend type byte to public key
-		typedPublicKeyBytes = append([]byte{crypto.TypeSecp256k1}, publicKeyBytes...)
-	default:
-		return nil, fmt.Errorf(""Unsupported key type (%s)"", keyType)
-	}
-	newPubKey, err := crypto.PubKeyFromBytes(typedPublicKeyBytes)
-	if err != nil {
-		return nil, err
-	}
-	// ability to unbond to multiple accounts currently unused
-	var unbondTo []BasicAccount
-
-	address, err := acm.AddressFromBytes(newPubKey.Address())
-	if err != nil {
-		return nil, err
-	}
-	return &Validator{
-		BasicAccount: BasicAccount{
-			Address:   address,
-			PublicKey: acm.PublicKeyFromPubKey(newPubKey),
-			Amount:    amount,
-		},
-		Name: name,
-		UnbondTo: append(unbondTo, BasicAccount{
-			Address: unbondToAddress,
-			Amount:  unbondAmount,
-		}),
-	}, nil
-}
-
-//------------------------------------------------------------------------------------
-// interface functions that are consumed by monax tooling
-
-func GenerateKnown(chainName, accountsPathCSV, validatorsPathCSV string) (string, error) {
-	return generateKnownWithTime(chainName, accountsPathCSV, validatorsPathCSV,
-		// set the timestamp for the genesis
-		time.Now())
-}
-
-//------------------------------------------------------------------------------------
-// interface functions that are consumed by monax tooling
-
-func GenerateGenesisFileBytes(chainName string, salt []byte, genesisTime time.Time, genesisAccounts map[string]acm.Account,
-	genesisValidators map[string]acm.Validator) ([]byte, error) {
-
-	genesisDoc := MakeGenesisDocFromAccounts(chainName, salt, genesisTime, genesisAccounts, genesisValidators)
-
-	var err error
-	buf, buf2, n := new(bytes.Buffer), new(bytes.Buffer), new(int)
-	wire.WriteJSON(genesisDoc, buf, n, &err)
-	if err != nil {
-		return nil, err
-	}
-	if err := json.Indent(buf2, buf.Bytes(), """", ""\t""); err != nil {
-		return nil, err
-	}
-
-	return buf2.Bytes(), nil
-}
-
-//------------------------------------------------------------------------------------
-// core functions that provide functionality for monax tooling in v0.16
-
-// GenerateKnownWithTime takes chainName, an accounts and validators CSV filepath
-// and a timestamp to generate the string of `genesis.json`
-// NOTE: [ben] is introduced as technical debt to preserve the signature
-// of GenerateKnown but in order to introduce the timestamp gradually
-// This will be deprecated in v0.17
-func generateKnownWithTime(chainName, accountsPathCSV, validatorsPathCSV string,
-	genesisTime time.Time) (string, error) {
-	var genDoc *GenesisDoc
-
-	// TODO [eb] eliminate reading priv_val ... [zr] where?
-	if accountsPathCSV == """" || validatorsPathCSV == """" {
-		return """", fmt.Errorf(""both accounts.csv and validators.csv is required"")
-	}
-
-	pubkeys, amts, names, perms, setbits, err := parseCsv(validatorsPathCSV)
-	if err != nil {
-		return """", err
-	}
-
-	pubkeysA, amtsA, namesA, permsA, setbitsA, err := parseCsv(accountsPathCSV)
-	if err != nil {
-		return """", err
-	}
-
-	genDoc = newGenDoc(chainName, genesisTime, len(pubkeys), len(pubkeysA))
-	for i, pk := range pubkeys {
-		genDocAddValidator(genDoc, pk, amts[i], names[i], perms[i], setbits[i], i)
-	}
-	for i, pk := range pubkeysA {
-		genDocAddAccount(genDoc, pk, amtsA[i], namesA[i], permsA[i], setbitsA[i], i)
-	}
-
-	buf, buf2, n := new(bytes.Buffer), new(bytes.Buffer), new(int)
-	wire.WriteJSON(genDoc, buf, n, &err)
-	if err != nil {
-		return """", err
-	}
-	if err := json.Indent(buf2, buf.Bytes(), """", ""\t""); err != nil {
-		return """", err
-	}
-
-	return buf2.String(), nil
-}
-
-//-----------------------------------------------------------------------------
-// gendoc convenience functions
-
-func newGenDoc(chainName string, genesisTime time.Time, nVal, nAcc int) *GenesisDoc {
-	genDoc := GenesisDoc{
-		ChainName:   chainName,
-		GenesisTime: genesisTime,
-	}
-	genDoc.Accounts = make([]Account, nAcc)
-	genDoc.Validators = make([]Validator, nVal)
-	return &genDoc
-}
-
-func genDocAddAccount(genDoc *GenesisDoc, pubKey crypto.PubKeyEd25519, amt uint64, name string,
-	perm, setbit ptypes.PermFlag, index int) {
-	addr, _ := acm.AddressFromBytes(pubKey.Address())
-	acc := Account{
-		BasicAccount: BasicAccount{
-			Address: addr,
-			Amount:  amt,
-		},
-		Name: name,
-		Permissions: ptypes.AccountPermissions{
-			Base: ptypes.BasePermissions{
-				Perms:  perm,
-				SetBit: setbit,
-			},
-		},
-	}
-	if index < 0 {
-		genDoc.Accounts = append(genDoc.Accounts, acc)
-	} else {
-		genDoc.Accounts[index] = acc
-	}
-}
-
-func genDocAddValidator(genDoc *GenesisDoc, pubKey crypto.PubKeyEd25519, amt uint64, name string,
-	perm, setbit ptypes.PermFlag, index int) {
-	addr, _ := acm.AddressFromBytes(pubKey.Address())
-	genDoc.Validators[index] = Validator{
-		BasicAccount: BasicAccount{
-			Address:   acm.MustAddressFromBytes(pubKey.Address()),
-			PublicKey: acm.PublicKeyFromPubKey(pubKey.Wrap()),
-			Amount:    amt,
-		},
-		Name: name,
-		UnbondTo: []BasicAccount{
-			{
-				Address: addr,
-				Amount:  amt,
-			},
-		},
-	}
-	// [zr] why no index < 0 like in genDocAddAccount?
-}
-
-//-----------------------------------------------------------------------------
-// util functions
-
-// convert hex strings to ed25519 pubkeys
-func pubKeyStringsToPubKeys(pubkeys []string) ([]crypto.PubKeyEd25519, error) {
-	pubKeys := make([]crypto.PubKeyEd25519, len(pubkeys))
-	for i, k := range pubkeys {
-		pubBytes, err := hex.DecodeString(k)
-		if err != nil {
-			return pubKeys, err
-		}
-		copy(pubKeys[i][:], pubBytes)
-	}
-	return pubKeys, nil
-}
-
-// empty is over written
-func ifExistsElse(list []string, index int, defaultValue string) string {
-	if len(list) > index {
-		if list[index] != """" {
-			return list[index]
-		}
-	}
-	return defaultValue
-}
-
-// takes a csv in the following format: pubkey, starting balance, name, permissions, setbit
-func parseCsv(filePath string) (pubKeys []crypto.PubKeyEd25519, amts []uint64, names []string, perms, setbits []ptypes.PermFlag, err error) {
-
-	csvFile, err := os.Open(filePath)
-	if err != nil {
-		util.Fatalf(""Couldn't open file: %s: %v"", filePath, err)
-	}
-	defer csvFile.Close()
-
-	r := csv.NewReader(csvFile)
-	//r.FieldsPerRecord = # of records expected
-	params, err := r.ReadAll()
-	if err != nil {
-		util.Fatalf(""Couldn't read file: %v"", err)
-
-	}
-
-	pubkeys := make([]string, len(params))
-	amtS := make([]string, len(params))
-	names = make([]string, len(params))
-	permsS := make([]string, len(params))
-	setbitS := make([]string, len(params))
-	for i, each := range params {
-		pubkeys[i] = each[0]
-		amtS[i] = ifExistsElse(each, 1, ""1000"")
-		names[i] = ifExistsElse(each, 2, """")
-		permsS[i] = ifExistsElse(each, 3, fmt.Sprintf(""%d"", permission.DefaultPermFlags))
-		setbitS[i] = ifExistsElse(each, 4, permsS[i])
-	}
-
-	//TODO convert int to uint64, see issue #25
-	perms = make([]ptypes.PermFlag, len(permsS))
-	for i, perm := range permsS {
-		pflag, err := strconv.Atoi(perm)
-		if err != nil {
-			util.Fatalf(""Permissions (%v) must be an integer"", perm)
-		}
-		perms[i] = ptypes.PermFlag(pflag)
-	}
-	setbits = make([]ptypes.PermFlag, len(setbitS))
-	for i, setbit := range setbitS {
-		setbitsFlag, err := strconv.Atoi(setbit)
-		if err != nil {
-			util.Fatalf(""SetBits (%v) must be an integer"", setbit)
-		}
-		setbits[i] = ptypes.PermFlag(setbitsFlag)
-	}
-
-	// convert amts to ints
-	amts = make([]uint64, len(amtS))
-	for i, a := range amtS {
-		if amts[i], err = strconv.ParseUint(a, 10, 64); err != nil {
-			err = fmt.Errorf(""Invalid amount: %v"", err)
-			return
-		}
-	}
-
-	// convert pubkey hex strings to struct
-	pubKeys, err = pubKeyStringsToPubKeys(pubkeys)
-	if err != nil {
-		return
-	}
-
-	return pubKeys, amts, names, perms, setbits, nil
-}",,2018-01-25 21:11:34,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163964839,https://github.com/hyperledger/burrow/pull/666#discussion_r163964839,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,This implementation is nice. And very readable...! ,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-25 20:55:12,163965094,"@@ -26,13 +26,56 @@ func FullAccount(index int) GenesisSpec {
 	}
 }
 
+func RootAccount(index int) GenesisSpec {
+	// Inheriting from the arbitrary figures used by monax tool for now
+	amount := uint64(99999999999999)
+	return GenesisSpec{
+		Accounts: []TemplateAccount{{
+			Name:        fmt.Sprintf(""Root_%v"", index),
+			Amount:      &amount,
+			Permissions: []string{permission.AllString},
+		},
+		},
+	}
+}
+
 func ParticipantAccount(index int) GenesisSpec {
+	// Inheriting from the arbitrary figures used by monax tool for now
 	amount := uint64(9999999999)
 	return GenesisSpec{
 		Accounts: []TemplateAccount{{
-			Name:        fmt.Sprintf(""Participant_%v"", index),
-			Amount:      &amount,
-			Permissions: []string{permission.SendString, permission.CallString, permission.NameString, permission.HasRoleString},
+			Name:   fmt.Sprintf(""Participant_%v"", index),
+			Amount: &amount,
+			Permissions: []string{permission.SendString, permission.CallString, permission.NameString,
+				permission.HasRoleString},
+		}},
+	}
+}
+
+func DeveloperAccount(index int) GenesisSpec {
+	// Inheriting from the arbitrary figures used by monax tool for now
+	amount := uint64(9999999999)
+	return GenesisSpec{
+		Accounts: []TemplateAccount{{
+			Name:   fmt.Sprintf(""Developer_%v"", index),
+			Amount: &amount,
+			Permissions: []string{permission.SendString, permission.CallString, permission.CreateContractString,
+				permission.CreateAccountString, permission.NameString, permission.HasRoleString,
+				permission.RemoveRoleString},
+		}},
+	}
+}
+
+func ValidatorAccount(index int) GenesisSpec {
+	// Inheriting from the arbitrary figures used by monax tool for now
+	amount := uint64(9999999999)
+	amountBonded := amount - 1
+	return GenesisSpec{
+		Accounts: []TemplateAccount{{
+			Name:         fmt.Sprintf(""Validator_%v"", index),
+			Amount:       &amount,
+			AmountBonded: &amountBonded,
+			Permissions: []string{permission.BondString},
 		}},
 	}
 }",,2018-01-25 21:11:34,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163965094,https://github.com/hyperledger/burrow/pull/666#discussion_r163965094,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,💃 ,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-25 20:59:49,163966172,"@@ -0,0 +1,235 @@
+package account
+
+import (
+	""bytes""
+	""crypto/rand""
+	""crypto/sha256""
+	""fmt""
+	""io""
+
+	""github.com/tendermint/go-crypto""
+	""golang.org/x/crypto/ed25519""",11,2018-01-25 21:11:34,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163966172,https://github.com/hyperledger/burrow/pull/666#discussion_r163966172,compleatang
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"It's only adds overhead on systems that have 32-bit words, which IOT possibilities aside, is probably not that many. On 64-bit systems it's free.

Also I do not think it's unnecessary - suppose I hammer a chain using the same account as input with 100 txs per block - unusual but perfectly within the realm of load testing - then we run out of int32s in about 8 months. Worse than this is _if_ we have validators running on a mix of 32-bit and 64-bit architectures the 32-bit ones will die while the 64-bit ones won't. By forcing this as uint64 then we have parity across architectures - and the overhead is really minimal, just space not time really because we do minimal arithmetic on these. So I think this make sense right now, even if we don't _need_ it for height (even then - simulating a long-running chain - the disparity between archs is not nice)",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-25 21:31:17,163973444,"@@ -41,64 +36,319 @@ func SignBytes(chainID string, o Signable) []byte {
 	buf, n, err := new(bytes.Buffer), new(int), new(error)
 	o.WriteSignBytes(chainID, buf, n, err)
 	if *err != nil {
-		sanity.PanicCrisis(err)
+		panic(fmt.Sprintf(""could not write sign bytes for a signable: %s"", *err))
 	}
-
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64",,2018-01-25 21:31:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163973444,https://github.com/hyperledger/burrow/pull/666#discussion_r163973444,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"yeah, there were actually quite a few inherited panics that I've remove in this batch of changes - not quite sure why I kept them. This one I added myself - I guess a kind of 'bar' was set - so good you challenged on this.",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-25 21:33:00,163973918,"@@ -284,22 +278,22 @@ func (caw concreteAccountWrapper) SetPublicKey(pubKey PublicKey) MutableAccount
 	return caw
 }
 
-func (caw concreteAccountWrapper) SubtractFromBalance(amount uint64) MutableAccount {
+func (caw concreteAccountWrapper) SubtractFromBalance(amount uint64) (MutableAccount, error) {
 	if amount > caw.Balance() {
-		panic(fmt.Errorf(""insufficient funds: attempt to subtract %v from the balance of %s"",
-			amount, caw.ConcreteAccount))
+		return nil, fmt.Errorf(""insufficient funds: attempt to subtract %v from the balance of %s"",
+			amount, caw.ConcreteAccount)",,2018-01-25 21:33:00,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163973918,https://github.com/hyperledger/burrow/pull/666#discussion_r163973918,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"No sure where we will end up with go-crypto... I think the aim will be to make it increasingly replaceable, but it may be that it does most of what we want. There's a few things it does I find a bit dubious, but we'll see...",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-25 21:41:57,163976153,"@@ -0,0 +1,235 @@
+package account
+
+import (
+	""bytes""
+	""crypto/rand""
+	""crypto/sha256""
+	""fmt""
+	""io""
+
+	""github.com/tendermint/go-crypto""
+	""golang.org/x/crypto/ed25519""",11,2018-01-25 21:41:57,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163976153,https://github.com/hyperledger/burrow/pull/666#discussion_r163976153,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"I think they issue you may have stumbled upon, and I haven't found a good workaround yet, is that we are using Go.",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-25 21:42:45,163976354,"@@ -781,7 +799,10 @@ func (exe *executor) Execute(tx txs.Tx) error {
 
 		// Good!
 		inAcc.IncSequence()
-		inAcc.SubtractFromBalance(value)
+		inAcc, err = inAcc.SubtractFromBalance(value)
+		if err != nil {
+			return err
+		}",,2018-01-25 21:42:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163976354,https://github.com/hyperledger/burrow/pull/666#discussion_r163976354,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,😢 ,0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-25 21:43:22,163976518,"@@ -1,324 +0,0 @@
-// Copyright 2017 Monax Industries Limited
-//
-// Licensed under the Apache License, Version 2.0 (the ""License"");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an ""AS IS"" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package genesis
-
-import (
-	""bytes""
-	""encoding/csv""
-	""encoding/hex""
-	""encoding/json""
-	""fmt""
-	""os""
-	""strconv""
-	""time""
-
-	acm ""github.com/hyperledger/burrow/account""
-	""github.com/hyperledger/burrow/permission""
-	ptypes ""github.com/hyperledger/burrow/permission/types""
-	""github.com/hyperledger/burrow/util""
-	""github.com/tendermint/go-crypto""
-	wire ""github.com/tendermint/go-wire""
-)
-
-const (
-	PublicKeyEd25519ByteLength   int = 32
-	PublicKeySecp256k1ByteLength int = 64
-)
-
-// NewGenesisAccount returns a new Account
-func NewGenesisAccount(address acm.Address, amount uint64, name string,
-	permissions *ptypes.AccountPermissions) *Account {
-	return &Account{
-		BasicAccount: BasicAccount{
-			Address: address,
-			Amount:  amount,
-		},
-		Name:        name,
-		Permissions: permissions.Clone(),
-	}
-}
-
-func NewGenesisValidator(amount uint64, name string, unbondToAddress acm.Address,
-	unbondAmount uint64, keyType string, publicKeyBytes []byte) (*Validator, error) {
-	// convert the key bytes into a typed fixed size byte array
-	var typedPublicKeyBytes []byte
-	switch keyType {
-	case ""ed25519"": // ed25519 has type byte 0x01
-		// TODO: [ben] functionality and checks need to be inherit in the type
-		if len(publicKeyBytes) != PublicKeyEd25519ByteLength {
-			return nil, fmt.Errorf(""Invalid length provided for ed25519 public key (%v bytes provided but expected %v bytes)"",
-				len(publicKeyBytes), PublicKeyEd25519ByteLength)
-		}
-		// prepend type byte to public key
-		typedPublicKeyBytes = append([]byte{crypto.TypeEd25519}, publicKeyBytes...)
-	case ""secp256k1"": // secp256k1 has type byte 0x02
-		if len(publicKeyBytes) != PublicKeySecp256k1ByteLength {
-			return nil, fmt.Errorf(""Invalid length provided for secp256k1 public key (%v bytes provided but expected %v bytes)"",
-				len(publicKeyBytes), PublicKeySecp256k1ByteLength)
-		}
-		// prepend type byte to public key
-		typedPublicKeyBytes = append([]byte{crypto.TypeSecp256k1}, publicKeyBytes...)
-	default:
-		return nil, fmt.Errorf(""Unsupported key type (%s)"", keyType)
-	}
-	newPubKey, err := crypto.PubKeyFromBytes(typedPublicKeyBytes)
-	if err != nil {
-		return nil, err
-	}
-	// ability to unbond to multiple accounts currently unused
-	var unbondTo []BasicAccount
-
-	address, err := acm.AddressFromBytes(newPubKey.Address())
-	if err != nil {
-		return nil, err
-	}
-	return &Validator{
-		BasicAccount: BasicAccount{
-			Address:   address,
-			PublicKey: acm.PublicKeyFromPubKey(newPubKey),
-			Amount:    amount,
-		},
-		Name: name,
-		UnbondTo: append(unbondTo, BasicAccount{
-			Address: unbondToAddress,
-			Amount:  unbondAmount,
-		}),
-	}, nil
-}
-
-//------------------------------------------------------------------------------------
-// interface functions that are consumed by monax tooling
-
-func GenerateKnown(chainName, accountsPathCSV, validatorsPathCSV string) (string, error) {
-	return generateKnownWithTime(chainName, accountsPathCSV, validatorsPathCSV,
-		// set the timestamp for the genesis
-		time.Now())
-}
-
-//------------------------------------------------------------------------------------
-// interface functions that are consumed by monax tooling
-
-func GenerateGenesisFileBytes(chainName string, salt []byte, genesisTime time.Time, genesisAccounts map[string]acm.Account,
-	genesisValidators map[string]acm.Validator) ([]byte, error) {
-
-	genesisDoc := MakeGenesisDocFromAccounts(chainName, salt, genesisTime, genesisAccounts, genesisValidators)
-
-	var err error
-	buf, buf2, n := new(bytes.Buffer), new(bytes.Buffer), new(int)
-	wire.WriteJSON(genesisDoc, buf, n, &err)
-	if err != nil {
-		return nil, err
-	}
-	if err := json.Indent(buf2, buf.Bytes(), """", ""\t""); err != nil {
-		return nil, err
-	}
-
-	return buf2.Bytes(), nil
-}
-
-//------------------------------------------------------------------------------------
-// core functions that provide functionality for monax tooling in v0.16
-
-// GenerateKnownWithTime takes chainName, an accounts and validators CSV filepath
-// and a timestamp to generate the string of `genesis.json`
-// NOTE: [ben] is introduced as technical debt to preserve the signature
-// of GenerateKnown but in order to introduce the timestamp gradually
-// This will be deprecated in v0.17
-func generateKnownWithTime(chainName, accountsPathCSV, validatorsPathCSV string,
-	genesisTime time.Time) (string, error) {
-	var genDoc *GenesisDoc
-
-	// TODO [eb] eliminate reading priv_val ... [zr] where?
-	if accountsPathCSV == """" || validatorsPathCSV == """" {
-		return """", fmt.Errorf(""both accounts.csv and validators.csv is required"")
-	}
-
-	pubkeys, amts, names, perms, setbits, err := parseCsv(validatorsPathCSV)
-	if err != nil {
-		return """", err
-	}
-
-	pubkeysA, amtsA, namesA, permsA, setbitsA, err := parseCsv(accountsPathCSV)
-	if err != nil {
-		return """", err
-	}
-
-	genDoc = newGenDoc(chainName, genesisTime, len(pubkeys), len(pubkeysA))
-	for i, pk := range pubkeys {
-		genDocAddValidator(genDoc, pk, amts[i], names[i], perms[i], setbits[i], i)
-	}
-	for i, pk := range pubkeysA {
-		genDocAddAccount(genDoc, pk, amtsA[i], namesA[i], permsA[i], setbitsA[i], i)
-	}
-
-	buf, buf2, n := new(bytes.Buffer), new(bytes.Buffer), new(int)
-	wire.WriteJSON(genDoc, buf, n, &err)
-	if err != nil {
-		return """", err
-	}
-	if err := json.Indent(buf2, buf.Bytes(), """", ""\t""); err != nil {
-		return """", err
-	}
-
-	return buf2.String(), nil
-}
-
-//-----------------------------------------------------------------------------
-// gendoc convenience functions
-
-func newGenDoc(chainName string, genesisTime time.Time, nVal, nAcc int) *GenesisDoc {
-	genDoc := GenesisDoc{
-		ChainName:   chainName,
-		GenesisTime: genesisTime,
-	}
-	genDoc.Accounts = make([]Account, nAcc)
-	genDoc.Validators = make([]Validator, nVal)
-	return &genDoc
-}
-
-func genDocAddAccount(genDoc *GenesisDoc, pubKey crypto.PubKeyEd25519, amt uint64, name string,
-	perm, setbit ptypes.PermFlag, index int) {
-	addr, _ := acm.AddressFromBytes(pubKey.Address())
-	acc := Account{
-		BasicAccount: BasicAccount{
-			Address: addr,
-			Amount:  amt,
-		},
-		Name: name,
-		Permissions: ptypes.AccountPermissions{
-			Base: ptypes.BasePermissions{
-				Perms:  perm,
-				SetBit: setbit,
-			},
-		},
-	}
-	if index < 0 {
-		genDoc.Accounts = append(genDoc.Accounts, acc)
-	} else {
-		genDoc.Accounts[index] = acc
-	}
-}
-
-func genDocAddValidator(genDoc *GenesisDoc, pubKey crypto.PubKeyEd25519, amt uint64, name string,
-	perm, setbit ptypes.PermFlag, index int) {
-	addr, _ := acm.AddressFromBytes(pubKey.Address())
-	genDoc.Validators[index] = Validator{
-		BasicAccount: BasicAccount{
-			Address:   acm.MustAddressFromBytes(pubKey.Address()),
-			PublicKey: acm.PublicKeyFromPubKey(pubKey.Wrap()),
-			Amount:    amt,
-		},
-		Name: name,
-		UnbondTo: []BasicAccount{
-			{
-				Address: addr,
-				Amount:  amt,
-			},
-		},
-	}
-	// [zr] why no index < 0 like in genDocAddAccount?
-}
-
-//-----------------------------------------------------------------------------
-// util functions
-
-// convert hex strings to ed25519 pubkeys
-func pubKeyStringsToPubKeys(pubkeys []string) ([]crypto.PubKeyEd25519, error) {
-	pubKeys := make([]crypto.PubKeyEd25519, len(pubkeys))
-	for i, k := range pubkeys {
-		pubBytes, err := hex.DecodeString(k)
-		if err != nil {
-			return pubKeys, err
-		}
-		copy(pubKeys[i][:], pubBytes)
-	}
-	return pubKeys, nil
-}
-
-// empty is over written
-func ifExistsElse(list []string, index int, defaultValue string) string {
-	if len(list) > index {
-		if list[index] != """" {
-			return list[index]
-		}
-	}
-	return defaultValue
-}
-
-// takes a csv in the following format: pubkey, starting balance, name, permissions, setbit
-func parseCsv(filePath string) (pubKeys []crypto.PubKeyEd25519, amts []uint64, names []string, perms, setbits []ptypes.PermFlag, err error) {
-
-	csvFile, err := os.Open(filePath)
-	if err != nil {
-		util.Fatalf(""Couldn't open file: %s: %v"", filePath, err)
-	}
-	defer csvFile.Close()
-
-	r := csv.NewReader(csvFile)
-	//r.FieldsPerRecord = # of records expected
-	params, err := r.ReadAll()
-	if err != nil {
-		util.Fatalf(""Couldn't read file: %v"", err)
-
-	}
-
-	pubkeys := make([]string, len(params))
-	amtS := make([]string, len(params))
-	names = make([]string, len(params))
-	permsS := make([]string, len(params))
-	setbitS := make([]string, len(params))
-	for i, each := range params {
-		pubkeys[i] = each[0]
-		amtS[i] = ifExistsElse(each, 1, ""1000"")
-		names[i] = ifExistsElse(each, 2, """")
-		permsS[i] = ifExistsElse(each, 3, fmt.Sprintf(""%d"", permission.DefaultPermFlags))
-		setbitS[i] = ifExistsElse(each, 4, permsS[i])
-	}
-
-	//TODO convert int to uint64, see issue #25
-	perms = make([]ptypes.PermFlag, len(permsS))
-	for i, perm := range permsS {
-		pflag, err := strconv.Atoi(perm)
-		if err != nil {
-			util.Fatalf(""Permissions (%v) must be an integer"", perm)
-		}
-		perms[i] = ptypes.PermFlag(pflag)
-	}
-	setbits = make([]ptypes.PermFlag, len(setbitS))
-	for i, setbit := range setbitS {
-		setbitsFlag, err := strconv.Atoi(setbit)
-		if err != nil {
-			util.Fatalf(""SetBits (%v) must be an integer"", setbit)
-		}
-		setbits[i] = ptypes.PermFlag(setbitsFlag)
-	}
-
-	// convert amts to ints
-	amts = make([]uint64, len(amtS))
-	for i, a := range amtS {
-		if amts[i], err = strconv.ParseUint(a, 10, 64); err != nil {
-			err = fmt.Errorf(""Invalid amount: %v"", err)
-			return
-		}
-	}
-
-	// convert pubkey hex strings to struct
-	pubKeys, err = pubKeyStringsToPubKeys(pubkeys)
-	if err != nil {
-		return
-	}
-
-	return pubKeys, amts, names, perms, setbits, nil
-}",,2018-01-25 21:43:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/163976518,https://github.com/hyperledger/burrow/pull/666#discussion_r163976518,silasdavis
https://github.com/hyperledger/burrow/pull/666,https://github.com/hyperledger/burrow/pull/666,"Cool.
",0c24967776071ed8d264c6891c9433bfe93f08c7,2018-01-26 11:33:48,164090368,"@@ -0,0 +1,98 @@
+package genesis
+
+import (
+	""math/rand""
+	""time""
+
+	""fmt""
+
+	acm ""github.com/hyperledger/burrow/account""
+	""github.com/hyperledger/burrow/permission""
+	""github.com/tendermint/ed25519""
+	""github.com/tendermint/go-crypto""
+)
+
+type deterministicGenesis struct {
+	random *rand.Rand
+}
+
+// Generates deterministic pseudo-random genesis state
+func NewDeterministicGenesis(seed int64) *deterministicGenesis {
+	return &deterministicGenesis{
+		random: rand.New(rand.NewSource(seed)),
+	}
+}
+
+func (dg *deterministicGenesis) GenesisDoc(numAccounts int, randBalance bool, minBalance uint64, numValidators int,
+	randBonded bool, minBonded int64) (*GenesisDoc, []acm.PrivateAccount) {
+
+	accounts := make([]Account, numAccounts)
+	privAccounts := make([]acm.PrivateAccount, numAccounts)
+	defaultPerms := permission.DefaultAccountPermissions
+	for i := 0; i < numAccounts; i++ {
+		account, privAccount := dg.Account(randBalance, minBalance)",30,2018-01-26 11:33:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/164090368,https://github.com/hyperledger/burrow/pull/666#discussion_r164090368,compleatang
https://github.com/hyperledger/burrow/pull/657,https://github.com/hyperledger/burrow/pull/657,"Like we talked about, not sure doing this registration here is a good pattern because it is burying how this library is used. Although I might buy the argument that placing it close to the types it is interacting with is a good idea.",e47400687ea4e65984311c4fea58834ea6993184,2017-12-05 19:26:23,155051315,"@@ -45,58 +41,335 @@ func SignBytes(chainID string, o Signable) []byte {
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
 }
 
-func (acc *Account) Copy() *Account {
-	accCopy := *acc
-	return &accCopy
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {
+	Address     Address
+	PublicKey   PublicKey
+	Balance     uint64
+	Code        Bytecode
+	Sequence    uint64
+	StorageRoot []byte
+	Permissions ptypes.AccountPermissions
 }
 
-func (acc *Account) String() string {
-	if acc == nil {
-		return ""nil-Account""
+func NewConcreteAccount(pubKey PublicKey) ConcreteAccount {
+	return ConcreteAccount{
+		Address:   MustAddressFromBytes(pubKey.Address()),
+		PublicKey: pubKey,
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
 	}
-	return fmt.Sprintf(""Account{%X:%v B:%v C:%v S:%X P:%s}"", acc.Address, acc.PubKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
 }
 
-func AccountEncoder(o interface{}, w io.Writer, n *int, err *error) {
-	wire.WriteBinary(o.(*Account), w, n, err)
+func NewConcreteAccountFromSecret(secret string) ConcreteAccount {
+	return NewConcreteAccount(PublicKeyFromPubKey(PrivateKeyFromSecret(secret).PubKey()))
 }
 
-func AccountDecoder(r io.Reader, n *int, err *error) interface{} {
-	return wire.ReadBinary(&Account{}, r, 0, n, err)
+// Return as immutable Account
+func (acc ConcreteAccount) Account() Account {
+	return concreteAccountWrapper{&acc}
 }
 
-var AccountCodec = wire.Codec{
-	Encode: AccountEncoder,
-	Decode: AccountDecoder,
+// Return as mutable MutableACCount
+func (acc ConcreteAccount) MutableAccount() MutableAccount {
+	return concreteAccountWrapper{&acc}
 }
 
-func EncodeAccount(acc *Account) []byte {
+func (acc *ConcreteAccount) Encode() []byte {
 	w := new(bytes.Buffer)
 	var n int
 	var err error
 	AccountEncoder(acc, w, &n, &err)
 	return w.Bytes()
 }
 
-func DecodeAccount(accBytes []byte) *Account {
+func (acc *ConcreteAccount) Copy() *ConcreteAccount {
+	accCopy := *acc
+	return &accCopy
+}
+
+func (acc *ConcreteAccount) String() string {
+	if acc == nil {
+		return ""Account{nil}""
+	}
+
+	return fmt.Sprintf(""Account{Address: %s; PublicKey: %v Balance: %v; CodeBytes: %v; StorageRoot: 0x%X; Permissions: %s}"",
+		acc.Address, acc.PublicKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
+}
+
+// ConcreteAccount
+// -------------------------------------------------
+// Conversions
+//
+// Using the naming convention is this package of 'As<Type>' being
+// a conversion from Account to <Type> and 'From<Type>' being conversion
+// from <Type> to Account. Conversions are done by copying
+
+// Returns a mutable, serialisable ConcreteAccount by copying from account
+func AsConcreteAccount(account Account) *ConcreteAccount {
+	if account == nil {
+		return nil
+	}
+	if ca, ok := account.(concreteAccountWrapper); ok {
+		return ca.ConcreteAccount
+	}
+	return &ConcreteAccount{
+		Address:     account.Address(),
+		PublicKey:   account.PublicKey(),
+		Balance:     account.Balance(),
+		Code:        account.Code(),
+		Sequence:    account.Sequence(),
+		StorageRoot: account.StorageRoot(),
+		Permissions: account.Permissions(),
+	}
+}
+
+// Creates an otherwise zeroed Account from an Addressable and returns it as MutableAccount
+func FromAddressable(addressable Addressable) MutableAccount {
+	return ConcreteAccount{
+		Address:   addressable.Address(),
+		PublicKey: addressable.PublicKey(),
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
+	}.MutableAccount()
+}
+
+// Returns an immutable account by copying from account
+func AsAccount(account Account) Account {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).Account()
+}
+
+// Returns a MutableAccount by copying from account
+func AsMutableAccount(account Account) MutableAccount {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).MutableAccount()
+}
+
+func GetMutableAccount(getter Getter, address Address) (MutableAccount, error) {
+	acc, err := getter.GetAccount(address)
+	if err != nil {
+		return nil, err
+	}
+	// If we get get our own concreteAccountWrapper back we can save an unnecessary copy and just
+	// return since ConcreteAccount.Account() will have been used to produce it which will already
+	// have copied
+	caw, ok := acc.(concreteAccountWrapper)
+	if ok {
+		return caw, nil
+	}
+	return AsMutableAccount(acc), nil
+}
+
+//----------------------------------------------
+// concreteAccount Wrapper
+
+// concreteAccountWrapper wraps ConcreteAccount to provide a immutable read-only view
+// via its implementation of Account and a mutable implementation via its implementation of
+// MutableAccount
+type concreteAccountWrapper struct {
+	*ConcreteAccount `json:""unwrap""`
+}
+
+var _ = wire.RegisterInterface(struct{ Account }{}, wire.ConcreteType{concreteAccountWrapper{}, 0x01})",,2017-12-18 15:57:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/155051315,https://github.com/hyperledger/burrow/pull/657#discussion_r155051315,aludvik
https://github.com/hyperledger/burrow/pull/657,https://github.com/hyperledger/burrow/pull/657,"Seems odd that you need a wrapper class around this, but from our offline conversation I understand that it is related to how serialization is performed. IMO it would be better if `ConcreteAccount` had private instance variables that could be serialized.",e47400687ea4e65984311c4fea58834ea6993184,2017-12-05 19:35:25,155053658,"@@ -45,58 +41,335 @@ func SignBytes(chainID string, o Signable) []byte {
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
 }
 
-func (acc *Account) Copy() *Account {
-	accCopy := *acc
-	return &accCopy
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {
+	Address     Address
+	PublicKey   PublicKey
+	Balance     uint64
+	Code        Bytecode
+	Sequence    uint64
+	StorageRoot []byte
+	Permissions ptypes.AccountPermissions
 }
 
-func (acc *Account) String() string {
-	if acc == nil {
-		return ""nil-Account""
+func NewConcreteAccount(pubKey PublicKey) ConcreteAccount {
+	return ConcreteAccount{
+		Address:   MustAddressFromBytes(pubKey.Address()),
+		PublicKey: pubKey,
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
 	}
-	return fmt.Sprintf(""Account{%X:%v B:%v C:%v S:%X P:%s}"", acc.Address, acc.PubKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
 }
 
-func AccountEncoder(o interface{}, w io.Writer, n *int, err *error) {
-	wire.WriteBinary(o.(*Account), w, n, err)
+func NewConcreteAccountFromSecret(secret string) ConcreteAccount {
+	return NewConcreteAccount(PublicKeyFromPubKey(PrivateKeyFromSecret(secret).PubKey()))
 }
 
-func AccountDecoder(r io.Reader, n *int, err *error) interface{} {
-	return wire.ReadBinary(&Account{}, r, 0, n, err)
+// Return as immutable Account
+func (acc ConcreteAccount) Account() Account {
+	return concreteAccountWrapper{&acc}
 }
 
-var AccountCodec = wire.Codec{
-	Encode: AccountEncoder,
-	Decode: AccountDecoder,
+// Return as mutable MutableACCount
+func (acc ConcreteAccount) MutableAccount() MutableAccount {
+	return concreteAccountWrapper{&acc}
 }
 
-func EncodeAccount(acc *Account) []byte {
+func (acc *ConcreteAccount) Encode() []byte {
 	w := new(bytes.Buffer)
 	var n int
 	var err error
 	AccountEncoder(acc, w, &n, &err)
 	return w.Bytes()
 }
 
-func DecodeAccount(accBytes []byte) *Account {
+func (acc *ConcreteAccount) Copy() *ConcreteAccount {
+	accCopy := *acc
+	return &accCopy
+}
+
+func (acc *ConcreteAccount) String() string {
+	if acc == nil {
+		return ""Account{nil}""
+	}
+
+	return fmt.Sprintf(""Account{Address: %s; PublicKey: %v Balance: %v; CodeBytes: %v; StorageRoot: 0x%X; Permissions: %s}"",
+		acc.Address, acc.PublicKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
+}
+
+// ConcreteAccount
+// -------------------------------------------------
+// Conversions
+//
+// Using the naming convention is this package of 'As<Type>' being
+// a conversion from Account to <Type> and 'From<Type>' being conversion
+// from <Type> to Account. Conversions are done by copying
+
+// Returns a mutable, serialisable ConcreteAccount by copying from account
+func AsConcreteAccount(account Account) *ConcreteAccount {
+	if account == nil {
+		return nil
+	}
+	if ca, ok := account.(concreteAccountWrapper); ok {
+		return ca.ConcreteAccount
+	}
+	return &ConcreteAccount{
+		Address:     account.Address(),
+		PublicKey:   account.PublicKey(),
+		Balance:     account.Balance(),
+		Code:        account.Code(),
+		Sequence:    account.Sequence(),
+		StorageRoot: account.StorageRoot(),
+		Permissions: account.Permissions(),
+	}
+}
+
+// Creates an otherwise zeroed Account from an Addressable and returns it as MutableAccount
+func FromAddressable(addressable Addressable) MutableAccount {
+	return ConcreteAccount{
+		Address:   addressable.Address(),
+		PublicKey: addressable.PublicKey(),
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
+	}.MutableAccount()
+}
+
+// Returns an immutable account by copying from account
+func AsAccount(account Account) Account {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).Account()
+}
+
+// Returns a MutableAccount by copying from account
+func AsMutableAccount(account Account) MutableAccount {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).MutableAccount()
+}
+
+func GetMutableAccount(getter Getter, address Address) (MutableAccount, error) {
+	acc, err := getter.GetAccount(address)
+	if err != nil {
+		return nil, err
+	}
+	// If we get get our own concreteAccountWrapper back we can save an unnecessary copy and just
+	// return since ConcreteAccount.Account() will have been used to produce it which will already
+	// have copied
+	caw, ok := acc.(concreteAccountWrapper)
+	if ok {
+		return caw, nil
+	}
+	return AsMutableAccount(acc), nil
+}
+
+//----------------------------------------------
+// concreteAccount Wrapper
+
+// concreteAccountWrapper wraps ConcreteAccount to provide a immutable read-only view
+// via its implementation of Account and a mutable implementation via its implementation of
+// MutableAccount
+type concreteAccountWrapper struct {",226,2017-12-18 15:57:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/155053658,https://github.com/hyperledger/burrow/pull/657#discussion_r155053658,aludvik
https://github.com/hyperledger/burrow/pull/657,https://github.com/hyperledger/burrow/pull/657,Is this just a compile time check and hint to people reading the source that this implements the given interface?,e47400687ea4e65984311c4fea58834ea6993184,2017-12-05 19:36:24,155053923,"@@ -45,58 +41,335 @@ func SignBytes(chainID string, o Signable) []byte {
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
 }
 
-func (acc *Account) Copy() *Account {
-	accCopy := *acc
-	return &accCopy
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {
+	Address     Address
+	PublicKey   PublicKey
+	Balance     uint64
+	Code        Bytecode
+	Sequence    uint64
+	StorageRoot []byte
+	Permissions ptypes.AccountPermissions
 }
 
-func (acc *Account) String() string {
-	if acc == nil {
-		return ""nil-Account""
+func NewConcreteAccount(pubKey PublicKey) ConcreteAccount {
+	return ConcreteAccount{
+		Address:   MustAddressFromBytes(pubKey.Address()),
+		PublicKey: pubKey,
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
 	}
-	return fmt.Sprintf(""Account{%X:%v B:%v C:%v S:%X P:%s}"", acc.Address, acc.PubKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
 }
 
-func AccountEncoder(o interface{}, w io.Writer, n *int, err *error) {
-	wire.WriteBinary(o.(*Account), w, n, err)
+func NewConcreteAccountFromSecret(secret string) ConcreteAccount {
+	return NewConcreteAccount(PublicKeyFromPubKey(PrivateKeyFromSecret(secret).PubKey()))
 }
 
-func AccountDecoder(r io.Reader, n *int, err *error) interface{} {
-	return wire.ReadBinary(&Account{}, r, 0, n, err)
+// Return as immutable Account
+func (acc ConcreteAccount) Account() Account {
+	return concreteAccountWrapper{&acc}
 }
 
-var AccountCodec = wire.Codec{
-	Encode: AccountEncoder,
-	Decode: AccountDecoder,
+// Return as mutable MutableACCount
+func (acc ConcreteAccount) MutableAccount() MutableAccount {
+	return concreteAccountWrapper{&acc}
 }
 
-func EncodeAccount(acc *Account) []byte {
+func (acc *ConcreteAccount) Encode() []byte {
 	w := new(bytes.Buffer)
 	var n int
 	var err error
 	AccountEncoder(acc, w, &n, &err)
 	return w.Bytes()
 }
 
-func DecodeAccount(accBytes []byte) *Account {
+func (acc *ConcreteAccount) Copy() *ConcreteAccount {
+	accCopy := *acc
+	return &accCopy
+}
+
+func (acc *ConcreteAccount) String() string {
+	if acc == nil {
+		return ""Account{nil}""
+	}
+
+	return fmt.Sprintf(""Account{Address: %s; PublicKey: %v Balance: %v; CodeBytes: %v; StorageRoot: 0x%X; Permissions: %s}"",
+		acc.Address, acc.PublicKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
+}
+
+// ConcreteAccount
+// -------------------------------------------------
+// Conversions
+//
+// Using the naming convention is this package of 'As<Type>' being
+// a conversion from Account to <Type> and 'From<Type>' being conversion
+// from <Type> to Account. Conversions are done by copying
+
+// Returns a mutable, serialisable ConcreteAccount by copying from account
+func AsConcreteAccount(account Account) *ConcreteAccount {
+	if account == nil {
+		return nil
+	}
+	if ca, ok := account.(concreteAccountWrapper); ok {
+		return ca.ConcreteAccount
+	}
+	return &ConcreteAccount{
+		Address:     account.Address(),
+		PublicKey:   account.PublicKey(),
+		Balance:     account.Balance(),
+		Code:        account.Code(),
+		Sequence:    account.Sequence(),
+		StorageRoot: account.StorageRoot(),
+		Permissions: account.Permissions(),
+	}
+}
+
+// Creates an otherwise zeroed Account from an Addressable and returns it as MutableAccount
+func FromAddressable(addressable Addressable) MutableAccount {
+	return ConcreteAccount{
+		Address:   addressable.Address(),
+		PublicKey: addressable.PublicKey(),
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
+	}.MutableAccount()
+}
+
+// Returns an immutable account by copying from account
+func AsAccount(account Account) Account {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).Account()
+}
+
+// Returns a MutableAccount by copying from account
+func AsMutableAccount(account Account) MutableAccount {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).MutableAccount()
+}
+
+func GetMutableAccount(getter Getter, address Address) (MutableAccount, error) {
+	acc, err := getter.GetAccount(address)
+	if err != nil {
+		return nil, err
+	}
+	// If we get get our own concreteAccountWrapper back we can save an unnecessary copy and just
+	// return since ConcreteAccount.Account() will have been used to produce it which will already
+	// have copied
+	caw, ok := acc.(concreteAccountWrapper)
+	if ok {
+		return caw, nil
+	}
+	return AsMutableAccount(acc), nil
+}
+
+//----------------------------------------------
+// concreteAccount Wrapper
+
+// concreteAccountWrapper wraps ConcreteAccount to provide a immutable read-only view
+// via its implementation of Account and a mutable implementation via its implementation of
+// MutableAccount
+type concreteAccountWrapper struct {
+	*ConcreteAccount `json:""unwrap""`
+}
+
+var _ = wire.RegisterInterface(struct{ Account }{}, wire.ConcreteType{concreteAccountWrapper{}, 0x01})
+
+var _ Account = concreteAccountWrapper{}
+
+func (caw concreteAccountWrapper) Address() Address {
+	return caw.ConcreteAccount.Address
+}
+
+func (caw concreteAccountWrapper) PublicKey() PublicKey {
+	return caw.ConcreteAccount.PublicKey
+}
+
+func (caw concreteAccountWrapper) Balance() uint64 {
+	return caw.ConcreteAccount.Balance
+}
+
+func (caw concreteAccountWrapper) Code() Bytecode {
+	return caw.ConcreteAccount.Code
+}
+
+func (caw concreteAccountWrapper) Sequence() uint64 {
+	return caw.ConcreteAccount.Sequence
+}
+
+func (caw concreteAccountWrapper) StorageRoot() []byte {
+	return caw.ConcreteAccount.StorageRoot
+}
+
+func (caw concreteAccountWrapper) Permissions() ptypes.AccountPermissions {
+	return caw.ConcreteAccount.Permissions
+}
+
+func (caw concreteAccountWrapper) Encode() []byte {
+	return caw.ConcreteAccount.Encode()
+}
+
+func (caw concreteAccountWrapper) MarshalJSON() ([]byte, error) {
+	return json.Marshal(caw.ConcreteAccount)
+}
+
+// Account mutation via MutableAccount interface
+var _ MutableAccount = concreteAccountWrapper{}",269,2017-12-18 15:57:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/155053923,https://github.com/hyperledger/burrow/pull/657#discussion_r155053923,aludvik
https://github.com/hyperledger/burrow/pull/657,https://github.com/hyperledger/burrow/pull/657,"I don't love the name `ConcreteAccount`. If the intention is for `Account` to be a true interface that can later be replaced by another implementation, `BurrowAccount` would seem like a better name. Then if other projects want to depend on Burrow, but replace the implementation, they could define `FabricAccount` or `SawtoothAccount` instead of `AnotherConcreteAccount` or something.",e47400687ea4e65984311c4fea58834ea6993184,2017-12-05 19:39:12,155054673,"@@ -45,58 +41,335 @@ func SignBytes(chainID string, o Signable) []byte {
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
 }
 
-func (acc *Account) Copy() *Account {
-	accCopy := *acc
-	return &accCopy
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {",79,2017-12-18 15:57:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/155054673,https://github.com/hyperledger/burrow/pull/657#discussion_r155054673,aludvik
https://github.com/hyperledger/burrow/pull/657,https://github.com/hyperledger/burrow/pull/657,typo: `s/MutableACCount/MutableAccount/`,e47400687ea4e65984311c4fea58834ea6993184,2017-12-05 19:40:54,155055103,"@@ -45,58 +41,335 @@ func SignBytes(chainID string, o Signable) []byte {
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
 }
 
-func (acc *Account) Copy() *Account {
-	accCopy := *acc
-	return &accCopy
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {
+	Address     Address
+	PublicKey   PublicKey
+	Balance     uint64
+	Code        Bytecode
+	Sequence    uint64
+	StorageRoot []byte
+	Permissions ptypes.AccountPermissions
 }
 
-func (acc *Account) String() string {
-	if acc == nil {
-		return ""nil-Account""
+func NewConcreteAccount(pubKey PublicKey) ConcreteAccount {
+	return ConcreteAccount{
+		Address:   MustAddressFromBytes(pubKey.Address()),
+		PublicKey: pubKey,
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
 	}
-	return fmt.Sprintf(""Account{%X:%v B:%v C:%v S:%X P:%s}"", acc.Address, acc.PubKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
 }
 
-func AccountEncoder(o interface{}, w io.Writer, n *int, err *error) {
-	wire.WriteBinary(o.(*Account), w, n, err)
+func NewConcreteAccountFromSecret(secret string) ConcreteAccount {
+	return NewConcreteAccount(PublicKeyFromPubKey(PrivateKeyFromSecret(secret).PubKey()))
 }
 
-func AccountDecoder(r io.Reader, n *int, err *error) interface{} {
-	return wire.ReadBinary(&Account{}, r, 0, n, err)
+// Return as immutable Account
+func (acc ConcreteAccount) Account() Account {
+	return concreteAccountWrapper{&acc}
 }
 
-var AccountCodec = wire.Codec{
-	Encode: AccountEncoder,
-	Decode: AccountDecoder,
+// Return as mutable MutableACCount",,2017-12-18 15:57:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/155055103,https://github.com/hyperledger/burrow/pull/657#discussion_r155055103,aludvik
https://github.com/hyperledger/burrow/pull/657,https://github.com/hyperledger/burrow/pull/657,"This will compile if no matter what you pass `AccountEncoder`, but will panic at runtime if it is anything but a `*ConcreteAccount`.",e47400687ea4e65984311c4fea58834ea6993184,2017-12-05 19:48:28,155057050,"@@ -45,58 +41,335 @@ func SignBytes(chainID string, o Signable) []byte {
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
 }
 
-func (acc *Account) Copy() *Account {
-	accCopy := *acc
-	return &accCopy
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {
+	Address     Address
+	PublicKey   PublicKey
+	Balance     uint64
+	Code        Bytecode
+	Sequence    uint64
+	StorageRoot []byte
+	Permissions ptypes.AccountPermissions
 }
 
-func (acc *Account) String() string {
-	if acc == nil {
-		return ""nil-Account""
+func NewConcreteAccount(pubKey PublicKey) ConcreteAccount {
+	return ConcreteAccount{
+		Address:   MustAddressFromBytes(pubKey.Address()),
+		PublicKey: pubKey,
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
 	}
-	return fmt.Sprintf(""Account{%X:%v B:%v C:%v S:%X P:%s}"", acc.Address, acc.PubKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
 }
 
-func AccountEncoder(o interface{}, w io.Writer, n *int, err *error) {
-	wire.WriteBinary(o.(*Account), w, n, err)
+func NewConcreteAccountFromSecret(secret string) ConcreteAccount {
+	return NewConcreteAccount(PublicKeyFromPubKey(PrivateKeyFromSecret(secret).PubKey()))
 }
 
-func AccountDecoder(r io.Reader, n *int, err *error) interface{} {
-	return wire.ReadBinary(&Account{}, r, 0, n, err)
+// Return as immutable Account
+func (acc ConcreteAccount) Account() Account {
+	return concreteAccountWrapper{&acc}
 }
 
-var AccountCodec = wire.Codec{
-	Encode: AccountEncoder,
-	Decode: AccountDecoder,
+// Return as mutable MutableACCount
+func (acc ConcreteAccount) MutableAccount() MutableAccount {
+	return concreteAccountWrapper{&acc}
 }
 
-func EncodeAccount(acc *Account) []byte {
+func (acc *ConcreteAccount) Encode() []byte {
 	w := new(bytes.Buffer)
 	var n int
 	var err error
 	AccountEncoder(acc, w, &n, &err)
 	return w.Bytes()
 }
 
-func DecodeAccount(accBytes []byte) *Account {
+func (acc *ConcreteAccount) Copy() *ConcreteAccount {
+	accCopy := *acc
+	return &accCopy
+}
+
+func (acc *ConcreteAccount) String() string {
+	if acc == nil {
+		return ""Account{nil}""
+	}
+
+	return fmt.Sprintf(""Account{Address: %s; PublicKey: %v Balance: %v; CodeBytes: %v; StorageRoot: 0x%X; Permissions: %s}"",
+		acc.Address, acc.PublicKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
+}
+
+// ConcreteAccount
+// -------------------------------------------------
+// Conversions
+//
+// Using the naming convention is this package of 'As<Type>' being
+// a conversion from Account to <Type> and 'From<Type>' being conversion
+// from <Type> to Account. Conversions are done by copying
+
+// Returns a mutable, serialisable ConcreteAccount by copying from account
+func AsConcreteAccount(account Account) *ConcreteAccount {
+	if account == nil {
+		return nil
+	}
+	if ca, ok := account.(concreteAccountWrapper); ok {
+		return ca.ConcreteAccount
+	}
+	return &ConcreteAccount{
+		Address:     account.Address(),
+		PublicKey:   account.PublicKey(),
+		Balance:     account.Balance(),
+		Code:        account.Code(),
+		Sequence:    account.Sequence(),
+		StorageRoot: account.StorageRoot(),
+		Permissions: account.Permissions(),
+	}
+}
+
+// Creates an otherwise zeroed Account from an Addressable and returns it as MutableAccount
+func FromAddressable(addressable Addressable) MutableAccount {
+	return ConcreteAccount{
+		Address:   addressable.Address(),
+		PublicKey: addressable.PublicKey(),
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
+	}.MutableAccount()
+}
+
+// Returns an immutable account by copying from account
+func AsAccount(account Account) Account {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).Account()
+}
+
+// Returns a MutableAccount by copying from account
+func AsMutableAccount(account Account) MutableAccount {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).MutableAccount()
+}
+
+func GetMutableAccount(getter Getter, address Address) (MutableAccount, error) {
+	acc, err := getter.GetAccount(address)
+	if err != nil {
+		return nil, err
+	}
+	// If we get get our own concreteAccountWrapper back we can save an unnecessary copy and just
+	// return since ConcreteAccount.Account() will have been used to produce it which will already
+	// have copied
+	caw, ok := acc.(concreteAccountWrapper)
+	if ok {
+		return caw, nil
+	}
+	return AsMutableAccount(acc), nil
+}
+
+//----------------------------------------------
+// concreteAccount Wrapper
+
+// concreteAccountWrapper wraps ConcreteAccount to provide a immutable read-only view
+// via its implementation of Account and a mutable implementation via its implementation of
+// MutableAccount
+type concreteAccountWrapper struct {
+	*ConcreteAccount `json:""unwrap""`
+}
+
+var _ = wire.RegisterInterface(struct{ Account }{}, wire.ConcreteType{concreteAccountWrapper{}, 0x01})
+
+var _ Account = concreteAccountWrapper{}
+
+func (caw concreteAccountWrapper) Address() Address {
+	return caw.ConcreteAccount.Address
+}
+
+func (caw concreteAccountWrapper) PublicKey() PublicKey {
+	return caw.ConcreteAccount.PublicKey
+}
+
+func (caw concreteAccountWrapper) Balance() uint64 {
+	return caw.ConcreteAccount.Balance
+}
+
+func (caw concreteAccountWrapper) Code() Bytecode {
+	return caw.ConcreteAccount.Code
+}
+
+func (caw concreteAccountWrapper) Sequence() uint64 {
+	return caw.ConcreteAccount.Sequence
+}
+
+func (caw concreteAccountWrapper) StorageRoot() []byte {
+	return caw.ConcreteAccount.StorageRoot
+}
+
+func (caw concreteAccountWrapper) Permissions() ptypes.AccountPermissions {
+	return caw.ConcreteAccount.Permissions
+}
+
+func (caw concreteAccountWrapper) Encode() []byte {
+	return caw.ConcreteAccount.Encode()
+}
+
+func (caw concreteAccountWrapper) MarshalJSON() ([]byte, error) {
+	return json.Marshal(caw.ConcreteAccount)
+}
+
+// Account mutation via MutableAccount interface
+var _ MutableAccount = concreteAccountWrapper{}
+
+func (caw concreteAccountWrapper) SetPublicKey(pubKey PublicKey) MutableAccount {
+	caw.ConcreteAccount.PublicKey = pubKey
+	addressFromPubKey, err := AddressFromBytes(pubKey.Address())
+	if err != nil {
+		// We rely on this working in all over the place so shouldn't happen
+		panic(fmt.Errorf(""could not obtain address from public key: %v"", pubKey))
+	}
+	// We don't want the wrong public key to take control of an account so we panic here
+	if caw.ConcreteAccount.Address != addressFromPubKey {
+		panic(fmt.Errorf(""attempt to set public key of account %s to %v, ""+
+			""but that public key has address %s"",
+			caw.ConcreteAccount.Address, pubKey, addressFromPubKey))
+	}
+	return caw
+}
+
+func (caw concreteAccountWrapper) SubtractFromBalance(amount uint64) MutableAccount {
+	if amount > caw.Balance() {
+		panic(fmt.Errorf(""insufficient funds: attempt to subtract %v from the balance of %s"",
+			amount, caw.ConcreteAccount))
+	}
+	caw.ConcreteAccount.Balance -= amount
+	return caw
+}
+
+func (caw concreteAccountWrapper) AddToBalance(amount uint64) MutableAccount {
+	if binary.IsUint64SumOverflow(caw.Balance(), amount) {
+		panic(fmt.Errorf(""uint64 overflow: attempt to add %v to the balance of %s"",
+			amount, caw.ConcreteAccount))
+	}
+	caw.ConcreteAccount.Balance += amount
+	return caw
+}
+
+func (caw concreteAccountWrapper) SetCode(code []byte) MutableAccount {
+	caw.ConcreteAccount.Code = code
+	return caw
+}
+
+func (caw concreteAccountWrapper) IncSequence() MutableAccount {
+	caw.ConcreteAccount.Sequence += 1
+	return caw
+}
+
+func (caw concreteAccountWrapper) SetStorageRoot(storageRoot []byte) MutableAccount {
+	caw.ConcreteAccount.StorageRoot = storageRoot
+	return caw
+}
+
+func (caw concreteAccountWrapper) SetPermissions(permissions ptypes.AccountPermissions) MutableAccount {
+	caw.ConcreteAccount.Permissions = permissions
+	return caw
+}
+
+func (caw concreteAccountWrapper) MutablePermissions() *ptypes.AccountPermissions {
+	return &caw.ConcreteAccount.Permissions
+}
+
+func (caw concreteAccountWrapper) Copy() MutableAccount {
+	return concreteAccountWrapper{caw.ConcreteAccount.Copy()}
+}
+
+// concreteAccount Wrapper
+//----------------------------------------------
+// Encoding/decoding
+
+func AccountEncoder(o interface{}, w io.Writer, n *int, err *error) {
+	wire.WriteBinary(o.(*ConcreteAccount), w, n, err)",,2017-12-18 15:57:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/155057050,https://github.com/hyperledger/burrow/pull/657#discussion_r155057050,aludvik
https://github.com/hyperledger/burrow/pull/657,https://github.com/hyperledger/burrow/pull/657,I think you could use the `Account` interface instead of `interface{}` and then do something like this https://gist.github.com/aludvik/12b816a7026850f24c0f5f64463c2902,e47400687ea4e65984311c4fea58834ea6993184,2017-12-05 20:25:32,155065895,"@@ -45,58 +41,335 @@ func SignBytes(chainID string, o Signable) []byte {
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
 }
 
-func (acc *Account) Copy() *Account {
-	accCopy := *acc
-	return &accCopy
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {
+	Address     Address
+	PublicKey   PublicKey
+	Balance     uint64
+	Code        Bytecode
+	Sequence    uint64
+	StorageRoot []byte
+	Permissions ptypes.AccountPermissions
 }
 
-func (acc *Account) String() string {
-	if acc == nil {
-		return ""nil-Account""
+func NewConcreteAccount(pubKey PublicKey) ConcreteAccount {
+	return ConcreteAccount{
+		Address:   MustAddressFromBytes(pubKey.Address()),
+		PublicKey: pubKey,
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
 	}
-	return fmt.Sprintf(""Account{%X:%v B:%v C:%v S:%X P:%s}"", acc.Address, acc.PubKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
 }
 
-func AccountEncoder(o interface{}, w io.Writer, n *int, err *error) {
-	wire.WriteBinary(o.(*Account), w, n, err)
+func NewConcreteAccountFromSecret(secret string) ConcreteAccount {
+	return NewConcreteAccount(PublicKeyFromPubKey(PrivateKeyFromSecret(secret).PubKey()))
 }
 
-func AccountDecoder(r io.Reader, n *int, err *error) interface{} {
-	return wire.ReadBinary(&Account{}, r, 0, n, err)
+// Return as immutable Account
+func (acc ConcreteAccount) Account() Account {
+	return concreteAccountWrapper{&acc}
 }
 
-var AccountCodec = wire.Codec{
-	Encode: AccountEncoder,
-	Decode: AccountDecoder,
+// Return as mutable MutableACCount
+func (acc ConcreteAccount) MutableAccount() MutableAccount {
+	return concreteAccountWrapper{&acc}
 }
 
-func EncodeAccount(acc *Account) []byte {
+func (acc *ConcreteAccount) Encode() []byte {
 	w := new(bytes.Buffer)
 	var n int
 	var err error
 	AccountEncoder(acc, w, &n, &err)
 	return w.Bytes()
 }
 
-func DecodeAccount(accBytes []byte) *Account {
+func (acc *ConcreteAccount) Copy() *ConcreteAccount {
+	accCopy := *acc
+	return &accCopy
+}
+
+func (acc *ConcreteAccount) String() string {
+	if acc == nil {
+		return ""Account{nil}""
+	}
+
+	return fmt.Sprintf(""Account{Address: %s; PublicKey: %v Balance: %v; CodeBytes: %v; StorageRoot: 0x%X; Permissions: %s}"",
+		acc.Address, acc.PublicKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
+}
+
+// ConcreteAccount
+// -------------------------------------------------
+// Conversions
+//
+// Using the naming convention is this package of 'As<Type>' being
+// a conversion from Account to <Type> and 'From<Type>' being conversion
+// from <Type> to Account. Conversions are done by copying
+
+// Returns a mutable, serialisable ConcreteAccount by copying from account
+func AsConcreteAccount(account Account) *ConcreteAccount {
+	if account == nil {
+		return nil
+	}
+	if ca, ok := account.(concreteAccountWrapper); ok {
+		return ca.ConcreteAccount
+	}
+	return &ConcreteAccount{
+		Address:     account.Address(),
+		PublicKey:   account.PublicKey(),
+		Balance:     account.Balance(),
+		Code:        account.Code(),
+		Sequence:    account.Sequence(),
+		StorageRoot: account.StorageRoot(),
+		Permissions: account.Permissions(),
+	}
+}
+
+// Creates an otherwise zeroed Account from an Addressable and returns it as MutableAccount
+func FromAddressable(addressable Addressable) MutableAccount {
+	return ConcreteAccount{
+		Address:   addressable.Address(),
+		PublicKey: addressable.PublicKey(),
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
+	}.MutableAccount()
+}
+
+// Returns an immutable account by copying from account
+func AsAccount(account Account) Account {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).Account()
+}
+
+// Returns a MutableAccount by copying from account
+func AsMutableAccount(account Account) MutableAccount {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).MutableAccount()
+}
+
+func GetMutableAccount(getter Getter, address Address) (MutableAccount, error) {
+	acc, err := getter.GetAccount(address)
+	if err != nil {
+		return nil, err
+	}
+	// If we get get our own concreteAccountWrapper back we can save an unnecessary copy and just
+	// return since ConcreteAccount.Account() will have been used to produce it which will already
+	// have copied
+	caw, ok := acc.(concreteAccountWrapper)
+	if ok {
+		return caw, nil
+	}
+	return AsMutableAccount(acc), nil
+}
+
+//----------------------------------------------
+// concreteAccount Wrapper
+
+// concreteAccountWrapper wraps ConcreteAccount to provide a immutable read-only view
+// via its implementation of Account and a mutable implementation via its implementation of
+// MutableAccount
+type concreteAccountWrapper struct {
+	*ConcreteAccount `json:""unwrap""`
+}
+
+var _ = wire.RegisterInterface(struct{ Account }{}, wire.ConcreteType{concreteAccountWrapper{}, 0x01})
+
+var _ Account = concreteAccountWrapper{}
+
+func (caw concreteAccountWrapper) Address() Address {
+	return caw.ConcreteAccount.Address
+}
+
+func (caw concreteAccountWrapper) PublicKey() PublicKey {
+	return caw.ConcreteAccount.PublicKey
+}
+
+func (caw concreteAccountWrapper) Balance() uint64 {
+	return caw.ConcreteAccount.Balance
+}
+
+func (caw concreteAccountWrapper) Code() Bytecode {
+	return caw.ConcreteAccount.Code
+}
+
+func (caw concreteAccountWrapper) Sequence() uint64 {
+	return caw.ConcreteAccount.Sequence
+}
+
+func (caw concreteAccountWrapper) StorageRoot() []byte {
+	return caw.ConcreteAccount.StorageRoot
+}
+
+func (caw concreteAccountWrapper) Permissions() ptypes.AccountPermissions {
+	return caw.ConcreteAccount.Permissions
+}
+
+func (caw concreteAccountWrapper) Encode() []byte {
+	return caw.ConcreteAccount.Encode()
+}
+
+func (caw concreteAccountWrapper) MarshalJSON() ([]byte, error) {
+	return json.Marshal(caw.ConcreteAccount)
+}
+
+// Account mutation via MutableAccount interface
+var _ MutableAccount = concreteAccountWrapper{}
+
+func (caw concreteAccountWrapper) SetPublicKey(pubKey PublicKey) MutableAccount {
+	caw.ConcreteAccount.PublicKey = pubKey
+	addressFromPubKey, err := AddressFromBytes(pubKey.Address())
+	if err != nil {
+		// We rely on this working in all over the place so shouldn't happen
+		panic(fmt.Errorf(""could not obtain address from public key: %v"", pubKey))
+	}
+	// We don't want the wrong public key to take control of an account so we panic here
+	if caw.ConcreteAccount.Address != addressFromPubKey {
+		panic(fmt.Errorf(""attempt to set public key of account %s to %v, ""+
+			""but that public key has address %s"",
+			caw.ConcreteAccount.Address, pubKey, addressFromPubKey))
+	}
+	return caw
+}
+
+func (caw concreteAccountWrapper) SubtractFromBalance(amount uint64) MutableAccount {
+	if amount > caw.Balance() {
+		panic(fmt.Errorf(""insufficient funds: attempt to subtract %v from the balance of %s"",
+			amount, caw.ConcreteAccount))
+	}
+	caw.ConcreteAccount.Balance -= amount
+	return caw
+}
+
+func (caw concreteAccountWrapper) AddToBalance(amount uint64) MutableAccount {
+	if binary.IsUint64SumOverflow(caw.Balance(), amount) {
+		panic(fmt.Errorf(""uint64 overflow: attempt to add %v to the balance of %s"",
+			amount, caw.ConcreteAccount))
+	}
+	caw.ConcreteAccount.Balance += amount
+	return caw
+}
+
+func (caw concreteAccountWrapper) SetCode(code []byte) MutableAccount {
+	caw.ConcreteAccount.Code = code
+	return caw
+}
+
+func (caw concreteAccountWrapper) IncSequence() MutableAccount {
+	caw.ConcreteAccount.Sequence += 1
+	return caw
+}
+
+func (caw concreteAccountWrapper) SetStorageRoot(storageRoot []byte) MutableAccount {
+	caw.ConcreteAccount.StorageRoot = storageRoot
+	return caw
+}
+
+func (caw concreteAccountWrapper) SetPermissions(permissions ptypes.AccountPermissions) MutableAccount {
+	caw.ConcreteAccount.Permissions = permissions
+	return caw
+}
+
+func (caw concreteAccountWrapper) MutablePermissions() *ptypes.AccountPermissions {
+	return &caw.ConcreteAccount.Permissions
+}
+
+func (caw concreteAccountWrapper) Copy() MutableAccount {
+	return concreteAccountWrapper{caw.ConcreteAccount.Copy()}
+}
+
+// concreteAccount Wrapper
+//----------------------------------------------
+// Encoding/decoding
+
+func AccountEncoder(o interface{}, w io.Writer, n *int, err *error) {
+	wire.WriteBinary(o.(*ConcreteAccount), w, n, err)",,2017-12-18 15:57:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/155065895,https://github.com/hyperledger/burrow/pull/657#discussion_r155065895,aludvik
https://github.com/hyperledger/burrow/pull/657,https://github.com/hyperledger/burrow/pull/657,Errors from encoding are not handle in this function. I think the errors are probably only encountered because wire takes a generic writer which can cause errors that propagate back...,e47400687ea4e65984311c4fea58834ea6993184,2017-12-05 20:58:50,155073861,"@@ -45,58 +41,335 @@ func SignBytes(chainID string, o Signable) []byte {
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
 }
 
-func (acc *Account) Copy() *Account {
-	accCopy := *acc
-	return &accCopy
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {
+	Address     Address
+	PublicKey   PublicKey
+	Balance     uint64
+	Code        Bytecode
+	Sequence    uint64
+	StorageRoot []byte
+	Permissions ptypes.AccountPermissions
 }
 
-func (acc *Account) String() string {
-	if acc == nil {
-		return ""nil-Account""
+func NewConcreteAccount(pubKey PublicKey) ConcreteAccount {
+	return ConcreteAccount{
+		Address:   MustAddressFromBytes(pubKey.Address()),
+		PublicKey: pubKey,
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
 	}
-	return fmt.Sprintf(""Account{%X:%v B:%v C:%v S:%X P:%s}"", acc.Address, acc.PubKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
 }
 
-func AccountEncoder(o interface{}, w io.Writer, n *int, err *error) {
-	wire.WriteBinary(o.(*Account), w, n, err)
+func NewConcreteAccountFromSecret(secret string) ConcreteAccount {
+	return NewConcreteAccount(PublicKeyFromPubKey(PrivateKeyFromSecret(secret).PubKey()))
 }
 
-func AccountDecoder(r io.Reader, n *int, err *error) interface{} {
-	return wire.ReadBinary(&Account{}, r, 0, n, err)
+// Return as immutable Account
+func (acc ConcreteAccount) Account() Account {
+	return concreteAccountWrapper{&acc}
 }
 
-var AccountCodec = wire.Codec{
-	Encode: AccountEncoder,
-	Decode: AccountDecoder,
+// Return as mutable MutableACCount
+func (acc ConcreteAccount) MutableAccount() MutableAccount {
+	return concreteAccountWrapper{&acc}
 }
 
-func EncodeAccount(acc *Account) []byte {
+func (acc *ConcreteAccount) Encode() []byte {",,2017-12-18 15:57:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/155073861,https://github.com/hyperledger/burrow/pull/657#discussion_r155073861,aludvik
https://github.com/hyperledger/burrow/pull/657,https://github.com/hyperledger/burrow/pull/657,Same for other types following the `T` -> `ConcreteT` pattern,e47400687ea4e65984311c4fea58834ea6993184,2017-12-05 21:04:46,155075297,"@@ -45,58 +41,335 @@ func SignBytes(chainID string, o Signable) []byte {
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
 }
 
-func (acc *Account) Copy() *Account {
-	accCopy := *acc
-	return &accCopy
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {",79,2017-12-18 15:57:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/155075297,https://github.com/hyperledger/burrow/pull/657#discussion_r155075297,aludvik
https://github.com/hyperledger/burrow/pull/657,https://github.com/hyperledger/burrow/pull/657,I am not sure the PrivateAccount and Account interfaces are being used to the extent that they could be here and in other places. Is it possible to have the return type here be just `PrivateAccount` and to do something similar in other places where possible (such as the other generate functions below)?,e47400687ea4e65984311c4fea58834ea6993184,2017-12-05 21:17:11,155078207,"@@ -0,0 +1,136 @@
+// Copyright 2017 Monax Industries Limited
+//
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package account
+
+import (
+	""fmt""
+
+	""github.com/tendermint/ed25519""
+	""github.com/tendermint/go-crypto""
+	""github.com/tendermint/go-wire""
+)
+
+type Signer interface {
+	Sign(msg []byte) (crypto.Signature, error)
+}
+
+type PrivateAccount interface {
+	Addressable
+	PrivateKey() PrivateKey
+	Signer
+}
+
+type ConcretePrivateAccount struct {
+	Address    Address
+	PublicKey  PublicKey
+	PrivateKey PrivateKey
+}
+
+type concretePrivateAccountWrapper struct {
+	*ConcretePrivateAccount `json:""unwrap""`
+}
+
+var _ = wire.RegisterInterface(struct{ PrivateAccount }{}, wire.ConcreteType{concretePrivateAccountWrapper{}, 0x01})
+
+var _ PrivateAccount = concretePrivateAccountWrapper{}
+
+func (cpaw concretePrivateAccountWrapper) Address() Address {
+	return cpaw.ConcretePrivateAccount.Address
+}
+
+func (cpaw concretePrivateAccountWrapper) PublicKey() PublicKey {
+	return cpaw.ConcretePrivateAccount.PublicKey
+}
+
+func (cpaw concretePrivateAccountWrapper) PrivateKey() PrivateKey {
+	return cpaw.ConcretePrivateAccount.PrivateKey
+}
+
+func (pa ConcretePrivateAccount) PrivateAccount() concretePrivateAccountWrapper {
+	return concretePrivateAccountWrapper{&pa}
+}
+
+func (pa ConcretePrivateAccount) Sign(msg []byte) (crypto.Signature, error) {
+	return pa.PrivateKey.Sign(msg), nil
+}
+
+func ChainSign(pa PrivateAccount, chainID string, o Signable) crypto.Signature {
+	sig, _ := pa.Sign(SignBytes(chainID, o))
+	return sig
+}
+
+func (pa *ConcretePrivateAccount) Generate(index int) concretePrivateAccountWrapper {
+	newPrivKey := PrivateKeyFromPrivKey(pa.PrivateKey.Unwrap().(crypto.PrivKeyEd25519).Generate(index).Wrap())
+	newPubKey := PublicKeyFromPubKey(newPrivKey.PubKey())
+	newAddress, _ := AddressFromBytes(newPubKey.Address())
+	return ConcretePrivateAccount{
+		Address:    newAddress,
+		PublicKey:  newPubKey,
+		PrivateKey: newPrivKey,
+	}.PrivateAccount()
+}
+
+func (pa *ConcretePrivateAccount) String() string {
+	return fmt.Sprintf(""ConcretePrivateAccount{%s}"", pa.Address)
+}
+
+//----------------------------------------
+
+// Generates a new account with private key.
+func GeneratePrivateAccount() concretePrivateAccountWrapper {",92,2017-12-18 15:57:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/155078207,https://github.com/hyperledger/burrow/pull/657#discussion_r155078207,aludvik
https://github.com/hyperledger/burrow/pull/657,https://github.com/hyperledger/burrow/pull/657,"I like Head or ChainHead better, as I tend to think of a blockchain as a kind of linked list. Not a big deal.",e47400687ea4e65984311c4fea58834ea6993184,2017-12-05 21:25:28,155080165,"@@ -0,0 +1,181 @@
+// Copyright 2017 Monax Industries Limited
+//
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package blockchain
+
+import (
+	""time""
+
+	""sync""
+
+	acm ""github.com/hyperledger/burrow/account""
+	""github.com/hyperledger/burrow/genesis""
+)
+
+// Immutable Root of blockchain
+type Root interface {
+	// ChainID precomputed from GenesisDoc
+	ChainID() string
+	// GenesisHash precomputed from GenesisDoc
+	GenesisHash() []byte
+	GenesisDoc() genesis.GenesisDoc
+}
+
+// Immutable pointer to the current tip of the blockchain
+type Tip interface {",36,2017-12-18 15:57:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/155080165,https://github.com/hyperledger/burrow/pull/657#discussion_r155080165,aludvik
https://github.com/hyperledger/burrow/pull/657,https://github.com/hyperledger/burrow/pull/657,can probably delete that TODO,e47400687ea4e65984311c4fea58834ea6993184,2017-12-05 21:34:51,155082526,"@@ -143,23 +142,23 @@ func (blockHeightFilter *BlockHeightFilter) Configure(fd *event.FilterData) erro
 }
 
 func (this *BlockHeightFilter) Match(v interface{}) bool {
-	bl, ok := v.(*tendermint_types.BlockMeta)
+	bl, ok := v.(*tm_types.BlockMeta)
 	if !ok {
 		return false
 	}
 	return this.match(bl.Header.Height, this.value)
 }
 
 // TODO i should start using named return params...
-func getHeightMinMax(fda []*event.FilterData, height int) (int, int, []*event.FilterData, error) {
+func getHeightMinMax(fda []*event.FilterData, height uint64) (uint64, uint64, []*event.FilterData, error) {",68,2017-12-18 15:57:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/155082526,https://github.com/hyperledger/burrow/pull/657#discussion_r155082526,aludvik
https://github.com/hyperledger/burrow/pull/657,https://github.com/hyperledger/burrow/pull/657,"I'm not in love with the name either. `BurrowAccount` is a bit redundant since 'Burrow' is in the namespace already, also `Account` is the real Burrow account. The ugly name is probably a symptom of the ugly concept... Open to other suggestions.",e47400687ea4e65984311c4fea58834ea6993184,2017-12-06 11:11:30,155207300,"@@ -45,58 +41,335 @@ func SignBytes(chainID string, o Signable) []byte {
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
 }
 
-func (acc *Account) Copy() *Account {
-	accCopy := *acc
-	return &accCopy
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {",79,2017-12-18 15:57:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/155207300,https://github.com/hyperledger/burrow/pull/657#discussion_r155207300,silasdavis
https://github.com/hyperledger/burrow/pull/657,https://github.com/hyperledger/burrow/pull/657,Must have sneezed,e47400687ea4e65984311c4fea58834ea6993184,2017-12-06 11:12:29,155207510,"@@ -45,58 +41,335 @@ func SignBytes(chainID string, o Signable) []byte {
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
 }
 
-func (acc *Account) Copy() *Account {
-	accCopy := *acc
-	return &accCopy
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {
+	Address     Address
+	PublicKey   PublicKey
+	Balance     uint64
+	Code        Bytecode
+	Sequence    uint64
+	StorageRoot []byte
+	Permissions ptypes.AccountPermissions
 }
 
-func (acc *Account) String() string {
-	if acc == nil {
-		return ""nil-Account""
+func NewConcreteAccount(pubKey PublicKey) ConcreteAccount {
+	return ConcreteAccount{
+		Address:   MustAddressFromBytes(pubKey.Address()),
+		PublicKey: pubKey,
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
 	}
-	return fmt.Sprintf(""Account{%X:%v B:%v C:%v S:%X P:%s}"", acc.Address, acc.PubKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
 }
 
-func AccountEncoder(o interface{}, w io.Writer, n *int, err *error) {
-	wire.WriteBinary(o.(*Account), w, n, err)
+func NewConcreteAccountFromSecret(secret string) ConcreteAccount {
+	return NewConcreteAccount(PublicKeyFromPubKey(PrivateKeyFromSecret(secret).PubKey()))
 }
 
-func AccountDecoder(r io.Reader, n *int, err *error) interface{} {
-	return wire.ReadBinary(&Account{}, r, 0, n, err)
+// Return as immutable Account
+func (acc ConcreteAccount) Account() Account {
+	return concreteAccountWrapper{&acc}
 }
 
-var AccountCodec = wire.Codec{
-	Encode: AccountEncoder,
-	Decode: AccountDecoder,
+// Return as mutable MutableACCount",,2017-12-18 15:57:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/155207510,https://github.com/hyperledger/burrow/pull/657#discussion_r155207510,silasdavis
https://github.com/hyperledger/burrow/pull/657,https://github.com/hyperledger/burrow/pull/657,😢 ,e47400687ea4e65984311c4fea58834ea6993184,2017-12-06 11:12:54,155207594,"@@ -45,58 +41,335 @@ func SignBytes(chainID string, o Signable) []byte {
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
 }
 
-func (acc *Account) Copy() *Account {
-	accCopy := *acc
-	return &accCopy
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {
+	Address     Address
+	PublicKey   PublicKey
+	Balance     uint64
+	Code        Bytecode
+	Sequence    uint64
+	StorageRoot []byte
+	Permissions ptypes.AccountPermissions
 }
 
-func (acc *Account) String() string {
-	if acc == nil {
-		return ""nil-Account""
+func NewConcreteAccount(pubKey PublicKey) ConcreteAccount {
+	return ConcreteAccount{
+		Address:   MustAddressFromBytes(pubKey.Address()),
+		PublicKey: pubKey,
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
 	}
-	return fmt.Sprintf(""Account{%X:%v B:%v C:%v S:%X P:%s}"", acc.Address, acc.PubKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
 }
 
-func AccountEncoder(o interface{}, w io.Writer, n *int, err *error) {
-	wire.WriteBinary(o.(*Account), w, n, err)
+func NewConcreteAccountFromSecret(secret string) ConcreteAccount {
+	return NewConcreteAccount(PublicKeyFromPubKey(PrivateKeyFromSecret(secret).PubKey()))
 }
 
-func AccountDecoder(r io.Reader, n *int, err *error) interface{} {
-	return wire.ReadBinary(&Account{}, r, 0, n, err)
+// Return as immutable Account
+func (acc ConcreteAccount) Account() Account {
+	return concreteAccountWrapper{&acc}
 }
 
-var AccountCodec = wire.Codec{
-	Encode: AccountEncoder,
-	Decode: AccountDecoder,
+// Return as mutable MutableACCount
+func (acc ConcreteAccount) MutableAccount() MutableAccount {
+	return concreteAccountWrapper{&acc}
 }
 
-func EncodeAccount(acc *Account) []byte {
+func (acc *ConcreteAccount) Encode() []byte {
 	w := new(bytes.Buffer)
 	var n int
 	var err error
 	AccountEncoder(acc, w, &n, &err)
 	return w.Bytes()
 }
 
-func DecodeAccount(accBytes []byte) *Account {
+func (acc *ConcreteAccount) Copy() *ConcreteAccount {
+	accCopy := *acc
+	return &accCopy
+}
+
+func (acc *ConcreteAccount) String() string {
+	if acc == nil {
+		return ""Account{nil}""
+	}
+
+	return fmt.Sprintf(""Account{Address: %s; PublicKey: %v Balance: %v; CodeBytes: %v; StorageRoot: 0x%X; Permissions: %s}"",
+		acc.Address, acc.PublicKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
+}
+
+// ConcreteAccount
+// -------------------------------------------------
+// Conversions
+//
+// Using the naming convention is this package of 'As<Type>' being
+// a conversion from Account to <Type> and 'From<Type>' being conversion
+// from <Type> to Account. Conversions are done by copying
+
+// Returns a mutable, serialisable ConcreteAccount by copying from account
+func AsConcreteAccount(account Account) *ConcreteAccount {
+	if account == nil {
+		return nil
+	}
+	if ca, ok := account.(concreteAccountWrapper); ok {
+		return ca.ConcreteAccount
+	}
+	return &ConcreteAccount{
+		Address:     account.Address(),
+		PublicKey:   account.PublicKey(),
+		Balance:     account.Balance(),
+		Code:        account.Code(),
+		Sequence:    account.Sequence(),
+		StorageRoot: account.StorageRoot(),
+		Permissions: account.Permissions(),
+	}
+}
+
+// Creates an otherwise zeroed Account from an Addressable and returns it as MutableAccount
+func FromAddressable(addressable Addressable) MutableAccount {
+	return ConcreteAccount{
+		Address:   addressable.Address(),
+		PublicKey: addressable.PublicKey(),
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
+	}.MutableAccount()
+}
+
+// Returns an immutable account by copying from account
+func AsAccount(account Account) Account {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).Account()
+}
+
+// Returns a MutableAccount by copying from account
+func AsMutableAccount(account Account) MutableAccount {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).MutableAccount()
+}
+
+func GetMutableAccount(getter Getter, address Address) (MutableAccount, error) {
+	acc, err := getter.GetAccount(address)
+	if err != nil {
+		return nil, err
+	}
+	// If we get get our own concreteAccountWrapper back we can save an unnecessary copy and just
+	// return since ConcreteAccount.Account() will have been used to produce it which will already
+	// have copied
+	caw, ok := acc.(concreteAccountWrapper)
+	if ok {
+		return caw, nil
+	}
+	return AsMutableAccount(acc), nil
+}
+
+//----------------------------------------------
+// concreteAccount Wrapper
+
+// concreteAccountWrapper wraps ConcreteAccount to provide a immutable read-only view
+// via its implementation of Account and a mutable implementation via its implementation of
+// MutableAccount
+type concreteAccountWrapper struct {",226,2017-12-18 15:57:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/155207594,https://github.com/hyperledger/burrow/pull/657#discussion_r155207594,silasdavis
https://github.com/hyperledger/burrow/pull/657,https://github.com/hyperledger/burrow/pull/657,"I don't need this here, we are bound in to go-wire in a few places, but this was superstitious ",e47400687ea4e65984311c4fea58834ea6993184,2017-12-06 11:13:29,155207709,"@@ -45,58 +41,335 @@ func SignBytes(chainID string, o Signable) []byte {
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
 }
 
-func (acc *Account) Copy() *Account {
-	accCopy := *acc
-	return &accCopy
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {
+	Address     Address
+	PublicKey   PublicKey
+	Balance     uint64
+	Code        Bytecode
+	Sequence    uint64
+	StorageRoot []byte
+	Permissions ptypes.AccountPermissions
 }
 
-func (acc *Account) String() string {
-	if acc == nil {
-		return ""nil-Account""
+func NewConcreteAccount(pubKey PublicKey) ConcreteAccount {
+	return ConcreteAccount{
+		Address:   MustAddressFromBytes(pubKey.Address()),
+		PublicKey: pubKey,
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
 	}
-	return fmt.Sprintf(""Account{%X:%v B:%v C:%v S:%X P:%s}"", acc.Address, acc.PubKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
 }
 
-func AccountEncoder(o interface{}, w io.Writer, n *int, err *error) {
-	wire.WriteBinary(o.(*Account), w, n, err)
+func NewConcreteAccountFromSecret(secret string) ConcreteAccount {
+	return NewConcreteAccount(PublicKeyFromPubKey(PrivateKeyFromSecret(secret).PubKey()))
 }
 
-func AccountDecoder(r io.Reader, n *int, err *error) interface{} {
-	return wire.ReadBinary(&Account{}, r, 0, n, err)
+// Return as immutable Account
+func (acc ConcreteAccount) Account() Account {
+	return concreteAccountWrapper{&acc}
 }
 
-var AccountCodec = wire.Codec{
-	Encode: AccountEncoder,
-	Decode: AccountDecoder,
+// Return as mutable MutableACCount
+func (acc ConcreteAccount) MutableAccount() MutableAccount {
+	return concreteAccountWrapper{&acc}
 }
 
-func EncodeAccount(acc *Account) []byte {
+func (acc *ConcreteAccount) Encode() []byte {
 	w := new(bytes.Buffer)
 	var n int
 	var err error
 	AccountEncoder(acc, w, &n, &err)
 	return w.Bytes()
 }
 
-func DecodeAccount(accBytes []byte) *Account {
+func (acc *ConcreteAccount) Copy() *ConcreteAccount {
+	accCopy := *acc
+	return &accCopy
+}
+
+func (acc *ConcreteAccount) String() string {
+	if acc == nil {
+		return ""Account{nil}""
+	}
+
+	return fmt.Sprintf(""Account{Address: %s; PublicKey: %v Balance: %v; CodeBytes: %v; StorageRoot: 0x%X; Permissions: %s}"",
+		acc.Address, acc.PublicKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
+}
+
+// ConcreteAccount
+// -------------------------------------------------
+// Conversions
+//
+// Using the naming convention is this package of 'As<Type>' being
+// a conversion from Account to <Type> and 'From<Type>' being conversion
+// from <Type> to Account. Conversions are done by copying
+
+// Returns a mutable, serialisable ConcreteAccount by copying from account
+func AsConcreteAccount(account Account) *ConcreteAccount {
+	if account == nil {
+		return nil
+	}
+	if ca, ok := account.(concreteAccountWrapper); ok {
+		return ca.ConcreteAccount
+	}
+	return &ConcreteAccount{
+		Address:     account.Address(),
+		PublicKey:   account.PublicKey(),
+		Balance:     account.Balance(),
+		Code:        account.Code(),
+		Sequence:    account.Sequence(),
+		StorageRoot: account.StorageRoot(),
+		Permissions: account.Permissions(),
+	}
+}
+
+// Creates an otherwise zeroed Account from an Addressable and returns it as MutableAccount
+func FromAddressable(addressable Addressable) MutableAccount {
+	return ConcreteAccount{
+		Address:   addressable.Address(),
+		PublicKey: addressable.PublicKey(),
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
+	}.MutableAccount()
+}
+
+// Returns an immutable account by copying from account
+func AsAccount(account Account) Account {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).Account()
+}
+
+// Returns a MutableAccount by copying from account
+func AsMutableAccount(account Account) MutableAccount {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).MutableAccount()
+}
+
+func GetMutableAccount(getter Getter, address Address) (MutableAccount, error) {
+	acc, err := getter.GetAccount(address)
+	if err != nil {
+		return nil, err
+	}
+	// If we get get our own concreteAccountWrapper back we can save an unnecessary copy and just
+	// return since ConcreteAccount.Account() will have been used to produce it which will already
+	// have copied
+	caw, ok := acc.(concreteAccountWrapper)
+	if ok {
+		return caw, nil
+	}
+	return AsMutableAccount(acc), nil
+}
+
+//----------------------------------------------
+// concreteAccount Wrapper
+
+// concreteAccountWrapper wraps ConcreteAccount to provide a immutable read-only view
+// via its implementation of Account and a mutable implementation via its implementation of
+// MutableAccount
+type concreteAccountWrapper struct {
+	*ConcreteAccount `json:""unwrap""`
+}
+
+var _ = wire.RegisterInterface(struct{ Account }{}, wire.ConcreteType{concreteAccountWrapper{}, 0x01})",,2017-12-18 15:57:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/155207709,https://github.com/hyperledger/burrow/pull/657#discussion_r155207709,silasdavis
https://github.com/hyperledger/burrow/pull/657,https://github.com/hyperledger/burrow/pull/657,"Yep, I do this a lot in go...",e47400687ea4e65984311c4fea58834ea6993184,2017-12-06 11:13:55,155207808,"@@ -45,58 +41,335 @@ func SignBytes(chainID string, o Signable) []byte {
 	return buf.Bytes()
 }
 
-//-----------------------------------------------------------------------------
+type Addressable interface {
+	// Get the 20 byte EVM address of this account
+	Address() Address
+	// Public key from which the Address is derived
+	PublicKey() PublicKey
+}
 
-// Account resides in the application state, and is mutated by transactions
-// on the blockchain.
-// Serialized by wire.[read|write]Reflect
-type Account struct {
-	Address     []byte        `json:""address""`
-	PubKey      crypto.PubKey `json:""pub_key""`
-	Sequence    int           `json:""sequence""`
-	Balance     int64         `json:""balance""`
-	Code        []byte        `json:""code""`         // VM code
-	StorageRoot []byte        `json:""storage_root""` // VM storage merkle root.
+// The default immutable interface to an account
+type Account interface {
+	Addressable
+	// The value held by this account in terms of the chain-native token
+	Balance() uint64
+	// The EVM byte code held by this account (or equivalently, this contract)
+	Code() Bytecode
+	// The sequence number (or nonce) of this account, incremented each time a mutation of the
+	// Account is persisted to the blockchain state
+	Sequence() uint64
+	// The hash of all the values in this accounts storage (typically the root of some subtree
+	// in the merkle tree of global storage state)
+	StorageRoot() []byte
+	// The permission flags and roles for this account
+	Permissions() ptypes.AccountPermissions
+	// Obtain a deterministic serialisation of this account
+	// (i.e. update order and Go runtime independent)
+	Encode() []byte
+}
 
-	Permissions ptypes.AccountPermissions `json:""permissions""`
+type MutableAccount interface {
+	Account
+	// Set public key (needed for lazy initialisation), should also set the dependent address
+	SetPublicKey(pubKey PublicKey) MutableAccount
+	// Subtract amount from account balance (will panic if amount is greater than balance)
+	SubtractFromBalance(amount uint64) MutableAccount
+	// Add amount to balance (will panic if amount plus balance is a uint64 overflow)
+	AddToBalance(amount uint64) MutableAccount
+	// Set EVM byte code associated with account
+	SetCode(code []byte) MutableAccount
+	// Increment Sequence number by 1 (capturing the current Sequence number as the index for any pending mutations)
+	IncSequence() MutableAccount
+	// Set the storage root hash
+	SetStorageRoot(storageRoot []byte) MutableAccount
+	// Set account permissions
+	SetPermissions(permissions ptypes.AccountPermissions) MutableAccount
+	// Get a pointer this account's AccountPermissions in order to mutate them
+	MutablePermissions() *ptypes.AccountPermissions
+	// Create a complete copy of this MutableAccount that is itself mutable
+	Copy() MutableAccount
 }
 
-func (acc *Account) Copy() *Account {
-	accCopy := *acc
-	return &accCopy
+// -------------------------------------------------
+// ConcreteAccount
+
+// ConcreteAccount is the canonical serialisation and bash-in-place object for an Account
+type ConcreteAccount struct {
+	Address     Address
+	PublicKey   PublicKey
+	Balance     uint64
+	Code        Bytecode
+	Sequence    uint64
+	StorageRoot []byte
+	Permissions ptypes.AccountPermissions
 }
 
-func (acc *Account) String() string {
-	if acc == nil {
-		return ""nil-Account""
+func NewConcreteAccount(pubKey PublicKey) ConcreteAccount {
+	return ConcreteAccount{
+		Address:   MustAddressFromBytes(pubKey.Address()),
+		PublicKey: pubKey,
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
 	}
-	return fmt.Sprintf(""Account{%X:%v B:%v C:%v S:%X P:%s}"", acc.Address, acc.PubKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
 }
 
-func AccountEncoder(o interface{}, w io.Writer, n *int, err *error) {
-	wire.WriteBinary(o.(*Account), w, n, err)
+func NewConcreteAccountFromSecret(secret string) ConcreteAccount {
+	return NewConcreteAccount(PublicKeyFromPubKey(PrivateKeyFromSecret(secret).PubKey()))
 }
 
-func AccountDecoder(r io.Reader, n *int, err *error) interface{} {
-	return wire.ReadBinary(&Account{}, r, 0, n, err)
+// Return as immutable Account
+func (acc ConcreteAccount) Account() Account {
+	return concreteAccountWrapper{&acc}
 }
 
-var AccountCodec = wire.Codec{
-	Encode: AccountEncoder,
-	Decode: AccountDecoder,
+// Return as mutable MutableACCount
+func (acc ConcreteAccount) MutableAccount() MutableAccount {
+	return concreteAccountWrapper{&acc}
 }
 
-func EncodeAccount(acc *Account) []byte {
+func (acc *ConcreteAccount) Encode() []byte {
 	w := new(bytes.Buffer)
 	var n int
 	var err error
 	AccountEncoder(acc, w, &n, &err)
 	return w.Bytes()
 }
 
-func DecodeAccount(accBytes []byte) *Account {
+func (acc *ConcreteAccount) Copy() *ConcreteAccount {
+	accCopy := *acc
+	return &accCopy
+}
+
+func (acc *ConcreteAccount) String() string {
+	if acc == nil {
+		return ""Account{nil}""
+	}
+
+	return fmt.Sprintf(""Account{Address: %s; PublicKey: %v Balance: %v; CodeBytes: %v; StorageRoot: 0x%X; Permissions: %s}"",
+		acc.Address, acc.PublicKey, acc.Balance, len(acc.Code), acc.StorageRoot, acc.Permissions)
+}
+
+// ConcreteAccount
+// -------------------------------------------------
+// Conversions
+//
+// Using the naming convention is this package of 'As<Type>' being
+// a conversion from Account to <Type> and 'From<Type>' being conversion
+// from <Type> to Account. Conversions are done by copying
+
+// Returns a mutable, serialisable ConcreteAccount by copying from account
+func AsConcreteAccount(account Account) *ConcreteAccount {
+	if account == nil {
+		return nil
+	}
+	if ca, ok := account.(concreteAccountWrapper); ok {
+		return ca.ConcreteAccount
+	}
+	return &ConcreteAccount{
+		Address:     account.Address(),
+		PublicKey:   account.PublicKey(),
+		Balance:     account.Balance(),
+		Code:        account.Code(),
+		Sequence:    account.Sequence(),
+		StorageRoot: account.StorageRoot(),
+		Permissions: account.Permissions(),
+	}
+}
+
+// Creates an otherwise zeroed Account from an Addressable and returns it as MutableAccount
+func FromAddressable(addressable Addressable) MutableAccount {
+	return ConcreteAccount{
+		Address:   addressable.Address(),
+		PublicKey: addressable.PublicKey(),
+		// Since nil slices and maps compare differently to empty ones
+		Code:        Bytecode{},
+		StorageRoot: []byte{},
+		Permissions: ptypes.AccountPermissions{
+			Roles: []string{},
+		},
+	}.MutableAccount()
+}
+
+// Returns an immutable account by copying from account
+func AsAccount(account Account) Account {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).Account()
+}
+
+// Returns a MutableAccount by copying from account
+func AsMutableAccount(account Account) MutableAccount {
+	if account == nil {
+		return nil
+	}
+	return AsConcreteAccount(account).MutableAccount()
+}
+
+func GetMutableAccount(getter Getter, address Address) (MutableAccount, error) {
+	acc, err := getter.GetAccount(address)
+	if err != nil {
+		return nil, err
+	}
+	// If we get get our own concreteAccountWrapper back we can save an unnecessary copy and just
+	// return since ConcreteAccount.Account() will have been used to produce it which will already
+	// have copied
+	caw, ok := acc.(concreteAccountWrapper)
+	if ok {
+		return caw, nil
+	}
+	return AsMutableAccount(acc), nil
+}
+
+//----------------------------------------------
+// concreteAccount Wrapper
+
+// concreteAccountWrapper wraps ConcreteAccount to provide a immutable read-only view
+// via its implementation of Account and a mutable implementation via its implementation of
+// MutableAccount
+type concreteAccountWrapper struct {
+	*ConcreteAccount `json:""unwrap""`
+}
+
+var _ = wire.RegisterInterface(struct{ Account }{}, wire.ConcreteType{concreteAccountWrapper{}, 0x01})
+
+var _ Account = concreteAccountWrapper{}
+
+func (caw concreteAccountWrapper) Address() Address {
+	return caw.ConcreteAccount.Address
+}
+
+func (caw concreteAccountWrapper) PublicKey() PublicKey {
+	return caw.ConcreteAccount.PublicKey
+}
+
+func (caw concreteAccountWrapper) Balance() uint64 {
+	return caw.ConcreteAccount.Balance
+}
+
+func (caw concreteAccountWrapper) Code() Bytecode {
+	return caw.ConcreteAccount.Code
+}
+
+func (caw concreteAccountWrapper) Sequence() uint64 {
+	return caw.ConcreteAccount.Sequence
+}
+
+func (caw concreteAccountWrapper) StorageRoot() []byte {
+	return caw.ConcreteAccount.StorageRoot
+}
+
+func (caw concreteAccountWrapper) Permissions() ptypes.AccountPermissions {
+	return caw.ConcreteAccount.Permissions
+}
+
+func (caw concreteAccountWrapper) Encode() []byte {
+	return caw.ConcreteAccount.Encode()
+}
+
+func (caw concreteAccountWrapper) MarshalJSON() ([]byte, error) {
+	return json.Marshal(caw.ConcreteAccount)
+}
+
+// Account mutation via MutableAccount interface
+var _ MutableAccount = concreteAccountWrapper{}",269,2017-12-18 15:57:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/155207808,https://github.com/hyperledger/burrow/pull/657#discussion_r155207808,silasdavis
https://github.com/hyperledger/burrow/pull/643,https://github.com/hyperledger/burrow/pull/643,race,ec475e704abad286a1ce66fde243c8140c95eba9,2017-08-30 15:46:10,136108970,"@@ -68,32 +67,29 @@ func (this *mockEventEmitter) Subscribe(subId, eventId string, callback func(txs
 	this.mutex.Unlock()
 
 	go func() {
-		<-me.sdChan
-		me.shutdown = true",34,2017-08-30 15:46:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/136108970,https://github.com/hyperledger/burrow/pull/643#discussion_r136108970,silasdavis
https://github.com/hyperledger/burrow/pull/643,https://github.com/hyperledger/burrow/pull/643,shutdown channel was there but never used,ec475e704abad286a1ce66fde243c8140c95eba9,2017-08-30 15:46:30,136109070,"@@ -68,32 +67,29 @@ func (this *mockEventEmitter) Subscribe(subId, eventId string, callback func(txs
 	this.mutex.Unlock()
 
 	go func() {
-		<-me.sdChan
-		me.shutdown = true
-	}()
-	go func() {
 		for {
-			if !me.shutdown {
-				me.f(mockEventData{subId, eventId})
-			} else {
+			select {
+			case <-me.sdChan:
 				this.mutex.Lock()
 				delete(this.subs, subId)
 				this.mutex.Unlock()
 				return
+			case <-time.After(mockInterval):
+				me.f(mockEventData{subId, eventId})
 			}
-			time.Sleep(mockInterval)
 		}
 	}()
 	return nil
 }
 
 func (this *mockEventEmitter) Unsubscribe(subId string) error {
+	this.mutex.Lock()
 	sub, ok := this.subs[subId]
+	this.mutex.Unlock()
 	if !ok {
 		return nil
 	}
-	sub.shutdown = true
-	delete(this.subs, subId)
+	sub.sdChan <- struct{}{}",65,2017-08-30 15:46:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/136109070,https://github.com/hyperledger/burrow/pull/643#discussion_r136109070,silasdavis
https://github.com/hyperledger/burrow/pull/643,https://github.com/hyperledger/burrow/pull/643,receiving goroutine is responsible for this. Obvious race.,ec475e704abad286a1ce66fde243c8140c95eba9,2017-08-30 15:46:56,136109197,"@@ -68,32 +67,29 @@ func (this *mockEventEmitter) Subscribe(subId, eventId string, callback func(txs
 	this.mutex.Unlock()
 
 	go func() {
-		<-me.sdChan
-		me.shutdown = true
-	}()
-	go func() {
 		for {
-			if !me.shutdown {
-				me.f(mockEventData{subId, eventId})
-			} else {
+			select {
+			case <-me.sdChan:
 				this.mutex.Lock()
 				delete(this.subs, subId)
 				this.mutex.Unlock()
 				return
+			case <-time.After(mockInterval):
+				me.f(mockEventData{subId, eventId})
 			}
-			time.Sleep(mockInterval)
 		}
 	}()
 	return nil
 }
 
 func (this *mockEventEmitter) Unsubscribe(subId string) error {
+	this.mutex.Lock()
 	sub, ok := this.subs[subId]
+	this.mutex.Unlock()
 	if !ok {
 		return nil
 	}
-	sub.shutdown = true
-	delete(this.subs, subId)",64,2017-08-30 15:46:56,https://api.github.com/repos/hyperledger/burrow/pulls/comments/136109197,https://github.com/hyperledger/burrow/pull/643#discussion_r136109197,silasdavis
https://github.com/hyperledger/burrow/pull/643,https://github.com/hyperledger/burrow/pull/643,Read-write race,ec475e704abad286a1ce66fde243c8140c95eba9,2017-08-30 15:47:15,136109274,"@@ -68,32 +67,29 @@ func (this *mockEventEmitter) Subscribe(subId, eventId string, callback func(txs
 	this.mutex.Unlock()
 
 	go func() {
-		<-me.sdChan
-		me.shutdown = true
-	}()
-	go func() {
 		for {
-			if !me.shutdown {
-				me.f(mockEventData{subId, eventId})
-			} else {
+			select {
+			case <-me.sdChan:
 				this.mutex.Lock()
 				delete(this.subs, subId)
 				this.mutex.Unlock()
 				return
+			case <-time.After(mockInterval):
+				me.f(mockEventData{subId, eventId})
 			}
-			time.Sleep(mockInterval)
 		}
 	}()
 	return nil
 }
 
 func (this *mockEventEmitter) Unsubscribe(subId string) error {
+	this.mutex.Lock()
 	sub, ok := this.subs[subId]",58,2017-08-30 15:47:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/136109274,https://github.com/hyperledger/burrow/pull/643#discussion_r136109274,silasdavis
https://github.com/hyperledger/burrow/pull/637,https://github.com/hyperledger/burrow/pull/637,"Without the check above we get an empty map that gives us a non-nil logging config which kills the logs. Before we were using `GetStringMap` this did not happen, but config structure was changed requiring this thus the lack of logs without an explicit config.",93330c8e3c199330d8d6d4592525610dd9957c62,2017-08-25 15:42:38,135290528,"@@ -107,6 +107,9 @@ func LoadServerConfig(chainId string, rootConfig *viper.Viper) (*server.ServerCo
 }
 
 func LoadLoggingConfigFromDo(do *definitions.Do) (*lconfig.LoggingConfig, error) {
+	if !do.Config.IsSet(""logging"") {
+		return nil, nil
+	}
 	loggingConfigMap := do.Config.GetStringMap(""logging"")",7,2017-08-25 15:42:38,https://api.github.com/repos/hyperledger/burrow/pulls/comments/135290528,https://github.com/hyperledger/burrow/pull/637#discussion_r135290528,silasdavis
https://github.com/hyperledger/burrow/pull/621,https://github.com/hyperledger/burrow/pull/621,presume you did this?,36f5cf8c469ba09afc6d47f194adf6a8ebe10b47,2017-06-05 07:14:36,120053662,"@@ -40,7 +40,7 @@ var rc = [...]uint64{
 // ro_xx represent the rotation offsets for use in the χ step.
 // Defining them as const instead of in an array allows the compiler to insert constant shifts.
 const (
-	ro_00 = 0
+	ro_00 = 0 // not used",5,2017-06-05 07:14:36,https://api.github.com/repos/hyperledger/burrow/pulls/comments/120053662,https://github.com/hyperledger/burrow/pull/621#discussion_r120053662,silasdavis
https://github.com/hyperledger/burrow/pull/621,https://github.com/hyperledger/burrow/pull/621,"yeah, because the `unused` tool throws. can remove",36f5cf8c469ba09afc6d47f194adf6a8ebe10b47,2017-06-05 15:03:50,120128702,"@@ -40,7 +40,7 @@ var rc = [...]uint64{
 // ro_xx represent the rotation offsets for use in the χ step.
 // Defining them as const instead of in an array allows the compiler to insert constant shifts.
 const (
-	ro_00 = 0
+	ro_00 = 0 // not used",5,2017-06-05 15:03:50,https://api.github.com/repos/hyperledger/burrow/pulls/comments/120128702,https://github.com/hyperledger/burrow/pull/621#discussion_r120128702,zramsay
https://github.com/hyperledger/burrow/pull/613,https://github.com/hyperledger/burrow/pull/613,name of helper function should be singular now,7f6cda48e76608398661315311bf328466af1d71,2017-05-24 11:29:16,118227432,"@@ -91,14 +89,10 @@ func CaptureStdlibLogOutput(infoTraceLogger types.InfoTraceLogger) {
 }
 
 // Helpers
-func infoTraceLoggersFromLoggingConfig(loggingConfig *config.LoggingConfig) (kitlog.Logger, kitlog.Logger, error) {
-	infoOnlyLogger, _, err := loggingConfig.InfoSink.BuildLogger()
+func infoTraceLoggersFromLoggingConfig(loggingConfig *config.LoggingConfig) (kitlog.Logger, error) {",,2017-05-24 21:22:49,https://api.github.com/repos/hyperledger/burrow/pulls/comments/118227432,https://github.com/hyperledger/burrow/pull/613#discussion_r118227432,benjaminbollen
https://github.com/hyperledger/burrow/pull/607,https://github.com/hyperledger/burrow/pull/607,This was renamed to be consistent with ret below,78691647b54424d4a714cd82e9d825b4e463b7f3,2017-05-09 19:01:13,115574063,"@@ -324,14 +324,14 @@ func (function *SNativeFunctionDescription) NArgs() int {
 	return len(function.Args)
 }
 
-func arg(name string, abiTypeName abi.TypeName) abi.Arg {
+func abiArg(name string, abiTypeName abi.TypeName) abi.Arg {",102,2017-05-15 18:27:37,https://api.github.com/repos/hyperledger/burrow/pulls/comments/115574063,https://github.com/hyperledger/burrow/pull/607#discussion_r115574063,silasdavis
https://github.com/hyperledger/burrow/pull/607,https://github.com/hyperledger/burrow/pull/607,This was renamed so as to not clash with the local variable `ret` in the vm package,78691647b54424d4a714cd82e9d825b4e463b7f3,2017-05-09 19:01:33,115574135,"@@ -324,14 +324,14 @@ func (function *SNativeFunctionDescription) NArgs() int {
 	return len(function.Args)
 }
 
-func arg(name string, abiTypeName abi.TypeName) abi.Arg {
+func abiArg(name string, abiTypeName abi.TypeName) abi.Arg {
 	return abi.Arg{
 		Name:     name,
 		TypeName: abiTypeName,
 	}
 }
 
-func ret(name string, abiTypeName abi.TypeName) abi.Return {
+func abiReturn(name string, abiTypeName abi.TypeName) abi.Return {",110,2017-05-15 18:27:37,https://api.github.com/repos/hyperledger/burrow/pulls/comments/115574135,https://github.com/hyperledger/burrow/pull/607#discussion_r115574135,silasdavis
https://github.com/hyperledger/burrow/pull/606,https://github.com/hyperledger/burrow/pull/606,"unfinished error message, include `toAddress`, spacing between sentences and that native contracts cannot be called directly ""... from RPC/pipe"".

please apply `LeftPadWord256` here explicitly.

Even though this error is caught before entering execution, and additionally it would hit L420 `GetAccount` and should fail; but it is a good catch because we should consider blocking out the (creation and) existence of contracts at a registered native contracts)",9ce5b1b3d71835860b3ecb81cd0cf0e2d7b39fd4,2017-05-08 11:13:25,115224373,"@@ -409,6 +411,10 @@ func (pipe *burrowMintPipe) DumpStorage(address []byte) (*rpc_tm_types.ResultDum
 // TODO: [ben] resolve incompatibilities in byte representation for 0.12.0 release
 func (pipe *burrowMintPipe) Call(fromAddress, toAddress, data []byte) (*rpc_tm_types.ResultCall,
 	error) {
+	if vm.RegisteredNativeContractAddress(toAddress) {
+		return nil, errors.New(""Native contracts can not be called directly."" +
+			""Use a deployed contract that calls the s"")",,2017-05-08 14:43:36,https://api.github.com/repos/hyperledger/burrow/pulls/comments/115224373,https://github.com/hyperledger/burrow/pull/606#discussion_r115224373,benjaminbollen
https://github.com/hyperledger/burrow/pull/606,https://github.com/hyperledger/burrow/pull/606,"We should work towards stronger typing, not looser typing;  `LeftPadWord256` should be called by caller of `RegisteredNativeContract(word256) bool`; so please revert and adjust two places where you call.",9ce5b1b3d71835860b3ecb81cd0cf0e2d7b39fd4,2017-05-08 11:21:31,115225669,"@@ -24,8 +24,12 @@ import (
 
 var registeredNativeContracts = make(map[Word256]NativeContract)
 
-func RegisteredNativeContract(addr Word256) bool {
-	_, ok := registeredNativeContracts[addr]
+func RegisteredNativeContractAddress(address []byte) bool {",,2017-05-08 14:43:36,https://api.github.com/repos/hyperledger/burrow/pulls/comments/115225669,https://github.com/hyperledger/burrow/pull/606#discussion_r115225669,benjaminbollen
https://github.com/hyperledger/burrow/pull/606,https://github.com/hyperledger/burrow/pull/606,"please revert `LeftPadWord256`; such conversion from []byte to Address should be handled by a type `Address`, not by a function signature.  Until we introduce such stronger typing the paradigm is to use these conversion functions.",9ce5b1b3d71835860b3ecb81cd0cf0e2d7b39fd4,2017-05-08 11:33:48,115227410,"@@ -430,8 +430,10 @@ func ExecTx(blockCache *BlockCache, tx txs.Tx, runCall bool, evc events.Fireable
 				return txs.ErrTxInvalidAddress
 			}
 			// check if its a native contract
-			if vm.RegisteredNativeContract(LeftPadWord256(tx.Address)) {
-				return fmt.Errorf(""NativeContracts can not be called using CallTx. Use a contract or the appropriate tx type (eg. PermissionsTx, NameTx)"")
+			if vm.RegisteredNativeContractAddress(tx.Address) {",,2017-05-08 14:43:36,https://api.github.com/repos/hyperledger/burrow/pulls/comments/115227410,https://github.com/hyperledger/burrow/pull/606#discussion_r115227410,benjaminbollen
https://github.com/hyperledger/burrow/pull/605,https://github.com/hyperledger/burrow/pull/605,If the accountInfo has been removed then acc will have been set to nil so we will get a nil pointer panic before we even get to the `PanicCrisis`,288737d6ebec0888d131897489de7deb69969831,2017-05-05 18:34:35,115061799,"@@ -224,8 +225,9 @@ func (cache *BlockCache) Sync() {
 		if removed {
 			removed := cache.backend.RemoveAccount([]byte(addrStr))
 			if !removed {
-				sanity.PanicCrisis(fmt.Sprintf(""Could not remove account to be removed: %X"", acc.Address))
+				sanity.PanicCrisis(fmt.Sprintf(""Could not remove account to be removed: %X"", addrStr))",15,2017-05-08 16:50:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/115061799,https://github.com/hyperledger/burrow/pull/605#discussion_r115061799,silasdavis
https://github.com/hyperledger/burrow/pull/598,https://github.com/hyperledger/burrow/pull/598,Battle marmot needs to return to base,3cc9f9a26e21b4f65c4633c3e8d4ba7f8169ac11,2017-05-04 13:00:37,114766254,"@@ -260,29 +260,32 @@ func TestSubscribe(t *testing.T) {
 	var subId string
 	subscribe(t, wsc, txs.EventStringNewBlock())
 
-	timeout := time.NewTimer(timeoutSeconds * time.Second)
+	// timeout to check subscription process is live
+	timeout := time.After(timeoutSeconds * time.Second)
 Subscribe:
 	for {
 		select {
-		case <-timeout.C:
+		case <-timeout:
 			t.Fatal(""Timed out waiting for subscription result"")
 
 		case bs := <-wsc.ResultsCh:
 			resultSubscribe, ok := readResult(t, bs).(*core_types.ResultSubscribe)
 			if ok {
 				assert.Equal(t, txs.EventStringNewBlock(), resultSubscribe.Event)
 				subId = resultSubscribe.SubscriptionId
+				fmt.Printf(""\x1b[30m\x1b[46mMARMOT!: subid %s\x1b[0m\n"", subId)",,2017-05-04 13:07:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/114766254,https://github.com/hyperledger/burrow/pull/598#discussion_r114766254,benjaminbollen
https://github.com/hyperledger/burrow/pull/598,https://github.com/hyperledger/burrow/pull/598,Haha. Dammit those special ops marmots can be hell to extract from the field once they've gone to ground. ,3cc9f9a26e21b4f65c4633c3e8d4ba7f8169ac11,2017-05-04 13:06:49,114767534,"@@ -260,29 +260,32 @@ func TestSubscribe(t *testing.T) {
 	var subId string
 	subscribe(t, wsc, txs.EventStringNewBlock())
 
-	timeout := time.NewTimer(timeoutSeconds * time.Second)
+	// timeout to check subscription process is live
+	timeout := time.After(timeoutSeconds * time.Second)
 Subscribe:
 	for {
 		select {
-		case <-timeout.C:
+		case <-timeout:
 			t.Fatal(""Timed out waiting for subscription result"")
 
 		case bs := <-wsc.ResultsCh:
 			resultSubscribe, ok := readResult(t, bs).(*core_types.ResultSubscribe)
 			if ok {
 				assert.Equal(t, txs.EventStringNewBlock(), resultSubscribe.Event)
 				subId = resultSubscribe.SubscriptionId
+				fmt.Printf(""\x1b[30m\x1b[46mMARMOT!: subid %s\x1b[0m\n"", subId)",,2017-05-04 13:07:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/114767534,https://github.com/hyperledger/burrow/pull/598#discussion_r114767534,silasdavis
https://github.com/hyperledger/burrow/pull/595,https://github.com/hyperledger/burrow/pull/595,Nice,f0a23cc24813becccfd577b64ebea23200cf5061,2017-05-02 12:07:40,114302994,"@@ -119,3 +119,8 @@ func (core *Core) NewGatewayTendermint(config *server.ServerConfig) (
 	return rpc_tendermint.NewTendermintWebsocketServer(config,
 		core.tendermintPipe, core.evsw)
 }
+
+// Stop the core allowing for a graceful shutdown of component in order.
+func (core *Core) Stop() bool {",6,2017-05-02 12:15:14,https://api.github.com/repos/hyperledger/burrow/pulls/comments/114302994,https://github.com/hyperledger/burrow/pull/595#discussion_r114302994,benjaminbollen
https://github.com/hyperledger/burrow/pull/595,https://github.com/hyperledger/burrow/pull/595,Agreed.,f0a23cc24813becccfd577b64ebea23200cf5061,2017-05-02 12:12:12,114303712,"@@ -177,6 +186,32 @@ func (app *BurrowMint) Commit() (res abci.Result) {
 	return abci.NewResultOK(appHash, ""Success"")
 }
 
-func (app *BurrowMint) Query(query []byte) (res abci.Result) {
-	return abci.NewResultOK(nil, ""Success"")
+func (app *BurrowMint) Query(query abci.RequestQuery) (res abci.ResponseQuery) {
+	return abci.ResponseQuery{
+		Code: abci.CodeType_OK,
+		Log:  ""success"",
+	}
+}
+
+// BlockchainAware interface
+
+// Initialise the blockchain
+// validators: genesis validators from tendermint core
+func (app *BurrowMint) InitChain(validators []*abci.Validator) {
+	// Could verify agreement on initial validator set here
+}
+
+// Signals the beginning of a block
+func (app *BurrowMint) BeginBlock(hash []byte, header *abci.Header) {
+
 }
+
+// Signals the end of a blockchain, return value can be used to modify validator
+// set and voting power distribution see our BlockchainAware interface
+func (app *BurrowMint) EndBlock(height uint64) (respEndblock abci.ResponseEndBlock) {
+	// TODO: [Silas] Bondage
+	// TODO: [Silas] this might be a better place for us to dispatch new block",67,2017-05-02 12:15:14,https://api.github.com/repos/hyperledger/burrow/pulls/comments/114303712,https://github.com/hyperledger/burrow/pull/595#discussion_r114303712,benjaminbollen
https://github.com/hyperledger/burrow/pull/595,https://github.com/hyperledger/burrow/pull/595,"Actually only issue with that is is that I think they are sending ABCI EndBlock _before_ they save Tendermint state. Not an issue for something things, but may be if you were expecting post-block consensus state to be ready.",f0a23cc24813becccfd577b64ebea23200cf5061,2017-05-02 12:20:55,114305169,"@@ -177,6 +186,32 @@ func (app *BurrowMint) Commit() (res abci.Result) {
 	return abci.NewResultOK(appHash, ""Success"")
 }
 
-func (app *BurrowMint) Query(query []byte) (res abci.Result) {
-	return abci.NewResultOK(nil, ""Success"")
+func (app *BurrowMint) Query(query abci.RequestQuery) (res abci.ResponseQuery) {
+	return abci.ResponseQuery{
+		Code: abci.CodeType_OK,
+		Log:  ""success"",
+	}
+}
+
+// BlockchainAware interface
+
+// Initialise the blockchain
+// validators: genesis validators from tendermint core
+func (app *BurrowMint) InitChain(validators []*abci.Validator) {
+	// Could verify agreement on initial validator set here
+}
+
+// Signals the beginning of a block
+func (app *BurrowMint) BeginBlock(hash []byte, header *abci.Header) {
+
 }
+
+// Signals the end of a blockchain, return value can be used to modify validator
+// set and voting power distribution see our BlockchainAware interface
+func (app *BurrowMint) EndBlock(height uint64) (respEndblock abci.ResponseEndBlock) {
+	// TODO: [Silas] Bondage
+	// TODO: [Silas] this might be a better place for us to dispatch new block",67,2017-05-02 12:20:55,https://api.github.com/repos/hyperledger/burrow/pulls/comments/114305169,https://github.com/hyperledger/burrow/pull/595#discussion_r114305169,silasdavis
https://github.com/hyperledger/burrow/pull/565,https://github.com/hyperledger/burrow/pull/565,this is 0.17,dc3fcc1308a2f4c26c3b66c361c1c58e5214d39b,2017-04-11 22:31:55,111029240,"@@ -280,7 +280,7 @@ const sectionBurrowMint = `
 ################################################################################
 ##
 ## Burrow-Mint
-## version 0.16
+## version 0.17",,2017-04-12 10:28:55,https://api.github.com/repos/hyperledger/burrow/pulls/comments/111029240,https://github.com/hyperledger/burrow/pull/565#discussion_r111029240,zramsay
https://github.com/hyperledger/burrow/pull/565,https://github.com/hyperledger/burrow/pull/565,this is 0.16,dc3fcc1308a2f4c26c3b66c361c1c58e5214d39b,2017-04-11 22:32:04,111029266,"@@ -38,7 +39,7 @@ var defaultConfig = `# Copyright 2017 Monax Industries Limited
 assert_chain_id = ""MyChainId""
 # semantic major and minor version
 major_version = 0
-minor_version = 12
+minor_version = 16",13,2017-04-12 10:28:55,https://api.github.com/repos/hyperledger/burrow/pulls/comments/111029266,https://github.com/hyperledger/burrow/pull/565#discussion_r111029266,zramsay
https://github.com/hyperledger/burrow/pull/553,https://github.com/hyperledger/burrow/pull/553,an burrow -> a Burrow,7ba8c63e44bd4dc7f3af8bba9c51364b67055f9d,2017-04-04 18:30:44,109742693,"@@ -1,36 +1,36 @@
-# Eris-db changelog
+# burrow changelog
 ## v0.16.0
 This is a consolidation release that fixes various bugs and improves elements
-of the architecture across the Eris Platform to support a quicker release
+of the architecture across the Burrow Platform to support a quicker release
 cadence.
 
 #### Features and improvements (among others)
-- [pull-510](https://github.com/monax/eris-db/pull/510) upgrade consensus engine to Tendermint v0.8.0
-- [pull-507](https://github.com/monax/eris-db/pull/507) use sha3 for snative addresses for future-proofing
-- [pull-506](https://github.com/monax/eris-db/pull/506) alignment and consolidation for genesis and config between tooling and chains
-- [pull-504](https://github.com/monax/eris-db/pull/504) relicense eris-db to Apache 2.0
-- [pull-500](https://github.com/monax/eris-db/pull/500) introduce more strongly types secure native contracts
-- [pull-499](https://github.com/monax/eris-db/pull/499) introduce word256 and remove dependency on tendermint/go-common
-- [pull-493](https://github.com/monax/eris-db/pull/493) re-introduce GenesisTime in GenesisDoc
+- [pull-510](https://github.com/monax/burrow/pull/510) upgrade consensus engine to Tendermint v0.8.0
+- [pull-507](https://github.com/monax/burrow/pull/507) use sha3 for snative addresses for future-proofing
+- [pull-506](https://github.com/monax/burrow/pull/506) alignment and consolidation for genesis and config between tooling and chains
+- [pull-504](https://github.com/monax/burrow/pull/504) relicense burrow to Apache 2.0
+- [pull-500](https://github.com/monax/burrow/pull/500) introduce more strongly types secure native contracts
+- [pull-499](https://github.com/monax/burrow/pull/499) introduce word256 and remove dependency on tendermint/go-common
+- [pull-493](https://github.com/monax/burrow/pull/493) re-introduce GenesisTime in GenesisDoc
 
-- Logging system overhauled based on the central logging interface of go-kit log. Configuration lacking in this release but should be in 0.16.1. Allows powerful routing, filtering, and output options for better operations and increasing the observability of an eris blockchain. More to follow.
-- Genesis making is improved and moved into eris-db.
-- Config templating is moved into eris-db for better synchronisation of server config between the consumer of it (eris-db) and the producers of it (eris cli and other tools).
+- Logging system overhauled based on the central logging interface of go-kit log. Configuration lacking in this release but should be in 0.16.1. Allows powerful routing, filtering, and output options for better operations and increasing the observability of an burrow blockchain. More to follow.",,2017-04-06 18:14:36,https://api.github.com/repos/hyperledger/burrow/pulls/comments/109742693,https://github.com/hyperledger/burrow/pull/553#discussion_r109742693,benjaminbollen
https://github.com/hyperledger/burrow/pull/553,https://github.com/hyperledger/burrow/pull/553,Burrow Platform -> `Monax Ecosystem Platform` or `Burrow blockchain / distributed ledger`,7ba8c63e44bd4dc7f3af8bba9c51364b67055f9d,2017-04-04 18:59:43,109749738,"@@ -1,36 +1,36 @@
-# Eris-db changelog
+# burrow changelog
 ## v0.16.0
 This is a consolidation release that fixes various bugs and improves elements
-of the architecture across the Eris Platform to support a quicker release
+of the architecture across the Burrow Platform to support a quicker release
 cadence.
 
 #### Features and improvements (among others)
-- [pull-510](https://github.com/monax/eris-db/pull/510) upgrade consensus engine to Tendermint v0.8.0
-- [pull-507](https://github.com/monax/eris-db/pull/507) use sha3 for snative addresses for future-proofing
-- [pull-506](https://github.com/monax/eris-db/pull/506) alignment and consolidation for genesis and config between tooling and chains
-- [pull-504](https://github.com/monax/eris-db/pull/504) relicense eris-db to Apache 2.0
-- [pull-500](https://github.com/monax/eris-db/pull/500) introduce more strongly types secure native contracts
-- [pull-499](https://github.com/monax/eris-db/pull/499) introduce word256 and remove dependency on tendermint/go-common
-- [pull-493](https://github.com/monax/eris-db/pull/493) re-introduce GenesisTime in GenesisDoc
+- [pull-510](https://github.com/monax/burrow/pull/510) upgrade consensus engine to Tendermint v0.8.0
+- [pull-507](https://github.com/monax/burrow/pull/507) use sha3 for snative addresses for future-proofing
+- [pull-506](https://github.com/monax/burrow/pull/506) alignment and consolidation for genesis and config between tooling and chains
+- [pull-504](https://github.com/monax/burrow/pull/504) relicense burrow to Apache 2.0
+- [pull-500](https://github.com/monax/burrow/pull/500) introduce more strongly types secure native contracts
+- [pull-499](https://github.com/monax/burrow/pull/499) introduce word256 and remove dependency on tendermint/go-common
+- [pull-493](https://github.com/monax/burrow/pull/493) re-introduce GenesisTime in GenesisDoc
 
-- Logging system overhauled based on the central logging interface of go-kit log. Configuration lacking in this release but should be in 0.16.1. Allows powerful routing, filtering, and output options for better operations and increasing the observability of an eris blockchain. More to follow.
-- Genesis making is improved and moved into eris-db.
-- Config templating is moved into eris-db for better synchronisation of server config between the consumer of it (eris-db) and the producers of it (eris cli and other tools).
+- Logging system overhauled based on the central logging interface of go-kit log. Configuration lacking in this release but should be in 0.16.1. Allows powerful routing, filtering, and output options for better operations and increasing the observability of an burrow blockchain. More to follow.
+- Genesis making is improved and moved into burrow.
+- Config templating is moved into burrow for better synchronisation of server config between the consumer of it (burrow) and the producers of it (cli and other tools).
 - Some documentation updates in code and in specs.
-- [pull-462](https://github.com/monax/eris-db/pull/499) Makefile added to capture conventions around building and testing and replicate them across different environments such as continuous integration systems.
+- [pull-462](https://github.com/monax/burrow/pull/499) Makefile added to capture conventions around building and testing and replicate them across different environments such as continuous integration systems.
 
 #### Bugfixes (among others)
-- [pull-516](https://github.com/monax/eris-db/pull/516) Organize and add unit tests for rpc/v0
-- [pull-453](https://github.com/monax/eris-db/pull/453) Fix deserialisation for BroadcastTx on rpc/v0
-- [pull-476](https://github.com/monax/eris-db/pull/476) patch EXTCODESIZE for native contracts as solc ^v0.4 performs a safety check for non-zero contract code
-- [pull-468](https://github.com/monax/eris-db/pull/468) correct specifications for params on unsubscribe on rpc/tendermint
-- [pull-465](https://github.com/monax/eris-db/pull/465) fix divergence from JSON-RPC spec for Response object
-- [pull-366](https://github.com/monax/eris-db/pull/366) correction to circle ci script
-- [pull-379](https://github.com/monax/eris-db/pull/379) more descriptive error message for eris-client
+- [pull-516](https://github.com/monax/burrow/pull/516) Organize and add unit tests for rpc/v0
+- [pull-453](https://github.com/monax/burrow/pull/453) Fix deserialisation for BroadcastTx on rpc/v0
+- [pull-476](https://github.com/monax/burrow/pull/476) patch EXTCODESIZE for native contracts as solc ^v0.4 performs a safety check for non-zero contract code
+- [pull-468](https://github.com/monax/burrow/pull/468) correct specifications for params on unsubscribe on rpc/tendermint
+- [pull-465](https://github.com/monax/burrow/pull/465) fix divergence from JSON-RPC spec for Response object
+- [pull-366](https://github.com/monax/burrow/pull/366) correction to circle ci script
+- [pull-379](https://github.com/monax/burrow/pull/379) more descriptive error message for burrow-client
 
 ## v0.12.0
-This release marks the start of Eris-DB as the full permissioned blockchain node
- of the Eris platform with the Tendermint permissioned consensus engine.
+This release marks the start of burrow as the full permissioned blockchain node
+ of the Burrow Platform with the Tendermint permissioned consensus engine.",,2017-04-06 18:14:36,https://api.github.com/repos/hyperledger/burrow/pulls/comments/109749738,https://github.com/hyperledger/burrow/pull/553#discussion_r109749738,benjaminbollen
https://github.com/hyperledger/burrow/pull/553,https://github.com/hyperledger/burrow/pull/553,can be versioned: https://github.com/monax/cli/pull/1295/files#diff-0551cf25c62a749fe9b04d036a1ef478R44,7ba8c63e44bd4dc7f3af8bba9c51364b67055f9d,2017-04-05 22:08:12,110039615,"@@ -1,4 +1,4 @@
-FROM quay.io/eris/build
+FROM quay.io/monax/build",,2017-04-06 15:54:19,https://api.github.com/repos/hyperledger/burrow/pulls/comments/110039615,https://github.com/hyperledger/burrow/pull/553#discussion_r110039615,zramsay
https://github.com/hyperledger/burrow/pull/553,https://github.com/hyperledger/burrow/pull/553,version it? that's what i did for keys and compilers,7ba8c63e44bd4dc7f3af8bba9c51364b67055f9d,2017-04-06 16:01:01,110201525,"@@ -1,4 +1,4 @@
-FROM quay.io/monax/base:alpine
+FROM quay.io/monax/base",,2017-04-06 16:01:01,https://api.github.com/repos/hyperledger/burrow/pulls/comments/110201525,https://github.com/hyperledger/burrow/pull/553#discussion_r110201525,zramsay
https://github.com/hyperledger/burrow/pull/553,https://github.com/hyperledger/burrow/pull/553,uh yes... need to do that,7ba8c63e44bd4dc7f3af8bba9c51364b67055f9d,2017-04-06 16:09:23,110203581,"@@ -1,4 +1,4 @@
-FROM quay.io/monax/base:alpine
+FROM quay.io/monax/base",,2017-04-06 16:09:23,https://api.github.com/repos/hyperledger/burrow/pulls/comments/110203581,https://github.com/hyperledger/burrow/pull/553#discussion_r110203581,silasdavis
https://github.com/hyperledger/burrow/pull/549,https://github.com/hyperledger/burrow/pull/549,"""its""",a5ce7ff43e8e173b4a771d91299750d696098644,2017-04-04 15:55:51,109703567,"@@ -0,0 +1,18 @@
+### Deployment
+Included in this directory are some template files for running Burrow in a 
+cluster orchestration environment. [start_in_cluster](start_in_cluster) 
+is a general purpose script and the files in [kubernetes](kubernetes) are some
+example Service and Deployment files that illustrates its possible usage.
+
+#### start_in_cluster
+[start_in_cluster](start_in_cluster) takes its parameters as environment variables.
+
+You can find the variables used at the top of the file along with their defaults.
+
+#### Kubernetes
+[all_nodes.yml](kubernetes/all_nodes.yaml) is a Kubernetes Service definition
+that launches an entire network of nodes based on Deployment definitions like the
+example [node000-deploy.yaml](kubernetes/node000-deploy.yaml). Each validating
+node should have it's own Deployment defintion like the one found in ",16,2017-04-04 16:30:11,https://api.github.com/repos/hyperledger/burrow/pulls/comments/109703567,https://github.com/hyperledger/burrow/pull/549#discussion_r109703567,benjaminbollen
https://github.com/hyperledger/burrow/pull/549,https://github.com/hyperledger/burrow/pull/549,what is `|` ?,a5ce7ff43e8e173b4a771d91299750d696098644,2017-04-04 15:57:39,109704087,"@@ -0,0 +1,37 @@
+# All Nodes - Load balanced API ports
+kind: Service
+apiVersion: v1
+metadata:
+  name: your-app-chain-api
+  labels:
+    app: your-app
+    tier: chain
+    chain_name: your-chain
+    vendor: monax
+spec:
+  sessionAffinity: ClientIP
+  selector:
+    app: your-app
+    tier: chain
+    # node_number: ""001""
+  ports:
+    - protocol: TCP
+      port: 1337
+      targetPort: 1337
+      name: your-app-chain-api
+
+# All Nodes - genesis.json as ConfigMap
+---
+kind: ConfigMap
+apiVersion: v1
+metadata:
+  name: your-app-ecosystem-chain-genesis
+  labels:
+    app: your-app-ecosystem
+    tier: chain
+    chain_name: your-app
+    vendor: monax
+data:
+  chain-genesis: |",35,2017-04-04 16:30:11,https://api.github.com/repos/hyperledger/burrow/pulls/comments/109704087,https://github.com/hyperledger/burrow/pull/549#discussion_r109704087,benjaminbollen
https://github.com/hyperledger/burrow/pull/544,https://github.com/hyperledger/burrow/pull/544,ugh. that is a very direct way to pull this through the whole stack... but  you might be right that for now it is a useful things to have.,957f904a1dfa11bf458a5d4bccb529cb743f4186,2017-04-03 12:23:33,109403040,"@@ -161,6 +162,8 @@ func ServeRunner(do *definitions.Do) func(*cobra.Command, []string) {
 				DefaultConfigFilename)
 		}
 
+		vm.SetDebug(do.Debug)",12,2017-04-03 12:24:14,https://api.github.com/repos/hyperledger/burrow/pulls/comments/109403040,https://github.com/hyperledger/burrow/pull/544#discussion_r109403040,benjaminbollen
https://github.com/hyperledger/burrow/pull/536,https://github.com/hyperledger/burrow/pull/536,`monax/cli/cmd/eris`,64657464235b5ad44fcc2073a8f6f5f72016130f,2017-03-24 18:41:13,107973692,"@@ -18,7 +18,7 @@ dependencies:
     - sudo curl -L -o /usr/bin/docker http://s3-external-1.amazonaws.com/circle-downloads/docker-$DOCKER_VERSION-circleci; sudo chmod 0775 /usr/bin/docker; sudo usermod -a -G docker $USER; true
     - sudo service docker start
     # - sudo curl -sSL -o /usr/local/bin/docker-machine https://github.com/docker/machine/releases/download/v$DOCKER_MACHINE_VERSION/docker-machine-linux-x86_64; sudo chmod 0755 /usr/local/bin/docker-machine
-    # - ""go get github.com/eris-ltd/eris-cli/cmd/eris; cd ${GOPATH%%:*}/src/github.com/eris-ltd/eris-cli && git checkout origin/$ERIS_CLI_BRANCH && go install ./cmd/eris""
+    # - ""go get github.com/monax/eris/cmd/eris; cd ${GOPATH%%:*}/src/github.com/monax/eris && git checkout origin/$ERIS_CLI_BRANCH && go install ./cmd/eris""",14,2017-03-24 18:53:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/107973692,https://github.com/hyperledger/burrow/pull/536#discussion_r107973692,zramsay
https://github.com/hyperledger/burrow/pull/536,https://github.com/hyperledger/burrow/pull/536,drop the `.`,64657464235b5ad44fcc2073a8f6f5f72016130f,2017-03-24 18:44:45,107974373,"@@ -15,47 +15,84 @@
 package mock
 
 import (
+	""crypto/rand""
 	""encoding/hex""
 	""fmt""
 
-	// for the mock of key server we explicitly import
-	// the keys server to ensure the core components are
-	// compatible with eris-db.
-	""github.com/eris-ltd/eris-keys/crypto""
+	. ""github.com/monax/eris-db/keys""",12,2017-03-24 18:53:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/107974373,https://github.com/hyperledger/burrow/pull/536#discussion_r107974373,zramsay
https://github.com/hyperledger/burrow/pull/536,https://github.com/hyperledger/burrow/pull/536,that ticket no longer exists,64657464235b5ad44fcc2073a8f6f5f72016130f,2017-03-24 18:47:13,107974883,"@@ -194,7 +194,7 @@ func TestSendCall(t *testing.T) {
 
 // This test was introduced to cover an issues exposed in our handling of the
 // gas limit passed from caller to callee on various forms of CALL
-// this ticket gives some background: https://github.com/eris-ltd/eris-pm/issues/212
+// this ticket gives some background: https://github.com/monax/eris-pm/issues/212",20,2017-03-24 18:53:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/107974883,https://github.com/hyperledger/burrow/pull/536#discussion_r107974883,zramsay
https://github.com/hyperledger/burrow/pull/532,https://github.com/hyperledger/burrow/pull/532,if you re vendoring in the dependencies then running glide install is not necessary anymore either. ,68ad4bdcea3e17838a58c335204a4e7c852e0eb5,2017-04-03 12:58:01,109409716,"@@ -5,8 +5,6 @@ MAINTAINER Monax <support@monax.io>
 ENV TARGET eris-db
 ENV REPO $GOPATH/src/github.com/monax/$TARGET
 
-ADD ./glide.yaml $REPO/
-ADD ./glide.lock $REPO/
 WORKDIR $REPO
 RUN glide install",,2017-04-03 15:32:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/109409716,https://github.com/hyperledger/burrow/pull/532#discussion_r109409716,benjaminbollen
https://github.com/hyperledger/burrow/pull/532,https://github.com/hyperledger/burrow/pull/532,Agreed. Let me kill that.,68ad4bdcea3e17838a58c335204a4e7c852e0eb5,2017-04-03 15:29:10,109447569,"@@ -5,8 +5,6 @@ MAINTAINER Monax <support@monax.io>
 ENV TARGET eris-db
 ENV REPO $GOPATH/src/github.com/monax/$TARGET
 
-ADD ./glide.yaml $REPO/
-ADD ./glide.lock $REPO/
 WORKDIR $REPO
 RUN glide install",,2017-04-03 15:32:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/109447569,https://github.com/hyperledger/burrow/pull/532#discussion_r109447569,VoR0220
https://github.com/hyperledger/burrow/pull/531,https://github.com/hyperledger/burrow/pull/531,"eris-db will need its own documentation (especially with Hyperledger now); but yes, good change",4fb0dd487c23fe256ef20f4c5486943e3d7a60b1,2017-03-21 16:42:21,107207990,"@@ -34,7 +34,7 @@ your needs.
 
 Made with <3 by Monax Industries.
 
-Complete documentation is available at https://monax.io/docs/documentation
+Complete documentation is available at https://monax.io/docs",5,2017-03-21 16:43:02,https://api.github.com/repos/hyperledger/burrow/pulls/comments/107207990,https://github.com/hyperledger/burrow/pull/531#discussion_r107207990,benjaminbollen
https://github.com/hyperledger/burrow/pull/520,https://github.com/hyperledger/burrow/pull/520,"Not to be anal about this, but now there is not even a pretence of order left.",037e4e298703d8749b80609c80e243086e7bd97b,2017-02-28 15:50:11,103484507,"@@ -12,16 +12,17 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package rpc
+package v0
 
 import (
 	""encoding/json""
+	""io""
 )
 
 // JSON-RPC 2.0 error codes.
 const (
-	PARSE_ERROR      = -32700
 	INVALID_REQUEST  = -32600
+	PARSE_ERROR      = -32700",,2017-03-02 13:51:31,https://api.github.com/repos/hyperledger/burrow/pulls/comments/103484507,https://github.com/hyperledger/burrow/pull/520#discussion_r103484507,benjaminbollen
https://github.com/hyperledger/burrow/pull/520,https://github.com/hyperledger/burrow/pull/520,Why do you remove the general interface?,037e4e298703d8749b80609c80e243086e7bd97b,2017-02-28 15:50:45,103484659,"@@ -1,28 +0,0 @@
-// Copyright 2017 Monax Industries Limited
-//",2,2017-03-02 13:51:31,https://api.github.com/repos/hyperledger/burrow/pulls/comments/103484659,https://github.com/hyperledger/burrow/pull/520#discussion_r103484659,benjaminbollen
https://github.com/hyperledger/burrow/pull/520,https://github.com/hyperledger/burrow/pull/520,yeah that wasn't meant to happen,037e4e298703d8749b80609c80e243086e7bd97b,2017-03-01 10:06:54,103648645,"@@ -12,16 +12,17 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package rpc
+package v0
 
 import (
 	""encoding/json""
+	""io""
 )
 
 // JSON-RPC 2.0 error codes.
 const (
-	PARSE_ERROR      = -32700
 	INVALID_REQUEST  = -32600
+	PARSE_ERROR      = -32700",,2017-03-02 13:51:31,https://api.github.com/repos/hyperledger/burrow/pulls/comments/103648645,https://github.com/hyperledger/burrow/pull/520#discussion_r103648645,silasdavis
https://github.com/hyperledger/burrow/pull/520,https://github.com/hyperledger/burrow/pull/520,It's not general in the sense of being used by both RPCs. I don't that we'd particularly likely to use it for the next iteration of the RPC,037e4e298703d8749b80609c80e243086e7bd97b,2017-03-01 10:08:20,103649020,"@@ -1,28 +0,0 @@
-// Copyright 2017 Monax Industries Limited
-//",2,2017-03-02 13:51:31,https://api.github.com/repos/hyperledger/burrow/pulls/comments/103649020,https://github.com/hyperledger/burrow/pull/520#discussion_r103649020,silasdavis
https://github.com/hyperledger/burrow/pull/517,https://github.com/hyperledger/burrow/pull/517,Monax Nightsky?,2c31656b335ba711fc6beb940789290cf511c892,2017-02-28 12:40:59,103444413,"@@ -58,8 +71,32 @@ A commented template config will be written as part of the `eris chains make` [p
 
 ## Contribute
 
-See the [CONTRIBUTING.md](.github/CONTRIBUTING.md) for more details.
+We welcome all contributions and have submitted the code base to the Hyperledger project governance during incubation phase.  As an integral part of this effort we want to invite new contributors, not just to maintain but also to steer the future direction of the code in an active and open process.
+
+You can find us on:
+- [the Marmot Den (slack)](http://slack.monax.io)
+- [here on Github](http://github.com/eris-ltd/eris-db/issues)
+- [support.monax.io](http://support.monax.io)
+
 
 ## License
 
 [Apache 2.0](license.md)
+
+## Future work
+
+Some burrows marmots have already started digging to build the enterprise ecosystem applications of the future are listed below.  Marmots live in groups we welcome your help on these or other improvement proposals.
+
+#### Security, Identity and Privacy
+
+- **(Q2) Advanced security framework:** Functionality preceding Monax’s Nightsky (see multi-chain universe continuation below) to enable global encryption of transactions, genesis files and account storage at rest.
+- **(Q2) Identity Management and Whitelisting:** write protection is inherent to the permissioning scheme but read protection will be enabled by integrating certificates for restricting connectivity access to the peer-to-peer network for validators, verifiers or light clients.  This is in addition to normal VPN and firewall solutions and a precursor of Monax’s Nightsky, which restricts read-access through selective decryption.
+- **(Q3) Multi-chain Universe (Step 2 of 3):** The second step towards enabling the multi-chain universe is well-underway with the Tendermint Cosmos proposal for interblockchain communication.  
+- **(Q3) Multi-chain Universe (Step 3 of 3):** The third and final step is the Monax’s Nightsky proposal for inherent encryption of transactions and allowing only partial reconstruction of the smart contract application state for verifiers or light clients (for mobile or IoT devices). Together Cosmos and Nightsky allow smart contracts to orchestrate where information flows and who has the ability to decypher what part of the data.",,2017-02-28 14:54:14,https://api.github.com/repos/hyperledger/burrow/pulls/comments/103444413,https://github.com/hyperledger/burrow/pull/517#discussion_r103444413,silasdavis
https://github.com/hyperledger/burrow/pull/510,https://github.com/hyperledger/burrow/pull/510,this is still for 0.16.0,8af5ac097832fe954d2a4e2936a117ee923760d3,2017-02-24 18:02:23,102996670,"@@ -32,7 +32,7 @@ const (
 	// Minor version component of the current release
 	erisVersionMinor = 16
 	// Patch version component of the current release
-	erisVersionPatch = 0
+	erisVersionPatch = 1",,2017-02-24 18:06:42,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102996670,https://github.com/hyperledger/burrow/pull/510#discussion_r102996670,benjaminbollen
https://github.com/hyperledger/burrow/pull/508,https://github.com/hyperledger/burrow/pull/508,these are great flags to have,4626fa2ddab44c67b68328f938797dd8c07405ba,2017-02-23 23:29:04,102846077,"@@ -64,17 +69,21 @@ func (tmintConfig *TendermintConfig) AssertTendermintDefaults(chainId, workDir,
 	tmintConfig.SetDefault(""fast_sync"", true)
 	tmintConfig.SetDefault(""skip_upnp"", false)
 	tmintConfig.SetDefault(""addrbook_file"", path.Join(rootDir, ""addrbook.json""))
+	tmintConfig.SetDefault(""addrbook_strict"", true) // disable to allow connections locally
+	tmintConfig.SetDefault(""pex_reactor"", false)    // enable for peer exchange
 	tmintConfig.SetDefault(""priv_validator_file"", path.Join(rootDir, ""priv_validator.json""))
 	tmintConfig.SetDefault(""db_backend"", ""leveldb"")
 	tmintConfig.SetDefault(""db_dir"", dataDir)
 	tmintConfig.SetDefault(""log_level"", ""info"")
 	tmintConfig.SetDefault(""rpc_laddr"", """")
 	tmintConfig.SetDefault(""prof_laddr"", """")
 	tmintConfig.SetDefault(""revision_file"", path.Join(workDir, ""revision""))
-	tmintConfig.SetDefault(""cswal"", path.Join(dataDir, ""cswal""))
-	tmintConfig.SetDefault(""cswal_light"", false)
+	tmintConfig.SetDefault(""cs_wal_dir"", path.Join(dataDir,""cs.wal""))
+	tmintConfig.SetDefault(""cs_wal_light"", false)
+	tmintConfig.SetDefault(""filter_peers"", false)",29,2017-02-23 23:30:02,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102846077,https://github.com/hyperledger/burrow/pull/508#discussion_r102846077,benjaminbollen
https://github.com/hyperledger/burrow/pull/508,https://github.com/hyperledger/burrow/pull/508,nice!,4626fa2ddab44c67b68328f938797dd8c07405ba,2017-02-23 23:29:18,102846116,"@@ -64,17 +69,21 @@ func (tmintConfig *TendermintConfig) AssertTendermintDefaults(chainId, workDir,
 	tmintConfig.SetDefault(""fast_sync"", true)
 	tmintConfig.SetDefault(""skip_upnp"", false)
 	tmintConfig.SetDefault(""addrbook_file"", path.Join(rootDir, ""addrbook.json""))
+	tmintConfig.SetDefault(""addrbook_strict"", true) // disable to allow connections locally
+	tmintConfig.SetDefault(""pex_reactor"", false)    // enable for peer exchange
 	tmintConfig.SetDefault(""priv_validator_file"", path.Join(rootDir, ""priv_validator.json""))
 	tmintConfig.SetDefault(""db_backend"", ""leveldb"")
 	tmintConfig.SetDefault(""db_dir"", dataDir)
 	tmintConfig.SetDefault(""log_level"", ""info"")
 	tmintConfig.SetDefault(""rpc_laddr"", """")
 	tmintConfig.SetDefault(""prof_laddr"", """")
 	tmintConfig.SetDefault(""revision_file"", path.Join(workDir, ""revision""))
-	tmintConfig.SetDefault(""cswal"", path.Join(dataDir, ""cswal""))
-	tmintConfig.SetDefault(""cswal_light"", false)
+	tmintConfig.SetDefault(""cs_wal_dir"", path.Join(dataDir,""cs.wal""))
+	tmintConfig.SetDefault(""cs_wal_light"", false)
+	tmintConfig.SetDefault(""filter_peers"", false)
 
-	tmintConfig.SetDefault(""block_size"", 10000)
+	tmintConfig.SetDefault(""block_size"", 10000)      // max number of txs
+	tmintConfig.SetDefault(""block_part_size"", 65536) // part size 64K",33,2017-02-23 23:30:02,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102846116,https://github.com/hyperledger/burrow/pull/508#discussion_r102846116,benjaminbollen
https://github.com/hyperledger/burrow/pull/507,https://github.com/hyperledger/burrow/pull/507,"Ethereum takes the right most 20 bytes of the 256bit Keccak digest; not the first 20 bytes;

see eris-keys here https://github.com/eris-ltd/eris-keys/blob/master/crypto/key.go#L152-L153
or also here http://bitcoin.stackexchange.com/questions/42055/what-is-the-approach-to-calculate-an-ethereum-address-from-a-256-bit-private-key",4506df7cc58d5a5637b98781a35bc312a24faeb4,2017-02-23 16:22:46,102752406,"@@ -247,14 +247,27 @@ func (contract *SNativeContractDescription) Dispatch(appState AppState,
 	return function.F(appState, caller, remainingArgs, gas)
 }
 
-// We define the address of an SNative contact as the simplest possible hash of
-// its canonical name
-func (contract *SNativeContractDescription) Address() Word256 {
-	return LeftPadWord256([]byte(contract.Name))
+// We define the address of an SNative contact as the first 20 bytes of the sha3
+// hash of its name
+func (contract *SNativeContractDescription) Address() abi.Address {
+	var address abi.Address
+	copy(address[:], sha3.Sha3([]byte(contract.Name))[:abi.AddressLength])",,2017-02-23 21:11:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102752406,https://github.com/hyperledger/burrow/pull/507#discussion_r102752406,benjaminbollen
https://github.com/hyperledger/burrow/pull/507,https://github.com/hyperledger/burrow/pull/507,"that's of a public key though, so it's kind of unrelated... We could copy, but I can't see how it will make any difference. The point is just to have a uniform hash over the 20 bytes.",4506df7cc58d5a5637b98781a35bc312a24faeb4,2017-02-23 16:26:13,102753430,"@@ -247,14 +247,27 @@ func (contract *SNativeContractDescription) Dispatch(appState AppState,
 	return function.F(appState, caller, remainingArgs, gas)
 }
 
-// We define the address of an SNative contact as the simplest possible hash of
-// its canonical name
-func (contract *SNativeContractDescription) Address() Word256 {
-	return LeftPadWord256([]byte(contract.Name))
+// We define the address of an SNative contact as the first 20 bytes of the sha3
+// hash of its name
+func (contract *SNativeContractDescription) Address() abi.Address {
+	var address abi.Address
+	copy(address[:], sha3.Sha3([]byte(contract.Name))[:abi.AddressLength])",,2017-02-23 21:11:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102753430,https://github.com/hyperledger/burrow/pull/507#discussion_r102753430,silasdavis
https://github.com/hyperledger/burrow/pull/502,https://github.com/hyperledger/burrow/pull/502,why is this changed; a requirement or an improvement?,081628063cb5949859218e1f632e2b57f0619dfc,2017-02-23 12:55:14,102706082,"@@ -55,7 +55,7 @@ func Multiplex(events ...EventEmitter) *multiplexedEvents {
 
 // The events struct has methods for working with events.
 type events struct {
-	eventSwitch *go_events.EventSwitch
+	eventSwitch go_events.EventSwitch",14,2017-02-23 18:02:45,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102706082,https://github.com/hyperledger/burrow/pull/502#discussion_r102706082,benjaminbollen
https://github.com/hyperledger/burrow/pull/502,https://github.com/hyperledger/burrow/pull/502,best to remember to remove //space above here matters now ;),081628063cb5949859218e1f632e2b57f0619dfc,2017-02-23 18:22:43,102781298,"@@ -1,4 +1,3 @@
-// +build integration
 
 // Space above here matters",3,2017-02-23 18:23:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102781298,https://github.com/hyperledger/burrow/pull/502#discussion_r102781298,benjaminbollen
https://github.com/hyperledger/burrow/pull/502,https://github.com/hyperledger/burrow/pull/502,we can remove this from the config,081628063cb5949859218e1f632e2b57f0619dfc,2017-02-23 18:23:01,102781380,"@@ -135,21 +135,19 @@ genesis_file = ""genesis.json""
 
 ################################################################################
 ##
-## Tendermint Socket Protocol (TMSP)
-## version 0.6.0
+## Tendermint Socket Protocol (abci)
 ##
-## TMSP expects a tendermint consensus process to run and connect to Eris-DB
+## abci expects a tendermint consensus process to run and connect to Eris-DB
 ##
 ################################################################################
 
-[tmsp]
+[abci]
 # listener address for accepting tendermint socket protocol connections
 listener = ""tcp://0.0.0.0:46658""
 
 ################################################################################
-##
+##yeah we had partial support for that with TMSP",35,2017-02-23 18:23:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102781380,https://github.com/hyperledger/burrow/pull/502#discussion_r102781380,benjaminbollen
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,I don't think this is necessary `DefaultAccountPermissions` is a struct value so it's copied on assignment.,fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 19:59:32,102302886,"@@ -0,0 +1,85 @@
+// Copyright 2015-2017 Monax Industries Limited.
+// This file is part of the Monax platform (Monax)
+
+// Monax is free software: you can use, redistribute it and/or modify
+// it only under the terms of the GNU General Public License, version
+// 3, as published by the Free Software Foundation.
+
+// Monax is distributed WITHOUT ANY WARRANTY pursuant to
+// the terms of the Gnu General Public Licence, version 3, including
+// (but not limited to) Clause 15 thereof. See the text of the
+// GNU General Public License, version 3 for full terms.
+
+// You should have received a copy of the GNU General Public License,
+// version 3, with Monax.  If not, see <http://www.gnu.org/licenses/>.
+
+package genesis
+
+import (
+	""bytes""
+	""encoding/json""
+	""time""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+	wire ""github.com/tendermint/go-wire""
+)
+
+// MakeGenesisDocFromAccounts takes a chainName and a slice of pointers to GenesisAccount,
+// and a slice of pointers to GenesisValidator to construct a GenesisDoc, or returns an error on
+// failure.  In particular MakeGenesisDocFromAccount uses the local time as a
+// timestamp for the GenesisDoc.
+func MakeGenesisDocFromAccounts(chainName string, accounts []*GenesisAccount,
+	validators []*GenesisValidator) (GenesisDoc, error) {
+
+	// TODO: assert valid accounts and validators
+	// TODO: [ben] expose setting global permissions
+	globalPermissions := ptypes.DefaultAccountPermissions.Clone()",36,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102302886,https://github.com/hyperledger/burrow/pull/501#discussion_r102302886,silasdavis
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,"Similar to other comment, if it's convenient to pass `genesisAccounts []GenesisAccount` then we could probably get away without a clone... (though we do have pointers from `GenesisAccount` to `AccountPermissions`, but I don't think we accidentally mutate here)",fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:03:44,102303851,"@@ -28,6 +28,25 @@ func GenerateKnown(chainID, accountsPathCSV, validatorsPathCSV string) (string,
 }
 
 //------------------------------------------------------------------------------------
+// interface functions that are consumed by monax tooling
+
+func GenerateGenesisFileBytes(chainName string, genesisAccounts []*GenesisAccount,",6,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102303851,https://github.com/hyperledger/burrow/pull/501#discussion_r102303851,silasdavis
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,I would rather replace all magic number references with named constants,fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:05:19,102304215,"@@ -0,0 +1,80 @@
+// Copyright 2015-2017 Monax Industries Limited.
+// This file is part of the Monax platform (Monax)
+
+// Monax is free software: you can use, redistribute it and/or modify
+// it only under the terms of the GNU General Public License, version
+// 3, as published by the Free Software Foundation.
+
+// Monax is distributed WITHOUT ANY WARRANTY pursuant to
+// the terms of the Gnu General Public Licence, version 3, including
+// (but not limited to) Clause 15 thereof. See the text of the
+// GNU General Public License, version 3 for full terms.
+
+// You should have received a copy of the GNU General Public License,
+// version 3, with Monax.  If not, see <http://www.gnu.org/licenses/>.
+
+package genesis
+
+import (
+	""fmt""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+
+	""github.com/tendermint/go-crypto""
+)
+
+// NewGenesisAccount returns a new GenesisAccount
+func NewGenesisAccount(address []byte, amount int64, name string,
+	permissions *ptypes.AccountPermissions) *GenesisAccount {
+	return &GenesisAccount{
+		Address:     address,
+		Amount:      amount,
+		Name:        name,
+		Permissions: permissions,
+	}
+}
+
+func NewGenesisValidator(amount int64, name string, unbondToAddress []byte,
+	unbondAmount int64, keyType string, publicKeyBytes []byte) (*GenesisValidator, error) {
+	// convert the key bytes into a typed fixed size byte array
+	var typedPublicKeyBytes []byte
+	switch keyType {
+	case ""ed25519"":
+		// TODO: [ben] functionality and checks need to be inherit in the type
+		if len(publicKeyBytes) != 32 {",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102304215,https://github.com/hyperledger/burrow/pull/501#discussion_r102304215,silasdavis
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,likewise would prefer `publicKeyLength + 1`,fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:05:41,102304293,"@@ -0,0 +1,80 @@
+// Copyright 2015-2017 Monax Industries Limited.
+// This file is part of the Monax platform (Monax)
+
+// Monax is free software: you can use, redistribute it and/or modify
+// it only under the terms of the GNU General Public License, version
+// 3, as published by the Free Software Foundation.
+
+// Monax is distributed WITHOUT ANY WARRANTY pursuant to
+// the terms of the Gnu General Public Licence, version 3, including
+// (but not limited to) Clause 15 thereof. See the text of the
+// GNU General Public License, version 3 for full terms.
+
+// You should have received a copy of the GNU General Public License,
+// version 3, with Monax.  If not, see <http://www.gnu.org/licenses/>.
+
+package genesis
+
+import (
+	""fmt""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+
+	""github.com/tendermint/go-crypto""
+)
+
+// NewGenesisAccount returns a new GenesisAccount
+func NewGenesisAccount(address []byte, amount int64, name string,
+	permissions *ptypes.AccountPermissions) *GenesisAccount {
+	return &GenesisAccount{
+		Address:     address,
+		Amount:      amount,
+		Name:        name,
+		Permissions: permissions,
+	}
+}
+
+func NewGenesisValidator(amount int64, name string, unbondToAddress []byte,
+	unbondAmount int64, keyType string, publicKeyBytes []byte) (*GenesisValidator, error) {
+	// convert the key bytes into a typed fixed size byte array
+	var typedPublicKeyBytes []byte
+	switch keyType {
+	case ""ed25519"":
+		// TODO: [ben] functionality and checks need to be inherit in the type
+		if len(publicKeyBytes) != 32 {
+			return nil, fmt.Errorf(""Invalid length provided for ed25519 public key (len %v)"",
+				len(publicKeyBytes))
+		}
+		// ed25519 has type byte 0x01
+		typedPublicKeyBytes = make([]byte, 33)",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102304293,https://github.com/hyperledger/burrow/pull/501#discussion_r102304293,silasdavis
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,again,fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:06:01,102304376,"@@ -0,0 +1,80 @@
+// Copyright 2015-2017 Monax Industries Limited.
+// This file is part of the Monax platform (Monax)
+
+// Monax is free software: you can use, redistribute it and/or modify
+// it only under the terms of the GNU General Public License, version
+// 3, as published by the Free Software Foundation.
+
+// Monax is distributed WITHOUT ANY WARRANTY pursuant to
+// the terms of the Gnu General Public Licence, version 3, including
+// (but not limited to) Clause 15 thereof. See the text of the
+// GNU General Public License, version 3 for full terms.
+
+// You should have received a copy of the GNU General Public License,
+// version 3, with Monax.  If not, see <http://www.gnu.org/licenses/>.
+
+package genesis
+
+import (
+	""fmt""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+
+	""github.com/tendermint/go-crypto""
+)
+
+// NewGenesisAccount returns a new GenesisAccount
+func NewGenesisAccount(address []byte, amount int64, name string,
+	permissions *ptypes.AccountPermissions) *GenesisAccount {
+	return &GenesisAccount{
+		Address:     address,
+		Amount:      amount,
+		Name:        name,
+		Permissions: permissions,
+	}
+}
+
+func NewGenesisValidator(amount int64, name string, unbondToAddress []byte,
+	unbondAmount int64, keyType string, publicKeyBytes []byte) (*GenesisValidator, error) {
+	// convert the key bytes into a typed fixed size byte array
+	var typedPublicKeyBytes []byte
+	switch keyType {
+	case ""ed25519"":
+		// TODO: [ben] functionality and checks need to be inherit in the type
+		if len(publicKeyBytes) != 32 {
+			return nil, fmt.Errorf(""Invalid length provided for ed25519 public key (len %v)"",
+				len(publicKeyBytes))
+		}
+		// ed25519 has type byte 0x01
+		typedPublicKeyBytes = make([]byte, 33)
+		// prepend type byte to public key
+		typedPublicKeyBytes = append([]byte{crypto.PubKeyTypeEd25519}, publicKeyBytes...)
+	case ""secp256k1"":
+		if len(publicKeyBytes) != 64 {",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102304376,https://github.com/hyperledger/burrow/pull/501#discussion_r102304376,silasdavis
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,same,fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:06:09,102304407,"@@ -0,0 +1,80 @@
+// Copyright 2015-2017 Monax Industries Limited.
+// This file is part of the Monax platform (Monax)
+
+// Monax is free software: you can use, redistribute it and/or modify
+// it only under the terms of the GNU General Public License, version
+// 3, as published by the Free Software Foundation.
+
+// Monax is distributed WITHOUT ANY WARRANTY pursuant to
+// the terms of the Gnu General Public Licence, version 3, including
+// (but not limited to) Clause 15 thereof. See the text of the
+// GNU General Public License, version 3 for full terms.
+
+// You should have received a copy of the GNU General Public License,
+// version 3, with Monax.  If not, see <http://www.gnu.org/licenses/>.
+
+package genesis
+
+import (
+	""fmt""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+
+	""github.com/tendermint/go-crypto""
+)
+
+// NewGenesisAccount returns a new GenesisAccount
+func NewGenesisAccount(address []byte, amount int64, name string,
+	permissions *ptypes.AccountPermissions) *GenesisAccount {
+	return &GenesisAccount{
+		Address:     address,
+		Amount:      amount,
+		Name:        name,
+		Permissions: permissions,
+	}
+}
+
+func NewGenesisValidator(amount int64, name string, unbondToAddress []byte,
+	unbondAmount int64, keyType string, publicKeyBytes []byte) (*GenesisValidator, error) {
+	// convert the key bytes into a typed fixed size byte array
+	var typedPublicKeyBytes []byte
+	switch keyType {
+	case ""ed25519"":
+		// TODO: [ben] functionality and checks need to be inherit in the type
+		if len(publicKeyBytes) != 32 {
+			return nil, fmt.Errorf(""Invalid length provided for ed25519 public key (len %v)"",
+				len(publicKeyBytes))
+		}
+		// ed25519 has type byte 0x01
+		typedPublicKeyBytes = make([]byte, 33)
+		// prepend type byte to public key
+		typedPublicKeyBytes = append([]byte{crypto.PubKeyTypeEd25519}, publicKeyBytes...)
+	case ""secp256k1"":
+		if len(publicKeyBytes) != 64 {
+			return nil, fmt.Errorf(""Invalid length provided for secp256k1 public key (len %v)"",
+				len(publicKeyBytes))
+		}
+		// secp256k1 has type byte 0x02
+		typedPublicKeyBytes = make([]byte, 65)",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102304407,https://github.com/hyperledger/burrow/pull/501#discussion_r102304407,silasdavis
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,I can see how this is sort of defensive. But I wonder if it is a step too far. Ultimately we have to trust that  we are not being handed internal bytes slice that we might mutate. We can see for sure that we are not being handed a reference to internal bytes as it is.,fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:09:33,102305195,"@@ -65,3 +94,71 @@ func GenesisDocFromJSON(jsonBlob []byte) (genState *GenesisDoc) {
 	}
 	return
 }
+
+//------------------------------------------------------------
+// Methods for genesis types
+// NOTE: breaks formatting convention
+// TODO: split each genesis type in its own file definition
+
+//------------------------------------------------------------
+// GenesisAccount methods
+
+// Clone clones the genesis account
+func (genesisAccount *GenesisAccount) Clone() GenesisAccount {
+	// clone the address
+	addressClone := make([]byte, len(genesisAccount.Address))
+	copy(addressClone, genesisAccount.Address)
+	// clone the account permissions
+	accountPermissionsClone := genesisAccount.Permissions.Clone()
+	return GenesisAccount{
+		Address:     addressClone,
+		Amount:      genesisAccount.Amount,
+		Name:        genesisAccount.Name,
+		Permissions: &accountPermissionsClone,
+	}
+}
+
+//------------------------------------------------------------
+// GenesisValidator methods
+
+// Clone clones the genesis validator
+func (genesisValidator *GenesisValidator) Clone() (GenesisValidator, error) {
+	if genesisValidator == nil {
+		return GenesisValidator{}, fmt.Errorf(""Cannot clone nil GenesisValidator."")
+	}
+	if genesisValidator.PubKey == nil {
+		return GenesisValidator{}, fmt.Errorf(""Invalid GenesisValidator %s with nil public key."",
+			genesisValidator.Name)
+	}
+	// clone the public key by writing and reading over go-wire serialisation
+	// TODO! write unit test to see whether this is correct
+	publicKeyClone, err := crypto.PubKeyFromBytes(genesisValidator.PubKey.Bytes())",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102305195,https://github.com/hyperledger/burrow/pull/501#discussion_r102305195,silasdavis
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,"Yes, but is a struct `AccountPermissions` of a struct `BasePermissions` and a slice of `strings`; I believe - but not sure - that the struct `BasePermissions` is treated as a pointer essentially; but definitely the `Roles []string` is an effective pointer;

secondly, genesis is currently constructed with `Params` as a pointer to a `GenesisParams` which is a pointer to an `AccountPermissions`;  I dont particularly like this construction; but I didnt want to end up with a `GenesisDoc` that didnt own its own data;

Arguably this does read very defensive",fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:26:55,102308944,"@@ -0,0 +1,85 @@
+// Copyright 2015-2017 Monax Industries Limited.
+// This file is part of the Monax platform (Monax)
+
+// Monax is free software: you can use, redistribute it and/or modify
+// it only under the terms of the GNU General Public License, version
+// 3, as published by the Free Software Foundation.
+
+// Monax is distributed WITHOUT ANY WARRANTY pursuant to
+// the terms of the Gnu General Public Licence, version 3, including
+// (but not limited to) Clause 15 thereof. See the text of the
+// GNU General Public License, version 3 for full terms.
+
+// You should have received a copy of the GNU General Public License,
+// version 3, with Monax.  If not, see <http://www.gnu.org/licenses/>.
+
+package genesis
+
+import (
+	""bytes""
+	""encoding/json""
+	""time""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+	wire ""github.com/tendermint/go-wire""
+)
+
+// MakeGenesisDocFromAccounts takes a chainName and a slice of pointers to GenesisAccount,
+// and a slice of pointers to GenesisValidator to construct a GenesisDoc, or returns an error on
+// failure.  In particular MakeGenesisDocFromAccount uses the local time as a
+// timestamp for the GenesisDoc.
+func MakeGenesisDocFromAccounts(chainName string, accounts []*GenesisAccount,
+	validators []*GenesisValidator) (GenesisDoc, error) {
+
+	// TODO: assert valid accounts and validators
+	// TODO: [ben] expose setting global permissions
+	globalPermissions := ptypes.DefaultAccountPermissions.Clone()",36,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102308944,https://github.com/hyperledger/burrow/pull/501#discussion_r102308944,benjaminbollen
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,"in tooling there is a usage of passing slices of pointers; which is justified there because they are passed around a lot during construction;

this is why i deliberately gave tooling an interface that respects the `[ ]*T`; but `GenesisDoc` is constructed with `[ ]T` and once `GenesisDoc` is constructed changing the original argument `T` should not affect the `GenesisDoc`",fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:30:11,102309593,"@@ -28,6 +28,25 @@ func GenerateKnown(chainID, accountsPathCSV, validatorsPathCSV string) (string,
 }
 
 //------------------------------------------------------------------------------------
+// interface functions that are consumed by monax tooling
+
+func GenerateGenesisFileBytes(chainName string, genesisAccounts []*GenesisAccount,",6,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102309593,https://github.com/hyperledger/burrow/pull/501#discussion_r102309593,benjaminbollen
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,"yes, but `tendermint/go-crypto/pub_key.go` does not have this definition; and while I agree with you.  I prefer to hold off making that definition until (very soon) we make `eris-db/crypto`",fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:31:59,102310005,"@@ -0,0 +1,80 @@
+// Copyright 2015-2017 Monax Industries Limited.
+// This file is part of the Monax platform (Monax)
+
+// Monax is free software: you can use, redistribute it and/or modify
+// it only under the terms of the GNU General Public License, version
+// 3, as published by the Free Software Foundation.
+
+// Monax is distributed WITHOUT ANY WARRANTY pursuant to
+// the terms of the Gnu General Public Licence, version 3, including
+// (but not limited to) Clause 15 thereof. See the text of the
+// GNU General Public License, version 3 for full terms.
+
+// You should have received a copy of the GNU General Public License,
+// version 3, with Monax.  If not, see <http://www.gnu.org/licenses/>.
+
+package genesis
+
+import (
+	""fmt""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+
+	""github.com/tendermint/go-crypto""
+)
+
+// NewGenesisAccount returns a new GenesisAccount
+func NewGenesisAccount(address []byte, amount int64, name string,
+	permissions *ptypes.AccountPermissions) *GenesisAccount {
+	return &GenesisAccount{
+		Address:     address,
+		Amount:      amount,
+		Name:        name,
+		Permissions: permissions,
+	}
+}
+
+func NewGenesisValidator(amount int64, name string, unbondToAddress []byte,
+	unbondAmount int64, keyType string, publicKeyBytes []byte) (*GenesisValidator, error) {
+	// convert the key bytes into a typed fixed size byte array
+	var typedPublicKeyBytes []byte
+	switch keyType {
+	case ""ed25519"":
+		// TODO: [ben] functionality and checks need to be inherit in the type
+		if len(publicKeyBytes) != 32 {",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102310005,https://github.com/hyperledger/burrow/pull/501#discussion_r102310005,benjaminbollen
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,"yes, on the same page, but without a `const`, `32+1` is a bit weird ",fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:33:02,102310238,"@@ -0,0 +1,80 @@
+// Copyright 2015-2017 Monax Industries Limited.
+// This file is part of the Monax platform (Monax)
+
+// Monax is free software: you can use, redistribute it and/or modify
+// it only under the terms of the GNU General Public License, version
+// 3, as published by the Free Software Foundation.
+
+// Monax is distributed WITHOUT ANY WARRANTY pursuant to
+// the terms of the Gnu General Public Licence, version 3, including
+// (but not limited to) Clause 15 thereof. See the text of the
+// GNU General Public License, version 3 for full terms.
+
+// You should have received a copy of the GNU General Public License,
+// version 3, with Monax.  If not, see <http://www.gnu.org/licenses/>.
+
+package genesis
+
+import (
+	""fmt""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+
+	""github.com/tendermint/go-crypto""
+)
+
+// NewGenesisAccount returns a new GenesisAccount
+func NewGenesisAccount(address []byte, amount int64, name string,
+	permissions *ptypes.AccountPermissions) *GenesisAccount {
+	return &GenesisAccount{
+		Address:     address,
+		Amount:      amount,
+		Name:        name,
+		Permissions: permissions,
+	}
+}
+
+func NewGenesisValidator(amount int64, name string, unbondToAddress []byte,
+	unbondAmount int64, keyType string, publicKeyBytes []byte) (*GenesisValidator, error) {
+	// convert the key bytes into a typed fixed size byte array
+	var typedPublicKeyBytes []byte
+	switch keyType {
+	case ""ed25519"":
+		// TODO: [ben] functionality and checks need to be inherit in the type
+		if len(publicKeyBytes) != 32 {
+			return nil, fmt.Errorf(""Invalid length provided for ed25519 public key (len %v)"",
+				len(publicKeyBytes))
+		}
+		// ed25519 has type byte 0x01
+		typedPublicKeyBytes = make([]byte, 33)",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102310238,https://github.com/hyperledger/burrow/pull/501#discussion_r102310238,benjaminbollen
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,"Having a `Clone` in general is very good practice, because it allows you to make it explicit when you're copying data; and as a result avoid copying it when you don't have to.

Here again Clone is introduced, because on construction of the genesisDoc I want to have unique ownership of GenesisDoc",fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:35:57,102310876,"@@ -65,3 +94,71 @@ func GenesisDocFromJSON(jsonBlob []byte) (genState *GenesisDoc) {
 	}
 	return
 }
+
+//------------------------------------------------------------
+// Methods for genesis types
+// NOTE: breaks formatting convention
+// TODO: split each genesis type in its own file definition
+
+//------------------------------------------------------------
+// GenesisAccount methods
+
+// Clone clones the genesis account
+func (genesisAccount *GenesisAccount) Clone() GenesisAccount {
+	// clone the address
+	addressClone := make([]byte, len(genesisAccount.Address))
+	copy(addressClone, genesisAccount.Address)
+	// clone the account permissions
+	accountPermissionsClone := genesisAccount.Permissions.Clone()
+	return GenesisAccount{
+		Address:     addressClone,
+		Amount:      genesisAccount.Amount,
+		Name:        genesisAccount.Name,
+		Permissions: &accountPermissionsClone,
+	}
+}
+
+//------------------------------------------------------------
+// GenesisValidator methods
+
+// Clone clones the genesis validator
+func (genesisValidator *GenesisValidator) Clone() (GenesisValidator, error) {
+	if genesisValidator == nil {
+		return GenesisValidator{}, fmt.Errorf(""Cannot clone nil GenesisValidator."")
+	}
+	if genesisValidator.PubKey == nil {
+		return GenesisValidator{}, fmt.Errorf(""Invalid GenesisValidator %s with nil public key."",
+			genesisValidator.Name)
+	}
+	// clone the public key by writing and reading over go-wire serialisation
+	// TODO! write unit test to see whether this is correct
+	publicKeyClone, err := crypto.PubKeyFromBytes(genesisValidator.PubKey.Bytes())",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102310876,https://github.com/hyperledger/burrow/pull/501#discussion_r102310876,benjaminbollen
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,"The inner struct is just another value, the memory is copied in a single pass. See: https://play.golang.org/p/Ut_7gZ3TyJ

Yeah the slice does give you mutable access. But this is go, I think we need to choose our battles. I'd rather we were passing immutable sequences of values but we're not. And in the event we are not writing back to the roles, and that would be a weird thing to do.",fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:36:16,102310942,"@@ -0,0 +1,85 @@
+// Copyright 2015-2017 Monax Industries Limited.
+// This file is part of the Monax platform (Monax)
+
+// Monax is free software: you can use, redistribute it and/or modify
+// it only under the terms of the GNU General Public License, version
+// 3, as published by the Free Software Foundation.
+
+// Monax is distributed WITHOUT ANY WARRANTY pursuant to
+// the terms of the Gnu General Public Licence, version 3, including
+// (but not limited to) Clause 15 thereof. See the text of the
+// GNU General Public License, version 3 for full terms.
+
+// You should have received a copy of the GNU General Public License,
+// version 3, with Monax.  If not, see <http://www.gnu.org/licenses/>.
+
+package genesis
+
+import (
+	""bytes""
+	""encoding/json""
+	""time""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+	wire ""github.com/tendermint/go-wire""
+)
+
+// MakeGenesisDocFromAccounts takes a chainName and a slice of pointers to GenesisAccount,
+// and a slice of pointers to GenesisValidator to construct a GenesisDoc, or returns an error on
+// failure.  In particular MakeGenesisDocFromAccount uses the local time as a
+// timestamp for the GenesisDoc.
+func MakeGenesisDocFromAccounts(chainName string, accounts []*GenesisAccount,
+	validators []*GenesisValidator) (GenesisDoc, error) {
+
+	// TODO: assert valid accounts and validators
+	// TODO: [ben] expose setting global permissions
+	globalPermissions := ptypes.DefaultAccountPermissions.Clone()",36,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102310942,https://github.com/hyperledger/burrow/pull/501#discussion_r102310942,silasdavis
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,thought that might be the case. Makes sense.,fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:37:10,102311156,"@@ -28,6 +28,25 @@ func GenerateKnown(chainID, accountsPathCSV, validatorsPathCSV string) (string,
 }
 
 //------------------------------------------------------------------------------------
+// interface functions that are consumed by monax tooling
+
+func GenerateGenesisFileBytes(chainName string, genesisAccounts []*GenesisAccount,",6,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102311156,https://github.com/hyperledger/burrow/pull/501#discussion_r102311156,silasdavis
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,"yep, which is why you should introduce the constant. In the same file if necessary.",fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:37:52,102311303,"@@ -0,0 +1,80 @@
+// Copyright 2015-2017 Monax Industries Limited.
+// This file is part of the Monax platform (Monax)
+
+// Monax is free software: you can use, redistribute it and/or modify
+// it only under the terms of the GNU General Public License, version
+// 3, as published by the Free Software Foundation.
+
+// Monax is distributed WITHOUT ANY WARRANTY pursuant to
+// the terms of the Gnu General Public Licence, version 3, including
+// (but not limited to) Clause 15 thereof. See the text of the
+// GNU General Public License, version 3 for full terms.
+
+// You should have received a copy of the GNU General Public License,
+// version 3, with Monax.  If not, see <http://www.gnu.org/licenses/>.
+
+package genesis
+
+import (
+	""fmt""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+
+	""github.com/tendermint/go-crypto""
+)
+
+// NewGenesisAccount returns a new GenesisAccount
+func NewGenesisAccount(address []byte, amount int64, name string,
+	permissions *ptypes.AccountPermissions) *GenesisAccount {
+	return &GenesisAccount{
+		Address:     address,
+		Amount:      amount,
+		Name:        name,
+		Permissions: permissions,
+	}
+}
+
+func NewGenesisValidator(amount int64, name string, unbondToAddress []byte,
+	unbondAmount int64, keyType string, publicKeyBytes []byte) (*GenesisValidator, error) {
+	// convert the key bytes into a typed fixed size byte array
+	var typedPublicKeyBytes []byte
+	switch keyType {
+	case ""ed25519"":
+		// TODO: [ben] functionality and checks need to be inherit in the type
+		if len(publicKeyBytes) != 32 {
+			return nil, fmt.Errorf(""Invalid length provided for ed25519 public key (len %v)"",
+				len(publicKeyBytes))
+		}
+		// ed25519 has type byte 0x01
+		typedPublicKeyBytes = make([]byte, 33)",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102311303,https://github.com/hyperledger/burrow/pull/501#discussion_r102311303,silasdavis
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,"We should just name it in the same file, let's not make the perfect an enemy of the good.",fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:38:14,102311367,"@@ -0,0 +1,80 @@
+// Copyright 2015-2017 Monax Industries Limited.
+// This file is part of the Monax platform (Monax)
+
+// Monax is free software: you can use, redistribute it and/or modify
+// it only under the terms of the GNU General Public License, version
+// 3, as published by the Free Software Foundation.
+
+// Monax is distributed WITHOUT ANY WARRANTY pursuant to
+// the terms of the Gnu General Public Licence, version 3, including
+// (but not limited to) Clause 15 thereof. See the text of the
+// GNU General Public License, version 3 for full terms.
+
+// You should have received a copy of the GNU General Public License,
+// version 3, with Monax.  If not, see <http://www.gnu.org/licenses/>.
+
+package genesis
+
+import (
+	""fmt""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+
+	""github.com/tendermint/go-crypto""
+)
+
+// NewGenesisAccount returns a new GenesisAccount
+func NewGenesisAccount(address []byte, amount int64, name string,
+	permissions *ptypes.AccountPermissions) *GenesisAccount {
+	return &GenesisAccount{
+		Address:     address,
+		Amount:      amount,
+		Name:        name,
+		Permissions: permissions,
+	}
+}
+
+func NewGenesisValidator(amount int64, name string, unbondToAddress []byte,
+	unbondAmount int64, keyType string, publicKeyBytes []byte) (*GenesisValidator, error) {
+	// convert the key bytes into a typed fixed size byte array
+	var typedPublicKeyBytes []byte
+	switch keyType {
+	case ""ed25519"":
+		// TODO: [ben] functionality and checks need to be inherit in the type
+		if len(publicKeyBytes) != 32 {",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102311367,https://github.com/hyperledger/burrow/pull/501#discussion_r102311367,silasdavis
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,"I do get it, it's just using non-pointer values is idiomatic way of doing this in go. If this is really such a special case that we need to be extra explicit about copying then maybe. But my concern is that fighting the language like this leads to a mess/a burden we cannot hope to (would not want to) live up to everywhere.

I particularly don't like this given that we are running it through go-wire for little reason.",fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:41:19,102312017,"@@ -65,3 +94,71 @@ func GenesisDocFromJSON(jsonBlob []byte) (genState *GenesisDoc) {
 	}
 	return
 }
+
+//------------------------------------------------------------
+// Methods for genesis types
+// NOTE: breaks formatting convention
+// TODO: split each genesis type in its own file definition
+
+//------------------------------------------------------------
+// GenesisAccount methods
+
+// Clone clones the genesis account
+func (genesisAccount *GenesisAccount) Clone() GenesisAccount {
+	// clone the address
+	addressClone := make([]byte, len(genesisAccount.Address))
+	copy(addressClone, genesisAccount.Address)
+	// clone the account permissions
+	accountPermissionsClone := genesisAccount.Permissions.Clone()
+	return GenesisAccount{
+		Address:     addressClone,
+		Amount:      genesisAccount.Amount,
+		Name:        genesisAccount.Name,
+		Permissions: &accountPermissionsClone,
+	}
+}
+
+//------------------------------------------------------------
+// GenesisValidator methods
+
+// Clone clones the genesis validator
+func (genesisValidator *GenesisValidator) Clone() (GenesisValidator, error) {
+	if genesisValidator == nil {
+		return GenesisValidator{}, fmt.Errorf(""Cannot clone nil GenesisValidator."")
+	}
+	if genesisValidator.PubKey == nil {
+		return GenesisValidator{}, fmt.Errorf(""Invalid GenesisValidator %s with nil public key."",
+			genesisValidator.Name)
+	}
+	// clone the public key by writing and reading over go-wire serialisation
+	// TODO! write unit test to see whether this is correct
+	publicKeyClone, err := crypto.PubKeyFromBytes(genesisValidator.PubKey.Bytes())",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102312017,https://github.com/hyperledger/burrow/pull/501#discussion_r102312017,silasdavis
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,Im ok with introducing the constants and moving them later,fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:42:46,102312309,"@@ -0,0 +1,80 @@
+// Copyright 2015-2017 Monax Industries Limited.
+// This file is part of the Monax platform (Monax)
+
+// Monax is free software: you can use, redistribute it and/or modify
+// it only under the terms of the GNU General Public License, version
+// 3, as published by the Free Software Foundation.
+
+// Monax is distributed WITHOUT ANY WARRANTY pursuant to
+// the terms of the Gnu General Public Licence, version 3, including
+// (but not limited to) Clause 15 thereof. See the text of the
+// GNU General Public License, version 3 for full terms.
+
+// You should have received a copy of the GNU General Public License,
+// version 3, with Monax.  If not, see <http://www.gnu.org/licenses/>.
+
+package genesis
+
+import (
+	""fmt""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+
+	""github.com/tendermint/go-crypto""
+)
+
+// NewGenesisAccount returns a new GenesisAccount
+func NewGenesisAccount(address []byte, amount int64, name string,
+	permissions *ptypes.AccountPermissions) *GenesisAccount {
+	return &GenesisAccount{
+		Address:     address,
+		Amount:      amount,
+		Name:        name,
+		Permissions: permissions,
+	}
+}
+
+func NewGenesisValidator(amount int64, name string, unbondToAddress []byte,
+	unbondAmount int64, keyType string, publicKeyBytes []byte) (*GenesisValidator, error) {
+	// convert the key bytes into a typed fixed size byte array
+	var typedPublicKeyBytes []byte
+	switch keyType {
+	case ""ed25519"":
+		// TODO: [ben] functionality and checks need to be inherit in the type
+		if len(publicKeyBytes) != 32 {
+			return nil, fmt.Errorf(""Invalid length provided for ed25519 public key (len %v)"",
+				len(publicKeyBytes))
+		}
+		// ed25519 has type byte 0x01
+		typedPublicKeyBytes = make([]byte, 33)",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102312309,https://github.com/hyperledger/burrow/pull/501#discussion_r102312309,benjaminbollen
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,Im not sure whether it is fighting the language or fighting bad habits,fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:44:17,102312632,"@@ -65,3 +94,71 @@ func GenesisDocFromJSON(jsonBlob []byte) (genState *GenesisDoc) {
 	}
 	return
 }
+
+//------------------------------------------------------------
+// Methods for genesis types
+// NOTE: breaks formatting convention
+// TODO: split each genesis type in its own file definition
+
+//------------------------------------------------------------
+// GenesisAccount methods
+
+// Clone clones the genesis account
+func (genesisAccount *GenesisAccount) Clone() GenesisAccount {
+	// clone the address
+	addressClone := make([]byte, len(genesisAccount.Address))
+	copy(addressClone, genesisAccount.Address)
+	// clone the account permissions
+	accountPermissionsClone := genesisAccount.Permissions.Clone()
+	return GenesisAccount{
+		Address:     addressClone,
+		Amount:      genesisAccount.Amount,
+		Name:        genesisAccount.Name,
+		Permissions: &accountPermissionsClone,
+	}
+}
+
+//------------------------------------------------------------
+// GenesisValidator methods
+
+// Clone clones the genesis validator
+func (genesisValidator *GenesisValidator) Clone() (GenesisValidator, error) {
+	if genesisValidator == nil {
+		return GenesisValidator{}, fmt.Errorf(""Cannot clone nil GenesisValidator."")
+	}
+	if genesisValidator.PubKey == nil {
+		return GenesisValidator{}, fmt.Errorf(""Invalid GenesisValidator %s with nil public key."",
+			genesisValidator.Name)
+	}
+	// clone the public key by writing and reading over go-wire serialisation
+	// TODO! write unit test to see whether this is correct
+	publicKeyClone, err := crypto.PubKeyFromBytes(genesisValidator.PubKey.Bytes())",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102312632,https://github.com/hyperledger/burrow/pull/501#discussion_r102312632,benjaminbollen
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,"using go-wire was here rather elegant; otherwise it requires many lines of reflecting which keytype it is then copying it in the correct fixed size byte array and then casting it back to the interface;

in my opinion `interface PubKey` should have a `Clone()` but it does not; so using the available interfaces worked quite nicely",fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 20:46:12,102313047,"@@ -65,3 +94,71 @@ func GenesisDocFromJSON(jsonBlob []byte) (genState *GenesisDoc) {
 	}
 	return
 }
+
+//------------------------------------------------------------
+// Methods for genesis types
+// NOTE: breaks formatting convention
+// TODO: split each genesis type in its own file definition
+
+//------------------------------------------------------------
+// GenesisAccount methods
+
+// Clone clones the genesis account
+func (genesisAccount *GenesisAccount) Clone() GenesisAccount {
+	// clone the address
+	addressClone := make([]byte, len(genesisAccount.Address))
+	copy(addressClone, genesisAccount.Address)
+	// clone the account permissions
+	accountPermissionsClone := genesisAccount.Permissions.Clone()
+	return GenesisAccount{
+		Address:     addressClone,
+		Amount:      genesisAccount.Amount,
+		Name:        genesisAccount.Name,
+		Permissions: &accountPermissionsClone,
+	}
+}
+
+//------------------------------------------------------------
+// GenesisValidator methods
+
+// Clone clones the genesis validator
+func (genesisValidator *GenesisValidator) Clone() (GenesisValidator, error) {
+	if genesisValidator == nil {
+		return GenesisValidator{}, fmt.Errorf(""Cannot clone nil GenesisValidator."")
+	}
+	if genesisValidator.PubKey == nil {
+		return GenesisValidator{}, fmt.Errorf(""Invalid GenesisValidator %s with nil public key."",
+			genesisValidator.Name)
+	}
+	// clone the public key by writing and reading over go-wire serialisation
+	// TODO! write unit test to see whether this is correct
+	publicKeyClone, err := crypto.PubKeyFromBytes(genesisValidator.PubKey.Bytes())",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102313047,https://github.com/hyperledger/burrow/pull/501#discussion_r102313047,benjaminbollen
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,"> because it allows you to make it explicit when you're copying data; and as a result avoid copying it when you don't have to.

You are copying data exactly when you don't have to because `PubKey.Bytes()` does a copy itself (as it ought to) ",fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 21:11:33,102318645,"@@ -65,3 +94,71 @@ func GenesisDocFromJSON(jsonBlob []byte) (genState *GenesisDoc) {
 	}
 	return
 }
+
+//------------------------------------------------------------
+// Methods for genesis types
+// NOTE: breaks formatting convention
+// TODO: split each genesis type in its own file definition
+
+//------------------------------------------------------------
+// GenesisAccount methods
+
+// Clone clones the genesis account
+func (genesisAccount *GenesisAccount) Clone() GenesisAccount {
+	// clone the address
+	addressClone := make([]byte, len(genesisAccount.Address))
+	copy(addressClone, genesisAccount.Address)
+	// clone the account permissions
+	accountPermissionsClone := genesisAccount.Permissions.Clone()
+	return GenesisAccount{
+		Address:     addressClone,
+		Amount:      genesisAccount.Amount,
+		Name:        genesisAccount.Name,
+		Permissions: &accountPermissionsClone,
+	}
+}
+
+//------------------------------------------------------------
+// GenesisValidator methods
+
+// Clone clones the genesis validator
+func (genesisValidator *GenesisValidator) Clone() (GenesisValidator, error) {
+	if genesisValidator == nil {
+		return GenesisValidator{}, fmt.Errorf(""Cannot clone nil GenesisValidator."")
+	}
+	if genesisValidator.PubKey == nil {
+		return GenesisValidator{}, fmt.Errorf(""Invalid GenesisValidator %s with nil public key."",
+			genesisValidator.Name)
+	}
+	// clone the public key by writing and reading over go-wire serialisation
+	// TODO! write unit test to see whether this is correct
+	publicKeyClone, err := crypto.PubKeyFromBytes(genesisValidator.PubKey.Bytes())",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102318645,https://github.com/hyperledger/burrow/pull/501#discussion_r102318645,silasdavis
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,"but it returns a []byte as type byte prepended public key bytes; I need to then copy that byte slice in a `[32]byte` or `[64]byte` and then cast that to the interface; this one line captures all that;

Im fine for it to be improved in `eris-db/crypto`; but right now I need a way to take deep ownership of the data in genesisDoc so that once the `GenesisDoc` is created it is independent of the memory that went into creating it",fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 21:22:58,102321091,"@@ -65,3 +94,71 @@ func GenesisDocFromJSON(jsonBlob []byte) (genState *GenesisDoc) {
 	}
 	return
 }
+
+//------------------------------------------------------------
+// Methods for genesis types
+// NOTE: breaks formatting convention
+// TODO: split each genesis type in its own file definition
+
+//------------------------------------------------------------
+// GenesisAccount methods
+
+// Clone clones the genesis account
+func (genesisAccount *GenesisAccount) Clone() GenesisAccount {
+	// clone the address
+	addressClone := make([]byte, len(genesisAccount.Address))
+	copy(addressClone, genesisAccount.Address)
+	// clone the account permissions
+	accountPermissionsClone := genesisAccount.Permissions.Clone()
+	return GenesisAccount{
+		Address:     addressClone,
+		Amount:      genesisAccount.Amount,
+		Name:        genesisAccount.Name,
+		Permissions: &accountPermissionsClone,
+	}
+}
+
+//------------------------------------------------------------
+// GenesisValidator methods
+
+// Clone clones the genesis validator
+func (genesisValidator *GenesisValidator) Clone() (GenesisValidator, error) {
+	if genesisValidator == nil {
+		return GenesisValidator{}, fmt.Errorf(""Cannot clone nil GenesisValidator."")
+	}
+	if genesisValidator.PubKey == nil {
+		return GenesisValidator{}, fmt.Errorf(""Invalid GenesisValidator %s with nil public key."",
+			genesisValidator.Name)
+	}
+	// clone the public key by writing and reading over go-wire serialisation
+	// TODO! write unit test to see whether this is correct
+	publicKeyClone, err := crypto.PubKeyFromBytes(genesisValidator.PubKey.Bytes())",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102321091,https://github.com/hyperledger/burrow/pull/501#discussion_r102321091,benjaminbollen
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,"My point is you have a PubKey, you don't need a clone, it's the same PubKey `genesisValidator.PubKey` and the `PubKey` interface is immutable.",fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 21:26:52,102322037,"@@ -65,3 +94,71 @@ func GenesisDocFromJSON(jsonBlob []byte) (genState *GenesisDoc) {
 	}
 	return
 }
+
+//------------------------------------------------------------
+// Methods for genesis types
+// NOTE: breaks formatting convention
+// TODO: split each genesis type in its own file definition
+
+//------------------------------------------------------------
+// GenesisAccount methods
+
+// Clone clones the genesis account
+func (genesisAccount *GenesisAccount) Clone() GenesisAccount {
+	// clone the address
+	addressClone := make([]byte, len(genesisAccount.Address))
+	copy(addressClone, genesisAccount.Address)
+	// clone the account permissions
+	accountPermissionsClone := genesisAccount.Permissions.Clone()
+	return GenesisAccount{
+		Address:     addressClone,
+		Amount:      genesisAccount.Amount,
+		Name:        genesisAccount.Name,
+		Permissions: &accountPermissionsClone,
+	}
+}
+
+//------------------------------------------------------------
+// GenesisValidator methods
+
+// Clone clones the genesis validator
+func (genesisValidator *GenesisValidator) Clone() (GenesisValidator, error) {
+	if genesisValidator == nil {
+		return GenesisValidator{}, fmt.Errorf(""Cannot clone nil GenesisValidator."")
+	}
+	if genesisValidator.PubKey == nil {
+		return GenesisValidator{}, fmt.Errorf(""Invalid GenesisValidator %s with nil public key."",
+			genesisValidator.Name)
+	}
+	// clone the public key by writing and reading over go-wire serialisation
+	// TODO! write unit test to see whether this is correct
+	publicKeyClone, err := crypto.PubKeyFromBytes(genesisValidator.PubKey.Bytes())",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102322037,https://github.com/hyperledger/burrow/pull/501#discussion_r102322037,silasdavis
https://github.com/hyperledger/burrow/pull/501,https://github.com/hyperledger/burrow/pull/501,And you already own the memory because you created it: https://github.com/benjaminbollen/eris-db/blob/441c1a6db5b3d679b94df5bd0335ee32f5d9697e/genesis/maker.go#L77,fa0ed7e27c5b5e27081c11c76805e858594e2ef6,2017-02-21 21:29:24,102322613,"@@ -65,3 +94,71 @@ func GenesisDocFromJSON(jsonBlob []byte) (genState *GenesisDoc) {
 	}
 	return
 }
+
+//------------------------------------------------------------
+// Methods for genesis types
+// NOTE: breaks formatting convention
+// TODO: split each genesis type in its own file definition
+
+//------------------------------------------------------------
+// GenesisAccount methods
+
+// Clone clones the genesis account
+func (genesisAccount *GenesisAccount) Clone() GenesisAccount {
+	// clone the address
+	addressClone := make([]byte, len(genesisAccount.Address))
+	copy(addressClone, genesisAccount.Address)
+	// clone the account permissions
+	accountPermissionsClone := genesisAccount.Permissions.Clone()
+	return GenesisAccount{
+		Address:     addressClone,
+		Amount:      genesisAccount.Amount,
+		Name:        genesisAccount.Name,
+		Permissions: &accountPermissionsClone,
+	}
+}
+
+//------------------------------------------------------------
+// GenesisValidator methods
+
+// Clone clones the genesis validator
+func (genesisValidator *GenesisValidator) Clone() (GenesisValidator, error) {
+	if genesisValidator == nil {
+		return GenesisValidator{}, fmt.Errorf(""Cannot clone nil GenesisValidator."")
+	}
+	if genesisValidator.PubKey == nil {
+		return GenesisValidator{}, fmt.Errorf(""Invalid GenesisValidator %s with nil public key."",
+			genesisValidator.Name)
+	}
+	// clone the public key by writing and reading over go-wire serialisation
+	// TODO! write unit test to see whether this is correct
+	publicKeyClone, err := crypto.PubKeyFromBytes(genesisValidator.PubKey.Bytes())",,2017-02-22 12:56:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102322613,https://github.com/hyperledger/burrow/pull/501#discussion_r102322613,silasdavis
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,Thought we said camelCase? ,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-17 18:44:53,101820586,"@@ -0,0 +1,143 @@
+package vm
+
+import (
+	""encoding/hex""
+	""testing""
+
+	. ""github.com/eris-ltd/eris-db/word256""
+	""github.com/stretchr/testify/assert""
+	""fmt""
+	. ""github.com/eris-ltd/eris-db/manager/eris-mint/evm/opcodes""
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+)
+
+/* Compiling the Permissions solidity contract at
+(generated by Solidity() function)
+https://ethereum.github.io/browser-solidity yields:
+
+3fbf7da5 add_role(address,bytes32)
+744f5998 has_base(address,uint64)
+e8145855 has_role(address,bytes32)
+28fd0194 rm_role(address,bytes32)
+3f0ebb30 set_base(address,uint64,uint64)
+67dc6f70 set_global(address,uint64,uint64)
+73448c99 unset_base(address,uint64)
+*/
+
+func TestPermissionsContractSignatures(t *testing.T) {
+	contract := SNativeContracts()[""permissions_contract""]
+
+	assertContractFunction(t, contract, ""3fbf7da5"",
+		""add_role(address,bytes32)"")",,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/101820586,https://github.com/hyperledger/burrow/pull/500#discussion_r101820586,VoR0220
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,"Ah right yeah, I can do that, but it will involve a few more changes. Obviously just a search and replace job in Eris db so I can do it, but it got me to question the wisdom, will do it if you and Jason and Ben think it's good idea ",a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-17 18:51:58,101822055,"@@ -0,0 +1,143 @@
+package vm
+
+import (
+	""encoding/hex""
+	""testing""
+
+	. ""github.com/eris-ltd/eris-db/word256""
+	""github.com/stretchr/testify/assert""
+	""fmt""
+	. ""github.com/eris-ltd/eris-db/manager/eris-mint/evm/opcodes""
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+)
+
+/* Compiling the Permissions solidity contract at
+(generated by Solidity() function)
+https://ethereum.github.io/browser-solidity yields:
+
+3fbf7da5 add_role(address,bytes32)
+744f5998 has_base(address,uint64)
+e8145855 has_role(address,bytes32)
+28fd0194 rm_role(address,bytes32)
+3f0ebb30 set_base(address,uint64,uint64)
+67dc6f70 set_global(address,uint64,uint64)
+73448c99 unset_base(address,uint64)
+*/
+
+func TestPermissionsContractSignatures(t *testing.T) {
+	contract := SNativeContracts()[""permissions_contract""]
+
+	assertContractFunction(t, contract, ""3fbf7da5"",
+		""add_role(address,bytes32)"")",,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/101822055,https://github.com/hyperledger/burrow/pull/500#discussion_r101822055,silasdavis
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,nice :),a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 11:50:52,102000939,"@@ -378,6 +379,8 @@ func Bytecode(bytelikes ...interface{}) []byte {
 			if int64(bytes[i]) != b {
 				panic(fmt.Sprintf(""The int64 %v does not fit inside a byte"", b))
 			}
+		case word256.Word256:",12,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102000939,https://github.com/hyperledger/burrow/pull/500#discussion_r102000939,benjaminbollen
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,"Strictly speaking, should this not be an interface for which we have a Solidity implementation?  The argument is that Solidity is not the only language that can access our Ethereum compatible secure native functions",a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 11:58:40,102002225,"@@ -1,104 +1,351 @@
 package vm
 
 import (
-	""encoding/hex""
 	""fmt""
 
 	""github.com/eris-ltd/eris-db/common/sanity""
 	""github.com/eris-ltd/eris-db/manager/eris-mint/evm/sha3""
 	ptypes ""github.com/eris-ltd/eris-db/permission/types""
 	. ""github.com/eris-ltd/eris-db/word256""
+
+	""bytes""
+	""strings""
 )
 
 //------------------------------------------------------------------------------------------------
 // Registered SNative contracts
 
-var PermissionsContract = ""permissions_contract""
-
-func registerSNativeContracts() {
-	registeredNativeContracts[LeftPadWord256([]byte(PermissionsContract))] = permissionsContract
-
-	/*
-		// we could expose these but we moved permission and args checks into the permissionsContract
-		// so calling them would be unsafe ...
-		registeredNativeContracts[LeftPadWord256([]byte(""has_base""))] = has_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_base""))] = set_base
-		registeredNativeContracts[LeftPadWord256([]byte(""unset_base""))] = unset_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_global""))] = set_global
-		registeredNativeContracts[LeftPadWord256([]byte(""has_role""))] = has_role
-		registeredNativeContracts[LeftPadWord256([]byte(""add_role""))] = add_role
-		registeredNativeContracts[LeftPadWord256([]byte(""rm_role""))] = rm_role
-	*/
+type SNativeContractDescription struct {
+	Comment   string
+	Name      string
+	functions map[FuncID]SNativeFuncDescription
 }
 
-//-----------------------------------------------------------------------------
-// snative are native contracts that can access and modify an account's permissions
-
 type SNativeFuncDescription struct {",,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102002225,https://github.com/hyperledger/burrow/pull/500#discussion_r102002225,benjaminbollen
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,"This should not panic, even if it would only be called on initialization;",a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 12:09:21,102003899,"@@ -1,104 +1,351 @@
 package vm
 
 import (
-	""encoding/hex""
 	""fmt""
 
 	""github.com/eris-ltd/eris-db/common/sanity""
 	""github.com/eris-ltd/eris-db/manager/eris-mint/evm/sha3""
 	ptypes ""github.com/eris-ltd/eris-db/permission/types""
 	. ""github.com/eris-ltd/eris-db/word256""
+
+	""bytes""
+	""strings""
 )
 
 //------------------------------------------------------------------------------------------------
 // Registered SNative contracts
 
-var PermissionsContract = ""permissions_contract""
-
-func registerSNativeContracts() {
-	registeredNativeContracts[LeftPadWord256([]byte(PermissionsContract))] = permissionsContract
-
-	/*
-		// we could expose these but we moved permission and args checks into the permissionsContract
-		// so calling them would be unsafe ...
-		registeredNativeContracts[LeftPadWord256([]byte(""has_base""))] = has_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_base""))] = set_base
-		registeredNativeContracts[LeftPadWord256([]byte(""unset_base""))] = unset_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_global""))] = set_global
-		registeredNativeContracts[LeftPadWord256([]byte(""has_role""))] = has_role
-		registeredNativeContracts[LeftPadWord256([]byte(""add_role""))] = add_role
-		registeredNativeContracts[LeftPadWord256([]byte(""rm_role""))] = rm_role
-	*/
+type SNativeContractDescription struct {
+	Comment   string
+	Name      string
+	functions map[FuncID]SNativeFuncDescription
 }
 
-//-----------------------------------------------------------------------------
-// snative are native contracts that can access and modify an account's permissions
-
 type SNativeFuncDescription struct {
+	Comment  string
 	Name     string
-	NArgs    int
+	Args     []SolidityArg
+	Return   SolidityReturn
 	PermFlag ptypes.PermFlag
 	F        NativeContract
 }
 
-/* The solidity interface used to generate the abi function ids below
-contract Permissions {
-	function has_base(address addr, uint64 permFlag) constant returns (bool value) {}
-	function set_base(address addr, uint64 permFlag, bool value) constant returns (bool val) {}
-	function unset_base(address addr, uint64 permFlag) constant returns (uint64 pf) {}
-	function set_global(uint64 permFlag, bool value) constant returns (uint64 pf) {}
-	function has_role(address addr, string role) constant returns (bool val) {}
-	function add_role(address addr, string role) constant returns (bool added) {}
-	function rm_role(address addr, string role) constant returns (bool removed) {}
+type SolidityType string
+
+type SolidityArg struct {
+	Name string
+	Type SolidityType
 }
-*/
 
-// function identifiers from the solidity abi
-var PermsMap = map[string]SNativeFuncDescription{
-	getFuncIdentifiersFromSignature(""has_role(address,bytes32)""):    SNativeFuncDescription{""has_role"", 2, ptypes.HasRole, has_role},
-	getFuncIdentifiersFromSignature(""unset_base(address,uint64)""):   SNativeFuncDescription{""unset_base"", 2, ptypes.UnsetBase, unset_base},
-	getFuncIdentifiersFromSignature(""set_global(uint64,bool)""):      SNativeFuncDescription{""set_global"", 2, ptypes.SetGlobal, set_global},
-	getFuncIdentifiersFromSignature(""add_role(address,bytes32)""):    SNativeFuncDescription{""add_role"", 2, ptypes.AddRole, add_role},
-	getFuncIdentifiersFromSignature(""set_base(address,uint64,bool""): SNativeFuncDescription{""set_base"", 3, ptypes.SetBase, set_base},
-	getFuncIdentifiersFromSignature(""has_base(address,uint64)""):     SNativeFuncDescription{""has_base"", 2, ptypes.HasBase, has_base},
-	getFuncIdentifiersFromSignature(""rm_role(address,bytes32)""):     SNativeFuncDescription{""rm_role"", 2, ptypes.RmRole, rm_role},
+type SolidityReturn struct {
+	Name string
+	Type SolidityType
 }
 
-func getFuncIdentifiersFromSignature(signature string) string {
-	identifier := sha3.Sha3([]byte(signature))
-	return hex.EncodeToString(identifier[:4])
+const (
+	// We don't need to be exhaustive here, just make what we used strongly typed
+	SolidityAddress SolidityType = ""address""
+	SolidityInt     SolidityType = ""int""
+	SolidityUint64  SolidityType = ""uint64""
+	SolidityBytes32 SolidityType = ""bytes32""
+	SolidityString  SolidityType = ""string""
+	SolidityBool    SolidityType = ""bool""
+)
+
+func registerSNativeContracts() {
+	for _, contract := range SNativeContracts() {
+		registeredNativeContracts[contract.Address()] = contract.Dispatch
+	}
 }
 
-func permissionsContract(appState AppState, caller *Account, args []byte, gas *int64) (output []byte, err error) {
-	if len(args) < 4 {
-		return nil, fmt.Errorf(""permissionsContract expects at least a 4-byte function identifier"")
+// Returns a map of all SNative contracts defined indexed by name
+func SNativeContracts() map[string]SNativeContractDescription {
+	permFlagType := SolidityUint64
+	roleType := SolidityBytes32
+	contracts := []SNativeContractDescription{
+		NewSNativeContract(`
+		* Interface for managing Secure Native authorizations.
+		* @dev This Solidity interface describes the functions exposed by the SNative permissions layer in the Monax blockchain (ErisDB).
+		`,
+			""permissions_contract"",
+			SNativeFuncDescription{`
+			* @notice Adds a role to an account
+			* @param _account account
+			* @param _role role
+			* @return result whether role was added
+			`,
+				""add_role"",
+				[]SolidityArg{
+					arg(""_account"", SolidityAddress),
+					arg(""_role"", roleType),
+				},
+				ret(""result"", SolidityBool),
+				ptypes.AddRole,
+				add_role},
+
+			SNativeFuncDescription{`
+			* @notice Indicates whether an account has a role
+			* @param _account account
+			* @param _role role
+			* @return result whether account has role
+			`,
+				""has_role"",
+				[]SolidityArg{
+					arg(""_account"", SolidityAddress),
+					arg(""_role"", roleType),
+				},
+				ret(""result"", SolidityBool),
+				ptypes.HasRole,
+				has_role},
+
+			SNativeFuncDescription{`
+			* @notice Removes a role from an account
+			* @param _account account
+			* @param _role role
+			* @return result whether role was removed
+			`,
+				""rm_role"",
+				[]SolidityArg{
+					arg(""_account"", SolidityAddress),
+					arg(""_role"", roleType),
+				},
+				ret(""result"", SolidityBool),
+				ptypes.RmRole,
+				rm_role},
+
+			SNativeFuncDescription{`
+			* @notice Sets a base authorization for an account
+			* @param _account account
+			* @param _authorization base authorization
+			* @param _value value of base authorization
+			* @return result value passed in
+			`,
+				""set_base"",
+				[]SolidityArg{
+					arg(""_account"", SolidityAddress),
+					arg(""_authorization"", permFlagType),
+					arg(""_value"", permFlagType)},
+				ret(""result"", SolidityBool),
+				ptypes.SetBase,
+				set_base},
+
+			SNativeFuncDescription{`
+			* @notice Indicates whether an account has a base authorization
+			* @param _account account
+			* @param _authorization base authorization
+			* @return result whether account has base authorization set
+			`,
+				""has_base"",
+				[]SolidityArg{
+					arg(""_account"", SolidityAddress),
+					arg(""_authorization"", permFlagType)},
+				ret(""result"", SolidityBool),
+				ptypes.HasBase,
+				has_base},
+
+			SNativeFuncDescription{`
+			* @notice Sets a base authorization for an account to the global (default) value of the base authorization
+      * @param _account account
+      * @param _authorization base authorization
+      * @return authorization base authorization passed in
+      `,
+				""unset_base"",
+				[]SolidityArg{
+					arg(""_account"", SolidityAddress),
+					arg(""_authorization"", permFlagType)},
+				ret(""authorization"", permFlagType),
+				ptypes.UnsetBase,
+				unset_base},
+
+			SNativeFuncDescription{`
+			* @notice Sets global (default) value for a base authorization
+			* @param _authorization base authorization
+			* @param _value value of base authorization
+			* @return authorization base authorization passed in
+			`,
+				""set_global"",
+				[]SolidityArg{
+					arg(""_authorization"", permFlagType),
+					arg(""_value"", permFlagType)},
+				ret(""authorization"", permFlagType),
+				ptypes.SetGlobal,
+				set_global},
+		),
 	}
 
-	// map solidity abi function id to snative
-	funcIDbytes := args[:4]
-	args = args[4:]
-	funcID := hex.EncodeToString(funcIDbytes)
-	d, ok := PermsMap[funcID]
-	if !ok {
-		return nil, fmt.Errorf(""unknown permissionsContract funcID %s"", funcID)
+	contractMap := make(map[string]SNativeContractDescription, len(contracts))
+	for _, contract := range contracts {
+		contractMap[contract.Name] = contract
 	}
+	return contractMap
+}
+
+//-----------------------------------------------------------------------------
+// snative are native contracts that can access and modify an account's permissions
+
+func NewSNativeContract(comment, name string, functions ...SNativeFuncDescription) SNativeContractDescription {
+	fs := make(map[FuncID]SNativeFuncDescription, len(functions))
+	for _, f := range functions {
+		fid := f.ID()
+		otherF, ok := fs[fid]
+		if ok {
+			panic(fmt.Errorf(""Function with ID %x already defined: %s"", fid,",,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102003899,https://github.com/hyperledger/burrow/pull/500#discussion_r102003899,benjaminbollen
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,Good on returning `Zero256`,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 12:10:34,102004098,"@@ -1,104 +1,351 @@
 package vm
 
 import (
-	""encoding/hex""
 	""fmt""
 
 	""github.com/eris-ltd/eris-db/common/sanity""
 	""github.com/eris-ltd/eris-db/manager/eris-mint/evm/sha3""
 	ptypes ""github.com/eris-ltd/eris-db/permission/types""
 	. ""github.com/eris-ltd/eris-db/word256""
+
+	""bytes""
+	""strings""
 )
 
 //------------------------------------------------------------------------------------------------
 // Registered SNative contracts
 
-var PermissionsContract = ""permissions_contract""
-
-func registerSNativeContracts() {
-	registeredNativeContracts[LeftPadWord256([]byte(PermissionsContract))] = permissionsContract
-
-	/*
-		// we could expose these but we moved permission and args checks into the permissionsContract
-		// so calling them would be unsafe ...
-		registeredNativeContracts[LeftPadWord256([]byte(""has_base""))] = has_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_base""))] = set_base
-		registeredNativeContracts[LeftPadWord256([]byte(""unset_base""))] = unset_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_global""))] = set_global
-		registeredNativeContracts[LeftPadWord256([]byte(""has_role""))] = has_role
-		registeredNativeContracts[LeftPadWord256([]byte(""add_role""))] = add_role
-		registeredNativeContracts[LeftPadWord256([]byte(""rm_role""))] = rm_role
-	*/
+type SNativeContractDescription struct {
+	Comment   string
+	Name      string
+	functions map[FuncID]SNativeFuncDescription
 }
 
-//-----------------------------------------------------------------------------
-// snative are native contracts that can access and modify an account's permissions
-
 type SNativeFuncDescription struct {
+	Comment  string
 	Name     string
-	NArgs    int
+	Args     []SolidityArg
+	Return   SolidityReturn
 	PermFlag ptypes.PermFlag
 	F        NativeContract
 }
 
-/* The solidity interface used to generate the abi function ids below
-contract Permissions {
-	function has_base(address addr, uint64 permFlag) constant returns (bool value) {}
-	function set_base(address addr, uint64 permFlag, bool value) constant returns (bool val) {}
-	function unset_base(address addr, uint64 permFlag) constant returns (uint64 pf) {}
-	function set_global(uint64 permFlag, bool value) constant returns (uint64 pf) {}
-	function has_role(address addr, string role) constant returns (bool val) {}
-	function add_role(address addr, string role) constant returns (bool added) {}
-	function rm_role(address addr, string role) constant returns (bool removed) {}
+type SolidityType string
+
+type SolidityArg struct {
+	Name string
+	Type SolidityType
 }
-*/
 
-// function identifiers from the solidity abi
-var PermsMap = map[string]SNativeFuncDescription{
-	getFuncIdentifiersFromSignature(""has_role(address,bytes32)""):    SNativeFuncDescription{""has_role"", 2, ptypes.HasRole, has_role},
-	getFuncIdentifiersFromSignature(""unset_base(address,uint64)""):   SNativeFuncDescription{""unset_base"", 2, ptypes.UnsetBase, unset_base},
-	getFuncIdentifiersFromSignature(""set_global(uint64,bool)""):      SNativeFuncDescription{""set_global"", 2, ptypes.SetGlobal, set_global},
-	getFuncIdentifiersFromSignature(""add_role(address,bytes32)""):    SNativeFuncDescription{""add_role"", 2, ptypes.AddRole, add_role},
-	getFuncIdentifiersFromSignature(""set_base(address,uint64,bool""): SNativeFuncDescription{""set_base"", 3, ptypes.SetBase, set_base},
-	getFuncIdentifiersFromSignature(""has_base(address,uint64)""):     SNativeFuncDescription{""has_base"", 2, ptypes.HasBase, has_base},
-	getFuncIdentifiersFromSignature(""rm_role(address,bytes32)""):     SNativeFuncDescription{""rm_role"", 2, ptypes.RmRole, rm_role},
+type SolidityReturn struct {
+	Name string
+	Type SolidityType
 }
 
-func getFuncIdentifiersFromSignature(signature string) string {
-	identifier := sha3.Sha3([]byte(signature))
-	return hex.EncodeToString(identifier[:4])
+const (
+	// We don't need to be exhaustive here, just make what we used strongly typed
+	SolidityAddress SolidityType = ""address""
+	SolidityInt     SolidityType = ""int""
+	SolidityUint64  SolidityType = ""uint64""
+	SolidityBytes32 SolidityType = ""bytes32""
+	SolidityString  SolidityType = ""string""
+	SolidityBool    SolidityType = ""bool""
+)
+
+func registerSNativeContracts() {
+	for _, contract := range SNativeContracts() {
+		registeredNativeContracts[contract.Address()] = contract.Dispatch
+	}
 }
 
-func permissionsContract(appState AppState, caller *Account, args []byte, gas *int64) (output []byte, err error) {
-	if len(args) < 4 {
-		return nil, fmt.Errorf(""permissionsContract expects at least a 4-byte function identifier"")
+// Returns a map of all SNative contracts defined indexed by name
+func SNativeContracts() map[string]SNativeContractDescription {
+	permFlagType := SolidityUint64
+	roleType := SolidityBytes32
+	contracts := []SNativeContractDescription{
+		NewSNativeContract(`
+		* Interface for managing Secure Native authorizations.
+		* @dev This Solidity interface describes the functions exposed by the SNative permissions layer in the Monax blockchain (ErisDB).
+		`,
+			""permissions_contract"",
+			SNativeFuncDescription{`
+			* @notice Adds a role to an account
+			* @param _account account
+			* @param _role role
+			* @return result whether role was added
+			`,
+				""add_role"",
+				[]SolidityArg{
+					arg(""_account"", SolidityAddress),
+					arg(""_role"", roleType),
+				},
+				ret(""result"", SolidityBool),
+				ptypes.AddRole,
+				add_role},
+
+			SNativeFuncDescription{`
+			* @notice Indicates whether an account has a role
+			* @param _account account
+			* @param _role role
+			* @return result whether account has role
+			`,
+				""has_role"",
+				[]SolidityArg{
+					arg(""_account"", SolidityAddress),
+					arg(""_role"", roleType),
+				},
+				ret(""result"", SolidityBool),
+				ptypes.HasRole,
+				has_role},
+
+			SNativeFuncDescription{`
+			* @notice Removes a role from an account
+			* @param _account account
+			* @param _role role
+			* @return result whether role was removed
+			`,
+				""rm_role"",
+				[]SolidityArg{
+					arg(""_account"", SolidityAddress),
+					arg(""_role"", roleType),
+				},
+				ret(""result"", SolidityBool),
+				ptypes.RmRole,
+				rm_role},
+
+			SNativeFuncDescription{`
+			* @notice Sets a base authorization for an account
+			* @param _account account
+			* @param _authorization base authorization
+			* @param _value value of base authorization
+			* @return result value passed in
+			`,
+				""set_base"",
+				[]SolidityArg{
+					arg(""_account"", SolidityAddress),
+					arg(""_authorization"", permFlagType),
+					arg(""_value"", permFlagType)},
+				ret(""result"", SolidityBool),
+				ptypes.SetBase,
+				set_base},
+
+			SNativeFuncDescription{`
+			* @notice Indicates whether an account has a base authorization
+			* @param _account account
+			* @param _authorization base authorization
+			* @return result whether account has base authorization set
+			`,
+				""has_base"",
+				[]SolidityArg{
+					arg(""_account"", SolidityAddress),
+					arg(""_authorization"", permFlagType)},
+				ret(""result"", SolidityBool),
+				ptypes.HasBase,
+				has_base},
+
+			SNativeFuncDescription{`
+			* @notice Sets a base authorization for an account to the global (default) value of the base authorization
+      * @param _account account
+      * @param _authorization base authorization
+      * @return authorization base authorization passed in
+      `,
+				""unset_base"",
+				[]SolidityArg{
+					arg(""_account"", SolidityAddress),
+					arg(""_authorization"", permFlagType)},
+				ret(""authorization"", permFlagType),
+				ptypes.UnsetBase,
+				unset_base},
+
+			SNativeFuncDescription{`
+			* @notice Sets global (default) value for a base authorization
+			* @param _authorization base authorization
+			* @param _value value of base authorization
+			* @return authorization base authorization passed in
+			`,
+				""set_global"",
+				[]SolidityArg{
+					arg(""_authorization"", permFlagType),
+					arg(""_value"", permFlagType)},
+				ret(""authorization"", permFlagType),
+				ptypes.SetGlobal,
+				set_global},
+		),
 	}
 
-	// map solidity abi function id to snative
-	funcIDbytes := args[:4]
-	args = args[4:]
-	funcID := hex.EncodeToString(funcIDbytes)
-	d, ok := PermsMap[funcID]
-	if !ok {
-		return nil, fmt.Errorf(""unknown permissionsContract funcID %s"", funcID)
+	contractMap := make(map[string]SNativeContractDescription, len(contracts))
+	for _, contract := range contracts {
+		contractMap[contract.Name] = contract
 	}
+	return contractMap
+}
+
+//-----------------------------------------------------------------------------
+// snative are native contracts that can access and modify an account's permissions
+
+func NewSNativeContract(comment, name string, functions ...SNativeFuncDescription) SNativeContractDescription {
+	fs := make(map[FuncID]SNativeFuncDescription, len(functions))
+	for _, f := range functions {
+		fid := f.ID()
+		otherF, ok := fs[fid]
+		if ok {
+			panic(fmt.Errorf(""Function with ID %x already defined: %s"", fid,
+				otherF))
+		}
+		fs[fid] = f
+	}
+	return SNativeContractDescription{
+		Comment:   comment,
+		Name:      name,
+		functions: fs,
+	}
+}
+
+// This function is designed to be called from the EVM once a SNative contract
+// has been selected. It is also placed in a registry by registerSNativeContracts
+// So it can be looked up by SNative address
+func (contract *SNativeContractDescription) Dispatch(appState AppState,
+	caller *Account, args []byte, gas *int64) (output []byte, err error) {
+	if len(args) < FuncIDLength {
+		return Zero256.Bytes(), fmt.Errorf(""SNatives dispatch requires a 4-byte function ""+
+			""identifier but arguments are only %s bytes long"", len(args))
+	}
+
+	function, err := contract.FunctionByID(firstFourBytes(args))
+	if err != nil {
+		return Zero256.Bytes(), err
+	}
+
+	remainingArgs := args[FuncIDLength:]
 
 	// check if we have permission to call this function
-	if !HasPermission(appState, caller, d.PermFlag) {
-		return nil, ErrInvalidPermission{caller.Address, d.Name}
+	if !HasPermission(appState, caller, function.PermFlag) {
+		return Zero256.Bytes(), ErrInvalidPermission{caller.Address, function.Name}",,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102004098,https://github.com/hyperledger/burrow/pull/500#discussion_r102004098,benjaminbollen
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,"Internally we treat roles as strings, but I agree that it is better and sufficient to type it strictly as `bytes32`; alternatively we should change our impl to treat it as `Word256`",a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 12:38:47,102008824,"@@ -1,104 +1,351 @@
 package vm
 
 import (
-	""encoding/hex""
 	""fmt""
 
 	""github.com/eris-ltd/eris-db/common/sanity""
 	""github.com/eris-ltd/eris-db/manager/eris-mint/evm/sha3""
 	ptypes ""github.com/eris-ltd/eris-db/permission/types""
 	. ""github.com/eris-ltd/eris-db/word256""
+
+	""bytes""
+	""strings""
 )
 
 //------------------------------------------------------------------------------------------------
 // Registered SNative contracts
 
-var PermissionsContract = ""permissions_contract""
-
-func registerSNativeContracts() {
-	registeredNativeContracts[LeftPadWord256([]byte(PermissionsContract))] = permissionsContract
-
-	/*
-		// we could expose these but we moved permission and args checks into the permissionsContract
-		// so calling them would be unsafe ...
-		registeredNativeContracts[LeftPadWord256([]byte(""has_base""))] = has_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_base""))] = set_base
-		registeredNativeContracts[LeftPadWord256([]byte(""unset_base""))] = unset_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_global""))] = set_global
-		registeredNativeContracts[LeftPadWord256([]byte(""has_role""))] = has_role
-		registeredNativeContracts[LeftPadWord256([]byte(""add_role""))] = add_role
-		registeredNativeContracts[LeftPadWord256([]byte(""rm_role""))] = rm_role
-	*/
+type SNativeContractDescription struct {
+	Comment   string
+	Name      string
+	functions map[FuncID]SNativeFuncDescription
 }
 
-//-----------------------------------------------------------------------------
-// snative are native contracts that can access and modify an account's permissions
-
 type SNativeFuncDescription struct {
+	Comment  string
 	Name     string
-	NArgs    int
+	Args     []SolidityArg
+	Return   SolidityReturn
 	PermFlag ptypes.PermFlag
 	F        NativeContract
 }
 
-/* The solidity interface used to generate the abi function ids below
-contract Permissions {
-	function has_base(address addr, uint64 permFlag) constant returns (bool value) {}
-	function set_base(address addr, uint64 permFlag, bool value) constant returns (bool val) {}
-	function unset_base(address addr, uint64 permFlag) constant returns (uint64 pf) {}
-	function set_global(uint64 permFlag, bool value) constant returns (uint64 pf) {}
-	function has_role(address addr, string role) constant returns (bool val) {}
-	function add_role(address addr, string role) constant returns (bool added) {}
-	function rm_role(address addr, string role) constant returns (bool removed) {}
+type SolidityType string
+
+type SolidityArg struct {
+	Name string
+	Type SolidityType
 }
-*/
 
-// function identifiers from the solidity abi
-var PermsMap = map[string]SNativeFuncDescription{
-	getFuncIdentifiersFromSignature(""has_role(address,bytes32)""):    SNativeFuncDescription{""has_role"", 2, ptypes.HasRole, has_role},
-	getFuncIdentifiersFromSignature(""unset_base(address,uint64)""):   SNativeFuncDescription{""unset_base"", 2, ptypes.UnsetBase, unset_base},
-	getFuncIdentifiersFromSignature(""set_global(uint64,bool)""):      SNativeFuncDescription{""set_global"", 2, ptypes.SetGlobal, set_global},
-	getFuncIdentifiersFromSignature(""add_role(address,bytes32)""):    SNativeFuncDescription{""add_role"", 2, ptypes.AddRole, add_role},
-	getFuncIdentifiersFromSignature(""set_base(address,uint64,bool""): SNativeFuncDescription{""set_base"", 3, ptypes.SetBase, set_base},
-	getFuncIdentifiersFromSignature(""has_base(address,uint64)""):     SNativeFuncDescription{""has_base"", 2, ptypes.HasBase, has_base},
-	getFuncIdentifiersFromSignature(""rm_role(address,bytes32)""):     SNativeFuncDescription{""rm_role"", 2, ptypes.RmRole, rm_role},
+type SolidityReturn struct {
+	Name string
+	Type SolidityType
 }
 
-func getFuncIdentifiersFromSignature(signature string) string {
-	identifier := sha3.Sha3([]byte(signature))
-	return hex.EncodeToString(identifier[:4])
+const (
+	// We don't need to be exhaustive here, just make what we used strongly typed
+	SolidityAddress SolidityType = ""address""
+	SolidityInt     SolidityType = ""int""
+	SolidityUint64  SolidityType = ""uint64""
+	SolidityBytes32 SolidityType = ""bytes32""
+	SolidityString  SolidityType = ""string""
+	SolidityBool    SolidityType = ""bool""
+)
+
+func registerSNativeContracts() {
+	for _, contract := range SNativeContracts() {
+		registeredNativeContracts[contract.Address()] = contract.Dispatch
+	}
 }
 
-func permissionsContract(appState AppState, caller *Account, args []byte, gas *int64) (output []byte, err error) {
-	if len(args) < 4 {
-		return nil, fmt.Errorf(""permissionsContract expects at least a 4-byte function identifier"")
+// Returns a map of all SNative contracts defined indexed by name
+func SNativeContracts() map[string]SNativeContractDescription {
+	permFlagType := SolidityUint64
+	roleType := SolidityBytes32",,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102008824,https://github.com/hyperledger/burrow/pull/500#discussion_r102008824,benjaminbollen
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,"Second thought / correction: `SNativeFuncDescription` should not become an interface as suggested above.  Rather the SNative definition should be defined with `LanguageTypes` and the templating should be a package on itself, that produces the solidity code based on the mapping of `LanguageType` to `SolidityType`.  We can raise this as an issue and proceed as is for now; the net gain in readability is sufficient for me.",a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 12:47:58,102010203,"@@ -1,104 +1,351 @@
 package vm
 
 import (
-	""encoding/hex""
 	""fmt""
 
 	""github.com/eris-ltd/eris-db/common/sanity""
 	""github.com/eris-ltd/eris-db/manager/eris-mint/evm/sha3""
 	ptypes ""github.com/eris-ltd/eris-db/permission/types""
 	. ""github.com/eris-ltd/eris-db/word256""
+
+	""bytes""
+	""strings""
 )
 
 //------------------------------------------------------------------------------------------------
 // Registered SNative contracts
 
-var PermissionsContract = ""permissions_contract""
-
-func registerSNativeContracts() {
-	registeredNativeContracts[LeftPadWord256([]byte(PermissionsContract))] = permissionsContract
-
-	/*
-		// we could expose these but we moved permission and args checks into the permissionsContract
-		// so calling them would be unsafe ...
-		registeredNativeContracts[LeftPadWord256([]byte(""has_base""))] = has_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_base""))] = set_base
-		registeredNativeContracts[LeftPadWord256([]byte(""unset_base""))] = unset_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_global""))] = set_global
-		registeredNativeContracts[LeftPadWord256([]byte(""has_role""))] = has_role
-		registeredNativeContracts[LeftPadWord256([]byte(""add_role""))] = add_role
-		registeredNativeContracts[LeftPadWord256([]byte(""rm_role""))] = rm_role
-	*/
+type SNativeContractDescription struct {
+	Comment   string
+	Name      string
+	functions map[FuncID]SNativeFuncDescription
 }
 
-//-----------------------------------------------------------------------------
-// snative are native contracts that can access and modify an account's permissions
-
 type SNativeFuncDescription struct {",,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102010203,https://github.com/hyperledger/burrow/pull/500#discussion_r102010203,benjaminbollen
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,Make that `ProtoType` rather than `LanguageType`,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 13:09:12,102013841,"@@ -1,104 +1,351 @@
 package vm
 
 import (
-	""encoding/hex""
 	""fmt""
 
 	""github.com/eris-ltd/eris-db/common/sanity""
 	""github.com/eris-ltd/eris-db/manager/eris-mint/evm/sha3""
 	ptypes ""github.com/eris-ltd/eris-db/permission/types""
 	. ""github.com/eris-ltd/eris-db/word256""
+
+	""bytes""
+	""strings""
 )
 
 //------------------------------------------------------------------------------------------------
 // Registered SNative contracts
 
-var PermissionsContract = ""permissions_contract""
-
-func registerSNativeContracts() {
-	registeredNativeContracts[LeftPadWord256([]byte(PermissionsContract))] = permissionsContract
-
-	/*
-		// we could expose these but we moved permission and args checks into the permissionsContract
-		// so calling them would be unsafe ...
-		registeredNativeContracts[LeftPadWord256([]byte(""has_base""))] = has_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_base""))] = set_base
-		registeredNativeContracts[LeftPadWord256([]byte(""unset_base""))] = unset_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_global""))] = set_global
-		registeredNativeContracts[LeftPadWord256([]byte(""has_role""))] = has_role
-		registeredNativeContracts[LeftPadWord256([]byte(""add_role""))] = add_role
-		registeredNativeContracts[LeftPadWord256([]byte(""rm_role""))] = rm_role
-	*/
+type SNativeContractDescription struct {
+	Comment   string
+	Name      string
+	functions map[FuncID]SNativeFuncDescription
 }
 
-//-----------------------------------------------------------------------------
-// snative are native contracts that can access and modify an account's permissions
-
 type SNativeFuncDescription struct {",,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102013841,https://github.com/hyperledger/burrow/pull/500#discussion_r102013841,benjaminbollen
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,"Tried this out, works like a charm. Good work. ",a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 18:43:48,102074794,"@@ -73,6 +73,11 @@ hell:
 	go build -o ${REPO}/target/hell ./util/hell/cmd/hell/main.go
 	./target/hell $(filter-out $@,$(MAKECMDGOALS))
 
+# Dumps Solidity interface contracts for SNatives
+.PHONY: snatives
+snatives:
+	@go run ./util/snatives/cmd/main.go",7,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102074794,https://github.com/hyperledger/burrow/pull/500#discussion_r102074794,VoR0220
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,Reason for this? ,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 18:44:01,102074845,"@@ -13,7 +13,7 @@ import (
 	""github.com/stretchr/testify/assert""
 )
 
-var mockInterval = 10 * time.Millisecond
+var mockInterval = 40 * time.Millisecond",5,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102074845,https://github.com/hyperledger/burrow/pull/500#discussion_r102074845,VoR0220
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,"Should clarify in the notes below that this is an ABI for our SNative contracts. That it creates a binding from our native Go Code to Solidity and vice versa, and could further be extended to Java and whatever language the enterprise institutions want. ",a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 18:44:56,102075009,"@@ -0,0 +1,27 @@
+package abi",1,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102075009,https://github.com/hyperledger/burrow/pull/500#discussion_r102075009,VoR0220
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,++,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 18:45:57,102075150,"@@ -3,7 +3,6 @@ package vm
 import (
 	""fmt""
 
-	. ""github.com/eris-ltd/eris-db/manager/eris-mint/evm""",4,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102075150,https://github.com/hyperledger/burrow/pull/500#discussion_r102075150,VoR0220
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,++,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 18:46:03,102075169,"@@ -5,7 +5,6 @@ import (
 	""reflect""
 	""testing""
 
-	. ""github.com/eris-ltd/eris-db/manager/eris-mint/evm""",4,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102075169,https://github.com/hyperledger/burrow/pull/500#discussion_r102075169,VoR0220
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,Needs Godoc documentation of what each of the parameters that are exported do. ,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 18:47:10,102075313,"@@ -1,104 +1,286 @@
 package vm
 
 import (
-	""encoding/hex""
 	""fmt""
 
 	""github.com/eris-ltd/eris-db/common/sanity""
 	""github.com/eris-ltd/eris-db/manager/eris-mint/evm/sha3""
 	ptypes ""github.com/eris-ltd/eris-db/permission/types""
 	. ""github.com/eris-ltd/eris-db/word256""
+
+	""strings""
+	""github.com/eris-ltd/eris-db/manager/eris-mint/evm/abi""
 )
 
 //------------------------------------------------------------------------------------------------
 // Registered SNative contracts
 
-var PermissionsContract = ""permissions_contract""
-
-func registerSNativeContracts() {
-	registeredNativeContracts[LeftPadWord256([]byte(PermissionsContract))] = permissionsContract
-
-	/*
-		// we could expose these but we moved permission and args checks into the permissionsContract
-		// so calling them would be unsafe ...
-		registeredNativeContracts[LeftPadWord256([]byte(""has_base""))] = has_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_base""))] = set_base
-		registeredNativeContracts[LeftPadWord256([]byte(""unset_base""))] = unset_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_global""))] = set_global
-		registeredNativeContracts[LeftPadWord256([]byte(""has_role""))] = has_role
-		registeredNativeContracts[LeftPadWord256([]byte(""add_role""))] = add_role
-		registeredNativeContracts[LeftPadWord256([]byte(""rm_role""))] = rm_role
-	*/
+type SNativeContractDescription struct {",,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102075313,https://github.com/hyperledger/burrow/pull/500#discussion_r102075313,VoR0220
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,Same here. ,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 18:47:16,102075329,"@@ -1,104 +1,286 @@
 package vm
 
 import (
-	""encoding/hex""
 	""fmt""
 
 	""github.com/eris-ltd/eris-db/common/sanity""
 	""github.com/eris-ltd/eris-db/manager/eris-mint/evm/sha3""
 	ptypes ""github.com/eris-ltd/eris-db/permission/types""
 	. ""github.com/eris-ltd/eris-db/word256""
+
+	""strings""
+	""github.com/eris-ltd/eris-db/manager/eris-mint/evm/abi""
 )
 
 //------------------------------------------------------------------------------------------------
 // Registered SNative contracts
 
-var PermissionsContract = ""permissions_contract""
-
-func registerSNativeContracts() {
-	registeredNativeContracts[LeftPadWord256([]byte(PermissionsContract))] = permissionsContract
-
-	/*
-		// we could expose these but we moved permission and args checks into the permissionsContract
-		// so calling them would be unsafe ...
-		registeredNativeContracts[LeftPadWord256([]byte(""has_base""))] = has_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_base""))] = set_base
-		registeredNativeContracts[LeftPadWord256([]byte(""unset_base""))] = unset_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_global""))] = set_global
-		registeredNativeContracts[LeftPadWord256([]byte(""has_role""))] = has_role
-		registeredNativeContracts[LeftPadWord256([]byte(""add_role""))] = add_role
-		registeredNativeContracts[LeftPadWord256([]byte(""rm_role""))] = rm_role
-	*/
+type SNativeContractDescription struct {
+	Comment   string
+	Name      string
+	functions map[FuncID]*SNativeFunctionDescription
 }
 
-//-----------------------------------------------------------------------------
-// snative are native contracts that can access and modify an account's permissions
-
-type SNativeFuncDescription struct {
+type SNativeFunctionDescription struct {",,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102075329,https://github.com/hyperledger/burrow/pull/500#discussion_r102075329,VoR0220
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,much better name ++ ,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 18:49:26,102075629,"@@ -115,7 +297,7 @@ func has_base(appState AppState, caller *Account, args []byte, gas *int64) (outp
 }
 
 func set_base(appState AppState, caller *Account, args []byte, gas *int64) (output []byte, err error) {
-	addr, permNum, perm := returnThreeArgs(args)
+	addr, permNum, permVal := returnThreeArgs(args)",,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102075629,https://github.com/hyperledger/burrow/pull/500#discussion_r102075629,VoR0220
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,very nice. ,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 18:49:40,102075663,"@@ -228,6 +410,10 @@ func ValidPermN(n ptypes.PermFlag) bool {
 	return true
 }
 
+func resultantPermBytes(basePerms ptypes.BasePermissions) []byte {",,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102075663,https://github.com/hyperledger/burrow/pull/500#discussion_r102075663,VoR0220
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,Need to decide if we're going CamelCase Here...or mixedCase (as is Solidity convention). ,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 18:52:50,102076079,"@@ -0,0 +1,124 @@
+package vm
+
+import (
+	""encoding/hex""
+	""testing""
+
+	. ""github.com/eris-ltd/eris-db/word256""
+	""github.com/stretchr/testify/assert""
+	. ""github.com/eris-ltd/eris-db/manager/eris-mint/evm/opcodes""
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+)
+
+/* Compiling the Permissions solidity contract at
+(generated by Solidity() function)
+https://ethereum.github.io/browser-solidity yields:
+
+Functions
+3fbf7da5 add_role(address,bytes32)",,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102076079,https://github.com/hyperledger/burrow/pull/500#discussion_r102076079,VoR0220
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,permissions_contract or are we doing PermissionsContract? Either way I'm fine. Just clarifying. ,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 18:56:01,102076472,"@@ -1,104 +1,286 @@
 package vm
 
 import (
-	""encoding/hex""
 	""fmt""
 
 	""github.com/eris-ltd/eris-db/common/sanity""
 	""github.com/eris-ltd/eris-db/manager/eris-mint/evm/sha3""
 	ptypes ""github.com/eris-ltd/eris-db/permission/types""
 	. ""github.com/eris-ltd/eris-db/word256""
+
+	""strings""
+	""github.com/eris-ltd/eris-db/manager/eris-mint/evm/abi""
 )
 
 //------------------------------------------------------------------------------------------------
 // Registered SNative contracts
 
-var PermissionsContract = ""permissions_contract""
-
-func registerSNativeContracts() {
-	registeredNativeContracts[LeftPadWord256([]byte(PermissionsContract))] = permissionsContract
-
-	/*
-		// we could expose these but we moved permission and args checks into the permissionsContract
-		// so calling them would be unsafe ...
-		registeredNativeContracts[LeftPadWord256([]byte(""has_base""))] = has_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_base""))] = set_base
-		registeredNativeContracts[LeftPadWord256([]byte(""unset_base""))] = unset_base
-		registeredNativeContracts[LeftPadWord256([]byte(""set_global""))] = set_global
-		registeredNativeContracts[LeftPadWord256([]byte(""has_role""))] = has_role
-		registeredNativeContracts[LeftPadWord256([]byte(""add_role""))] = add_role
-		registeredNativeContracts[LeftPadWord256([]byte(""rm_role""))] = rm_role
-	*/
+type SNativeContractDescription struct {
+	Comment   string
+	Name      string
+	functions map[FuncID]*SNativeFunctionDescription
 }
 
-//-----------------------------------------------------------------------------
-// snative are native contracts that can access and modify an account's permissions
-
-type SNativeFuncDescription struct {
+type SNativeFunctionDescription struct {
+	Comment  string
 	Name     string
-	NArgs    int
+	Args     []abi.Arg
+	Return   abi.Return
 	PermFlag ptypes.PermFlag
 	F        NativeContract
 }
 
-/* The solidity interface used to generate the abi function ids below
-contract Permissions {
-	function has_base(address addr, uint64 permFlag) constant returns (bool value) {}
-	function set_base(address addr, uint64 permFlag, bool value) constant returns (bool val) {}
-	function unset_base(address addr, uint64 permFlag) constant returns (uint64 pf) {}
-	function set_global(uint64 permFlag, bool value) constant returns (uint64 pf) {}
-	function has_role(address addr, string role) constant returns (bool val) {}
-	function add_role(address addr, string role) constant returns (bool added) {}
-	function rm_role(address addr, string role) constant returns (bool removed) {}
+func registerSNativeContracts() {
+	for _, contract := range SNativeContracts() {
+		registeredNativeContracts[contract.Address()] = contract.Dispatch
+	}
 }
-*/
 
-// function identifiers from the solidity abi
-var PermsMap = map[string]SNativeFuncDescription{
-	getFuncIdentifiersFromSignature(""has_role(address,bytes32)""):    SNativeFuncDescription{""has_role"", 2, ptypes.HasRole, has_role},
-	getFuncIdentifiersFromSignature(""unset_base(address,uint64)""):   SNativeFuncDescription{""unset_base"", 2, ptypes.UnsetBase, unset_base},
-	getFuncIdentifiersFromSignature(""set_global(uint64,bool)""):      SNativeFuncDescription{""set_global"", 2, ptypes.SetGlobal, set_global},
-	getFuncIdentifiersFromSignature(""add_role(address,bytes32)""):    SNativeFuncDescription{""add_role"", 2, ptypes.AddRole, add_role},
-	getFuncIdentifiersFromSignature(""set_base(address,uint64,bool""): SNativeFuncDescription{""set_base"", 3, ptypes.SetBase, set_base},
-	getFuncIdentifiersFromSignature(""has_base(address,uint64)""):     SNativeFuncDescription{""has_base"", 2, ptypes.HasBase, has_base},
-	getFuncIdentifiersFromSignature(""rm_role(address,bytes32)""):     SNativeFuncDescription{""rm_role"", 2, ptypes.RmRole, rm_role},
+// Returns a map of all SNative contracts defined indexed by name
+func SNativeContracts() map[string]*SNativeContractDescription {
+	permFlagType := abi.Uint64
+	roleType := abi.Bytes32
+	contracts := []*SNativeContractDescription{
+		NewSNativeContract(`
+		* Interface for managing Secure Native authorizations.
+		* @dev This interface describes the functions exposed by the SNative permissions layer in the Monax blockchain (ErisDB).
+		`,
+			""permissions_contract"",",,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102076472,https://github.com/hyperledger/burrow/pull/500#discussion_r102076472,VoR0220
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,"I had a CI failure, timing here was a little tight anyway, also ugly, but pre-existing and we'll get around to that.",a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-20 19:23:24,102079867,"@@ -13,7 +13,7 @@ import (
 	""github.com/stretchr/testify/assert""
 )
 
-var mockInterval = 10 * time.Millisecond
+var mockInterval = 40 * time.Millisecond",5,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102079867,https://github.com/hyperledger/burrow/pull/500#discussion_r102079867,silasdavis
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,A comment is not unwelcome; but great! thx for adding this line,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-21 18:12:47,102277312,"@@ -19,6 +19,8 @@ type TxCache struct {
 	storages map[Tuple256]Word256
 }
 
+var _ vm.AppState = &TxCache{}",4,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102277312,https://github.com/hyperledger/burrow/pull/500#discussion_r102277312,benjaminbollen
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,this is not ok as a public function;  It can encourage usage of it and it should be clear that effective permissions are those of the global permissions + delta of base permissions for that account. Why would we have this function?,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-21 18:15:37,102277941,"@@ -112,6 +112,12 @@ func (p *BasePermissions) IsSet(ty PermFlag) bool {
 	return p.SetBit&ty > 0
 }
 
+// Returns the Perms PermFlag masked with SetBit bit field to give the resultant
+// permissions enabled by this BasePermissions
+func (p *BasePermissions) ResultantPerms() PermFlag {",6,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102277941,https://github.com/hyperledger/burrow/pull/500#discussion_r102277941,benjaminbollen
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,Nice ! I like that you moved them to util; even better than having them in evm,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-21 18:16:37,102278180,"@@ -0,0 +1,133 @@
+package templates",1,2017-02-21 19:30:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102278180,https://github.com/hyperledger/burrow/pull/500#discussion_r102278180,benjaminbollen
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,"If we're going to harden these, now would be the time to add a test for every permission. This way we can effectively gauge what parts are on the jobs failing and what parts are on e-db failing, atleast more easily...currently I'm having trouble deciphering this. ",a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-21 19:37:31,102297528,"@@ -147,7 +147,7 @@ func testPermissions(t *testing.T,
 	nonceString := """"
 
 	_, err := Permissions(nodeClient, keyClient, publicKeyString, addressString,
-		nonceString, ""set_base"", []string{permAddressString, ""root"", ""true""})
+		nonceString, ""setBase"", []string{permAddressString, ""root"", ""true""})",5,2017-02-21 19:37:31,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102297528,https://github.com/hyperledger/burrow/pull/500#discussion_r102297528,VoR0220
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,There are extensive unit tests in `/manager/eris-mint/state/permissions_test.go` that have been passing without failure,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-21 19:58:22,102302600,"@@ -147,7 +147,7 @@ func testPermissions(t *testing.T,
 	nonceString := """"
 
 	_, err := Permissions(nodeClient, keyClient, publicKeyString, addressString,
-		nonceString, ""set_base"", []string{permAddressString, ""root"", ""true""})
+		nonceString, ""setBase"", []string{permAddressString, ""root"", ""true""})",5,2017-02-21 19:58:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102302600,https://github.com/hyperledger/burrow/pull/500#discussion_r102302600,benjaminbollen
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,"That's fine, but working directly on the EVM/SNative is not the same as going through the RPC (as we've seen with https://github.com/eris-ltd/eris-db/pull/477). I would recommend that there is atleast one of every RPC permission call type included in here and to ensure that they are passing. ",a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-21 20:06:55,102304599,"@@ -147,7 +147,7 @@ func testPermissions(t *testing.T,
 	nonceString := """"
 
 	_, err := Permissions(nodeClient, keyClient, publicKeyString, addressString,
-		nonceString, ""set_base"", []string{permAddressString, ""root"", ""true""})
+		nonceString, ""setBase"", []string{permAddressString, ""root"", ""true""})",5,2017-02-21 20:06:56,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102304599,https://github.com/hyperledger/burrow/pull/500#discussion_r102304599,VoR0220
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,"""TxCache implements vm.AppState"", what sort of comment were you after?",a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-22 12:52:27,102454422,"@@ -19,6 +19,8 @@ type TxCache struct {
 	storages map[Tuple256]Word256
 }
 
+var _ vm.AppState = &TxCache{}",4,2017-02-22 12:52:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102454422,https://github.com/hyperledger/burrow/pull/500#discussion_r102454422,silasdavis
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,If you want to see what permissions are set at the account level. Knowing effective permissions is also useful I agree.,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-22 12:53:53,102454682,"@@ -112,6 +112,12 @@ func (p *BasePermissions) IsSet(ty PermFlag) bool {
 	return p.SetBit&ty > 0
 }
 
+// Returns the Perms PermFlag masked with SetBit bit field to give the resultant
+// permissions enabled by this BasePermissions
+func (p *BasePermissions) ResultantPerms() PermFlag {",6,2017-02-22 12:53:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102454682,https://github.com/hyperledger/burrow/pull/500#discussion_r102454682,silasdavis
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,"optionally yes, it s not entirely obvious otherwise",a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-22 12:54:10,102454734,"@@ -19,6 +19,8 @@ type TxCache struct {
 	storages map[Tuple256]Word256
 }
 
+var _ vm.AppState = &TxCache{}",4,2017-02-22 12:54:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102454734,https://github.com/hyperledger/burrow/pull/500#discussion_r102454734,benjaminbollen
https://github.com/hyperledger/burrow/pull/500,https://github.com/hyperledger/burrow/pull/500,Given that `BasePermissions.Perms` and `BasePermissions.SetBit` are both public fields I'd say this was arguably less obscure in meaning than those. Callers are allowed to interrogate account level permissions and global permissions separately. ,a48afca83ea3556a51a9af3de7198db2ac0172df,2017-02-22 12:57:51,102455381,"@@ -112,6 +112,12 @@ func (p *BasePermissions) IsSet(ty PermFlag) bool {
 	return p.SetBit&ty > 0
 }
 
+// Returns the Perms PermFlag masked with SetBit bit field to give the resultant
+// permissions enabled by this BasePermissions
+func (p *BasePermissions) ResultantPerms() PermFlag {",6,2017-02-22 12:57:51,https://api.github.com/repos/hyperledger/burrow/pulls/comments/102455381,https://github.com/hyperledger/burrow/pull/500#discussion_r102455381,silasdavis
https://github.com/hyperledger/burrow/pull/492,https://github.com/hyperledger/burrow/pull/492,is that necessary?,2eb0b0d389fda05a71dfd173420bf9e324788cc0,2017-02-11 17:21:48,100671911,"@@ -55,6 +55,15 @@ deployment:
       - docker push quay.io/eris/db
       # push the updated documentation
       - docs/build.sh
+  develop:
+    branch: develop
+    commands:
+      - docker login -e $DOCKER_EMAIL -u $DOCKER_USER -p $DOCKER_PASS quay.io
+      # build docker image and tag the image with the version
+      - tests/build_tool.sh
+      - docker push quay.io/eris/db
+      # push the updated documentation and replace latest
+      - docs/build.sh",,2017-02-11 21:08:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100671911,https://github.com/hyperledger/burrow/pull/492#discussion_r100671911,zramsay
https://github.com/hyperledger/burrow/pull/492,https://github.com/hyperledger/burrow/pull/492,the docs building? no probably not.  Ill take it out,2eb0b0d389fda05a71dfd173420bf9e324788cc0,2017-02-11 21:03:46,100676717,"@@ -55,6 +55,15 @@ deployment:
       - docker push quay.io/eris/db
       # push the updated documentation
       - docs/build.sh
+  develop:
+    branch: develop
+    commands:
+      - docker login -e $DOCKER_EMAIL -u $DOCKER_USER -p $DOCKER_PASS quay.io
+      # build docker image and tag the image with the version
+      - tests/build_tool.sh
+      - docker push quay.io/eris/db
+      # push the updated documentation and replace latest
+      - docs/build.sh",,2017-02-11 21:08:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100676717,https://github.com/hyperledger/burrow/pull/492#discussion_r100676717,benjaminbollen
https://github.com/hyperledger/burrow/pull/484,https://github.com/hyperledger/burrow/pull/484,informational question: do we know where hashicorp/hcl sits in the dependency tree? ,23b629bcd865a781d0b4569e1c094b0429561dc2,2017-02-09 14:14:59,100313913,"@@ -42,37 +52,45 @@ imports:
   version: d9eb7a3d35ec988b8585d4a0068e462c27d28380
 - name: github.com/gorilla/websocket
   version: a68708917c6a4f06314ab4e52493cc61359c9d42
+- name: github.com/Graylog2/go-gelf
+  version: 5bfd5bbbfe86489017c268bf86539fcec7e28d8e
 - name: github.com/hashicorp/hcl",,2017-04-13 18:49:38,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100313913,https://github.com/hyperledger/burrow/pull/484#discussion_r100313913,benjaminbollen
https://github.com/hyperledger/burrow/pull/484,https://github.com/hyperledger/burrow/pull/484,Noted. ,23b629bcd865a781d0b4569e1c094b0429561dc2,2017-02-09 14:22:52,100315470,"@@ -0,0 +1,80 @@
+package config
+
+import (
+	""bytes""
+
+	""fmt""
+
+	""github.com/BurntSushi/toml""
+	""github.com/eris-ltd/eris-db/logging/structure""
+)
+
+type LoggingConfig struct {
+	InfoSink         *SinkConfig `toml:""info_sink""`
+	InfoAndTraceSink *SinkConfig `toml:""info_and_trace_sink""`
+}
+
+// For encoding a top-level '[logging]' TOML table
+type LoggingConfigWrapper struct {
+	Logging *LoggingConfig `toml:""logging""`
+}
+
+func DefaultNodeLoggingConfig() *LoggingConfig {
+	return &LoggingConfig{
+		InfoSink:         Sink(),
+		InfoAndTraceSink: Sink().SetOutput(StderrOutput()),
+	}
+}
+
+func DefaultClientLoggingConfig() *LoggingConfig {
+	return &LoggingConfig{
+		// No output
+		InfoSink: Sink().
+			SetTransform(FilterTransform(ExcludeWhenAnyMatches,
+				structure.CapturedLoggingSourceKey, """")).
+			SetOutput(StderrOutput()),
+		InfoAndTraceSink: Sink(),
+	}
+}
+
+// Returns the TOML for a top-level logging config wrapped with [logging]
+func (lc *LoggingConfig) RootTOMLString() string {
+	return tomlString(LoggingConfigWrapper{lc})
+}
+
+func (lc *LoggingConfig) TOMLString() string {
+	return tomlString(lc)
+}
+
+func LoggingConfigFromMap(loggingRootMap map[string]interface{}) (*LoggingConfig, error) {
+	lc := new(LoggingConfig)
+	buf := new(bytes.Buffer)
+	enc := toml.NewEncoder(buf)
+	// TODO: [Silas] consider using strongly typed config/struct mapping everywhere",53,2017-04-13 18:49:38,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100315470,https://github.com/hyperledger/burrow/pull/484#discussion_r100315470,benjaminbollen
https://github.com/hyperledger/burrow/pull/484,https://github.com/hyperledger/burrow/pull/484,"**(shivers)** ... because it is in logging/config, but I'm not fully on-board here. Ok to pass.",23b629bcd865a781d0b4569e1c094b0429561dc2,2017-02-09 14:25:48,100316130,"@@ -0,0 +1,80 @@
+package config
+
+import (
+	""bytes""
+
+	""fmt""
+
+	""github.com/BurntSushi/toml""
+	""github.com/eris-ltd/eris-db/logging/structure""
+)
+
+type LoggingConfig struct {
+	InfoSink         *SinkConfig `toml:""info_sink""`
+	InfoAndTraceSink *SinkConfig `toml:""info_and_trace_sink""`
+}
+
+// For encoding a top-level '[logging]' TOML table
+type LoggingConfigWrapper struct {
+	Logging *LoggingConfig `toml:""logging""`
+}
+
+func DefaultNodeLoggingConfig() *LoggingConfig {
+	return &LoggingConfig{
+		InfoSink:         Sink(),
+		InfoAndTraceSink: Sink().SetOutput(StderrOutput()),
+	}
+}
+
+func DefaultClientLoggingConfig() *LoggingConfig {
+	return &LoggingConfig{
+		// No output
+		InfoSink: Sink().
+			SetTransform(FilterTransform(ExcludeWhenAnyMatches,
+				structure.CapturedLoggingSourceKey, """")).
+			SetOutput(StderrOutput()),
+		InfoAndTraceSink: Sink(),
+	}
+}
+
+// Returns the TOML for a top-level logging config wrapped with [logging]
+func (lc *LoggingConfig) RootTOMLString() string {
+	return tomlString(LoggingConfigWrapper{lc})
+}
+
+func (lc *LoggingConfig) TOMLString() string {
+	return tomlString(lc)
+}
+
+func LoggingConfigFromMap(loggingRootMap map[string]interface{}) (*LoggingConfig, error) {
+	lc := new(LoggingConfig)
+	buf := new(bytes.Buffer)
+	enc := toml.NewEncoder(buf)
+	// TODO: [Silas] consider using strongly typed config/struct mapping everywhere
+	// (!! unfortunately the way we are using viper
+	// to pass around a untyped bag of config means that we don't get keys mapped
+	// according to their metadata `toml:""Name""` tags. So we are re-encoding to toml
+	// and then decoding into the strongly type struct as a work-around)
+	// Encode the map back to TOML
+	err := enc.Encode(loggingRootMap)
+	if err != nil {
+		return nil, err
+	}
+	// Decode into struct into the LoggingConfig struct
+	_, err = toml.Decode(buf.String(), lc)
+	if err != nil {
+		return nil, err
+	}
+	return lc, nil
+}
+
+func tomlString(v interface{}) string {
+	buf := new(bytes.Buffer)
+	encoder := toml.NewEncoder(buf)
+	err := encoder.Encode(v)
+	if err != nil {
+		// Seems like a reasonable compromise to make the string function clean",76,2017-04-13 18:49:38,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100316130,https://github.com/hyperledger/burrow/pull/484#discussion_r100316130,benjaminbollen
https://github.com/hyperledger/burrow/pull/484,https://github.com/hyperledger/burrow/pull/484,Label: A Label!,23b629bcd865a781d0b4569e1c094b0429561dc2,2017-02-09 14:30:16,100317189,"@@ -0,0 +1,112 @@
+package config
+
+import (
+	""testing""
+
+	""github.com/stretchr/testify/assert""
+)
+
+func TestBuildLoggerFromSinkConfig(t *testing.T) {
+	sinkConfig := Sink().
+		AddSinks(
+			Sink().
+				AddSinks(
+					Sink().
+						AddSinks(
+							Sink().
+								SetTransform(CaptureTransform(""cap"", 100, true)).
+								SetOutput(StderrOutput()).
+								AddSinks(
+									Sink().
+										SetTransform(LabelTransform(true, ""Label"", ""A Label!"")).",21,2017-04-13 18:49:38,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100317189,https://github.com/hyperledger/burrow/pull/484#discussion_r100317189,benjaminbollen
https://github.com/hyperledger/burrow/pull/484,https://github.com/hyperledger/burrow/pull/484,Pulled in by Viper (util.go),23b629bcd865a781d0b4569e1c094b0429561dc2,2017-02-10 14:52:32,100549521,"@@ -42,37 +52,45 @@ imports:
   version: d9eb7a3d35ec988b8585d4a0068e462c27d28380
 - name: github.com/gorilla/websocket
   version: a68708917c6a4f06314ab4e52493cc61359c9d42
+- name: github.com/Graylog2/go-gelf
+  version: 5bfd5bbbfe86489017c268bf86539fcec7e28d8e
 - name: github.com/hashicorp/hcl",,2017-04-13 18:49:38,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100549521,https://github.com/hyperledger/burrow/pull/484#discussion_r100549521,silasdavis
https://github.com/hyperledger/burrow/pull/484,https://github.com/hyperledger/burrow/pull/484,"The reasoning is, this will generate pretty obviously failing config if it does slip through, shouldn't cause a runtime issue, and primarily because failures are highly likely to be caught by tests. It doesn't seem reasonable to error or panic on encoding a well-known type like this.

That said, I also feel borderline about this.",23b629bcd865a781d0b4569e1c094b0429561dc2,2017-02-10 14:59:20,100550917,"@@ -0,0 +1,80 @@
+package config
+
+import (
+	""bytes""
+
+	""fmt""
+
+	""github.com/BurntSushi/toml""
+	""github.com/eris-ltd/eris-db/logging/structure""
+)
+
+type LoggingConfig struct {
+	InfoSink         *SinkConfig `toml:""info_sink""`
+	InfoAndTraceSink *SinkConfig `toml:""info_and_trace_sink""`
+}
+
+// For encoding a top-level '[logging]' TOML table
+type LoggingConfigWrapper struct {
+	Logging *LoggingConfig `toml:""logging""`
+}
+
+func DefaultNodeLoggingConfig() *LoggingConfig {
+	return &LoggingConfig{
+		InfoSink:         Sink(),
+		InfoAndTraceSink: Sink().SetOutput(StderrOutput()),
+	}
+}
+
+func DefaultClientLoggingConfig() *LoggingConfig {
+	return &LoggingConfig{
+		// No output
+		InfoSink: Sink().
+			SetTransform(FilterTransform(ExcludeWhenAnyMatches,
+				structure.CapturedLoggingSourceKey, """")).
+			SetOutput(StderrOutput()),
+		InfoAndTraceSink: Sink(),
+	}
+}
+
+// Returns the TOML for a top-level logging config wrapped with [logging]
+func (lc *LoggingConfig) RootTOMLString() string {
+	return tomlString(LoggingConfigWrapper{lc})
+}
+
+func (lc *LoggingConfig) TOMLString() string {
+	return tomlString(lc)
+}
+
+func LoggingConfigFromMap(loggingRootMap map[string]interface{}) (*LoggingConfig, error) {
+	lc := new(LoggingConfig)
+	buf := new(bytes.Buffer)
+	enc := toml.NewEncoder(buf)
+	// TODO: [Silas] consider using strongly typed config/struct mapping everywhere
+	// (!! unfortunately the way we are using viper
+	// to pass around a untyped bag of config means that we don't get keys mapped
+	// according to their metadata `toml:""Name""` tags. So we are re-encoding to toml
+	// and then decoding into the strongly type struct as a work-around)
+	// Encode the map back to TOML
+	err := enc.Encode(loggingRootMap)
+	if err != nil {
+		return nil, err
+	}
+	// Decode into struct into the LoggingConfig struct
+	_, err = toml.Decode(buf.String(), lc)
+	if err != nil {
+		return nil, err
+	}
+	return lc, nil
+}
+
+func tomlString(v interface{}) string {
+	buf := new(bytes.Buffer)
+	encoder := toml.NewEncoder(buf)
+	err := encoder.Encode(v)
+	if err != nil {
+		// Seems like a reasonable compromise to make the string function clean",76,2017-04-13 18:49:38,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100550917,https://github.com/hyperledger/burrow/pull/484#discussion_r100550917,silasdavis
https://github.com/hyperledger/burrow/pull/484,https://github.com/hyperledger/burrow/pull/484,"It's a label, if that was unclear",23b629bcd865a781d0b4569e1c094b0429561dc2,2017-02-10 14:59:37,100550986,"@@ -0,0 +1,112 @@
+package config
+
+import (
+	""testing""
+
+	""github.com/stretchr/testify/assert""
+)
+
+func TestBuildLoggerFromSinkConfig(t *testing.T) {
+	sinkConfig := Sink().
+		AddSinks(
+			Sink().
+				AddSinks(
+					Sink().
+						AddSinks(
+							Sink().
+								SetTransform(CaptureTransform(""cap"", 100, true)).
+								SetOutput(StderrOutput()).
+								AddSinks(
+									Sink().
+										SetTransform(LabelTransform(true, ""Label"", ""A Label!"")).",21,2017-04-13 18:49:38,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100550986,https://github.com/hyperledger/burrow/pull/484#discussion_r100550986,silasdavis
https://github.com/hyperledger/burrow/pull/484,https://github.com/hyperledger/burrow/pull/484,this dependency can be removed normally (and the repo is monax/keys now) ,23b629bcd865a781d0b4569e1c094b0429561dc2,2017-04-13 17:45:33,111446727,"@@ -29,8 +29,12 @@ imports:
   version: 44cc805cf13205b55f69e14bcb69867d1ae92f98
 - name: github.com/ebuchman/fail-test
   version: c1eddaa09da2b4017351245b0d43234955276798
+- name: github.com/monax/eris-keys",,2017-04-13 18:49:38,https://api.github.com/repos/hyperledger/burrow/pulls/comments/111446727,https://github.com/hyperledger/burrow/pull/484#discussion_r111446727,benjaminbollen
https://github.com/hyperledger/burrow/pull/484,https://github.com/hyperledger/burrow/pull/484,This should not be here; corresponds to comment on glide.lock,23b629bcd865a781d0b4569e1c094b0429561dc2,2017-04-13 17:46:12,111446867,"@@ -1,5 +1,6 @@
 package: github.com/hyperledger/burrow
 import:
+- package: github.com/monax/eris-keys",,2017-04-13 18:49:38,https://api.github.com/repos/hyperledger/burrow/pulls/comments/111446867,https://github.com/hyperledger/burrow/pull/484#discussion_r111446867,benjaminbollen
https://github.com/hyperledger/burrow/pull/484,https://github.com/hyperledger/burrow/pull/484,doesnt need the separation; and below best separate and switch order,23b629bcd865a781d0b4569e1c094b0429561dc2,2017-04-13 17:54:00,111448507,"@@ -0,0 +1,80 @@
+package config
+
+import (
+	""bytes""
+",,2017-04-13 18:49:38,https://api.github.com/repos/hyperledger/burrow/pulls/comments/111448507,https://github.com/hyperledger/burrow/pull/484#discussion_r111448507,benjaminbollen
https://github.com/hyperledger/burrow/pull/479,https://github.com/hyperledger/burrow/pull/479,This is not good.,5473ab7e414fadef4110b0bd5381add7c5e80cdb,2017-02-08 18:15:54,100132247,"@@ -167,7 +168,15 @@ func (app *ErisMint) Commit() (res tmsp.Result) {
 	// flush events to listeners (XXX: note issue with blocking)
 	app.evc.Flush()
 
-	return tmsp.NewResultOK(app.state.Hash(), ""Success"")
+	// MARMOT:",13,2017-02-10 19:43:08,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100132247,https://github.com/hyperledger/burrow/pull/479#discussion_r100132247,benjaminbollen
https://github.com/hyperledger/burrow/pull/479,https://github.com/hyperledger/burrow/pull/479,This is not good.,5473ab7e414fadef4110b0bd5381add7c5e80cdb,2017-02-08 18:16:18,100132339,"@@ -156,7 +157,9 @@ func (vm *VM) DelegateCall(caller, callee *Account, code, input []byte, value in
 
 	exception := new(string)
 	// fire the post call event (including exception if applicable)
-	defer vm.fireCallEvent(exception, &output, caller, callee, input, value, gas)
+	// NOTE: [ben] hotfix for issue 371;",37,2017-02-10 19:43:08,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100132339,https://github.com/hyperledger/burrow/pull/479#discussion_r100132339,benjaminbollen
https://github.com/hyperledger/burrow/pull/479,https://github.com/hyperledger/burrow/pull/479,This is not good.,5473ab7e414fadef4110b0bd5381add7c5e80cdb,2017-02-08 18:16:38,100132392,"@@ -416,7 +416,10 @@ func MakeGenesisState(db dbm.DB, genDoc *genesis.GenesisDoc) *State {
 	}
 
 	if genDoc.GenesisTime.IsZero() {
-		genDoc.GenesisTime = time.Now()
+		// MARMOT: really?",5,2017-02-10 19:43:08,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100132392,https://github.com/hyperledger/burrow/pull/479#discussion_r100132392,benjaminbollen
https://github.com/hyperledger/burrow/pull/479,https://github.com/hyperledger/burrow/pull/479,This is not good.,5473ab7e414fadef4110b0bd5381add7c5e80cdb,2017-02-08 18:16:53,100132453,"@@ -416,7 +416,10 @@ func MakeGenesisState(db dbm.DB, genDoc *genesis.GenesisDoc) *State {
 	}
 
 	if genDoc.GenesisTime.IsZero() {
-		genDoc.GenesisTime = time.Now()
+		// MARMOT: really?
+		// set time to 11/18/2016 @ 4:09am (UTC)
+		genDoc.GenesisTime = time.Unix(1479442162, 0)",7,2017-02-10 19:43:08,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100132453,https://github.com/hyperledger/burrow/pull/479#discussion_r100132453,benjaminbollen
https://github.com/hyperledger/burrow/pull/478,https://github.com/hyperledger/burrow/pull/478,Please remove this change from the PR since it is not related to https://github.com/eris-ltd/eris-db/issues/417,421be21b617f87f336799bb3f0afcd3a020c0f8c,2017-02-08 11:26:13,100044507,"@@ -562,25 +564,32 @@ func (vm *VM) call(caller, callee *Account, code, input []byte, value int64, gas
 
 		case EXTCODESIZE: // 0x3B
 			addr := stack.Pop()
+
 			if useGasNegative(gas, GasGetAccount, &err) {
 				return nil, err
 			}
 			acc := vm.appState.GetAccount(addr)
 			if acc == nil {
-				return nil, firstErr(err, ErrUnknownAddress)
+				if _, ok := registeredNativeContracts[addr]; !ok {",27,2017-02-08 11:30:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100044507,https://github.com/hyperledger/burrow/pull/478#discussion_r100044507,silasdavis
https://github.com/hyperledger/burrow/pull/478,https://github.com/hyperledger/burrow/pull/478,remove,421be21b617f87f336799bb3f0afcd3a020c0f8c,2017-02-08 11:26:27,100044544,"@@ -562,25 +564,32 @@ func (vm *VM) call(caller, callee *Account, code, input []byte, value int64, gas
 
 		case EXTCODESIZE: // 0x3B
 			addr := stack.Pop()
+
 			if useGasNegative(gas, GasGetAccount, &err) {
 				return nil, err
 			}
 			acc := vm.appState.GetAccount(addr)
 			if acc == nil {
-				return nil, firstErr(err, ErrUnknownAddress)
+				if _, ok := registeredNativeContracts[addr]; !ok {
+					fmt.Println(""ERROR IN EXTCODESIZE!"")
+					return nil, firstErr(err, ErrUnknownAddress)
+				}
+				stack.Push64(int64(1))
+				dbg.Printf("" => Hit native contract\n"")
+			} else {
+				code := acc.Code
+				l := int64(len(code))
+				stack.Push64(l)
+				dbg.Printf("" => %d\n"", l)
 			}
-			code := acc.Code
-			l := int64(len(code))
-			stack.Push64(l)
-			dbg.Printf("" => %d\n"", l)
-
 		case EXTCODECOPY: // 0x3C
 			addr := stack.Pop()
 			if useGasNegative(gas, GasGetAccount, &err) {
 				return nil, err
 			}
 			acc := vm.appState.GetAccount(addr)
 			if acc == nil {
+				fmt.Println(""ERROR IN EXTCODECOPY!"")",51,2017-02-08 11:30:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100044544,https://github.com/hyperledger/burrow/pull/478#discussion_r100044544,silasdavis
https://github.com/hyperledger/burrow/pull/478,https://github.com/hyperledger/burrow/pull/478,remove,421be21b617f87f336799bb3f0afcd3a020c0f8c,2017-02-08 11:26:33,100044559,"@@ -831,11 +840,13 @@ func (vm *VM) call(caller, callee *Account, code, input []byte, value int64, gas
 				// ethereum actually cares
 				if op == CALLCODE {
 					if acc == nil {
+						fmt.Println(""ERROR IN CALLCODE!"")",59,2017-02-08 11:30:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100044559,https://github.com/hyperledger/burrow/pull/478#discussion_r100044559,silasdavis
https://github.com/hyperledger/burrow/pull/478,https://github.com/hyperledger/burrow/pull/478,remove,421be21b617f87f336799bb3f0afcd3a020c0f8c,2017-02-08 11:26:40,100044579,"@@ -831,11 +840,13 @@ func (vm *VM) call(caller, callee *Account, code, input []byte, value int64, gas
 				// ethereum actually cares
 				if op == CALLCODE {
 					if acc == nil {
+						fmt.Println(""ERROR IN CALLCODE!"")
 						return nil, firstErr(err, ErrUnknownAddress)
 					}
 					ret, err = vm.Call(callee, callee, acc.Code, args, value, &gasLimit)
 				} else if op == DELEGATECALL {
 					if acc == nil {
+						fmt.Println(""ERROR IN DELEGATECALL!"")",65,2017-02-08 11:30:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100044579,https://github.com/hyperledger/burrow/pull/478#discussion_r100044579,silasdavis
https://github.com/hyperledger/burrow/pull/478,https://github.com/hyperledger/burrow/pull/478,remove,421be21b617f87f336799bb3f0afcd3a020c0f8c,2017-02-08 11:26:49,100044594,"@@ -890,6 +901,7 @@ func (vm *VM) call(caller, callee *Account, code, input []byte, value int64, gas
 			// TODO: create account if doesn't exist (no reason not to)
 			receiver := vm.appState.GetAccount(addr)
 			if receiver == nil {
+				fmt.Println(""ERROR IN SUICIDE!"")",73,2017-02-08 11:30:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100044594,https://github.com/hyperledger/burrow/pull/478#discussion_r100044594,silasdavis
https://github.com/hyperledger/burrow/pull/478,https://github.com/hyperledger/burrow/pull/478,How did you generate these? We really ought to automate and document this,421be21b617f87f336799bb3f0afcd3a020c0f8c,2017-02-08 11:27:56,100044819,"@@ -53,13 +52,13 @@ contract Permissions {
 
 // function identifiers from the solidity abi
 var PermsMap = map[string]SNativeFuncDescription{
-	""e8145855"": SNativeFuncDescription{""has_role"", 2, ptypes.HasRole, has_role},",12,2017-02-08 11:30:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100044819,https://github.com/hyperledger/burrow/pull/478#discussion_r100044819,silasdavis
https://github.com/hyperledger/burrow/pull/476,https://github.com/hyperledger/burrow/pull/476,"Thus far we have not returned a code size for native contracts.  Is this motivated by a change in solidity, where it newly checks the code length before going to a contract.  We have not had a problem before calling our snative contracts.  Can you document and elaborate?",9e141fa0c29d3e53e011ac7dae7249526caacf6e,2017-02-08 11:48:59,100048196,"@@ -565,13 +565,17 @@ func (vm *VM) call(caller, callee *Account, code, input []byte, value int64, gas
 			}
 			acc := vm.appState.GetAccount(addr)
 			if acc == nil {
-				return nil, firstErr(err, ErrUnknownAddress)
+				if _, ok := registeredNativeContracts[addr]; !ok {",37,2017-02-08 17:41:21,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100048196,https://github.com/hyperledger/burrow/pull/476#discussion_r100048196,benjaminbollen
https://github.com/hyperledger/burrow/pull/476,https://github.com/hyperledger/burrow/pull/476,More idiomatic and a little more efficient to use `stack.Push(One256) here`,9e141fa0c29d3e53e011ac7dae7249526caacf6e,2017-02-08 16:24:33,100106220,"@@ -565,13 +565,17 @@ func (vm *VM) call(caller, callee *Account, code, input []byte, value int64, gas
 			}
 			acc := vm.appState.GetAccount(addr)
 			if acc == nil {
-				return nil, firstErr(err, ErrUnknownAddress)
+				if _, ok := registeredNativeContracts[addr]; !ok {
+					return nil, firstErr(err, ErrUnknownAddress)
+				}
+				stack.Push64(int64(1))",,2017-02-08 17:41:21,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100106220,https://github.com/hyperledger/burrow/pull/476#discussion_r100106220,silasdavis
https://github.com/hyperledger/burrow/pull/476,https://github.com/hyperledger/burrow/pull/476,"again, I think this should be `stack.Push(One256)` it saves doing the conversion to use the constant, and it is used elsewhere",9e141fa0c29d3e53e011ac7dae7249526caacf6e,2017-02-08 17:24:23,100121135,"@@ -565,21 +566,28 @@ func (vm *VM) call(caller, callee *Account, code, input []byte, value int64, gas
 			}
 			acc := vm.appState.GetAccount(addr)
 			if acc == nil {
-				return nil, firstErr(err, ErrUnknownAddress)
+				if _, ok := registeredNativeContracts[addr]; !ok {
+					return nil, firstErr(err, ErrUnknownAddress)
+				}
+				stack.Push64(int64(One256))
+				dbg.Printf("" => Hit native contract\n\n"")
+			} else {
+				code := acc.Code
+				l := int64(len(code))
+				stack.Push64(l)",,2017-02-08 17:41:21,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100121135,https://github.com/hyperledger/burrow/pull/476#discussion_r100121135,silasdavis
https://github.com/hyperledger/burrow/pull/476,https://github.com/hyperledger/burrow/pull/476,This is the actual code length for normal contracts that are not natives. ,9e141fa0c29d3e53e011ac7dae7249526caacf6e,2017-02-08 17:25:05,100121287,"@@ -565,21 +566,28 @@ func (vm *VM) call(caller, callee *Account, code, input []byte, value int64, gas
 			}
 			acc := vm.appState.GetAccount(addr)
 			if acc == nil {
-				return nil, firstErr(err, ErrUnknownAddress)
+				if _, ok := registeredNativeContracts[addr]; !ok {
+					return nil, firstErr(err, ErrUnknownAddress)
+				}
+				stack.Push64(int64(One256))
+				dbg.Printf("" => Hit native contract\n\n"")
+			} else {
+				code := acc.Code
+				l := int64(len(code))
+				stack.Push64(l)",,2017-02-08 17:41:21,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100121287,https://github.com/hyperledger/burrow/pull/476#discussion_r100121287,VoR0220
https://github.com/hyperledger/burrow/pull/476,https://github.com/hyperledger/burrow/pull/476,It should stay as it is. ,9e141fa0c29d3e53e011ac7dae7249526caacf6e,2017-02-08 17:25:17,100121336,"@@ -565,21 +566,28 @@ func (vm *VM) call(caller, callee *Account, code, input []byte, value int64, gas
 			}
 			acc := vm.appState.GetAccount(addr)
 			if acc == nil {
-				return nil, firstErr(err, ErrUnknownAddress)
+				if _, ok := registeredNativeContracts[addr]; !ok {
+					return nil, firstErr(err, ErrUnknownAddress)
+				}
+				stack.Push64(int64(One256))
+				dbg.Printf("" => Hit native contract\n\n"")
+			} else {
+				code := acc.Code
+				l := int64(len(code))
+				stack.Push64(l)",,2017-02-08 17:41:21,https://api.github.com/repos/hyperledger/burrow/pulls/comments/100121336,https://github.com/hyperledger/burrow/pull/476#discussion_r100121336,VoR0220
https://github.com/hyperledger/burrow/pull/465,https://github.com/hyperledger/burrow/pull/465,How about making this an interface with a marker method `func AssertIsRPCResponse()`?,5377dcd04bbdff0e19ddd33bcbf78b9bf14fb879,2017-01-31 15:27:35,98692171,"@@ -22,35 +38,47 @@ type (
 		Id      string          `json:""id""`
 	}
 
-	RPCResponse struct {
+	// RPCResponse MUST follow the JSON-RPC specification for Response object
+	// reference: http://www.jsonrpc.org/specification#response_object
+	RPCResponse interface{}",,2017-01-31 15:59:43,https://api.github.com/repos/hyperledger/burrow/pulls/comments/98692171,https://github.com/hyperledger/burrow/pull/465#discussion_r98692171,silasdavis
https://github.com/hyperledger/burrow/pull/463,https://github.com/hyperledger/burrow/pull/463,"Rule Britannia, Britannia rules the waves...",d1634c899d224dfa79ccc8060286ffadbc3214c3,2017-01-30 11:38:49,98423875,"@@ -3,13 +3,8 @@ MAINTAINER Monax <support@monax.io>
 
 ENV TARGET eris-db
 
-# runtime customization start here
-COPY ./eris-client $INSTALL_BASE/eris-client
-COPY ./bin/start_eris_db $INSTALL_BASE/erisdb-wrapper
-# runtime customization end here
-
-# Get the binary from the artifact in pwd
-COPY ./""$TARGET""_build_artifact $INSTALL_BASE/$TARGET
+# Get the binary from the artefact in pwd/target/docker
+COPY ./target/docker/""$TARGET"".dockerartefact $INSTALL_BASE/$TARGET",12,2017-01-30 11:56:37,https://api.github.com/repos/hyperledger/burrow/pulls/comments/98423875,https://github.com/hyperledger/burrow/pull/463#discussion_r98423875,silasdavis
https://github.com/hyperledger/burrow/pull/463,https://github.com/hyperledger/burrow/pull/463,This is about the most 'programming' I would like to do in a makefile before switching to a more fully featured build tool,d1634c899d224dfa79ccc8060286ffadbc3214c3,2017-01-30 11:44:44,98424684,"@@ -0,0 +1,156 @@
+# ----------------------------------------------------------
+# REQUIREMENTS
+
+# - go installed locally
+# - for build_docker: docker installed locally
+
+# ----------------------------------------------------------
+
+SHELL := /bin/bash
+REPO := $(shell pwd)
+GOFILES_NOVENDOR := $(shell find ${REPO} -type f -name '*.go' -not -path ""${REPO}/vendor/*"")
+PACKAGES_NOVENDOR := $(shell go list github.com/eris-ltd/eris-db/... | grep -v /vendor/)
+VERSION := $(shell cat ${REPO}/version/version.go | tail -n 1 | cut -d \  -f 4 | tr -d '""')
+VERSION_MIN := $(shell echo ${VERSION} | cut -d . -f 1-2)
+COMMIT_SHA := $(shell echo `git rev-parse --short --verify HEAD`)
+
+DOCKER_NAMESPACE := quay.io/eris
+
+
+.PHONY: greet
+greet:
+	@echo ""Hi! I'm the marmot that will help you with eris-db v${VERSION}""
+
+### Formatting, linting and vetting
+
+# check the code for style standards; currently enforces go formatting.
+# display output first, then check for success	
+.PHONY: check
+check:
+	@echo ""Checking code for formatting style compliance.""
+	@gofmt -l -d ${GOFILES_NOVENDOR}
+	@gofmt -l ${GOFILES_NOVENDOR} | read && echo && echo ""Your marmot has found a problem with the formatting style of the code."" 1>&2 && exit 1 || true
+
+# fmt runs gofmt -w on the code, modifying any files that do not match
+# the style guide.
+.PHONY: fmt
+fmt:
+	@echo ""Correcting any formatting style corrections.""
+	@gofmt -l -w ${GOFILES_NOVENDOR}
+
+# lint installs golint and prints recommendations for coding style.
+lint: 
+	@echo ""Running lint checks.""
+	go get -u github.com/golang/lint/golint
+	@for file in $(GOFILES_NOVENDOR); do \",45,2017-01-30 11:56:37,https://api.github.com/repos/hyperledger/burrow/pulls/comments/98424684,https://github.com/hyperledger/burrow/pull/463#discussion_r98424684,silasdavis
https://github.com/hyperledger/burrow/pull/461,https://github.com/hyperledger/burrow/pull/461,Generate known as opposed to what? What is known?,78b35a14f48755a6c88ede9b126f5be9695395cc,2017-01-27 14:04:50,98207623,"@@ -0,0 +1,199 @@
+package genesis
+
+import (
+	""bytes""
+	""encoding/csv""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""os""
+	""strconv""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+	""github.com/eris-ltd/eris-db/util""
+
+	""github.com/tendermint/go-crypto""
+	wire ""github.com/tendermint/go-wire""
+)
+
+//------------------------------------------------------------------------------------
+// core functions
+
+func GenerateKnown(chainID, accountsPathCSV, validatorsPathCSV string) (string, error) {",22,2017-01-27 14:11:20,https://api.github.com/repos/hyperledger/burrow/pulls/comments/98207623,https://github.com/hyperledger/burrow/pull/461#discussion_r98207623,silasdavis
https://github.com/hyperledger/burrow/pull/461,https://github.com/hyperledger/burrow/pull/461,"I could go either way, but I wonder if this would be nicer:

```go
ps := NewParamsWithDefaults(params, nil, ""1000"", """", fmt.Sprintf(""%d"", ptypes.DefaultPermFlags)), permsS[i])
...
ps.get(1)
```

Perhaps not worth it.",78b35a14f48755a6c88ede9b126f5be9695395cc,2017-01-27 14:09:02,98208377,"@@ -0,0 +1,199 @@
+package genesis
+
+import (
+	""bytes""
+	""encoding/csv""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""os""
+	""strconv""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+	""github.com/eris-ltd/eris-db/util""
+
+	""github.com/tendermint/go-crypto""
+	wire ""github.com/tendermint/go-wire""
+)
+
+//------------------------------------------------------------------------------------
+// core functions
+
+func GenerateKnown(chainID, accountsPathCSV, validatorsPathCSV string) (string, error) {
+	var genDoc *GenesisDoc
+
+	// TODO [eb] eliminate reading priv_val ... [zr] where?
+	if accountsPathCSV == """" || validatorsPathCSV == """" {
+		return """", fmt.Errorf(""both accounts.csv and validators.csv is required"")
+	}
+
+	pubkeys, amts, names, perms, setbits, err := parseCsv(validatorsPathCSV)
+	if err != nil {
+		return """", err
+	}
+
+	pubkeysA, amtsA, namesA, permsA, setbitsA, err := parseCsv(accountsPathCSV)
+	if err != nil {
+		return """", err
+	}
+
+	genDoc = newGenDoc(chainID, len(pubkeys), len(pubkeysA))
+	for i, pk := range pubkeys {
+		genDocAddValidator(genDoc, pk, amts[i], names[i], perms[i], setbits[i], i)
+	}
+	for i, pk := range pubkeysA {
+		genDocAddAccount(genDoc, pk, amtsA[i], namesA[i], permsA[i], setbitsA[i], i)
+	}
+
+	buf, buf2, n := new(bytes.Buffer), new(bytes.Buffer), new(int)
+	wire.WriteJSON(genDoc, buf, n, &err)
+	if err != nil {
+		return """", err
+	}
+	if err := json.Indent(buf2, buf.Bytes(), """", ""\t""); err != nil {
+		return """", err
+	}
+
+	return buf2.String(), nil
+}
+
+//-----------------------------------------------------------------------------
+// gendoc convenience functions
+
+func newGenDoc(chainID string, nVal, nAcc int) *GenesisDoc {
+	genDoc := GenesisDoc{
+		ChainID: chainID,
+		// GenesisTime: time.Now(),
+	}
+	genDoc.Accounts = make([]GenesisAccount, nAcc)
+	genDoc.Validators = make([]GenesisValidator, nVal)
+	return &genDoc
+}
+
+func genDocAddAccount(genDoc *GenesisDoc, pubKey crypto.PubKeyEd25519, amt int64, name string, perm, setbit ptypes.PermFlag, index int) {
+	addr := pubKey.Address()
+	acc := GenesisAccount{
+		Address: addr,
+		Amount:  amt,
+		Name:    name,
+		Permissions: &ptypes.AccountPermissions{
+			Base: ptypes.BasePermissions{
+				Perms:  perm,
+				SetBit: setbit,
+			},
+		},
+	}
+	if index < 0 {
+		genDoc.Accounts = append(genDoc.Accounts, acc)
+	} else {
+		genDoc.Accounts[index] = acc
+	}
+}
+
+func genDocAddValidator(genDoc *GenesisDoc, pubKey crypto.PubKeyEd25519, amt int64, name string, perm, setbit ptypes.PermFlag, index int) {
+	addr := pubKey.Address()
+	genDoc.Validators[index] = GenesisValidator{
+		PubKey: pubKey,
+		Amount: amt,
+		Name:   name,
+		UnbondTo: []BasicAccount{
+			{
+				Address: addr,
+				Amount:  amt,
+			},
+		},
+	}
+	// [zr] why no index < 0 like in genDocAddAccount?
+}
+
+//-----------------------------------------------------------------------------
+// util functions
+
+// convert hex strings to ed25519 pubkeys
+func pubKeyStringsToPubKeys(pubkeys []string) ([]crypto.PubKeyEd25519, error) {
+	pubKeys := make([]crypto.PubKeyEd25519, len(pubkeys))
+	for i, k := range pubkeys {
+		pubBytes, err := hex.DecodeString(k)
+		if err != nil {
+			return pubKeys, err
+		}
+		copy(pubKeys[i][:], pubBytes)
+	}
+	return pubKeys, nil
+}
+
+// empty is over written
+func ifExistsElse(list []string, index int, defaultValue string) string {
+	if len(list) > index {
+		if list[index] != """" {
+			return list[index]
+		}
+	}
+	return defaultValue
+}
+
+// takes a csv in the following format: pubkey, starting balance, name, permissions, setbit
+func parseCsv(filePath string) (pubKeys []crypto.PubKeyEd25519, amts []int64, names []string, perms, setbits []ptypes.PermFlag, err error) {
+
+	csvFile, err := os.Open(filePath)
+	if err != nil {
+		util.Fatalf(""Couldn't open file: %s: %v"", filePath, err)
+	}
+	defer csvFile.Close()
+
+	r := csv.NewReader(csvFile)
+	//r.FieldsPerRecord = # of records expected
+	params, err := r.ReadAll()
+	if err != nil {
+		util.Fatalf(""Couldn't read file: %v"", err)
+
+	}
+
+	pubkeys := make([]string, len(params))
+	amtS := make([]string, len(params))
+	names = make([]string, len(params))
+	permsS := make([]string, len(params))
+	setbitS := make([]string, len(params))
+	for i, each := range params {
+		pubkeys[i] = each[0]
+		amtS[i] = ifExistsElse(each, 1, ""1000"")",159,2017-01-27 14:11:20,https://api.github.com/repos/hyperledger/burrow/pulls/comments/98208377,https://github.com/hyperledger/burrow/pull/461#discussion_r98208377,silasdavis
https://github.com/hyperledger/burrow/pull/461,https://github.com/hyperledger/burrow/pull/461,"GenerateKnown is currently the signature of the function as it is used by cli.  So my plan here is to rewrite package genesis fully, but keep `GenerateKnown` so that we can work on the content of genesis within eris-db without blocking work on cli.  Then afterwards the name and signature of that function can be swapped out.  `GenerateKnown`, in my mind, refers to ""known accounts written in a csv file""",78b35a14f48755a6c88ede9b126f5be9695395cc,2017-01-27 14:15:49,98209495,"@@ -0,0 +1,199 @@
+package genesis
+
+import (
+	""bytes""
+	""encoding/csv""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""os""
+	""strconv""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+	""github.com/eris-ltd/eris-db/util""
+
+	""github.com/tendermint/go-crypto""
+	wire ""github.com/tendermint/go-wire""
+)
+
+//------------------------------------------------------------------------------------
+// core functions
+
+func GenerateKnown(chainID, accountsPathCSV, validatorsPathCSV string) (string, error) {",22,2017-01-27 14:15:49,https://api.github.com/repos/hyperledger/burrow/pulls/comments/98209495,https://github.com/hyperledger/burrow/pull/461#discussion_r98209495,benjaminbollen
https://github.com/hyperledger/burrow/pull/461,https://github.com/hyperledger/burrow/pull/461,"While I was rewriting this, it will not come as a surprise that I simply got rid of ""filling in randomly chosen parameters at randomly hardcoded places in the code"".  The aim here is to get everything onto develop, so that cli can move forward.",78b35a14f48755a6c88ede9b126f5be9695395cc,2017-01-27 14:18:58,98210055,"@@ -0,0 +1,199 @@
+package genesis
+
+import (
+	""bytes""
+	""encoding/csv""
+	""encoding/hex""
+	""encoding/json""
+	""fmt""
+	""os""
+	""strconv""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+	""github.com/eris-ltd/eris-db/util""
+
+	""github.com/tendermint/go-crypto""
+	wire ""github.com/tendermint/go-wire""
+)
+
+//------------------------------------------------------------------------------------
+// core functions
+
+func GenerateKnown(chainID, accountsPathCSV, validatorsPathCSV string) (string, error) {
+	var genDoc *GenesisDoc
+
+	// TODO [eb] eliminate reading priv_val ... [zr] where?
+	if accountsPathCSV == """" || validatorsPathCSV == """" {
+		return """", fmt.Errorf(""both accounts.csv and validators.csv is required"")
+	}
+
+	pubkeys, amts, names, perms, setbits, err := parseCsv(validatorsPathCSV)
+	if err != nil {
+		return """", err
+	}
+
+	pubkeysA, amtsA, namesA, permsA, setbitsA, err := parseCsv(accountsPathCSV)
+	if err != nil {
+		return """", err
+	}
+
+	genDoc = newGenDoc(chainID, len(pubkeys), len(pubkeysA))
+	for i, pk := range pubkeys {
+		genDocAddValidator(genDoc, pk, amts[i], names[i], perms[i], setbits[i], i)
+	}
+	for i, pk := range pubkeysA {
+		genDocAddAccount(genDoc, pk, amtsA[i], namesA[i], permsA[i], setbitsA[i], i)
+	}
+
+	buf, buf2, n := new(bytes.Buffer), new(bytes.Buffer), new(int)
+	wire.WriteJSON(genDoc, buf, n, &err)
+	if err != nil {
+		return """", err
+	}
+	if err := json.Indent(buf2, buf.Bytes(), """", ""\t""); err != nil {
+		return """", err
+	}
+
+	return buf2.String(), nil
+}
+
+//-----------------------------------------------------------------------------
+// gendoc convenience functions
+
+func newGenDoc(chainID string, nVal, nAcc int) *GenesisDoc {
+	genDoc := GenesisDoc{
+		ChainID: chainID,
+		// GenesisTime: time.Now(),
+	}
+	genDoc.Accounts = make([]GenesisAccount, nAcc)
+	genDoc.Validators = make([]GenesisValidator, nVal)
+	return &genDoc
+}
+
+func genDocAddAccount(genDoc *GenesisDoc, pubKey crypto.PubKeyEd25519, amt int64, name string, perm, setbit ptypes.PermFlag, index int) {
+	addr := pubKey.Address()
+	acc := GenesisAccount{
+		Address: addr,
+		Amount:  amt,
+		Name:    name,
+		Permissions: &ptypes.AccountPermissions{
+			Base: ptypes.BasePermissions{
+				Perms:  perm,
+				SetBit: setbit,
+			},
+		},
+	}
+	if index < 0 {
+		genDoc.Accounts = append(genDoc.Accounts, acc)
+	} else {
+		genDoc.Accounts[index] = acc
+	}
+}
+
+func genDocAddValidator(genDoc *GenesisDoc, pubKey crypto.PubKeyEd25519, amt int64, name string, perm, setbit ptypes.PermFlag, index int) {
+	addr := pubKey.Address()
+	genDoc.Validators[index] = GenesisValidator{
+		PubKey: pubKey,
+		Amount: amt,
+		Name:   name,
+		UnbondTo: []BasicAccount{
+			{
+				Address: addr,
+				Amount:  amt,
+			},
+		},
+	}
+	// [zr] why no index < 0 like in genDocAddAccount?
+}
+
+//-----------------------------------------------------------------------------
+// util functions
+
+// convert hex strings to ed25519 pubkeys
+func pubKeyStringsToPubKeys(pubkeys []string) ([]crypto.PubKeyEd25519, error) {
+	pubKeys := make([]crypto.PubKeyEd25519, len(pubkeys))
+	for i, k := range pubkeys {
+		pubBytes, err := hex.DecodeString(k)
+		if err != nil {
+			return pubKeys, err
+		}
+		copy(pubKeys[i][:], pubBytes)
+	}
+	return pubKeys, nil
+}
+
+// empty is over written
+func ifExistsElse(list []string, index int, defaultValue string) string {
+	if len(list) > index {
+		if list[index] != """" {
+			return list[index]
+		}
+	}
+	return defaultValue
+}
+
+// takes a csv in the following format: pubkey, starting balance, name, permissions, setbit
+func parseCsv(filePath string) (pubKeys []crypto.PubKeyEd25519, amts []int64, names []string, perms, setbits []ptypes.PermFlag, err error) {
+
+	csvFile, err := os.Open(filePath)
+	if err != nil {
+		util.Fatalf(""Couldn't open file: %s: %v"", filePath, err)
+	}
+	defer csvFile.Close()
+
+	r := csv.NewReader(csvFile)
+	//r.FieldsPerRecord = # of records expected
+	params, err := r.ReadAll()
+	if err != nil {
+		util.Fatalf(""Couldn't read file: %v"", err)
+
+	}
+
+	pubkeys := make([]string, len(params))
+	amtS := make([]string, len(params))
+	names = make([]string, len(params))
+	permsS := make([]string, len(params))
+	setbitS := make([]string, len(params))
+	for i, each := range params {
+		pubkeys[i] = each[0]
+		amtS[i] = ifExistsElse(each, 1, ""1000"")",159,2017-01-27 14:18:58,https://api.github.com/repos/hyperledger/burrow/pulls/comments/98210055,https://github.com/hyperledger/burrow/pull/461#discussion_r98210055,benjaminbollen
https://github.com/hyperledger/burrow/pull/458,https://github.com/hyperledger/burrow/pull/458,no space needed,4fa87a50c3b8f2bc1eb7d49cf82c1df5f0235a0e,2017-01-26 13:47:37,97995651,"@@ -7,13 +7,13 @@ import (
 	""strings""
 	""text/template""
 
-	docs ""github.com/eris-ltd/eris-db/docs/generator""
 	commands ""github.com/eris-ltd/eris-db/cmd""
+	docs ""github.com/eris-ltd/eris-db/docs/generator""
 ",7,2017-01-26 15:08:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97995651,https://github.com/hyperledger/burrow/pull/458#discussion_r97995651,zramsay
https://github.com/hyperledger/burrow/pull/458,https://github.com/hyperledger/burrow/pull/458,space missing,4fa87a50c3b8f2bc1eb7d49cf82c1df5f0235a0e,2017-01-26 13:47:53,97995702,"@@ -7,13 +7,13 @@ import (
 	""strings""
 	""text/template""
 
-	docs ""github.com/eris-ltd/eris-db/docs/generator""
 	commands ""github.com/eris-ltd/eris-db/cmd""
+	docs ""github.com/eris-ltd/eris-db/docs/generator""
 
 	clientCommands ""github.com/eris-ltd/eris-db/client/cmd""
+	""github.com/eris-ltd/eris-db/definitions""
 	""github.com/eris-ltd/eris-db/version""
 	""github.com/spf13/cobra""",11,2017-01-26 15:08:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97995702,https://github.com/hyperledger/burrow/pull/458#discussion_r97995702,zramsay
https://github.com/hyperledger/burrow/pull/458,https://github.com/hyperledger/burrow/pull/458,rm empty line,4fa87a50c3b8f2bc1eb7d49cf82c1df5f0235a0e,2017-01-26 13:49:13,97995961,"@@ -3,8 +3,9 @@ package loggers
 import (
 	""testing""
 ",3,2017-01-26 15:08:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97995961,https://github.com/hyperledger/burrow/pull/458#discussion_r97995961,zramsay
https://github.com/hyperledger/burrow/pull/458,https://github.com/hyperledger/burrow/pull/458,"```
import (
    ""go""
    ""deps""
    ""are""
    ""here""

    ""repo""
    ""deps""
    ""are""
    ""here""

    ""glided""
    ""deps""
    ""are""
    ""here""
)
````",4fa87a50c3b8f2bc1eb7d49cf82c1df5f0235a0e,2017-01-26 13:51:20,97996332,"@@ -18,8 +18,8 @@ import (
 	""github.com/tendermint/go-wire""
 
 	core_types ""github.com/eris-ltd/eris-db/core/types""
-	""github.com/tendermint/tendermint/types""
 	""github.com/eris-ltd/eris-db/util""
+	""github.com/tendermint/tendermint/types""",6,2017-01-26 15:08:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97996332,https://github.com/hyperledger/burrow/pull/458#discussion_r97996332,zramsay
https://github.com/hyperledger/burrow/pull/458,https://github.com/hyperledger/burrow/pull/458,split import paths per above template,4fa87a50c3b8f2bc1eb7d49cf82c1df5f0235a0e,2017-01-26 13:54:21,97996947,"@@ -6,15 +6,15 @@ import (
 
 	""path/filepath""
 
+	""github.com/Masterminds/glide/action""
 	""github.com/Masterminds/glide/cache""
 	""github.com/Masterminds/glide/cfg""
 	""github.com/Masterminds/glide/msg""
 	""github.com/Masterminds/glide/path""
+	""github.com/Masterminds/glide/repo""
 	""github.com/Masterminds/glide/util""
 	""github.com/eris-ltd/eris-db/util/hell""
 	""github.com/spf13/cobra""",,2017-01-26 15:08:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97996947,https://github.com/hyperledger/burrow/pull/458#discussion_r97996947,zramsay
https://github.com/hyperledger/burrow/pull/455,https://github.com/hyperledger/burrow/pull/455,what's the file for?,4f2e38add04c5b9ac04443390f1f2c735f5b3a81,2017-01-25 18:18:48,97843379,"@@ -0,0 +1,2 @@
+package adapters
+",,2017-01-25 18:55:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97843379,https://github.com/hyperledger/burrow/pull/455#discussion_r97843379,zramsay
https://github.com/hyperledger/burrow/pull/455,https://github.com/hyperledger/burrow/pull/455,we should avoid shorthanding unless there's a good reason,4f2e38add04c5b9ac04443390f1f2c735f5b3a81,2017-01-25 18:19:56,97843604,"@@ -0,0 +1,70 @@
+package adapters
+
+import (
+	""time""
+
+	""github.com/eris-ltd/eris-db/logging/loggers""
+	""github.com/eris-ltd/eris-db/logging/structure""
+	. ""github.com/eris-ltd/eris-db/util/slice""",8,2017-01-25 18:55:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97843604,https://github.com/hyperledger/burrow/pull/455#discussion_r97843604,zramsay
https://github.com/hyperledger/burrow/pull/455,https://github.com/hyperledger/burrow/pull/455,should be on line 5,4f2e38add04c5b9ac04443390f1f2c735f5b3a81,2017-01-25 18:21:10,97843872,"@@ -0,0 +1,32 @@
+package loggers
+
+import (
+	""testing""
+
+	""github.com/stretchr/testify/assert""
+	""fmt""",7,2017-01-25 18:55:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97843872,https://github.com/hyperledger/burrow/pull/455#discussion_r97843872,zramsay
https://github.com/hyperledger/burrow/pull/455,https://github.com/hyperledger/burrow/pull/455,Removed,4f2e38add04c5b9ac04443390f1f2c735f5b3a81,2017-01-25 18:22:21,97844124,"@@ -0,0 +1,2 @@
+package adapters
+",,2017-01-25 18:55:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97844124,https://github.com/hyperledger/burrow/pull/455#discussion_r97844124,silasdavis
https://github.com/hyperledger/burrow/pull/455,https://github.com/hyperledger/burrow/pull/455,remove period?,4f2e38add04c5b9ac04443390f1f2c735f5b3a81,2017-01-25 18:23:23,97844338,"@@ -0,0 +1,146 @@
+package structure
+
+import (
+	""reflect""
+
+	. ""github.com/eris-ltd/eris-db/util/slice""",6,2017-01-25 18:55:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97844338,https://github.com/hyperledger/burrow/pull/455#discussion_r97844338,zramsay
https://github.com/hyperledger/burrow/pull/455,https://github.com/hyperledger/burrow/pull/455,ibid,4f2e38add04c5b9ac04443390f1f2c735f5b3a81,2017-01-25 18:23:38,97844391,"@@ -0,0 +1,36 @@
+package structure
+
+import (
+	""testing""
+
+	. ""github.com/eris-ltd/eris-db/util/slice""",6,2017-01-25 18:55:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97844391,https://github.com/hyperledger/burrow/pull/455#discussion_r97844391,zramsay
https://github.com/hyperledger/burrow/pull/455,https://github.com/hyperledger/burrow/pull/455,I'll make another PR to goimports everything,4f2e38add04c5b9ac04443390f1f2c735f5b3a81,2017-01-25 18:24:04,97844493,"@@ -0,0 +1,32 @@
+package loggers
+
+import (
+	""testing""
+
+	""github.com/stretchr/testify/assert""
+	""fmt""",7,2017-01-25 18:55:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97844493,https://github.com/hyperledger/burrow/pull/455#discussion_r97844493,silasdavis
https://github.com/hyperledger/burrow/pull/455,https://github.com/hyperledger/burrow/pull/455,these don't need to be declared,4f2e38add04c5b9ac04443390f1f2c735f5b3a81,2017-01-25 18:25:08,97844714,"@@ -21,12 +21,13 @@ import (
 
 	events ""github.com/tendermint/go-events""
 
-	log ""github.com/eris-ltd/eris-logger""
-
 	config ""github.com/eris-ltd/eris-db/config""
 	definitions ""github.com/eris-ltd/eris-db/definitions""",7,2017-01-25 18:55:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97844714,https://github.com/hyperledger/burrow/pull/455#discussion_r97844714,zramsay
https://github.com/hyperledger/burrow/pull/455,https://github.com/hyperledger/burrow/pull/455,external package should be on own line below,4f2e38add04c5b9ac04443390f1f2c735f5b3a81,2017-01-25 18:25:44,97844860,"@@ -21,6 +21,7 @@ import (
 
 	""path""
 
+	""github.com/eris-ltd/eris-db/logging/lifecycle""
 	state_types ""github.com/eris-ltd/eris-db/manager/eris-mint/state/types""
 	""github.com/spf13/viper""",6,2017-01-25 18:55:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97844860,https://github.com/hyperledger/burrow/pull/455#discussion_r97844860,zramsay
https://github.com/hyperledger/burrow/pull/455,https://github.com/hyperledger/burrow/pull/455,"In general I would agree. In this case these functions are really intended for brevity and providing builtin-style functions for working with generic slices. I introduced them because there is a lot of that with the generic `Log(keyvals... interface{}) error` kitlog interface. I could be persuaded to step back, but I quite like it how it is.",4f2e38add04c5b9ac04443390f1f2c735f5b3a81,2017-01-25 18:25:59,97844906,"@@ -0,0 +1,70 @@
+package adapters
+
+import (
+	""time""
+
+	""github.com/eris-ltd/eris-db/logging/loggers""
+	""github.com/eris-ltd/eris-db/logging/structure""
+	. ""github.com/eris-ltd/eris-db/util/slice""",8,2017-01-25 18:55:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97844906,https://github.com/hyperledger/burrow/pull/455#discussion_r97844906,silasdavis
https://github.com/hyperledger/burrow/pull/455,https://github.com/hyperledger/burrow/pull/455,i'll shutup then :+1: ,4f2e38add04c5b9ac04443390f1f2c735f5b3a81,2017-01-25 18:26:14,97844962,"@@ -0,0 +1,32 @@
+package loggers
+
+import (
+	""testing""
+
+	""github.com/stretchr/testify/assert""
+	""fmt""",7,2017-01-25 18:55:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97844962,https://github.com/hyperledger/burrow/pull/455#discussion_r97844962,zramsay
https://github.com/hyperledger/burrow/pull/455,https://github.com/hyperledger/burrow/pull/455,Agreed. But not going to change that here.,4f2e38add04c5b9ac04443390f1f2c735f5b3a81,2017-01-25 18:26:30,97845019,"@@ -21,12 +21,13 @@ import (
 
 	events ""github.com/tendermint/go-events""
 
-	log ""github.com/eris-ltd/eris-logger""
-
 	config ""github.com/eris-ltd/eris-db/config""
 	definitions ""github.com/eris-ltd/eris-db/definitions""",7,2017-01-25 18:55:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97845019,https://github.com/hyperledger/burrow/pull/455#discussion_r97845019,silasdavis
https://github.com/hyperledger/burrow/pull/455,https://github.com/hyperledger/burrow/pull/455,Will goimports separately will touch may files so don't want to muddy this.,4f2e38add04c5b9ac04443390f1f2c735f5b3a81,2017-01-25 18:26:52,97845108,"@@ -21,6 +21,7 @@ import (
 
 	""path""
 
+	""github.com/eris-ltd/eris-db/logging/lifecycle""
 	state_types ""github.com/eris-ltd/eris-db/manager/eris-mint/state/types""
 	""github.com/spf13/viper""",6,2017-01-25 18:55:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97845108,https://github.com/hyperledger/burrow/pull/455#discussion_r97845108,silasdavis
https://github.com/hyperledger/burrow/pull/453,https://github.com/hyperledger/burrow/pull/453,"I'm not sure we need this. I think it will work with `DecodeBytes`, did you try that?",7a2ffc6b0eeb83ed18a1b443a60be7c413f4887a,2017-01-26 12:30:18,97983749,"@@ -9,5 +9,6 @@ type Codec interface {
 	EncodeBytes(interface{}) ([]byte, error)
 	Encode(interface{}, io.Writer) error
 	DecodeBytes(interface{}, []byte) error
+	DecodeBytesPtr(interface{}, []byte) error",4,2017-01-26 12:32:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97983749,https://github.com/hyperledger/burrow/pull/453#discussion_r97983749,silasdavis
https://github.com/hyperledger/burrow/pull/453,https://github.com/hyperledger/burrow/pull/453,`wire.ReadJSON` should delegate to `ReadJSONPtr` if it gets a pointer.,7a2ffc6b0eeb83ed18a1b443a60be7c413f4887a,2017-01-26 12:31:53,97983947,"@@ -64,3 +64,11 @@ func (this *TCodec) DecodeBytes(v interface{}, bts []byte) error {
 	wire.ReadJSON(v, bts, &err)
 	return err
 }
+
+// Decode from a byte array pointer.
+func (this *TCodec) DecodeBytesPtr(v interface{}, bts []byte) error {
+       var err error
+       wire.ReadJSONPtr(v, bts, &err)",8,2017-01-26 12:32:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97983947,https://github.com/hyperledger/burrow/pull/453#discussion_r97983947,silasdavis
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,gofmt?,6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-18 15:49:57,96665140,"@@ -17,14 +17,12 @@
 package commands
 
 import (
-	""os""
-	""strings""
+""strings""",,2017-01-23 12:48:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/96665140,https://github.com/hyperledger/burrow/pull/450#discussion_r96665140,benjaminbollen
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,instance of use of util.Fatalf,6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-18 16:05:42,96669121,"@@ -180,26 +178,21 @@ func defaultAddress() string {
 
 func assertParameters(cmd *cobra.Command, args []string) {
 	if clientDo.ChainidFlag == """" {
-		log.Fatal(`Please provide a chain id either through the flag --chain-id or environment variable $CHAIN_ID.`)
-		os.Exit(1)
+		util.Fatalf(`Please provide a chain id either through the flag --chain-id or environment variable $CHAIN_ID.`)
 	}
 
 	if !strings.HasPrefix(clientDo.NodeAddrFlag, ""tcp://"") &&
-		!strings.HasPrefix(clientDo.NodeAddrFlag, ""unix://"") {
+			!strings.HasPrefix(clientDo.NodeAddrFlag, ""unix://"") {
 		// TODO: [ben] go-rpc will deprecate reformatting; also it is bad practice to auto-correct for this;
-		log.Warn(`Please use fully formed listening address for the node, including the tcp:// or unix:// prefix.`)
+		// TODO: [Silas] I've made this fatal, but I'm inclined to define the default as tcp:// and normalise as with http
+		// below
+		util.Fatalf(`Please use fully formed listening address for the node, including the tcp:// or unix:// prefix.`)",67,2017-01-23 12:48:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/96669121,https://github.com/hyperledger/burrow/pull/450#discussion_r96669121,benjaminbollen
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,"woops, arguably here we used os.Exit(1) -- guilty as charged",6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-18 16:06:32,96669331,"@@ -180,26 +178,21 @@ func defaultAddress() string {
 
 func assertParameters(cmd *cobra.Command, args []string) {
 	if clientDo.ChainidFlag == """" {
-		log.Fatal(`Please provide a chain id either through the flag --chain-id or environment variable $CHAIN_ID.`)
-		os.Exit(1)
+		util.Fatalf(`Please provide a chain id either through the flag --chain-id or environment variable $CHAIN_ID.`)",58,2017-01-23 12:48:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/96669331,https://github.com/hyperledger/burrow/pull/450#discussion_r96669331,benjaminbollen
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,"but the new introductions of it are, I believe, to be avoided.  I would not want to regress on this point of no forced exits from library package.",6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-18 16:08:00,96669727,"@@ -17,31 +17,33 @@
 package methods
 
 import (
-	log ""github.com/eris-ltd/eris-logger""
-
 	""github.com/eris-ltd/eris-db/client""
 	""github.com/eris-ltd/eris-db/client/rpc""
 	""github.com/eris-ltd/eris-db/definitions""
 	""github.com/eris-ltd/eris-db/keys""
+	""github.com/eris-ltd/eris-db/util""
 )
 
 func Call(do *definitions.ClientDo) {
 	// construct two clients to call out to keys server and
 	// blockchain node.
-	erisKeyClient := keys.NewErisKeyClient(do.SignAddrFlag)
-	erisNodeClient := client.NewErisNodeClient(do.NodeAddrFlag)
+	logger, err := loggerFromClientDo(do, ""Call"")
+	if err != nil {
+		util.Fatalf(""Could not generate logging config from ClientDo: %s"", err)",,2017-01-23 12:48:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/96669727,https://github.com/hyperledger/burrow/pull/450#discussion_r96669727,benjaminbollen
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,we use `util.IfExit()` for the record. Might be good to standardize across repos.,6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-18 16:37:24,96677137,"@@ -17,31 +17,33 @@
 package methods
 
 import (
-	log ""github.com/eris-ltd/eris-logger""
-
 	""github.com/eris-ltd/eris-db/client""
 	""github.com/eris-ltd/eris-db/client/rpc""
 	""github.com/eris-ltd/eris-db/definitions""
 	""github.com/eris-ltd/eris-db/keys""
+	""github.com/eris-ltd/eris-db/util""
 )
 
 func Call(do *definitions.ClientDo) {
 	// construct two clients to call out to keys server and
 	// blockchain node.
-	erisKeyClient := keys.NewErisKeyClient(do.SignAddrFlag)
-	erisNodeClient := client.NewErisNodeClient(do.NodeAddrFlag)
+	logger, err := loggerFromClientDo(do, ""Call"")
+	if err != nil {
+		util.Fatalf(""Could not generate logging config from ClientDo: %s"", err)",,2017-01-23 12:48:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/96677137,https://github.com/hyperledger/burrow/pull/450#discussion_r96677137,zramsay
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,see https://github.com/eris-ltd/eris-cli/blob/master/util/exit.go,6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-18 16:38:15,96677331,"@@ -17,31 +17,33 @@
 package methods
 
 import (
-	log ""github.com/eris-ltd/eris-logger""
-
 	""github.com/eris-ltd/eris-db/client""
 	""github.com/eris-ltd/eris-db/client/rpc""
 	""github.com/eris-ltd/eris-db/definitions""
 	""github.com/eris-ltd/eris-db/keys""
+	""github.com/eris-ltd/eris-db/util""
 )
 
 func Call(do *definitions.ClientDo) {
 	// construct two clients to call out to keys server and
 	// blockchain node.
-	erisKeyClient := keys.NewErisKeyClient(do.SignAddrFlag)
-	erisNodeClient := client.NewErisNodeClient(do.NodeAddrFlag)
+	logger, err := loggerFromClientDo(do, ""Call"")
+	if err != nil {
+		util.Fatalf(""Could not generate logging config from ClientDo: %s"", err)",,2017-01-23 12:48:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/96677331,https://github.com/hyperledger/burrow/pull/450#discussion_r96677331,zramsay
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,i could have sworn I reviewed a logging PR very recently where `s/this/evts` ... any reason you're going back the other way?,6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-18 16:41:54,96678173,"@@ -178,7 +178,7 @@ func TestSubManualClose(t *testing.T) {
 // Test that the system doesn't fail under high pressure.
 func TestSubFlooding(t *testing.T) {
 	NUM_SUBS := 100
-	// Keep the reaper out of evts.
+	// Keep the reaper out of this.",14,2017-01-23 12:48:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/96678173,https://github.com/hyperledger/burrow/pull/450#discussion_r96678173,zramsay
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,"""time"" should be up with ""os"", followed by \n, then any eris dependencies, then another \n then external dependencies",6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-18 16:44:06,96678784,"@@ -16,8 +15,11 @@ import (
 	""time""",,2017-01-23 12:48:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/96678784,https://github.com/hyperledger/burrow/pull/450#discussion_r96678784,zramsay
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,\n,6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-18 16:45:16,96679048,"@@ -0,0 +1,38 @@
+package loggers
+
+import (
+	""fmt""
+
+	""github.com/eris-ltd/eris-db/logging/structure""
+	kitlog ""github.com/go-kit/kit/log""",,2017-01-23 12:48:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/96679048,https://github.com/hyperledger/burrow/pull/450#discussion_r96679048,zramsay
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,"You did! The code usages are intact, but my refactor accidentally clobbered a bunch of usages of the English word 'this', which was unintentional, and which this corrects.",6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-18 16:48:18,96679801,"@@ -178,7 +178,7 @@ func TestSubManualClose(t *testing.T) {
 // Test that the system doesn't fail under high pressure.
 func TestSubFlooding(t *testing.T) {
 	NUM_SUBS := 100
-	// Keep the reaper out of evts.
+	// Keep the reaper out of this.",14,2017-01-23 12:48:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/96679801,https://github.com/hyperledger/burrow/pull/450#discussion_r96679801,silasdavis
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,"Yeah I agree I was working off the precedent with the exit thing.

As an aside, I don't like `Warn`s; they seem like they'll be useful but they end up being a pain in the arse. I'd rather force the code author to do something drastic (error or exit) or just provide an informational message and make sure continued execution is valid, because I think providing a warning option gives implied license to do unsafe things because 'they were warned', when a lot of the time warnings are ignored/unobserved. Also various packages will 'warn' over things that can never be resolved (because of your architecture for example) so I think the stock of warnings are is pretty low.

In this case, we can return errors from the `methods` package, and `Fatalf` them in the `cmd` package. Don't see any problem with this, but then again when I see `ClientDo` I tend to think we should be able to assume we are at interactive context (and so are allowed to exit). So that is perhaps a separate argument for evicting ClientDo from this level (I'll see how that looks).",6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-18 16:49:24,96680063,"@@ -17,31 +17,33 @@
 package methods
 
 import (
-	log ""github.com/eris-ltd/eris-logger""
-
 	""github.com/eris-ltd/eris-db/client""
 	""github.com/eris-ltd/eris-db/client/rpc""
 	""github.com/eris-ltd/eris-db/definitions""
 	""github.com/eris-ltd/eris-db/keys""
+	""github.com/eris-ltd/eris-db/util""
 )
 
 func Call(do *definitions.ClientDo) {
 	// construct two clients to call out to keys server and
 	// blockchain node.
-	erisKeyClient := keys.NewErisKeyClient(do.SignAddrFlag)
-	erisNodeClient := client.NewErisNodeClient(do.NodeAddrFlag)
+	logger, err := loggerFromClientDo(do, ""Call"")
+	if err != nil {
+		util.Fatalf(""Could not generate logging config from ClientDo: %s"", err)",,2017-01-23 12:48:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/96680063,https://github.com/hyperledger/burrow/pull/450#discussion_r96680063,silasdavis
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,Yeah I think this is legitimate within the cmd package,6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-18 17:17:43,96687016,"@@ -180,26 +178,21 @@ func defaultAddress() string {
 
 func assertParameters(cmd *cobra.Command, args []string) {
 	if clientDo.ChainidFlag == """" {
-		log.Fatal(`Please provide a chain id either through the flag --chain-id or environment variable $CHAIN_ID.`)
-		os.Exit(1)
+		util.Fatalf(`Please provide a chain id either through the flag --chain-id or environment variable $CHAIN_ID.`)
 	}
 
 	if !strings.HasPrefix(clientDo.NodeAddrFlag, ""tcp://"") &&
-		!strings.HasPrefix(clientDo.NodeAddrFlag, ""unix://"") {
+			!strings.HasPrefix(clientDo.NodeAddrFlag, ""unix://"") {
 		// TODO: [ben] go-rpc will deprecate reformatting; also it is bad practice to auto-correct for this;
-		log.Warn(`Please use fully formed listening address for the node, including the tcp:// or unix:// prefix.`)
+		// TODO: [Silas] I've made this fatal, but I'm inclined to define the default as tcp:// and normalise as with http
+		// below
+		util.Fatalf(`Please use fully formed listening address for the node, including the tcp:// or unix:// prefix.`)",67,2017-01-23 12:48:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/96687016,https://github.com/hyperledger/burrow/pull/450#discussion_r96687016,silasdavis
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,As above - I've remove these from methods - but as a helper in the cmd package I think exit here is apt,6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-18 17:18:33,96687236,"@@ -180,26 +178,21 @@ func defaultAddress() string {
 
 func assertParameters(cmd *cobra.Command, args []string) {
 	if clientDo.ChainidFlag == """" {
-		log.Fatal(`Please provide a chain id either through the flag --chain-id or environment variable $CHAIN_ID.`)
-		os.Exit(1)
+		util.Fatalf(`Please provide a chain id either through the flag --chain-id or environment variable $CHAIN_ID.`)",58,2017-01-23 12:48:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/96687236,https://github.com/hyperledger/burrow/pull/450#discussion_r96687236,silasdavis
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,Should this not remain a public type?,6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-23 12:56:48,97312011,"@@ -58,37 +58,31 @@ type NodeWebsocketClient interface {
 	Close()
 }
 
-// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// NOTE [ben] Compiler check to ensure erisNodeClient successfully implements
 // eris-db/client.NodeClient
-var _ NodeClient = (*ErisNodeClient)(nil)
+var _ NodeClient = (*erisNodeClient)(nil)
 
 // Eris-Client is a simple struct exposing the client rpc methods
-
-type ErisNodeClient struct {
+type erisNodeClient struct {",41,2017-01-23 13:02:41,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97312011,https://github.com/hyperledger/burrow/pull/450#discussion_r97312011,benjaminbollen
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,"less important here, but equally I don't understand why this type is made private.",6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-23 12:59:15,97312380,"@@ -41,29 +41,30 @@ type Confirmation struct {
 	Error     error
 }
 
-// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// NOTE [ben] Compiler check to ensure erisNodeClient successfully implements
 // eris-db/client.NodeClient
-var _ NodeWebsocketClient = (*ErisNodeWebsocketClient)(nil)
+var _ NodeWebsocketClient = (*erisNodeWebsocketClient)(nil)
 
-type ErisNodeWebsocketClient struct {
+type erisNodeWebsocketClient struct {",22,2017-01-23 13:02:41,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97312380,https://github.com/hyperledger/burrow/pull/450#discussion_r97312380,benjaminbollen
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,"Good!  yes, happy to see the docs generator included here.",6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-23 13:00:28,97312550,"@@ -0,0 +1,333 @@
+package generator",1,2017-01-23 13:02:41,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97312550,https://github.com/hyperledger/burrow/pull/450#discussion_r97312550,benjaminbollen
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,"Again, same question: not sure why these types are made private.",6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-23 13:01:17,97312639,"@@ -29,31 +31,33 @@ type KeyClient interface {
 	PublicKey(address []byte) (publicKey []byte, err error)
 }
 
-// NOTE [ben] Compiler check to ensure ErisKeyClient successfully implements
+// NOTE [ben] Compiler check to ensure erisKeyClient successfully implements
 // eris-db/keys.KeyClient
-var _ KeyClient = (*ErisKeyClient)(nil)
+var _ KeyClient = (*erisKeyClient)(nil)
 
-type ErisKeyClient struct {
+type erisKeyClient struct {",20,2017-01-23 13:02:41,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97312639,https://github.com/hyperledger/burrow/pull/450#discussion_r97312639,benjaminbollen
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,Yea this needs to be remade public for epm usage...,6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-23 13:44:05,97319330,"@@ -29,31 +31,33 @@ type KeyClient interface {
 	PublicKey(address []byte) (publicKey []byte, err error)
 }
 
-// NOTE [ben] Compiler check to ensure ErisKeyClient successfully implements
+// NOTE [ben] Compiler check to ensure erisKeyClient successfully implements
 // eris-db/keys.KeyClient
-var _ KeyClient = (*ErisKeyClient)(nil)
+var _ KeyClient = (*erisKeyClient)(nil)
 
-type ErisKeyClient struct {
+type erisKeyClient struct {",20,2017-01-23 13:44:05,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97319330,https://github.com/hyperledger/burrow/pull/450#discussion_r97319330,VoR0220
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,Yes. Needs to remain exported. ,6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-23 13:44:47,97319451,"@@ -58,37 +58,31 @@ type NodeWebsocketClient interface {
 	Close()
 }
 
-// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// NOTE [ben] Compiler check to ensure erisNodeClient successfully implements
 // eris-db/client.NodeClient
-var _ NodeClient = (*ErisNodeClient)(nil)
+var _ NodeClient = (*erisNodeClient)(nil)
 
 // Eris-Client is a simple struct exposing the client rpc methods
-
-type ErisNodeClient struct {
+type erisNodeClient struct {",41,2017-01-23 13:44:47,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97319451,https://github.com/hyperledger/burrow/pull/450#discussion_r97319451,VoR0220
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,"This was a hygiene thing. Note that the methods are on the interface `NodeClient`. Generally I avoid exporting the concrete struct type that implements and interfaces because I don't want people constructing it without using my constructor, `NewErisNodeClient` in this case. Bear in mind you don't need to export the struct to use the type via the exported constructor. I use this pattern a lot: https://github.com/eris-ltd/eris-db/blob/feature_logging/logging/loggers/info_trace_logger.go#L16.

In this case I particularly think it should be unexported because it has private fields so an external package won't be able to initialise it properly for certain.",6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-23 14:16:42,97325452,"@@ -58,37 +58,31 @@ type NodeWebsocketClient interface {
 	Close()
 }
 
-// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// NOTE [ben] Compiler check to ensure erisNodeClient successfully implements
 // eris-db/client.NodeClient
-var _ NodeClient = (*ErisNodeClient)(nil)
+var _ NodeClient = (*erisNodeClient)(nil)
 
 // Eris-Client is a simple struct exposing the client rpc methods
-
-type ErisNodeClient struct {
+type erisNodeClient struct {",41,2017-01-23 14:17:03,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97325452,https://github.com/hyperledger/burrow/pull/450#discussion_r97325452,silasdavis
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,Ah...good point. ,6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-23 14:21:34,97326396,"@@ -58,37 +58,31 @@ type NodeWebsocketClient interface {
 	Close()
 }
 
-// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// NOTE [ben] Compiler check to ensure erisNodeClient successfully implements
 // eris-db/client.NodeClient
-var _ NodeClient = (*ErisNodeClient)(nil)
+var _ NodeClient = (*erisNodeClient)(nil)
 
 // Eris-Client is a simple struct exposing the client rpc methods
-
-type ErisNodeClient struct {
+type erisNodeClient struct {",41,2017-01-23 14:21:34,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97326396,https://github.com/hyperledger/burrow/pull/450#discussion_r97326396,VoR0220
https://github.com/hyperledger/burrow/pull/450,https://github.com/hyperledger/burrow/pull/450,"Good point, thanks.",6c23762ca9b28578361c9d6ac7c39cfd1e7ef2e3,2017-01-23 14:23:04,97326677,"@@ -58,37 +58,31 @@ type NodeWebsocketClient interface {
 	Close()
 }
 
-// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// NOTE [ben] Compiler check to ensure erisNodeClient successfully implements
 // eris-db/client.NodeClient
-var _ NodeClient = (*ErisNodeClient)(nil)
+var _ NodeClient = (*erisNodeClient)(nil)
 
 // Eris-Client is a simple struct exposing the client rpc methods
-
-type ErisNodeClient struct {
+type erisNodeClient struct {",41,2017-01-23 14:23:04,https://api.github.com/repos/hyperledger/burrow/pulls/comments/97326677,https://github.com/hyperledger/burrow/pull/450#discussion_r97326677,benjaminbollen
https://github.com/hyperledger/burrow/pull/447,https://github.com/hyperledger/burrow/pull/447,You were a bit quick with the replace alls for `this` -> `evts`,78fe37a03241b5f58c94486e59a3acd235445f3f,2017-01-18 11:38:49,96616535,"@@ -70,7 +70,7 @@ func reap(es *EventSubscriptions) {
 	defer es.mtx.Unlock()
 	for id, sub := range es.subs {
 		if time.Since(sub.ts) > reaperThreshold {
-			// Seems like Go is ok with this..
+			// Seems like Go is ok with evts..",5,2017-01-18 11:38:49,https://api.github.com/repos/hyperledger/burrow/pulls/comments/96616535,https://github.com/hyperledger/burrow/pull/447#discussion_r96616535,benjaminbollen
https://github.com/hyperledger/burrow/pull/447,https://github.com/hyperledger/burrow/pull/447,fixed in current working directory,78fe37a03241b5f58c94486e59a3acd235445f3f,2017-01-18 12:33:46,96624839,"@@ -70,7 +70,7 @@ func reap(es *EventSubscriptions) {
 	defer es.mtx.Unlock()
 	for id, sub := range es.subs {
 		if time.Since(sub.ts) > reaperThreshold {
-			// Seems like Go is ok with this..
+			// Seems like Go is ok with evts..",5,2017-01-18 12:33:46,https://api.github.com/repos/hyperledger/burrow/pulls/comments/96624839,https://github.com/hyperledger/burrow/pull/447#discussion_r96624839,silasdavis
https://github.com/hyperledger/burrow/pull/442,https://github.com/hyperledger/burrow/pull/442,"Note: worth adding that for code contracts the address of an account is derived not from a public key - it is derived by the evm or even (arbitrarily) provided in a CALL transaction to this new account, and it is unfeasible to search for a private-public key pair that can unlock the account.  Such an account will only be controlled by the code it has stored.",a4e3a3169eab5082344c2af957b6326eb76c5f6e,2017-01-13 12:37:40,95988164,"@@ -203,6 +203,12 @@ func getOrMakeOutputs(state AccountGetter, accounts map[string]*acm.Account, out
 	return accounts, nil
 }
 
+// Since all ethereum accounts implicitly exist we sometimes lazily create an Account object to represent them
+// only when needed. Sometimes we need to create an unknown Account knowing only its address (which is expected to
+// be a deterministic hash of its associated public key) and not its public key. When we eventually receive a
+// transaction acting on behalf of that account we will be given a public key that we can check matches the address.
+// If it does then we will associate the public key with the stub account already registered in the system once and
+// for all time.",9,2017-01-13 12:37:46,https://api.github.com/repos/hyperledger/burrow/pulls/comments/95988164,https://github.com/hyperledger/burrow/pull/442#discussion_r95988164,benjaminbollen
https://github.com/hyperledger/burrow/pull/442,https://github.com/hyperledger/burrow/pull/442,"Hm, it is arbitrarily _provided_, which means the actor triggering the call has the option of deriving it from a public key beforehand. I am not aware of a place where the EVM 'generates' it... If it does can you link?",a4e3a3169eab5082344c2af957b6326eb76c5f6e,2017-01-13 13:07:14,95991753,"@@ -203,6 +203,12 @@ func getOrMakeOutputs(state AccountGetter, accounts map[string]*acm.Account, out
 	return accounts, nil
 }
 
+// Since all ethereum accounts implicitly exist we sometimes lazily create an Account object to represent them
+// only when needed. Sometimes we need to create an unknown Account knowing only its address (which is expected to
+// be a deterministic hash of its associated public key) and not its public key. When we eventually receive a
+// transaction acting on behalf of that account we will be given a public key that we can check matches the address.
+// If it does then we will associate the public key with the stub account already registered in the system once and
+// for all time.",9,2017-01-13 13:07:14,https://api.github.com/repos/hyperledger/burrow/pulls/comments/95991753,https://github.com/hyperledger/burrow/pull/442#discussion_r95991753,silasdavis
https://github.com/hyperledger/burrow/pull/442,https://github.com/hyperledger/burrow/pull/442,on EVM CREATE or if a CallTx goes to an uninitialised Account (state),a4e3a3169eab5082344c2af957b6326eb76c5f6e,2017-01-13 13:20:30,95993461,"@@ -203,6 +203,12 @@ func getOrMakeOutputs(state AccountGetter, accounts map[string]*acm.Account, out
 	return accounts, nil
 }
 
+// Since all ethereum accounts implicitly exist we sometimes lazily create an Account object to represent them
+// only when needed. Sometimes we need to create an unknown Account knowing only its address (which is expected to
+// be a deterministic hash of its associated public key) and not its public key. When we eventually receive a
+// transaction acting on behalf of that account we will be given a public key that we can check matches the address.
+// If it does then we will associate the public key with the stub account already registered in the system once and
+// for all time.",9,2017-01-13 13:20:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/95993461,https://github.com/hyperledger/burrow/pull/442#discussion_r95993461,benjaminbollen
https://github.com/hyperledger/burrow/pull/428,https://github.com/hyperledger/burrow/pull/428,"wait, what?",c6a98d159033b2c513ed0b270154b2dc81e4ccd3,2016-12-20 15:06:36,93254929,"@@ -5,6 +5,7 @@ import (
 
 	""github.com/eris-ltd/eris-db/logging/loggers""
 	""github.com/eris-ltd/eris-db/logging/structure""
+	""github.com/eris-ltd/mint-client/Godeps/_workspace/src/github.com/inconshreveable/log15/stack""",,2016-12-24 20:47:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/93254929,https://github.com/hyperledger/burrow/pull/428#discussion_r93254929,benjaminbollen
https://github.com/hyperledger/burrow/pull/428,https://github.com/hyperledger/burrow/pull/428,"well spotted, intellij auto-import, ugh",c6a98d159033b2c513ed0b270154b2dc81e4ccd3,2016-12-20 15:07:58,93255169,"@@ -5,6 +5,7 @@ import (
 
 	""github.com/eris-ltd/eris-db/logging/loggers""
 	""github.com/eris-ltd/eris-db/logging/structure""
+	""github.com/eris-ltd/mint-client/Godeps/_workspace/src/github.com/inconshreveable/log15/stack""",,2016-12-24 20:47:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/93255169,https://github.com/hyperledger/burrow/pull/428#discussion_r93255169,silasdavis
https://github.com/hyperledger/burrow/pull/421,https://github.com/hyperledger/burrow/pull/421,"we don't need to panic here, if we cleanly `os.Exit(1)` below ?",8a1708f0f9cd4a34eda419b4ceb634209e8ffafd,2016-12-13 14:02:26,92173354,"@@ -41,148 +41,157 @@ var DefaultConfigFilename = fmt.Sprintf(""%s.%s"",
 	DefaultConfigBasename,
 	DefaultConfigType)
 
-var ServeCmd = &cobra.Command{
-	Use:   ""serve"",
-	Short: ""Eris-DB serve starts an eris-db node with client API enabled by default."",
-	Long: `Eris-DB serve starts an eris-db node with client API enabled by default.
+// build the serve subcommand
+func buildServeCommand(do *definitions.Do) *cobra.Command {
+	cmd := &cobra.Command{
+		Use:   ""serve"",
+		Short: ""Eris-DB serve starts an eris-db node with client API enabled by default."",
+		Long: `Eris-DB serve starts an eris-db node with client API enabled by default.
 The Eris-DB node is modularly configured for the consensus engine and application
 manager.  The client API can be disabled.`,
-	Example: fmt.Sprintf(`$ eris-db serve -- will start the Eris-DB node based on the configuration file ""%s"" in the current working directory
+		Example: fmt.Sprintf(`$ eris-db serve -- will start the Eris-DB node based on the configuration file ""%s"" in the current working directory
 $ eris-db serve --work-dir <path-to-working-directory> -- will start the Eris-DB node based on the configuration file ""%s"" in the provided working directory
 $ eris-db serve --chain-id <CHAIN_ID> -- will overrule the configuration entry assert_chain_id`,
-		DefaultConfigFilename, DefaultConfigFilename),
-	PreRun: func(cmd *cobra.Command, args []string) {
-		// if WorkDir was not set by a flag or by $ERIS_DB_WORKDIR
-		// NOTE [ben]: we can consider an `Explicit` flag that eliminates
-		// the use of any assumptions while starting Eris-DB
-		if do.WorkDir == """" {
-			if currentDirectory, err := os.Getwd(); err != nil {
-				log.Fatalf(""No directory provided and failed to get current working directory: %v"", err)
+			DefaultConfigFilename, DefaultConfigFilename),
+		PreRun: func(cmd *cobra.Command, args []string) {
+			// if WorkDir was not set by a flag or by $ERIS_DB_WORKDIR
+			// NOTE [ben]: we can consider an `Explicit` flag that eliminates
+			// the use of any assumptions while starting Eris-DB
+			if do.WorkDir == """" {
+				if currentDirectory, err := os.Getwd(); err != nil {
+					panic(fmt.Sprintf(""No directory provided and failed to get current ""+",62,2016-12-15 10:22:02,https://api.github.com/repos/hyperledger/burrow/pulls/comments/92173354,https://github.com/hyperledger/burrow/pull/421#discussion_r92173354,benjaminbollen
https://github.com/hyperledger/burrow/pull/421,https://github.com/hyperledger/burrow/pull/421,redundant whiteline,8a1708f0f9cd4a34eda419b4ceb634209e8ffafd,2016-12-13 14:44:19,92181877,"@@ -41,148 +41,157 @@ var DefaultConfigFilename = fmt.Sprintf(""%s.%s"",
 	DefaultConfigBasename,
 	DefaultConfigType)
 
-var ServeCmd = &cobra.Command{
-	Use:   ""serve"",
-	Short: ""Eris-DB serve starts an eris-db node with client API enabled by default."",
-	Long: `Eris-DB serve starts an eris-db node with client API enabled by default.
+// build the serve subcommand
+func buildServeCommand(do *definitions.Do) *cobra.Command {
+	cmd := &cobra.Command{
+		Use:   ""serve"",
+		Short: ""Eris-DB serve starts an eris-db node with client API enabled by default."",
+		Long: `Eris-DB serve starts an eris-db node with client API enabled by default.
 The Eris-DB node is modularly configured for the consensus engine and application
 manager.  The client API can be disabled.`,
-	Example: fmt.Sprintf(`$ eris-db serve -- will start the Eris-DB node based on the configuration file ""%s"" in the current working directory
+		Example: fmt.Sprintf(`$ eris-db serve -- will start the Eris-DB node based on the configuration file ""%s"" in the current working directory
 $ eris-db serve --work-dir <path-to-working-directory> -- will start the Eris-DB node based on the configuration file ""%s"" in the provided working directory
 $ eris-db serve --chain-id <CHAIN_ID> -- will overrule the configuration entry assert_chain_id`,
-		DefaultConfigFilename, DefaultConfigFilename),
-	PreRun: func(cmd *cobra.Command, args []string) {
-		// if WorkDir was not set by a flag or by $ERIS_DB_WORKDIR
-		// NOTE [ben]: we can consider an `Explicit` flag that eliminates
-		// the use of any assumptions while starting Eris-DB
-		if do.WorkDir == """" {
-			if currentDirectory, err := os.Getwd(); err != nil {
-				log.Fatalf(""No directory provided and failed to get current working directory: %v"", err)
+			DefaultConfigFilename, DefaultConfigFilename),
+		PreRun: func(cmd *cobra.Command, args []string) {
+			// if WorkDir was not set by a flag or by $ERIS_DB_WORKDIR
+			// NOTE [ben]: we can consider an `Explicit` flag that eliminates
+			// the use of any assumptions while starting Eris-DB
+			if do.WorkDir == """" {
+				if currentDirectory, err := os.Getwd(); err != nil {
+					panic(fmt.Sprintf(""No directory provided and failed to get current ""+
+						""working directory: %v"", err))
+					os.Exit(1)
+				} else {
+					do.WorkDir = currentDirectory
+				}
+			}
+			if !util.IsDir(do.WorkDir) {
+				panic(fmt.Sprintf(""Provided working directory %s is not a directory"",
+					do.WorkDir))
 				os.Exit(1)
-			} else {
-				do.WorkDir = currentDirectory
 			}
-		}
-		if !util.IsDir(do.WorkDir) {
-			log.Fatalf(""Provided working directory %s is not a directory"", do.WorkDir)
-		}
-	},
-	Run: Serve,
-}
-
-// build the serve subcommand
-func buildServeCommand() {
-	addServeFlags()
+		},
+		Run: ServeRunner(do),
+	}
+	addServeFlags(do, cmd)
+	return cmd
 }
 
-func addServeFlags() {
-	ServeCmd.PersistentFlags().StringVarP(&do.ChainId, ""chain-id"", ""c"",
+func addServeFlags(do *definitions.Do, serveCmd *cobra.Command) {
+	serveCmd.PersistentFlags().StringVarP(&do.ChainId, ""chain-id"", ""c"",
 		defaultChainId(), ""specify the chain id to use for assertion against the genesis file or the existing state. If omitted, and no id is set in $CHAIN_ID, then assert_chain_id is used from the configuration file."")
-	ServeCmd.PersistentFlags().StringVarP(&do.WorkDir, ""work-dir"", ""w"",
+	serveCmd.PersistentFlags().StringVarP(&do.WorkDir, ""work-dir"", ""w"",
 		defaultWorkDir(), ""specify the working directory for the chain to run.  If omitted, and no path set in $ERIS_DB_WORKDIR, the current working directory is taken."")
-	ServeCmd.PersistentFlags().StringVarP(&do.DataDir, ""data-dir"", """",
+	serveCmd.PersistentFlags().StringVarP(&do.DataDir, ""data-dir"", """",
 		defaultDataDir(), ""specify the data directory.  If omitted and not set in $ERIS_DB_DATADIR, <working_directory>/data is taken."")
-	ServeCmd.PersistentFlags().BoolVarP(&do.DisableRpc, ""disable-rpc"", """",
+	serveCmd.PersistentFlags().BoolVarP(&do.DisableRpc, ""disable-rpc"", """",
 		defaultDisableRpc(), ""indicate for the RPC to be disabled. If omitted the RPC is enabled by default, unless (deprecated) $ERISDB_API is set to false."")
 }
 
 //------------------------------------------------------------------------------
 // functions
-
-// serve() prepares the environment and sets up the core for Eris_DB to run.
-// After the setup succeeds, serve() starts the core and halts for core to
-// terminate.
-func Serve(cmd *cobra.Command, args []string) {
-	// load configuration from a single location to avoid a wrong configuration
-	// file is loaded.
-	err := do.ReadConfig(do.WorkDir, DefaultConfigBasename, DefaultConfigType)
-	if err != nil {
-		log.WithFields(log.Fields{
-			""directory"": do.WorkDir,
-			""file"":      DefaultConfigFilename,
-		}).Fatalf(""Fatal error reading configuration"")
-		os.Exit(1)
-	}
-	// if do.ChainId is not yet set, load chain_id for assertion from configuration file
-	if do.ChainId == """" {
-		if do.ChainId = do.Config.GetString(""chain.assert_chain_id""); do.ChainId == """" {
-			log.Fatalf(""Failed to read non-empty string for ChainId from config."")
-			os.Exit(1)
-		}
-	}
+func NewCoreFromDo(do *definitions.Do) (*core.Core, error) {
 	// load the genesis file path
 	do.GenesisFile = path.Join(do.WorkDir,
 		do.Config.GetString(""chain.genesis_file""))
+
 	if do.Config.GetString(""chain.genesis_file"") == """" {
-		log.Fatalf(""Failed to read non-empty string for genesis file from config."")
-		os.Exit(1)
+		return nil, fmt.Errorf(""The config value chain.genesis_file is empty, "" +
+			""but should be set to the location of the genesis.json file."")
 	}
 	// Ensure data directory is set and accessible
 	if err := do.InitialiseDataDirectory(); err != nil {
-		log.Fatalf(""Failed to initialise data directory (%s): %v"", do.DataDir, err)
-		os.Exit(1)
+		return nil, fmt.Errorf(""Failed to initialise data directory (%s): %v"", do.DataDir, err)
 	}
-	log.WithFields(log.Fields{
-		""chainId"":          do.ChainId,
-		""workingDirectory"": do.WorkDir,
-		""dataDirectory"":    do.DataDir,
-		""genesisFile"":      do.GenesisFile,
-	}).Info(""Eris-DB serve configuring"")
 
-	consensusConfig, err := core.LoadConsensusModuleConfig(do)
+	loggerConfig, err := core.LoadLoggingConfig(do)
 	if err != nil {
-		log.Fatalf(""Failed to load consensus module configuration: %s."", err)
-		os.Exit(1)
+		return nil, fmt.Errorf(""Failed to load logging config: %s"", err)
 	}
 
-	managerConfig, err := core.LoadApplicationManagerModuleConfig(do)
+	// Create a root logger to pass through to dependencies
+	logger := lifecycle.NewLoggerFromConfig(*loggerConfig)
+	// Capture all logging from tendermint/tendermint and tendermint/go-*
+	// dependencies
+	lifecycle.CaptureTendermintLog15Output(logger)
+
+	cmdLogger := logger.With(""command"", ""serve"")
+
+	// if do.ChainId is not yet set, load chain_id for assertion from configuration file
+
+	if do.ChainId == """" {
+		if do.ChainId = do.Config.GetString(""chain.assert_chain_id""); do.ChainId == """" {
+			return nil, fmt.Errorf(""The config chain.assert_chain_id is empty, "" +
+				""but should be set to the chain_id of the chain we are trying to run."")
+		}
+	}
+
+	cmdLogger.Info(""chainId"", do.ChainId,
+		""workingDirectory"", do.WorkDir,
+		""dataDirectory"", do.DataDir,
+		""genesisFile"", do.GenesisFile,
+		structure.MessageKey, ""Loading configuration for serve command"")
+
+	consensusConfig, err := core.LoadConsensusModuleConfig(do)
 	if err != nil {
-		log.Fatalf(""Failed to load application manager module configuration: %s."", err)
-		os.Exit(1)
+		return nil, fmt.Errorf(""Failed to load consensus module configuration: %s."", err)
 	}
-	log.WithFields(log.Fields{
-		""consensusModule"":    consensusConfig.Version,
-		""applicationManager"": managerConfig.Version,
-	}).Debug(""Modules configured"")
 
-	newCore, err := core.NewCore(do.ChainId, consensusConfig, managerConfig)
+	managerConfig, err := core.LoadApplicationManagerModuleConfig(do)
 	if err != nil {
-		log.Fatalf(""Failed to load core: %s"", err)
+		return nil, fmt.Errorf(""Failed to load application manager module configuration: %s."", err)
 	}
 
-	if !do.DisableRpc {
-		serverConfig, err := core.LoadServerConfig(do)
-		if err != nil {
-			log.Fatalf(""Failed to load server configuration: %s."", err)
-			os.Exit(1)
-		}
+	cmdLogger.Info(""consensusModule"", consensusConfig.Version,
+		""applicationManager"", managerConfig.Version,
+		structure.MessageKey, ""Modules configured"")
+
+	return core.NewCore(do.ChainId, consensusConfig, managerConfig, logger)
+}
 
-		serverProcess, err := newCore.NewGatewayV0(serverConfig)
+// ServeRunner() returns a command runner that prepares the environment and sets
+// up the core for Eris-DB to run. After the setup succeeds, it starts the core
+// and waits for the core to terminate.
+func ServeRunner(do *definitions.Do) func(*cobra.Command, []string) {
+	return func(cmd *cobra.Command, args []string) {
+		// load configuration from a single location to avoid a wrong configuration
+		// file is loaded.
+		err := do.ReadConfig(do.WorkDir, DefaultConfigBasename, DefaultConfigType)
 		if err != nil {
-			log.Fatalf(""Failed to load servers: %s."", err)
-			os.Exit(1)
+			util.Fatalf(""Fatal error reading configuration from %s/%s"", do.WorkDir,
+				DefaultConfigFilename)
 		}
-		err = serverProcess.Start()
+
+		newCore, err := NewCoreFromDo(do)
+",239,2016-12-15 10:22:02,https://api.github.com/repos/hyperledger/burrow/pulls/comments/92181877,https://github.com/hyperledger/burrow/pull/421#discussion_r92181877,benjaminbollen
https://github.com/hyperledger/burrow/pull/421,https://github.com/hyperledger/burrow/pull/421,sweet!,8a1708f0f9cd4a34eda419b4ceb634209e8ffafd,2016-12-13 14:51:49,92183677,"@@ -0,0 +1,29 @@
+package config
+
+import (
+	""fmt""
+	""github.com/spf13/viper""
+)
+
+// Safely get the subtree from a viper config, returning an error if it could not
+// be obtained for any reason.
+func ViperSubConfig(conf *viper.Viper, configSubtreePath string) (subConfig *viper.Viper, err error) {",10,2016-12-15 10:22:02,https://api.github.com/repos/hyperledger/burrow/pulls/comments/92183677,https://github.com/hyperledger/burrow/pull/421#discussion_r92183677,benjaminbollen
https://github.com/hyperledger/burrow/pull/421,https://github.com/hyperledger/burrow/pull/421,:) ,8a1708f0f9cd4a34eda419b4ceb634209e8ffafd,2016-12-13 14:57:53,92185156,"@@ -0,0 +1,23 @@
+package adapters
+
+import (
+	""github.com/Sirupsen/logrus""
+	kitlog ""github.com/go-kit/kit/log""
+)
+
+type logrusLogger struct {
+	logger logrus.Logger
+}
+
+var _ kitlog.Logger = (*logrusLogger)(nil)",12,2016-12-15 10:22:02,https://api.github.com/repos/hyperledger/burrow/pulls/comments/92185156,https://github.com/hyperledger/burrow/pull/421#discussion_r92185156,benjaminbollen
https://github.com/hyperledger/burrow/pull/421,https://github.com/hyperledger/burrow/pull/421,indentation ,8a1708f0f9cd4a34eda419b4ceb634209e8ffafd,2016-12-13 14:58:42,92185358,"@@ -0,0 +1,26 @@
+package stdlib
+
+import (
+	""io""
+	""log""
+
+	""github.com/eris-ltd/eris-db/logging/loggers""
+	kitlog ""github.com/go-kit/kit/log""
+)
+
+func Capture(stdLibLogger log.Logger,
+logger loggers.InfoTraceLogger) io.Writer {",12,2016-12-15 10:22:02,https://api.github.com/repos/hyperledger/burrow/pulls/comments/92185358,https://github.com/hyperledger/burrow/pull/421#discussion_r92185358,benjaminbollen
https://github.com/hyperledger/burrow/pull/421,https://github.com/hyperledger/burrow/pull/421,"neat, this is a good abstraction, we can also use this in eris-client",8a1708f0f9cd4a34eda419b4ceb634209e8ffafd,2016-12-13 15:07:30,92187292,"@@ -0,0 +1,37 @@
+package lifecycle
+
+// No package in ./logging/... should depend on lifecycle
+
+import (
+	""os""
+
+	""github.com/eris-ltd/eris-db/logging""
+	tmLog15adapter ""github.com/eris-ltd/eris-db/logging/adapters/tendermint_log15""
+	""github.com/eris-ltd/eris-db/logging/loggers""
+	kitlog ""github.com/go-kit/kit/log""
+	tmLog15 ""github.com/tendermint/log15""
+	""github.com/eris-ltd/eris-db/logging/structure""
+)
+
+func NewLoggerFromConfig(LoggingConfig logging.LoggingConfig) loggers.InfoTraceLogger {
+	infoLogger := kitlog.NewLogfmtLogger(os.Stderr)
+	traceLogger := kitlog.NewLogfmtLogger(os.Stderr)
+	return logging.WithMetadata(loggers.NewInfoTraceLogger(infoLogger, traceLogger))
+}
+
+func NewStdErrLogger() loggers.InfoTraceLogger {
+	logger := tmLog15adapter.Log15HandlerAsKitLogger(
+		tmLog15.StreamHandler(os.Stderr, tmLog15.TerminalFormat()))
+	return NewLogger(logger, logger)
+}
+
+func NewLogger(infoLogger, traceLogger kitlog.Logger) loggers.InfoTraceLogger {
+	infoTraceLogger := loggers.NewInfoTraceLogger(infoLogger, traceLogger)
+	return logging.WithMetadata(infoTraceLogger)
+}
+
+func CaptureTendermintLog15Output(infoTraceLogger loggers.InfoTraceLogger) {",33,2016-12-15 10:22:02,https://api.github.com/repos/hyperledger/burrow/pulls/comments/92187292,https://github.com/hyperledger/burrow/pull/421#discussion_r92187292,benjaminbollen
https://github.com/hyperledger/burrow/pull/421,https://github.com/hyperledger/burrow/pull/421,"we should maybe try to import from the ""official"" (does such a thing exist ?) golang repository where possible? 
`import ""gopkg.in/eapache/channels.v1""`
 ",8a1708f0f9cd4a34eda419b4ceb634209e8ffafd,2016-12-13 15:33:10,92193115,"@@ -0,0 +1,73 @@
+package loggers
+
+import (
+	""github.com/eapache/channels""",4,2016-12-15 10:22:02,https://api.github.com/repos/hyperledger/burrow/pulls/comments/92193115,https://github.com/hyperledger/burrow/pull/421#discussion_r92193115,benjaminbollen
https://github.com/hyperledger/burrow/pull/421,https://github.com/hyperledger/burrow/pull/421,"yeah, about that... :) - it's ok though, we have a specific logging situation and the proposed solution is, albeit complete, but elegant",8a1708f0f9cd4a34eda419b4ceb634209e8ffafd,2016-12-13 16:18:47,92204535,"@@ -0,0 +1,27 @@
+package logging
+
+import (
+	""time""
+
+	""github.com/eris-ltd/eris-db/logging/loggers""
+	""github.com/eris-ltd/eris-db/logging/structure""
+	kitlog ""github.com/go-kit/kit/log""
+)
+
+const (
+	// To get the Caller information correct on the log, we need to count the
+	// number of calls from a log call in the code to the time it hits a kitlog
+	// context: [log call site (5), Info/Trace (4), MultipleChannelLogger.Log (3),
+	// kitlog.Context.Log (2), kitlog.bindValues (1) (binding occurs),
+	// kitlog.Caller (0), stack.caller]
+	infoTraceLoggerCallDepth = 5",17,2016-12-15 10:22:02,https://api.github.com/repos/hyperledger/burrow/pulls/comments/92204535,https://github.com/hyperledger/burrow/pull/421#discussion_r92204535,benjaminbollen
https://github.com/hyperledger/burrow/pull/421,https://github.com/hyperledger/burrow/pull/421,do we still need eris-logger?,8a1708f0f9cd4a34eda419b4ceb634209e8ffafd,2016-12-13 16:21:21,92205197,"@@ -38,12 +36,15 @@ import (
 	core_types ""github.com/eris-ltd/eris-db/core/types""
 	""github.com/eris-ltd/eris-db/definitions""
 	edb_event ""github.com/eris-ltd/eris-db/event""
+	""github.com/eris-ltd/eris-db/logging/loggers""
+	""github.com/eris-ltd/eris-db/logging/structure""
 	vm ""github.com/eris-ltd/eris-db/manager/eris-mint/evm""
 	""github.com/eris-ltd/eris-db/manager/eris-mint/state""
 	state_types ""github.com/eris-ltd/eris-db/manager/eris-mint/state/types""
 	manager_types ""github.com/eris-ltd/eris-db/manager/types""
 	rpc_tm_types ""github.com/eris-ltd/eris-db/rpc/tendermint/core/types""
 	""github.com/eris-ltd/eris-db/txs""
+	log ""github.com/eris-ltd/eris-logger""",21,2016-12-15 10:22:02,https://api.github.com/repos/hyperledger/burrow/pulls/comments/92205197,https://github.com/hyperledger/burrow/pull/421#discussion_r92205197,benjaminbollen
https://github.com/hyperledger/burrow/pull/421,https://github.com/hyperledger/burrow/pull/421,where is `stMessageKey` defined / imported ?,8a1708f0f9cd4a34eda419b4ceb634209e8ffafd,2016-12-13 16:22:58,92205614,"@@ -79,11 +82,11 @@ func NewErisMintPipe(moduleConfig *config.ModuleConfig,
 		return nil, fmt.Errorf(""Failed to start state: %v"", err)
 	}
 	// assert ChainId matches genesis ChainId
-	log.WithFields(log.Fields{
-		""chainId"":         startedState.ChainID,
-		""lastBlockHeight"": startedState.LastBlockHeight,
-		""lastBlockHash"":   startedState.LastBlockHash,
-	}).Debug(""Loaded state"")
+	logger.Info(
+		""chainId"", startedState.ChainID,
+		""lastBlockHeight"", startedState.LastBlockHeight,
+		""lastBlockHash"", startedState.LastBlockHash,
+		structure.MessageKey, ""Loaded state"")",56,2016-12-15 10:22:02,https://api.github.com/repos/hyperledger/burrow/pulls/comments/92205614,https://github.com/hyperledger/burrow/pull/421#discussion_r92205614,benjaminbollen
https://github.com/hyperledger/burrow/pull/421,https://github.com/hyperledger/burrow/pull/421,rejoyce,8a1708f0f9cd4a34eda419b4ceb634209e8ffafd,2016-12-13 16:30:42,92207662,"@@ -12,14 +12,14 @@ import (
 	ptypes ""github.com/eris-ltd/eris-db/permission/types""
 	""github.com/eris-ltd/eris-db/txs""
 
-	. ""github.com/tendermint/go-common""",4,2016-12-15 10:22:02,https://api.github.com/repos/hyperledger/burrow/pulls/comments/92207662,https://github.com/hyperledger/burrow/pull/421#discussion_r92207662,benjaminbollen
https://github.com/hyperledger/burrow/pull/421,https://github.com/hyperledger/burrow/pull/421,"noop
",8a1708f0f9cd4a34eda419b4ceb634209e8ffafd,2016-12-13 16:43:12,92210692,"@@ -38,12 +36,15 @@ import (
 	core_types ""github.com/eris-ltd/eris-db/core/types""
 	""github.com/eris-ltd/eris-db/definitions""
 	edb_event ""github.com/eris-ltd/eris-db/event""
+	""github.com/eris-ltd/eris-db/logging/loggers""
+	""github.com/eris-ltd/eris-db/logging/structure""
 	vm ""github.com/eris-ltd/eris-db/manager/eris-mint/evm""
 	""github.com/eris-ltd/eris-db/manager/eris-mint/state""
 	state_types ""github.com/eris-ltd/eris-db/manager/eris-mint/state/types""
 	manager_types ""github.com/eris-ltd/eris-db/manager/types""
 	rpc_tm_types ""github.com/eris-ltd/eris-db/rpc/tendermint/core/types""
 	""github.com/eris-ltd/eris-db/txs""
+	log ""github.com/eris-ltd/eris-logger""",21,2016-12-15 10:22:02,https://api.github.com/repos/hyperledger/burrow/pulls/comments/92210692,https://github.com/hyperledger/burrow/pull/421#discussion_r92210692,VoR0220
https://github.com/hyperledger/burrow/pull/421,https://github.com/hyperledger/burrow/pull/421,it definitely needs to go else cli gets a build error when importing edb,8a1708f0f9cd4a34eda419b4ceb634209e8ffafd,2016-12-13 17:25:00,92220594,"@@ -38,12 +36,15 @@ import (
 	core_types ""github.com/eris-ltd/eris-db/core/types""
 	""github.com/eris-ltd/eris-db/definitions""
 	edb_event ""github.com/eris-ltd/eris-db/event""
+	""github.com/eris-ltd/eris-db/logging/loggers""
+	""github.com/eris-ltd/eris-db/logging/structure""
 	vm ""github.com/eris-ltd/eris-db/manager/eris-mint/evm""
 	""github.com/eris-ltd/eris-db/manager/eris-mint/state""
 	state_types ""github.com/eris-ltd/eris-db/manager/eris-mint/state/types""
 	manager_types ""github.com/eris-ltd/eris-db/manager/types""
 	rpc_tm_types ""github.com/eris-ltd/eris-db/rpc/tendermint/core/types""
 	""github.com/eris-ltd/eris-db/txs""
+	log ""github.com/eris-ltd/eris-logger""",21,2016-12-15 10:22:02,https://api.github.com/repos/hyperledger/burrow/pulls/comments/92220594,https://github.com/hyperledger/burrow/pull/421#discussion_r92220594,zramsay
https://github.com/hyperledger/burrow/pull/409,https://github.com/hyperledger/burrow/pull/409,I personally favor naming `XXXX-something` prefixing the issue number. Worth chaning?,8623f842509dfa46883d637fe7e5e3f40d97d9e5,2016-11-28 12:25:52,89771088,"@@ -0,0 +1,70 @@
+# Contributing to `eris-db`:
+Forked from Docker's [contributing guidelines](https://github.com/docker/docker/blob/master/CONTRIBUTING.md)
+
+## Bug Reporting
+
+A great way to contribute to the project is to send a detailed report when you encounter an issue. We always appreciate a well-written, thorough bug report, and will thank you for it!
+
+Check that the issue doesn't already exist before submitting an issue. If you find a match, you can use the ""subscribe"" button to get notified on updates. Add a :+1: if you've also encountered this issue. If you have ways to reproduce the issue or have additional information that may help resolving the issue, please leave a comment.
+
+Also include the steps required to reproduce the problem if possible and applicable. This information will help us review and fix your issue faster. When sending lengthy log-files, post them as a gist (https://gist.github.com). Don't forget to remove sensitive data from your log files before posting (you can replace those parts with ""REDACTED"").
+
+Our [ISSUE_TEMPLATE.md](ISSUE_TEMPLATE.md) will autopopulate the new issue.
+
+## Contribution Tips and Guidelines
+
+### Pull requests are always welcome (to `develop` rather than `master`).
+
+Not sure if that typo is worth a pull request? Found a bug and know how to fix it? Do it! We will appreciate it. Any significant improvement should be documented as a GitHub issue or discussed in [The Marmot Den](https://slack.monax.io) Slack community prior to beginning.
+
+We are always thrilled to receive pull requests (and bug reports!) and we do our best to process them quickly. 
+
+## Conventions
+
+Fork the repository and make changes on your fork in a feature branch (branched from develop), create an issue outlining your feature or a bug, or use an open one.
+
+    If it's a bug fix branch, name it something-XXXX where XXXX is the number of the issue.",26,2016-11-28 12:25:52,https://api.github.com/repos/hyperledger/burrow/pulls/comments/89771088,https://github.com/hyperledger/burrow/pull/409#discussion_r89771088,benjaminbollen
https://github.com/hyperledger/burrow/pull/385,https://github.com/hyperledger/burrow/pull/385,"https://github.com/eris-ltd/mint-client/blob/master/mintgen/cli.go#L226
",eb981cbb18a813910e57e6f3531efd188466e393,2016-11-18 17:18:58,88698958,"@@ -413,7 +413,10 @@ func MakeGenesisState(db dbm.DB, genDoc *GenesisDoc) *State {
 	}
 
 	if genDoc.GenesisTime.IsZero() {
-		genDoc.GenesisTime = time.Now()
+		// MARMOT: really?
+		// set time to 11/18/2016 @ 4:09am (UTC)
+		genDoc.GenesisTime = time.Unix(1479442162, 0)
+		// genDoc.GenesisTime = time.Now()",8,2016-11-18 17:18:59,https://api.github.com/repos/hyperledger/burrow/pulls/comments/88698958,https://github.com/hyperledger/burrow/pull/385#discussion_r88698958,zramsay
https://github.com/hyperledger/burrow/pull/385,https://github.com/hyperledger/burrow/pull/385,Nice one ! @zramsay ,eb981cbb18a813910e57e6f3531efd188466e393,2016-11-21 11:35:51,88876948,"@@ -413,7 +413,10 @@ func MakeGenesisState(db dbm.DB, genDoc *GenesisDoc) *State {
 	}
 
 	if genDoc.GenesisTime.IsZero() {
-		genDoc.GenesisTime = time.Now()
+		// MARMOT: really?
+		// set time to 11/18/2016 @ 4:09am (UTC)
+		genDoc.GenesisTime = time.Unix(1479442162, 0)
+		// genDoc.GenesisTime = time.Now()",8,2016-11-21 11:35:51,https://api.github.com/repos/hyperledger/burrow/pulls/comments/88876948,https://github.com/hyperledger/burrow/pull/385#discussion_r88876948,benjaminbollen
https://github.com/hyperledger/burrow/pull/381,https://github.com/hyperledger/burrow/pull/381,"i think `w:` is a typo...
",4ebd82a6412aca9f2cdad000bb69fe50af233ec2,2016-11-14 21:32:02,87896985,"@@ -308,7 +308,7 @@ func SignAndBroadcast(chainID string, nodeClient client.NodeClient, keyClient ke
 						return
 					}
 					if confirmation.Exception != nil {
-						log.Errorf(""Encountered Exception from chain w: %s\n"", confirmation.Error)
+						log.Errorf(""Encountered Exception from chain w: %s\n"", confirmation.Exception)",,2016-11-14 21:32:40,https://api.github.com/repos/hyperledger/burrow/pulls/comments/87896985,https://github.com/hyperledger/burrow/pull/381#discussion_r87896985,zramsay
https://github.com/hyperledger/burrow/pull/320,https://github.com/hyperledger/burrow/pull/320,"`server_config.toml` is dead code that will go out of sync; but we can revisit this when we make a clear tooling | chains split on responsibilities.  Good for rc3
",1b710230277901ad10366569237831f0f3ba1b9a,2016-10-11 11:55:54,82776574,"@@ -38,12 +38,11 @@ This will start the node using the provided folder as working dir. If the path i
 
 ## Usage
 
-Once the server has started, it will begin syncing up with the network. At that point you may begin using it. The preferred way is through our [javascript api](https://monax.io/docs/documentation/db.js/), but it is possible to connect directly via HTTP or websocket. The JSON-RPC and web-api reference can be found [here](https://monax.io/docs/documentation/db/0.12.0-rc3/specifications/api/)
+Once the server has started, it will begin syncing up with the network. At that point you may begin using it. The preferred way is through our [javascript api](https://monax.io/docs/documentation/db.js/), but it is possible to connect directly via HTTP or websocket. The JSON-RPC and web-api reference can be found [here](https://monax.io/docs/documentation/db/latest/specifications/api/).
 
 ## Configuration
 
-See commented template config at [server_config.toml](server_config.toml)
-
+See commented template config at [server_config.toml](server_config.toml). This will be written as part of the `eris chains make` [process](https://monax.io/docs/documentation/cli/latest/eris_chains_make/) and can be edited prior to the `eris chains start` [process](https://monax.io/docs/documentation/cli/latest/eris_chains_start/).",11,2016-10-11 11:56:00,https://api.github.com/repos/hyperledger/burrow/pulls/comments/82776574,https://github.com/hyperledger/burrow/pull/320#discussion_r82776574,benjaminbollen
https://github.com/hyperledger/burrow/pull/315,https://github.com/hyperledger/burrow/pull/315,"why is a private key included here?
",f8b670a358e53bf6c33851e945993b3d44376427,2016-10-07 13:22:40,82387286,"@@ -90,6 +90,13 @@ type (
 		GasLimit int64  `json:""gas_limit""`
 	}
 
+	// Used when sending a 'Send' transaction.
+	SendParam struct {
+		PrivKey   []byte `json:""priv_key""`",6,2016-10-07 13:22:43,https://api.github.com/repos/hyperledger/burrow/pulls/comments/82387286,https://github.com/hyperledger/burrow/pull/315#discussion_r82387286,benjaminbollen
https://github.com/hyperledger/burrow/pull/315,https://github.com/hyperledger/burrow/pull/315,"ah never mind, transact and transactAndHold have the same ""broken"" architecture; both of these need to be deprectaed in favor of using eris-client which now has the `waitForConfirmation`; but we can merge it for rc3
",f8b670a358e53bf6c33851e945993b3d44376427,2016-10-07 13:24:56,82387665,"@@ -90,6 +90,13 @@ type (
 		GasLimit int64  `json:""gas_limit""`
 	}
 
+	// Used when sending a 'Send' transaction.
+	SendParam struct {
+		PrivKey   []byte `json:""priv_key""`",6,2016-10-07 13:24:56,https://api.github.com/repos/hyperledger/burrow/pulls/comments/82387665,https://github.com/hyperledger/burrow/pull/315#discussion_r82387665,benjaminbollen
https://github.com/hyperledger/burrow/pull/314,https://github.com/hyperledger/burrow/pull/314,"These defaults I've taken from Tendermint; it is important to check that Tendermint will not set them, if they are not set by us.  but yes, we definitely want to look at disabling tendermints internal rpc for in-process tendermint
",1d1b2b920f334dea5269a1ca470e22fd142d328f,2016-10-07 13:59:01,82394129,"@@ -73,7 +73,7 @@ func (tmintConfig *TendermintConfig) AssertTendermintDefaults(chainId, workDir,
 	tmintConfig.SetDefault(""db_backend"", ""leveldb"")
 	tmintConfig.SetDefault(""db_dir"", dataDir)
 	tmintConfig.SetDefault(""log_level"", ""info"")
-	tmintConfig.SetDefault(""rpc_laddr"", ""0.0.0.0:46657"")",4,2016-10-07 14:44:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/82394129,https://github.com/hyperledger/burrow/pull/314#discussion_r82394129,benjaminbollen
https://github.com/hyperledger/burrow/pull/314,https://github.com/hyperledger/burrow/pull/314,"brilliant, but Im not sure that it would work;  I would almost default to setting the tendermint rpc to a different port by default `0.0.0.0:48857` eg
",1d1b2b920f334dea5269a1ca470e22fd142d328f,2016-10-07 14:00:48,82394450,"@@ -111,6 +111,16 @@ func NewTendermint(moduleConfig *config.ModuleConfig,
 		path.Join(moduleConfig.RootDir,
 			moduleConfig.Config.GetString(""private_validator_file"")))
 
+	// TODO: [Silas] we want to something better than this like not not have it in
+	// the config at all, but for now I think it's much safer to make sure we are
+	// not running the tendermint RPC as it could lead to unexpected behaviour,
+	// not least if we accidentally try to run it on the same address as our own
+	if tmintConfig.GetString(""rpc_laddr"") != """" {",8,2016-10-07 14:44:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/82394450,https://github.com/hyperledger/burrow/pull/314#discussion_r82394450,benjaminbollen
https://github.com/hyperledger/burrow/pull/314,https://github.com/hyperledger/burrow/pull/314,"alternatively we can hand transactor a pointer to ConsensusEngine, when it is set; but we'll come back to this soon, and then remove the need for these compatibility constructions
",1d1b2b920f334dea5269a1ca470e22fd142d328f,2016-10-07 14:06:14,82395407,"@@ -87,34 +87,47 @@ func NewErisMintPipe(moduleConfig *config.ModuleConfig,
 	// start the application
 	erisMint := NewErisMint(startedState, eventSwitch)
 
-	// NOTE: [ben] Set Host opens an RPC pipe to Tendermint;  this is a remnant
-	// of the old Eris-DB / Tendermint and should be considered as an in-process
-	// call when possible
-	tendermintHost := moduleConfig.Config.GetString(""tendermint_host"")
-	erisMint.SetHostAddress(tendermintHost)
-
 	// initialise the components of the pipe
 	events := edb_event.NewEvents(eventSwitch)
 	accounts := newAccounts(erisMint)
 	namereg := newNameReg(erisMint)
-	transactor := newTransactor(moduleConfig.ChainId, eventSwitch, erisMint,
-		events)
 
-	return &erisMintPipe{
+	pipe := &erisMintPipe{
 		erisMintState: startedState,
 		erisMint:      erisMint,
 		accounts:      accounts,
 		events:        events,
 		namereg:       namereg,
-		transactor:    transactor,
+		// We need to set transactor later since we are introducing a mutual dependency
+		// NOTE: this will be cleaned up when the RPC is unified
+		transactor: nil,
 		// genesis cache
 		genesisDoc:   genesisDoc,
 		genesisState: nil,
 		// consensus and blockchain should both be loaded into the pipe by a higher
 		// authority - this is a sort of dependency injection pattern
 		consensusEngine: nil,
 		blockchain:      nil,
-	}, nil
+	}
+
+	// NOTE: [Silas]
+	// This is something of a loopback, but seems like a nicer option than
+	// transactor calling the Tendermint native RPC (as it was before),
+	// or indeed calling this RPC over the wire given that we have direct access.
+	//
+	// We could just hand transactor a copy of Pipe, but doing it this way seems
+	// like a reasonably minimal and flexible way of providing transactor with the
+	// broadcast function it needs, without making it explicitly
+	// aware of/depend on Pipe.
+	transactor := newTransactor(moduleConfig.ChainId, eventSwitch, erisMint,",47,2016-10-07 14:44:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/82395407,https://github.com/hyperledger/burrow/pull/314#discussion_r82395407,benjaminbollen
https://github.com/hyperledger/burrow/pull/314,https://github.com/hyperledger/burrow/pull/314,"This is a typo, but also we should no longer have server_config.toml in the root directory.
",1d1b2b920f334dea5269a1ca470e22fd142d328f,2016-10-07 14:11:09,82396383,"@@ -150,7 +150,7 @@ listener = ""tcp://0.0.0.0:46658""
 # This file needs to be in the root directory
 private_validator_file = ""priv_validator.json""
 
-  # Tendermint requires additional configuration parameters.
+  # Tendermint requires additional configuration parameters.TransactAndHold",,2016-10-07 14:44:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/82396383,https://github.com/hyperledger/burrow/pull/314#discussion_r82396383,benjaminbollen
https://github.com/hyperledger/burrow/pull/314,https://github.com/hyperledger/burrow/pull/314,"No it disables it: https://github.com/tendermint/tendermint/blob/master/node/node.go#L362 
",1d1b2b920f334dea5269a1ca470e22fd142d328f,2016-10-07 14:11:45,82396517,"@@ -111,6 +111,16 @@ func NewTendermint(moduleConfig *config.ModuleConfig,
 		path.Join(moduleConfig.RootDir,
 			moduleConfig.Config.GetString(""private_validator_file"")))
 
+	// TODO: [Silas] we want to something better than this like not not have it in
+	// the config at all, but for now I think it's much safer to make sure we are
+	// not running the tendermint RPC as it could lead to unexpected behaviour,
+	// not least if we accidentally try to run it on the same address as our own
+	if tmintConfig.GetString(""rpc_laddr"") != """" {",8,2016-10-07 14:44:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/82396517,https://github.com/hyperledger/burrow/pull/314#discussion_r82396517,silasdavis
https://github.com/hyperledger/burrow/pull/314,https://github.com/hyperledger/burrow/pull/314,"I've checked the path and it does not re-set it, and as you see below I am forcibly disabling the RPC. Also checked with Ethan.
",1d1b2b920f334dea5269a1ca470e22fd142d328f,2016-10-07 14:12:27,82396645,"@@ -73,7 +73,7 @@ func (tmintConfig *TendermintConfig) AssertTendermintDefaults(chainId, workDir,
 	tmintConfig.SetDefault(""db_backend"", ""leveldb"")
 	tmintConfig.SetDefault(""db_dir"", dataDir)
 	tmintConfig.SetDefault(""log_level"", ""info"")
-	tmintConfig.SetDefault(""rpc_laddr"", ""0.0.0.0:46657"")",4,2016-10-07 14:44:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/82396645,https://github.com/hyperledger/burrow/pull/314#discussion_r82396645,silasdavis
https://github.com/hyperledger/burrow/pull/314,https://github.com/hyperledger/burrow/pull/314,"Unless there is a strong reason to change it, I'd rather stick with this, as soon it will all be laid to waste as you say...
",1d1b2b920f334dea5269a1ca470e22fd142d328f,2016-10-07 14:14:10,82396942,"@@ -87,34 +87,47 @@ func NewErisMintPipe(moduleConfig *config.ModuleConfig,
 	// start the application
 	erisMint := NewErisMint(startedState, eventSwitch)
 
-	// NOTE: [ben] Set Host opens an RPC pipe to Tendermint;  this is a remnant
-	// of the old Eris-DB / Tendermint and should be considered as an in-process
-	// call when possible
-	tendermintHost := moduleConfig.Config.GetString(""tendermint_host"")
-	erisMint.SetHostAddress(tendermintHost)
-
 	// initialise the components of the pipe
 	events := edb_event.NewEvents(eventSwitch)
 	accounts := newAccounts(erisMint)
 	namereg := newNameReg(erisMint)
-	transactor := newTransactor(moduleConfig.ChainId, eventSwitch, erisMint,
-		events)
 
-	return &erisMintPipe{
+	pipe := &erisMintPipe{
 		erisMintState: startedState,
 		erisMint:      erisMint,
 		accounts:      accounts,
 		events:        events,
 		namereg:       namereg,
-		transactor:    transactor,
+		// We need to set transactor later since we are introducing a mutual dependency
+		// NOTE: this will be cleaned up when the RPC is unified
+		transactor: nil,
 		// genesis cache
 		genesisDoc:   genesisDoc,
 		genesisState: nil,
 		// consensus and blockchain should both be loaded into the pipe by a higher
 		// authority - this is a sort of dependency injection pattern
 		consensusEngine: nil,
 		blockchain:      nil,
-	}, nil
+	}
+
+	// NOTE: [Silas]
+	// This is something of a loopback, but seems like a nicer option than
+	// transactor calling the Tendermint native RPC (as it was before),
+	// or indeed calling this RPC over the wire given that we have direct access.
+	//
+	// We could just hand transactor a copy of Pipe, but doing it this way seems
+	// like a reasonably minimal and flexible way of providing transactor with the
+	// broadcast function it needs, without making it explicitly
+	// aware of/depend on Pipe.
+	transactor := newTransactor(moduleConfig.ChainId, eventSwitch, erisMint,",47,2016-10-07 14:44:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/82396942,https://github.com/hyperledger/burrow/pull/314#discussion_r82396942,silasdavis
https://github.com/hyperledger/burrow/pull/314,https://github.com/hyperledger/burrow/pull/314,"oops yeah, I'll fix that. I more or less agree, at least not in this form. Having said that i think there is an argument to have the config templating as a part of eris-db/eris-client, so changes to config happen in the same place as they are consumed. i.e. move some of what is in eris-cm. But let's shelve this.
",1d1b2b920f334dea5269a1ca470e22fd142d328f,2016-10-07 14:15:54,82397287,"@@ -150,7 +150,7 @@ listener = ""tcp://0.0.0.0:46658""
 # This file needs to be in the root directory
 private_validator_file = ""priv_validator.json""
 
-  # Tendermint requires additional configuration parameters.
+  # Tendermint requires additional configuration parameters.TransactAndHold",,2016-10-07 14:44:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/82397287,https://github.com/hyperledger/burrow/pull/314#discussion_r82397287,silasdavis
https://github.com/hyperledger/burrow/pull/314,https://github.com/hyperledger/burrow/pull/314,"yeah, while I was typing that, it makes sense to me as well that having cm define the config and edb consume it is dangerous.  Better for cm to have it write and manage all, but depend on a eris-client functionality
",1d1b2b920f334dea5269a1ca470e22fd142d328f,2016-10-07 14:18:14,82397765,"@@ -150,7 +150,7 @@ listener = ""tcp://0.0.0.0:46658""
 # This file needs to be in the root directory
 private_validator_file = ""priv_validator.json""
 
-  # Tendermint requires additional configuration parameters.
+  # Tendermint requires additional configuration parameters.TransactAndHold",,2016-10-07 14:44:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/82397765,https://github.com/hyperledger/burrow/pull/314#discussion_r82397765,benjaminbollen
https://github.com/hyperledger/burrow/pull/314,https://github.com/hyperledger/burrow/pull/314,"no stick with it here.  That was what I was hoping to convey.  It s very nice and like it.
",1d1b2b920f334dea5269a1ca470e22fd142d328f,2016-10-07 14:27:59,82399810,"@@ -87,34 +87,47 @@ func NewErisMintPipe(moduleConfig *config.ModuleConfig,
 	// start the application
 	erisMint := NewErisMint(startedState, eventSwitch)
 
-	// NOTE: [ben] Set Host opens an RPC pipe to Tendermint;  this is a remnant
-	// of the old Eris-DB / Tendermint and should be considered as an in-process
-	// call when possible
-	tendermintHost := moduleConfig.Config.GetString(""tendermint_host"")
-	erisMint.SetHostAddress(tendermintHost)
-
 	// initialise the components of the pipe
 	events := edb_event.NewEvents(eventSwitch)
 	accounts := newAccounts(erisMint)
 	namereg := newNameReg(erisMint)
-	transactor := newTransactor(moduleConfig.ChainId, eventSwitch, erisMint,
-		events)
 
-	return &erisMintPipe{
+	pipe := &erisMintPipe{
 		erisMintState: startedState,
 		erisMint:      erisMint,
 		accounts:      accounts,
 		events:        events,
 		namereg:       namereg,
-		transactor:    transactor,
+		// We need to set transactor later since we are introducing a mutual dependency
+		// NOTE: this will be cleaned up when the RPC is unified
+		transactor: nil,
 		// genesis cache
 		genesisDoc:   genesisDoc,
 		genesisState: nil,
 		// consensus and blockchain should both be loaded into the pipe by a higher
 		// authority - this is a sort of dependency injection pattern
 		consensusEngine: nil,
 		blockchain:      nil,
-	}, nil
+	}
+
+	// NOTE: [Silas]
+	// This is something of a loopback, but seems like a nicer option than
+	// transactor calling the Tendermint native RPC (as it was before),
+	// or indeed calling this RPC over the wire given that we have direct access.
+	//
+	// We could just hand transactor a copy of Pipe, but doing it this way seems
+	// like a reasonably minimal and flexible way of providing transactor with the
+	// broadcast function it needs, without making it explicitly
+	// aware of/depend on Pipe.
+	transactor := newTransactor(moduleConfig.ChainId, eventSwitch, erisMint,",47,2016-10-07 14:44:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/82399810,https://github.com/hyperledger/burrow/pull/314#discussion_r82399810,benjaminbollen
https://github.com/hyperledger/burrow/pull/314,https://github.com/hyperledger/burrow/pull/314,"Ha! brilliant, BUT we then need to `Set` it to """" and not `SetDefault`.  That way the config file cannot overwrite it.  Also bare in mind that Tendermint will set it's own default if it is not set, but that should be fine given we set the defaults first, then Tendermint runs over this code.  https://github.com/tendermint/tendermint/blob/master/config/tendermint/config.go#L68
",1d1b2b920f334dea5269a1ca470e22fd142d328f,2016-10-07 14:38:04,82401840,"@@ -111,6 +111,16 @@ func NewTendermint(moduleConfig *config.ModuleConfig,
 		path.Join(moduleConfig.RootDir,
 			moduleConfig.Config.GetString(""private_validator_file"")))
 
+	// TODO: [Silas] we want to something better than this like not not have it in
+	// the config at all, but for now I think it's much safer to make sure we are
+	// not running the tendermint RPC as it could lead to unexpected behaviour,
+	// not least if we accidentally try to run it on the same address as our own
+	if tmintConfig.GetString(""rpc_laddr"") != """" {",8,2016-10-07 14:44:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/82401840,https://github.com/hyperledger/burrow/pull/314#discussion_r82401840,benjaminbollen
https://github.com/hyperledger/burrow/pull/310,https://github.com/hyperledger/burrow/pull/310,"It is convenient to be able to include the opcodes independent of the entire EVM
",91a36760840b498c2b4f3b5cec2d447c61dc1e3b,2016-10-05 09:46:48,81936723,"@@ -1,4 +1,4 @@
-package vm
+package opcodes",2,2016-10-05 09:49:52,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81936723,https://github.com/hyperledger/burrow/pull/310#discussion_r81936723,silasdavis
https://github.com/hyperledger/burrow/pull/310,https://github.com/hyperledger/burrow/pull/310,"With reference to previous remark, here we can write down bytecode in a more humane way
",91a36760840b498c2b4f3b5cec2d447c61dc1e3b,2016-10-05 09:47:26,81936832,"@@ -222,17 +329,42 @@ func callContractCode(addr []byte) []byte {
 	inOff, inSize := byte(0x0), byte(0x0) // no call data
 	retOff, retSize := byte(0x0), byte(0x20)
 	// this is the code we want to run (send funds to an account and return)
+	return Bytecode(PUSH1, retSize, PUSH1, retOff, PUSH1, inSize, PUSH1,
+		inOff, PUSH1, value, PUSH20, addr, PUSH2, gas1, gas2, CALL, PUSH1, retSize,
+		PUSH1, retOff, RETURN)
+}
+
+func TestBytecode(t *testing.T) {
+	assert.Equal(t,
+		Bytecode(1, 2, 3, 4, 5, 6),
+		Bytecode(1, 2, 3, Bytecode(4, 5, 6)))
+	assert.Equal(t,
+		Bytecode(1, 2, 3, 4, 5, 6, 7, 8),
+		Bytecode(1, 2, 3, Bytecode(4, Bytecode(5), 6), 7, 8))
+	assert.Equal(t,
+		Bytecode(PUSH1, 2),
+		Bytecode(byte(PUSH1), 0x02))
+	assert.Equal(t,
+		[]byte{},
+		Bytecode(Bytecode(Bytecode())))
+
+	contractAccount := &Account{Address: Int64ToWord256(102)}
+	addr := contractAccount.Address.Postfix(20)
+	gas1, gas2 := byte(0x1), byte(0x1)
+	value := byte(0x69)
+	inOff, inSize := byte(0x0), byte(0x0) // no call data
+	retOff, retSize := byte(0x0), byte(0x20)
+	contractCodeBytecode := Bytecode(PUSH1, retSize, PUSH1, retOff, PUSH1, inSize, PUSH1,
+		inOff, PUSH1, value, PUSH20, addr, PUSH2, gas1, gas2, CALL, PUSH1, retSize,
+		PUSH1, retOff, RETURN)",259,2016-10-05 09:49:52,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81936832,https://github.com/hyperledger/burrow/pull/310#discussion_r81936832,silasdavis
https://github.com/hyperledger/burrow/pull/310,https://github.com/hyperledger/burrow/pull/310,"Before this change we were not leaving enough head-room for the caller when sending gas for the callee, and so were getting an insufficient gas error
",91a36760840b498c2b4f3b5cec2d447c61dc1e3b,2016-10-05 09:48:47,81937063,"@@ -1257,17 +1258,17 @@ func snativeRoleTestInputTx(name string, user *acm.PrivAccount, role string) (sn
 func callContractCode(contractAddr []byte) []byte {
 	// calldatacopy into mem and use as input to call
 	memOff, inputOff := byte(0x0), byte(0x0)
-	contractCode := []byte{0x36, 0x60, inputOff, 0x60, memOff, 0x37}
-
-	gas1, gas2 := byte(0x1), byte(0x1)
 	value := byte(0x1)
 	inOff := byte(0x0)
 	retOff, retSize := byte(0x0), byte(0x20)
+
 	// this is the code we want to run (call a contract and return)
-	contractCode = append(contractCode, []byte{0x60, retSize, 0x60, retOff, 0x36, 0x60, inOff, 0x60, value, 0x73}...)
-	contractCode = append(contractCode, contractAddr...)
-	contractCode = append(contractCode, []byte{0x61, gas1, gas2, 0xf1, 0x60, 0x20, 0x60, 0x0, 0xf3}...)
-	return contractCode
+	return Bytecode(CALLDATASIZE, PUSH1, inputOff, PUSH1, memOff,
+		CALLDATACOPY, PUSH1, retSize, PUSH1, retOff, CALLDATASIZE, PUSH1, inOff,
+		PUSH1, value, PUSH20, contractAddr,
+		// Zeno loves us - call with half of the available gas each time we CALL
+		PUSH1, 2, GAS, DIV, CALL,",28,2016-10-05 09:49:52,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81937063,https://github.com/hyperledger/burrow/pull/310#discussion_r81937063,silasdavis
https://github.com/hyperledger/burrow/pull/310,https://github.com/hyperledger/burrow/pull/310,"There just wasn't enough gas for the hardcoded bytecode that is used by this test
",91a36760840b498c2b4f3b5cec2d447c61dc1e3b,2016-10-05 09:52:38,81937715,"@@ -463,7 +464,7 @@ func TestCreates(t *testing.T) {
 			PubKey:   acc0PubKey,
 		},
 		Address:  acc1.Address,
-		GasLimit: 10000,
+		GasLimit: 100000,",20,2016-10-05 09:52:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81937715,https://github.com/hyperledger/burrow/pull/310#discussion_r81937715,silasdavis
https://github.com/hyperledger/burrow/pull/310,https://github.com/hyperledger/burrow/pull/310,"nice!
",91a36760840b498c2b4f3b5cec2d447c61dc1e3b,2016-10-05 09:54:29,81938012,"@@ -222,17 +329,42 @@ func callContractCode(addr []byte) []byte {
 	inOff, inSize := byte(0x0), byte(0x0) // no call data
 	retOff, retSize := byte(0x0), byte(0x20)
 	// this is the code we want to run (send funds to an account and return)
+	return Bytecode(PUSH1, retSize, PUSH1, retOff, PUSH1, inSize, PUSH1,
+		inOff, PUSH1, value, PUSH20, addr, PUSH2, gas1, gas2, CALL, PUSH1, retSize,
+		PUSH1, retOff, RETURN)
+}
+
+func TestBytecode(t *testing.T) {
+	assert.Equal(t,
+		Bytecode(1, 2, 3, 4, 5, 6),
+		Bytecode(1, 2, 3, Bytecode(4, 5, 6)))
+	assert.Equal(t,
+		Bytecode(1, 2, 3, 4, 5, 6, 7, 8),
+		Bytecode(1, 2, 3, Bytecode(4, Bytecode(5), 6), 7, 8))
+	assert.Equal(t,
+		Bytecode(PUSH1, 2),
+		Bytecode(byte(PUSH1), 0x02))
+	assert.Equal(t,
+		[]byte{},
+		Bytecode(Bytecode(Bytecode())))
+
+	contractAccount := &Account{Address: Int64ToWord256(102)}
+	addr := contractAccount.Address.Postfix(20)
+	gas1, gas2 := byte(0x1), byte(0x1)
+	value := byte(0x69)
+	inOff, inSize := byte(0x0), byte(0x0) // no call data
+	retOff, retSize := byte(0x0), byte(0x20)
+	contractCodeBytecode := Bytecode(PUSH1, retSize, PUSH1, retOff, PUSH1, inSize, PUSH1,
+		inOff, PUSH1, value, PUSH20, addr, PUSH2, gas1, gas2, CALL, PUSH1, retSize,
+		PUSH1, retOff, RETURN)",259,2016-10-05 10:07:07,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81938012,https://github.com/hyperledger/burrow/pull/310#discussion_r81938012,benjaminbollen
https://github.com/hyperledger/burrow/pull/304,https://github.com/hyperledger/burrow/pull/304,"yeah since it's local
",9182a76c02cd6180aa04a889d95b0475e5a107fa,2016-10-04 18:44:12,81825803,"@@ -186,8 +229,7 @@ func (erisNodeClient *ErisNodeClient) GetName(name string) (owner []byte, data s
 		return nil, """", 0, err
 	}
 	// unwrap return results
-	owner = make([]byte, len(entryResult.Owner))
-	copy(owner, entryResult.Owner) 
+	owner = entryResult.Owner",,2016-10-06 10:26:06,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81825803,https://github.com/hyperledger/burrow/pull/304#discussion_r81825803,silasdavis
https://github.com/hyperledger/burrow/pull/304,https://github.com/hyperledger/burrow/pull/304,"I think this is about as clean as we can/should be for now, good
",9182a76c02cd6180aa04a889d95b0475e5a107fa,2016-10-04 18:44:29,81825867,"@@ -75,6 +87,37 @@ func (erisNodeClient *ErisNodeClient) Broadcast(tx txs.Tx) (*txs.Receipt, error)
 	return &receipt, nil
 }
 
+func (erisNodeClient *ErisNodeClient) DeriveWebsocketClient() (nodeWsClient NodeWebsocketClient, err error) {
+	var wsAddr string
+	// TODO: clean up this inherited mess on dealing with the address prefixes.
+	nodeAddr := erisNodeClient.broadcastRPC
+	if strings.HasPrefix(nodeAddr, ""http://"") {
+		wsAddr = strings.TrimPrefix(nodeAddr, ""http://"")
+	}
+	if strings.HasPrefix(nodeAddr, ""tcp://"") {
+		wsAddr = strings.TrimPrefix(nodeAddr, ""tcp://"")
+	}
+	if strings.HasPrefix(nodeAddr, ""unix://"") {
+		log.WithFields(log.Fields{
+			""node address"": nodeAddr,
+		}).Error(""Unable to subscribe to websocket from unix socket."")
+		return nil, fmt.Errorf(""Unable to construct websocket from unix socket: %s"", nodeAddr)
+	}
+	wsAddr = ""ws://"" + wsAddr
+	log.WithFields(log.Fields{
+		""websocket address"": wsAddr,
+		""endpoint"": ""/websocket"",
+	}).Debug(""Subscribing to websocket address"")
+	wsClient := rpcclient.NewWSClient(wsAddr, ""/websocket"")
+	if _, err = wsClient.Start(); err != nil {
+		return nil, err
+	}
+	derivedErisNodeWebsocketClient := &ErisNodeWebsocketClient{
+		tendermintWebsocket: wsClient,
+	}
+	return derivedErisNodeWebsocketClient, nil",79,2016-10-06 10:26:06,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81825867,https://github.com/hyperledger/burrow/pull/304#discussion_r81825867,silasdavis
https://github.com/hyperledger/burrow/pull/304,https://github.com/hyperledger/burrow/pull/304,"I think you can just inline this. Under 'normal' circumstances no need to clean up time.After, see: https://groups.google.com/forum/#!topic/golang-nuts/cCdm0Ixwi9A 
",9182a76c02cd6180aa04a889d95b0475e5a107fa,2016-10-04 18:48:42,81826670,"@@ -0,0 +1,193 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package client
+
+import (
+	""bytes""
+	""fmt""
+	""time""
+
+	""github.com/tendermint/go-rpc/client""
+	""github.com/tendermint/go-wire""
+
+	log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/txs""
+	ctypes ""github.com/eris-ltd/eris-db/rpc/tendermint/core/types""
+)
+
+const (
+	MaxCommitWaitTimeSeconds = 10
+)
+
+type Confirmation struct {
+	BlockHash []byte
+	Event     txs.EventData
+	Exception error
+	Error     error
+}
+
+// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// eris-db/client.NodeClient
+var _ NodeWebsocketClient = (*ErisNodeWebsocketClient)(nil)
+
+type ErisNodeWebsocketClient struct {
+	// TODO: assert no memory leak on closing with open websocket
+	tendermintWebsocket *rpcclient.WSClient
+}
+
+// Subscribe to an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Subscribe(eventid string) error {
+	// TODO we can in the background listen to the subscription id and remember it to ease unsubscribing later.
+	return erisNodeWebsocketClient.tendermintWebsocket.Subscribe(eventid)
+}
+
+// Unsubscribe from an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Unsubscribe(subscriptionId string) error {
+	return erisNodeWebsocketClient.tendermintWebsocket.Unsubscribe(subscriptionId)
+}
+
+// Returns a channel that will receive a confirmation with a result or the exception that
+// has been confirmed; or an error is returned and the confirmation channel is nil.
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) WaitForConfirmation(tx txs.Tx, chainId string, inputAddr []byte) (chan Confirmation, error) {
+	// check no errors are reported on the websocket 
+	if err := erisNodeWebsocketClient.assertNoErrors(); err != nil {
+		return nil, err
+	}
+
+	// Setup the confirmation channel to be returned
+	confirmationChannel := make(chan Confirmation, 1)
+	var latestBlockHash []byte
+
+	eid := txs.EventStringAccInput(inputAddr)
+
+	// Read the incoming events
+	go func() {
+		var err error
+		for {
+			resultBytes := <- erisNodeWebsocketClient.tendermintWebsocket.ResultsCh
+			result := new(ctypes.ErisDBResult)
+			if wire.ReadJSONPtr(result, resultBytes, &err); err != nil {
+				// keep calm and carry on
+				log.Errorf(""eris-client - Failed to unmarshal json bytes for websocket event: %s"", err)
+				continue
+			}
+			
+			event, ok := (*result).(*ctypes.ResultEvent)
+			if !ok {
+				// keep calm and carry on
+				log.Error(""eris-client - Failed to cast to ResultEvent for websocket event"")
+				continue
+			}
+			
+			blockData, ok := event.Data.(txs.EventDataNewBlock)
+			if ok {
+				latestBlockHash = blockData.Block.Hash()
+				log.WithFields(log.Fields{
+					""new block"": blockData.Block,
+					""latest hash"": latestBlockHash,
+				}).Debug(""Registered new block"")
+				continue
+			}
+			
+			// we don't accept events unless they came after a new block (ie. in)
+			if latestBlockHash == nil {
+				continue
+			}
+
+			if event.Event != eid {
+				log.Warnf(""Received unsolicited event! Got %s, expected %s\n"", event.Event, eid)
+				continue
+			}
+
+			data, ok := event.Data.(txs.EventDataTx)
+			if !ok {
+				// We are on the lookout for EventDataTx
+				confirmationChannel <- Confirmation{
+					BlockHash: latestBlockHash,
+					Event: nil,
+					Exception: fmt.Errorf(""response error: expected result.Data to be *types.EventDataTx""),
+					Error: nil,
+				}
+				return
+			}
+
+			if !bytes.Equal(txs.TxHash(chainId, data.Tx), txs.TxHash(chainId, tx)) {
+				log.WithFields(log.Fields{
+					// TODO: consider re-implementing TxID again, or other more clear debug
+					""received transaction event"": txs.TxHash(chainId, data.Tx),
+				}).Debug(""Received different event"")
+				continue
+			}
+
+			if data.Exception != """" {
+				confirmationChannel <- Confirmation{
+					BlockHash: latestBlockHash,
+					Event: &data,
+					Exception: fmt.Errorf(""Transaction confirmed with exception:"", data.Exception),
+					Error: nil,
+				}
+				return
+			}
+			
+			// success, return the full event and blockhash and exit go-routine
+			confirmationChannel <- Confirmation{
+				BlockHash: latestBlockHash,
+				Event: &data,
+				Exception: nil,
+				Error: nil,
+			}
+			return
+		}
+
+	}()
+
+	// TODO: [ben] this is a draft implementation as resources on time.After can not be
+	// recovered before the timeout.  Close-down timeout at success properly.
+	timeout := time.After(time.Duration(MaxCommitWaitTimeSeconds) * time.Second)",176,2016-10-06 10:26:06,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81826670,https://github.com/hyperledger/burrow/pull/304#discussion_r81826670,silasdavis
https://github.com/hyperledger/burrow/pull/304,https://github.com/hyperledger/burrow/pull/304,"Is this really an error? Can't quite think what other stuff gets shoved down this pipe, but I seem to remember a few different types are.
",9182a76c02cd6180aa04a889d95b0475e5a107fa,2016-10-04 18:51:06,81827186,"@@ -0,0 +1,193 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package client
+
+import (
+	""bytes""
+	""fmt""
+	""time""
+
+	""github.com/tendermint/go-rpc/client""
+	""github.com/tendermint/go-wire""
+
+	log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/txs""
+	ctypes ""github.com/eris-ltd/eris-db/rpc/tendermint/core/types""
+)
+
+const (
+	MaxCommitWaitTimeSeconds = 10
+)
+
+type Confirmation struct {
+	BlockHash []byte
+	Event     txs.EventData
+	Exception error
+	Error     error
+}
+
+// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// eris-db/client.NodeClient
+var _ NodeWebsocketClient = (*ErisNodeWebsocketClient)(nil)
+
+type ErisNodeWebsocketClient struct {
+	// TODO: assert no memory leak on closing with open websocket
+	tendermintWebsocket *rpcclient.WSClient
+}
+
+// Subscribe to an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Subscribe(eventid string) error {
+	// TODO we can in the background listen to the subscription id and remember it to ease unsubscribing later.
+	return erisNodeWebsocketClient.tendermintWebsocket.Subscribe(eventid)
+}
+
+// Unsubscribe from an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Unsubscribe(subscriptionId string) error {
+	return erisNodeWebsocketClient.tendermintWebsocket.Unsubscribe(subscriptionId)
+}
+
+// Returns a channel that will receive a confirmation with a result or the exception that
+// has been confirmed; or an error is returned and the confirmation channel is nil.
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) WaitForConfirmation(tx txs.Tx, chainId string, inputAddr []byte) (chan Confirmation, error) {
+	// check no errors are reported on the websocket 
+	if err := erisNodeWebsocketClient.assertNoErrors(); err != nil {
+		return nil, err
+	}
+
+	// Setup the confirmation channel to be returned
+	confirmationChannel := make(chan Confirmation, 1)
+	var latestBlockHash []byte
+
+	eid := txs.EventStringAccInput(inputAddr)
+
+	// Read the incoming events
+	go func() {
+		var err error
+		for {
+			resultBytes := <- erisNodeWebsocketClient.tendermintWebsocket.ResultsCh
+			result := new(ctypes.ErisDBResult)
+			if wire.ReadJSONPtr(result, resultBytes, &err); err != nil {
+				// keep calm and carry on
+				log.Errorf(""eris-client - Failed to unmarshal json bytes for websocket event: %s"", err)
+				continue
+			}
+			
+			event, ok := (*result).(*ctypes.ResultEvent)
+			if !ok {
+				// keep calm and carry on
+				log.Error(""eris-client - Failed to cast to ResultEvent for websocket event"")",,2016-10-06 10:26:06,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81827186,https://github.com/hyperledger/burrow/pull/304#discussion_r81827186,silasdavis
https://github.com/hyperledger/burrow/pull/304,https://github.com/hyperledger/burrow/pull/304,"Similar to above, it might be correct to return some sort of error here, but I just want to query that.
",9182a76c02cd6180aa04a889d95b0475e5a107fa,2016-10-04 18:51:43,81827309,"@@ -0,0 +1,193 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package client
+
+import (
+	""bytes""
+	""fmt""
+	""time""
+
+	""github.com/tendermint/go-rpc/client""
+	""github.com/tendermint/go-wire""
+
+	log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/txs""
+	ctypes ""github.com/eris-ltd/eris-db/rpc/tendermint/core/types""
+)
+
+const (
+	MaxCommitWaitTimeSeconds = 10
+)
+
+type Confirmation struct {
+	BlockHash []byte
+	Event     txs.EventData
+	Exception error
+	Error     error
+}
+
+// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// eris-db/client.NodeClient
+var _ NodeWebsocketClient = (*ErisNodeWebsocketClient)(nil)
+
+type ErisNodeWebsocketClient struct {
+	// TODO: assert no memory leak on closing with open websocket
+	tendermintWebsocket *rpcclient.WSClient
+}
+
+// Subscribe to an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Subscribe(eventid string) error {
+	// TODO we can in the background listen to the subscription id and remember it to ease unsubscribing later.
+	return erisNodeWebsocketClient.tendermintWebsocket.Subscribe(eventid)
+}
+
+// Unsubscribe from an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Unsubscribe(subscriptionId string) error {
+	return erisNodeWebsocketClient.tendermintWebsocket.Unsubscribe(subscriptionId)
+}
+
+// Returns a channel that will receive a confirmation with a result or the exception that
+// has been confirmed; or an error is returned and the confirmation channel is nil.
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) WaitForConfirmation(tx txs.Tx, chainId string, inputAddr []byte) (chan Confirmation, error) {
+	// check no errors are reported on the websocket 
+	if err := erisNodeWebsocketClient.assertNoErrors(); err != nil {
+		return nil, err
+	}
+
+	// Setup the confirmation channel to be returned
+	confirmationChannel := make(chan Confirmation, 1)
+	var latestBlockHash []byte
+
+	eid := txs.EventStringAccInput(inputAddr)
+
+	// Read the incoming events
+	go func() {
+		var err error
+		for {
+			resultBytes := <- erisNodeWebsocketClient.tendermintWebsocket.ResultsCh
+			result := new(ctypes.ErisDBResult)
+			if wire.ReadJSONPtr(result, resultBytes, &err); err != nil {
+				// keep calm and carry on
+				log.Errorf(""eris-client - Failed to unmarshal json bytes for websocket event: %s"", err)
+				continue
+			}
+			
+			event, ok := (*result).(*ctypes.ResultEvent)
+			if !ok {
+				// keep calm and carry on
+				log.Error(""eris-client - Failed to cast to ResultEvent for websocket event"")
+				continue
+			}
+			
+			blockData, ok := event.Data.(txs.EventDataNewBlock)
+			if ok {
+				latestBlockHash = blockData.Block.Hash()
+				log.WithFields(log.Fields{
+					""new block"": blockData.Block,
+					""latest hash"": latestBlockHash,
+				}).Debug(""Registered new block"")
+				continue
+			}
+			
+			// we don't accept events unless they came after a new block (ie. in)
+			if latestBlockHash == nil {
+				continue
+			}
+
+			if event.Event != eid {
+				log.Warnf(""Received unsolicited event! Got %s, expected %s\n"", event.Event, eid)
+				continue
+			}
+
+			data, ok := event.Data.(txs.EventDataTx)
+			if !ok {",134,2016-10-06 10:26:06,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81827309,https://github.com/hyperledger/burrow/pull/304#discussion_r81827309,silasdavis
https://github.com/hyperledger/burrow/pull/304,https://github.com/hyperledger/burrow/pull/304,"So if I'm following correctly, the idea is that we want to receive a single confirmation in a non-blocking fashion (into the 1-buffer), and we never hit a second send on the channel before returning?
",9182a76c02cd6180aa04a889d95b0475e5a107fa,2016-10-04 18:54:22,81827826,"@@ -0,0 +1,193 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package client
+
+import (
+	""bytes""
+	""fmt""
+	""time""
+
+	""github.com/tendermint/go-rpc/client""
+	""github.com/tendermint/go-wire""
+
+	log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/txs""
+	ctypes ""github.com/eris-ltd/eris-db/rpc/tendermint/core/types""
+)
+
+const (
+	MaxCommitWaitTimeSeconds = 10
+)
+
+type Confirmation struct {
+	BlockHash []byte
+	Event     txs.EventData
+	Exception error
+	Error     error
+}
+
+// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// eris-db/client.NodeClient
+var _ NodeWebsocketClient = (*ErisNodeWebsocketClient)(nil)
+
+type ErisNodeWebsocketClient struct {
+	// TODO: assert no memory leak on closing with open websocket
+	tendermintWebsocket *rpcclient.WSClient
+}
+
+// Subscribe to an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Subscribe(eventid string) error {
+	// TODO we can in the background listen to the subscription id and remember it to ease unsubscribing later.
+	return erisNodeWebsocketClient.tendermintWebsocket.Subscribe(eventid)
+}
+
+// Unsubscribe from an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Unsubscribe(subscriptionId string) error {
+	return erisNodeWebsocketClient.tendermintWebsocket.Unsubscribe(subscriptionId)
+}
+
+// Returns a channel that will receive a confirmation with a result or the exception that
+// has been confirmed; or an error is returned and the confirmation channel is nil.
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) WaitForConfirmation(tx txs.Tx, chainId string, inputAddr []byte) (chan Confirmation, error) {
+	// check no errors are reported on the websocket 
+	if err := erisNodeWebsocketClient.assertNoErrors(); err != nil {
+		return nil, err
+	}
+
+	// Setup the confirmation channel to be returned
+	confirmationChannel := make(chan Confirmation, 1)",73,2016-10-06 10:26:06,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81827826,https://github.com/hyperledger/burrow/pull/304#discussion_r81827826,silasdavis
https://github.com/hyperledger/burrow/pull/304,https://github.com/hyperledger/burrow/pull/304,"I wonder if we should use something like:

``` golang
go func(){
    select {
    case <-time.After(time.Duration(MaxCommitWaitTimeSeconds) * time.Second):
        // Error confirmation
        return
    case <-shutdownCh:
        // Avoid timing out after have received confirmation
    }
}
```

Where shutdownCh gets sent a message as soon as we have a valid confirmation.

As it stands It shouldn't really make any difference, just if code were to be added before the return of the function there could be a race.

Hmm... I'm not sure if this is a valid thing to do really in the circumstances, but I've suggested it now so I'll leave it!
",9182a76c02cd6180aa04a889d95b0475e5a107fa,2016-10-04 19:07:31,81830462,"@@ -0,0 +1,193 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package client
+
+import (
+	""bytes""
+	""fmt""
+	""time""
+
+	""github.com/tendermint/go-rpc/client""
+	""github.com/tendermint/go-wire""
+
+	log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/txs""
+	ctypes ""github.com/eris-ltd/eris-db/rpc/tendermint/core/types""
+)
+
+const (
+	MaxCommitWaitTimeSeconds = 10
+)
+
+type Confirmation struct {
+	BlockHash []byte
+	Event     txs.EventData
+	Exception error
+	Error     error
+}
+
+// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// eris-db/client.NodeClient
+var _ NodeWebsocketClient = (*ErisNodeWebsocketClient)(nil)
+
+type ErisNodeWebsocketClient struct {
+	// TODO: assert no memory leak on closing with open websocket
+	tendermintWebsocket *rpcclient.WSClient
+}
+
+// Subscribe to an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Subscribe(eventid string) error {
+	// TODO we can in the background listen to the subscription id and remember it to ease unsubscribing later.
+	return erisNodeWebsocketClient.tendermintWebsocket.Subscribe(eventid)
+}
+
+// Unsubscribe from an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Unsubscribe(subscriptionId string) error {
+	return erisNodeWebsocketClient.tendermintWebsocket.Unsubscribe(subscriptionId)
+}
+
+// Returns a channel that will receive a confirmation with a result or the exception that
+// has been confirmed; or an error is returned and the confirmation channel is nil.
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) WaitForConfirmation(tx txs.Tx, chainId string, inputAddr []byte) (chan Confirmation, error) {
+	// check no errors are reported on the websocket 
+	if err := erisNodeWebsocketClient.assertNoErrors(); err != nil {
+		return nil, err
+	}
+
+	// Setup the confirmation channel to be returned
+	confirmationChannel := make(chan Confirmation, 1)
+	var latestBlockHash []byte
+
+	eid := txs.EventStringAccInput(inputAddr)
+
+	// Read the incoming events
+	go func() {
+		var err error
+		for {
+			resultBytes := <- erisNodeWebsocketClient.tendermintWebsocket.ResultsCh
+			result := new(ctypes.ErisDBResult)
+			if wire.ReadJSONPtr(result, resultBytes, &err); err != nil {
+				// keep calm and carry on
+				log.Errorf(""eris-client - Failed to unmarshal json bytes for websocket event: %s"", err)
+				continue
+			}
+			
+			event, ok := (*result).(*ctypes.ResultEvent)
+			if !ok {
+				// keep calm and carry on
+				log.Error(""eris-client - Failed to cast to ResultEvent for websocket event"")
+				continue
+			}
+			
+			blockData, ok := event.Data.(txs.EventDataNewBlock)
+			if ok {
+				latestBlockHash = blockData.Block.Hash()
+				log.WithFields(log.Fields{
+					""new block"": blockData.Block,
+					""latest hash"": latestBlockHash,
+				}).Debug(""Registered new block"")
+				continue
+			}
+			
+			// we don't accept events unless they came after a new block (ie. in)
+			if latestBlockHash == nil {
+				continue
+			}
+
+			if event.Event != eid {
+				log.Warnf(""Received unsolicited event! Got %s, expected %s\n"", event.Event, eid)
+				continue
+			}
+
+			data, ok := event.Data.(txs.EventDataTx)
+			if !ok {
+				// We are on the lookout for EventDataTx
+				confirmationChannel <- Confirmation{
+					BlockHash: latestBlockHash,
+					Event: nil,
+					Exception: fmt.Errorf(""response error: expected result.Data to be *types.EventDataTx""),
+					Error: nil,
+				}
+				return
+			}
+
+			if !bytes.Equal(txs.TxHash(chainId, data.Tx), txs.TxHash(chainId, tx)) {
+				log.WithFields(log.Fields{
+					// TODO: consider re-implementing TxID again, or other more clear debug
+					""received transaction event"": txs.TxHash(chainId, data.Tx),
+				}).Debug(""Received different event"")
+				continue
+			}
+
+			if data.Exception != """" {
+				confirmationChannel <- Confirmation{
+					BlockHash: latestBlockHash,
+					Event: &data,
+					Exception: fmt.Errorf(""Transaction confirmed with exception:"", data.Exception),
+					Error: nil,
+				}
+				return
+			}
+			
+			// success, return the full event and blockhash and exit go-routine
+			confirmationChannel <- Confirmation{
+				BlockHash: latestBlockHash,
+				Event: &data,
+				Exception: nil,
+				Error: nil,
+			}
+			return
+		}
+
+	}()
+
+	// TODO: [ben] this is a draft implementation as resources on time.After can not be
+	// recovered before the timeout.  Close-down timeout at success properly.
+	timeout := time.After(time.Duration(MaxCommitWaitTimeSeconds) * time.Second)
+
+	go func() {
+		<- timeout",,2016-10-06 10:26:06,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81830462,https://github.com/hyperledger/burrow/pull/304#discussion_r81830462,silasdavis
https://github.com/hyperledger/burrow/pull/304,https://github.com/hyperledger/burrow/pull/304,"I take it this is just because the way things are... If so, noted and I move on
",9182a76c02cd6180aa04a889d95b0475e5a107fa,2016-10-04 19:09:56,81830941,"@@ -17,13 +17,14 @@
 package keys
 
 import (
+	""fmt""
 	""encoding/hex""
 )
 
 type KeyClient interface {
 	// Sign needs to return the signature bytes for given message to sign
 	// and the address to sign it with.
-	Sign(signBytes []byte, signAddress []byte) (signature []byte, err error)
+	Sign(signBytesString string, signAddress []byte) (signature []byte, err error)",,2016-10-06 10:26:06,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81830941,https://github.com/hyperledger/burrow/pull/304#discussion_r81830941,silasdavis
https://github.com/hyperledger/burrow/pull/304,https://github.com/hyperledger/burrow/pull/304,"strictly speaking it is possible to get multiple confirmation on this channel; so strictly speaking the receiver needs to empty it.  It's very much a draft construction but close/if not literal from mint-client.  A lot of room for improvement
",9182a76c02cd6180aa04a889d95b0475e5a107fa,2016-10-04 20:27:02,81845826,"@@ -0,0 +1,193 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package client
+
+import (
+	""bytes""
+	""fmt""
+	""time""
+
+	""github.com/tendermint/go-rpc/client""
+	""github.com/tendermint/go-wire""
+
+	log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/txs""
+	ctypes ""github.com/eris-ltd/eris-db/rpc/tendermint/core/types""
+)
+
+const (
+	MaxCommitWaitTimeSeconds = 10
+)
+
+type Confirmation struct {
+	BlockHash []byte
+	Event     txs.EventData
+	Exception error
+	Error     error
+}
+
+// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// eris-db/client.NodeClient
+var _ NodeWebsocketClient = (*ErisNodeWebsocketClient)(nil)
+
+type ErisNodeWebsocketClient struct {
+	// TODO: assert no memory leak on closing with open websocket
+	tendermintWebsocket *rpcclient.WSClient
+}
+
+// Subscribe to an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Subscribe(eventid string) error {
+	// TODO we can in the background listen to the subscription id and remember it to ease unsubscribing later.
+	return erisNodeWebsocketClient.tendermintWebsocket.Subscribe(eventid)
+}
+
+// Unsubscribe from an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Unsubscribe(subscriptionId string) error {
+	return erisNodeWebsocketClient.tendermintWebsocket.Unsubscribe(subscriptionId)
+}
+
+// Returns a channel that will receive a confirmation with a result or the exception that
+// has been confirmed; or an error is returned and the confirmation channel is nil.
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) WaitForConfirmation(tx txs.Tx, chainId string, inputAddr []byte) (chan Confirmation, error) {
+	// check no errors are reported on the websocket 
+	if err := erisNodeWebsocketClient.assertNoErrors(); err != nil {
+		return nil, err
+	}
+
+	// Setup the confirmation channel to be returned
+	confirmationChannel := make(chan Confirmation, 1)",73,2016-10-06 10:26:06,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81845826,https://github.com/hyperledger/burrow/pull/304#discussion_r81845826,benjaminbollen
https://github.com/hyperledger/burrow/pull/304,https://github.com/hyperledger/burrow/pull/304,"so you would log warning?
",9182a76c02cd6180aa04a889d95b0475e5a107fa,2016-10-04 20:28:51,81846243,"@@ -0,0 +1,193 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package client
+
+import (
+	""bytes""
+	""fmt""
+	""time""
+
+	""github.com/tendermint/go-rpc/client""
+	""github.com/tendermint/go-wire""
+
+	log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/txs""
+	ctypes ""github.com/eris-ltd/eris-db/rpc/tendermint/core/types""
+)
+
+const (
+	MaxCommitWaitTimeSeconds = 10
+)
+
+type Confirmation struct {
+	BlockHash []byte
+	Event     txs.EventData
+	Exception error
+	Error     error
+}
+
+// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// eris-db/client.NodeClient
+var _ NodeWebsocketClient = (*ErisNodeWebsocketClient)(nil)
+
+type ErisNodeWebsocketClient struct {
+	// TODO: assert no memory leak on closing with open websocket
+	tendermintWebsocket *rpcclient.WSClient
+}
+
+// Subscribe to an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Subscribe(eventid string) error {
+	// TODO we can in the background listen to the subscription id and remember it to ease unsubscribing later.
+	return erisNodeWebsocketClient.tendermintWebsocket.Subscribe(eventid)
+}
+
+// Unsubscribe from an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Unsubscribe(subscriptionId string) error {
+	return erisNodeWebsocketClient.tendermintWebsocket.Unsubscribe(subscriptionId)
+}
+
+// Returns a channel that will receive a confirmation with a result or the exception that
+// has been confirmed; or an error is returned and the confirmation channel is nil.
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) WaitForConfirmation(tx txs.Tx, chainId string, inputAddr []byte) (chan Confirmation, error) {
+	// check no errors are reported on the websocket 
+	if err := erisNodeWebsocketClient.assertNoErrors(); err != nil {
+		return nil, err
+	}
+
+	// Setup the confirmation channel to be returned
+	confirmationChannel := make(chan Confirmation, 1)
+	var latestBlockHash []byte
+
+	eid := txs.EventStringAccInput(inputAddr)
+
+	// Read the incoming events
+	go func() {
+		var err error
+		for {
+			resultBytes := <- erisNodeWebsocketClient.tendermintWebsocket.ResultsCh
+			result := new(ctypes.ErisDBResult)
+			if wire.ReadJSONPtr(result, resultBytes, &err); err != nil {
+				// keep calm and carry on
+				log.Errorf(""eris-client - Failed to unmarshal json bytes for websocket event: %s"", err)
+				continue
+			}
+			
+			event, ok := (*result).(*ctypes.ResultEvent)
+			if !ok {
+				// keep calm and carry on
+				log.Error(""eris-client - Failed to cast to ResultEvent for websocket event"")",,2016-10-06 10:26:06,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81846243,https://github.com/hyperledger/burrow/pull/304#discussion_r81846243,benjaminbollen
https://github.com/hyperledger/burrow/pull/304,https://github.com/hyperledger/burrow/pull/304,"You're right that this indeed is not an error;
",9182a76c02cd6180aa04a889d95b0475e5a107fa,2016-10-04 20:29:07,81846298,"@@ -0,0 +1,193 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package client
+
+import (
+	""bytes""
+	""fmt""
+	""time""
+
+	""github.com/tendermint/go-rpc/client""
+	""github.com/tendermint/go-wire""
+
+	log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/txs""
+	ctypes ""github.com/eris-ltd/eris-db/rpc/tendermint/core/types""
+)
+
+const (
+	MaxCommitWaitTimeSeconds = 10
+)
+
+type Confirmation struct {
+	BlockHash []byte
+	Event     txs.EventData
+	Exception error
+	Error     error
+}
+
+// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// eris-db/client.NodeClient
+var _ NodeWebsocketClient = (*ErisNodeWebsocketClient)(nil)
+
+type ErisNodeWebsocketClient struct {
+	// TODO: assert no memory leak on closing with open websocket
+	tendermintWebsocket *rpcclient.WSClient
+}
+
+// Subscribe to an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Subscribe(eventid string) error {
+	// TODO we can in the background listen to the subscription id and remember it to ease unsubscribing later.
+	return erisNodeWebsocketClient.tendermintWebsocket.Subscribe(eventid)
+}
+
+// Unsubscribe from an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Unsubscribe(subscriptionId string) error {
+	return erisNodeWebsocketClient.tendermintWebsocket.Unsubscribe(subscriptionId)
+}
+
+// Returns a channel that will receive a confirmation with a result or the exception that
+// has been confirmed; or an error is returned and the confirmation channel is nil.
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) WaitForConfirmation(tx txs.Tx, chainId string, inputAddr []byte) (chan Confirmation, error) {
+	// check no errors are reported on the websocket 
+	if err := erisNodeWebsocketClient.assertNoErrors(); err != nil {
+		return nil, err
+	}
+
+	// Setup the confirmation channel to be returned
+	confirmationChannel := make(chan Confirmation, 1)
+	var latestBlockHash []byte
+
+	eid := txs.EventStringAccInput(inputAddr)
+
+	// Read the incoming events
+	go func() {
+		var err error
+		for {
+			resultBytes := <- erisNodeWebsocketClient.tendermintWebsocket.ResultsCh
+			result := new(ctypes.ErisDBResult)
+			if wire.ReadJSONPtr(result, resultBytes, &err); err != nil {
+				// keep calm and carry on
+				log.Errorf(""eris-client - Failed to unmarshal json bytes for websocket event: %s"", err)
+				continue
+			}
+			
+			event, ok := (*result).(*ctypes.ResultEvent)
+			if !ok {
+				// keep calm and carry on
+				log.Error(""eris-client - Failed to cast to ResultEvent for websocket event"")",,2016-10-06 10:26:06,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81846298,https://github.com/hyperledger/burrow/pull/304#discussion_r81846298,benjaminbollen
https://github.com/hyperledger/burrow/pull/304,https://github.com/hyperledger/burrow/pull/304,"Here I think it _should_ only be an EventDataTx for the event string formed from `InputAddr`; so this is stronger an error case than above I think
",9182a76c02cd6180aa04a889d95b0475e5a107fa,2016-10-04 20:30:22,81846554,"@@ -0,0 +1,193 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package client
+
+import (
+	""bytes""
+	""fmt""
+	""time""
+
+	""github.com/tendermint/go-rpc/client""
+	""github.com/tendermint/go-wire""
+
+	log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/txs""
+	ctypes ""github.com/eris-ltd/eris-db/rpc/tendermint/core/types""
+)
+
+const (
+	MaxCommitWaitTimeSeconds = 10
+)
+
+type Confirmation struct {
+	BlockHash []byte
+	Event     txs.EventData
+	Exception error
+	Error     error
+}
+
+// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// eris-db/client.NodeClient
+var _ NodeWebsocketClient = (*ErisNodeWebsocketClient)(nil)
+
+type ErisNodeWebsocketClient struct {
+	// TODO: assert no memory leak on closing with open websocket
+	tendermintWebsocket *rpcclient.WSClient
+}
+
+// Subscribe to an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Subscribe(eventid string) error {
+	// TODO we can in the background listen to the subscription id and remember it to ease unsubscribing later.
+	return erisNodeWebsocketClient.tendermintWebsocket.Subscribe(eventid)
+}
+
+// Unsubscribe from an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Unsubscribe(subscriptionId string) error {
+	return erisNodeWebsocketClient.tendermintWebsocket.Unsubscribe(subscriptionId)
+}
+
+// Returns a channel that will receive a confirmation with a result or the exception that
+// has been confirmed; or an error is returned and the confirmation channel is nil.
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) WaitForConfirmation(tx txs.Tx, chainId string, inputAddr []byte) (chan Confirmation, error) {
+	// check no errors are reported on the websocket 
+	if err := erisNodeWebsocketClient.assertNoErrors(); err != nil {
+		return nil, err
+	}
+
+	// Setup the confirmation channel to be returned
+	confirmationChannel := make(chan Confirmation, 1)
+	var latestBlockHash []byte
+
+	eid := txs.EventStringAccInput(inputAddr)
+
+	// Read the incoming events
+	go func() {
+		var err error
+		for {
+			resultBytes := <- erisNodeWebsocketClient.tendermintWebsocket.ResultsCh
+			result := new(ctypes.ErisDBResult)
+			if wire.ReadJSONPtr(result, resultBytes, &err); err != nil {
+				// keep calm and carry on
+				log.Errorf(""eris-client - Failed to unmarshal json bytes for websocket event: %s"", err)
+				continue
+			}
+			
+			event, ok := (*result).(*ctypes.ResultEvent)
+			if !ok {
+				// keep calm and carry on
+				log.Error(""eris-client - Failed to cast to ResultEvent for websocket event"")
+				continue
+			}
+			
+			blockData, ok := event.Data.(txs.EventDataNewBlock)
+			if ok {
+				latestBlockHash = blockData.Block.Hash()
+				log.WithFields(log.Fields{
+					""new block"": blockData.Block,
+					""latest hash"": latestBlockHash,
+				}).Debug(""Registered new block"")
+				continue
+			}
+			
+			// we don't accept events unless they came after a new block (ie. in)
+			if latestBlockHash == nil {
+				continue
+			}
+
+			if event.Event != eid {
+				log.Warnf(""Received unsolicited event! Got %s, expected %s\n"", event.Event, eid)
+				continue
+			}
+
+			data, ok := event.Data.(txs.EventDataTx)
+			if !ok {",134,2016-10-06 10:26:06,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81846554,https://github.com/hyperledger/burrow/pull/304#discussion_r81846554,benjaminbollen
https://github.com/hyperledger/burrow/pull/304,https://github.com/hyperledger/burrow/pull/304,"Ha! To my victory.  The mint-client code had time.Tick which I thought was more concerning: if used as a command line, then that is fine as program terminates; but we use it as a library in e-pm and that is a problematic use (of time.Tick here);  So I changed it to time.After, so indeed that should saturate the resources used on a 10 second window; but will still pile up these go-routines if many calls are made per second.

For now this can pass as sufficient, but for load testing, I think this might be a point of concern
",9182a76c02cd6180aa04a889d95b0475e5a107fa,2016-10-04 20:51:55,81851024,"@@ -0,0 +1,193 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package client
+
+import (
+	""bytes""
+	""fmt""
+	""time""
+
+	""github.com/tendermint/go-rpc/client""
+	""github.com/tendermint/go-wire""
+
+	log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/txs""
+	ctypes ""github.com/eris-ltd/eris-db/rpc/tendermint/core/types""
+)
+
+const (
+	MaxCommitWaitTimeSeconds = 10
+)
+
+type Confirmation struct {
+	BlockHash []byte
+	Event     txs.EventData
+	Exception error
+	Error     error
+}
+
+// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// eris-db/client.NodeClient
+var _ NodeWebsocketClient = (*ErisNodeWebsocketClient)(nil)
+
+type ErisNodeWebsocketClient struct {
+	// TODO: assert no memory leak on closing with open websocket
+	tendermintWebsocket *rpcclient.WSClient
+}
+
+// Subscribe to an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Subscribe(eventid string) error {
+	// TODO we can in the background listen to the subscription id and remember it to ease unsubscribing later.
+	return erisNodeWebsocketClient.tendermintWebsocket.Subscribe(eventid)
+}
+
+// Unsubscribe from an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Unsubscribe(subscriptionId string) error {
+	return erisNodeWebsocketClient.tendermintWebsocket.Unsubscribe(subscriptionId)
+}
+
+// Returns a channel that will receive a confirmation with a result or the exception that
+// has been confirmed; or an error is returned and the confirmation channel is nil.
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) WaitForConfirmation(tx txs.Tx, chainId string, inputAddr []byte) (chan Confirmation, error) {
+	// check no errors are reported on the websocket 
+	if err := erisNodeWebsocketClient.assertNoErrors(); err != nil {
+		return nil, err
+	}
+
+	// Setup the confirmation channel to be returned
+	confirmationChannel := make(chan Confirmation, 1)
+	var latestBlockHash []byte
+
+	eid := txs.EventStringAccInput(inputAddr)
+
+	// Read the incoming events
+	go func() {
+		var err error
+		for {
+			resultBytes := <- erisNodeWebsocketClient.tendermintWebsocket.ResultsCh
+			result := new(ctypes.ErisDBResult)
+			if wire.ReadJSONPtr(result, resultBytes, &err); err != nil {
+				// keep calm and carry on
+				log.Errorf(""eris-client - Failed to unmarshal json bytes for websocket event: %s"", err)
+				continue
+			}
+			
+			event, ok := (*result).(*ctypes.ResultEvent)
+			if !ok {
+				// keep calm and carry on
+				log.Error(""eris-client - Failed to cast to ResultEvent for websocket event"")
+				continue
+			}
+			
+			blockData, ok := event.Data.(txs.EventDataNewBlock)
+			if ok {
+				latestBlockHash = blockData.Block.Hash()
+				log.WithFields(log.Fields{
+					""new block"": blockData.Block,
+					""latest hash"": latestBlockHash,
+				}).Debug(""Registered new block"")
+				continue
+			}
+			
+			// we don't accept events unless they came after a new block (ie. in)
+			if latestBlockHash == nil {
+				continue
+			}
+
+			if event.Event != eid {
+				log.Warnf(""Received unsolicited event! Got %s, expected %s\n"", event.Event, eid)
+				continue
+			}
+
+			data, ok := event.Data.(txs.EventDataTx)
+			if !ok {
+				// We are on the lookout for EventDataTx
+				confirmationChannel <- Confirmation{
+					BlockHash: latestBlockHash,
+					Event: nil,
+					Exception: fmt.Errorf(""response error: expected result.Data to be *types.EventDataTx""),
+					Error: nil,
+				}
+				return
+			}
+
+			if !bytes.Equal(txs.TxHash(chainId, data.Tx), txs.TxHash(chainId, tx)) {
+				log.WithFields(log.Fields{
+					// TODO: consider re-implementing TxID again, or other more clear debug
+					""received transaction event"": txs.TxHash(chainId, data.Tx),
+				}).Debug(""Received different event"")
+				continue
+			}
+
+			if data.Exception != """" {
+				confirmationChannel <- Confirmation{
+					BlockHash: latestBlockHash,
+					Event: &data,
+					Exception: fmt.Errorf(""Transaction confirmed with exception:"", data.Exception),
+					Error: nil,
+				}
+				return
+			}
+			
+			// success, return the full event and blockhash and exit go-routine
+			confirmationChannel <- Confirmation{
+				BlockHash: latestBlockHash,
+				Event: &data,
+				Exception: nil,
+				Error: nil,
+			}
+			return
+		}
+
+	}()
+
+	// TODO: [ben] this is a draft implementation as resources on time.After can not be
+	// recovered before the timeout.  Close-down timeout at success properly.
+	timeout := time.After(time.Duration(MaxCommitWaitTimeSeconds) * time.Second)",176,2016-10-06 10:26:06,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81851024,https://github.com/hyperledger/burrow/pull/304#discussion_r81851024,benjaminbollen
https://github.com/hyperledger/burrow/pull/304,https://github.com/hyperledger/burrow/pull/304,"It s a good suggestion; there are more edge-cases so probably this whole architecture can be drafted better
",9182a76c02cd6180aa04a889d95b0475e5a107fa,2016-10-04 21:07:46,81854112,"@@ -0,0 +1,193 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package client
+
+import (
+	""bytes""
+	""fmt""
+	""time""
+
+	""github.com/tendermint/go-rpc/client""
+	""github.com/tendermint/go-wire""
+
+	log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/txs""
+	ctypes ""github.com/eris-ltd/eris-db/rpc/tendermint/core/types""
+)
+
+const (
+	MaxCommitWaitTimeSeconds = 10
+)
+
+type Confirmation struct {
+	BlockHash []byte
+	Event     txs.EventData
+	Exception error
+	Error     error
+}
+
+// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// eris-db/client.NodeClient
+var _ NodeWebsocketClient = (*ErisNodeWebsocketClient)(nil)
+
+type ErisNodeWebsocketClient struct {
+	// TODO: assert no memory leak on closing with open websocket
+	tendermintWebsocket *rpcclient.WSClient
+}
+
+// Subscribe to an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Subscribe(eventid string) error {
+	// TODO we can in the background listen to the subscription id and remember it to ease unsubscribing later.
+	return erisNodeWebsocketClient.tendermintWebsocket.Subscribe(eventid)
+}
+
+// Unsubscribe from an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Unsubscribe(subscriptionId string) error {
+	return erisNodeWebsocketClient.tendermintWebsocket.Unsubscribe(subscriptionId)
+}
+
+// Returns a channel that will receive a confirmation with a result or the exception that
+// has been confirmed; or an error is returned and the confirmation channel is nil.
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) WaitForConfirmation(tx txs.Tx, chainId string, inputAddr []byte) (chan Confirmation, error) {
+	// check no errors are reported on the websocket 
+	if err := erisNodeWebsocketClient.assertNoErrors(); err != nil {
+		return nil, err
+	}
+
+	// Setup the confirmation channel to be returned
+	confirmationChannel := make(chan Confirmation, 1)
+	var latestBlockHash []byte
+
+	eid := txs.EventStringAccInput(inputAddr)
+
+	// Read the incoming events
+	go func() {
+		var err error
+		for {
+			resultBytes := <- erisNodeWebsocketClient.tendermintWebsocket.ResultsCh
+			result := new(ctypes.ErisDBResult)
+			if wire.ReadJSONPtr(result, resultBytes, &err); err != nil {
+				// keep calm and carry on
+				log.Errorf(""eris-client - Failed to unmarshal json bytes for websocket event: %s"", err)
+				continue
+			}
+			
+			event, ok := (*result).(*ctypes.ResultEvent)
+			if !ok {
+				// keep calm and carry on
+				log.Error(""eris-client - Failed to cast to ResultEvent for websocket event"")
+				continue
+			}
+			
+			blockData, ok := event.Data.(txs.EventDataNewBlock)
+			if ok {
+				latestBlockHash = blockData.Block.Hash()
+				log.WithFields(log.Fields{
+					""new block"": blockData.Block,
+					""latest hash"": latestBlockHash,
+				}).Debug(""Registered new block"")
+				continue
+			}
+			
+			// we don't accept events unless they came after a new block (ie. in)
+			if latestBlockHash == nil {
+				continue
+			}
+
+			if event.Event != eid {
+				log.Warnf(""Received unsolicited event! Got %s, expected %s\n"", event.Event, eid)
+				continue
+			}
+
+			data, ok := event.Data.(txs.EventDataTx)
+			if !ok {
+				// We are on the lookout for EventDataTx
+				confirmationChannel <- Confirmation{
+					BlockHash: latestBlockHash,
+					Event: nil,
+					Exception: fmt.Errorf(""response error: expected result.Data to be *types.EventDataTx""),
+					Error: nil,
+				}
+				return
+			}
+
+			if !bytes.Equal(txs.TxHash(chainId, data.Tx), txs.TxHash(chainId, tx)) {
+				log.WithFields(log.Fields{
+					// TODO: consider re-implementing TxID again, or other more clear debug
+					""received transaction event"": txs.TxHash(chainId, data.Tx),
+				}).Debug(""Received different event"")
+				continue
+			}
+
+			if data.Exception != """" {
+				confirmationChannel <- Confirmation{
+					BlockHash: latestBlockHash,
+					Event: &data,
+					Exception: fmt.Errorf(""Transaction confirmed with exception:"", data.Exception),
+					Error: nil,
+				}
+				return
+			}
+			
+			// success, return the full event and blockhash and exit go-routine
+			confirmationChannel <- Confirmation{
+				BlockHash: latestBlockHash,
+				Event: &data,
+				Exception: nil,
+				Error: nil,
+			}
+			return
+		}
+
+	}()
+
+	// TODO: [ben] this is a draft implementation as resources on time.After can not be
+	// recovered before the timeout.  Close-down timeout at success properly.
+	timeout := time.After(time.Duration(MaxCommitWaitTimeSeconds) * time.Second)
+
+	go func() {
+		<- timeout",,2016-10-06 10:26:06,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81854112,https://github.com/hyperledger/burrow/pull/304#discussion_r81854112,benjaminbollen
https://github.com/hyperledger/burrow/pull/304,https://github.com/hyperledger/burrow/pull/304,"the way things are :)
",9182a76c02cd6180aa04a889d95b0475e5a107fa,2016-10-04 21:08:06,81854178,"@@ -17,13 +17,14 @@
 package keys
 
 import (
+	""fmt""
 	""encoding/hex""
 )
 
 type KeyClient interface {
 	// Sign needs to return the signature bytes for given message to sign
 	// and the address to sign it with.
-	Sign(signBytes []byte, signAddress []byte) (signature []byte, err error)
+	Sign(signBytesString string, signAddress []byte) (signature []byte, err error)",,2016-10-06 10:26:06,https://api.github.com/repos/hyperledger/burrow/pulls/comments/81854178,https://github.com/hyperledger/burrow/pull/304#discussion_r81854178,benjaminbollen
https://github.com/hyperledger/burrow/pull/304,https://github.com/hyperledger/burrow/pull/304,"Do you want to remove it or downgrade to Info?
",9182a76c02cd6180aa04a889d95b0475e5a107fa,2016-10-06 13:26:20,82187155,"@@ -0,0 +1,193 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package client
+
+import (
+	""bytes""
+	""fmt""
+	""time""
+
+	""github.com/tendermint/go-rpc/client""
+	""github.com/tendermint/go-wire""
+
+	log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/txs""
+	ctypes ""github.com/eris-ltd/eris-db/rpc/tendermint/core/types""
+)
+
+const (
+	MaxCommitWaitTimeSeconds = 10
+)
+
+type Confirmation struct {
+	BlockHash []byte
+	Event     txs.EventData
+	Exception error
+	Error     error
+}
+
+// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// eris-db/client.NodeClient
+var _ NodeWebsocketClient = (*ErisNodeWebsocketClient)(nil)
+
+type ErisNodeWebsocketClient struct {
+	// TODO: assert no memory leak on closing with open websocket
+	tendermintWebsocket *rpcclient.WSClient
+}
+
+// Subscribe to an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Subscribe(eventid string) error {
+	// TODO we can in the background listen to the subscription id and remember it to ease unsubscribing later.
+	return erisNodeWebsocketClient.tendermintWebsocket.Subscribe(eventid)
+}
+
+// Unsubscribe from an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Unsubscribe(subscriptionId string) error {
+	return erisNodeWebsocketClient.tendermintWebsocket.Unsubscribe(subscriptionId)
+}
+
+// Returns a channel that will receive a confirmation with a result or the exception that
+// has been confirmed; or an error is returned and the confirmation channel is nil.
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) WaitForConfirmation(tx txs.Tx, chainId string, inputAddr []byte) (chan Confirmation, error) {
+	// check no errors are reported on the websocket 
+	if err := erisNodeWebsocketClient.assertNoErrors(); err != nil {
+		return nil, err
+	}
+
+	// Setup the confirmation channel to be returned
+	confirmationChannel := make(chan Confirmation, 1)
+	var latestBlockHash []byte
+
+	eid := txs.EventStringAccInput(inputAddr)
+
+	// Read the incoming events
+	go func() {
+		var err error
+		for {
+			resultBytes := <- erisNodeWebsocketClient.tendermintWebsocket.ResultsCh
+			result := new(ctypes.ErisDBResult)
+			if wire.ReadJSONPtr(result, resultBytes, &err); err != nil {
+				// keep calm and carry on
+				log.Errorf(""eris-client - Failed to unmarshal json bytes for websocket event: %s"", err)
+				continue
+			}
+			
+			event, ok := (*result).(*ctypes.ResultEvent)
+			if !ok {
+				// keep calm and carry on
+				log.Error(""eris-client - Failed to cast to ResultEvent for websocket event"")",,2016-10-06 13:26:21,https://api.github.com/repos/hyperledger/burrow/pulls/comments/82187155,https://github.com/hyperledger/burrow/pull/304#discussion_r82187155,silasdavis
https://github.com/hyperledger/burrow/pull/304,https://github.com/hyperledger/burrow/pull/304,"You still might as well in-line this..
",9182a76c02cd6180aa04a889d95b0475e5a107fa,2016-10-06 13:26:58,82187290,"@@ -0,0 +1,193 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package client
+
+import (
+	""bytes""
+	""fmt""
+	""time""
+
+	""github.com/tendermint/go-rpc/client""
+	""github.com/tendermint/go-wire""
+
+	log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/txs""
+	ctypes ""github.com/eris-ltd/eris-db/rpc/tendermint/core/types""
+)
+
+const (
+	MaxCommitWaitTimeSeconds = 10
+)
+
+type Confirmation struct {
+	BlockHash []byte
+	Event     txs.EventData
+	Exception error
+	Error     error
+}
+
+// NOTE [ben] Compiler check to ensure ErisNodeClient successfully implements
+// eris-db/client.NodeClient
+var _ NodeWebsocketClient = (*ErisNodeWebsocketClient)(nil)
+
+type ErisNodeWebsocketClient struct {
+	// TODO: assert no memory leak on closing with open websocket
+	tendermintWebsocket *rpcclient.WSClient
+}
+
+// Subscribe to an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Subscribe(eventid string) error {
+	// TODO we can in the background listen to the subscription id and remember it to ease unsubscribing later.
+	return erisNodeWebsocketClient.tendermintWebsocket.Subscribe(eventid)
+}
+
+// Unsubscribe from an eventid
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) Unsubscribe(subscriptionId string) error {
+	return erisNodeWebsocketClient.tendermintWebsocket.Unsubscribe(subscriptionId)
+}
+
+// Returns a channel that will receive a confirmation with a result or the exception that
+// has been confirmed; or an error is returned and the confirmation channel is nil.
+func (erisNodeWebsocketClient *ErisNodeWebsocketClient) WaitForConfirmation(tx txs.Tx, chainId string, inputAddr []byte) (chan Confirmation, error) {
+	// check no errors are reported on the websocket 
+	if err := erisNodeWebsocketClient.assertNoErrors(); err != nil {
+		return nil, err
+	}
+
+	// Setup the confirmation channel to be returned
+	confirmationChannel := make(chan Confirmation, 1)
+	var latestBlockHash []byte
+
+	eid := txs.EventStringAccInput(inputAddr)
+
+	// Read the incoming events
+	go func() {
+		var err error
+		for {
+			resultBytes := <- erisNodeWebsocketClient.tendermintWebsocket.ResultsCh
+			result := new(ctypes.ErisDBResult)
+			if wire.ReadJSONPtr(result, resultBytes, &err); err != nil {
+				// keep calm and carry on
+				log.Errorf(""eris-client - Failed to unmarshal json bytes for websocket event: %s"", err)
+				continue
+			}
+			
+			event, ok := (*result).(*ctypes.ResultEvent)
+			if !ok {
+				// keep calm and carry on
+				log.Error(""eris-client - Failed to cast to ResultEvent for websocket event"")
+				continue
+			}
+			
+			blockData, ok := event.Data.(txs.EventDataNewBlock)
+			if ok {
+				latestBlockHash = blockData.Block.Hash()
+				log.WithFields(log.Fields{
+					""new block"": blockData.Block,
+					""latest hash"": latestBlockHash,
+				}).Debug(""Registered new block"")
+				continue
+			}
+			
+			// we don't accept events unless they came after a new block (ie. in)
+			if latestBlockHash == nil {
+				continue
+			}
+
+			if event.Event != eid {
+				log.Warnf(""Received unsolicited event! Got %s, expected %s\n"", event.Event, eid)
+				continue
+			}
+
+			data, ok := event.Data.(txs.EventDataTx)
+			if !ok {
+				// We are on the lookout for EventDataTx
+				confirmationChannel <- Confirmation{
+					BlockHash: latestBlockHash,
+					Event: nil,
+					Exception: fmt.Errorf(""response error: expected result.Data to be *types.EventDataTx""),
+					Error: nil,
+				}
+				return
+			}
+
+			if !bytes.Equal(txs.TxHash(chainId, data.Tx), txs.TxHash(chainId, tx)) {
+				log.WithFields(log.Fields{
+					// TODO: consider re-implementing TxID again, or other more clear debug
+					""received transaction event"": txs.TxHash(chainId, data.Tx),
+				}).Debug(""Received different event"")
+				continue
+			}
+
+			if data.Exception != """" {
+				confirmationChannel <- Confirmation{
+					BlockHash: latestBlockHash,
+					Event: &data,
+					Exception: fmt.Errorf(""Transaction confirmed with exception:"", data.Exception),
+					Error: nil,
+				}
+				return
+			}
+			
+			// success, return the full event and blockhash and exit go-routine
+			confirmationChannel <- Confirmation{
+				BlockHash: latestBlockHash,
+				Event: &data,
+				Exception: nil,
+				Error: nil,
+			}
+			return
+		}
+
+	}()
+
+	// TODO: [ben] this is a draft implementation as resources on time.After can not be
+	// recovered before the timeout.  Close-down timeout at success properly.
+	timeout := time.After(time.Duration(MaxCommitWaitTimeSeconds) * time.Second)",176,2016-10-06 13:26:58,https://api.github.com/repos/hyperledger/burrow/pulls/comments/82187290,https://github.com/hyperledger/burrow/pull/304#discussion_r82187290,silasdavis
https://github.com/hyperledger/burrow/pull/301,https://github.com/hyperledger/burrow/pull/301,"change to eris-db
",43ad042557cc988b0ec4d9a87dfcb35d5c5c23b5,2016-09-27 17:55:40,80754868,"@@ -0,0 +1,59 @@
+#!/usr/bin/env bash
+
+# -------------------------------------------------------------------
+# Set vars (change if used in another repo)
+
+base_name=eris-pm",,2016-09-27 18:38:09,https://api.github.com/repos/hyperledger/burrow/pulls/comments/80754868,https://github.com/hyperledger/burrow/pull/301#discussion_r80754868,compleatang
https://github.com/hyperledger/burrow/pull/301,https://github.com/hyperledger/burrow/pull/301,"change to db
",43ad042557cc988b0ec4d9a87dfcb35d5c5c23b5,2016-09-27 17:55:51,80754903,"@@ -0,0 +1,59 @@
+#!/usr/bin/env bash
+
+# -------------------------------------------------------------------
+# Set vars (change if used in another repo)
+
+base_name=eris-pm
+user_name=eris-ltd
+docs_site=monax.io
+docs_name=./docs/documentation
+slim_name=pm",,2016-09-27 18:38:09,https://api.github.com/repos/hyperledger/burrow/pulls/comments/80754903,https://github.com/hyperledger/burrow/pull/301#discussion_r80754903,compleatang
https://github.com/hyperledger/burrow/pull/301,https://github.com/hyperledger/burrow/pull/301,"you'll need to explicitly add the subcommands in here... so something like this ->

``` go
db := commands.ErisDbCmd
commands.InitErisDbCli()
commands.AddGlobalFlags()
commands.AddCommands()
```

Then give the RenderFiles function the `db` object.
",43ad042557cc988b0ec4d9a87dfcb35d5c5c23b5,2016-09-27 18:00:36,80756012,"@@ -0,0 +1,114 @@
+package main
+
+import (
+	""fmt""
+	""os""
+	""strings""
+	""text/template""
+
+	""github.com/eris-ltd/common/go/docs""
+	commands ""github.com/eris-ltd/eris-db/cmd""
+
+	""github.com/eris-ltd/eris-db/version""
+	""github.com/spf13/cobra""
+)
+
+// Repository maintainers should customize the next two lines.
+var Description = ""Blockchain Client""                                         // should match the docs site name
+var RenderDir = fmt.Sprintf(""./docs/documentation/db/%s/"", version.VERSION) // should be the ""shortversion...""
+
+// The below variables should be updated only if necessary.
+var Specs = []*docs.Entry{}
+var Examples = []*docs.Entry{}
+var SpecsDir = ""./docs/specs""
+var ExamplesDir = ""./docs/examples""
+
+type Cmd struct {
+	Command     *cobra.Command
+	Entry       *docs.Entry
+	Description string
+}
+
+func RenderFiles(cmdRaw *cobra.Command, tmpl *template.Template) error {
+	this_entry := &docs.Entry{
+		Title:          cmdRaw.CommandPath(),
+		Specifications: Specs,
+		Examples:       Examples,
+		BaseURL:        strings.Replace(RenderDir, ""."", """", 1),
+		Template:       tmpl,
+		FileName:       docs.GenerateFileName(RenderDir, cmdRaw.CommandPath()),
+	}
+
+	cmd := &Cmd{
+		Command:     cmdRaw,
+		Entry:       this_entry,
+		Description: Description,
+	}
+
+	for _, command := range cmd.Command.Commands() {
+		RenderFiles(command, tmpl)
+	}
+
+	if !cmd.Command.HasParent() {
+		entries := append(cmd.Entry.Specifications, cmd.Entry.Examples...)
+		for _, entry := range entries {
+			entry.Specifications = cmd.Entry.Specifications
+			entry.Examples = cmd.Entry.Examples
+			entry.CmdEntryPoint = cmd.Entry.Title
+			entry.BaseURL = cmd.Entry.BaseURL
+			if err := docs.RenderEntry(entry); err != nil {
+				return err
+			}
+		}
+	}
+
+	outFile, err := os.Create(cmd.Entry.FileName)
+	if err != nil {
+		return err
+	}
+	defer outFile.Close()
+
+	err = cmd.Entry.Template.Execute(outFile, cmd)
+	if err != nil {
+		return err
+	}
+
+	return nil
+}
+
+func main() {
+	// Repository maintainers should populate the top level command object.
+	// pm := commands.EPMCmd",,2016-09-27 18:38:09,https://api.github.com/repos/hyperledger/burrow/pulls/comments/80756012,https://github.com/hyperledger/burrow/pull/301#discussion_r80756012,compleatang
https://github.com/hyperledger/burrow/pull/301,https://github.com/hyperledger/burrow/pull/301,"we should refer to new `config.toml` produced by eris-cm
",43ad042557cc988b0ec4d9a87dfcb35d5c5c23b5,2016-09-27 18:13:11,80758999,"@@ -28,103 +28,27 @@ See the [eris-db documentation](https://erisindustries.com/components/erisdb/) f
 
 1. [Install go](https://golang.org/doc/install)
 2. Ensure you have `gmp` installed (`sudo apt-get install libgmp3-dev || brew install gmp`)
-3. `go get github.com/eris-ltd/eris-db/cmd/erisdb`
+3. `go get github.com/eris-ltd/eris-db/cmd/eris-db`
 
 
-To run `erisdb`, just type `$ erisdb /path/to/working/folder`
+To run `eris-db`, just type `$ eris-db serve --work-dir <path to chain directory>`
 
 This will start the node using the provided folder as working dir. If the path is omitted it defaults to `~/.erisdb` 
 
 
 ## Usage
 
-Once the server has started, it will begin syncing up with the network. At that point you may begin using it. The preferred way is through our [javascript api](https://github.com/eris-ltd/eris-db.js), but it is possible to connect directly via HTTP or websocket. The JSON-RPC and web-api reference can be found [here](api)
+Once the server has started, it will begin syncing up with the network. At that point you may begin using it. The preferred way is through our [javascript api](https://github.com/eris-ltd/eris-db.js), but it is possible to connect directly via HTTP or websocket. The JSON-RPC and web-api reference can be found [here](docs/api.md)
 
-### Configuration Files
+## Configuration
 
-Three files are currently required: 
-```
-config.toml
-genesis.json
-priv_validator.json
-```
-while `server_conf.toml` is optional
+See commented template config at [server_config.toml](server_config.toml)",38,2016-09-27 18:38:09,https://api.github.com/repos/hyperledger/burrow/pulls/comments/80758999,https://github.com/hyperledger/burrow/pull/301#discussion_r80758999,benjaminbollen
https://github.com/hyperledger/burrow/pull/301,https://github.com/hyperledger/burrow/pull/301,"Ah does it take the cobra commands ? Interesting.  I was under the false impression that golang had a tool that scrapes the comments out of the code and builds an api documentation for the whole code :)
",43ad042557cc988b0ec4d9a87dfcb35d5c5c23b5,2016-09-27 18:17:33,80759989,"@@ -0,0 +1,114 @@
+package main
+
+import (
+	""fmt""
+	""os""
+	""strings""
+	""text/template""
+
+	""github.com/eris-ltd/common/go/docs""
+	commands ""github.com/eris-ltd/eris-db/cmd""
+
+	""github.com/eris-ltd/eris-db/version""
+	""github.com/spf13/cobra""
+)
+
+// Repository maintainers should customize the next two lines.
+var Description = ""Blockchain Client""                                         // should match the docs site name
+var RenderDir = fmt.Sprintf(""./docs/documentation/db/%s/"", version.VERSION) // should be the ""shortversion...""
+
+// The below variables should be updated only if necessary.
+var Specs = []*docs.Entry{}
+var Examples = []*docs.Entry{}
+var SpecsDir = ""./docs/specs""
+var ExamplesDir = ""./docs/examples""
+
+type Cmd struct {
+	Command     *cobra.Command
+	Entry       *docs.Entry
+	Description string
+}
+
+func RenderFiles(cmdRaw *cobra.Command, tmpl *template.Template) error {
+	this_entry := &docs.Entry{
+		Title:          cmdRaw.CommandPath(),
+		Specifications: Specs,
+		Examples:       Examples,
+		BaseURL:        strings.Replace(RenderDir, ""."", """", 1),
+		Template:       tmpl,
+		FileName:       docs.GenerateFileName(RenderDir, cmdRaw.CommandPath()),
+	}
+
+	cmd := &Cmd{
+		Command:     cmdRaw,
+		Entry:       this_entry,
+		Description: Description,
+	}
+
+	for _, command := range cmd.Command.Commands() {
+		RenderFiles(command, tmpl)
+	}
+
+	if !cmd.Command.HasParent() {
+		entries := append(cmd.Entry.Specifications, cmd.Entry.Examples...)
+		for _, entry := range entries {
+			entry.Specifications = cmd.Entry.Specifications
+			entry.Examples = cmd.Entry.Examples
+			entry.CmdEntryPoint = cmd.Entry.Title
+			entry.BaseURL = cmd.Entry.BaseURL
+			if err := docs.RenderEntry(entry); err != nil {
+				return err
+			}
+		}
+	}
+
+	outFile, err := os.Create(cmd.Entry.FileName)
+	if err != nil {
+		return err
+	}
+	defer outFile.Close()
+
+	err = cmd.Entry.Template.Execute(outFile, cmd)
+	if err != nil {
+		return err
+	}
+
+	return nil
+}
+
+func main() {
+	// Repository maintainers should populate the top level command object.
+	// pm := commands.EPMCmd",,2016-09-27 18:38:09,https://api.github.com/repos/hyperledger/burrow/pulls/comments/80759989,https://github.com/hyperledger/burrow/pull/301#discussion_r80759989,benjaminbollen
https://github.com/hyperledger/burrow/pull/301,https://github.com/hyperledger/burrow/pull/301,"I want it to be something you can click straight through to with comments. To what would we be referring to here? Where/how does cm create config.toml?
",43ad042557cc988b0ec4d9a87dfcb35d5c5c23b5,2016-09-27 18:18:25,80760184,"@@ -28,103 +28,27 @@ See the [eris-db documentation](https://erisindustries.com/components/erisdb/) f
 
 1. [Install go](https://golang.org/doc/install)
 2. Ensure you have `gmp` installed (`sudo apt-get install libgmp3-dev || brew install gmp`)
-3. `go get github.com/eris-ltd/eris-db/cmd/erisdb`
+3. `go get github.com/eris-ltd/eris-db/cmd/eris-db`
 
 
-To run `erisdb`, just type `$ erisdb /path/to/working/folder`
+To run `eris-db`, just type `$ eris-db serve --work-dir <path to chain directory>`
 
 This will start the node using the provided folder as working dir. If the path is omitted it defaults to `~/.erisdb` 
 
 
 ## Usage
 
-Once the server has started, it will begin syncing up with the network. At that point you may begin using it. The preferred way is through our [javascript api](https://github.com/eris-ltd/eris-db.js), but it is possible to connect directly via HTTP or websocket. The JSON-RPC and web-api reference can be found [here](api)
+Once the server has started, it will begin syncing up with the network. At that point you may begin using it. The preferred way is through our [javascript api](https://github.com/eris-ltd/eris-db.js), but it is possible to connect directly via HTTP or websocket. The JSON-RPC and web-api reference can be found [here](docs/api.md)
 
-### Configuration Files
+## Configuration
 
-Three files are currently required: 
-```
-config.toml
-genesis.json
-priv_validator.json
-```
-while `server_conf.toml` is optional
+See commented template config at [server_config.toml](server_config.toml)",38,2016-09-27 18:38:09,https://api.github.com/repos/hyperledger/burrow/pulls/comments/80760184,https://github.com/hyperledger/burrow/pull/301#discussion_r80760184,silasdavis
https://github.com/hyperledger/burrow/pull/301,https://github.com/hyperledger/burrow/pull/301,"The template -> https://github.com/eris-ltd/common/blob/master/go/docs/docs_generator.go#L75-L123 is rendered based on cobra's Command struct.
",43ad042557cc988b0ec4d9a87dfcb35d5c5c23b5,2016-09-27 18:20:40,80760687,"@@ -0,0 +1,114 @@
+package main
+
+import (
+	""fmt""
+	""os""
+	""strings""
+	""text/template""
+
+	""github.com/eris-ltd/common/go/docs""
+	commands ""github.com/eris-ltd/eris-db/cmd""
+
+	""github.com/eris-ltd/eris-db/version""
+	""github.com/spf13/cobra""
+)
+
+// Repository maintainers should customize the next two lines.
+var Description = ""Blockchain Client""                                         // should match the docs site name
+var RenderDir = fmt.Sprintf(""./docs/documentation/db/%s/"", version.VERSION) // should be the ""shortversion...""
+
+// The below variables should be updated only if necessary.
+var Specs = []*docs.Entry{}
+var Examples = []*docs.Entry{}
+var SpecsDir = ""./docs/specs""
+var ExamplesDir = ""./docs/examples""
+
+type Cmd struct {
+	Command     *cobra.Command
+	Entry       *docs.Entry
+	Description string
+}
+
+func RenderFiles(cmdRaw *cobra.Command, tmpl *template.Template) error {
+	this_entry := &docs.Entry{
+		Title:          cmdRaw.CommandPath(),
+		Specifications: Specs,
+		Examples:       Examples,
+		BaseURL:        strings.Replace(RenderDir, ""."", """", 1),
+		Template:       tmpl,
+		FileName:       docs.GenerateFileName(RenderDir, cmdRaw.CommandPath()),
+	}
+
+	cmd := &Cmd{
+		Command:     cmdRaw,
+		Entry:       this_entry,
+		Description: Description,
+	}
+
+	for _, command := range cmd.Command.Commands() {
+		RenderFiles(command, tmpl)
+	}
+
+	if !cmd.Command.HasParent() {
+		entries := append(cmd.Entry.Specifications, cmd.Entry.Examples...)
+		for _, entry := range entries {
+			entry.Specifications = cmd.Entry.Specifications
+			entry.Examples = cmd.Entry.Examples
+			entry.CmdEntryPoint = cmd.Entry.Title
+			entry.BaseURL = cmd.Entry.BaseURL
+			if err := docs.RenderEntry(entry); err != nil {
+				return err
+			}
+		}
+	}
+
+	outFile, err := os.Create(cmd.Entry.FileName)
+	if err != nil {
+		return err
+	}
+	defer outFile.Close()
+
+	err = cmd.Entry.Template.Execute(outFile, cmd)
+	if err != nil {
+		return err
+	}
+
+	return nil
+}
+
+func main() {
+	// Repository maintainers should populate the top level command object.
+	// pm := commands.EPMCmd",,2016-09-27 18:38:09,https://api.github.com/repos/hyperledger/burrow/pulls/comments/80760687,https://github.com/hyperledger/burrow/pull/301#discussion_r80760687,compleatang
https://github.com/hyperledger/burrow/pull/301,https://github.com/hyperledger/burrow/pull/301,"https://github.com/eris-ltd/eris-cm/blob/develop/configuration/templates.go
",43ad042557cc988b0ec4d9a87dfcb35d5c5c23b5,2016-09-27 18:22:01,80761030,"@@ -28,103 +28,27 @@ See the [eris-db documentation](https://erisindustries.com/components/erisdb/) f
 
 1. [Install go](https://golang.org/doc/install)
 2. Ensure you have `gmp` installed (`sudo apt-get install libgmp3-dev || brew install gmp`)
-3. `go get github.com/eris-ltd/eris-db/cmd/erisdb`
+3. `go get github.com/eris-ltd/eris-db/cmd/eris-db`
 
 
-To run `erisdb`, just type `$ erisdb /path/to/working/folder`
+To run `eris-db`, just type `$ eris-db serve --work-dir <path to chain directory>`
 
 This will start the node using the provided folder as working dir. If the path is omitted it defaults to `~/.erisdb` 
 
 
 ## Usage
 
-Once the server has started, it will begin syncing up with the network. At that point you may begin using it. The preferred way is through our [javascript api](https://github.com/eris-ltd/eris-db.js), but it is possible to connect directly via HTTP or websocket. The JSON-RPC and web-api reference can be found [here](api)
+Once the server has started, it will begin syncing up with the network. At that point you may begin using it. The preferred way is through our [javascript api](https://github.com/eris-ltd/eris-db.js), but it is possible to connect directly via HTTP or websocket. The JSON-RPC and web-api reference can be found [here](docs/api.md)
 
-### Configuration Files
+## Configuration
 
-Three files are currently required: 
-```
-config.toml
-genesis.json
-priv_validator.json
-```
-while `server_conf.toml` is optional
+See commented template config at [server_config.toml](server_config.toml)",38,2016-09-27 18:38:09,https://api.github.com/repos/hyperledger/burrow/pulls/comments/80761030,https://github.com/hyperledger/burrow/pull/301#discussion_r80761030,compleatang
https://github.com/hyperledger/burrow/pull/297,https://github.com/hyperledger/burrow/pull/297,"not used outside of v0, no need to have this on Pipe since underlying information replicated with Peers, Listeners etc. make way for RPC unification
",1c3dad0af0ddf37f1de6d588318eea60fb0cfe4f,2016-09-23 15:49:33,80271774,"@@ -68,16 +67,6 @@ type NameReg interface {
 	Entries([]*event.FilterData) (*types.ResultListNames, error)
 }
 
-type Net interface {",12,2016-09-26 15:29:34,https://api.github.com/repos/hyperledger/burrow/pulls/comments/80271774,https://github.com/hyperledger/burrow/pull/297#discussion_r80271774,silasdavis
https://github.com/hyperledger/burrow/pull/295,https://github.com/hyperledger/burrow/pull/295,"I started out using http uri requests over go-rpc; but then I get a conflict with the prefix; currently testing at client and node side, where the rpc breaks
",7fbac989afc87af8d62dedfa6158144aecb64f80,2016-09-23 12:09:31,80231987,"@@ -81,7 +81,7 @@ func (erisNodeClient *ErisNodeClient) Broadcast(tx txs.Tx) (*txs.Receipt, error)
 // Status returns the ChainId (GenesisHash), validator's PublicKey, latest block hash
 // the block height and the latest block time.
 func (erisNodeClient *ErisNodeClient) Status() (ChainId []byte, ValidatorPublicKey []byte, LatestBlockHash []byte, LatestBlockHeight int, LatestBlockTime int64, err error) {
-	client := rpcclient.NewClientURI(erisNodeClient.broadcastRPC)
+	client := rpcclient.NewClientJSONRPC(erisNodeClient.broadcastRPC)",,2016-09-27 12:44:40,https://api.github.com/repos/hyperledger/burrow/pulls/comments/80231987,https://github.com/hyperledger/burrow/pull/295#discussion_r80231987,benjaminbollen
https://github.com/hyperledger/burrow/pull/295,https://github.com/hyperledger/burrow/pull/295,"Not sure if we want to merge this, but this is wrong
",7fbac989afc87af8d62dedfa6158144aecb64f80,2016-09-23 15:50:40,80271999,"@@ -0,0 +1,41 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package methods
+
+import (
+	log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/client""
+	""github.com/eris-ltd/eris-db/definitions""
+)
+
+func Status(do *definitions.ClientDo)  {
+	erisNodeClient := client.NewErisNodeClient(do.NodeAddrFlag)
+	chainId, validatorPublicKey, latestBlockHash, latestBlockHeight, latestBlockTime, err := erisNodeClient.Status()
+	if err == nil {",,2016-09-27 12:44:40,https://api.github.com/repos/hyperledger/burrow/pulls/comments/80271999,https://github.com/hyperledger/burrow/pull/295#discussion_r80271999,silasdavis
https://github.com/hyperledger/burrow/pull/295,https://github.com/hyperledger/burrow/pull/295,"we don't want to merge this; i put it out here to have intermediate access to the eris-client for early testing; and yes, nice catch  ;)
",7fbac989afc87af8d62dedfa6158144aecb64f80,2016-09-23 16:09:01,80275284,"@@ -0,0 +1,41 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package methods
+
+import (
+	log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/client""
+	""github.com/eris-ltd/eris-db/definitions""
+)
+
+func Status(do *definitions.ClientDo)  {
+	erisNodeClient := client.NewErisNodeClient(do.NodeAddrFlag)
+	chainId, validatorPublicKey, latestBlockHash, latestBlockHeight, latestBlockTime, err := erisNodeClient.Status()
+	if err == nil {",,2016-09-27 12:44:40,https://api.github.com/repos/hyperledger/burrow/pulls/comments/80275284,https://github.com/hyperledger/burrow/pull/295#discussion_r80275284,benjaminbollen
https://github.com/hyperledger/burrow/pull/295,https://github.com/hyperledger/burrow/pull/295,"I've updated this, but not sure how to reflect this in the Github review; maybe a bug?
",7fbac989afc87af8d62dedfa6158144aecb64f80,2016-09-27 12:45:39,80682746,"@@ -0,0 +1,41 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package methods
+
+import (
+	log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/client""
+	""github.com/eris-ltd/eris-db/definitions""
+)
+
+func Status(do *definitions.ClientDo)  {
+	erisNodeClient := client.NewErisNodeClient(do.NodeAddrFlag)
+	chainId, validatorPublicKey, latestBlockHash, latestBlockHeight, latestBlockTime, err := erisNodeClient.Status()
+	if err == nil {",,2016-09-27 12:45:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/80682746,https://github.com/hyperledger/burrow/pull/295#discussion_r80682746,benjaminbollen
https://github.com/hyperledger/burrow/pull/290,https://github.com/hyperledger/burrow/pull/290,"I'm must say I prefer `fromAddress` `toAddress`, maybe it's just me, but I always need to think more than I'd like when I see 'callerAddress' and 'calleeAddress'. It's like we are doing a 'Call', so we're a caller, but the caller is the contract we want to make do a call, and then callee is a sort  of an unusual term in everyday English. Subjective I guess. FIPF.
",fea54b159dea82b37aa07ed111c87bb812fc4bcb,2016-09-21 14:25:48,79845605,"@@ -108,16 +93,13 @@ func (erisNodeClient *ErisNodeClient) Status() (ChainId []byte, ValidatorPublicK
 }
 
 // QueryContract executes the contract code at address with the given data
-func (erisNodeClient *ErisNodeClient) QueryContract(address, data []byte) (ret []byte, gasUsed int64, err error) {
+// NOTE: there is no check on the caller; 
+func (erisNodeClient *ErisNodeClient) QueryContract(callerAddress, calleeAddress, data []byte) (ret []byte, gasUsed int64, err error) {
 	client := rpcclient.NewClientURI(erisNodeClient.broadcastRPC)
-	var callerAddress = make([]byte, len(address))
-	var calleeAddress = make([]byte, len(address))
-	copy(callerAddress, address)
-	copy(calleeAddress, address)
 	callResult, err := tendermint_client.Call(client, callerAddress, calleeAddress, data)",55,2016-09-21 14:26:01,https://api.github.com/repos/hyperledger/burrow/pulls/comments/79845605,https://github.com/hyperledger/burrow/pull/290#discussion_r79845605,silasdavis
https://github.com/hyperledger/burrow/pull/286,https://github.com/hyperledger/burrow/pull/286,"1. this needs to be tested; I do not like golang, and this is both inefficient, ugly - and probably also wrong
2. I do hope that you see the conflict I try to address here; basically we moved the two rpc's into eris-db; but I want to start opening the path to having a single (versioned) rpc - essentially deprecating /rpc/tendermint;
   therefore, I dont want to expose these internal types that will disappear (sooner, rather than later)
   -- the deep copy is very inefficient, but right now I want to keep moving forward and solve the problem at the core: reclaim our types properly.
   -- reclaiming our types currently is tricky because we depend on go-wire, and I not enough faith in my understanding of go-wire to at this point change the encoding of the types.; Instead I want to move to gRPC+protobuf (eg) then remove this all together.
",480ab113830a9018068a0a5cf91c5c34f547c9af,2016-09-18 19:48:37,79313559,"@@ -0,0 +1,45 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package core_types
+
+import (
+	""github.com/eris-ltd/eris-db/core/types""
+)
+
+// UnwrapResultDumpStorage does a deep copy to remove /rpc/tendermint/core/types
+// and expose /core/types instead.  This is largely an artefact to be removed once
+// go-wire and go-rpc are deprecated.
+// This is not an efficient code, especially given Storage can be big.
+func UnwrapResultDumpStorage(result *ResultDumpStorage) (*types.Storage) {",27,2016-09-18 20:14:41,https://api.github.com/repos/hyperledger/burrow/pulls/comments/79313559,https://github.com/hyperledger/burrow/pull/286#discussion_r79313559,benjaminbollen
https://github.com/hyperledger/burrow/pull/286,https://github.com/hyperledger/burrow/pull/286,"I'm fine with this. We are going to have to do a lot of type mappings (one-way or otherwise) so we might want to put some machinery around it. Ultimately if we are going to have our own types fed from other systems we need to create our object, particularly if they are coming from another process. So I don't see that it's so inefficient. We can replace blind mappings with more selective ones as we go.
",480ab113830a9018068a0a5cf91c5c34f547c9af,2016-09-18 22:04:27,79316082,"@@ -0,0 +1,45 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package core_types
+
+import (
+	""github.com/eris-ltd/eris-db/core/types""
+)
+
+// UnwrapResultDumpStorage does a deep copy to remove /rpc/tendermint/core/types
+// and expose /core/types instead.  This is largely an artefact to be removed once
+// go-wire and go-rpc are deprecated.
+// This is not an efficient code, especially given Storage can be big.
+func UnwrapResultDumpStorage(result *ResultDumpStorage) (*types.Storage) {",27,2016-09-18 22:04:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/79316082,https://github.com/hyperledger/burrow/pull/286#discussion_r79316082,silasdavis
https://github.com/hyperledger/burrow/pull/283,https://github.com/hyperledger/burrow/pull/283,"What happens here?
",4c3dc318dd905f95dd763832471fa375e4bd3315,2016-09-17 18:36:10,79289536,"@@ -181,7 +181,7 @@ func TestEncodeTxDecodeTx(t *testing.T) {
 	inputAddress := []byte{1, 2, 3, 4, 5}
 	outputAddress := []byte{5, 4, 3, 2, 1}
 	amount := int64(2)
-	sequence := 1
+	sequence := 3",5,2016-09-17 18:36:14,https://api.github.com/repos/hyperledger/burrow/pulls/comments/79289536,https://github.com/hyperledger/burrow/pull/283#discussion_r79289536,benjaminbollen
https://github.com/hyperledger/burrow/pull/280,https://github.com/hyperledger/burrow/pull/280,"does this affect the actual mempool? ie, it is a state-affecting action, rather than a simple read?
",bd9cee834d56d24d8f909edff32d440ee6b59ca5,2016-09-16 14:52:56,79185767,"@@ -222,6 +225,44 @@ func (tendermint *Tendermint) BroadcastTransaction(transaction []byte,
 	return tendermint.tmintNode.MempoolReactor().BroadcastTx(transaction, callback)
 }
 
+func (tendermint *Tendermint) ListUnconfirmedTxs(
+	maxTxs int) ([]txs.Tx, error) {
+	tendermintTxs := tendermint.tmintNode.MempoolReactor().Mempool.Reap(maxTxs)",23,2016-09-16 15:22:56,https://api.github.com/repos/hyperledger/burrow/pulls/comments/79185767,https://github.com/hyperledger/burrow/pull/280#discussion_r79185767,benjaminbollen
https://github.com/hyperledger/burrow/pull/280,https://github.com/hyperledger/burrow/pull/280,"As discussed, per incorrect comment in tendermint, `-1` is uncapped, all unconfirmed transactions; 0 means none.  But fix comes in next pr
",bd9cee834d56d24d8f909edff32d440ee6b59ca5,2016-09-16 15:22:27,79191713,"@@ -211,5 +209,38 @@ func (tmRoutes *TendermintRoutes) BlockchainInfo(minHeight,
 	} else {
 		return r, nil
 	}
+}
 
+func (tmRoutes *TendermintRoutes) ListUnconfirmedTxs() (ctypes.ErisDBResult, error) {
+	// Get all Txs for now
+	r, err := tmRoutes.tendermintPipe.ListUnconfirmedTxs(0)",29,2016-09-16 15:22:56,https://api.github.com/repos/hyperledger/burrow/pulls/comments/79191713,https://github.com/hyperledger/burrow/pull/280#discussion_r79191713,benjaminbollen
https://github.com/hyperledger/burrow/pull/278,https://github.com/hyperledger/burrow/pull/278,"Thanks RJ,  very nice, just one remark here: at ErisNodeClient we do not want to expose internal types (that will be under heavy change like rpc/tendermint/core/types).  So the point of these functions here is to unwrap (in this case) `rpc_types.ResultStatus`) into only fundamental types (for eris-db permissions, transactions, accounts are toplevel types; but other than that we'll prefer bytes, int etc). So I'd suggest that we even leave out NodeInfo for the time being, and re-expose that in it's own function

`Status() (ChainId []byte, ValidatorPublicKey []byte, LatestBlockHash []byte, BlockHeight uint64, LatestBlockTime int64, err error)`
",b0e4cc8a4bd9b7ede1cbeb250b28fb0244ced691,2016-09-16 10:00:01,79139819,"@@ -23,13 +23,16 @@ import (
 
 	""github.com/eris-ltd/eris-db/account""
 	tendermint_client ""github.com/eris-ltd/eris-db/rpc/tendermint/client""
+	rpc_types ""github.com/eris-ltd/eris-db/rpc/tendermint/core/types""
 	""github.com/eris-ltd/eris-db/txs""
 )
 
 type NodeClient interface {
 	Broadcast(transaction txs.Tx) (*txs.Receipt, error)
 
 	GetAccount(address []byte) (*account.Account, error)
+
+	Status() (*rpc_types.ResultStatus, error)",13,2016-09-16 10:11:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/79139819,https://github.com/hyperledger/burrow/pull/278#discussion_r79139819,benjaminbollen
https://github.com/hyperledger/burrow/pull/276,https://github.com/hyperledger/burrow/pull/276,"as discussed, maybe we can put these constants in `/util/architecture/constants.go`
",e91a077225369cd6e2f5344e39beb1612cd2d36c,2016-09-15 11:50:03,78945513,"@@ -0,0 +1,9 @@
+// +build !arm",,2016-09-15 14:45:01,https://api.github.com/repos/hyperledger/burrow/pulls/comments/78945513,https://github.com/hyperledger/burrow/pull/276#discussion_r78945513,benjaminbollen
https://github.com/hyperledger/burrow/pull/276,https://github.com/hyperledger/burrow/pull/276,"a general note, I took the custom of adding the GLPv3 header on every ""new"" file (also as a marker of what was edit during the great-reordering)
",e91a077225369cd6e2f5344e39beb1612cd2d36c,2016-09-15 11:51:08,78945660,"@@ -0,0 +1,209 @@
+package blockchain",1,2016-09-15 14:45:01,https://api.github.com/repos/hyperledger/burrow/pulls/comments/78945660,https://github.com/hyperledger/burrow/pull/276#discussion_r78945660,benjaminbollen
https://github.com/hyperledger/burrow/pull/257,https://github.com/hyperledger/burrow/pull/257,"If you're killing the shorthand name, shouldn't you be using `StringVar`. Looking at the source I see this has the same effect (https://github.com/spf13/pflag/blob/master/string.go#L50) but you intention would be clearer and you would not be exposed to a change of implementation giving you undefined behaviour if you used `StringVar`
",bff682af4b0afa9ba2b2b3532638579c50414569,2016-09-06 15:38:17,77660265,"@@ -76,13 +76,13 @@ func buildTransactionCommand() {
 		Short: ""eris-client tx call --amt <amt> --fee <fee> --gas <gas> --to <contract addr> --data <data>"",
 		Long:  ""eris-client tx call --amt <amt> --fee <fee> --gas <gas> --to <contract addr> --data <data>"",
 		Run:   func(cmd *cobra.Command, args []string) {
-			// transaction.Call(clientDo)
+			transaction.Call(clientDo)
 		},
 		PreRun: assertParameters,
 	}
 	callCmd.Flags().StringVarP(&clientDo.AmtFlag, ""amt"", ""a"", """", ""specify an amount"")
 	callCmd.Flags().StringVarP(&clientDo.ToFlag, ""to"", ""t"", """", ""specify an address to send to"")
-	callCmd.Flags().StringVarP(&clientDo.DataFlag, ""data"", ""d"", """", ""specify some data"")
+	callCmd.Flags().StringVarP(&clientDo.DataFlag, ""data"", """", """", ""specify some data"")",21,2016-09-06 15:42:52,https://api.github.com/repos/hyperledger/burrow/pulls/comments/77660265,https://github.com/hyperledger/burrow/pull/257#discussion_r77660265,silasdavis
https://github.com/hyperledger/burrow/pull/257,https://github.com/hyperledger/burrow/pull/257,"P for cobra is persistent, and the need to remove d compared to old mint-client is due to introduction of -d --debug on top level command
",bff682af4b0afa9ba2b2b3532638579c50414569,2016-09-06 18:10:23,77688548,"@@ -76,13 +76,13 @@ func buildTransactionCommand() {
 		Short: ""eris-client tx call --amt <amt> --fee <fee> --gas <gas> --to <contract addr> --data <data>"",
 		Long:  ""eris-client tx call --amt <amt> --fee <fee> --gas <gas> --to <contract addr> --data <data>"",
 		Run:   func(cmd *cobra.Command, args []string) {
-			// transaction.Call(clientDo)
+			transaction.Call(clientDo)
 		},
 		PreRun: assertParameters,
 	}
 	callCmd.Flags().StringVarP(&clientDo.AmtFlag, ""amt"", ""a"", """", ""specify an amount"")
 	callCmd.Flags().StringVarP(&clientDo.ToFlag, ""to"", ""t"", """", ""specify an address to send to"")
-	callCmd.Flags().StringVarP(&clientDo.DataFlag, ""data"", ""d"", """", ""specify some data"")
+	callCmd.Flags().StringVarP(&clientDo.DataFlag, ""data"", """", """", ""specify some data"")",21,2016-09-06 18:10:23,https://api.github.com/repos/hyperledger/burrow/pulls/comments/77688548,https://github.com/hyperledger/burrow/pull/257#discussion_r77688548,benjaminbollen
https://github.com/hyperledger/burrow/pull/257,https://github.com/hyperledger/burrow/pull/257,"OK, just saying `StringVar` is more appropriate here than `StringVarP`
",bff682af4b0afa9ba2b2b3532638579c50414569,2016-09-07 06:07:55,77764245,"@@ -76,13 +76,13 @@ func buildTransactionCommand() {
 		Short: ""eris-client tx call --amt <amt> --fee <fee> --gas <gas> --to <contract addr> --data <data>"",
 		Long:  ""eris-client tx call --amt <amt> --fee <fee> --gas <gas> --to <contract addr> --data <data>"",
 		Run:   func(cmd *cobra.Command, args []string) {
-			// transaction.Call(clientDo)
+			transaction.Call(clientDo)
 		},
 		PreRun: assertParameters,
 	}
 	callCmd.Flags().StringVarP(&clientDo.AmtFlag, ""amt"", ""a"", """", ""specify an amount"")
 	callCmd.Flags().StringVarP(&clientDo.ToFlag, ""to"", ""t"", """", ""specify an address to send to"")
-	callCmd.Flags().StringVarP(&clientDo.DataFlag, ""data"", ""d"", """", ""specify some data"")
+	callCmd.Flags().StringVarP(&clientDo.DataFlag, ""data"", """", """", ""specify some data"")",21,2016-09-07 06:07:55,https://api.github.com/repos/hyperledger/burrow/pulls/comments/77764245,https://github.com/hyperledger/burrow/pull/257#discussion_r77764245,silasdavis
https://github.com/hyperledger/burrow/pull/256,https://github.com/hyperledger/burrow/pull/256,"This module has a set of functions that each construct the correspondingly named transaction format.  Simulated call is already accessible through the RPC, we do not want to confuse that here.
",85138701520feaf043c553b921d114bcb575f194,2016-09-05 22:18:30,77557619,"@@ -69,50 +69,74 @@ func Send(nodeAddr, signAddr, pubkey, addr, toAddr, amtS, nonceS string) (*txs.S
 	return tx, nil
 }
 
-// func Call(nodeAddr, signAddr, pubkey, addr, toAddr, amtS, nonceS, gasS, feeS, data string) (*txs.CallTx, error) {
-// 	pub, amt, nonce, err := checkCommon(nodeAddr, signAddr, pubkey, addr, amtS, nonceS)
-// 	if err != nil {
-// 		return nil, err
-// 	}
+func Call(nodeAddr, signAddr, pubkey, addr, toAddr, amtS, nonceS, gasS, feeS, data string) (*txs.CallTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeAddr, signAddr, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
 
-// 	toAddrBytes, err := hex.DecodeString(toAddr)
-// 	if err != nil {
-// 		return nil, fmt.Errorf(""toAddr is bad hex: %v"", err)
-// 	}
+	toAddrBytes, err := hex.DecodeString(toAddr)
+	if err != nil {
+		return nil, fmt.Errorf(""toAddr is bad hex: %v"", err)
+	}
 
-// 	fee, err := strconv.ParseInt(feeS, 10, 64)
-// 	if err != nil {
-// 		return nil, fmt.Errorf(""fee is misformatted: %v"", err)
-// 	}
+	fee, err := strconv.ParseInt(feeS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""fee is misformatted: %v"", err)
+	}
 
-// 	gas, err := strconv.ParseInt(gasS, 10, 64)
-// 	if err != nil {
-// 		return nil, fmt.Errorf(""gas is misformatted: %v"", err)
-// 	}
+	gas, err := strconv.ParseInt(gasS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""gas is misformatted: %v"", err)
+	}
 
-// 	dataBytes, err := hex.DecodeString(data)
-// 	if err != nil {
-// 		return nil, fmt.Errorf(""data is bad hex: %v"", err)
-// 	}
+	dataBytes, err := hex.DecodeString(data)
+	if err != nil {
+		return nil, fmt.Errorf(""data is bad hex: %v"", err)
+	}
 
-// 	tx := types.NewCallTxWithNonce(pub, toAddrBytes, dataBytes, amt, gas, fee, int(nonce))
-// 	return tx, nil
-// }
+	tx := txs.NewCallTxWithNonce(pub, toAddrBytes, dataBytes, amt, gas, fee, int(nonce))
+	return tx, nil
+}
 
-// func Name(nodeAddr, signAddr, pubkey, addr, amtS, nonceS, feeS, name, data string) (*txs.NameTx, error) {",67,2016-09-05 22:18:31,https://api.github.com/repos/hyperledger/burrow/pulls/comments/77557619,https://github.com/hyperledger/burrow/pull/256#discussion_r77557619,benjaminbollen
https://github.com/hyperledger/burrow/pull/256,https://github.com/hyperledger/burrow/pull/256,"yeah I messed that up here between all my git checkouts. 
",85138701520feaf043c553b921d114bcb575f194,2016-09-05 22:30:51,77557941,"@@ -69,50 +69,74 @@ func Send(nodeAddr, signAddr, pubkey, addr, toAddr, amtS, nonceS string) (*txs.S
 	return tx, nil
 }
 
-// func Call(nodeAddr, signAddr, pubkey, addr, toAddr, amtS, nonceS, gasS, feeS, data string) (*txs.CallTx, error) {
-// 	pub, amt, nonce, err := checkCommon(nodeAddr, signAddr, pubkey, addr, amtS, nonceS)
-// 	if err != nil {
-// 		return nil, err
-// 	}
+func Call(nodeAddr, signAddr, pubkey, addr, toAddr, amtS, nonceS, gasS, feeS, data string) (*txs.CallTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeAddr, signAddr, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
 
-// 	toAddrBytes, err := hex.DecodeString(toAddr)
-// 	if err != nil {
-// 		return nil, fmt.Errorf(""toAddr is bad hex: %v"", err)
-// 	}
+	toAddrBytes, err := hex.DecodeString(toAddr)
+	if err != nil {
+		return nil, fmt.Errorf(""toAddr is bad hex: %v"", err)
+	}
 
-// 	fee, err := strconv.ParseInt(feeS, 10, 64)
-// 	if err != nil {
-// 		return nil, fmt.Errorf(""fee is misformatted: %v"", err)
-// 	}
+	fee, err := strconv.ParseInt(feeS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""fee is misformatted: %v"", err)
+	}
 
-// 	gas, err := strconv.ParseInt(gasS, 10, 64)
-// 	if err != nil {
-// 		return nil, fmt.Errorf(""gas is misformatted: %v"", err)
-// 	}
+	gas, err := strconv.ParseInt(gasS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""gas is misformatted: %v"", err)
+	}
 
-// 	dataBytes, err := hex.DecodeString(data)
-// 	if err != nil {
-// 		return nil, fmt.Errorf(""data is bad hex: %v"", err)
-// 	}
+	dataBytes, err := hex.DecodeString(data)
+	if err != nil {
+		return nil, fmt.Errorf(""data is bad hex: %v"", err)
+	}
 
-// 	tx := types.NewCallTxWithNonce(pub, toAddrBytes, dataBytes, amt, gas, fee, int(nonce))
-// 	return tx, nil
-// }
+	tx := txs.NewCallTxWithNonce(pub, toAddrBytes, dataBytes, amt, gas, fee, int(nonce))
+	return tx, nil
+}
 
-// func Name(nodeAddr, signAddr, pubkey, addr, amtS, nonceS, feeS, name, data string) (*txs.NameTx, error) {",67,2016-09-05 22:30:51,https://api.github.com/repos/hyperledger/burrow/pulls/comments/77557941,https://github.com/hyperledger/burrow/pull/256#discussion_r77557941,VoR0220
https://github.com/hyperledger/burrow/pull/256,https://github.com/hyperledger/burrow/pull/256,"How do I access Simulated Call through the RPC? 
",85138701520feaf043c553b921d114bcb575f194,2016-09-05 22:31:16,77557951,"@@ -69,50 +69,74 @@ func Send(nodeAddr, signAddr, pubkey, addr, toAddr, amtS, nonceS string) (*txs.S
 	return tx, nil
 }
 
-// func Call(nodeAddr, signAddr, pubkey, addr, toAddr, amtS, nonceS, gasS, feeS, data string) (*txs.CallTx, error) {
-// 	pub, amt, nonce, err := checkCommon(nodeAddr, signAddr, pubkey, addr, amtS, nonceS)
-// 	if err != nil {
-// 		return nil, err
-// 	}
+func Call(nodeAddr, signAddr, pubkey, addr, toAddr, amtS, nonceS, gasS, feeS, data string) (*txs.CallTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeAddr, signAddr, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
 
-// 	toAddrBytes, err := hex.DecodeString(toAddr)
-// 	if err != nil {
-// 		return nil, fmt.Errorf(""toAddr is bad hex: %v"", err)
-// 	}
+	toAddrBytes, err := hex.DecodeString(toAddr)
+	if err != nil {
+		return nil, fmt.Errorf(""toAddr is bad hex: %v"", err)
+	}
 
-// 	fee, err := strconv.ParseInt(feeS, 10, 64)
-// 	if err != nil {
-// 		return nil, fmt.Errorf(""fee is misformatted: %v"", err)
-// 	}
+	fee, err := strconv.ParseInt(feeS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""fee is misformatted: %v"", err)
+	}
 
-// 	gas, err := strconv.ParseInt(gasS, 10, 64)
-// 	if err != nil {
-// 		return nil, fmt.Errorf(""gas is misformatted: %v"", err)
-// 	}
+	gas, err := strconv.ParseInt(gasS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""gas is misformatted: %v"", err)
+	}
 
-// 	dataBytes, err := hex.DecodeString(data)
-// 	if err != nil {
-// 		return nil, fmt.Errorf(""data is bad hex: %v"", err)
-// 	}
+	dataBytes, err := hex.DecodeString(data)
+	if err != nil {
+		return nil, fmt.Errorf(""data is bad hex: %v"", err)
+	}
 
-// 	tx := types.NewCallTxWithNonce(pub, toAddrBytes, dataBytes, amt, gas, fee, int(nonce))
-// 	return tx, nil
-// }
+	tx := txs.NewCallTxWithNonce(pub, toAddrBytes, dataBytes, amt, gas, fee, int(nonce))
+	return tx, nil
+}
 
-// func Name(nodeAddr, signAddr, pubkey, addr, amtS, nonceS, feeS, name, data string) (*txs.NameTx, error) {",67,2016-09-05 22:31:16,https://api.github.com/repos/hyperledger/burrow/pulls/comments/77557951,https://github.com/hyperledger/burrow/pull/256#discussion_r77557951,VoR0220
https://github.com/hyperledger/burrow/pull/250,https://github.com/hyperledger/burrow/pull/250,"dupe of L11/L47

``` diff
+# install eris-db's dependencies
-# fetch and install eris-db and its dependencies
+# install eris-db
```
",130023a772c2eca7c9c9b38a3844d7b16cc13390,2016-09-01 00:41:23,77098453,"@@ -8,25 +8,20 @@ EXPOSE 46656
 EXPOSE 46657
 
 #-----------------------------------------------------------------------------
-# install eris-db
+# install eris-db's dependencies
 
 # set the source code path and copy the repository in
 ENV ERIS_DB_SRC_PATH $GOPATH/src/github.com/eris-ltd/eris-db
-COPY . $ERIS_DB_SRC_PATH
+ADD glide.yaml $ERIS_DB_SRC_PATH/
+ADD glide.lock $ERIS_DB_SRC_PATH/
+# [csk] if we vendor the dependencies we should import them b4 the glide install, no?
 
 # fetch and install eris-db and its dependencies",,2016-09-01 01:00:48,https://api.github.com/repos/hyperledger/burrow/pulls/comments/77098453,https://github.com/hyperledger/burrow/pull/250#discussion_r77098453,therealplato
https://github.com/hyperledger/burrow/pull/250,https://github.com/hyperledger/burrow/pull/250,"good catch! thanks.
",130023a772c2eca7c9c9b38a3844d7b16cc13390,2016-09-01 01:01:35,77099854,"@@ -8,25 +8,20 @@ EXPOSE 46656
 EXPOSE 46657
 
 #-----------------------------------------------------------------------------
-# install eris-db
+# install eris-db's dependencies
 
 # set the source code path and copy the repository in
 ENV ERIS_DB_SRC_PATH $GOPATH/src/github.com/eris-ltd/eris-db
-COPY . $ERIS_DB_SRC_PATH
+ADD glide.yaml $ERIS_DB_SRC_PATH/
+ADD glide.lock $ERIS_DB_SRC_PATH/
+# [csk] if we vendor the dependencies we should import them b4 the glide install, no?
 
 # fetch and install eris-db and its dependencies",,2016-09-01 01:01:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/77099854,https://github.com/hyperledger/burrow/pull/250#discussion_r77099854,compleatang
https://github.com/hyperledger/burrow/pull/247,https://github.com/hyperledger/burrow/pull/247,"Not entirely correct. See here. https://github.com/ethereum/go-ethereum/blob/b7e3dfc5a2bc7e2f4d653fbe0ec9774277a10643/core/execution.go#L41
",167d1a6462018d1f525c6cbd600be7205d461ab4,2016-08-28 23:57:37,76542025,"@@ -147,6 +147,32 @@ func (vm *VM) Call(caller, callee *Account, code, input []byte, value int64, gas
 	return
 }
 
+
+// [This implementation is up for review].
+// DelegateCall is executed by the DELEGATECALL opcode, introduced as off Ethereum Homestead.
+// The intent of delegate call is to run the code of the callee in the storage context of the caller;
+// while preserving the original caller to the previous callee.
+// [ -->] Different to the normal CALL or CALLCODE, the value does not need to be transferred to the callee. [<-- CORRECT?]",,2016-09-07 10:09:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/76542025,https://github.com/hyperledger/burrow/pull/247#discussion_r76542025,VoR0220
https://github.com/hyperledger/burrow/pull/247,https://github.com/hyperledger/burrow/pull/247,"@pietv can you review whether for this PR to merge into master we want `VERSION=""0.12.0-rc2` or simply `VERSION=0.12.0` (rc labelling still has me confused)
",167d1a6462018d1f525c6cbd600be7205d461ab4,2016-09-06 13:57:50,77639218,"@@ -19,4 +19,4 @@ package version
 const TENDERMINT_VERSION = ""0.5.0""
 // IMPORTANT: Eris-DB version must be on the last line of this file for
 // the deployment script DOCKER/build.sh to pick up the right label.
-const VERSION = ""0.12.0""
+const VERSION = ""0.12.0-rc2""",,2016-09-07 10:09:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/77639218,https://github.com/hyperledger/burrow/pull/247#discussion_r77639218,benjaminbollen
https://github.com/hyperledger/burrow/pull/247,https://github.com/hyperledger/burrow/pull/247,"@benjaminbollen it's ""0.12.0"" for #master. without rc.
",167d1a6462018d1f525c6cbd600be7205d461ab4,2016-09-06 14:02:55,77640215,"@@ -19,4 +19,4 @@ package version
 const TENDERMINT_VERSION = ""0.5.0""
 // IMPORTANT: Eris-DB version must be on the last line of this file for
 // the deployment script DOCKER/build.sh to pick up the right label.
-const VERSION = ""0.12.0""
+const VERSION = ""0.12.0-rc2""",,2016-09-07 10:09:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/77640215,https://github.com/hyperledger/burrow/pull/247#discussion_r77640215,pietv
https://github.com/hyperledger/burrow/pull/247,https://github.com/hyperledger/burrow/pull/247,"Just change these notes here please @benjaminbollen then it should be ready to merge. 
",167d1a6462018d1f525c6cbd600be7205d461ab4,2016-09-06 16:47:00,77673066,"@@ -147,6 +147,32 @@ func (vm *VM) Call(caller, callee *Account, code, input []byte, value int64, gas
 	return
 }
 
+
+// [This implementation is up for review].
+// DelegateCall is executed by the DELEGATECALL opcode, introduced as off Ethereum Homestead.
+// The intent of delegate call is to run the code of the callee in the storage context of the caller;
+// while preserving the original caller to the previous callee.
+// [ -->] Different to the normal CALL or CALLCODE, the value does not need to be transferred to the callee. [<-- CORRECT?]",,2016-09-07 10:09:17,https://api.github.com/repos/hyperledger/burrow/pulls/comments/77673066,https://github.com/hyperledger/burrow/pull/247#discussion_r77673066,VoR0220
https://github.com/hyperledger/burrow/pull/247,https://github.com/hyperledger/burrow/pull/247,"done
",167d1a6462018d1f525c6cbd600be7205d461ab4,2016-09-07 10:12:55,77795147,"@@ -147,6 +147,32 @@ func (vm *VM) Call(caller, callee *Account, code, input []byte, value int64, gas
 	return
 }
 
+
+// [This implementation is up for review].
+// DelegateCall is executed by the DELEGATECALL opcode, introduced as off Ethereum Homestead.
+// The intent of delegate call is to run the code of the callee in the storage context of the caller;
+// while preserving the original caller to the previous callee.
+// [ -->] Different to the normal CALL or CALLCODE, the value does not need to be transferred to the callee. [<-- CORRECT?]",,2016-09-07 10:12:55,https://api.github.com/repos/hyperledger/burrow/pulls/comments/77795147,https://github.com/hyperledger/burrow/pull/247#discussion_r77795147,benjaminbollen
https://github.com/hyperledger/burrow/pull/247,https://github.com/hyperledger/burrow/pull/247,"We keeping this as todo?
",167d1a6462018d1f525c6cbd600be7205d461ab4,2016-09-07 10:24:43,77796604,"@@ -745,12 +769,21 @@ func (vm *VM) call(caller, callee *Account, code, input []byte, value int64, gas
 				stack.Push(newAccount.Address)
 			}
 
-		case CALL, CALLCODE: // 0xF1, 0xF2
+		case CALL, CALLCODE, DELEGATECALL: // 0xF1, 0xF2, 0xF4
 			if !HasPermission(vm.appState, callee, ptypes.Call) {
 				return nil, ErrPermission{""call""}
 			}
 			gasLimit := stack.Pop64()
-			addr, value := stack.Pop(), stack.Pop64()
+			addr := stack.Pop()
+			// NOTE: for DELEGATECALL value is preserved from the original
+			// caller, as such it is not stored on stack for the address
+			// to be called; for CALL and CALLCODE value is stored on stack
+			// and needs to be overwritten from the given value.
+			// TODO: [ben] assert that malicious code cannot produce",47,2016-09-07 10:24:43,https://api.github.com/repos/hyperledger/burrow/pulls/comments/77796604,https://github.com/hyperledger/burrow/pull/247#discussion_r77796604,silasdavis
https://github.com/hyperledger/burrow/pull/247,https://github.com/hyperledger/burrow/pull/247,"It is arguably redundant as value cannot be passed to another contract if it did not exist; and value is atomically swapped.  However, should a contract rely on `CALLVALUE` Im at this point not confident it would not be possible to produce bytecode that would put a malignent value on the stack and as such provide a hidden way to corrupt seemingly valid solidity.
",167d1a6462018d1f525c6cbd600be7205d461ab4,2016-09-07 10:34:59,77797849,"@@ -745,12 +769,21 @@ func (vm *VM) call(caller, callee *Account, code, input []byte, value int64, gas
 				stack.Push(newAccount.Address)
 			}
 
-		case CALL, CALLCODE: // 0xF1, 0xF2
+		case CALL, CALLCODE, DELEGATECALL: // 0xF1, 0xF2, 0xF4
 			if !HasPermission(vm.appState, callee, ptypes.Call) {
 				return nil, ErrPermission{""call""}
 			}
 			gasLimit := stack.Pop64()
-			addr, value := stack.Pop(), stack.Pop64()
+			addr := stack.Pop()
+			// NOTE: for DELEGATECALL value is preserved from the original
+			// caller, as such it is not stored on stack for the address
+			// to be called; for CALL and CALLCODE value is stored on stack
+			// and needs to be overwritten from the given value.
+			// TODO: [ben] assert that malicious code cannot produce",47,2016-09-07 10:34:59,https://api.github.com/repos/hyperledger/burrow/pulls/comments/77797849,https://github.com/hyperledger/burrow/pull/247#discussion_r77797849,benjaminbollen
https://github.com/hyperledger/burrow/pull/247,https://github.com/hyperledger/burrow/pull/247,"I found this a bit hard to parse, having read it a few times over. Here is a proposed rewording for clarity, but happy to see an even better version if this doesn't convey proper meaning:

```
            // NOTE: for DELEGATECALL value is preserved from the original
            // caller, as such it is not stored on stack for as an argument for
            // DELEGATECALL and should not be popped. Instead the previous
            // caller value is use.
            // for CALL and CALLCODE value is stored on stack
            // and needs to overwrite the original caller value.
```
",167d1a6462018d1f525c6cbd600be7205d461ab4,2016-09-07 10:39:27,77798383,"@@ -745,12 +769,21 @@ func (vm *VM) call(caller, callee *Account, code, input []byte, value int64, gas
 				stack.Push(newAccount.Address)
 			}
 
-		case CALL, CALLCODE: // 0xF1, 0xF2
+		case CALL, CALLCODE, DELEGATECALL: // 0xF1, 0xF2, 0xF4
 			if !HasPermission(vm.appState, callee, ptypes.Call) {
 				return nil, ErrPermission{""call""}
 			}
 			gasLimit := stack.Pop64()
-			addr, value := stack.Pop(), stack.Pop64()
+			addr := stack.Pop()
+			// NOTE: for DELEGATECALL value is preserved from the original
+			// caller, as such it is not stored on stack for the address
+			// to be called; for CALL and CALLCODE value is stored on stack
+			// and needs to be overwritten from the given value.",46,2016-09-07 10:41:54,https://api.github.com/repos/hyperledger/burrow/pulls/comments/77798383,https://github.com/hyperledger/burrow/pull/247#discussion_r77798383,silasdavis
https://github.com/hyperledger/burrow/pull/247,https://github.com/hyperledger/burrow/pull/247,"I was making these changes on develop; ok to just take the new comment on 0.12 develop? And leave it for hotfix here as is?
",167d1a6462018d1f525c6cbd600be7205d461ab4,2016-09-07 10:42:30,77798717,"@@ -745,12 +769,21 @@ func (vm *VM) call(caller, callee *Account, code, input []byte, value int64, gas
 				stack.Push(newAccount.Address)
 			}
 
-		case CALL, CALLCODE: // 0xF1, 0xF2
+		case CALL, CALLCODE, DELEGATECALL: // 0xF1, 0xF2, 0xF4
 			if !HasPermission(vm.appState, callee, ptypes.Call) {
 				return nil, ErrPermission{""call""}
 			}
 			gasLimit := stack.Pop64()
-			addr, value := stack.Pop(), stack.Pop64()
+			addr := stack.Pop()
+			// NOTE: for DELEGATECALL value is preserved from the original
+			// caller, as such it is not stored on stack for the address
+			// to be called; for CALL and CALLCODE value is stored on stack
+			// and needs to be overwritten from the given value.",46,2016-09-07 10:42:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/77798717,https://github.com/hyperledger/burrow/pull/247#discussion_r77798717,benjaminbollen
https://github.com/hyperledger/burrow/pull/242,https://github.com/hyperledger/burrow/pull/242,"very nice !
",4eafa72349a533398abeef5ede7949f1d8ea3378,2016-08-29 08:54:29,76574026,"@@ -41,7 +41,11 @@ test:
     - cd $GOPATH_REPO && go install ./cmd/eris-db
   override:
     # We only wish to test our packages not vendored ones
+    - echo ""Running unit tests...""
     - cd $GOPATH_REPO && glide novendor | xargs go test -v
+    - echo ""Running integration tests...""
+    - cd $GOPATH_REPO && glide novendor | xargs go test -v -tags integration",7,2016-08-29 08:54:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/76574026,https://github.com/hyperledger/burrow/pull/242#discussion_r76574026,benjaminbollen
https://github.com/hyperledger/burrow/pull/240,https://github.com/hyperledger/burrow/pull/240,"What about version 256...?
",0c1a3736ead0040807bad225b93338ad1ffda935,2016-08-23 15:34:11,75891645,"@@ -17,21 +17,62 @@
 package tendermint
 
 import (
+	""strconv""
+
+	tendermint_version ""github.com/tendermint/tendermint/version""
+
 	version ""github.com/eris-ltd/eris-db/version""
 )
 
 const (
 	// Client identifier to advertise over the network
 	tendermintClientIdentifier = ""tendermint""
 	// Major version component of the current release
-	tendermintVersionMajor = 0
+	tendermintVersionMajorConst uint8 = 0
 	// Minor version component of the current release
-	tendermintVersionMinor = 6
+	tendermintVersionMinorConst uint8 = 6
 	// Patch version component of the current release
-	tendermintVersionPatch = 0
+	tendermintVersionPatchConst uint8 = 0
+)
+
+var (
+	tendermintVersionMajor uint8",26,2016-08-23 15:34:11,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75891645,https://github.com/hyperledger/burrow/pull/240#discussion_r75891645,silasdavis
https://github.com/hyperledger/burrow/pull/237,https://github.com/hyperledger/burrow/pull/237,"I dislike golang for allowing this.
",2dcfd037d1e064163c53433078ff8c0593976808,2016-08-22 17:19:42,75719225,"@@ -158,7 +159,7 @@ func mapAndValues(orderedKeyVals ...interface{}) (map[string]interface{},
 		}
 		val := orderedKeyVals[i+1]
 		paramsMap[key] = val
-		paramsSlice = append(paramsSlice, val)
+		paramsSlice[i/2] = val",13,2016-08-22 17:19:42,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75719225,https://github.com/hyperledger/burrow/pull/237#discussion_r75719225,benjaminbollen
https://github.com/hyperledger/burrow/pull/237,https://github.com/hyperledger/burrow/pull/237,"Rather I should say, I'd prefer we multiply *2 in line 154; over dividing here; but fine :)
",2dcfd037d1e064163c53433078ff8c0593976808,2016-08-22 17:23:12,75719856,"@@ -158,7 +159,7 @@ func mapAndValues(orderedKeyVals ...interface{}) (map[string]interface{},
 		}
 		val := orderedKeyVals[i+1]
 		paramsMap[key] = val
-		paramsSlice = append(paramsSlice, val)
+		paramsSlice[i/2] = val",13,2016-08-22 17:23:12,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75719856,https://github.com/hyperledger/burrow/pull/237#discussion_r75719856,benjaminbollen
https://github.com/hyperledger/burrow/pull/235,https://github.com/hyperledger/burrow/pull/235,"Is this being run? as it is not exported?
",f632852bb6e032292b9cbadb427b03c807ddb018,2016-08-23 10:04:53,75836496,"@@ -251,7 +253,59 @@ func asEventDataTx(t *testing.T, eventData txs.EventData) txs.EventDataTx {
 	return eventDataTx
 }
 
-func doNothing(eventId string, eventData txs.EventData) (bool, error) {
+func doNothing(_ string, _ txs.EventData) (bool, error) {
 	// And ask waitForEvent to stop waiting
 	return true, nil
 }
+
+func testSubscribe(t *testing.T) {",41,2016-08-23 10:04:53,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75836496,https://github.com/hyperledger/burrow/pull/235#discussion_r75836496,benjaminbollen
https://github.com/hyperledger/burrow/pull/235,https://github.com/hyperledger/burrow/pull/235,"Note this is not a *_test.go file.

It's following the same pattern as other methods in here, it's the testing method that the real one in https://github.com/silasdavis/eris-db/blob/f632852bb6e032292b9cbadb427b03c807ddb018/rpc/tendermint/test/client_ws_test.go#L241 calls.

Aside from following that pattern, the main reason I have it here is because go-wire doesn't work from *_test.go files it would seem. Something to do with the global var interface registration.
",f632852bb6e032292b9cbadb427b03c807ddb018,2016-08-23 10:13:50,75837795,"@@ -251,7 +253,59 @@ func asEventDataTx(t *testing.T, eventData txs.EventData) txs.EventDataTx {
 	return eventDataTx
 }
 
-func doNothing(eventId string, eventData txs.EventData) (bool, error) {
+func doNothing(_ string, _ txs.EventData) (bool, error) {
 	// And ask waitForEvent to stop waiting
 	return true, nil
 }
+
+func testSubscribe(t *testing.T) {",41,2016-08-23 10:14:09,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75837795,https://github.com/hyperledger/burrow/pull/235#discussion_r75837795,silasdavis
https://github.com/hyperledger/burrow/pull/235,https://github.com/hyperledger/burrow/pull/235,"Oh actually since I factored out `readResult`. I could probably get away with having it in client_ws_test.go. Still I'm fairly happy having it here since all the tests in client_ws_test.go are proxy functions to ones here. Mind you they need to be to centralise the HTTP/JSON logic.
",f632852bb6e032292b9cbadb427b03c807ddb018,2016-08-23 10:16:30,75838130,"@@ -251,7 +253,59 @@ func asEventDataTx(t *testing.T, eventData txs.EventData) txs.EventDataTx {
 	return eventDataTx
 }
 
-func doNothing(eventId string, eventData txs.EventData) (bool, error) {
+func doNothing(_ string, _ txs.EventData) (bool, error) {
 	// And ask waitForEvent to stop waiting
 	return true, nil
 }
+
+func testSubscribe(t *testing.T) {",41,2016-08-23 10:16:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75838130,https://github.com/hyperledger/burrow/pull/235#discussion_r75838130,silasdavis
https://github.com/hyperledger/burrow/pull/235,https://github.com/hyperledger/burrow/pull/235,"Points taken onboard.
",f632852bb6e032292b9cbadb427b03c807ddb018,2016-08-23 10:17:49,75838307,"@@ -251,7 +253,59 @@ func asEventDataTx(t *testing.T, eventData txs.EventData) txs.EventDataTx {
 	return eventDataTx
 }
 
-func doNothing(eventId string, eventData txs.EventData) (bool, error) {
+func doNothing(_ string, _ txs.EventData) (bool, error) {
 	// And ask waitForEvent to stop waiting
 	return true, nil
 }
+
+func testSubscribe(t *testing.T) {",41,2016-08-23 10:17:49,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75838307,https://github.com/hyperledger/burrow/pull/235#discussion_r75838307,benjaminbollen
https://github.com/hyperledger/burrow/pull/232,https://github.com/hyperledger/burrow/pull/232,"These panics should not be panics, rather errors.  I can see why you use a panic here; but I would only want to move back to panics here, if we had asserted coverage of all calls to `mapAndValues` in the CI; right now this relies on our continued vigilance.
",85e17c4ae62329afebbfb190a775ae462973b10e,2016-08-22 10:51:49,75656429,"@@ -159,36 +94,68 @@ func CallCode(client rpcclient.Client,
 
 func Call(client rpcclient.Client, fromAddress, toAddress,
 	data []byte) (*rpc_types.ResultCall, error) {
-	var res rpc_types.ErisDBResult
-	var err error
-	switch cli := client.(type) {
-	case *rpcclient.ClientJSONRPC:
-		_, err = cli.Call(""call"", []interface{}{fromAddress, toAddress, data}, &res)
-	case *rpcclient.ClientURI:
-		_, err = cli.Call(""call"", map[string]interface{}{
-			""fromAddress"": fromAddress,
-			""toAddress"":   toAddress,
-			""data"":        data,
-		}, &res)
-
-	}
+	res, err := performCall(client, ""call"",
+		""fromAddress"", fromAddress,
+		""toAddress"", toAddress,
+		""data"", data)
 	if err != nil {
 		return nil, err
 	}
 	return res.(*rpc_types.ResultCall), err
 }
 
 func GetName(client rpcclient.Client, name string) (*core_types.NameRegEntry, error) {
-	var res rpc_types.ErisDBResult
-	var err error
-	switch cli := client.(type) {
-	case *rpcclient.ClientJSONRPC:
-		_, err = cli.Call(""get_name"", []interface{}{name}, &res)
-	case *rpcclient.ClientURI:
-		_, err = cli.Call(""get_name"", map[string]interface{}{""name"": name}, &res)
-	}
+	res, err := performCall(client, ""get_name"",
+		""name"", name)
 	if err != nil {
 		return nil, err
 	}
 	return res.(*rpc_types.ResultGetName).Entry, nil
 }
+
+func BlockchainInfo(client rpcclient.Client, minHeight,
+	maxHeight int) (*rpc_types.ResultBlockchainInfo, error) {
+	res, err := performCall(client, ""blockchain"",
+		""minHeight"", minHeight,
+		""maxHeight"", maxHeight)
+	if err != nil {
+		return nil, err
+	}
+	return res.(*rpc_types.ResultBlockchainInfo), err
+}
+
+func performCall(client rpcclient.Client, method string,
+	paramKeyVals ...interface{}) (res rpc_types.ErisDBResult, err error) {
+	paramsMap, paramsSlice := mapAndValues(paramKeyVals...)
+	switch cli := client.(type) {
+	case *rpcclient.ClientJSONRPC:
+		_, err = cli.Call(method, paramsSlice, &res)
+	case *rpcclient.ClientURI:
+		_, err = cli.Call(method, paramsMap, &res)
+	}
+	return res, err
+
+}
+func mapAndValues(orderedKeyVals ...interface{}) (map[string]interface{}, []interface{}) {
+	if len(orderedKeyVals)%2 != 0 {
+		panic(fmt.Sprintf(""mapAndValues requires a even length list of keys and ""+",,2016-08-22 11:52:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75656429,https://github.com/hyperledger/burrow/pull/232#discussion_r75656429,benjaminbollen
https://github.com/hyperledger/burrow/pull/232,https://github.com/hyperledger/burrow/pull/232,"Yeah I guess I could have just let it panic array out of bounds, so I saw this as making the panic nicer. But I agree.
",85e17c4ae62329afebbfb190a775ae462973b10e,2016-08-22 11:21:21,75659830,"@@ -159,36 +94,68 @@ func CallCode(client rpcclient.Client,
 
 func Call(client rpcclient.Client, fromAddress, toAddress,
 	data []byte) (*rpc_types.ResultCall, error) {
-	var res rpc_types.ErisDBResult
-	var err error
-	switch cli := client.(type) {
-	case *rpcclient.ClientJSONRPC:
-		_, err = cli.Call(""call"", []interface{}{fromAddress, toAddress, data}, &res)
-	case *rpcclient.ClientURI:
-		_, err = cli.Call(""call"", map[string]interface{}{
-			""fromAddress"": fromAddress,
-			""toAddress"":   toAddress,
-			""data"":        data,
-		}, &res)
-
-	}
+	res, err := performCall(client, ""call"",
+		""fromAddress"", fromAddress,
+		""toAddress"", toAddress,
+		""data"", data)
 	if err != nil {
 		return nil, err
 	}
 	return res.(*rpc_types.ResultCall), err
 }
 
 func GetName(client rpcclient.Client, name string) (*core_types.NameRegEntry, error) {
-	var res rpc_types.ErisDBResult
-	var err error
-	switch cli := client.(type) {
-	case *rpcclient.ClientJSONRPC:
-		_, err = cli.Call(""get_name"", []interface{}{name}, &res)
-	case *rpcclient.ClientURI:
-		_, err = cli.Call(""get_name"", map[string]interface{}{""name"": name}, &res)
-	}
+	res, err := performCall(client, ""get_name"",
+		""name"", name)
 	if err != nil {
 		return nil, err
 	}
 	return res.(*rpc_types.ResultGetName).Entry, nil
 }
+
+func BlockchainInfo(client rpcclient.Client, minHeight,
+	maxHeight int) (*rpc_types.ResultBlockchainInfo, error) {
+	res, err := performCall(client, ""blockchain"",
+		""minHeight"", minHeight,
+		""maxHeight"", maxHeight)
+	if err != nil {
+		return nil, err
+	}
+	return res.(*rpc_types.ResultBlockchainInfo), err
+}
+
+func performCall(client rpcclient.Client, method string,
+	paramKeyVals ...interface{}) (res rpc_types.ErisDBResult, err error) {
+	paramsMap, paramsSlice := mapAndValues(paramKeyVals...)
+	switch cli := client.(type) {
+	case *rpcclient.ClientJSONRPC:
+		_, err = cli.Call(method, paramsSlice, &res)
+	case *rpcclient.ClientURI:
+		_, err = cli.Call(method, paramsMap, &res)
+	}
+	return res, err
+
+}
+func mapAndValues(orderedKeyVals ...interface{}) (map[string]interface{}, []interface{}) {
+	if len(orderedKeyVals)%2 != 0 {
+		panic(fmt.Sprintf(""mapAndValues requires a even length list of keys and ""+",,2016-08-22 11:52:39,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75659830,https://github.com/hyperledger/burrow/pull/232#discussion_r75659830,silasdavis
https://github.com/hyperledger/burrow/pull/226,https://github.com/hyperledger/burrow/pull/226,"The concurrency model of TMSP application interface is still troublesome and we need to enforce it from the application side.  However, is the mempool not supposedly locked during commit, such that CheckTx and AppendTx are not called?

Can we consider a lock controlled by commit on holding all CheckTx/AppendTx, and holding commit until all CheckTx and AppendTx have cleared out of the queue?  -- I ve held off on this because we need to revisit the async model here at a fundamental level.

I am concerned here that undoing the nTxs breaks the original assumptions in this code.
",f17a96d29d30f8f93e89cf075f59dce63387dd53,2016-08-19 12:28:02,75472192,"@@ -185,15 +185,14 @@ func (app *ErisMint) Commit() (res tmsp.Result) {
 	// sync the AppendTx cache
 	app.cache.Sync()
 
-	// if there were any txs in the block,
-	// reset the check cache to the new height
-	if app.nTxs > 0 {
-		log.WithFields(log.Fields{
-			""txs"": app.nTxs,
-		}).Info(""Reset checkCache"")
-		app.checkCache = sm.NewBlockCache(app.state)
-	}
-	app.nTxs = 0
+	// Refresh checkCache even if there were no transactions. A CheckTx may have",,2016-08-19 13:33:19,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75472192,https://github.com/hyperledger/burrow/pull/226#discussion_r75472192,benjaminbollen
https://github.com/hyperledger/burrow/pull/226,https://github.com/hyperledger/burrow/pull/226,"Mulling on it a bit more; checkCache is okay to be ahead of the real application state; in addition to the above remark that we need to strongly enforce the concurrency from within erismint, CheckTx can be made more strongly aware of its inability to acknowledge the ordering and as such can be made smarter on explicit validations of ordering; eg sequence number on CheckTx should be a strict inequality, rather than exactly equal to `sequence_number + 1`

--- this is a stretch goal; the main point is that I think we should not reset cacheCheck on commit if no transactions are committed
",f17a96d29d30f8f93e89cf075f59dce63387dd53,2016-08-19 12:51:49,75475859,"@@ -185,15 +185,14 @@ func (app *ErisMint) Commit() (res tmsp.Result) {
 	// sync the AppendTx cache
 	app.cache.Sync()
 
-	// if there were any txs in the block,
-	// reset the check cache to the new height
-	if app.nTxs > 0 {
-		log.WithFields(log.Fields{
-			""txs"": app.nTxs,
-		}).Info(""Reset checkCache"")
-		app.checkCache = sm.NewBlockCache(app.state)
-	}
-	app.nTxs = 0
+	// Refresh checkCache even if there were no transactions. A CheckTx may have",,2016-08-19 13:33:19,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75475859,https://github.com/hyperledger/burrow/pull/226#discussion_r75475859,benjaminbollen
https://github.com/hyperledger/burrow/pull/226,https://github.com/hyperledger/burrow/pull/226,"> CheckTx can be made more strongly aware of its inability to acknowledge the ordering and as such can be made smarter on explicit validations of ordering;
> I'm not entirely sure what you are are saying in your second comment

I don't really understand what you are saying here. The ordering of any previous block's transaction are obviously fixed

When we commit we want to make sure future CheckTx runs have a fresh state, checking here for whether there is an empty block is a completely premature optimisation. I think it gains us very little and makes the code harder to understand.

The issue is that CheckTx can get run once and before being added to a proposal a recheck is forced (by a new block), the recheck should be running against the last committed state not the dirty state from the last CheckTx. Strict inequality wouldn't help here, I have a Tx with a correct nonce, but it is deemed invalid because it's been applied to the state twice. Actually it's valid against the current committed state.

Come to think of it, we should really be refreshing the checkCache every time CheckTx is called! I will remove this from here and make an analternative proposal we can discuss.
",f17a96d29d30f8f93e89cf075f59dce63387dd53,2016-08-19 13:29:49,75481119,"@@ -185,15 +185,14 @@ func (app *ErisMint) Commit() (res tmsp.Result) {
 	// sync the AppendTx cache
 	app.cache.Sync()
 
-	// if there were any txs in the block,
-	// reset the check cache to the new height
-	if app.nTxs > 0 {
-		log.WithFields(log.Fields{
-			""txs"": app.nTxs,
-		}).Info(""Reset checkCache"")
-		app.checkCache = sm.NewBlockCache(app.state)
-	}
-	app.nTxs = 0
+	// Refresh checkCache even if there were no transactions. A CheckTx may have",,2016-08-19 13:33:19,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75481119,https://github.com/hyperledger/burrow/pull/226#discussion_r75481119,silasdavis
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"This probably rings alarm bells, but I don't have anywhere sensible to send an Error here. Really it should happen if we have an up-to-date mapping against the tendermint version we are using.

Maybe it's better to drop events on the floor that we don't understand?
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-16 22:11:39,75030532,"@@ -47,12 +54,21 @@ func Multiplex(events ...EventEmitter) *multiplexedEvents {
 
 // The events struct has methods for working with events.
 type events struct {
-	eventSwitch *evts.EventSwitch
+	eventSwitch *go_events.EventSwitch
 }
 
 // Subscribe to an event.
-func (this *events) Subscribe(subId, event string, callback func(evts.EventData)) error {
-	this.eventSwitch.AddListenerForEvent(subId, event, callback)
+func (this *events) Subscribe(subId, event string,
+	callback func(txs.EventData)) error {
+	cb := func(evt go_events.EventData) {
+		eventData, err := mapToOurEventData(evt)
+		if err != nil {
+			panic(fmt.Sprintf(""Failed to map go-events EventData to our EventData %v"",
+				err))",,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75030532,https://github.com/hyperledger/burrow/pull/222#discussion_r75030532,silasdavis
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"We cannot introduce new panics at this point; an error is sufficient.
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-16 23:05:34,75037274,"@@ -47,12 +54,21 @@ func Multiplex(events ...EventEmitter) *multiplexedEvents {
 
 // The events struct has methods for working with events.
 type events struct {
-	eventSwitch *evts.EventSwitch
+	eventSwitch *go_events.EventSwitch
 }
 
 // Subscribe to an event.
-func (this *events) Subscribe(subId, event string, callback func(evts.EventData)) error {
-	this.eventSwitch.AddListenerForEvent(subId, event, callback)
+func (this *events) Subscribe(subId, event string,
+	callback func(txs.EventData)) error {
+	cb := func(evt go_events.EventData) {
+		eventData, err := mapToOurEventData(evt)
+		if err != nil {
+			panic(fmt.Sprintf(""Failed to map go-events EventData to our EventData %v"",",,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75037274,https://github.com/hyperledger/burrow/pull/222#discussion_r75037274,benjaminbollen
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"a void pointer `anyEventData` without argumentation seems uncalled for.
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-16 23:07:35,75037505,"@@ -21,20 +21,27 @@ import (
 	""encoding/hex""
 	""strings""
 
-	evts ""github.com/tendermint/go-events""
+	""fmt""
+
+	""github.com/eris-ltd/eris-db/txs""
+	go_events ""github.com/tendermint/go-events""
+	tm_types ""github.com/tendermint/tendermint/types""
 )
 
 // TODO improve
 // TODO: [ben] yes please ^^^
 // [ben] To improve this we will switch out go-events with eris-db/event so
 // that there is no need anymore for this poor wrapper.
 
+// Oh for a sum type",,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75037505,https://github.com/hyperledger/burrow/pull/222#discussion_r75037505,benjaminbollen
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"I had not refreshed the page, so you saw my comment coming :). It is a difficult point; I would look at having the `callback` function accept the error as an argument; If that causes too much work just now; I would prefer logging, dropping failed event and adding a clear TODO comment.
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-16 23:18:13,75038679,"@@ -47,12 +54,21 @@ func Multiplex(events ...EventEmitter) *multiplexedEvents {
 
 // The events struct has methods for working with events.
 type events struct {
-	eventSwitch *evts.EventSwitch
+	eventSwitch *go_events.EventSwitch
 }
 
 // Subscribe to an event.
-func (this *events) Subscribe(subId, event string, callback func(evts.EventData)) error {
-	this.eventSwitch.AddListenerForEvent(subId, event, callback)
+func (this *events) Subscribe(subId, event string,
+	callback func(txs.EventData)) error {
+	cb := func(evt go_events.EventData) {
+		eventData, err := mapToOurEventData(evt)
+		if err != nil {
+			panic(fmt.Sprintf(""Failed to map go-events EventData to our EventData %v"",
+				err))",,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75038679,https://github.com/hyperledger/burrow/pull/222#discussion_r75038679,benjaminbollen
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"Can we not define a new `txs` event type (or even define it at `/consensus`) that wraps around the go-events such that we swallow these event types, rather than this naked switch?  -- I'm not radically opposed if this resolves the bug in the short-term and we can add a comment of following discussion.
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-16 23:26:46,75039575,"@@ -118,5 +135,25 @@ func GenerateSubId() (string, error) {
 	}
 	rStr := hex.EncodeToString(b)
 	return strings.ToUpper(rStr), nil
+}
 
+func mapToOurEventData(eventData anyEventData) (txs.EventData, error) {
+	// While we depend on go-events in the way we do, we don't have much choice",,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75039575,https://github.com/hyperledger/burrow/pull/222#discussion_r75039575,benjaminbollen
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"What happened here?  -- looks like a non-trivial delta out of context, ie I don't get it :)
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-16 23:29:39,75039839,"@@ -32,7 +32,7 @@ func TestWrapper(runner func() int) int {
 func DebugMain() {
 	t := &testing.T{}
 	TestWrapper(func() int {
-		testBroadcastTx(t, ""HTTP"")",12,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75039839,https://github.com/hyperledger/burrow/pull/222#discussion_r75039839,benjaminbollen
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"I considered something like this, but since go-events doesn't use an erring callback it gets a bit weird with asynchrony. If you really wanted to do it I think using some error channels that you then need to check would be the way. I think we're trying to guard against a 'our coding' problem here rather than something we should really expect at runtime (we control the tendermint version).

Perhaps a nicer middle ground is to `log.Error(...)`. That way it should show up as serious but the whole stack doesn't go down just because someone subscribes to a tendermint event we don't understand..?
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-17 09:37:28,75091718,"@@ -47,12 +54,21 @@ func Multiplex(events ...EventEmitter) *multiplexedEvents {
 
 // The events struct has methods for working with events.
 type events struct {
-	eventSwitch *evts.EventSwitch
+	eventSwitch *go_events.EventSwitch
 }
 
 // Subscribe to an event.
-func (this *events) Subscribe(subId, event string, callback func(evts.EventData)) error {
-	this.eventSwitch.AddListenerForEvent(subId, event, callback)
+func (this *events) Subscribe(subId, event string,
+	callback func(txs.EventData)) error {
+	cb := func(evt go_events.EventData) {
+		eventData, err := mapToOurEventData(evt)
+		if err != nil {
+			panic(fmt.Sprintf(""Failed to map go-events EventData to our EventData %v"",
+				err))",,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75091718,https://github.com/hyperledger/burrow/pull/222#discussion_r75091718,silasdavis
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"So I think this is addressed in previous comment. I don't have a nice option here for returning an error along the callback chain.

I am leaning towards `log.Error`ing 
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-17 09:38:46,75091900,"@@ -47,12 +54,21 @@ func Multiplex(events ...EventEmitter) *multiplexedEvents {
 
 // The events struct has methods for working with events.
 type events struct {
-	eventSwitch *evts.EventSwitch
+	eventSwitch *go_events.EventSwitch
 }
 
 // Subscribe to an event.
-func (this *events) Subscribe(subId, event string, callback func(evts.EventData)) error {
-	this.eventSwitch.AddListenerForEvent(subId, event, callback)
+func (this *events) Subscribe(subId, event string,
+	callback func(txs.EventData)) error {
+	cb := func(evt go_events.EventData) {
+		eventData, err := mapToOurEventData(evt)
+		if err != nil {
+			panic(fmt.Sprintf(""Failed to map go-events EventData to our EventData %v"",",,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75091900,https://github.com/hyperledger/burrow/pull/222#discussion_r75091900,silasdavis
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"I need to accept `interface{}` because that is what a `TMEventData` (https://github.com/tendermint/tendermint/blob/master/types/events.go#L36), via go-events `EventData` (https://github.com/tendermint/go-events/blob/master/events.go#L11).

So creating a named type that is an `interface{}` is just an idiom that documents what I am expecting here.
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-17 09:42:41,75092391,"@@ -21,20 +21,27 @@ import (
 	""encoding/hex""
 	""strings""
 
-	evts ""github.com/tendermint/go-events""
+	""fmt""
+
+	""github.com/eris-ltd/eris-db/txs""
+	go_events ""github.com/tendermint/go-events""
+	tm_types ""github.com/tendermint/tendermint/types""
 )
 
 // TODO improve
 // TODO: [ben] yes please ^^^
 // [ben] To improve this we will switch out go-events with eris-db/event so
 // that there is no need anymore for this poor wrapper.
 
+// Oh for a sum type",,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75092391,https://github.com/hyperledger/burrow/pull/222#discussion_r75092391,silasdavis
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"DebugMain is my convenience method that allows me to run delve, it's not part of normal testing. It's really a workaround for delve not working off tests at the moment. I'd remove it to another project but I'd loose the visibility. I could remove it. 
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-17 09:43:46,75092528,"@@ -32,7 +32,7 @@ func TestWrapper(runner func() int) int {
 func DebugMain() {
 	t := &testing.T{}
 	TestWrapper(func() int {
-		testBroadcastTx(t, ""HTTP"")",12,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75092528,https://github.com/hyperledger/burrow/pull/222#discussion_r75092528,silasdavis
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"I'm really not sure there is a nicer way to do this. In essence `anyEventData` is wrapping around go-events `EventData`. I could embed `go_events.EventData` in `anyEventData`, but bear in mind that is just `interface{}` so the effect would be the same.

If we have decided that we want to have these event types in our code (I think we have) then this allows us to do more complex mapping/normalisation of events if we ever need to, for example for other consensus engines. But using a type switch like this I think is regrettably how this sort of thing is done in go.

I'm open to suggestions if you know of a better pattern or have something specific I haven't thought of when you say 'wraps around go-events'
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-17 09:48:44,75093201,"@@ -118,5 +135,25 @@ func GenerateSubId() (string, error) {
 	}
 	rStr := hex.EncodeToString(b)
 	return strings.ToUpper(rStr), nil
+}
 
+func mapToOurEventData(eventData anyEventData) (txs.EventData, error) {
+	// While we depend on go-events in the way we do, we don't have much choice",,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75093201,https://github.com/hyperledger/burrow/pull/222#discussion_r75093201,silasdavis
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"""Non-trivial delta out of context""... I'm just going to leave this [here](http://www.plainenglish.co.uk/)
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-17 09:51:51,75093645,"@@ -32,7 +32,7 @@ func TestWrapper(runner func() int) int {
 func DebugMain() {
 	t := &testing.T{}
 	TestWrapper(func() int {
-		testBroadcastTx(t, ""HTTP"")",12,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75093645,https://github.com/hyperledger/burrow/pull/222#discussion_r75093645,silasdavis
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"Also 'void pointer'? Have you been secretly writing C?
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-17 09:52:19,75093715,"@@ -21,20 +21,27 @@ import (
 	""encoding/hex""
 	""strings""
 
-	evts ""github.com/tendermint/go-events""
+	""fmt""
+
+	""github.com/eris-ltd/eris-db/txs""
+	go_events ""github.com/tendermint/go-events""
+	tm_types ""github.com/tendermint/tendermint/types""
 )
 
 // TODO improve
 // TODO: [ben] yes please ^^^
 // [ben] To improve this we will switch out go-events with eris-db/event so
 // that there is no need anymore for this poor wrapper.
 
+// Oh for a sum type",,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75093715,https://github.com/hyperledger/burrow/pull/222#discussion_r75093715,silasdavis
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"No, I think putting a short comment above the function is more than adequate to argue for it's existence (referencing delve as a debugging tool)
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-17 15:19:09,75143826,"@@ -32,7 +32,7 @@ func TestWrapper(runner func() int) int {
 func DebugMain() {
 	t := &testing.T{}
 	TestWrapper(func() int {
-		testBroadcastTx(t, ""HTTP"")",12,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75143826,https://github.com/hyperledger/burrow/pull/222#discussion_r75143826,benjaminbollen
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"Well, I fully agree this is a problematic construction and we need to sort it out first.  But this is why I committed a proposal base code (copied from go-ethereum) in `/event_new`; because the only solution I see is building this event stream from the ground up.  In my opinion, you're right to address this like this, but it's a temporary solution.
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-17 15:22:27,75144491,"@@ -118,5 +135,25 @@ func GenerateSubId() (string, error) {
 	}
 	rStr := hex.EncodeToString(b)
 	return strings.ToUpper(rStr), nil
+}
 
+func mapToOurEventData(eventData anyEventData) (txs.EventData, error) {
+	// While we depend on go-events in the way we do, we don't have much choice",,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75144491,https://github.com/hyperledger/burrow/pull/222#discussion_r75144491,benjaminbollen
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"OK. Mixing async paradigms (error channel where it's currently using callbacks) is not a net-gain on clarity, so let's not go there.  Im good with logging it and dropping it.
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-17 15:25:12,75145103,"@@ -47,12 +54,21 @@ func Multiplex(events ...EventEmitter) *multiplexedEvents {
 
 // The events struct has methods for working with events.
 type events struct {
-	eventSwitch *evts.EventSwitch
+	eventSwitch *go_events.EventSwitch
 }
 
 // Subscribe to an event.
-func (this *events) Subscribe(subId, event string, callback func(evts.EventData)) error {
-	this.eventSwitch.AddListenerForEvent(subId, event, callback)
+func (this *events) Subscribe(subId, event string,
+	callback func(txs.EventData)) error {
+	cb := func(evt go_events.EventData) {
+		eventData, err := mapToOurEventData(evt)
+		if err != nil {
+			panic(fmt.Sprintf(""Failed to map go-events EventData to our EventData %v"",
+				err))",,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75145103,https://github.com/hyperledger/burrow/pull/222#discussion_r75145103,benjaminbollen
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"But do add a TODO please
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-17 15:25:23,75145143,"@@ -47,12 +54,21 @@ func Multiplex(events ...EventEmitter) *multiplexedEvents {
 
 // The events struct has methods for working with events.
 type events struct {
-	eventSwitch *evts.EventSwitch
+	eventSwitch *go_events.EventSwitch
 }
 
 // Subscribe to an event.
-func (this *events) Subscribe(subId, event string, callback func(evts.EventData)) error {
-	this.eventSwitch.AddListenerForEvent(subId, event, callback)
+func (this *events) Subscribe(subId, event string,
+	callback func(txs.EventData)) error {
+	cb := func(evt go_events.EventData) {
+		eventData, err := mapToOurEventData(evt)
+		if err != nil {
+			panic(fmt.Sprintf(""Failed to map go-events EventData to our EventData %v"",
+				err))",,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75145143,https://github.com/hyperledger/burrow/pull/222#discussion_r75145143,benjaminbollen
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"OIC right yeah temporary WRT that I agree
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-17 15:27:18,75145518,"@@ -118,5 +135,25 @@ func GenerateSubId() (string, error) {
 	}
 	rStr := hex.EncodeToString(b)
 	return strings.ToUpper(rStr), nil
+}
 
+func mapToOurEventData(eventData anyEventData) (txs.EventData, error) {
+	// While we depend on go-events in the way we do, we don't have much choice",,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75145518,https://github.com/hyperledger/burrow/pull/222#discussion_r75145518,silasdavis
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"TODO: use a language where not closing over a sum type is a compile-time error.
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-17 15:28:28,75145750,"@@ -47,12 +54,21 @@ func Multiplex(events ...EventEmitter) *multiplexedEvents {
 
 // The events struct has methods for working with events.
 type events struct {
-	eventSwitch *evts.EventSwitch
+	eventSwitch *go_events.EventSwitch
 }
 
 // Subscribe to an event.
-func (this *events) Subscribe(subId, event string, callback func(evts.EventData)) error {
-	this.eventSwitch.AddListenerForEvent(subId, event, callback)
+func (this *events) Subscribe(subId, event string,
+	callback func(txs.EventData)) error {
+	cb := func(evt go_events.EventData) {
+		eventData, err := mapToOurEventData(evt)
+		if err != nil {
+			panic(fmt.Sprintf(""Failed to map go-events EventData to our EventData %v"",
+				err))",,2016-08-17 16:03:35,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75145750,https://github.com/hyperledger/burrow/pull/222#discussion_r75145750,silasdavis
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"for the ... ?
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-17 16:11:10,75154063,"@@ -21,20 +21,29 @@ import (
 	""encoding/hex""
 	""strings""
 
-	evts ""github.com/tendermint/go-events""
+	""fmt""
+
+	""github.com/eris-ltd/eris-db/txs""
+	log ""github.com/eris-ltd/eris-logger""
+	go_events ""github.com/tendermint/go-events""
+	tm_types ""github.com/tendermint/tendermint/types""
 )
 
-// TODO improve
-// TODO: [ben] yes please ^^^
-// [ben] To improve this we will switch out go-events with eris-db/event so
-// that there is no need anymore for this poor wrapper.
+// TODO: [Silas] this is a compatibility layer between our event types and
+// TODO: go-events. Our ultimate plan is to replace go-events with our own pub-sub
+// TODO: code that will better allow us to manage and multiplex events from different
+// TODO: subsystems
+
+// Oh for a sum type
+// We are using this as a marker interface for the",23,2016-08-17 16:11:10,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75154063,https://github.com/hyperledger/burrow/pull/222#discussion_r75154063,benjaminbollen
https://github.com/hyperledger/burrow/pull/222,https://github.com/hyperledger/burrow/pull/222,"woops, I'll fix that
",0a368e1bf0f1b50f2595fdaf85a336b0a088e3f0,2016-08-17 17:22:51,75166799,"@@ -21,20 +21,29 @@ import (
 	""encoding/hex""
 	""strings""
 
-	evts ""github.com/tendermint/go-events""
+	""fmt""
+
+	""github.com/eris-ltd/eris-db/txs""
+	log ""github.com/eris-ltd/eris-logger""
+	go_events ""github.com/tendermint/go-events""
+	tm_types ""github.com/tendermint/tendermint/types""
 )
 
-// TODO improve
-// TODO: [ben] yes please ^^^
-// [ben] To improve this we will switch out go-events with eris-db/event so
-// that there is no need anymore for this poor wrapper.
+// TODO: [Silas] this is a compatibility layer between our event types and
+// TODO: go-events. Our ultimate plan is to replace go-events with our own pub-sub
+// TODO: code that will better allow us to manage and multiplex events from different
+// TODO: subsystems
+
+// Oh for a sum type
+// We are using this as a marker interface for the",23,2016-08-17 17:22:51,https://api.github.com/repos/hyperledger/burrow/pulls/comments/75166799,https://github.com/hyperledger/burrow/pull/222#discussion_r75166799,silasdavis
https://github.com/hyperledger/burrow/pull/198,https://github.com/hyperledger/burrow/pull/198,"Please raise an issue for adding unit tests for this event multiplexing.
",e61ea42a8ff3da9eb6c5e527104aa8667b76f3b5,2016-08-11 10:22:31,74398652,"@@ -30,29 +30,61 @@ import (
 // that there is no need anymore for this poor wrapper.
 
 type EventEmitter interface {
-	Subscribe(subId, event string, callback func(evts.EventData)) (bool, error)
-	Unsubscribe(subId string) (bool, error)
+	Subscribe(subId, event string, callback func(evts.EventData)) error
+	Unsubscribe(subId string) error
+}
+
+func NewEvents(eventSwitch *evts.EventSwitch) *events {
+	return &events{eventSwitch}
+}
+
+func Multiplex(events ...EventEmitter) *multiplexedEvents {
+	return &multiplexedEvents{events}
 }
 
 // The events struct has methods for working with events.
 type events struct {
 	eventSwitch *evts.EventSwitch
 }
 
-func NewEvents(eventSwitch *evts.EventSwitch) *events {
-	return &events{eventSwitch}
-}
-
 // Subscribe to an event.
-func (this *events) Subscribe(subId, event string, callback func(evts.EventData)) (bool, error) {
+func (this *events) Subscribe(subId, event string, callback func(evts.EventData)) error {
 	this.eventSwitch.AddListenerForEvent(subId, event, callback)
-	return true, nil
+	return nil
 }
 
 // Un-subscribe from an event.
-func (this *events) Unsubscribe(subId string) (bool, error) {
+func (this *events) Unsubscribe(subId string) error {
 	this.eventSwitch.RemoveListener(subId)
-	return true, nil
+	return nil
+}
+
+type multiplexedEvents struct {
+	eventEmitters []EventEmitter
+}
+
+// Subscribe to an event.
+func (multiEvents *multiplexedEvents) Subscribe(subId, event string, callback func(evts.EventData)) error {",51,2016-08-11 14:50:47,https://api.github.com/repos/hyperledger/burrow/pulls/comments/74398652,https://github.com/hyperledger/burrow/pull/198#discussion_r74398652,benjaminbollen
https://github.com/hyperledger/burrow/pull/192,https://github.com/hyperledger/burrow/pull/192,"Probably functionally irrelevant, but shouldn't this be `maxHeight-h <= BLOCK_MAX` really?
",0dcd1b8389e3869748cf31f6cf5d041813431358,2016-08-04 11:20:22,73504309,"@@ -107,7 +107,8 @@ func (this *blockchain) Blocks(fda []*FilterData) (*Blocks, error) {
 	if skumtFel != nil {
 		return nil, fmt.Errorf(""Fel i förfrågan. Helskumt...: "" + skumtFel.Error())
 	}
-	for h := maxHeight; h >= minHeight && maxHeight-h > BLOCK_MAX; h-- {
+
+	for h := maxHeight; h >= minHeight && maxHeight-h < BLOCK_MAX; h-- {",6,2016-08-04 11:20:22,https://api.github.com/repos/hyperledger/burrow/pulls/comments/73504309,https://github.com/hyperledger/burrow/pull/192#discussion_r73504309,silasdavis
https://github.com/hyperledger/burrow/pull/192,https://github.com/hyperledger/burrow/pull/192,"arguably, but I will note it on #193 
",0dcd1b8389e3869748cf31f6cf5d041813431358,2016-08-04 11:32:44,73505734,"@@ -107,7 +107,8 @@ func (this *blockchain) Blocks(fda []*FilterData) (*Blocks, error) {
 	if skumtFel != nil {
 		return nil, fmt.Errorf(""Fel i förfrågan. Helskumt...: "" + skumtFel.Error())
 	}
-	for h := maxHeight; h >= minHeight && maxHeight-h > BLOCK_MAX; h-- {
+
+	for h := maxHeight; h >= minHeight && maxHeight-h < BLOCK_MAX; h-- {",6,2016-08-04 11:32:44,https://api.github.com/repos/hyperledger/burrow/pulls/comments/73505734,https://github.com/hyperledger/burrow/pull/192#discussion_r73505734,benjaminbollen
https://github.com/hyperledger/burrow/pull/187,https://github.com/hyperledger/burrow/pull/187,"How about just 'Client', I find 'Node' distracting here and suggestive of something else (like we have NodeJS in our stack, we have Tendermint's Node...). it seems like 'Client' doesn't clash with anything else. Or perhaps 'TxClient' or 'BroadcastClient' or 'TransactionClient'?

Yes it's minor, but names matter and they stick...
",5e53893ab1f027c9ac7849112fefc2ede14bfb29,2016-09-15 10:46:09,78935559,"@@ -0,0 +1,82 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package client
+
+import (
+	""fmt""
+
+	""github.com/tendermint/go-rpc/client""
+
+	""github.com/eris-ltd/eris-db/account""
+	tendermint_client ""github.com/eris-ltd/eris-db/rpc/tendermint/client""
+	""github.com/eris-ltd/eris-db/txs""
+)
+
+type NodeClient interface {",29,2016-09-15 11:24:20,https://api.github.com/repos/hyperledger/burrow/pulls/comments/78935559,https://github.com/hyperledger/burrow/pull/187#discussion_r78935559,silasdavis
https://github.com/hyperledger/burrow/pull/187,https://github.com/hyperledger/burrow/pull/187,"good :)
",5e53893ab1f027c9ac7849112fefc2ede14bfb29,2016-09-15 10:48:37,78935921,"@@ -0,0 +1,82 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package client
+
+import (
+	""fmt""
+
+	""github.com/tendermint/go-rpc/client""
+
+	""github.com/eris-ltd/eris-db/account""
+	tendermint_client ""github.com/eris-ltd/eris-db/rpc/tendermint/client""
+	""github.com/eris-ltd/eris-db/txs""
+)
+
+type NodeClient interface {
+	Broadcast(transaction txs.Tx) (*txs.Receipt, error)
+
+	GetAccount(address []byte) (*account.Account, error)
+}
+
+// NOTE [ben] Compiler check to ensure ErisClient successfully implements
+// eris-db/client.NodeClient
+var _ NodeClient = (*ErisNodeClient)(nil)
+
+// Eris-Client is a simple struct exposing the client rpc methods
+
+type ErisNodeClient struct {
+	broadcastRPC string
+}
+
+// ErisKeyClient.New returns a new eris-keys client for provided rpc location
+// Eris-keys connects over http request-responses
+func NewErisNodeClient(rpcString string) *ErisNodeClient {
+	return &ErisNodeClient{
+		broadcastRPC: rpcString,
+	}
+}
+
+//------------------------------------------------------------------------------------
+// broadcast to blockchain node
+// NOTE: [ben] Eris Client first continues from tendermint rpc, but will have handshake to negotiate
+// protocol version for moving towards rpc/v1
+
+func (erisClient *ErisNodeClient) Broadcast(tx txs.Tx) (*txs.Receipt, error) {
+	client := rpcclient.NewClientURI(erisClient.broadcastRPC)
+	receipt, err := tendermint_client.BroadcastTx(client, tx)
+	if err != nil {
+		return nil, err
+	}
+	return &receipt, nil
+}
+
+func (erisClient *ErisNodeClient) GetAccount(address []byte) (*account.Account, error) {
+	// fetch nonce from node
+	client := rpcclient.NewClientURI(erisClient.broadcastRPC)
+	account, err := tendermint_client.GetAccount(client, address)
+	if err != nil {
+		err = fmt.Errorf(""Error connecting to node (%s) to fetch account (%X): %s"",
+			erisClient.broadcastRPC, address, err.Error())
+		return nil, err
+	}
+	if account == nil {
+		err = fmt.Errorf(""Unknown account %X at node (%s)"", address, erisClient.broadcastRPC)
+		return nil, err
+	}
+
+	return account.Copy(), nil",81,2016-09-15 11:24:20,https://api.github.com/repos/hyperledger/burrow/pulls/comments/78935921,https://github.com/hyperledger/burrow/pull/187#discussion_r78935921,silasdavis
https://github.com/hyperledger/burrow/pull/187,https://github.com/hyperledger/burrow/pull/187,"Can we add a TODO here: expect this stuff in future PR
",5e53893ab1f027c9ac7849112fefc2ede14bfb29,2016-09-15 10:56:56,78937360,"@@ -0,0 +1,450 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package core
+
+import (
+	""encoding/hex""
+	""fmt""
+	""strconv""
+	// ""strings""
+	// ""time""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+
+	// log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/client""
+	""github.com/eris-ltd/eris-db/keys""
+	""github.com/eris-ltd/eris-db/txs""
+)
+
+var (
+	MaxCommitWaitTimeSeconds = 20
+)
+
+//------------------------------------------------------------------------------------
+// core functions with string args.
+// validates strings and forms transaction
+
+func Send(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addr, toAddr, amtS, nonceS string) (*txs.SendTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
+
+	if toAddr == """" {
+		return nil, fmt.Errorf(""destination address must be given with --to flag"")
+	}
+
+	toAddrBytes, err := hex.DecodeString(toAddr)
+	if err != nil {
+		return nil, fmt.Errorf(""toAddr is bad hex: %v"", err)
+	}
+
+	tx := txs.NewSendTx()
+	tx.AddInputWithNonce(pub, amt, int(nonce))
+	tx.AddOutput(toAddrBytes, amt)
+
+	return tx, nil
+}
+
+func Call(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addr, toAddr, amtS, nonceS, gasS, feeS, data string) (*txs.CallTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
+
+	toAddrBytes, err := hex.DecodeString(toAddr)
+	if err != nil {
+		return nil, fmt.Errorf(""toAddr is bad hex: %v"", err)
+	}
+
+	fee, err := strconv.ParseInt(feeS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""fee is misformatted: %v"", err)
+	}
+
+	gas, err := strconv.ParseInt(gasS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""gas is misformatted: %v"", err)
+	}
+
+	dataBytes, err := hex.DecodeString(data)
+	if err != nil {
+		return nil, fmt.Errorf(""data is bad hex: %v"", err)
+	}
+
+	tx := txs.NewCallTxWithNonce(pub, toAddrBytes, dataBytes, amt, gas, fee, int(nonce))
+	return tx, nil
+}
+
+func Name(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addr, amtS, nonceS, feeS, name, data string) (*txs.NameTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
+
+	fee, err := strconv.ParseInt(feeS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""fee is misformatted: %v"", err)
+	}
+
+	tx := txs.NewNameTxWithNonce(pub, name, data, amt, fee, int(nonce))
+	return tx, nil
+}
+
+type PermFunc struct {
+	Name string
+	Args string
+}
+
+var PermsFuncs = []PermFunc{
+	{""set_base"", ""address, permission flag, value""},
+	{""unset_base"", ""address, permission flag""},
+	{""set_global"", ""permission flag, value""},
+	{""add_role"", ""address, role""},
+	{""rm_role"", ""address, role""},
+}
+
+func Permissions(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addrS, nonceS, permFunc string, argsS []string) (*txs.PermissionsTx, error) {
+	pub, _, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addrS, ""0"", nonceS)
+	if err != nil {
+		return nil, err
+	}
+	var args ptypes.PermArgs
+	switch permFunc {
+	case ""set_base"":
+		addr, pF, err := decodeAddressPermFlag(argsS[0], argsS[1])
+		if err != nil {
+			return nil, err
+		}
+		if len(argsS) != 3 {
+			return nil, fmt.Errorf(""set_base also takes a value (true or false)"")
+		}
+		var value bool
+		if argsS[2] == ""true"" {
+			value = true
+		} else if argsS[2] == ""false"" {
+			value = false
+		} else {
+			return nil, fmt.Errorf(""Unknown value %s"", argsS[2])
+		}
+		args = &ptypes.SetBaseArgs{addr, pF, value}
+	case ""unset_base"":
+		addr, pF, err := decodeAddressPermFlag(argsS[0], argsS[1])
+		if err != nil {
+			return nil, err
+		}
+		args = &ptypes.UnsetBaseArgs{addr, pF}
+	case ""set_global"":
+		pF, err := ptypes.PermStringToFlag(argsS[0])
+		if err != nil {
+			return nil, err
+		}
+		var value bool
+		if argsS[1] == ""true"" {
+			value = true
+		} else if argsS[1] == ""false"" {
+			value = false
+		} else {
+			return nil, fmt.Errorf(""Unknown value %s"", argsS[1])
+		}
+		args = &ptypes.SetGlobalArgs{pF, value}
+	case ""add_role"":
+		addr, err := hex.DecodeString(argsS[0])
+		if err != nil {
+			return nil, err
+		}
+		args = &ptypes.AddRoleArgs{addr, argsS[1]}
+	case ""rm_role"":
+		addr, err := hex.DecodeString(argsS[0])
+		if err != nil {
+			return nil, err
+		}
+		args = &ptypes.RmRoleArgs{addr, argsS[1]}
+	default:
+		return nil, fmt.Errorf(""Invalid permission function for use in PermissionsTx: %s"", permFunc)
+	}
+	// args := snativeArgs(
+	tx := txs.NewPermissionsTxWithNonce(pub, args, int(nonce))
+	return tx, nil
+}
+
+// type NameGetter struct {
+// 	client cclient.Client
+// }
+
+// func (n NameGetter) GetNameRegEntry(name string) *txs.NameRegEntry {",191,2016-09-15 11:24:20,https://api.github.com/repos/hyperledger/burrow/pulls/comments/78937360,https://github.com/hyperledger/burrow/pull/187#discussion_r78937360,silasdavis
https://github.com/hyperledger/burrow/pull/187,https://github.com/hyperledger/burrow/pull/187,"Can we add a TODO here, perhaps reference similar functionality in: 

https://github.com/eris-ltd/eris-db/blob/develop/rpc/tendermint/test/ws_helpers.go#L137

Might be a good idea to share implementation... might not...
",5e53893ab1f027c9ac7849112fefc2ede14bfb29,2016-09-15 11:00:34,78937881,"@@ -0,0 +1,450 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package core
+
+import (
+	""encoding/hex""
+	""fmt""
+	""strconv""
+	// ""strings""
+	// ""time""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+
+	// log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/client""
+	""github.com/eris-ltd/eris-db/keys""
+	""github.com/eris-ltd/eris-db/txs""
+)
+
+var (
+	MaxCommitWaitTimeSeconds = 20
+)
+
+//------------------------------------------------------------------------------------
+// core functions with string args.
+// validates strings and forms transaction
+
+func Send(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addr, toAddr, amtS, nonceS string) (*txs.SendTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
+
+	if toAddr == """" {
+		return nil, fmt.Errorf(""destination address must be given with --to flag"")
+	}
+
+	toAddrBytes, err := hex.DecodeString(toAddr)
+	if err != nil {
+		return nil, fmt.Errorf(""toAddr is bad hex: %v"", err)
+	}
+
+	tx := txs.NewSendTx()
+	tx.AddInputWithNonce(pub, amt, int(nonce))
+	tx.AddOutput(toAddrBytes, amt)
+
+	return tx, nil
+}
+
+func Call(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addr, toAddr, amtS, nonceS, gasS, feeS, data string) (*txs.CallTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
+
+	toAddrBytes, err := hex.DecodeString(toAddr)
+	if err != nil {
+		return nil, fmt.Errorf(""toAddr is bad hex: %v"", err)
+	}
+
+	fee, err := strconv.ParseInt(feeS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""fee is misformatted: %v"", err)
+	}
+
+	gas, err := strconv.ParseInt(gasS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""gas is misformatted: %v"", err)
+	}
+
+	dataBytes, err := hex.DecodeString(data)
+	if err != nil {
+		return nil, fmt.Errorf(""data is bad hex: %v"", err)
+	}
+
+	tx := txs.NewCallTxWithNonce(pub, toAddrBytes, dataBytes, amt, gas, fee, int(nonce))
+	return tx, nil
+}
+
+func Name(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addr, amtS, nonceS, feeS, name, data string) (*txs.NameTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
+
+	fee, err := strconv.ParseInt(feeS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""fee is misformatted: %v"", err)
+	}
+
+	tx := txs.NewNameTxWithNonce(pub, name, data, amt, fee, int(nonce))
+	return tx, nil
+}
+
+type PermFunc struct {
+	Name string
+	Args string
+}
+
+var PermsFuncs = []PermFunc{
+	{""set_base"", ""address, permission flag, value""},
+	{""unset_base"", ""address, permission flag""},
+	{""set_global"", ""permission flag, value""},
+	{""add_role"", ""address, role""},
+	{""rm_role"", ""address, role""},
+}
+
+func Permissions(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addrS, nonceS, permFunc string, argsS []string) (*txs.PermissionsTx, error) {
+	pub, _, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addrS, ""0"", nonceS)
+	if err != nil {
+		return nil, err
+	}
+	var args ptypes.PermArgs
+	switch permFunc {
+	case ""set_base"":
+		addr, pF, err := decodeAddressPermFlag(argsS[0], argsS[1])
+		if err != nil {
+			return nil, err
+		}
+		if len(argsS) != 3 {
+			return nil, fmt.Errorf(""set_base also takes a value (true or false)"")
+		}
+		var value bool
+		if argsS[2] == ""true"" {
+			value = true
+		} else if argsS[2] == ""false"" {
+			value = false
+		} else {
+			return nil, fmt.Errorf(""Unknown value %s"", argsS[2])
+		}
+		args = &ptypes.SetBaseArgs{addr, pF, value}
+	case ""unset_base"":
+		addr, pF, err := decodeAddressPermFlag(argsS[0], argsS[1])
+		if err != nil {
+			return nil, err
+		}
+		args = &ptypes.UnsetBaseArgs{addr, pF}
+	case ""set_global"":
+		pF, err := ptypes.PermStringToFlag(argsS[0])
+		if err != nil {
+			return nil, err
+		}
+		var value bool
+		if argsS[1] == ""true"" {
+			value = true
+		} else if argsS[1] == ""false"" {
+			value = false
+		} else {
+			return nil, fmt.Errorf(""Unknown value %s"", argsS[1])
+		}
+		args = &ptypes.SetGlobalArgs{pF, value}
+	case ""add_role"":
+		addr, err := hex.DecodeString(argsS[0])
+		if err != nil {
+			return nil, err
+		}
+		args = &ptypes.AddRoleArgs{addr, argsS[1]}
+	case ""rm_role"":
+		addr, err := hex.DecodeString(argsS[0])
+		if err != nil {
+			return nil, err
+		}
+		args = &ptypes.RmRoleArgs{addr, argsS[1]}
+	default:
+		return nil, fmt.Errorf(""Invalid permission function for use in PermissionsTx: %s"", permFunc)
+	}
+	// args := snativeArgs(
+	tx := txs.NewPermissionsTxWithNonce(pub, args, int(nonce))
+	return tx, nil
+}
+
+// type NameGetter struct {
+// 	client cclient.Client
+// }
+
+// func (n NameGetter) GetNameRegEntry(name string) *txs.NameRegEntry {
+// 	entry, err := n.client.GetName(name)
+// 	if err != nil {
+// 		panic(err)
+// 	}
+// 	return entry.Entry
+// }
+
+/*
+func coreNewAccount(nodeAddr, pubkey, chainID string) (*types.NewAccountTx, error) {
+	pub, _, _, err := checkCommon(nodeAddr, pubkey, """", ""0"", ""0"")
+	if err != nil {
+		return nil, err
+	}
+
+	client := cclient.NewClient(nodeAddr, ""HTTP"")
+	return types.NewNewAccountTx(NameGetter{client}, pub, chainID)
+}
+*/
+
+// func Bond(nodeAddr, signAddr, pubkey, unbondAddr, amtS, nonceS string) (*txs.BondTx, error) {
+// 	pub, amt, nonce, err := checkCommon(nodeAddr, signAddr, pubkey, """", amtS, nonceS)
+// 	if err != nil {
+// 		return nil, err
+// 	}
+// 	var pubKey crypto.PubKeyEd25519
+// 	var unbondAddrBytes []byte
+
+// 	if unbondAddr == """" {
+// 		pkb, _ := hex.DecodeString(pubkey)
+// 		copy(pubKey[:], pkb)
+// 		unbondAddrBytes = pubKey.Address()
+// 	} else {
+// 		unbondAddrBytes, err = hex.DecodeString(unbondAddr)
+// 		if err != nil {
+// 			return nil, fmt.Errorf(""unbondAddr is bad hex: %v"", err)
+// 		}
+
+// 	}
+
+// 	tx, err := types.NewBondTx(pub)
+// 	if err != nil {
+// 		return nil, err
+// 	}
+// 	tx.AddInputWithNonce(pub, amt, int(nonce))
+// 	tx.AddOutput(unbondAddrBytes, amt)
+
+// 	return tx, nil
+// }
+
+// func Unbond(addrS, heightS string) (*txs.UnbondTx, error) {
+// 	if addrS == """" {
+// 		return nil, fmt.Errorf(""Validator address must be given with --addr flag"")
+// 	}
+
+// 	addrBytes, err := hex.DecodeString(addrS)
+// 	if err != nil {
+// 		return nil, fmt.Errorf(""addr is bad hex: %v"", err)
+// 	}
+
+// 	height, err := strconv.ParseInt(heightS, 10, 32)
+// 	if err != nil {
+// 		return nil, fmt.Errorf(""height is misformatted: %v"", err)
+// 	}
+
+// 	return &types.UnbondTx{
+// 		Address: addrBytes,
+// 		Height:  int(height),
+// 	}, nil
+// }
+
+// func Rebond(addrS, heightS string) (*txs.RebondTx, error) {
+// 	if addrS == """" {
+// 		return nil, fmt.Errorf(""Validator address must be given with --addr flag"")
+// 	}
+
+// 	addrBytes, err := hex.DecodeString(addrS)
+// 	if err != nil {
+// 		return nil, fmt.Errorf(""addr is bad hex: %v"", err)
+// 	}
+
+// 	height, err := strconv.ParseInt(heightS, 10, 32)
+// 	if err != nil {
+// 		return nil, fmt.Errorf(""height is misformatted: %v"", err)
+// 	}
+
+// 	return &types.RebondTx{
+// 		Address: addrBytes,
+// 		Height:  int(height),
+// 	}, nil
+// }
+
+type TxResult struct {
+	BlockHash []byte // all txs get in a block
+	Hash      []byte // all txs get a hash
+
+	// only CallTx
+	Address   []byte // only for new contracts
+	Return    []byte
+	Exception string
+
+	//TODO: make Broadcast() errors more responsive so we
+	// can differentiate mempool errors from other
+}
+
+// Preserve
+func SignAndBroadcast(chainID string, nodeClient client.NodeClient, keyClient keys.KeyClient, tx txs.Tx, sign, broadcast, wait bool) (txResult *TxResult, err error) {
+	// var inputAddr []byte
+	if sign {
+		_, tx, err = signTx(keyClient, chainID, tx)
+		if err != nil {
+			return nil, err
+		}
+	}
+
+	if broadcast {
+		// if wait {
+		// 	var ch chan Msg
+		// 	ch, err = subscribeAndWait(tx, chainID, nodeAddr, inputAddr)
+		// 	if err != nil {
+		// 		return nil, err
+		// 	} else {
+		// 		defer func() {
+		// 			if err != nil {
+		// 				// if broadcast threw an error, just return
+		// 				return
+		// 			}
+		// 			log.WithFields(log.Fields{
+		// 				"""",
+		// 				}).Debug(""Waiting for tx to be committed"")
+		// 			msg := <-ch
+		// 			if msg.Error != nil {
+		// 				logger.Infof(""Encountered error waiting for event: %v\n"", msg.Error)
+		// 				err = msg.Error
+		// 			} else {
+		// 				txResult.BlockHash = msg.BlockHash
+		// 				txResult.Return = msg.Value
+		// 				txResult.Exception = msg.Exception
+		// 			}
+		// 		}()
+		// 	}
+		// }
+		var receipt *txs.Receipt
+		receipt, err = nodeClient.Broadcast(tx)
+		if err != nil {
+			return nil, err
+		}
+		txResult = &TxResult{
+			Hash: receipt.TxHash,
+		}
+		// NOTE: [ben] is this consistent with the Ethereum protocol?  It should seem
+		// reasonable to get this returned from the chain directly.  Alternatively,
+		// the benefit is that the we don't need to trust the chain node
+		if tx_, ok := tx.(*txs.CallTx); ok {
+			if len(tx_.Address) == 0 {
+				txResult.Address = txs.NewContractAddress(tx_.Input.Address, tx_.Input.Sequence)
+			}
+		}
+	}
+	return
+}
+
+//------------------------------------------------------------------------------------
+// wait for events
+
+type Msg struct {
+	BlockHash []byte
+	Value     []byte
+	Exception string
+	Error     error
+}
+
+// func subscribeAndWait(tx txs.Tx, chainID, nodeAddr string, inputAddr []byte) (chan Msg, error) {",363,2016-09-15 11:24:20,https://api.github.com/repos/hyperledger/burrow/pulls/comments/78937881,https://github.com/hyperledger/burrow/pull/187#discussion_r78937881,silasdavis
https://github.com/hyperledger/burrow/pull/187,https://github.com/hyperledger/burrow/pull/187,"This is a bit non-standard. Rename to 'MakeRequest', or even 'Do'. Unless I'm missing something this is just a wrapping of making a HTTP request. I don't know of any libraries that would call this 'RequestResponse', despite there being a certain mind-bending logic to it...
",5e53893ab1f027c9ac7849112fefc2ede14bfb29,2016-09-15 11:21:10,78941392,"@@ -0,0 +1,91 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+// version provides the current Eris-DB version and a VersionIdentifier
+// for the modules to identify their version with.
+
+package keys
+
+import (
+	""bytes""
+	""encoding/json""
+	""fmt""
+	""io/ioutil""
+	""net/http""
+
+	log ""github.com/eris-ltd/eris-logger""
+)
+
+// Eris-Keys server connects over http request-response structures
+
+type HTTPResponse struct {
+	Response string
+	Error    string
+}
+
+func RequestResponse(addr, method string, args map[string]string) (string, error) {",39,2016-09-15 11:24:20,https://api.github.com/repos/hyperledger/burrow/pulls/comments/78941392,https://github.com/hyperledger/burrow/pull/187#discussion_r78941392,silasdavis
https://github.com/hyperledger/burrow/pull/187,https://github.com/hyperledger/burrow/pull/187,"I agree names are important, but I do like `Node` for the reason I call it here `ErisNodeClient` and `ErisKeyClient`; and yes `TendermintNode` (it is a node on its own at that consensus level);

`Node` in `ErisNodeClient` is a running instance of eris-db
",5e53893ab1f027c9ac7849112fefc2ede14bfb29,2016-09-15 14:40:41,78979762,"@@ -0,0 +1,82 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package client
+
+import (
+	""fmt""
+
+	""github.com/tendermint/go-rpc/client""
+
+	""github.com/eris-ltd/eris-db/account""
+	tendermint_client ""github.com/eris-ltd/eris-db/rpc/tendermint/client""
+	""github.com/eris-ltd/eris-db/txs""
+)
+
+type NodeClient interface {",29,2016-09-15 14:40:41,https://api.github.com/repos/hyperledger/burrow/pulls/comments/78979762,https://github.com/hyperledger/burrow/pull/187#discussion_r78979762,benjaminbollen
https://github.com/hyperledger/burrow/pull/187,https://github.com/hyperledger/burrow/pull/187,"added todo in https://github.com/eris-ltd/eris-db/issues/264
",5e53893ab1f027c9ac7849112fefc2ede14bfb29,2016-09-15 14:42:08,78980125,"@@ -0,0 +1,450 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package core
+
+import (
+	""encoding/hex""
+	""fmt""
+	""strconv""
+	// ""strings""
+	// ""time""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+
+	// log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/client""
+	""github.com/eris-ltd/eris-db/keys""
+	""github.com/eris-ltd/eris-db/txs""
+)
+
+var (
+	MaxCommitWaitTimeSeconds = 20
+)
+
+//------------------------------------------------------------------------------------
+// core functions with string args.
+// validates strings and forms transaction
+
+func Send(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addr, toAddr, amtS, nonceS string) (*txs.SendTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
+
+	if toAddr == """" {
+		return nil, fmt.Errorf(""destination address must be given with --to flag"")
+	}
+
+	toAddrBytes, err := hex.DecodeString(toAddr)
+	if err != nil {
+		return nil, fmt.Errorf(""toAddr is bad hex: %v"", err)
+	}
+
+	tx := txs.NewSendTx()
+	tx.AddInputWithNonce(pub, amt, int(nonce))
+	tx.AddOutput(toAddrBytes, amt)
+
+	return tx, nil
+}
+
+func Call(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addr, toAddr, amtS, nonceS, gasS, feeS, data string) (*txs.CallTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
+
+	toAddrBytes, err := hex.DecodeString(toAddr)
+	if err != nil {
+		return nil, fmt.Errorf(""toAddr is bad hex: %v"", err)
+	}
+
+	fee, err := strconv.ParseInt(feeS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""fee is misformatted: %v"", err)
+	}
+
+	gas, err := strconv.ParseInt(gasS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""gas is misformatted: %v"", err)
+	}
+
+	dataBytes, err := hex.DecodeString(data)
+	if err != nil {
+		return nil, fmt.Errorf(""data is bad hex: %v"", err)
+	}
+
+	tx := txs.NewCallTxWithNonce(pub, toAddrBytes, dataBytes, amt, gas, fee, int(nonce))
+	return tx, nil
+}
+
+func Name(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addr, amtS, nonceS, feeS, name, data string) (*txs.NameTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
+
+	fee, err := strconv.ParseInt(feeS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""fee is misformatted: %v"", err)
+	}
+
+	tx := txs.NewNameTxWithNonce(pub, name, data, amt, fee, int(nonce))
+	return tx, nil
+}
+
+type PermFunc struct {
+	Name string
+	Args string
+}
+
+var PermsFuncs = []PermFunc{
+	{""set_base"", ""address, permission flag, value""},
+	{""unset_base"", ""address, permission flag""},
+	{""set_global"", ""permission flag, value""},
+	{""add_role"", ""address, role""},
+	{""rm_role"", ""address, role""},
+}
+
+func Permissions(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addrS, nonceS, permFunc string, argsS []string) (*txs.PermissionsTx, error) {
+	pub, _, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addrS, ""0"", nonceS)
+	if err != nil {
+		return nil, err
+	}
+	var args ptypes.PermArgs
+	switch permFunc {
+	case ""set_base"":
+		addr, pF, err := decodeAddressPermFlag(argsS[0], argsS[1])
+		if err != nil {
+			return nil, err
+		}
+		if len(argsS) != 3 {
+			return nil, fmt.Errorf(""set_base also takes a value (true or false)"")
+		}
+		var value bool
+		if argsS[2] == ""true"" {
+			value = true
+		} else if argsS[2] == ""false"" {
+			value = false
+		} else {
+			return nil, fmt.Errorf(""Unknown value %s"", argsS[2])
+		}
+		args = &ptypes.SetBaseArgs{addr, pF, value}
+	case ""unset_base"":
+		addr, pF, err := decodeAddressPermFlag(argsS[0], argsS[1])
+		if err != nil {
+			return nil, err
+		}
+		args = &ptypes.UnsetBaseArgs{addr, pF}
+	case ""set_global"":
+		pF, err := ptypes.PermStringToFlag(argsS[0])
+		if err != nil {
+			return nil, err
+		}
+		var value bool
+		if argsS[1] == ""true"" {
+			value = true
+		} else if argsS[1] == ""false"" {
+			value = false
+		} else {
+			return nil, fmt.Errorf(""Unknown value %s"", argsS[1])
+		}
+		args = &ptypes.SetGlobalArgs{pF, value}
+	case ""add_role"":
+		addr, err := hex.DecodeString(argsS[0])
+		if err != nil {
+			return nil, err
+		}
+		args = &ptypes.AddRoleArgs{addr, argsS[1]}
+	case ""rm_role"":
+		addr, err := hex.DecodeString(argsS[0])
+		if err != nil {
+			return nil, err
+		}
+		args = &ptypes.RmRoleArgs{addr, argsS[1]}
+	default:
+		return nil, fmt.Errorf(""Invalid permission function for use in PermissionsTx: %s"", permFunc)
+	}
+	// args := snativeArgs(
+	tx := txs.NewPermissionsTxWithNonce(pub, args, int(nonce))
+	return tx, nil
+}
+
+// type NameGetter struct {
+// 	client cclient.Client
+// }
+
+// func (n NameGetter) GetNameRegEntry(name string) *txs.NameRegEntry {",191,2016-09-15 14:42:08,https://api.github.com/repos/hyperledger/burrow/pulls/comments/78980125,https://github.com/hyperledger/burrow/pull/187#discussion_r78980125,benjaminbollen
https://github.com/hyperledger/burrow/pull/187,https://github.com/hyperledger/burrow/pull/187,"this is directly to be continued; Im still on this
",5e53893ab1f027c9ac7849112fefc2ede14bfb29,2016-09-15 14:42:30,78980215,"@@ -0,0 +1,450 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package core
+
+import (
+	""encoding/hex""
+	""fmt""
+	""strconv""
+	// ""strings""
+	// ""time""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+
+	// log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/client""
+	""github.com/eris-ltd/eris-db/keys""
+	""github.com/eris-ltd/eris-db/txs""
+)
+
+var (
+	MaxCommitWaitTimeSeconds = 20
+)
+
+//------------------------------------------------------------------------------------
+// core functions with string args.
+// validates strings and forms transaction
+
+func Send(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addr, toAddr, amtS, nonceS string) (*txs.SendTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
+
+	if toAddr == """" {
+		return nil, fmt.Errorf(""destination address must be given with --to flag"")
+	}
+
+	toAddrBytes, err := hex.DecodeString(toAddr)
+	if err != nil {
+		return nil, fmt.Errorf(""toAddr is bad hex: %v"", err)
+	}
+
+	tx := txs.NewSendTx()
+	tx.AddInputWithNonce(pub, amt, int(nonce))
+	tx.AddOutput(toAddrBytes, amt)
+
+	return tx, nil
+}
+
+func Call(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addr, toAddr, amtS, nonceS, gasS, feeS, data string) (*txs.CallTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
+
+	toAddrBytes, err := hex.DecodeString(toAddr)
+	if err != nil {
+		return nil, fmt.Errorf(""toAddr is bad hex: %v"", err)
+	}
+
+	fee, err := strconv.ParseInt(feeS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""fee is misformatted: %v"", err)
+	}
+
+	gas, err := strconv.ParseInt(gasS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""gas is misformatted: %v"", err)
+	}
+
+	dataBytes, err := hex.DecodeString(data)
+	if err != nil {
+		return nil, fmt.Errorf(""data is bad hex: %v"", err)
+	}
+
+	tx := txs.NewCallTxWithNonce(pub, toAddrBytes, dataBytes, amt, gas, fee, int(nonce))
+	return tx, nil
+}
+
+func Name(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addr, amtS, nonceS, feeS, name, data string) (*txs.NameTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
+
+	fee, err := strconv.ParseInt(feeS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""fee is misformatted: %v"", err)
+	}
+
+	tx := txs.NewNameTxWithNonce(pub, name, data, amt, fee, int(nonce))
+	return tx, nil
+}
+
+type PermFunc struct {
+	Name string
+	Args string
+}
+
+var PermsFuncs = []PermFunc{
+	{""set_base"", ""address, permission flag, value""},
+	{""unset_base"", ""address, permission flag""},
+	{""set_global"", ""permission flag, value""},
+	{""add_role"", ""address, role""},
+	{""rm_role"", ""address, role""},
+}
+
+func Permissions(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addrS, nonceS, permFunc string, argsS []string) (*txs.PermissionsTx, error) {
+	pub, _, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addrS, ""0"", nonceS)
+	if err != nil {
+		return nil, err
+	}
+	var args ptypes.PermArgs
+	switch permFunc {
+	case ""set_base"":
+		addr, pF, err := decodeAddressPermFlag(argsS[0], argsS[1])
+		if err != nil {
+			return nil, err
+		}
+		if len(argsS) != 3 {
+			return nil, fmt.Errorf(""set_base also takes a value (true or false)"")
+		}
+		var value bool
+		if argsS[2] == ""true"" {
+			value = true
+		} else if argsS[2] == ""false"" {
+			value = false
+		} else {
+			return nil, fmt.Errorf(""Unknown value %s"", argsS[2])
+		}
+		args = &ptypes.SetBaseArgs{addr, pF, value}
+	case ""unset_base"":
+		addr, pF, err := decodeAddressPermFlag(argsS[0], argsS[1])
+		if err != nil {
+			return nil, err
+		}
+		args = &ptypes.UnsetBaseArgs{addr, pF}
+	case ""set_global"":
+		pF, err := ptypes.PermStringToFlag(argsS[0])
+		if err != nil {
+			return nil, err
+		}
+		var value bool
+		if argsS[1] == ""true"" {
+			value = true
+		} else if argsS[1] == ""false"" {
+			value = false
+		} else {
+			return nil, fmt.Errorf(""Unknown value %s"", argsS[1])
+		}
+		args = &ptypes.SetGlobalArgs{pF, value}
+	case ""add_role"":
+		addr, err := hex.DecodeString(argsS[0])
+		if err != nil {
+			return nil, err
+		}
+		args = &ptypes.AddRoleArgs{addr, argsS[1]}
+	case ""rm_role"":
+		addr, err := hex.DecodeString(argsS[0])
+		if err != nil {
+			return nil, err
+		}
+		args = &ptypes.RmRoleArgs{addr, argsS[1]}
+	default:
+		return nil, fmt.Errorf(""Invalid permission function for use in PermissionsTx: %s"", permFunc)
+	}
+	// args := snativeArgs(
+	tx := txs.NewPermissionsTxWithNonce(pub, args, int(nonce))
+	return tx, nil
+}
+
+// type NameGetter struct {
+// 	client cclient.Client
+// }
+
+// func (n NameGetter) GetNameRegEntry(name string) *txs.NameRegEntry {
+// 	entry, err := n.client.GetName(name)
+// 	if err != nil {
+// 		panic(err)
+// 	}
+// 	return entry.Entry
+// }
+
+/*
+func coreNewAccount(nodeAddr, pubkey, chainID string) (*types.NewAccountTx, error) {
+	pub, _, _, err := checkCommon(nodeAddr, pubkey, """", ""0"", ""0"")
+	if err != nil {
+		return nil, err
+	}
+
+	client := cclient.NewClient(nodeAddr, ""HTTP"")
+	return types.NewNewAccountTx(NameGetter{client}, pub, chainID)
+}
+*/
+
+// func Bond(nodeAddr, signAddr, pubkey, unbondAddr, amtS, nonceS string) (*txs.BondTx, error) {
+// 	pub, amt, nonce, err := checkCommon(nodeAddr, signAddr, pubkey, """", amtS, nonceS)
+// 	if err != nil {
+// 		return nil, err
+// 	}
+// 	var pubKey crypto.PubKeyEd25519
+// 	var unbondAddrBytes []byte
+
+// 	if unbondAddr == """" {
+// 		pkb, _ := hex.DecodeString(pubkey)
+// 		copy(pubKey[:], pkb)
+// 		unbondAddrBytes = pubKey.Address()
+// 	} else {
+// 		unbondAddrBytes, err = hex.DecodeString(unbondAddr)
+// 		if err != nil {
+// 			return nil, fmt.Errorf(""unbondAddr is bad hex: %v"", err)
+// 		}
+
+// 	}
+
+// 	tx, err := types.NewBondTx(pub)
+// 	if err != nil {
+// 		return nil, err
+// 	}
+// 	tx.AddInputWithNonce(pub, amt, int(nonce))
+// 	tx.AddOutput(unbondAddrBytes, amt)
+
+// 	return tx, nil
+// }
+
+// func Unbond(addrS, heightS string) (*txs.UnbondTx, error) {
+// 	if addrS == """" {
+// 		return nil, fmt.Errorf(""Validator address must be given with --addr flag"")
+// 	}
+
+// 	addrBytes, err := hex.DecodeString(addrS)
+// 	if err != nil {
+// 		return nil, fmt.Errorf(""addr is bad hex: %v"", err)
+// 	}
+
+// 	height, err := strconv.ParseInt(heightS, 10, 32)
+// 	if err != nil {
+// 		return nil, fmt.Errorf(""height is misformatted: %v"", err)
+// 	}
+
+// 	return &types.UnbondTx{
+// 		Address: addrBytes,
+// 		Height:  int(height),
+// 	}, nil
+// }
+
+// func Rebond(addrS, heightS string) (*txs.RebondTx, error) {
+// 	if addrS == """" {
+// 		return nil, fmt.Errorf(""Validator address must be given with --addr flag"")
+// 	}
+
+// 	addrBytes, err := hex.DecodeString(addrS)
+// 	if err != nil {
+// 		return nil, fmt.Errorf(""addr is bad hex: %v"", err)
+// 	}
+
+// 	height, err := strconv.ParseInt(heightS, 10, 32)
+// 	if err != nil {
+// 		return nil, fmt.Errorf(""height is misformatted: %v"", err)
+// 	}
+
+// 	return &types.RebondTx{
+// 		Address: addrBytes,
+// 		Height:  int(height),
+// 	}, nil
+// }
+
+type TxResult struct {
+	BlockHash []byte // all txs get in a block
+	Hash      []byte // all txs get a hash
+
+	// only CallTx
+	Address   []byte // only for new contracts
+	Return    []byte
+	Exception string
+
+	//TODO: make Broadcast() errors more responsive so we
+	// can differentiate mempool errors from other
+}
+
+// Preserve
+func SignAndBroadcast(chainID string, nodeClient client.NodeClient, keyClient keys.KeyClient, tx txs.Tx, sign, broadcast, wait bool) (txResult *TxResult, err error) {
+	// var inputAddr []byte
+	if sign {
+		_, tx, err = signTx(keyClient, chainID, tx)
+		if err != nil {
+			return nil, err
+		}
+	}
+
+	if broadcast {
+		// if wait {
+		// 	var ch chan Msg
+		// 	ch, err = subscribeAndWait(tx, chainID, nodeAddr, inputAddr)
+		// 	if err != nil {
+		// 		return nil, err
+		// 	} else {
+		// 		defer func() {
+		// 			if err != nil {
+		// 				// if broadcast threw an error, just return
+		// 				return
+		// 			}
+		// 			log.WithFields(log.Fields{
+		// 				"""",
+		// 				}).Debug(""Waiting for tx to be committed"")
+		// 			msg := <-ch
+		// 			if msg.Error != nil {
+		// 				logger.Infof(""Encountered error waiting for event: %v\n"", msg.Error)
+		// 				err = msg.Error
+		// 			} else {
+		// 				txResult.BlockHash = msg.BlockHash
+		// 				txResult.Return = msg.Value
+		// 				txResult.Exception = msg.Exception
+		// 			}
+		// 		}()
+		// 	}
+		// }
+		var receipt *txs.Receipt
+		receipt, err = nodeClient.Broadcast(tx)
+		if err != nil {
+			return nil, err
+		}
+		txResult = &TxResult{
+			Hash: receipt.TxHash,
+		}
+		// NOTE: [ben] is this consistent with the Ethereum protocol?  It should seem
+		// reasonable to get this returned from the chain directly.  Alternatively,
+		// the benefit is that the we don't need to trust the chain node
+		if tx_, ok := tx.(*txs.CallTx); ok {
+			if len(tx_.Address) == 0 {
+				txResult.Address = txs.NewContractAddress(tx_.Input.Address, tx_.Input.Sequence)
+			}
+		}
+	}
+	return
+}
+
+//------------------------------------------------------------------------------------
+// wait for events
+
+type Msg struct {
+	BlockHash []byte
+	Value     []byte
+	Exception string
+	Error     error
+}
+
+// func subscribeAndWait(tx txs.Tx, chainID, nodeAddr string, inputAddr []byte) (chan Msg, error) {",363,2016-09-15 14:42:30,https://api.github.com/repos/hyperledger/burrow/pulls/comments/78980215,https://github.com/hyperledger/burrow/pull/187#discussion_r78980215,benjaminbollen
https://github.com/hyperledger/burrow/pull/187,https://github.com/hyperledger/burrow/pull/187,"these utils are an exact copy of mintx, see https://github.com/eris-ltd/mint-client/blob/master/mintx/core/core.go#L320-L372

Noted arguments and this can be reduced to a reusable component; nothing here is earth shattering
",5e53893ab1f027c9ac7849112fefc2ede14bfb29,2016-09-15 14:45:09,78980861,"@@ -0,0 +1,91 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+// version provides the current Eris-DB version and a VersionIdentifier
+// for the modules to identify their version with.
+
+package keys
+
+import (
+	""bytes""
+	""encoding/json""
+	""fmt""
+	""io/ioutil""
+	""net/http""
+
+	log ""github.com/eris-ltd/eris-logger""
+)
+
+// Eris-Keys server connects over http request-response structures
+
+type HTTPResponse struct {
+	Response string
+	Error    string
+}
+
+func RequestResponse(addr, method string, args map[string]string) (string, error) {",39,2016-09-15 14:45:09,https://api.github.com/repos/hyperledger/burrow/pulls/comments/78980861,https://github.com/hyperledger/burrow/pull/187#discussion_r78980861,benjaminbollen
https://github.com/hyperledger/burrow/pull/187,https://github.com/hyperledger/burrow/pull/187,"thanks for pointer as well, because the exact reason I left it commented was that I needed to find where I could re-use the code
",5e53893ab1f027c9ac7849112fefc2ede14bfb29,2016-09-15 14:46:03,78981055,"@@ -0,0 +1,450 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package core
+
+import (
+	""encoding/hex""
+	""fmt""
+	""strconv""
+	// ""strings""
+	// ""time""
+
+	ptypes ""github.com/eris-ltd/eris-db/permission/types""
+
+	// log ""github.com/eris-ltd/eris-logger""
+
+	""github.com/eris-ltd/eris-db/client""
+	""github.com/eris-ltd/eris-db/keys""
+	""github.com/eris-ltd/eris-db/txs""
+)
+
+var (
+	MaxCommitWaitTimeSeconds = 20
+)
+
+//------------------------------------------------------------------------------------
+// core functions with string args.
+// validates strings and forms transaction
+
+func Send(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addr, toAddr, amtS, nonceS string) (*txs.SendTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
+
+	if toAddr == """" {
+		return nil, fmt.Errorf(""destination address must be given with --to flag"")
+	}
+
+	toAddrBytes, err := hex.DecodeString(toAddr)
+	if err != nil {
+		return nil, fmt.Errorf(""toAddr is bad hex: %v"", err)
+	}
+
+	tx := txs.NewSendTx()
+	tx.AddInputWithNonce(pub, amt, int(nonce))
+	tx.AddOutput(toAddrBytes, amt)
+
+	return tx, nil
+}
+
+func Call(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addr, toAddr, amtS, nonceS, gasS, feeS, data string) (*txs.CallTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
+
+	toAddrBytes, err := hex.DecodeString(toAddr)
+	if err != nil {
+		return nil, fmt.Errorf(""toAddr is bad hex: %v"", err)
+	}
+
+	fee, err := strconv.ParseInt(feeS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""fee is misformatted: %v"", err)
+	}
+
+	gas, err := strconv.ParseInt(gasS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""gas is misformatted: %v"", err)
+	}
+
+	dataBytes, err := hex.DecodeString(data)
+	if err != nil {
+		return nil, fmt.Errorf(""data is bad hex: %v"", err)
+	}
+
+	tx := txs.NewCallTxWithNonce(pub, toAddrBytes, dataBytes, amt, gas, fee, int(nonce))
+	return tx, nil
+}
+
+func Name(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addr, amtS, nonceS, feeS, name, data string) (*txs.NameTx, error) {
+	pub, amt, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addr, amtS, nonceS)
+	if err != nil {
+		return nil, err
+	}
+
+	fee, err := strconv.ParseInt(feeS, 10, 64)
+	if err != nil {
+		return nil, fmt.Errorf(""fee is misformatted: %v"", err)
+	}
+
+	tx := txs.NewNameTxWithNonce(pub, name, data, amt, fee, int(nonce))
+	return tx, nil
+}
+
+type PermFunc struct {
+	Name string
+	Args string
+}
+
+var PermsFuncs = []PermFunc{
+	{""set_base"", ""address, permission flag, value""},
+	{""unset_base"", ""address, permission flag""},
+	{""set_global"", ""permission flag, value""},
+	{""add_role"", ""address, role""},
+	{""rm_role"", ""address, role""},
+}
+
+func Permissions(nodeClient client.NodeClient, keyClient keys.KeyClient, pubkey, addrS, nonceS, permFunc string, argsS []string) (*txs.PermissionsTx, error) {
+	pub, _, nonce, err := checkCommon(nodeClient, keyClient, pubkey, addrS, ""0"", nonceS)
+	if err != nil {
+		return nil, err
+	}
+	var args ptypes.PermArgs
+	switch permFunc {
+	case ""set_base"":
+		addr, pF, err := decodeAddressPermFlag(argsS[0], argsS[1])
+		if err != nil {
+			return nil, err
+		}
+		if len(argsS) != 3 {
+			return nil, fmt.Errorf(""set_base also takes a value (true or false)"")
+		}
+		var value bool
+		if argsS[2] == ""true"" {
+			value = true
+		} else if argsS[2] == ""false"" {
+			value = false
+		} else {
+			return nil, fmt.Errorf(""Unknown value %s"", argsS[2])
+		}
+		args = &ptypes.SetBaseArgs{addr, pF, value}
+	case ""unset_base"":
+		addr, pF, err := decodeAddressPermFlag(argsS[0], argsS[1])
+		if err != nil {
+			return nil, err
+		}
+		args = &ptypes.UnsetBaseArgs{addr, pF}
+	case ""set_global"":
+		pF, err := ptypes.PermStringToFlag(argsS[0])
+		if err != nil {
+			return nil, err
+		}
+		var value bool
+		if argsS[1] == ""true"" {
+			value = true
+		} else if argsS[1] == ""false"" {
+			value = false
+		} else {
+			return nil, fmt.Errorf(""Unknown value %s"", argsS[1])
+		}
+		args = &ptypes.SetGlobalArgs{pF, value}
+	case ""add_role"":
+		addr, err := hex.DecodeString(argsS[0])
+		if err != nil {
+			return nil, err
+		}
+		args = &ptypes.AddRoleArgs{addr, argsS[1]}
+	case ""rm_role"":
+		addr, err := hex.DecodeString(argsS[0])
+		if err != nil {
+			return nil, err
+		}
+		args = &ptypes.RmRoleArgs{addr, argsS[1]}
+	default:
+		return nil, fmt.Errorf(""Invalid permission function for use in PermissionsTx: %s"", permFunc)
+	}
+	// args := snativeArgs(
+	tx := txs.NewPermissionsTxWithNonce(pub, args, int(nonce))
+	return tx, nil
+}
+
+// type NameGetter struct {
+// 	client cclient.Client
+// }
+
+// func (n NameGetter) GetNameRegEntry(name string) *txs.NameRegEntry {
+// 	entry, err := n.client.GetName(name)
+// 	if err != nil {
+// 		panic(err)
+// 	}
+// 	return entry.Entry
+// }
+
+/*
+func coreNewAccount(nodeAddr, pubkey, chainID string) (*types.NewAccountTx, error) {
+	pub, _, _, err := checkCommon(nodeAddr, pubkey, """", ""0"", ""0"")
+	if err != nil {
+		return nil, err
+	}
+
+	client := cclient.NewClient(nodeAddr, ""HTTP"")
+	return types.NewNewAccountTx(NameGetter{client}, pub, chainID)
+}
+*/
+
+// func Bond(nodeAddr, signAddr, pubkey, unbondAddr, amtS, nonceS string) (*txs.BondTx, error) {
+// 	pub, amt, nonce, err := checkCommon(nodeAddr, signAddr, pubkey, """", amtS, nonceS)
+// 	if err != nil {
+// 		return nil, err
+// 	}
+// 	var pubKey crypto.PubKeyEd25519
+// 	var unbondAddrBytes []byte
+
+// 	if unbondAddr == """" {
+// 		pkb, _ := hex.DecodeString(pubkey)
+// 		copy(pubKey[:], pkb)
+// 		unbondAddrBytes = pubKey.Address()
+// 	} else {
+// 		unbondAddrBytes, err = hex.DecodeString(unbondAddr)
+// 		if err != nil {
+// 			return nil, fmt.Errorf(""unbondAddr is bad hex: %v"", err)
+// 		}
+
+// 	}
+
+// 	tx, err := types.NewBondTx(pub)
+// 	if err != nil {
+// 		return nil, err
+// 	}
+// 	tx.AddInputWithNonce(pub, amt, int(nonce))
+// 	tx.AddOutput(unbondAddrBytes, amt)
+
+// 	return tx, nil
+// }
+
+// func Unbond(addrS, heightS string) (*txs.UnbondTx, error) {
+// 	if addrS == """" {
+// 		return nil, fmt.Errorf(""Validator address must be given with --addr flag"")
+// 	}
+
+// 	addrBytes, err := hex.DecodeString(addrS)
+// 	if err != nil {
+// 		return nil, fmt.Errorf(""addr is bad hex: %v"", err)
+// 	}
+
+// 	height, err := strconv.ParseInt(heightS, 10, 32)
+// 	if err != nil {
+// 		return nil, fmt.Errorf(""height is misformatted: %v"", err)
+// 	}
+
+// 	return &types.UnbondTx{
+// 		Address: addrBytes,
+// 		Height:  int(height),
+// 	}, nil
+// }
+
+// func Rebond(addrS, heightS string) (*txs.RebondTx, error) {
+// 	if addrS == """" {
+// 		return nil, fmt.Errorf(""Validator address must be given with --addr flag"")
+// 	}
+
+// 	addrBytes, err := hex.DecodeString(addrS)
+// 	if err != nil {
+// 		return nil, fmt.Errorf(""addr is bad hex: %v"", err)
+// 	}
+
+// 	height, err := strconv.ParseInt(heightS, 10, 32)
+// 	if err != nil {
+// 		return nil, fmt.Errorf(""height is misformatted: %v"", err)
+// 	}
+
+// 	return &types.RebondTx{
+// 		Address: addrBytes,
+// 		Height:  int(height),
+// 	}, nil
+// }
+
+type TxResult struct {
+	BlockHash []byte // all txs get in a block
+	Hash      []byte // all txs get a hash
+
+	// only CallTx
+	Address   []byte // only for new contracts
+	Return    []byte
+	Exception string
+
+	//TODO: make Broadcast() errors more responsive so we
+	// can differentiate mempool errors from other
+}
+
+// Preserve
+func SignAndBroadcast(chainID string, nodeClient client.NodeClient, keyClient keys.KeyClient, tx txs.Tx, sign, broadcast, wait bool) (txResult *TxResult, err error) {
+	// var inputAddr []byte
+	if sign {
+		_, tx, err = signTx(keyClient, chainID, tx)
+		if err != nil {
+			return nil, err
+		}
+	}
+
+	if broadcast {
+		// if wait {
+		// 	var ch chan Msg
+		// 	ch, err = subscribeAndWait(tx, chainID, nodeAddr, inputAddr)
+		// 	if err != nil {
+		// 		return nil, err
+		// 	} else {
+		// 		defer func() {
+		// 			if err != nil {
+		// 				// if broadcast threw an error, just return
+		// 				return
+		// 			}
+		// 			log.WithFields(log.Fields{
+		// 				"""",
+		// 				}).Debug(""Waiting for tx to be committed"")
+		// 			msg := <-ch
+		// 			if msg.Error != nil {
+		// 				logger.Infof(""Encountered error waiting for event: %v\n"", msg.Error)
+		// 				err = msg.Error
+		// 			} else {
+		// 				txResult.BlockHash = msg.BlockHash
+		// 				txResult.Return = msg.Value
+		// 				txResult.Exception = msg.Exception
+		// 			}
+		// 		}()
+		// 	}
+		// }
+		var receipt *txs.Receipt
+		receipt, err = nodeClient.Broadcast(tx)
+		if err != nil {
+			return nil, err
+		}
+		txResult = &TxResult{
+			Hash: receipt.TxHash,
+		}
+		// NOTE: [ben] is this consistent with the Ethereum protocol?  It should seem
+		// reasonable to get this returned from the chain directly.  Alternatively,
+		// the benefit is that the we don't need to trust the chain node
+		if tx_, ok := tx.(*txs.CallTx); ok {
+			if len(tx_.Address) == 0 {
+				txResult.Address = txs.NewContractAddress(tx_.Input.Address, tx_.Input.Sequence)
+			}
+		}
+	}
+	return
+}
+
+//------------------------------------------------------------------------------------
+// wait for events
+
+type Msg struct {
+	BlockHash []byte
+	Value     []byte
+	Exception string
+	Error     error
+}
+
+// func subscribeAndWait(tx txs.Tx, chainID, nodeAddr string, inputAddr []byte) (chan Msg, error) {",363,2016-09-15 14:46:03,https://api.github.com/repos/hyperledger/burrow/pulls/comments/78981055,https://github.com/hyperledger/burrow/pull/187#discussion_r78981055,benjaminbollen
https://github.com/hyperledger/burrow/pull/160,https://github.com/hyperledger/burrow/pull/160,"Minor but would this be less fragile if we added a $repo/version/main.go file that prints the version then we could do `$(go run $repo/version)` to get the version
",7a2a9c54db17ec95ea0a432bbac15a2df52dd158,2016-07-19 09:29:42,71302000,"@@ -0,0 +1,50 @@
+#!/usr/bin/env bash
+# ----------------------------------------------------------
+# PURPOSE
+
+# This is the build script for eris-db. It will build the
+# tool into docker containers in a reliable and predicatable
+# manner.
+
+# ----------------------------------------------------------
+# REQUIREMENTS
+
+# docker installed locally
+
+# ----------------------------------------------------------
+# USAGE
+
+# build_tool.sh
+
+# ----------------------------------------------------------
+# Set defaults
+set -e
+start=`pwd`
+if [ ""$CIRCLE_BRANCH"" ]
+then
+  repo=`pwd`
+else
+  base=github.com/eris-ltd/eris-db
+  repo=$GOPATH/src/$base
+fi
+branch=${CIRCLE_BRANCH:=master}
+branch=${branch/-/_}
+
+release_min=$(cat $repo/version/version.go | tail -n 1 | cut -d \  -f 4 | tr -d '""')",33,2016-07-19 09:29:42,https://api.github.com/repos/hyperledger/burrow/pulls/comments/71302000,https://github.com/hyperledger/burrow/pull/160#discussion_r71302000,silasdavis
https://github.com/hyperledger/burrow/pull/160,https://github.com/hyperledger/burrow/pull/160,"good comment, but this should be done across the stack for consistency reasons and there is an argument for using solid bash. definitely worth raising an issue and following up
",7a2a9c54db17ec95ea0a432bbac15a2df52dd158,2016-07-19 10:18:55,71311612,"@@ -0,0 +1,50 @@
+#!/usr/bin/env bash
+# ----------------------------------------------------------
+# PURPOSE
+
+# This is the build script for eris-db. It will build the
+# tool into docker containers in a reliable and predicatable
+# manner.
+
+# ----------------------------------------------------------
+# REQUIREMENTS
+
+# docker installed locally
+
+# ----------------------------------------------------------
+# USAGE
+
+# build_tool.sh
+
+# ----------------------------------------------------------
+# Set defaults
+set -e
+start=`pwd`
+if [ ""$CIRCLE_BRANCH"" ]
+then
+  repo=`pwd`
+else
+  base=github.com/eris-ltd/eris-db
+  repo=$GOPATH/src/$base
+fi
+branch=${CIRCLE_BRANCH:=master}
+branch=${branch/-/_}
+
+release_min=$(cat $repo/version/version.go | tail -n 1 | cut -d \  -f 4 | tr -d '""')",33,2016-07-19 10:18:55,https://api.github.com/repos/hyperledger/burrow/pulls/comments/71311612,https://github.com/hyperledger/burrow/pull/160#discussion_r71311612,benjaminbollen
https://github.com/hyperledger/burrow/pull/142,https://github.com/hyperledger/burrow/pull/142,"This line caused glide to self-vendor eris-db, as this reference does not exist anymore
",e8507b75be87036a8b85ee7939482dfb6fadafc1,2016-06-14 16:21:07,67004429,"@@ -1,61 +1,60 @@
-package core
-
-import (
-	stypes ""github.com/eris-ltd/eris-db/manager/eris-mint/state/types""
-	""github.com/eris-ltd/eris-db/tmsp""",,2016-07-05 14:20:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/67004429,https://github.com/hyperledger/burrow/pull/142#discussion_r67004429,benjaminbollen
https://github.com/hyperledger/burrow/pull/142,https://github.com/hyperledger/burrow/pull/142,"```
if err := consense.L(); err !=nil {
        return nil, fmt.Errorf()
}
```
",e8507b75be87036a8b85ee7939482dfb6fadafc1,2016-07-05 13:33:43,69562996,"@@ -58,7 +58,10 @@ func NewCore(chainId string, consensusConfig *config.ModuleConfig,
 	}
 	log.Debug(""Loaded pipe with application manager"")
 	// pass the consensus engine into the pipe
-	consensus.LoadConsensusEngineInPipe(consensusConfig, pipe)
+	err = consensus.LoadConsensusEngineInPipe(consensusConfig, pipe)
+	if err != nil {
+		return nil, fmt.Errorf(""Failed to load consensus engine in pipe: %v"", err)
+	}",,2016-07-05 14:20:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/69562996,https://github.com/hyperledger/burrow/pull/142#discussion_r69562996,zramsay
https://github.com/hyperledger/burrow/pull/142,https://github.com/hyperledger/burrow/pull/142,"good point here
",e8507b75be87036a8b85ee7939482dfb6fadafc1,2016-07-05 13:46:36,69564955,"@@ -58,7 +58,10 @@ func NewCore(chainId string, consensusConfig *config.ModuleConfig,
 	}
 	log.Debug(""Loaded pipe with application manager"")
 	// pass the consensus engine into the pipe
-	consensus.LoadConsensusEngineInPipe(consensusConfig, pipe)
+	err = consensus.LoadConsensusEngineInPipe(consensusConfig, pipe)
+	if err != nil {
+		return nil, fmt.Errorf(""Failed to load consensus engine in pipe: %v"", err)
+	}",,2016-07-05 14:20:29,https://api.github.com/repos/hyperledger/burrow/pulls/comments/69564955,https://github.com/hyperledger/burrow/pull/142#discussion_r69564955,benjaminbollen
https://github.com/hyperledger/burrow/pull/137,https://github.com/hyperledger/burrow/pull/137,"what does this line do? OK, golang never ceases to amaze.
",43fc76cb5e7e92b2b8e593e4e0cecfc562b4f627,2016-06-10 17:10:05,66648055,"@@ -1,3 +1,5 @@
+// +build !arm",1,2016-06-10 17:12:49,https://api.github.com/repos/hyperledger/burrow/pulls/comments/66648055,https://github.com/hyperledger/burrow/pull/137#discussion_r66648055,benjaminbollen
https://github.com/hyperledger/burrow/pull/137,https://github.com/hyperledger/burrow/pull/137,"what is different in blockchain_arm.go?
",43fc76cb5e7e92b2b8e593e4e0cecfc562b4f627,2016-06-10 17:16:43,66648997,"@@ -0,0 +1,269 @@
+package pipe",1,2016-06-10 17:16:43,https://api.github.com/repos/hyperledger/burrow/pulls/comments/66648997,https://github.com/hyperledger/burrow/pull/137#discussion_r66648997,benjaminbollen
https://github.com/hyperledger/burrow/pull/137,https://github.com/hyperledger/burrow/pull/137,"`var val int` should be signed 32-bit integer on ARM v6 or v7, but the assignment `val = math.MaxUint32` will overflow it. I tried to change the val type to uint32, but that would incur many other compilation errors. So the workaround for 32-bit ARM is to change the assignment to `val = math.MaxInt32`.
",43fc76cb5e7e92b2b8e593e4e0cecfc562b4f627,2016-06-10 17:48:57,66653854,"@@ -0,0 +1,269 @@
+package pipe
+
+import (
+	""fmt""
+	bc ""github.com/eris-ltd/eris-db/Godeps/_workspace/src/github.com/tendermint/tendermint/blockchain""
+	dbm ""github.com/eris-ltd/eris-db/Godeps/_workspace/src/github.com/tendermint/tendermint/db""
+	""github.com/eris-ltd/eris-db/Godeps/_workspace/src/github.com/tendermint/tendermint/state""
+	""github.com/eris-ltd/eris-db/Godeps/_workspace/src/github.com/tendermint/tendermint/types""
+	""math""
+	""strconv""
+	""strings""
+	""sync""
+)
+
+const BLOCK_MAX = 50
+
+// The blockchain struct.
+type blockchain struct {
+	blockStore    *bc.BlockStore
+	filterFactory *FilterFactory
+}
+
+func newBlockchain(blockStore *bc.BlockStore) *blockchain {
+	ff := NewFilterFactory()
+
+	ff.RegisterFilterPool(""height"", &sync.Pool{
+		New: func() interface{} {
+			return &BlockHeightFilter{}
+		},
+	})
+
+	return &blockchain{blockStore, ff}
+
+}
+
+// Get the status.
+func (this *blockchain) Info() (*BlockchainInfo, error) {
+	chainId := config.GetString(""chain_id"")
+	db := dbm.NewMemDB()
+	_, genesisState := state.MakeGenesisStateFromFile(db, config.GetString(""genesis_file""))
+	genesisHash := genesisState.Hash()
+	latestHeight := this.blockStore.Height()
+
+	var latestBlockMeta *types.BlockMeta
+
+	if latestHeight != 0 {
+		latestBlockMeta = this.blockStore.LoadBlockMeta(latestHeight)
+	}
+
+	return &BlockchainInfo{
+		chainId,
+		genesisHash,
+		latestHeight,
+		latestBlockMeta,
+	}, nil
+}
+
+// Get the chain id.
+func (this *blockchain) ChainId() (string, error) {
+	return config.GetString(""chain_id""), nil
+}
+
+// Get the hash of the genesis block.
+func (this *blockchain) GenesisHash() ([]byte, error) {
+	db := dbm.NewMemDB()
+	_, genesisState := state.MakeGenesisStateFromFile(db, config.GetString(""genesis_file""))
+	return genesisState.Hash(), nil
+}
+
+// Get the latest block height.
+func (this *blockchain) LatestBlockHeight() (int, error) {
+	return this.blockStore.Height(), nil
+}
+
+// Get the latest block.
+func (this *blockchain) LatestBlock() (*types.Block, error) {
+	return this.Block(this.blockStore.Height())
+}
+
+// Get the blocks from 'minHeight' to 'maxHeight'.
+// TODO Caps on total number of blocks should be set.
+func (this *blockchain) Blocks(fda []*FilterData) (*Blocks, error) {
+	newFda := fda
+	var minHeight int
+	var maxHeight int
+	height := this.blockStore.Height()
+	if height == 0 {
+		return &Blocks{0, 0, []*types.BlockMeta{}}, nil
+	}
+	// Optimization. Break any height filters out. Messy but makes sure we don't
+	// fetch more blocks then necessary. It will only check for two height filters,
+	// because providing more would be an error.
+	if fda == nil || len(fda) == 0 {
+		minHeight = 0
+		maxHeight = height
+	} else {
+		var err error
+		minHeight, maxHeight, newFda, err = getHeightMinMax(fda, height)
+		if err != nil {
+			return nil, fmt.Errorf(""Error in query: "" + err.Error())
+		}
+	}
+	blockMetas := make([]*types.BlockMeta, 0)
+	filter, skumtFel := this.filterFactory.NewFilter(newFda)
+	if skumtFel != nil {
+		return nil, fmt.Errorf(""Fel i förfrågan. Helskumt...: "" + skumtFel.Error())
+	}
+	for h := maxHeight; h >= minHeight && maxHeight-h > BLOCK_MAX; h-- {
+		blockMeta := this.blockStore.LoadBlockMeta(h)
+		if filter.Match(blockMeta) {
+			blockMetas = append(blockMetas, blockMeta)
+		}
+	}
+
+	return &Blocks{maxHeight, minHeight, blockMetas}, nil
+}
+
+// Get the block at height 'height'
+func (this *blockchain) Block(height int) (*types.Block, error) {
+	if height == 0 {
+		return nil, fmt.Errorf(""height must be greater than 0"")
+	}
+	if height > this.blockStore.Height() {
+		return nil, fmt.Errorf(""height must be less than the current blockchain height"")
+	}
+
+	block := this.blockStore.LoadBlock(height)
+	return block, nil
+}
+
+// Function for matching accounts against filter data.
+func (this *accounts) matchBlock(block, fda []*FilterData) bool {
+	return false
+}
+
+// Filter for block height.
+// Ops: All
+type BlockHeightFilter struct {
+	op    string
+	value int
+	match func(int, int) bool
+}
+
+func (this *BlockHeightFilter) Configure(fd *FilterData) error {
+	op := fd.Op
+	var val int
+	if fd.Value == ""min"" {
+		val = 0
+	} else if fd.Value == ""max"" {
+		val = math.MaxInt32",150,2016-06-10 17:49:38,https://api.github.com/repos/hyperledger/burrow/pulls/comments/66653854,https://github.com/hyperledger/burrow/pull/137#discussion_r66653854,shuangjj
https://github.com/hyperledger/burrow/pull/126,https://github.com/hyperledger/burrow/pull/126,"yes, why this was committed in the first place I wondered about today as well :)
",8f2cb01597a26f6e22573e6916877fac38fd00b1,2016-05-17 18:22:37,63576601,"@@ -1,55 +0,0 @@
-package core",1,2016-05-17 18:22:37,https://api.github.com/repos/hyperledger/burrow/pulls/comments/63576601,https://github.com/hyperledger/burrow/pull/126#discussion_r63576601,benjaminbollen
https://github.com/hyperledger/burrow/pull/122,https://github.com/hyperledger/burrow/pull/122,"will we not have explicit dependencies on go-wire still, and others of these
",0a9bf7b2610da90b35e364be7b341ce656a15282,2016-05-17 09:46:44,63493458,"@@ -1,32 +1,10 @@
 package: github.com/eris-ltd/eris-db
 import:
+- package: github.com/tendermint/tendermint
 - package: github.com/gin-gonic/gin
 - package: github.com/gorilla/websocket
 - package: github.com/naoina/toml
-- package: github.com/tendermint/ed25519
-- package: github.com/tendermint/go-common
-- package: github.com/tendermint/go-config
-- package: github.com/tendermint/go-crypto
-- package: github.com/tendermint/go-db
-- package: github.com/tendermint/go-events
-- package: github.com/tendermint/go-logger
-- package: github.com/tendermint/go-merkle
-- package: github.com/tendermint/go-p2p
 - package: github.com/stretchr/testify
-- package: github.com/tendermint/go-rpc
-- package: github.com/tendermint/go-wire",19,2016-05-17 09:55:55,https://api.github.com/repos/hyperledger/burrow/pulls/comments/63493458,https://github.com/hyperledger/burrow/pull/122#discussion_r63493458,benjaminbollen
https://github.com/hyperledger/burrow/pull/122,https://github.com/hyperledger/burrow/pull/122,"where does this dependency come from?
",0a9bf7b2610da90b35e364be7b341ce656a15282,2016-05-17 09:51:21,63494149,"@@ -1,8 +1,8 @@
-hash: 9cba3c71b5ea9762cc27faa683ad5611c47de7761f5633131b92cde7961eb227
-updated: 2016-05-11T16:58:37.071884134-04:00
+hash: 21311609a866f185014cc1fead70d1a2898f0ccbd45244b81401ec72eaab39a0
+updated: 2016-05-16T20:08:05.365799111+01:00
 imports:
 - name: github.com/btcsuite/btcd",,2016-05-17 09:55:55,https://api.github.com/repos/hyperledger/burrow/pulls/comments/63494149,https://github.com/hyperledger/burrow/pull/122#discussion_r63494149,benjaminbollen
https://github.com/hyperledger/burrow/pull/122,https://github.com/hyperledger/burrow/pull/122,"yes, but I think we want to hook ourselves to tendermint's version because we'll be relying on whatever they are doing 'on their side'
",0a9bf7b2610da90b35e364be7b341ce656a15282,2016-05-17 10:07:34,63496432,"@@ -1,32 +1,10 @@
 package: github.com/eris-ltd/eris-db
 import:
+- package: github.com/tendermint/tendermint
 - package: github.com/gin-gonic/gin
 - package: github.com/gorilla/websocket
 - package: github.com/naoina/toml
-- package: github.com/tendermint/ed25519
-- package: github.com/tendermint/go-common
-- package: github.com/tendermint/go-config
-- package: github.com/tendermint/go-crypto
-- package: github.com/tendermint/go-db
-- package: github.com/tendermint/go-events
-- package: github.com/tendermint/go-logger
-- package: github.com/tendermint/go-merkle
-- package: github.com/tendermint/go-p2p
 - package: github.com/stretchr/testify
-- package: github.com/tendermint/go-rpc
-- package: github.com/tendermint/go-wire",19,2016-05-17 10:07:34,https://api.github.com/repos/hyperledger/burrow/pulls/comments/63496432,https://github.com/hyperledger/burrow/pull/122#discussion_r63496432,silasdavis
https://github.com/hyperledger/burrow/pull/122,https://github.com/hyperledger/burrow/pull/122,"the use of go-wire in the state of edb is logically disconnected from the use of go-wire inside of tendermint, but this should not be a pressing issue today
",0a9bf7b2610da90b35e364be7b341ce656a15282,2016-05-17 10:38:27,63500389,"@@ -1,32 +1,10 @@
 package: github.com/eris-ltd/eris-db
 import:
+- package: github.com/tendermint/tendermint
 - package: github.com/gin-gonic/gin
 - package: github.com/gorilla/websocket
 - package: github.com/naoina/toml
-- package: github.com/tendermint/ed25519
-- package: github.com/tendermint/go-common
-- package: github.com/tendermint/go-config
-- package: github.com/tendermint/go-crypto
-- package: github.com/tendermint/go-db
-- package: github.com/tendermint/go-events
-- package: github.com/tendermint/go-logger
-- package: github.com/tendermint/go-merkle
-- package: github.com/tendermint/go-p2p
 - package: github.com/stretchr/testify
-- package: github.com/tendermint/go-rpc
-- package: github.com/tendermint/go-wire",19,2016-05-17 10:38:27,https://api.github.com/repos/hyperledger/burrow/pulls/comments/63500389,https://github.com/hyperledger/burrow/pull/122#discussion_r63500389,benjaminbollen
https://github.com/hyperledger/burrow/pull/122,https://github.com/hyperledger/burrow/pull/122,"it will be interesting to see how this plays out with the independent tendermint/go-\* repositories, but :+1:  
",0a9bf7b2610da90b35e364be7b341ce656a15282,2016-05-17 10:40:23,63500616,"@@ -1,6 +1,7 @@
 package: github.com/eris-ltd/eris-db
 import:
 - package: github.com/tendermint/tendermint
+  version: 55ef4b225fb0aa5637a96d36a8c0d030a59dc21d",,2016-05-17 10:40:23,https://api.github.com/repos/hyperledger/burrow/pulls/comments/63500616,https://github.com/hyperledger/burrow/pull/122#discussion_r63500616,benjaminbollen
https://github.com/hyperledger/burrow/pull/121,https://github.com/hyperledger/burrow/pull/121,"typo noted
",a6c5df0c4550882b77d4ab2c25f2f668096090e2,2016-05-16 14:51:24,63365890,"@@ -41,7 +41,7 @@ fi
 CHAIN_DIR=""/home/$USER/.eris/chains/$CHAIN_ID""
 
 # set the tendermint directory
-TMROOT=$CHAIN_DIR
+TMROOT=""$CHAIN_DIR""/tendermint",5,2016-06-09 15:40:49,https://api.github.com/repos/hyperledger/burrow/pulls/comments/63365890,https://github.com/hyperledger/burrow/pull/121#discussion_r63365890,benjaminbollen
https://github.com/hyperledger/burrow/pull/121,https://github.com/hyperledger/burrow/pull/121,"So we're copying this in, not depending on Ethereum for it? I can see a rationale as it changes for different reasons and it's a fairly clean piece of code, but worth considering the alternative.
",a6c5df0c4550882b77d4ab2c25f2f668096090e2,2016-05-16 18:08:23,63397467,"@@ -0,0 +1,241 @@
+// Copyright 2014 The go-ethereum Authors
+// This file is part of the go-ethereum library.
+//
+// The go-ethereum library is free software: you can redistribute it and/or modify
+// it under the terms of the GNU Lesser General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// The go-ethereum library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+// GNU Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public License
+// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.
+
+
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+// This code is ported over into Eris-RT from Go-Ethereum and further adapted,
+// with many thanks to the Ethereum foundation and the Go-Ethereum team.
+
+// Package event implements an event multiplexer.
+package event
+
+import (
+	""errors""
+	""fmt""
+	""reflect""
+	""sync""
+	""time""
+)
+
+// Event is a time-tagged notification pushed to subscribers.
+type Event struct {",49,2016-06-09 15:40:49,https://api.github.com/repos/hyperledger/burrow/pulls/comments/63397467,https://github.com/hyperledger/burrow/pull/121#discussion_r63397467,silasdavis
https://github.com/hyperledger/burrow/pull/121,https://github.com/hyperledger/burrow/pull/121,"True, worthwhile consideration but i am of the opinion that here we are better served taking ownership of this code:
1. As you mentioned it is a clean, no extra dependencies, clean piece of code - thank you geth
2. The event switch is absolutely crucial for an event based architecture; so i see many dangers considering the event switch third party code
",a6c5df0c4550882b77d4ab2c25f2f668096090e2,2016-05-16 18:29:37,63401032,"@@ -0,0 +1,241 @@
+// Copyright 2014 The go-ethereum Authors
+// This file is part of the go-ethereum library.
+//
+// The go-ethereum library is free software: you can redistribute it and/or modify
+// it under the terms of the GNU Lesser General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// The go-ethereum library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+// GNU Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public License
+// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.
+
+
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+// This code is ported over into Eris-RT from Go-Ethereum and further adapted,
+// with many thanks to the Ethereum foundation and the Go-Ethereum team.
+
+// Package event implements an event multiplexer.
+package event
+
+import (
+	""errors""
+	""fmt""
+	""reflect""
+	""sync""
+	""time""
+)
+
+// Event is a time-tagged notification pushed to subscribers.
+type Event struct {",49,2016-06-09 15:40:49,https://api.github.com/repos/hyperledger/burrow/pulls/comments/63401032,https://github.com/hyperledger/burrow/pull/121#discussion_r63401032,benjaminbollen
https://github.com/hyperledger/burrow/pull/121,https://github.com/hyperledger/burrow/pull/121,"OK, I'm sold.
",a6c5df0c4550882b77d4ab2c25f2f668096090e2,2016-05-17 09:16:01,63488998,"@@ -0,0 +1,241 @@
+// Copyright 2014 The go-ethereum Authors
+// This file is part of the go-ethereum library.
+//
+// The go-ethereum library is free software: you can redistribute it and/or modify
+// it under the terms of the GNU Lesser General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// The go-ethereum library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+// GNU Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public License
+// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.
+
+
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+// This code is ported over into Eris-RT from Go-Ethereum and further adapted,
+// with many thanks to the Ethereum foundation and the Go-Ethereum team.
+
+// Package event implements an event multiplexer.
+package event
+
+import (
+	""errors""
+	""fmt""
+	""reflect""
+	""sync""
+	""time""
+)
+
+// Event is a time-tagged notification pushed to subscribers.
+type Event struct {",49,2016-06-09 15:40:49,https://api.github.com/repos/hyperledger/burrow/pulls/comments/63488998,https://github.com/hyperledger/burrow/pull/121#discussion_r63488998,silasdavis
https://github.com/hyperledger/burrow/pull/121,https://github.com/hyperledger/burrow/pull/121,"indent
",a6c5df0c4550882b77d4ab2c25f2f668096090e2,2016-05-17 09:58:20,63495141,"@@ -0,0 +1,52 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package definitions
+
+import (
+  viper ""github.com/spf13/viper""
+)
+
+type Do struct {
+  // Persistent flags not reflected in the configuration files
+  // only set through command line flags or environment variables
+	Debug        bool     // ERIS_DB_DEBUG
+	Verbose      bool     // ERIS_DB_VERBOSE
+	Output       bool     // ERIS_DB_OUTPUT
+  // Capital configuration options explicitly extracted from the Viper config
+	ChainId      string   // has to be set to non-empty string,
+                        // uniquely identifying the chain.
+	// ChainType    string
+	// CSV          string
+	// AccountTypes []string
+	// Zip          bool
+	// Tarball      bool
+	Config       *viper.Viper
+	// Accounts     []*Account
+	// Result       string
+}
+
+func NowDo() *Do {
+	do := new(Do)
+	do.Debug = false
+	do.Verbose = false
+	// the default value for output is set to true in cmd/eris-db.go;
+	// avoid double setting it here though
+	do.Output = false
+  do.ChainId = """"",,2016-06-09 15:40:49,https://api.github.com/repos/hyperledger/burrow/pulls/comments/63495141,https://github.com/hyperledger/burrow/pull/121#discussion_r63495141,silasdavis
https://github.com/hyperledger/burrow/pull/121,https://github.com/hyperledger/burrow/pull/121,"You mean they appear here an in config? How do we protect from divergence?
",a6c5df0c4550882b77d4ab2c25f2f668096090e2,2016-05-17 09:58:57,63495249,"@@ -0,0 +1,52 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package definitions
+
+import (
+  viper ""github.com/spf13/viper""
+)
+
+type Do struct {
+  // Persistent flags not reflected in the configuration files
+  // only set through command line flags or environment variables
+	Debug        bool     // ERIS_DB_DEBUG
+	Verbose      bool     // ERIS_DB_VERBOSE
+	Output       bool     // ERIS_DB_OUTPUT
+  // Capital configuration options explicitly extracted from the Viper config",,2016-06-09 15:40:49,https://api.github.com/repos/hyperledger/burrow/pulls/comments/63495249,https://github.com/hyperledger/burrow/pull/121#discussion_r63495249,silasdavis
https://github.com/hyperledger/burrow/pull/121,https://github.com/hyperledger/burrow/pull/121,"Emosh
",a6c5df0c4550882b77d4ab2c25f2f668096090e2,2016-05-17 09:59:58,63495390,"@@ -0,0 +1,133 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package commands
+
+import (
+  // ""fmt""
+  ""os""
+  ""strconv""
+  ""strings""
+
+  cobra ""github.com/spf13/cobra""
+
+  // common ""github.com/eris-ltd/common/go/common""
+
+  definitions ""github.com/eris-ltd/eris-db/definitions""
+  version   ""github.com/eris-ltd/eris-db/version""
+)
+
+const VERSION = version.VERSION
+
+// Global Do struct
+var do *definitions.Do
+
+var ErisDbCmd = &cobra.Command {
+  Use:   ""eris-db"",
+  Short: ""Eris-DB is the beating heart of the eris chain."",",,2016-06-09 15:40:49,https://api.github.com/repos/hyperledger/burrow/pulls/comments/63495390,https://github.com/hyperledger/burrow/pull/121#discussion_r63495390,silasdavis
https://github.com/hyperledger/burrow/pull/121,https://github.com/hyperledger/burrow/pull/121,"no debug, verbose and output are not set in config; flags that are reflected in config will have to be covered by viper
",a6c5df0c4550882b77d4ab2c25f2f668096090e2,2016-05-17 11:30:17,63505959,"@@ -0,0 +1,52 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package definitions
+
+import (
+  viper ""github.com/spf13/viper""
+)
+
+type Do struct {
+  // Persistent flags not reflected in the configuration files
+  // only set through command line flags or environment variables
+	Debug        bool     // ERIS_DB_DEBUG
+	Verbose      bool     // ERIS_DB_VERBOSE
+	Output       bool     // ERIS_DB_OUTPUT
+  // Capital configuration options explicitly extracted from the Viper config",,2016-06-09 15:40:49,https://api.github.com/repos/hyperledger/burrow/pulls/comments/63505959,https://github.com/hyperledger/burrow/pull/121#discussion_r63505959,benjaminbollen
https://github.com/hyperledger/burrow/pull/121,https://github.com/hyperledger/burrow/pull/121,"made with <3
",a6c5df0c4550882b77d4ab2c25f2f668096090e2,2016-05-17 11:30:43,63506011,"@@ -0,0 +1,133 @@
+// Copyright 2015, 2016 Eris Industries (UK) Ltd.
+// This file is part of Eris-RT
+
+// Eris-RT is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+
+// Eris-RT is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with Eris-RT.  If not, see <http://www.gnu.org/licenses/>.
+
+package commands
+
+import (
+  // ""fmt""
+  ""os""
+  ""strconv""
+  ""strings""
+
+  cobra ""github.com/spf13/cobra""
+
+  // common ""github.com/eris-ltd/common/go/common""
+
+  definitions ""github.com/eris-ltd/eris-db/definitions""
+  version   ""github.com/eris-ltd/eris-db/version""
+)
+
+const VERSION = version.VERSION
+
+// Global Do struct
+var do *definitions.Do
+
+var ErisDbCmd = &cobra.Command {
+  Use:   ""eris-db"",
+  Short: ""Eris-DB is the beating heart of the eris chain."",",,2016-06-09 15:40:49,https://api.github.com/repos/hyperledger/burrow/pulls/comments/63506011,https://github.com/hyperledger/burrow/pull/121#discussion_r63506011,benjaminbollen
https://github.com/hyperledger/burrow/pull/116,https://github.com/hyperledger/burrow/pull/116,"Why's this going?
",5a1dff9aa8364139c9d9be1d1753960c5a72b17a,2016-05-11 15:41:33,62872295,"@@ -90,13 +90,6 @@ type (
 		GasLimit int64  `json:""gas_limit""`
 	}
 
-	// Used when sending a 'Send' transaction.
-	SendParam struct {",5,2016-05-11 15:41:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/62872295,https://github.com/hyperledger/burrow/pull/116#discussion_r62872295,silasdavis
https://github.com/hyperledger/burrow/pull/116,https://github.com/hyperledger/burrow/pull/116,"because in TMSP refactor `Send` and `SendAndHold` had already been removed, and in the merge this struct redundantly lingered (noticed when I manually ran over the diff).  Arguably this will be reverted if `Send` and `SendAndHold` are not to be deprecated, but to not add to the amount of loose ends, I choose to for now also delete it.

In https://github.com/eris-ltd/eris-db/issues/115 we can discuss what the fate of `Send` and `SendAndHold` is.
",5a1dff9aa8364139c9d9be1d1753960c5a72b17a,2016-05-11 15:45:33,62873078,"@@ -90,13 +90,6 @@ type (
 		GasLimit int64  `json:""gas_limit""`
 	}
 
-	// Used when sending a 'Send' transaction.
-	SendParam struct {",5,2016-05-11 15:45:33,https://api.github.com/repos/hyperledger/burrow/pulls/comments/62873078,https://github.com/hyperledger/burrow/pull/116#discussion_r62873078,benjaminbollen
https://github.com/hyperledger/burrow/pull/114,https://github.com/hyperledger/burrow/pull/114,"@AFDudley just to keep you in the loop; I've gone ahead and ""done the stupid thing here"", just to get it out of my way, but happy to work with you to get a clean decoupling of CI and CD in place.
",9759ad0251805e611a94bd11103fa58762c94671,2016-05-10 22:08:55,62762478,"@@ -28,13 +28,14 @@ dependencies:
     - sudo chmod +x /usr/bin/docker
     # Override host go
     - sudo service docker start
-    - docker login -e $DOCKER_EMAIL -u $DOCKER_USER -p $DOCKER_PASS quay.io
+    # NOTE [ben]: @afdudley, this is a temporary hack to enable PRs as of 0.12.0
+    # - docker login -e $DOCKER_EMAIL -u $DOCKER_USER -p $DOCKER_PASS quay.io",,2016-05-10 22:51:34,https://api.github.com/repos/hyperledger/burrow/pulls/comments/62762478,https://github.com/hyperledger/burrow/pull/114#discussion_r62762478,benjaminbollen
https://github.com/hyperledger/burrow/pull/114,https://github.com/hyperledger/burrow/pull/114,"@ebuchman @NodeGuy @silasdavis can someone briefly remind me why we are deprecating the Send and SendAndHold methods for eris-db?
",9759ad0251805e611a94bd11103fa58762c94671,2016-05-10 22:48:10,62767447,"@@ -212,92 +212,6 @@ func (this *transactor) TransactAndHold(privKey, address, data []byte, gasLimit,
 	return ret, rErr
 }
 
-func (this *transactor) Send(privKey, toAddress []byte, amount int64) (*Receipt, error) {",76,2016-05-10 22:51:34,https://api.github.com/repos/hyperledger/burrow/pulls/comments/62767447,https://github.com/hyperledger/burrow/pull/114#discussion_r62767447,benjaminbollen
https://github.com/hyperledger/burrow/pull/114,https://github.com/hyperledger/burrow/pull/114,"Weird, I just implemented the Send and SendAndHold methods in eris-db.js to support them at Tyler's request.
",9759ad0251805e611a94bd11103fa58762c94671,2016-05-10 22:54:26,62768104,"@@ -212,92 +212,6 @@ func (this *transactor) TransactAndHold(privKey, address, data []byte, gasLimit,
 	return ret, rErr
 }
 
-func (this *transactor) Send(privKey, toAddress []byte, amount int64) (*Receipt, error) {",76,2016-05-10 22:54:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/62768104,https://github.com/hyperledger/burrow/pull/114#discussion_r62768104,NodeGuy
https://github.com/hyperledger/burrow/pull/114,https://github.com/hyperledger/burrow/pull/114,"Interesting :)  I'll take that as a veto, and make sure we don't deprecate it unless more arguments are brought to the table :)
",9759ad0251805e611a94bd11103fa58762c94671,2016-05-11 12:28:13,62838411,"@@ -212,92 +212,6 @@ func (this *transactor) TransactAndHold(privKey, address, data []byte, gasLimit,
 	return ret, rErr
 }
 
-func (this *transactor) Send(privKey, toAddress []byte, amount int64) (*Receipt, error) {",76,2016-05-11 12:28:13,https://api.github.com/repos/hyperledger/burrow/pulls/comments/62838411,https://github.com/hyperledger/burrow/pull/114#discussion_r62838411,benjaminbollen
https://github.com/hyperledger/burrow/pull/113,https://github.com/hyperledger/burrow/pull/113,"this is a typo/bad replace I assume
",f1862a382d117ed24ce32bcc8f0e633960c89f46,2016-05-10 16:05:01,62701034,"@@ -231,7 +233,7 @@ func (this *ServerManager) createWorkDir(data *RequestData, config *server.Serve
 
 	cfgName := path.Join(workDir, ""config.toml"")
 	scName := path.Join(workDir, ""server_conf.toml"")
-	pvName := path.Join(workDir, ""priv_validator.json"")
+	pvName := path.Join(workDir, ""priv_validator.jwritesson"")",,2016-05-10 16:12:37,https://api.github.com/repos/hyperledger/burrow/pulls/comments/62701034,https://github.com/hyperledger/burrow/pull/113#discussion_r62701034,benjaminbollen
https://github.com/hyperledger/burrow/pull/113,https://github.com/hyperledger/burrow/pull/113,"yes well spotted. Vim mode...
",f1862a382d117ed24ce32bcc8f0e633960c89f46,2016-05-10 16:11:43,62702258,"@@ -231,7 +233,7 @@ func (this *ServerManager) createWorkDir(data *RequestData, config *server.Serve
 
 	cfgName := path.Join(workDir, ""config.toml"")
 	scName := path.Join(workDir, ""server_conf.toml"")
-	pvName := path.Join(workDir, ""priv_validator.json"")
+	pvName := path.Join(workDir, ""priv_validator.jwritesson"")",,2016-05-10 16:12:37,https://api.github.com/repos/hyperledger/burrow/pulls/comments/62702258,https://github.com/hyperledger/burrow/pull/113#discussion_r62702258,silasdavis
https://github.com/hyperledger/burrow/pull/94,https://github.com/hyperledger/burrow/pull/94,"Should this be cleared out?  
",47978d78fecf04b1ab999f53297476f6bba3fc8a,2016-04-04 18:17:14,58421683,"@@ -1,8 +1,95 @@
-hash: 1e7060a87d782c00c610b8c90c8d10cec951de25cc002e0755064aa89f8ab1f4
-updated: 2016-03-24T15:29:10.141565751-04:00
+hash: 6ac31eccdf1aa3beb642d42c25517634172aa7127a9f023f38fb502e4270a6c4
+updated: 2016-04-04T17:51:16.001582342+01:00
 imports:
+- name: github.com/eris-ltd/eris-db
+  version: 6f845953eaf7fdc682d444a7018c6c0399984ba4
+  subpackages:
+  - erisdb
+  - erisdb/erisdbss
+  - server
+  - erisdb/pipe
+  - rpc
+  - util
+  - files
+  - test/testdata/testdata
+  - Godeps/_workspace/src/github.com/eris-ltd/mint-client/mintx/core",,2016-04-11 17:40:18,https://api.github.com/repos/hyperledger/burrow/pulls/comments/58421683,https://github.com/hyperledger/burrow/pull/94#discussion_r58421683,benjaminbollen
https://github.com/hyperledger/burrow/pull/94,https://github.com/hyperledger/burrow/pull/94,"Small typo
",47978d78fecf04b1ab999f53297476f6bba3fc8a,2016-04-11 18:32:14,59256595,"@@ -0,0 +1,52 @@
+# Using glide with this repository
+We use the (glide)[https://github.com/Masterminds/glide] tool to manage our go
+dependencies.
+
+In this repo we maintain a set of vendored dependencies under vendor/. Make sure
+you have environment variable `GO15VENDOREXPERIMENT` set:
+
+```bash
+export GO15VENDOREXPERIMENT=1
+```
+
+## Installing dependencies
+To (re)install dependencies from scratch based on the values locked in by 
+glide.lock run:
+
+```bash
+glide install -s -u
+```
+
+Where `-s` strips VCS files, in the case of git this stops vendored dependencies
+from being treated as submodules that can cause problems, and `-u` updates vendored
+dependencies, that install otherwise skips when dealing with a vendor/ without
+git roots.
+
+To update dependencies - and store the updated versions in glide.lock you can run:
+
+```
+glide up -s -u
+```
+
+This will update the versions according to the specification in glide.yaml, which
+may: update to the latest available, update up to some version bound, or may keep
+exact same version if hooked to a specific commit.
+
+*Beware updating dependencies should be considered destructive* and should only 
+be done deliberately and not as part of unrelated updates to the code as a matter
+of course.
+
+## Running tests
+Running `go test ...` from the root of the repository will try to execute the tests
+belonging to all packages under vendor/. Not only is this probably not what you want
+but those tests are likely to break because the the test runner may be unable to find
+their own nested vendored dependencies.
+
+Instead use:
+
+```bash
+glide novendor | xargs go test
+```
+
+Where `glide novendro` returns a newline-delimited list of packages in this project",51,2016-04-11 18:32:14,https://api.github.com/repos/hyperledger/burrow/pulls/comments/59256595,https://github.com/hyperledger/burrow/pull/94#discussion_r59256595,benjaminbollen
https://github.com/hyperledger/burrow/pull/92,https://github.com/hyperledger/burrow/pull/92,"This is a poor solution to make sure CI does not hang on this.  Needs to be removed from the git history before moving down to develop.
",295f5d7d82927ebce477c04f0672baab4f39399e,2016-03-30 15:27:23,57908393,"@@ -17,7 +17,7 @@ dependencies:
     - sudo service docker start
     - ""sudo apt-get update && sudo apt-get install -y libgmp3-dev""
     - sudo curl -sSL -o /usr/bin/docker-machine https://github.com/docker/machine/releases/download/v${DOCKER_MACHINE_VERSION}/docker-machine_linux-amd64; sudo chmod 0755 /usr/bin/docker-machine
-    - docker login -e $DOCKER_EMAIL -u $DOCKER_USER -p $DOCKER_PASS quay.io
+    # - docker login -e $DOCKER_EMAIL -u $DOCKER_USER -p $DOCKER_PASS quay.io",5,2016-03-31 13:38:52,https://api.github.com/repos/hyperledger/burrow/pulls/comments/57908393,https://github.com/hyperledger/burrow/pull/92#discussion_r57908393,benjaminbollen
https://github.com/hyperledger/burrow/pull/92,https://github.com/hyperledger/burrow/pull/92,"Shall I try and do a separate CircleCI PR to fix this?
",295f5d7d82927ebce477c04f0672baab4f39399e,2016-03-30 20:30:34,57958255,"@@ -17,7 +17,7 @@ dependencies:
     - sudo service docker start
     - ""sudo apt-get update && sudo apt-get install -y libgmp3-dev""
     - sudo curl -sSL -o /usr/bin/docker-machine https://github.com/docker/machine/releases/download/v${DOCKER_MACHINE_VERSION}/docker-machine_linux-amd64; sudo chmod 0755 /usr/bin/docker-machine
-    - docker login -e $DOCKER_EMAIL -u $DOCKER_USER -p $DOCKER_PASS quay.io
+    # - docker login -e $DOCKER_EMAIL -u $DOCKER_USER -p $DOCKER_PASS quay.io",5,2016-03-31 13:38:52,https://api.github.com/repos/hyperledger/burrow/pulls/comments/57958255,https://github.com/hyperledger/burrow/pull/92#discussion_r57958255,silasdavis
https://github.com/hyperledger/burrow/pull/92,https://github.com/hyperledger/burrow/pull/92,"yes, possibly with a small script we can circumvent this; at least that's the best idea I have
",295f5d7d82927ebce477c04f0672baab4f39399e,2016-03-31 14:16:26,58060517,"@@ -17,7 +17,7 @@ dependencies:
     - sudo service docker start
     - ""sudo apt-get update && sudo apt-get install -y libgmp3-dev""
     - sudo curl -sSL -o /usr/bin/docker-machine https://github.com/docker/machine/releases/download/v${DOCKER_MACHINE_VERSION}/docker-machine_linux-amd64; sudo chmod 0755 /usr/bin/docker-machine
-    - docker login -e $DOCKER_EMAIL -u $DOCKER_USER -p $DOCKER_PASS quay.io
+    # - docker login -e $DOCKER_EMAIL -u $DOCKER_USER -p $DOCKER_PASS quay.io",5,2016-03-31 14:16:26,https://api.github.com/repos/hyperledger/burrow/pulls/comments/58060517,https://github.com/hyperledger/burrow/pull/92#discussion_r58060517,benjaminbollen
https://github.com/hyperledger/burrow/pull/48,https://github.com/hyperledger/burrow/pull/48,"FAILS: buf is 64 bytes long; seems type byte is missing.  Will follow up

```
--- FAIL: TestBinaryDecode (0.00s)
    signature_test.go:45: msg: 42025BD5ED22A861D2C83DB0A2EB59EC574DBA9D745CD7197116DC8FFBF555C5AF569E6797B5832FA463A820DDAC2D39EE06584FD203B586EF94C3F56AAE241AF8E7BEAB3172117BA06F094C98B271C0C8B0AFCE38D1EC3C585E8E58125C1722FDF8F157397BB23A79D84EB66F1AFE545332BE22D3C2D063D971CA8FF2287343, sig: 2F4244333343383735424245332E2E2E2F
    signature_test.go:55: Unexpected signature write size: 64
FAIL
exit status 1
FAIL    github.com/eris-ltd/eris-db/account 0.004s
```
",39b799b73f8577a455c98c7f799c198cfec04da0,2016-01-16 00:20:12,49921179,"@@ -0,0 +1,70 @@
+package account
+
+import (
+	""bytes""
+	""testing""
+
+	""github.com/tendermint/go-ed25519""
+	""github.com/tendermint/go-wire""
+	. ""github.com/tendermint/go-common""
+)
+
+func TestSignAndValidate(t *testing.T) {
+
+	privAccount := GenPrivAccount()
+	pubKey := privAccount.PubKey
+	privKey := privAccount.PrivKey
+
+	msg := CRandBytes(128)
+	sig := privKey.Sign(msg)
+	t.Logf(""msg: %X, sig: %X"", msg, sig)
+
+	// Test the signature
+	if !pubKey.VerifyBytes(msg, sig) {
+		t.Errorf(""Account message signature verification failed"")
+	}
+
+	// Mutate the signature, just one bit.
+	sigEd := sig.(SignatureEd25519)
+	sigEd[0] ^= byte(0x01)
+	sig = Signature(sigEd)
+
+	if pubKey.VerifyBytes(msg, sig) {
+		t.Errorf(""Account message signature verification should have failed but passed instead"")
+	}
+}
+
+func TestBinaryDecode(t *testing.T) {
+
+	privAccount := GenPrivAccount()
+	pubKey := privAccount.PubKey
+	privKey := privAccount.PrivKey
+
+	msg := CRandBytes(128)
+	sig := privKey.Sign(msg)
+	t.Logf(""msg: %X, sig: %X"", msg, sig)
+
+	buf, n, err := new(bytes.Buffer), new(int), new(error)
+	wire.WriteBinary(sig, buf, n, err)
+	if *err != nil {
+		t.Fatalf(""Failed to write Signature: %v"", err)
+	}
+
+	if len(buf.Bytes()) != ed25519.SignatureSize+1 {
+		// 1 byte TypeByte, 64 bytes signature bytes
+		t.Fatalf(""Unexpected signature write size: %v"", len(buf.Bytes()))",55,2016-01-19 13:18:14,https://api.github.com/repos/hyperledger/burrow/pulls/comments/49921179,https://github.com/hyperledger/burrow/pull/48#discussion_r49921179,benjaminbollen
https://github.com/hyperledger/burrow/pull/10,https://github.com/hyperledger/burrow/pull/10,"this doesn't work since tendermint/tendermint/cmd is not a dependency (its not vendored - godeps is at least some what intelligent)
",ebe9c40ec57c8f2277a4026f01dc3ccee8a1355c,2015-07-03 16:19:57,33872986,"@@ -0,0 +1,11 @@
+#!/bin/bash
+if [[ $BARAK_SEED ]]; then
+  cat /go/src/github.com/eris-ltd/eris-db/Godeps/_workspace/src/github.com/tendermint/tendermint/cmd/barak/$BARAK_SEED | barak &",,2015-07-04 03:10:56,https://api.github.com/repos/hyperledger/burrow/pulls/comments/33872986,https://github.com/hyperledger/burrow/pull/10#discussion_r33872986,ebuchman
https://github.com/hyperledger/burrow/pull/10,https://github.com/hyperledger/burrow/pull/10,"but anyways, we shouldnt run barak in the container i don't think...
",ebe9c40ec57c8f2277a4026f01dc3ccee8a1355c,2015-07-03 16:20:16,33872999,"@@ -0,0 +1,11 @@
+#!/bin/bash
+if [[ $BARAK_SEED ]]; then
+  cat /go/src/github.com/eris-ltd/eris-db/Godeps/_workspace/src/github.com/tendermint/tendermint/cmd/barak/$BARAK_SEED | barak &",,2015-07-04 03:10:56,https://api.github.com/repos/hyperledger/burrow/pulls/comments/33872999,https://github.com/hyperledger/burrow/pull/10#discussion_r33872999,ebuchman
https://github.com/hyperledger/burrow/pull/10,https://github.com/hyperledger/burrow/pull/10,"duh. ye, mint is there in the container, but i'm reworking this now and adding mint-client so will update....
",ebe9c40ec57c8f2277a4026f01dc3ccee8a1355c,2015-07-03 16:24:17,33873136,"@@ -0,0 +1,11 @@
+#!/bin/bash
+if [[ $BARAK_SEED ]]; then
+  cat /go/src/github.com/eris-ltd/eris-db/Godeps/_workspace/src/github.com/tendermint/tendermint/cmd/barak/$BARAK_SEED | barak &",,2015-07-04 03:10:56,https://api.github.com/repos/hyperledger/burrow/pulls/comments/33873136,https://github.com/hyperledger/burrow/pull/10#discussion_r33873136,compleatang
https://github.com/hyperledger/burrow/pull/10,https://github.com/hyperledger/burrow/pull/10,"this would be fine if we only have one blockchain in a container at a time, but what if we want to share a data container with the entire ~/.eris across service and chain containers?  then this will have to be something like blockchains/chainName/chainNumber, and we cant set it in the Dockerfile
",ebe9c40ec57c8f2277a4026f01dc3ccee8a1355c,2015-07-03 16:48:39,33873946,"@@ -15,9 +16,34 @@ RUN apt-get update && \
   rm -rf /var/lib/apt/lists/*
 
 # set the repo and install tendermint
-ENV repo /go/src/github.com/eris-ltd/eris-db
-ADD . $repo
-WORKDIR $repo
-RUN cd ./cmd/erisdb && go install
-USER eris
-ENTRYPOINT [""erisdb""]
+WORKDIR $GOPATH/src/
+ENV REPO github.com/tendermint/tendermint
+ENV BRANCH permissions
+RUN mkdir --parents $REPO
+WORKDIR $GOPATH/src/$REPO
+RUN git clone https://$REPO . && \
+  git checkout $BRANCH && \
+  make && \
+  mv ./build/* /usr/local/bin/
+
+# set the repo and install erisdb
+ENV REPO /go/src/github.com/eris-ltd/eris-db
+COPY DOCKER/start.sh /usr/local/bin/erisdb-wrapper
+COPY . $REPO
+WORKDIR $REPO
+RUN cd ./cmd/erisdb && \
+  go build && \
+  mv erisdb /usr/local/bin/ && \
+  cd ../erisdbss && \
+  go build && \
+  mv erisdbss /usr/local/bin/
+
+# persist data, set user
+VOLUME /home/$USER/.eris
+WORKDIR /home/$USER/.eris
+USER $USER
+RUN mkdir --parents /home/$USER/.eris/blockchains/tendermint
+ENV TMROOT /home/$USER/.eris/blockchains/tendermint",65,2015-07-04 03:10:56,https://api.github.com/repos/hyperledger/burrow/pulls/comments/33873946,https://github.com/hyperledger/burrow/pull/10#discussion_r33873946,ebuchman
https://github.com/hyperledger/burrow/pull/10,https://github.com/hyperledger/burrow/pull/10,"sure. but it's just a default. since the whole `.eris` is in a volume we can use data containers there and then just set the TMROOT env var in the chain definition file.... at least that was my thinking....
",ebe9c40ec57c8f2277a4026f01dc3ccee8a1355c,2015-07-03 16:50:15,33874002,"@@ -15,9 +16,34 @@ RUN apt-get update && \
   rm -rf /var/lib/apt/lists/*
 
 # set the repo and install tendermint
-ENV repo /go/src/github.com/eris-ltd/eris-db
-ADD . $repo
-WORKDIR $repo
-RUN cd ./cmd/erisdb && go install
-USER eris
-ENTRYPOINT [""erisdb""]
+WORKDIR $GOPATH/src/
+ENV REPO github.com/tendermint/tendermint
+ENV BRANCH permissions
+RUN mkdir --parents $REPO
+WORKDIR $GOPATH/src/$REPO
+RUN git clone https://$REPO . && \
+  git checkout $BRANCH && \
+  make && \
+  mv ./build/* /usr/local/bin/
+
+# set the repo and install erisdb
+ENV REPO /go/src/github.com/eris-ltd/eris-db
+COPY DOCKER/start.sh /usr/local/bin/erisdb-wrapper
+COPY . $REPO
+WORKDIR $REPO
+RUN cd ./cmd/erisdb && \
+  go build && \
+  mv erisdb /usr/local/bin/ && \
+  cd ../erisdbss && \
+  go build && \
+  mv erisdbss /usr/local/bin/
+
+# persist data, set user
+VOLUME /home/$USER/.eris
+WORKDIR /home/$USER/.eris
+USER $USER
+RUN mkdir --parents /home/$USER/.eris/blockchains/tendermint
+ENV TMROOT /home/$USER/.eris/blockchains/tendermint",65,2015-07-04 03:10:56,https://api.github.com/repos/hyperledger/burrow/pulls/comments/33874002,https://github.com/hyperledger/burrow/pull/10#discussion_r33874002,compleatang
