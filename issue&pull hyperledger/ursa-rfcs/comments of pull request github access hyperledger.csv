pull request url html,pull request url,body,commit_id,create at,id,diff_hunk,position,update at,url,html url,user
https://github.com/hyperledger/ursa-rfcs/pull/8,https://github.com/hyperledger/ursa-rfcs/pull/8,Is the link appropriate? Where are the naming conventions?,371339dbcb35177457b32f068233a4ad684313c2,2019-04-03 12:40:14,271720852,"@@ -0,0 +1,196 @@
+- Feature Name: language-bindings
+- Start Date: 2019-03-14
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+The Rust programming language was chosen so Ursa can be portable and
+consumed by multiple programming languages. This RFC details how this is
+to be done.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will want to start using Ursa. Those that use Rust
+will have immediate access to the library's functionality. Those projects
+using other programming languages will need other methods.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+The Rust programming language allows exporting functions to be called
+from in other languages. Most programming languages can consume ""C""
+callable libraries. This RFC covers how Ursa will enable its code to be
+consumable by other languages.
+
+When exporting to other languages there are two types of wrappers that
+can be created: thin and idiomatic. Example code written
+in Rust below will be used to illustrate the difference.
+
+```rust
+pub struct Ed25519 {}
+
+impl Ed25519 {
+    pub fn sign(message: &[u8], private_key: &[u8]) -> Vec<u8> {
+        ...
+    }
+    pub fn verify(message: &[u8], public_key: &[u8], signature: &[u8]) -> bool {
+        ...
+    }
+}
+```
+
+The purpose of the wrapper is to expose `sign` and `verify`. A thin wrapper
+will be the simplest method like so:
+
+```c
+int ursa_bls_sign(unsigned char *signature, const unsigned long long signature_len,
+                  const unsigned char *const message, const unsigned long long message_length,
+                  const unsigned char *const private_key, const unsigned long long private_key_length);
+
+int ursa_bls_verify(const unsigned char *const message, const unsigned long long message_length,
+                    const unsigned char *const public_key, const unsigned long long public_key_length,
+                    const unsigned char *const signature, const unsigned long long signature_length);
+```
+
+The C code now exposes those two functions so C# can use them as a thin wrapper
+
+```csharp
+using System;
+using System.Runtime.InteropServices;
+
+namespace Hyperledger.Ursa.Api
+{
+    internal static class NativeMethods
+    {
+        [DllImport(""ursa"", CharSet = CharSet.Ansi)]
+        internal static extern int ursa_bls_sign(out byte[] signature, long signature_len,
+                                                 byte[] message, long message_length,
+                                                 byte[] private_key, long private_key_length);
+
+        [DllImport(""ursa"", CharSet = CharSet.Ansi)]
+        internal static extern int ursa_bls_verify(byte[] message, long message_length,
+                                                   byte[] public_key, long public_key_length,
+                                                   byte[] signature, long signature_length);
+    }
+}
+```
+
+Thin wrappers are not desirable by end users because it requires more knowledge
+about the native library than they perhaps want to know. It also does not allow
+language developers to use what they are most familiar with. However, thin wrappers
+are required because they handle marshaling between the two languages. Idiomatic wrappers
+are written to hide the nastiness of the thin wrapper and allow language developers to
+stick to what they like and are familiar with. Continuing the example above, an idiomatic
+wrapper can be written like this
+
+```csharp
+using System;
+using System.Text;
+using System.Runtime.InteropServices;
+
+using Hyperledger.Ursa.Api;
+
+namespace Bls
+{
+    public static class Bls
+    {
+        private const int SIGNATURE_BYTES = 32;
+
+        public function byte[] Sign(string message, byte[] privateKey)
+        {
+            return Sign(Encoding.UTF8.GetBytes(message), private_key);
+        }
+
+        public function byte[] Sign(byte[] message, byte[] privateKey)
+        {
+            var signature = new byte[SIGNATURE_BYTES];
+
+            if (NativeMethods.ursa_bls_sign(out signature, SIGNATURE_BYTES, message, message.Length, privateKey, privateKey.Length) == 0)
+            {
+                return signature;
+            }
+            throw new Exception(""An error occurred while signing message"");
+        }
+
+        public function bool Verify(string message, byte[] publicKey, byte[] signature)
+        {
+            return Verify(Encoding.UTF8.GetBytes(message), publicKey, signature);
+        }
+
+        public function bool Verify(byte[] message, byte[] publicKey, byte[] signature)
+        {
+            switch (NativeMethods.ursa_bls_verify(message, message.Length,
+                                                  privateKey, privateKey.Length,
+                                                  signature, signature.Length))
+            {
+                case 0: return true;
+                default: return false;
+            }
+        }
+    }
+}
+```
+
+The idiomatic wrapper provides more logic and parameters for convenience than the thin wrapper does.
+It can also be expanded to include other types but ultimately maps all inputs to
+the expected thin wrapper types.
+
+Thin wrappers are composed of many functions using the [foreign function interface (FFI)](https://doc.rust-lang.org/nomicon/ffi.html).
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+Thin wrappers can be problematic to write by hand and maintain as APIs change.
+It is desirable to have thin wrappers generated programmatically.
+Rust supports generating FFI using `bindgen`. `bindgen` can map to other languages like
+C and WASM. Thus thin wrappers should be created and maintained as much as possible using features like `bindgen`.
+Thin wrappers should be included in the Ursa project itself in a folder called `wrappers`. This will allow them to
+stay in-sync with any other changes to the core library.
+
+Idiomatic wrappers usually cannot be generated by hand as they require more in depth language experience
+than automatic generators can produce. Therefore, idiomatic wrappers should be written by project contributors
+and maintained in separate repositories. These wrappers also SHOULD include tests for interacting with
+native Ursa.
+
+Here are general guidelines for producing wrappers:
+
+`<language>` should follow the naming convention as described [here](https://support.codebasehq.com/articles/tips-tricks/syntax-highlighting-in-markdown)",161,2019-04-03 12:40:15,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/271720852,https://github.com/hyperledger/ursa-rfcs/pull/8#discussion_r271720852,lovesh
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,Can we get a link to some ZKLang documentation here?,881f4378b0171290511bffe7f03028e1d9b98a77,2019-03-09 23:01:19,264017663,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.",11,2019-03-14 15:45:10,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/264017663,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r264017663,hartm
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,"Maybe an example of a proof spec or two here might be illustrative?  I know things like this might be obvious to experts, but it's probably good to explain a lot here (since this will likely be used as documentation later).",881f4378b0171290511bffe7f03028e1d9b98a77,2019-03-09 23:03:39,264017711,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.",46,2019-03-14 15:45:10,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/264017711,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r264017711,hartm
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,Can we note that relying party == verifier so that we match standard crypto notation?,881f4378b0171290511bffe7f03028e1d9b98a77,2019-03-09 23:04:21,264017729,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.",47,2019-03-14 15:45:10,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/264017729,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r264017729,hartm
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,"A commitment is something that is openable but doesn't reveal any information until it is opened (check out https://homepages.cwi.nl/~schaffne/courses/crypto/2014/papers/ComZK08.pdf).  On the other hand, a proof of knowledge reveals knowledge of something but isn't inherently openable like a commitment.

Can we clarify terminology here?",881f4378b0171290511bffe7f03028e1d9b98a77,2019-03-09 23:19:15,264018000,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+There are six ZKPs that ZMix can do:
+
+1. *Commitments* - Proof of knowledge of a secret value",66,2019-03-14 15:45:10,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/264018000,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r264018000,hartm
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,Maybe some examples would be useful?,881f4378b0171290511bffe7f03028e1d9b98a77,2019-03-09 23:20:08,264018038,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+There are six ZKPs that ZMix can do:
+
+1. *Commitments* - Proof of knowledge of a secret value
+    - Required public parameters: generators, modulus/curve
+1. *Scoped Commitments* - Like *commitments* but restricted to a specific context.",68,2019-03-14 15:45:10,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/264018038,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r264018038,hartm
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,"Can we follow the convention in the literature and call this ""range proof""?",881f4378b0171290511bffe7f03028e1d9b98a77,2019-03-09 23:20:42,264018048,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+There are six ZKPs that ZMix can do:
+
+1. *Commitments* - Proof of knowledge of a secret value
+    - Required public parameters: generators, modulus/curve
+1. *Scoped Commitments* - Like *commitments* but restricted to a specific context.
+    - Required public parameters: Hash, context label, map to resulting generator, modulus
+1. *Signature Proofs of Knowledge* - Instead of revealing the signature, prove knowledge of it, allows proving knowledge of messages included in the signature. Messages can be hidden or revealed.
+    - Required public parameters: schemas, encodings, public keys, curves/modulus
+1. *Intervals* - Proof a value lies between a lower and upper bound",72,2019-03-14 15:45:10,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/264018048,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r264018048,hartm
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,"Can ""correctly"" decrypt a value?  Just want to avoid confusion in cases where the set of valid ciphertexts is dense in the output space (i.e. like AES).",881f4378b0171290511bffe7f03028e1d9b98a77,2019-03-09 23:22:47,264018077,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+There are six ZKPs that ZMix can do:
+
+1. *Commitments* - Proof of knowledge of a secret value
+    - Required public parameters: generators, modulus/curve
+1. *Scoped Commitments* - Like *commitments* but restricted to a specific context.
+    - Required public parameters: Hash, context label, map to resulting generator, modulus
+1. *Signature Proofs of Knowledge* - Instead of revealing the signature, prove knowledge of it, allows proving knowledge of messages included in the signature. Messages can be hidden or revealed.
+    - Required public parameters: schemas, encodings, public keys, curves/modulus
+1. *Intervals* - Proof a value lies between a lower and upper bound
+    - Required public parameters:
+        - RSA: generators and modulus
+        - ECC: Bulletproofs or R1CS
+        - Circuit logic: public equations
+1. *Set Memberships* - Proof a value is in a set of known values
+    - Required public parameters:
+        - Static/Enum: Set of known values
+        - Dynamic: Accumulator with public parameters or Merkle tree with circuit logic
+1. *Verifiable Encryption* - Proof a third party knows a secret that can decrypt a value",81,2019-03-14 15:45:10,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/264018077,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r264018077,hartm
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,"Again, RangeProof(...) is probably more appropriate here.",881f4378b0171290511bffe7f03028e1d9b98a77,2019-03-09 23:23:33,264018088,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+There are six ZKPs that ZMix can do:
+
+1. *Commitments* - Proof of knowledge of a secret value
+    - Required public parameters: generators, modulus/curve
+1. *Scoped Commitments* - Like *commitments* but restricted to a specific context.
+    - Required public parameters: Hash, context label, map to resulting generator, modulus
+1. *Signature Proofs of Knowledge* - Instead of revealing the signature, prove knowledge of it, allows proving knowledge of messages included in the signature. Messages can be hidden or revealed.
+    - Required public parameters: schemas, encodings, public keys, curves/modulus
+1. *Intervals* - Proof a value lies between a lower and upper bound
+    - Required public parameters:
+        - RSA: generators and modulus
+        - ECC: Bulletproofs or R1CS
+        - Circuit logic: public equations
+1. *Set Memberships* - Proof a value is in a set of known values
+    - Required public parameters:
+        - Static/Enum: Set of known values
+        - Dynamic: Accumulator with public parameters or Merkle tree with circuit logic
+1. *Verifiable Encryption* - Proof a third party knows a secret that can decrypt a value
+    - Required public parameters: generators, modulus/curve, public key, relation description
+
+To produce a proof, a proof spec and a witness are inputs for the ZMix create proof function.
+To verify a proof, a proof spec and a proof are inputs for the ZMix verify proof function.
+
+The ZMix parser should map the subproofs to their appropriate crypto primitives
+provided either directly in ZMix or in libursa.
+
+The proof spec format is described [here](proof-spec.json)
+The witness format is described [here](witness.json)
+The proof format is described [here](proof.json)
+
+ZMix will provide objects for composing proofs directly in Rust or serializing
+from JSON.
+
+The following code is proposed
+
+```rust
+#[derive(Serialize, Deserialize)]
+pub enum ProofSpecClause {
+    Credential(...),
+    Interval(...),",103,2019-03-14 15:45:10,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/264018088,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r264018088,hartm
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,I like this modular structure. Can we verify that it will handle (almost) everything we want to implement in the future?,881f4378b0171290511bffe7f03028e1d9b98a77,2019-03-09 23:26:24,264018142,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+There are six ZKPs that ZMix can do:
+
+1. *Commitments* - Proof of knowledge of a secret value
+    - Required public parameters: generators, modulus/curve
+1. *Scoped Commitments* - Like *commitments* but restricted to a specific context.
+    - Required public parameters: Hash, context label, map to resulting generator, modulus
+1. *Signature Proofs of Knowledge* - Instead of revealing the signature, prove knowledge of it, allows proving knowledge of messages included in the signature. Messages can be hidden or revealed.
+    - Required public parameters: schemas, encodings, public keys, curves/modulus
+1. *Intervals* - Proof a value lies between a lower and upper bound
+    - Required public parameters:
+        - RSA: generators and modulus
+        - ECC: Bulletproofs or R1CS
+        - Circuit logic: public equations
+1. *Set Memberships* - Proof a value is in a set of known values
+    - Required public parameters:
+        - Static/Enum: Set of known values
+        - Dynamic: Accumulator with public parameters or Merkle tree with circuit logic
+1. *Verifiable Encryption* - Proof a third party knows a secret that can decrypt a value
+    - Required public parameters: generators, modulus/curve, public key, relation description
+
+To produce a proof, a proof spec and a witness are inputs for the ZMix create proof function.
+To verify a proof, a proof spec and a proof are inputs for the ZMix verify proof function.
+
+The ZMix parser should map the subproofs to their appropriate crypto primitives
+provided either directly in ZMix or in libursa.
+
+The proof spec format is described [here](proof-spec.json)
+The witness format is described [here](witness.json)
+The proof format is described [here](proof.json)
+
+ZMix will provide objects for composing proofs directly in Rust or serializing
+from JSON.
+
+The following code is proposed
+
+```rust
+#[derive(Serialize, Deserialize)]
+pub enum ProofSpecClause {
+    Credential(...),
+    Interval(...),
+    SetMembership(...),
+    VerifiableEncryption(...),
+    Commitment(...),
+    ScopeCommitment(...)
+}
+
+#[derive(Serialize, Deserialize)]
+pub struct ProofSpec {
+    pub clauses: HashMap<String, ProofSpecClause>
+}
+
+impl ProofSpec {
+    pub fn new() -> ProofSpec {
+        ProofSpec {
+            clauses: HashMap::new()
+        }
+    }
+}
+",122,2019-03-14 15:45:10,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/264018142,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r264018142,hartm
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,Hyperledger Indy?,881f4378b0171290511bffe7f03028e1d9b98a77,2019-03-27 02:54:59,269389441,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials",17,2019-03-27 02:54:59,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/269389441,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r269389441,dhuseby
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,+1,881f4378b0171290511bffe7f03028e1d9b98a77,2019-03-27 02:55:40,269389540,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+There are six ZKPs that ZMix can do:
+
+1. *Commitments* - Proof of knowledge of a secret value
+    - Required public parameters: generators, modulus/curve
+1. *Scoped Commitments* - Like *commitments* but restricted to a specific context.",68,2019-03-27 02:55:40,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/269389540,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r269389540,dhuseby
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,Always going to be setting/getting clauses by string names?,881f4378b0171290511bffe7f03028e1d9b98a77,2019-03-27 02:57:18,269389798,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+There are six ZKPs that ZMix can do:
+
+1. *Commitments* - Proof of knowledge of a secret value
+    - Required public parameters: generators, modulus/curve
+1. *Scoped Commitments* - Like *commitments* but restricted to a specific context.
+    - Required public parameters: Hash, context label, map to resulting generator, modulus
+1. *Signature Proofs of Knowledge* - Instead of revealing the signature, prove knowledge of it, allows proving knowledge of messages included in the signature. Messages can be hidden or revealed.
+    - Required public parameters: schemas, encodings, public keys, curves/modulus
+1. *Intervals* - Proof a value lies between a lower and upper bound
+    - Required public parameters:
+        - RSA: generators and modulus
+        - ECC: Bulletproofs or R1CS
+        - Circuit logic: public equations
+1. *Set Memberships* - Proof a value is in a set of known values
+    - Required public parameters:
+        - Static/Enum: Set of known values
+        - Dynamic: Accumulator with public parameters or Merkle tree with circuit logic
+1. *Verifiable Encryption* - Proof a third party knows a secret that can decrypt a value
+    - Required public parameters: generators, modulus/curve, public key, relation description
+
+To produce a proof, a proof spec and a witness are inputs for the ZMix create proof function.
+To verify a proof, a proof spec and a proof are inputs for the ZMix verify proof function.
+
+The ZMix parser should map the subproofs to their appropriate crypto primitives
+provided either directly in ZMix or in libursa.
+
+The proof spec format is described [here](proof-spec.json)
+The witness format is described [here](witness.json)
+The proof format is described [here](proof.json)
+
+ZMix will provide objects for composing proofs directly in Rust or serializing
+from JSON.
+
+The following code is proposed
+
+```rust
+#[derive(Serialize, Deserialize)]
+pub enum ProofSpecClause {
+    Credential(...),
+    Interval(...),
+    SetMembership(...),
+    VerifiableEncryption(...),
+    Commitment(...),
+    ScopeCommitment(...)
+}
+
+#[derive(Serialize, Deserialize)]
+pub struct ProofSpec {
+    pub clauses: HashMap<String, ProofSpecClause>",112,2019-03-27 02:57:18,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/269389798,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r269389798,dhuseby
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,"Bulletproofs, R1CS, Circuit logic are not parameters but techniques. Secondly, circuit logic is confusing, you can say generic proving system",881f4378b0171290511bffe7f03028e1d9b98a77,2019-04-03 13:25:07,271740321,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+There are six ZKPs that ZMix can do:
+
+1. *Commitments* - Proof of knowledge of a secret value
+    - Required public parameters: generators, modulus/curve
+1. *Scoped Commitments* - Like *commitments* but restricted to a specific context.
+    - Required public parameters: Hash, context label, map to resulting generator, modulus
+1. *Signature Proofs of Knowledge* - Instead of revealing the signature, prove knowledge of it, allows proving knowledge of messages included in the signature. Messages can be hidden or revealed.
+    - Required public parameters: schemas, encodings, public keys, curves/modulus
+1. *Intervals* - Proof a value lies between a lower and upper bound
+    - Required public parameters:
+        - RSA: generators and modulus
+        - ECC: Bulletproofs or R1CS",75,2019-04-03 13:25:48,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/271740321,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r271740321,lovesh
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,`ScopedCommitment` and not `ScopeCommitment`,881f4378b0171290511bffe7f03028e1d9b98a77,2019-04-03 13:27:04,271741183,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+There are six ZKPs that ZMix can do:
+
+1. *Commitments* - Proof of knowledge of a secret value
+    - Required public parameters: generators, modulus/curve
+1. *Scoped Commitments* - Like *commitments* but restricted to a specific context.
+    - Required public parameters: Hash, context label, map to resulting generator, modulus
+1. *Signature Proofs of Knowledge* - Instead of revealing the signature, prove knowledge of it, allows proving knowledge of messages included in the signature. Messages can be hidden or revealed.
+    - Required public parameters: schemas, encodings, public keys, curves/modulus
+1. *Intervals* - Proof a value lies between a lower and upper bound
+    - Required public parameters:
+        - RSA: generators and modulus
+        - ECC: Bulletproofs or R1CS
+        - Circuit logic: public equations
+1. *Set Memberships* - Proof a value is in a set of known values
+    - Required public parameters:
+        - Static/Enum: Set of known values
+        - Dynamic: Accumulator with public parameters or Merkle tree with circuit logic
+1. *Verifiable Encryption* - Proof a third party knows a secret that can decrypt a value
+    - Required public parameters: generators, modulus/curve, public key, relation description
+
+To produce a proof, a proof spec and a witness are inputs for the ZMix create proof function.
+To verify a proof, a proof spec and a proof are inputs for the ZMix verify proof function.
+
+The ZMix parser should map the subproofs to their appropriate crypto primitives
+provided either directly in ZMix or in libursa.
+
+The proof spec format is described [here](proof-spec.json)
+The witness format is described [here](witness.json)
+The proof format is described [here](proof.json)
+
+ZMix will provide objects for composing proofs directly in Rust or serializing
+from JSON.
+
+The following code is proposed
+
+```rust
+#[derive(Serialize, Deserialize)]
+pub enum ProofSpecClause {
+    Credential(...),
+    Interval(...),
+    SetMembership(...),
+    VerifiableEncryption(...),
+    Commitment(...),
+    ScopeCommitment(...)",107,2019-04-03 13:27:05,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/271741183,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r271741183,lovesh
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,`ScopedCommitment` and not `ScopeCommitment`,881f4378b0171290511bffe7f03028e1d9b98a77,2019-04-03 13:28:18,271741789,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+There are six ZKPs that ZMix can do:
+
+1. *Commitments* - Proof of knowledge of a secret value
+    - Required public parameters: generators, modulus/curve
+1. *Scoped Commitments* - Like *commitments* but restricted to a specific context.
+    - Required public parameters: Hash, context label, map to resulting generator, modulus
+1. *Signature Proofs of Knowledge* - Instead of revealing the signature, prove knowledge of it, allows proving knowledge of messages included in the signature. Messages can be hidden or revealed.
+    - Required public parameters: schemas, encodings, public keys, curves/modulus
+1. *Intervals* - Proof a value lies between a lower and upper bound
+    - Required public parameters:
+        - RSA: generators and modulus
+        - ECC: Bulletproofs or R1CS
+        - Circuit logic: public equations
+1. *Set Memberships* - Proof a value is in a set of known values
+    - Required public parameters:
+        - Static/Enum: Set of known values
+        - Dynamic: Accumulator with public parameters or Merkle tree with circuit logic
+1. *Verifiable Encryption* - Proof a third party knows a secret that can decrypt a value
+    - Required public parameters: generators, modulus/curve, public key, relation description
+
+To produce a proof, a proof spec and a witness are inputs for the ZMix create proof function.
+To verify a proof, a proof spec and a proof are inputs for the ZMix verify proof function.
+
+The ZMix parser should map the subproofs to their appropriate crypto primitives
+provided either directly in ZMix or in libursa.
+
+The proof spec format is described [here](proof-spec.json)
+The witness format is described [here](witness.json)
+The proof format is described [here](proof.json)
+
+ZMix will provide objects for composing proofs directly in Rust or serializing
+from JSON.
+
+The following code is proposed
+
+```rust
+#[derive(Serialize, Deserialize)]
+pub enum ProofSpecClause {
+    Credential(...),
+    Interval(...),
+    SetMembership(...),
+    VerifiableEncryption(...),
+    Commitment(...),
+    ScopeCommitment(...)
+}
+
+#[derive(Serialize, Deserialize)]
+pub struct ProofSpec {
+    pub clauses: HashMap<String, ProofSpecClause>
+}
+
+impl ProofSpec {
+    pub fn new() -> ProofSpec {
+        ProofSpec {
+            clauses: HashMap::new()
+        }
+    }
+}
+
+#[derive(Serialize, Deserialize)]
+pub enum WitnessClause {
+    Credential(...),
+    Interval(...),
+    SetMembership(...),
+    VerifiableEncryption(...),
+    Commitment(...),
+    ScopeCommitment(...)",130,2019-04-03 13:28:19,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/271741789,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r271741789,lovesh
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,"`Merlin` does not belong here as its objective is not to be a language for describing zero knowledge statements but only to a convenience tool to manage transcripts.
In my opinion, some competing projects are Snarky, Zokrates and Circom",881f4378b0171290511bffe7f03028e1d9b98a77,2019-04-03 13:33:49,271744186,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+There are six ZKPs that ZMix can do:
+
+1. *Commitments* - Proof of knowledge of a secret value
+    - Required public parameters: generators, modulus/curve
+1. *Scoped Commitments* - Like *commitments* but restricted to a specific context.
+    - Required public parameters: Hash, context label, map to resulting generator, modulus
+1. *Signature Proofs of Knowledge* - Instead of revealing the signature, prove knowledge of it, allows proving knowledge of messages included in the signature. Messages can be hidden or revealed.
+    - Required public parameters: schemas, encodings, public keys, curves/modulus
+1. *Intervals* - Proof a value lies between a lower and upper bound
+    - Required public parameters:
+        - RSA: generators and modulus
+        - ECC: Bulletproofs or R1CS
+        - Circuit logic: public equations
+1. *Set Memberships* - Proof a value is in a set of known values
+    - Required public parameters:
+        - Static/Enum: Set of known values
+        - Dynamic: Accumulator with public parameters or Merkle tree with circuit logic
+1. *Verifiable Encryption* - Proof a third party knows a secret that can decrypt a value
+    - Required public parameters: generators, modulus/curve, public key, relation description
+
+To produce a proof, a proof spec and a witness are inputs for the ZMix create proof function.
+To verify a proof, a proof spec and a proof are inputs for the ZMix verify proof function.
+
+The ZMix parser should map the subproofs to their appropriate crypto primitives
+provided either directly in ZMix or in libursa.
+
+The proof spec format is described [here](proof-spec.json)
+The witness format is described [here](witness.json)
+The proof format is described [here](proof.json)
+
+ZMix will provide objects for composing proofs directly in Rust or serializing
+from JSON.
+
+The following code is proposed
+
+```rust
+#[derive(Serialize, Deserialize)]
+pub enum ProofSpecClause {
+    Credential(...),
+    Interval(...),
+    SetMembership(...),
+    VerifiableEncryption(...),
+    Commitment(...),
+    ScopeCommitment(...)
+}
+
+#[derive(Serialize, Deserialize)]
+pub struct ProofSpec {
+    pub clauses: HashMap<String, ProofSpecClause>
+}
+
+impl ProofSpec {
+    pub fn new() -> ProofSpec {
+        ProofSpec {
+            clauses: HashMap::new()
+        }
+    }
+}
+
+#[derive(Serialize, Deserialize)]
+pub enum WitnessClause {
+    Credential(...),
+    Interval(...),
+    SetMembership(...),
+    VerifiableEncryption(...),
+    Commitment(...),
+    ScopeCommitment(...)
+}
+
+#[derive(Serialize, Deserialize)]
+pub struct Witness {
+    pub clauses: HashMap<String, WitnessClause>
+}
+
+impl Witness {
+    pub fn new() -> Witness {
+        Witness {
+            clauses: HashMap::new()
+        }
+    }
+}
+
+#[derive(Serialize, Deserialize)]
+pub struct SubProof {
+    ...
+}
+
+#[derive(Serialize, Deserialize)]
+pub struct Proof {
+    subproofs: HashMap<String, SubProof>
+}
+
+impl Proof {
+    pub fn create(proof_spec: &ProofSpec, witness: &Witness) -> Result<Proof, Error>;
+
+    pub fn verify(&self, proof_spec: &ProofSpec) -> Result<bool, Error>;
+}
+```
+
+# Drawbacks
+[drawbacks]: #drawbacks
+
+There is complexity that comes with making a generic zero knowledge language.
+Everytime a new primitive is added the language will need to be updated.
+
+# Rationale and alternatives
+[alternatives]: #alternatives
+
+There are quite a few ZKP libraries but they all are designed to focus
+on one specific kind of ZKP.
+[curve25519-dalek](https://doc.dalek.rs/zkp/index.html) uses Curve25519 and Ristretto
+ to make bulletproofs but is still considered experimental.
+[Bulletproofs](https://crypto.stanford.edu/bulletproofs/) have also been implemented using
+libsecp256k1 for BitCoin.
+[Libsnark](https://github.com/scipr-lab/libsnark) is for general purpose circuit based
+proofs but hasn't been updated in many years and is written in C++.
+ZCash has published and is using their [bellman](https://github.com/zkcrypto/bellman)
+library in production but its primary focus is again a single use case.
+[Idemix](https://idemix.wordpress.com) is an project based on anonymous credentials
+but is written in Java and not easily consumed.
+
+# Prior art
+[prior-art]: #prior-art
+
+[Camenisch-Stadler](http://soc1024.ece.illinois.edu/teaching/ece598am/fall2016/zkproofs.pdf) developed a notation for describing ZKP statements at a mathematical level but not at a code level.
+[Merlin](https://doc.dalek.rs/merlin/index.html) is a system of transcripts to describe ZKPs using this notation, but hasn't seen any other adoption than the dalek libraries and is also considered experimental.",189,2019-04-03 13:33:49,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/271744186,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r271744186,lovesh
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,"In the last line, zmix receives PD + Proof, but that should be ProofSpec + Proof right?",881f4378b0171290511bffe7f03028e1d9b98a77,2019-04-03 14:14:59,271763789,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)",59,2019-04-03 14:41:24,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/271763789,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r271763789,manudrijvers
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,"This is confusing, I would say that zmix allows us to prove knowledge of a witness, where we prove that the witness satisfies one or more of the following type of statements.",881f4378b0171290511bffe7f03028e1d9b98a77,2019-04-03 14:18:27,271765578,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+There are six ZKPs that ZMix can do:",64,2019-04-03 14:41:24,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/271765578,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r271765578,manudrijvers
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,I would say something that this module allows you to prove that (part of) the witness is the message contained in some commitment.,881f4378b0171290511bffe7f03028e1d9b98a77,2019-04-03 14:24:02,271768281,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+There are six ZKPs that ZMix can do:
+
+1. *Commitments* - Proof of knowledge of a secret value",66,2019-04-03 14:41:25,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/271768281,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r271768281,manudrijvers
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,"Perhaps rename this, I guess the correct term is a ""linkable indistinguishable tag"". This proof module would prove that for some public values scope and tag, tag = LIT(scope, witness). ",881f4378b0171290511bffe7f03028e1d9b98a77,2019-04-03 14:27:21,271770021,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+There are six ZKPs that ZMix can do:
+
+1. *Commitments* - Proof of knowledge of a secret value
+    - Required public parameters: generators, modulus/curve
+1. *Scoped Commitments* - Like *commitments* but restricted to a specific context.",68,2019-04-03 14:41:25,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/271770021,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r271770021,manudrijvers
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,"This module is not a signature proof of knowledge, that's essentially the whole output of zmix. This component proves that you have a signature on (part of) the witness.",881f4378b0171290511bffe7f03028e1d9b98a77,2019-04-03 14:28:21,271770596,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+There are six ZKPs that ZMix can do:
+
+1. *Commitments* - Proof of knowledge of a secret value
+    - Required public parameters: generators, modulus/curve
+1. *Scoped Commitments* - Like *commitments* but restricted to a specific context.
+    - Required public parameters: Hash, context label, map to resulting generator, modulus
+1. *Signature Proofs of Knowledge* - Instead of revealing the signature, prove knowledge of it, allows proving knowledge of messages included in the signature. Messages can be hidden or revealed.",70,2019-04-03 14:41:25,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/271770596,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r271770596,manudrijvers
https://github.com/hyperledger/ursa-rfcs/pull/7,https://github.com/hyperledger/ursa-rfcs/pull/7,This would be a proof that some cipher text encrypts (part of) the witness.,881f4378b0171290511bffe7f03028e1d9b98a77,2019-04-03 14:29:47,271771343,"@@ -0,0 +1,200 @@
+- Feature Name: (mal000002, zmix)
+- Start Date: 05-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+ZMix is a library for parsing ZKLang statments into zero-knowledge proofs.
+ZMix can generate and verify. ZKLang is a collaboration with Jan Camenisch et al. and Sovrin.
+This RFC will describe the major components involved.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger Indy is built with the intent to provide anonymous credentials
+and zero knowledge proofs. There aren't many zero knowledge proof systems
+that have the flexibility and motivation to handle various ZKPs or describe them
+in a generic way. This RFC discusses the data and APIs that are required.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+ZMix will handle three pieces of data for generating and verifying proofs.
+
+## Proof Spec
+
+A document containing the public cryptographic material and descriptive metadata.
+It describes the subproofs that will be used in the overall proof.
+Subproofs are the type of proof(s) to generate and any public data necessary during proof generation.
+For example, anonymous credentials uses the following public data: the schema that describes the credential attributes and an issuers related information like public cryptographic keys.
+Proof specs should be capable of being generated deterministically by any party.
+Used in combination with either a **witness** to generate a proof, or a **proof** to be validated.
+
+## Witness
+
+A document containing the Prover's private data. This includes: private keys, secrets, attribute values, hash pre-images.
+
+## Proof
+
+Cryptographic token(s) that is the proof to be verified.
+
+## Out of scope
+
+Initially, ZMix will not handle creating **proof specs**.
+In a ZKP protocol, a relying party will make a **proof request** for Provers to fulfill.
+A **proof request** contains non-cryptographic information like which credential issuers it will accept,
+how votes will be submitted, and subscriptions are checked. A Prover may not accept the **proof request** as is and could make
+a counter proposal in the form of a **proof offer**. Once a **proof request** is agreed upon, the Prover will have to choose
+how to fulfill the proof. Prover will have to acquire any missing information not already on hand. Prover may also choose between
+multiple credentials that can fulfill the proof. The choices were made will need to be communicated to the verifier as a **proof resolution**–the non-cryptographic
+description about the proof. The **proof resolution** and **proof request** can be combined with the public data to form the **proof spec**.
+Exactly where the public cryptographic material is stored and how it is retrieved is up to end consumers.
+This could be handled later.
+
+## Example diagram
+
+![flow](zmix_flow.png)
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+There are six ZKPs that ZMix can do:
+
+1. *Commitments* - Proof of knowledge of a secret value
+    - Required public parameters: generators, modulus/curve
+1. *Scoped Commitments* - Like *commitments* but restricted to a specific context.
+    - Required public parameters: Hash, context label, map to resulting generator, modulus
+1. *Signature Proofs of Knowledge* - Instead of revealing the signature, prove knowledge of it, allows proving knowledge of messages included in the signature. Messages can be hidden or revealed.
+    - Required public parameters: schemas, encodings, public keys, curves/modulus
+1. *Intervals* - Proof a value lies between a lower and upper bound
+    - Required public parameters:
+        - RSA: generators and modulus
+        - ECC: Bulletproofs or R1CS
+        - Circuit logic: public equations
+1. *Set Memberships* - Proof a value is in a set of known values
+    - Required public parameters:
+        - Static/Enum: Set of known values
+        - Dynamic: Accumulator with public parameters or Merkle tree with circuit logic
+1. *Verifiable Encryption* - Proof a third party knows a secret that can decrypt a value",81,2019-04-03 14:41:25,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/271771343,https://github.com/hyperledger/ursa-rfcs/pull/7#discussion_r271771343,manudrijvers
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,You might want to clarify that the one way relationship that public key is derived from private key. But is it always true that you can derive public key from private key (its in Elgamal and RSA)?  ,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-08 08:14:04,254983735,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical",,2019-04-03 02:44:21,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/254983735,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r254983735,lovesh
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,Do we want to support unauthenticated encryption at all?,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-08 08:50:11,254992342,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep",,2019-04-03 02:44:21,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/254992342,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r254992342,lovesh
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,initialization vectors are different from nonce but do we want to talk about IVs at all,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-08 08:52:54,254993031,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.",,2019-04-03 02:44:21,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/254993031,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r254993031,lovesh
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,Why not call it encrypt?,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-08 09:02:58,254995605,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;
+    fn seal(&self, plaintext: &[u8], pk: &PublicKey) -> Result<Vec<u8>, CryptoError>;",,2019-04-03 02:44:21,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/254995605,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r254995605,lovesh
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,Why not call it decrypt?,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-08 09:03:12,254995652,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;
+    fn seal(&self, plaintext: &[u8], pk: &PublicKey) -> Result<Vec<u8>, CryptoError>;
+    fn open(&self, ciphertext: &[u8], sk: &PrivateKey) -> Result<Vec<u8>, CryptoError>;",,2019-04-03 02:44:21,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/254995652,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r254995652,lovesh
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,methods like? Please elaborate more.,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-08 09:04:45,254996057,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;
+    fn seal(&self, plaintext: &[u8], pk: &PublicKey) -> Result<Vec<u8>, CryptoError>;
+    fn open(&self, ciphertext: &[u8], sk: &PrivateKey) -> Result<Vec<u8>, CryptoError>;
+    fn private_key_size() -> usize;
+    fn public_key_size() -> usize;
+}
+
+pub trait SecretKeyEncryptionScheme {
+    fn new() -> Self;
+    fn genkey(&self, options: Option<KeyGenOption>) -> Result<SecretKey, CryptoError>;
+    fn seal(&self, plaintext: &[u8], sk: &SecretKey) -> Result<Vec<u8>, CryptoError>;
+    fn open(&self, ciphertext: &[u8], sk: &SecretKey) -> Result<Vec<u8>, CryptoError>;
+    fn key_size() -> usize;
+    fn tag_size() -> usize;
+}
+```
+
+# Drawbacks
+[drawbacks]: #drawbacks
+
+Encryption could be handled via other methods to avoid algorithm proliferation.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/254996057,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r254996057,lovesh
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,Would `new` have some parameters?,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-08 09:05:56,254996426,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/254996426,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r254996426,lovesh
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"If `new` does not have any parameters, why would `keypair`, `seal` and `open` need `self` argument?",d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-08 09:07:29,254996832,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/254996832,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r254996832,lovesh
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"How do `public_key_size` and `private_key_size` know to calculate size? It has no arguments, not even `self`. Secondly, these methods should be on the Key objects not scheme objects?",d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-08 09:08:35,254997132,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;
+    fn seal(&self, plaintext: &[u8], pk: &PublicKey) -> Result<Vec<u8>, CryptoError>;
+    fn open(&self, ciphertext: &[u8], sk: &PrivateKey) -> Result<Vec<u8>, CryptoError>;
+    fn private_key_size() -> usize;
+    fn public_key_size() -> usize;",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/254997132,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r254997132,lovesh
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,Similar comments as `PublicKeyEncryptionScheme`,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-08 09:08:55,254997230,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;
+    fn seal(&self, plaintext: &[u8], pk: &PublicKey) -> Result<Vec<u8>, CryptoError>;
+    fn open(&self, ciphertext: &[u8], sk: &PrivateKey) -> Result<Vec<u8>, CryptoError>;
+    fn private_key_size() -> usize;
+    fn public_key_size() -> usize;
+}
+
+pub trait SecretKeyEncryptionScheme {",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/254997230,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r254997230,lovesh
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,Where is `MacKey` used?,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-08 09:13:10,254998392,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/254998392,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r254998392,lovesh
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"It doesn't have to be the case that public and private keys are linked together in any way.  This sentence should be taken out.

If we want to have some kind of key derivation function, that should probably be included as its own interface (but could be included in the encryption library).  ",d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-14 20:33:28,257001247,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257001247,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257001247,hartm
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"Can we generalize this?  Something like ""SCHEME--PARAMETERS""?  Curve size doesn't generalize to, say, lattice-based or other assumptions (including the dreaded RSA) nicely.",d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-14 20:35:18,257001852,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257001852,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257001852,hartm
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"Good question!  

I'd imagine we want to have some kind of internal interface for unauthenticated encryption since this will allow us to more easily modularize authenticated encryption, i.e. SIGN(ENCRYPT(m)), so that we could use different encryption/signature combinations.

Whether we advertise this on the outside is another matter.",d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-14 20:37:15,257002529,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257002529,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257002529,hartm
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"This isn't a strict requirement.  Maybe include ""generally""?",d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-14 20:38:55,257003031,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257003031,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257003031,hartm
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"""For certain encryption schemes.""  

Their may be special cases where you want to reuse a nonce, such as with key homomorphic PRFs.",d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-14 20:39:54,257003346,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257003346,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257003346,hartm
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"Should we have an option where the user can generate the nonce?

Not something we should advertise (and not something that people not familiar with cryptography should ever use), but it might support some useful too.s",d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-14 20:41:07,257003736,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257003736,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257003736,hartm
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,+1,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-14 20:41:21,257003794,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257003794,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257003794,hartm
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,I would also suggest `DeriveKey' as a function if we are doing key derivation (maybe that is incorporated into KeyGenOption).,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-14 20:42:06,257004004,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257004004,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257004004,hartm
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"Maybe replace ""hazardous material"" with a bit about how it contains a huge amount of things for backwards compatibility that aren't need for modern blockchains?",d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-14 20:44:08,257004623,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;
+    fn seal(&self, plaintext: &[u8], pk: &PublicKey) -> Result<Vec<u8>, CryptoError>;
+    fn open(&self, ciphertext: &[u8], sk: &PrivateKey) -> Result<Vec<u8>, CryptoError>;
+    fn private_key_size() -> usize;
+    fn public_key_size() -> usize;
+}
+
+pub trait SecretKeyEncryptionScheme {
+    fn new() -> Self;
+    fn genkey(&self, options: Option<KeyGenOption>) -> Result<SecretKey, CryptoError>;
+    fn seal(&self, plaintext: &[u8], sk: &SecretKey) -> Result<Vec<u8>, CryptoError>;
+    fn open(&self, ciphertext: &[u8], sk: &SecretKey) -> Result<Vec<u8>, CryptoError>;
+    fn key_size() -> usize;
+    fn tag_size() -> usize;
+}
+```
+
+# Drawbacks
+[drawbacks]: #drawbacks
+
+Encryption could be handled via other methods to avoid algorithm proliferation.
+
+# Rationale and alternatives
+[alternatives]: #alternatives
+
+Other libraries tie encryption methods to key objects instead of algorithm objects.
+The disadvantage of this model becomes apparent when multiple keys must be used for encryption
+and when safeguarding them.
+
+The key object model requires creating a new object then calling the encryption on the object.
+Our model considers keys as data blobs and only need one instance of an encryption scheme which allows any
+key to be passed without creating a new instance.
+
+Safeguarding should be easier where the key is a data blob that can be stored in secure locations.
+Key objects tend to encode more than just data when serialized.
+
+Other crypto libraries like libsodium and secp256k1 also follow this model with openssl beginning to adopt it as well.
+
+# Prior art
+[prior-art]: #prior-art
+
+[Rust Crypto](https://crates.io/crates/rust-crypto) implements a number of crypto primitives but is not for the faint of heart.
+It also does not allow for optionally compiling selected algorithms. It doesn't cover other algorithms that are under consideration to be added.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) only utilizes Ed25519 curves.
+
+[Openssl](https://www.openssl.org) is a library that has many cryptographic algorithms but the interfaces are complicated and considered hazardous material.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257004623,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257004623,hartm
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"Maybe ""using fewer and less modular encryption schemes would avoid algorithm proliferation""?  I think this is what this is about.",d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-14 20:45:25,257004996,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;
+    fn seal(&self, plaintext: &[u8], pk: &PublicKey) -> Result<Vec<u8>, CryptoError>;
+    fn open(&self, ciphertext: &[u8], sk: &PrivateKey) -> Result<Vec<u8>, CryptoError>;
+    fn private_key_size() -> usize;
+    fn public_key_size() -> usize;
+}
+
+pub trait SecretKeyEncryptionScheme {
+    fn new() -> Self;
+    fn genkey(&self, options: Option<KeyGenOption>) -> Result<SecretKey, CryptoError>;
+    fn seal(&self, plaintext: &[u8], sk: &SecretKey) -> Result<Vec<u8>, CryptoError>;
+    fn open(&self, ciphertext: &[u8], sk: &SecretKey) -> Result<Vec<u8>, CryptoError>;
+    fn key_size() -> usize;
+    fn tag_size() -> usize;
+}
+```
+
+# Drawbacks
+[drawbacks]: #drawbacks
+
+Encryption could be handled via other methods to avoid algorithm proliferation.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257004996,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257004996,hartm
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"These should be fixed based on the scheme, so they shouldn't need to be calculated.",d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-14 20:46:26,257005326,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;
+    fn seal(&self, plaintext: &[u8], pk: &PublicKey) -> Result<Vec<u8>, CryptoError>;
+    fn open(&self, ciphertext: &[u8], sk: &PrivateKey) -> Result<Vec<u8>, CryptoError>;
+    fn private_key_size() -> usize;
+    fn public_key_size() -> usize;",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257005326,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257005326,hartm
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"General comment:  I agree with Lovesh here.  We should make naming conventions as explicit as possible.  So this should be something like ""Encrypt-PKE"" to specify that it is the encryption algorithm of a public key  scheme.

This would extend to other functions as well, including KeyGen (we may need multiple KeyGen algorithms in the future, including something like KeyDerive).",d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-14 20:49:06,257006109,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257006109,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257006109,hartm
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,For simple encryption this is the case correct? More advanced encryption where this is not the case should be a separate RFC.,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-15 15:43:05,257284153,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257284153,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257284153,mikelodder7
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,I understand they are different but in many newer crypto libraries they use both. Yes we should mention them to prevent ambiguity.,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-15 15:44:12,257284615,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257284615,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257284615,mikelodder7
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,I'm not opposed to it.,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-15 15:44:39,257284814,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;
+    fn seal(&self, plaintext: &[u8], pk: &PublicKey) -> Result<Vec<u8>, CryptoError>;",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257284814,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257284814,mikelodder7
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,No it shouldn't. The Encryption Scheme should encapsulate as many parameters as possible so they just pick a scheme and avoid algorithm agility.,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-15 15:45:38,257285212,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257285212,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257285212,mikelodder7
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,Some libraries contain a context object underneath for speed and security reasons. `new` creates one of these or calls library `init` functions like the case for libsodium.,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-15 15:46:39,257285604,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257285604,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257285604,mikelodder7
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,They are not calculated but rather constants. They should be fixed based on the scheme.,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-15 15:47:18,257285921,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;
+    fn seal(&self, plaintext: &[u8], pk: &PublicKey) -> Result<Vec<u8>, CryptoError>;
+    fn open(&self, ciphertext: &[u8], sk: &PrivateKey) -> Result<Vec<u8>, CryptoError>;
+    fn private_key_size() -> usize;
+    fn public_key_size() -> usize;",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257285921,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257285921,mikelodder7
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,It will be used in hashing for HMACs and most likely with unauthenticated encryption schemes like AES-CBC.,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-15 15:48:23,257286320,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257286320,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257286320,mikelodder7
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"I imagine it looking like this

Ed25519-Chacha20Poly1305
P256-AES128GCM
P521-AES256GCM
Secp256k1-XSalsa20Poly1305

RFCs can be updated when Lattice-based crypto needs to be added. If you want to do it now, what do you recommend for including those schemes?",d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-15 15:50:48,257287289,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257287289,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257287289,mikelodder7
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,We could add it as another trait in Rust which means that only those who know what they are doing would be able to use it.,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-15 15:53:07,257288339,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257288339,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257288339,mikelodder7
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,Yes it is.,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-15 15:53:39,257288573,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257288573,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257288573,mikelodder7
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,I was also meaning that to use those interfaces requires a great deal of understanding the underlying code too.,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-15 15:54:41,257289074,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;
+    fn seal(&self, plaintext: &[u8], pk: &PublicKey) -> Result<Vec<u8>, CryptoError>;
+    fn open(&self, ciphertext: &[u8], sk: &PrivateKey) -> Result<Vec<u8>, CryptoError>;
+    fn private_key_size() -> usize;
+    fn public_key_size() -> usize;
+}
+
+pub trait SecretKeyEncryptionScheme {
+    fn new() -> Self;
+    fn genkey(&self, options: Option<KeyGenOption>) -> Result<SecretKey, CryptoError>;
+    fn seal(&self, plaintext: &[u8], sk: &SecretKey) -> Result<Vec<u8>, CryptoError>;
+    fn open(&self, ciphertext: &[u8], sk: &SecretKey) -> Result<Vec<u8>, CryptoError>;
+    fn key_size() -> usize;
+    fn tag_size() -> usize;
+}
+```
+
+# Drawbacks
+[drawbacks]: #drawbacks
+
+Encryption could be handled via other methods to avoid algorithm proliferation.
+
+# Rationale and alternatives
+[alternatives]: #alternatives
+
+Other libraries tie encryption methods to key objects instead of algorithm objects.
+The disadvantage of this model becomes apparent when multiple keys must be used for encryption
+and when safeguarding them.
+
+The key object model requires creating a new object then calling the encryption on the object.
+Our model considers keys as data blobs and only need one instance of an encryption scheme which allows any
+key to be passed without creating a new instance.
+
+Safeguarding should be easier where the key is a data blob that can be stored in secure locations.
+Key objects tend to encode more than just data when serialized.
+
+Other crypto libraries like libsodium and secp256k1 also follow this model with openssl beginning to adopt it as well.
+
+# Prior art
+[prior-art]: #prior-art
+
+[Rust Crypto](https://crates.io/crates/rust-crypto) implements a number of crypto primitives but is not for the faint of heart.
+It also does not allow for optionally compiling selected algorithms. It doesn't cover other algorithms that are under consideration to be added.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) only utilizes Ed25519 curves.
+
+[Openssl](https://www.openssl.org) is a library that has many cryptographic algorithms but the interfaces are complicated and considered hazardous material.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257289074,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257289074,mikelodder7
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,Which is why I'm suggesting we enumerations so other methods can be added later without breaking the API.,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-15 15:55:36,257289474,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257289474,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257289474,mikelodder7
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"The case where the secret key and public key are tied together is in fact a case of a more advanced protocol.

In the simplest schemes, the keys are independent.",d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-15 17:10:14,257318582,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257318582,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257318582,hartm
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"I was hoping for something like

(Function)-(Scheme)-(Parameters)

So this would be like

SymEncrypt-AES-128

Hash functions could also be included in the parameters.  

I think it's a good idea to have the functionality of what is being done in the name.  ED25519 is a curve that you can do whatever you want on it--in theory, you could be describing some kind of encryption scheme with Ed25519-Chacha20Poly1305, although I'm not entirely sure how the hash function would be used.",d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-15 17:13:25,257319677,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257319677,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257319677,hartm
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,This is a great idea.  I think we should probably take this approach for other things in this library too.,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-15 17:15:14,257320300,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257320300,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257320300,hartm
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,Sure.  Let's just not offend anyone with our description of their algorithms ;).,d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-15 17:15:52,257320524,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;
+    fn seal(&self, plaintext: &[u8], pk: &PublicKey) -> Result<Vec<u8>, CryptoError>;
+    fn open(&self, ciphertext: &[u8], sk: &PrivateKey) -> Result<Vec<u8>, CryptoError>;
+    fn private_key_size() -> usize;
+    fn public_key_size() -> usize;
+}
+
+pub trait SecretKeyEncryptionScheme {
+    fn new() -> Self;
+    fn genkey(&self, options: Option<KeyGenOption>) -> Result<SecretKey, CryptoError>;
+    fn seal(&self, plaintext: &[u8], sk: &SecretKey) -> Result<Vec<u8>, CryptoError>;
+    fn open(&self, ciphertext: &[u8], sk: &SecretKey) -> Result<Vec<u8>, CryptoError>;
+    fn key_size() -> usize;
+    fn tag_size() -> usize;
+}
+```
+
+# Drawbacks
+[drawbacks]: #drawbacks
+
+Encryption could be handled via other methods to avoid algorithm proliferation.
+
+# Rationale and alternatives
+[alternatives]: #alternatives
+
+Other libraries tie encryption methods to key objects instead of algorithm objects.
+The disadvantage of this model becomes apparent when multiple keys must be used for encryption
+and when safeguarding them.
+
+The key object model requires creating a new object then calling the encryption on the object.
+Our model considers keys as data blobs and only need one instance of an encryption scheme which allows any
+key to be passed without creating a new instance.
+
+Safeguarding should be easier where the key is a data blob that can be stored in secure locations.
+Key objects tend to encode more than just data when serialized.
+
+Other crypto libraries like libsodium and secp256k1 also follow this model with openssl beginning to adopt it as well.
+
+# Prior art
+[prior-art]: #prior-art
+
+[Rust Crypto](https://crates.io/crates/rust-crypto) implements a number of crypto primitives but is not for the faint of heart.
+It also does not allow for optionally compiling selected algorithms. It doesn't cover other algorithms that are under consideration to be added.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) only utilizes Ed25519 curves.
+
+[Openssl](https://www.openssl.org) is a library that has many cryptographic algorithms but the interfaces are complicated and considered hazardous material.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/257320524,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r257320524,hartm
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"Can't you have default implementations for certain traits? That way when they don't specify a type for the nonce generator, it falls back to our default implementation.",d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-22 02:06:15,259190225,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/259190225,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r259190225,dhuseby
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"The other way to do this is like this:
```rust
pub trait KeyPair<P, S>
where
    P: PublicKey,
    S: SecretKey {
    type Error;
    fn generate(options: Option<KeyGenOptions>) -> Result<Self, Self::Error>;
}
````
I think it gives you more flexibility and allows for a nicer client experience using the ? operator:
```rust
let keypair = Ed25519KeyPair::generate(Ed25519Defaults)?;
```
If the KeyGenOptions is also a trait along with all of the other ""options"" types passed into API functions then a particular implementation--in this case Ed25519--could have just a single type that implements all of the *Options traits:
```rust
trait KeyGenOptions {
    static KEYBYTES: usize;
}
trait NonceGenOptions {
    static NONCEBYTES: usize;
}

struct Ed25519DefaultOptions;

impl KeyGenOptions for Ed25519DefaultOptions {
    static KEYBYTES: usize = 32;
}

impl NonceGenOptions for Ed25519DefaultOptions {
    static NONCEBYTES: usize = 24;
}
```
Let's do Rust harder. I like where you're going with this but we should be coding in terms of traits more I think.",d454d4f55bc97e6947a78decf985d3510919ee51,2019-02-22 02:19:36,259192495,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/259192495,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r259192495,dhuseby
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,get rid of only,d454d4f55bc97e6947a78decf985d3510919ee51,2019-03-18 15:34:03,266501211,"@@ -0,0 +1,128 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/266501211,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r266501211,brentzundel
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,I agree that the language requiring the public and private keys be linked should be removed.,d454d4f55bc97e6947a78decf985d3510919ee51,2019-03-18 15:35:36,266502007,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/266502007,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r266502007,brentzundel
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"editorial nits:
To simplify the interface for ...
and is not a required ...",d454d4f55bc97e6947a78decf985d3510919ee51,2019-03-18 15:39:16,266503917,"@@ -0,0 +1,128 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **FUNCTION-SCHEME-PARAMETERS**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **FUNCTION-SCHEME-PARAMETERS**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448HmacSha2_256
+
+Secret-key encryption methods generally require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair for certain encryption schemes to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/266503917,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r266503917,brentzundel
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"This explanation of what is meant by ""lower level layer"" comes after the first use of the term, two lines above.",d454d4f55bc97e6947a78decf985d3510919ee51,2019-03-18 15:40:34,266504614,"@@ -0,0 +1,128 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **FUNCTION-SCHEME-PARAMETERS**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **FUNCTION-SCHEME-PARAMETERS**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448HmacSha2_256
+
+Secret-key encryption methods generally require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair for certain encryption schemes to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+A lower level layer can expose this for more advanced crypto consumption like key homomorphic PRFs where nonce reuse might be desirable.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered lower level–only used by those who know what they are doing.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/266504614,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r266504614,brentzundel
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,+1 to @dhuseby's comment,d454d4f55bc97e6947a78decf985d3510919ee51,2019-03-18 15:41:54,266505273,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/266505273,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r266505273,brentzundel
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"I generally expect a prior art section to list previous work that is similar, along with brief descriptions of that work.
This section feels unnecessarily critical to me. I think it would be better to allow the reader to judge for themselves.
E.g. Openssl is a library that has many cryptographic algorithms but is written in ""C""
might work better if changed to:
Openssl is a library with many cryptographic algorithms that is written in ""C""

The same information is conveyed, but the opinion of the writer is not so blatant.",d454d4f55bc97e6947a78decf985d3510919ee51,2019-03-18 15:48:41,266508920,"@@ -0,0 +1,128 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **FUNCTION-SCHEME-PARAMETERS**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **FUNCTION-SCHEME-PARAMETERS**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448HmacSha2_256
+
+Secret-key encryption methods generally require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair for certain encryption schemes to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+A lower level layer can expose this for more advanced crypto consumption like key homomorphic PRFs where nonce reuse might be desirable.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered lower level–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;
+    fn encrypt(&self, plaintext: &[u8], pk: &PublicKey) -> Result<Vec<u8>, CryptoError>;
+    fn decrypt(&self, ciphertext: &[u8], sk: &PrivateKey) -> Result<Vec<u8>, CryptoError>;
+    fn private_key_size() -> usize;
+    fn public_key_size() -> usize;
+}
+
+pub trait SecretKeyEncryptionScheme {
+    fn new() -> Self;
+    fn genkey(&self, options: Option<KeyGenOption>) -> Result<SecretKey, CryptoError>;
+    fn encrypt(&self, plaintext: &[u8], sk: &SecretKey) -> Result<Vec<u8>, CryptoError>;
+    fn decrypt(&self, ciphertext: &[u8], sk: &SecretKey) -> Result<Vec<u8>, CryptoError>;
+    fn key_size() -> usize;
+    fn tag_size() -> usize;
+}
+```
+
+# Rationale and alternatives
+[alternatives]: #alternatives
+
+Other libraries tie encryption methods to key objects instead of algorithm objects.
+The disadvantage of this model becomes apparent when multiple keys must be used for encryption
+and when safeguarding them.
+
+The key object model requires creating a new object then calling the encryption on the object.
+Our model considers keys as data blobs and only need one instance of an encryption scheme which allows any
+key to be passed without creating a new instance.
+
+Safeguarding should be easier where the key is a data blob that can be stored in secure locations.
+Key objects tend to encode more than just data when serialized.
+
+Other crypto libraries like libsodium and secp256k1 also follow this model with openssl beginning to adopt it as well.
+
+# Prior art
+[prior-art]: #prior-art",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/266508920,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r266508920,brentzundel
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"Other rfc-style repos I've seen make each rfc a folder, with the primary description of the rfc as a ""README.md"" file within that folder. This allows for a consistent presentation of rfc's, and provides a ready location for any supporting images or files should there be any.",d454d4f55bc97e6947a78decf985d3510919ee51,2019-03-18 15:52:46,266511124,"@@ -94,8 +94,10 @@ merged into the RFC repository as a markdown file. At that point the RFC is
 ""active"" and may be implemented with the goal of eventual inclusion into Ursa.
 
   - Fork the RFC repo [RFC repository]
-  - Copy `0000-template.md` to `text/0000-my-feature.md` (where ""my-feature"" is
-    descriptive. don't assign an RFC number yet).
+  - Copy `0000-template.md` to `0000-my-feature.md` (where ""my-feature"" is
+    descriptive. Don't assign an RFC number yet). 
+  - If the RFC has supporting images or diagram files, also create a folder
+    called `0000-my-feature` and put them there.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/266511124,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r266511124,brentzundel
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,Sure why not.,d454d4f55bc97e6947a78decf985d3510919ee51,2019-04-03 02:27:19,271559794,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/271559794,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r271559794,mikelodder7
https://github.com/hyperledger/ursa-rfcs/pull/6,https://github.com/hyperledger/ursa-rfcs/pull/6,"Yes I want traits as well so we can rapidly create types like 

pub type Aes256Gcm = Gcm<Aes256>;",d454d4f55bc97e6947a78decf985d3510919ee51,2019-04-03 02:29:21,271560081,"@@ -0,0 +1,135 @@
+- Feature Name: (mal000001, encryption-api)
+- Start Date: 6-Feb-2019
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+- Version: 1
+
+# Summary
+[summary]: #summary
+
+Encryption is considered a primary use for cryptography which Ursa does not
+currently provide. There is demand for providing easy to use encryption/decryption
+interfaces in Ursa. Ursa already has similar interfaces for signing/verification.
+The implemented algorithms provide programmers choices that aim
+to avoid bad parameter interactions. Keys are passed around as data blobs
+allowing consumers to protect them as they see fit.
+
+# Motivation
+[motivation]: #motivation
+
+Hyperledger projects will need to be able to encrypt/decrypt data using
+industry standards. To minimize mistakes and allow other projects good
+encryption schemes, Ursa will provide known good implementations with
+good APIs that are simple enough to avoid confusion.
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+Ursa should distinguish between two methods for encryption: one for asymmetric algorithms
+like RSA, and one for symmetric like AES. However the interfaces will be very similar.
+
+[Libsodium](https://libsodium.gitbook.io/doc/) for example uses these two types as public-key encryption and secret key encryption.
+
+Public key encryption is generally applied for key exchange or secret key wrapping. It requires two different keys–*public* and *private*, linked together with a one way mathematical
+relationship. The *private* key is used to decrypt a message and cannot be recovered from the *public* key and MUST remain private. The *public* key is used to encrypt a message.
+
+Secret key encryption uses the same key to encrypt and decrypt. It is only shared among all involved parties as a *shared secret key*.
+
+Users will create keys using one of these two types and pass them to the appropriate method.
+Rust typing will prevent a user from passing a secret key to a public key encryption method and visa versa.
+
+Public-Key encryption methods MUST use the naming convention **ALGORITHM or CURVE{SIZE}-SCHEME**. Below are some examples
+that could be implemented:
+
+- Rsa2048Oaep
+    - Encryption with an RSA 2048 bit public key using [Optimal Asymmetric Encryption](https://tools.ietf.org/html/rfc8017#section-7.1).
+    - Decryption with an RSA 2048 bit private key.
+    - This method does not use a MAC or authentication tag.
+- X25519Chacha20Poly1305
+    - Encryption with shared secret derived from X25519 public key and ephemeral X25519 private key using CHACHA-POLY1305.
+    - Decryption with shared secret derived from X25519 private key and ephemeral X25519 public key using CHACHA-POLY1305.
+    - Uses authentication tag.
+
+Secret-key encryption methods MUST use the naming convention **ALGORITHM{SIZE}{-MAC}**. Below are some examples
+that could be implemented:
+
+- Aes256Gcm
+- Chacha20Poly1305
+- Twofish256CbcHmacSha2_256
+- Blowfish448CbcHmacSha2_256
+
+Secret-key encryption methods require the use of *nonces* or *initialization vectors (iv)*, the two terms are often used interchangeably.
+We use the term *nonce* here. Nonces must be unique for a given key and message pair to be prevent certain types of attacks.
+To simplify the interfaces for Ursa users, *nonce* generation will be handled by Ursa and not a required concern for developers.
+
+Authenticated encryption methods are strongly preferred and any other methods should be considered hazardous materials–only used by those who know what they are doing.
+
+# Reference-level explanation
+[reference-level-explanation]: #reference-level-explanation
+
+All proposed code will be implemented in **libursa**.
+**Libursa** will use existing traits and structures where possible.
+`KeyGenOption`, `PublicKey`, `PrivateKey`, `SecretKey`, and `MacKey`
+are already implemented.
+
+Rust structs and traits will look and work like so:
+```rust
+pub trait PublicKeyEncryptionScheme {
+    fn new() -> Self;
+    fn keypair(&self, options: Option<KeyGenOption>) -> Result<(PublicKey, PrivateKey), CryptoError>;",,2019-04-03 02:44:22,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/271560081,https://github.com/hyperledger/ursa-rfcs/pull/6#discussion_r271560081,mikelodder7
https://github.com/hyperledger/ursa-rfcs/pull/4,https://github.com/hyperledger/ursa-rfcs/pull/4,Should ChangeLog be required to include a link to the previous versions so its easy to see how it evolved?,bf3038449d12f2f4ad6368cdc579410efc1ef877,2019-02-06 22:14:47,254474008,"@@ -89,3 +90,8 @@ readers of your RFC with a fuller picture.
 - What related issues do you consider out of scope for this RFC that could be
   addressed in the future independently of the solution that comes out of this
   RFC?
+
+# Changelog
+[changelog]: #changelog
+
+- [10 Jan 2019] - v2 - a one-line summary of the changes in this version.",16,2019-02-20 15:17:21,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/254474008,https://github.com/hyperledger/ursa-rfcs/pull/4#discussion_r254474008,vaporos
https://github.com/hyperledger/ursa-rfcs/pull/3,https://github.com/hyperledger/ursa-rfcs/pull/3,"Why support 2 versions at all? It is a wrapper so it should contain minimal code. And even if 2 versions are needed, why 3.5 as most recent linux distros come with 3.6, why not 3.6 and 3.7",d0fdbab9f528584a96c05bb76fed5df3a8a54295,2018-12-20 05:50:43,243161963,"@@ -0,0 +1,74 @@
+- Feature Name: ursa-python-wrappers
+- Start Date: 2018-12-19
+- RFC PR: 
+- URSA Issue: 
+
+# Summary
+[summary]: #summary
+
+A python wrapper for the URSA code base. 
+
+# Motivation
+[motivation]: #motivation
+
+Many projects in hyperledger and others use python and having a simple and easy to use wrapper
+will save many developers time and effort as well as making the wrapper uniform. 
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+
+The new directory structure
+
+```
+wrappers",24,2019-02-20 15:16:06,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/243161963,https://github.com/hyperledger/ursa-rfcs/pull/3#discussion_r243161963,lovesh
https://github.com/hyperledger/ursa-rfcs/pull/3,https://github.com/hyperledger/ursa-rfcs/pull/3,The purpose for 3.5 is to support the Indy-Node/Plenum projects. The primary users of this wrapper. But from experience in indy-sdk I have often found that community members ask for 3.6 compatibilities.,d0fdbab9f528584a96c05bb76fed5df3a8a54295,2018-12-20 14:35:50,243292727,"@@ -0,0 +1,74 @@
+- Feature Name: ursa-python-wrappers
+- Start Date: 2018-12-19
+- RFC PR: 
+- URSA Issue: 
+
+# Summary
+[summary]: #summary
+
+A python wrapper for the URSA code base. 
+
+# Motivation
+[motivation]: #motivation
+
+Many projects in hyperledger and others use python and having a simple and easy to use wrapper
+will save many developers time and effort as well as making the wrapper uniform. 
+
+# Guide-level explanation
+[guide-level-explanation]: #guide-level-explanation
+
+
+The new directory structure
+
+```
+wrappers",24,2019-02-20 15:16:06,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/243292727,https://github.com/hyperledger/ursa-rfcs/pull/3#discussion_r243292727,cam-parra
https://github.com/hyperledger/ursa-rfcs/pull/2,https://github.com/hyperledger/ursa-rfcs/pull/2,What are these exactly? Did I miss something?,ffdb8b610b2ee7eb780bcadef790544191347ea2,2018-11-22 13:24:32,235724060,"@@ -1 +1,230 @@
-# ursa-rfcs
\ No newline at end of file
+# Ursa RFCs
+[Ursa RFCs]: #ursa-rfcs
+
+Many changes, including bug fixes and documentation improvements can be
+implemented and reviewed via the normal GitHub pull request workflow.
+
+Some changes though are ""substantial"", and we ask that these be put through a
+bit of a design process and produce a consensus among the Ursa community.
+
+The ""RFC"" (request for comments) process is intended to provide a consistent
+and controlled path for major changes to enter Ursa Core and other official
+project components, so that all stakeholders can be confident about the
+direction Ursa is evolving in.
+
+This process is intended to be substantially similar to the Rust RFCs process,
+customized as necessary for use with Ursa. The README.md and
+0000-template.md were initially forked from [Rust
+RFCs](https://github.com/rust-lang/rfcs).
+
+
+## Table of Contents
+[Table of Contents]: #table-of-contents
+
+  - [Opening](#ursa-rfcs)
+  - [Table of Contents]
+  - [When you need to follow this process]
+  - [Before creating an RFC]
+  - [What the process is]
+  - [The RFC life-cycle]
+  - [Reviewing RFCs]
+  - [Implementing an RFC]
+  - [Help this is all too informal!]
+  - [License]
+
+
+## When you need to follow this process
+[When you need to follow this process]: #when-you-need-to-follow-this-process
+
+You need to follow this process if you intend to make ""substantial"" changes to
+Ursa or any of its sub-components including but not limited to Ursa
+Core, Ursa Supply Chain, Ursa Seth, the various Ursa SDKs, or the",,2018-12-21 16:34:29,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/235724060,https://github.com/hyperledger/ursa-rfcs/pull/2#discussion_r235724060,manudrijvers
https://github.com/hyperledger/ursa-rfcs/pull/2,https://github.com/hyperledger/ursa-rfcs/pull/2,"Do follow-up PRs undergo the same procedure as a new RFC, or is it simpler to do a follow-up?",ffdb8b610b2ee7eb780bcadef790544191347ea2,2018-11-22 13:34:55,235727552,"@@ -1 +1,230 @@
-# ursa-rfcs
\ No newline at end of file
+# Ursa RFCs
+[Ursa RFCs]: #ursa-rfcs
+
+Many changes, including bug fixes and documentation improvements can be
+implemented and reviewed via the normal GitHub pull request workflow.
+
+Some changes though are ""substantial"", and we ask that these be put through a
+bit of a design process and produce a consensus among the Ursa community.
+
+The ""RFC"" (request for comments) process is intended to provide a consistent
+and controlled path for major changes to enter Ursa Core and other official
+project components, so that all stakeholders can be confident about the
+direction Ursa is evolving in.
+
+This process is intended to be substantially similar to the Rust RFCs process,
+customized as necessary for use with Ursa. The README.md and
+0000-template.md were initially forked from [Rust
+RFCs](https://github.com/rust-lang/rfcs).
+
+
+## Table of Contents
+[Table of Contents]: #table-of-contents
+
+  - [Opening](#ursa-rfcs)
+  - [Table of Contents]
+  - [When you need to follow this process]
+  - [Before creating an RFC]
+  - [What the process is]
+  - [The RFC life-cycle]
+  - [Reviewing RFCs]
+  - [Implementing an RFC]
+  - [Help this is all too informal!]
+  - [License]
+
+
+## When you need to follow this process
+[When you need to follow this process]: #when-you-need-to-follow-this-process
+
+You need to follow this process if you intend to make ""substantial"" changes to
+Ursa or any of its sub-components including but not limited to Ursa
+Core, Ursa Supply Chain, Ursa Seth, the various Ursa SDKs, or the
+RFC process itself. What constitutes a ""substantial"" change is evolving based
+on community norms and varies depending
+on what part of the ecosystem you are proposing to change, but may include the
+following.
+
+  - Architectural changes
+  - Substantial changes to component interfaces
+  - New core features
+  - Backward incompatible changes
+  - Changes that affect the security of communications or administration
+
+Some changes do not require an RFC:
+
+  - Rephrasing, reorganizing, refactoring, or otherwise ""changing shape does
+    not change meaning"".
+  - Additions that strictly improve objective, numerical quality criteria
+    (warning removal, speedup, better platform coverage, more parallelism, trap
+    more errors, etc.)
+
+If you submit a pull request to implement a new feature without going through
+the RFC process, it may be closed with a polite request to submit an RFC first.
+
+## Before creating an RFC
+[Before creating an RFC]: #before-creating-an-rfc
+
+A hastily-proposed RFC can hurt its chances of acceptance. Low quality
+proposals, proposals for previously-rejected changes, or those that don't fit
+into the near-term roadmap, may be quickly rejected, which can be demotivating
+for the unprepared contributor. Laying some groundwork ahead of the RFC can
+make the process smoother.
+
+Although there is no single way to prepare for submitting an RFC, it is
+generally a good idea to pursue feedback from other project developers
+beforehand, to ascertain that the RFC may be desirable; having a consistent
+impact on the project requires concerted effort toward consensus-building.
+
+The most common preparations for writing and submitting an RFC include talking
+the idea over on [#ursa](https://chat.hyperledger.org/channel/ursa) and
+proposing ideas to the Hyperledger Ursa mailing list
+(https://lists.hyperledger.org/mailman/listinfo/hyperledger-ursa).
+
+As a rule of thumb, receiving encouraging feedback from long-standing project
+developers, and particularly maintainers is a good
+indication that the RFC is worth pursuing.
+
+
+## What the process is
+[What the process is]: #what-the-process-is
+
+In short, to get a major feature added to Ursa, one must first get the RFC
+merged into the RFC repository as a markdown file. At that point the RFC is
+""active"" and may be implemented with the goal of eventual inclusion into Ursa.
+
+  - Fork the RFC repo [RFC repository]
+  - Copy `0000-template.md` to `text/0000-my-feature.md` (where ""my-feature"" is
+    descriptive. don't assign an RFC number yet).
+  - Fill in the RFC. Put care into the details: RFCs that do not present
+    convincing motivation, demonstrate understanding of the impact of the
+    design, or are disingenuous about the drawbacks or alternatives tend to be
+    poorly-received.
+  - Submit a pull request. As a pull request the RFC will receive design
+    feedback from the larger community, and the author should be prepared to
+    revise it in response.
+  - Build consensus and integrate feedback. RFCs that have broad support are
+    much more likely to make progress than those that don't receive any
+    comments. Feel free to reach out to the RFC assignee in particular to get
+    help identifying stakeholders and obstacles.
+  - Maintainers will discuss the RFC pull request, as much as possible in the
+    comment thread of the pull request itself. Offline discussion will be
+    summarized on the pull request comment thread.
+  - RFCs rarely go through this process unchanged, especially as alternatives
+    and drawbacks are shown. You can make edits, big and small, to the RFC to
+    clarify or change the design, but make changes as new commits to the pull
+    request, and leave a comment on the pull request explaining your changes.
+    Specifically, do not squash or rebase commits after they are visible on the
+    pull request.
+  - At some point, a maintainer will propose a ""motion for final
+    comment period"" (FCP), along with a *disposition* for the RFC (merge, close,
+    or postpone).
+    - This step is taken when enough of the tradeoffs have been discussed that
+    the maintainers are in a position to make a decision. That does not require
+    consensus amongst all participants in the RFC thread (which is usually
+    impossible). However, the argument supporting the disposition on the RFC
+    needs to have already been clearly articulated, and there should not be a
+    strong consensus *against* that position outside of the maintainers. 
+    Maintainers use their best judgment in taking this step, and the FCP itself
+    ensures there is ample time and notification for stakeholders to push back
+    if it is made prematurely.
+    - For RFCs with lengthy discussion, the motion to FCP is usually preceded by
+      a *summary comment* trying to lay out the current state of the discussion
+      and major trade-offs/points of disagreement.
+    - Before actually entering FCP, *all* maintainers must sign off;
+    this is often the point at which many maintainers first review the RFC
+    in full depth.
+  - The FCP lasts one week, or seven calendar days. It is also advertised
+    widely, e.g. in [Ursa Mailing
+    List](https://lists.hyperledger.org/mailman/listinfo/hyperledger-ursa). This
+    way all stakeholders have a chance to lodge any final objections before
+    a decision is reached.
+  - In most cases, the FCP period is quiet, and the RFC is either merged or
+    closed. However, sometimes substantial new arguments or ideas are raised,
+    the FCP is canceled, and the RFC goes back into development mode.
+
+## The RFC life-cycle
+[The RFC life-cycle]: #the-rfc-life-cycle
+
+Once an RFC becomes ""active"" then authors may implement it and submit the
+change as a pull request to the corresponding Ursa repo. Being ""active"" is not a rubber
+stamp, and in particular still does not mean the change will ultimately be
+merged; it does mean that in principle all the major stakeholders have agreed
+to the change and are amenable to merging it.
+
+Furthermore, the fact that a given RFC has been accepted and is ""active""
+implies nothing about what priority is assigned to its implementation, nor does
+it imply anything about whether a Ursa developer has been assigned the task of
+implementing the feature. While it is not *necessary* that the author of the
+RFC also write the implementation, it is by far the most effective way to see
+an RFC through to completion: authors should not expect that other project
+developers will take on responsibility for implementing their accepted feature.
+
+Modifications to ""active"" RFCs can be done in follow-up pull requests. We",165,2018-12-21 16:34:29,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/235727552,https://github.com/hyperledger/ursa-rfcs/pull/2#discussion_r235727552,manudrijvers
https://github.com/hyperledger/ursa-rfcs/pull/2,https://github.com/hyperledger/ursa-rfcs/pull/2,oops. cut and paste error. i'll push up a fixup. ,ffdb8b610b2ee7eb780bcadef790544191347ea2,2018-11-26 21:10:03,236427474,"@@ -1 +1,230 @@
-# ursa-rfcs
\ No newline at end of file
+# Ursa RFCs
+[Ursa RFCs]: #ursa-rfcs
+
+Many changes, including bug fixes and documentation improvements can be
+implemented and reviewed via the normal GitHub pull request workflow.
+
+Some changes though are ""substantial"", and we ask that these be put through a
+bit of a design process and produce a consensus among the Ursa community.
+
+The ""RFC"" (request for comments) process is intended to provide a consistent
+and controlled path for major changes to enter Ursa Core and other official
+project components, so that all stakeholders can be confident about the
+direction Ursa is evolving in.
+
+This process is intended to be substantially similar to the Rust RFCs process,
+customized as necessary for use with Ursa. The README.md and
+0000-template.md were initially forked from [Rust
+RFCs](https://github.com/rust-lang/rfcs).
+
+
+## Table of Contents
+[Table of Contents]: #table-of-contents
+
+  - [Opening](#ursa-rfcs)
+  - [Table of Contents]
+  - [When you need to follow this process]
+  - [Before creating an RFC]
+  - [What the process is]
+  - [The RFC life-cycle]
+  - [Reviewing RFCs]
+  - [Implementing an RFC]
+  - [Help this is all too informal!]
+  - [License]
+
+
+## When you need to follow this process
+[When you need to follow this process]: #when-you-need-to-follow-this-process
+
+You need to follow this process if you intend to make ""substantial"" changes to
+Ursa or any of its sub-components including but not limited to Ursa
+Core, Ursa Supply Chain, Ursa Seth, the various Ursa SDKs, or the",,2018-12-21 16:34:29,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/236427474,https://github.com/hyperledger/ursa-rfcs/pull/2#discussion_r236427474,dcmiddle
https://github.com/hyperledger/ursa-rfcs/pull/2,https://github.com/hyperledger/ursa-rfcs/pull/2,"It should be easier to touch up the language. If there's a substantial change to the design then it should be a new RFC. Maybe for small changes to previously approved RFCs we just revert to the existing PR approval, i.e. approval from two different maintainers who are different from the submitter and who ideally represent different viewpoints. ",ffdb8b610b2ee7eb780bcadef790544191347ea2,2018-11-26 21:19:54,236430826,"@@ -1 +1,230 @@
-# ursa-rfcs
\ No newline at end of file
+# Ursa RFCs
+[Ursa RFCs]: #ursa-rfcs
+
+Many changes, including bug fixes and documentation improvements can be
+implemented and reviewed via the normal GitHub pull request workflow.
+
+Some changes though are ""substantial"", and we ask that these be put through a
+bit of a design process and produce a consensus among the Ursa community.
+
+The ""RFC"" (request for comments) process is intended to provide a consistent
+and controlled path for major changes to enter Ursa Core and other official
+project components, so that all stakeholders can be confident about the
+direction Ursa is evolving in.
+
+This process is intended to be substantially similar to the Rust RFCs process,
+customized as necessary for use with Ursa. The README.md and
+0000-template.md were initially forked from [Rust
+RFCs](https://github.com/rust-lang/rfcs).
+
+
+## Table of Contents
+[Table of Contents]: #table-of-contents
+
+  - [Opening](#ursa-rfcs)
+  - [Table of Contents]
+  - [When you need to follow this process]
+  - [Before creating an RFC]
+  - [What the process is]
+  - [The RFC life-cycle]
+  - [Reviewing RFCs]
+  - [Implementing an RFC]
+  - [Help this is all too informal!]
+  - [License]
+
+
+## When you need to follow this process
+[When you need to follow this process]: #when-you-need-to-follow-this-process
+
+You need to follow this process if you intend to make ""substantial"" changes to
+Ursa or any of its sub-components including but not limited to Ursa
+Core, Ursa Supply Chain, Ursa Seth, the various Ursa SDKs, or the
+RFC process itself. What constitutes a ""substantial"" change is evolving based
+on community norms and varies depending
+on what part of the ecosystem you are proposing to change, but may include the
+following.
+
+  - Architectural changes
+  - Substantial changes to component interfaces
+  - New core features
+  - Backward incompatible changes
+  - Changes that affect the security of communications or administration
+
+Some changes do not require an RFC:
+
+  - Rephrasing, reorganizing, refactoring, or otherwise ""changing shape does
+    not change meaning"".
+  - Additions that strictly improve objective, numerical quality criteria
+    (warning removal, speedup, better platform coverage, more parallelism, trap
+    more errors, etc.)
+
+If you submit a pull request to implement a new feature without going through
+the RFC process, it may be closed with a polite request to submit an RFC first.
+
+## Before creating an RFC
+[Before creating an RFC]: #before-creating-an-rfc
+
+A hastily-proposed RFC can hurt its chances of acceptance. Low quality
+proposals, proposals for previously-rejected changes, or those that don't fit
+into the near-term roadmap, may be quickly rejected, which can be demotivating
+for the unprepared contributor. Laying some groundwork ahead of the RFC can
+make the process smoother.
+
+Although there is no single way to prepare for submitting an RFC, it is
+generally a good idea to pursue feedback from other project developers
+beforehand, to ascertain that the RFC may be desirable; having a consistent
+impact on the project requires concerted effort toward consensus-building.
+
+The most common preparations for writing and submitting an RFC include talking
+the idea over on [#ursa](https://chat.hyperledger.org/channel/ursa) and
+proposing ideas to the Hyperledger Ursa mailing list
+(https://lists.hyperledger.org/mailman/listinfo/hyperledger-ursa).
+
+As a rule of thumb, receiving encouraging feedback from long-standing project
+developers, and particularly maintainers is a good
+indication that the RFC is worth pursuing.
+
+
+## What the process is
+[What the process is]: #what-the-process-is
+
+In short, to get a major feature added to Ursa, one must first get the RFC
+merged into the RFC repository as a markdown file. At that point the RFC is
+""active"" and may be implemented with the goal of eventual inclusion into Ursa.
+
+  - Fork the RFC repo [RFC repository]
+  - Copy `0000-template.md` to `text/0000-my-feature.md` (where ""my-feature"" is
+    descriptive. don't assign an RFC number yet).
+  - Fill in the RFC. Put care into the details: RFCs that do not present
+    convincing motivation, demonstrate understanding of the impact of the
+    design, or are disingenuous about the drawbacks or alternatives tend to be
+    poorly-received.
+  - Submit a pull request. As a pull request the RFC will receive design
+    feedback from the larger community, and the author should be prepared to
+    revise it in response.
+  - Build consensus and integrate feedback. RFCs that have broad support are
+    much more likely to make progress than those that don't receive any
+    comments. Feel free to reach out to the RFC assignee in particular to get
+    help identifying stakeholders and obstacles.
+  - Maintainers will discuss the RFC pull request, as much as possible in the
+    comment thread of the pull request itself. Offline discussion will be
+    summarized on the pull request comment thread.
+  - RFCs rarely go through this process unchanged, especially as alternatives
+    and drawbacks are shown. You can make edits, big and small, to the RFC to
+    clarify or change the design, but make changes as new commits to the pull
+    request, and leave a comment on the pull request explaining your changes.
+    Specifically, do not squash or rebase commits after they are visible on the
+    pull request.
+  - At some point, a maintainer will propose a ""motion for final
+    comment period"" (FCP), along with a *disposition* for the RFC (merge, close,
+    or postpone).
+    - This step is taken when enough of the tradeoffs have been discussed that
+    the maintainers are in a position to make a decision. That does not require
+    consensus amongst all participants in the RFC thread (which is usually
+    impossible). However, the argument supporting the disposition on the RFC
+    needs to have already been clearly articulated, and there should not be a
+    strong consensus *against* that position outside of the maintainers. 
+    Maintainers use their best judgment in taking this step, and the FCP itself
+    ensures there is ample time and notification for stakeholders to push back
+    if it is made prematurely.
+    - For RFCs with lengthy discussion, the motion to FCP is usually preceded by
+      a *summary comment* trying to lay out the current state of the discussion
+      and major trade-offs/points of disagreement.
+    - Before actually entering FCP, *all* maintainers must sign off;
+    this is often the point at which many maintainers first review the RFC
+    in full depth.
+  - The FCP lasts one week, or seven calendar days. It is also advertised
+    widely, e.g. in [Ursa Mailing
+    List](https://lists.hyperledger.org/mailman/listinfo/hyperledger-ursa). This
+    way all stakeholders have a chance to lodge any final objections before
+    a decision is reached.
+  - In most cases, the FCP period is quiet, and the RFC is either merged or
+    closed. However, sometimes substantial new arguments or ideas are raised,
+    the FCP is canceled, and the RFC goes back into development mode.
+
+## The RFC life-cycle
+[The RFC life-cycle]: #the-rfc-life-cycle
+
+Once an RFC becomes ""active"" then authors may implement it and submit the
+change as a pull request to the corresponding Ursa repo. Being ""active"" is not a rubber
+stamp, and in particular still does not mean the change will ultimately be
+merged; it does mean that in principle all the major stakeholders have agreed
+to the change and are amenable to merging it.
+
+Furthermore, the fact that a given RFC has been accepted and is ""active""
+implies nothing about what priority is assigned to its implementation, nor does
+it imply anything about whether a Ursa developer has been assigned the task of
+implementing the feature. While it is not *necessary* that the author of the
+RFC also write the implementation, it is by far the most effective way to see
+an RFC through to completion: authors should not expect that other project
+developers will take on responsibility for implementing their accepted feature.
+
+Modifications to ""active"" RFCs can be done in follow-up pull requests. We",165,2018-12-21 16:34:29,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/236430826,https://github.com/hyperledger/ursa-rfcs/pull/2#discussion_r236430826,dcmiddle
https://github.com/hyperledger/ursa-rfcs/pull/2,https://github.com/hyperledger/ursa-rfcs/pull/2,"Can we provide some examples here that are crypto-related for guidance?  For instance, proposing a new protocol definitely should require an RFC.  But what about a new implementation of an existing protocol (that could be very different from the old implementation, perhaps with different security properties)?",ffdb8b610b2ee7eb780bcadef790544191347ea2,2018-11-28 02:12:19,236919034,"@@ -1 +1,228 @@
-# ursa-rfcs
\ No newline at end of file
+# Ursa RFCs
+[Ursa RFCs]: #ursa-rfcs
+
+Many changes, including bug fixes and documentation improvements can be
+implemented and reviewed via the normal GitHub pull request workflow.
+
+Some changes though are ""substantial"", and we ask that these be put through a
+bit of a design process and produce a consensus among the Ursa community.
+
+The ""RFC"" (request for comments) process is intended to provide a consistent
+and controlled path for major changes to enter Ursa and other official
+project components, so that all stakeholders can be confident about the
+direction Ursa is evolving in.
+
+This process is intended to be substantially similar to the Rust RFCs process,
+customized as necessary for use with Ursa. The README.md and
+0000-template.md were initially forked from [Rust
+RFCs](https://github.com/rust-lang/rfcs).
+
+
+## Table of Contents
+[Table of Contents]: #table-of-contents
+
+  - [Opening](#ursa-rfcs)
+  - [Table of Contents]
+  - [When you need to follow this process]
+  - [Before creating an RFC]
+  - [What the process is]
+  - [The RFC life-cycle]
+  - [Reviewing RFCs]
+  - [Implementing an RFC]
+  - [Help this is all too informal!]
+  - [License]
+
+
+## When you need to follow this process
+[When you need to follow this process]: #when-you-need-to-follow-this-process
+
+You need to follow this process if you intend to make ""substantial"" changes to
+Ursa or any of its sub-components or the  RFC process itself. What constitutes a
+""substantial"" change is evolving based on community norms and varies depending
+on what part of the project you are proposing to change, but may include the
+following.
+
+  - Architectural changes
+  - Substantial changes to component interfaces
+  - New core features
+  - Backward incompatible changes
+  - Changes that affect the security of communications or administration
+
+Some changes do not require an RFC:
+
+  - Rephrasing, reorganizing, refactoring, or otherwise ""changing shape does
+    not change meaning"".
+  - Additions that strictly improve objective, numerical quality criteria
+    (warning removal, speedup, better platform coverage, more parallelism, trap
+    more errors, etc.)",62,2018-12-21 16:34:29,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/236919034,https://github.com/hyperledger/ursa-rfcs/pull/2#discussion_r236919034,hartm
https://github.com/hyperledger/ursa-rfcs/pull/2,https://github.com/hyperledger/ursa-rfcs/pull/2,"Will update with examples including that new implementations of previously approved algorithms require RFCs. All RFCs will include the motivation for the request, i.e. what is the upstream requirement. ",ffdb8b610b2ee7eb780bcadef790544191347ea2,2018-11-28 15:42:42,237138620,"@@ -1 +1,228 @@
-# ursa-rfcs
\ No newline at end of file
+# Ursa RFCs
+[Ursa RFCs]: #ursa-rfcs
+
+Many changes, including bug fixes and documentation improvements can be
+implemented and reviewed via the normal GitHub pull request workflow.
+
+Some changes though are ""substantial"", and we ask that these be put through a
+bit of a design process and produce a consensus among the Ursa community.
+
+The ""RFC"" (request for comments) process is intended to provide a consistent
+and controlled path for major changes to enter Ursa and other official
+project components, so that all stakeholders can be confident about the
+direction Ursa is evolving in.
+
+This process is intended to be substantially similar to the Rust RFCs process,
+customized as necessary for use with Ursa. The README.md and
+0000-template.md were initially forked from [Rust
+RFCs](https://github.com/rust-lang/rfcs).
+
+
+## Table of Contents
+[Table of Contents]: #table-of-contents
+
+  - [Opening](#ursa-rfcs)
+  - [Table of Contents]
+  - [When you need to follow this process]
+  - [Before creating an RFC]
+  - [What the process is]
+  - [The RFC life-cycle]
+  - [Reviewing RFCs]
+  - [Implementing an RFC]
+  - [Help this is all too informal!]
+  - [License]
+
+
+## When you need to follow this process
+[When you need to follow this process]: #when-you-need-to-follow-this-process
+
+You need to follow this process if you intend to make ""substantial"" changes to
+Ursa or any of its sub-components or the  RFC process itself. What constitutes a
+""substantial"" change is evolving based on community norms and varies depending
+on what part of the project you are proposing to change, but may include the
+following.
+
+  - Architectural changes
+  - Substantial changes to component interfaces
+  - New core features
+  - Backward incompatible changes
+  - Changes that affect the security of communications or administration
+
+Some changes do not require an RFC:
+
+  - Rephrasing, reorganizing, refactoring, or otherwise ""changing shape does
+    not change meaning"".
+  - Additions that strictly improve objective, numerical quality criteria
+    (warning removal, speedup, better platform coverage, more parallelism, trap
+    more errors, etc.)",62,2018-12-21 16:34:29,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/237138620,https://github.com/hyperledger/ursa-rfcs/pull/2#discussion_r237138620,dcmiddle
https://github.com/hyperledger/ursa-rfcs/pull/2,https://github.com/hyperledger/ursa-rfcs/pull/2,"Saw the change.  Thanks!  I hope as the RFCs come in, we can add some more concrete examples.",ffdb8b610b2ee7eb780bcadef790544191347ea2,2019-01-09 05:31:09,246263676,"@@ -1 +1,228 @@
-# ursa-rfcs
\ No newline at end of file
+# Ursa RFCs
+[Ursa RFCs]: #ursa-rfcs
+
+Many changes, including bug fixes and documentation improvements can be
+implemented and reviewed via the normal GitHub pull request workflow.
+
+Some changes though are ""substantial"", and we ask that these be put through a
+bit of a design process and produce a consensus among the Ursa community.
+
+The ""RFC"" (request for comments) process is intended to provide a consistent
+and controlled path for major changes to enter Ursa and other official
+project components, so that all stakeholders can be confident about the
+direction Ursa is evolving in.
+
+This process is intended to be substantially similar to the Rust RFCs process,
+customized as necessary for use with Ursa. The README.md and
+0000-template.md were initially forked from [Rust
+RFCs](https://github.com/rust-lang/rfcs).
+
+
+## Table of Contents
+[Table of Contents]: #table-of-contents
+
+  - [Opening](#ursa-rfcs)
+  - [Table of Contents]
+  - [When you need to follow this process]
+  - [Before creating an RFC]
+  - [What the process is]
+  - [The RFC life-cycle]
+  - [Reviewing RFCs]
+  - [Implementing an RFC]
+  - [Help this is all too informal!]
+  - [License]
+
+
+## When you need to follow this process
+[When you need to follow this process]: #when-you-need-to-follow-this-process
+
+You need to follow this process if you intend to make ""substantial"" changes to
+Ursa or any of its sub-components or the  RFC process itself. What constitutes a
+""substantial"" change is evolving based on community norms and varies depending
+on what part of the project you are proposing to change, but may include the
+following.
+
+  - Architectural changes
+  - Substantial changes to component interfaces
+  - New core features
+  - Backward incompatible changes
+  - Changes that affect the security of communications or administration
+
+Some changes do not require an RFC:
+
+  - Rephrasing, reorganizing, refactoring, or otherwise ""changing shape does
+    not change meaning"".
+  - Additions that strictly improve objective, numerical quality criteria
+    (warning removal, speedup, better platform coverage, more parallelism, trap
+    more errors, etc.)",62,2019-01-09 05:31:09,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/246263676,https://github.com/hyperledger/ursa-rfcs/pull/2#discussion_r246263676,hartm
https://github.com/hyperledger/ursa-rfcs/pull/2,https://github.com/hyperledger/ursa-rfcs/pull/2,"```suggestion
- Version: 2

```",ffdb8b610b2ee7eb780bcadef790544191347ea2,2019-01-10 04:59:04,246636492,"@@ -0,0 +1,91 @@
+- Feature Name: (fill me in with a unique identifier, my_awesome_feature)
+- Start Date: (fill me in with today's date, YYYY-MM-DD)
+- RFC PR: (leave this empty)
+- Ursa Issue: (leave this empty)
+",5,2019-01-10 05:28:08,https://api.github.com/repos/hyperledger/ursa-rfcs/pulls/comments/246636492,https://github.com/hyperledger/ursa-rfcs/pull/2#discussion_r246636492,dhuseby
