pull request url html,pull request url,body,commit_id,create at,id,diff_hunk,position,update at,url,html url,user
https://github.com/hyperledger/quilt/pull/191,https://github.com/hyperledger/quilt/pull/191,That is a super-weird syntax!,ba03b08d6cdd67273aa6f89010772c68115093a2,2019-03-28 07:07:50,269877401,"@@ -293,7 +293,7 @@
             <dependency>
               <groupId>com.puppycrawl.tools</groupId>
               <artifactId>checkstyle</artifactId>
-              <version>8.4</version>
+              <version>[8.18,)</version>",5,2019-03-28 07:07:55,https://api.github.com/repos/hyperledger/quilt/pulls/comments/269877401,https://github.com/hyperledger/quilt/pull/191#discussion_r269877401,adrianhopebailie
https://github.com/hyperledger/quilt/pull/183,https://github.com/hyperledger/quilt/pull/183,"We need to think a bit more about this. An `IL-DCP` request is basically just a PreparePacket, and it doesn't play well with the InterledgerCodecContextFactory, which sort of trumps this CodecContext since both objects are of type `InterledgerPreparePacket`.

I'm leaning towards getting rid of IL-DCP packets as a formal concept, and perhaps just consider a way to encode/decode the `IldcpResponse` into the data-portion of a Fulfill packet.",1a699d7275b577ceb7aba4ee102c1fb041ef24d1,2019-03-09 02:57:25,263983542,"@@ -0,0 +1,70 @@
+package org.interledger.ildcp.asn.framework;
+
+/*-
+ * ========================LICENSE_START=================================
+ * Interledger Dynamic Configuration Protocol Core Codecs
+ * %%
+ * Copyright (C) 2017 - 2018 Hyperledger and its contributors
+ * %%
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * =========================LICENSE_END==================================
+ */
+
+import org.interledger.core.InterledgerPacket;
+import org.interledger.encoding.asn.framework.CodecContext;
+import org.interledger.encoding.asn.framework.CodecContextFactory;
+import org.interledger.ildcp.IldcpRequestPacket;
+import org.interledger.ildcp.IldcpResponse;
+import org.interledger.ildcp.IldcpResponsePacket;
+import org.interledger.ildcp.asn.codecs.AsnIldcpPacketCodec;
+import org.interledger.ildcp.asn.codecs.AsnIldcpRequestPacketCodec;
+import org.interledger.ildcp.asn.codecs.AsnIldcpResponseCodec;
+import org.interledger.ildcp.asn.codecs.AsnIldcpResponsePacketDataCodec;
+
+/**
+ * A factory class for constructing a CodecContext that can read and write Interledger Dynamic Configuration Protocol
+ * objects using ASN.1 OER encoding.
+ *
+ * @see ""https://github.com/interledger/rfcs/blob/master/0031-dynamic-configuration-protocol/0031-dynamic-configuration-protocol.md""
+ */
+public class IldcpCodecContextFactory {
+
+  /**
+   * Create an instance of {@link CodecContext} that encodes and decodes BTP packets using ASN.1 OER encoding.
+   *
+   * @return A new instance of {@link CodecContext}.
+   */
+  public static CodecContext oer() {
+    final CodecContext btpCodecContext = CodecContextFactory.getContext(CodecContextFactory.OCTET_ENCODING_RULES);
+    return register(btpCodecContext);
+  }
+
+  /**
+   * Register the IL-DCP protocol codecs into the provided context.
+   *
+   * @param context the context to register the codecs into
+   *
+   * @return The supplied {@code context} with BTP codecs registered into it.
+   */
+  public static CodecContext register(CodecContext context) {
+    // For encoding this into a `data` field.
+    context.register(IldcpResponse.class, AsnIldcpResponseCodec::new);
+
+    context.register(InterledgerPacket.class, AsnIldcpPacketCodec::new);
+    context.register(IldcpRequestPacket.class, AsnIldcpRequestPacketCodec::new);",64,2019-03-17 00:15:35,https://api.github.com/repos/hyperledger/quilt/pulls/comments/263983542,https://github.com/hyperledger/quilt/pull/183#discussion_r263983542,sappenin
https://github.com/hyperledger/quilt/pull/183,https://github.com/hyperledger/quilt/pull/183,I think this might be a mistake...I'll look this weekend.,1a699d7275b577ceb7aba4ee102c1fb041ef24d1,2019-03-09 02:57:53,263983561,"@@ -0,0 +1,70 @@
+package org.interledger.ildcp.asn.framework;
+
+/*-
+ * ========================LICENSE_START=================================
+ * Interledger Dynamic Configuration Protocol Core Codecs
+ * %%
+ * Copyright (C) 2017 - 2018 Hyperledger and its contributors
+ * %%
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * =========================LICENSE_END==================================
+ */
+
+import org.interledger.core.InterledgerPacket;
+import org.interledger.encoding.asn.framework.CodecContext;
+import org.interledger.encoding.asn.framework.CodecContextFactory;
+import org.interledger.ildcp.IldcpRequestPacket;
+import org.interledger.ildcp.IldcpResponse;
+import org.interledger.ildcp.IldcpResponsePacket;
+import org.interledger.ildcp.asn.codecs.AsnIldcpPacketCodec;
+import org.interledger.ildcp.asn.codecs.AsnIldcpRequestPacketCodec;
+import org.interledger.ildcp.asn.codecs.AsnIldcpResponseCodec;
+import org.interledger.ildcp.asn.codecs.AsnIldcpResponsePacketDataCodec;
+
+/**
+ * A factory class for constructing a CodecContext that can read and write Interledger Dynamic Configuration Protocol
+ * objects using ASN.1 OER encoding.
+ *
+ * @see ""https://github.com/interledger/rfcs/blob/master/0031-dynamic-configuration-protocol/0031-dynamic-configuration-protocol.md""
+ */
+public class IldcpCodecContextFactory {
+
+  /**
+   * Create an instance of {@link CodecContext} that encodes and decodes BTP packets using ASN.1 OER encoding.
+   *
+   * @return A new instance of {@link CodecContext}.
+   */
+  public static CodecContext oer() {
+    final CodecContext btpCodecContext = CodecContextFactory.getContext(CodecContextFactory.OCTET_ENCODING_RULES);
+    return register(btpCodecContext);
+  }
+
+  /**
+   * Register the IL-DCP protocol codecs into the provided context.
+   *
+   * @param context the context to register the codecs into
+   *
+   * @return The supplied {@code context} with BTP codecs registered into it.
+   */
+  public static CodecContext register(CodecContext context) {
+    // For encoding this into a `data` field.
+    context.register(IldcpResponse.class, AsnIldcpResponseCodec::new);
+
+    context.register(InterledgerPacket.class, AsnIldcpPacketCodec::new);",63,2019-03-17 00:15:35,https://api.github.com/repos/hyperledger/quilt/pulls/comments/263983561,https://github.com/hyperledger/quilt/pull/183#discussion_r263983561,sappenin
https://github.com/hyperledger/quilt/pull/183,https://github.com/hyperledger/quilt/pull/183,"Should IldcpRequestPacket extend/implement InterledgerPacket?
Maybe not, since the condition etc are hardcoded",1a699d7275b577ceb7aba4ee102c1fb041ef24d1,2019-03-11 10:01:13,264158895,"@@ -0,0 +1,70 @@
+package org.interledger.ildcp.asn.framework;
+
+/*-
+ * ========================LICENSE_START=================================
+ * Interledger Dynamic Configuration Protocol Core Codecs
+ * %%
+ * Copyright (C) 2017 - 2018 Hyperledger and its contributors
+ * %%
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * =========================LICENSE_END==================================
+ */
+
+import org.interledger.core.InterledgerPacket;
+import org.interledger.encoding.asn.framework.CodecContext;
+import org.interledger.encoding.asn.framework.CodecContextFactory;
+import org.interledger.ildcp.IldcpRequestPacket;
+import org.interledger.ildcp.IldcpResponse;
+import org.interledger.ildcp.IldcpResponsePacket;
+import org.interledger.ildcp.asn.codecs.AsnIldcpPacketCodec;
+import org.interledger.ildcp.asn.codecs.AsnIldcpRequestPacketCodec;
+import org.interledger.ildcp.asn.codecs.AsnIldcpResponseCodec;
+import org.interledger.ildcp.asn.codecs.AsnIldcpResponsePacketDataCodec;
+
+/**
+ * A factory class for constructing a CodecContext that can read and write Interledger Dynamic Configuration Protocol
+ * objects using ASN.1 OER encoding.
+ *
+ * @see ""https://github.com/interledger/rfcs/blob/master/0031-dynamic-configuration-protocol/0031-dynamic-configuration-protocol.md""
+ */
+public class IldcpCodecContextFactory {
+
+  /**
+   * Create an instance of {@link CodecContext} that encodes and decodes BTP packets using ASN.1 OER encoding.
+   *
+   * @return A new instance of {@link CodecContext}.
+   */
+  public static CodecContext oer() {
+    final CodecContext btpCodecContext = CodecContextFactory.getContext(CodecContextFactory.OCTET_ENCODING_RULES);
+    return register(btpCodecContext);
+  }
+
+  /**
+   * Register the IL-DCP protocol codecs into the provided context.
+   *
+   * @param context the context to register the codecs into
+   *
+   * @return The supplied {@code context} with BTP codecs registered into it.
+   */
+  public static CodecContext register(CodecContext context) {
+    // For encoding this into a `data` field.
+    context.register(IldcpResponse.class, AsnIldcpResponseCodec::new);
+
+    context.register(InterledgerPacket.class, AsnIldcpPacketCodec::new);
+    context.register(IldcpRequestPacket.class, AsnIldcpRequestPacketCodec::new);",64,2019-03-17 00:15:35,https://api.github.com/repos/hyperledger/quilt/pulls/comments/264158895,https://github.com/hyperledger/quilt/pull/183#discussion_r264158895,adrianhopebailie
https://github.com/hyperledger/quilt/pull/183,https://github.com/hyperledger/quilt/pull/183,"So, in the most recent update to this PR, I've kept the concept of an `IldcpRequestPacket` that extends `InterledgerPreparePacket` and `IldcpResponsePacket` that extends `InterledgerFulfillPacket`. The Codecs work now with both, and I like the Java interfaces now because it's mostly obvious when you're dealing with which.

Also, the polymorphic handlers (e.g., see [InterledgerResponsePacketHandler.java](https://github.com/hyperledger/quilt/blob/master/ilp-core/src/main/java/org/interledger/core/InterledgerResponsePacketHandler.java)) still work with ILDCP packets _because_ they extend the actual packets classes.

All that to say, let's keep this pattern for now, and as I work it into a Connector/Sender/Receiver, we can always update from there.",1a699d7275b577ceb7aba4ee102c1fb041ef24d1,2019-03-15 14:44:29,266011438,"@@ -0,0 +1,70 @@
+package org.interledger.ildcp.asn.framework;
+
+/*-
+ * ========================LICENSE_START=================================
+ * Interledger Dynamic Configuration Protocol Core Codecs
+ * %%
+ * Copyright (C) 2017 - 2018 Hyperledger and its contributors
+ * %%
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * =========================LICENSE_END==================================
+ */
+
+import org.interledger.core.InterledgerPacket;
+import org.interledger.encoding.asn.framework.CodecContext;
+import org.interledger.encoding.asn.framework.CodecContextFactory;
+import org.interledger.ildcp.IldcpRequestPacket;
+import org.interledger.ildcp.IldcpResponse;
+import org.interledger.ildcp.IldcpResponsePacket;
+import org.interledger.ildcp.asn.codecs.AsnIldcpPacketCodec;
+import org.interledger.ildcp.asn.codecs.AsnIldcpRequestPacketCodec;
+import org.interledger.ildcp.asn.codecs.AsnIldcpResponseCodec;
+import org.interledger.ildcp.asn.codecs.AsnIldcpResponsePacketDataCodec;
+
+/**
+ * A factory class for constructing a CodecContext that can read and write Interledger Dynamic Configuration Protocol
+ * objects using ASN.1 OER encoding.
+ *
+ * @see ""https://github.com/interledger/rfcs/blob/master/0031-dynamic-configuration-protocol/0031-dynamic-configuration-protocol.md""
+ */
+public class IldcpCodecContextFactory {
+
+  /**
+   * Create an instance of {@link CodecContext} that encodes and decodes BTP packets using ASN.1 OER encoding.
+   *
+   * @return A new instance of {@link CodecContext}.
+   */
+  public static CodecContext oer() {
+    final CodecContext btpCodecContext = CodecContextFactory.getContext(CodecContextFactory.OCTET_ENCODING_RULES);
+    return register(btpCodecContext);
+  }
+
+  /**
+   * Register the IL-DCP protocol codecs into the provided context.
+   *
+   * @param context the context to register the codecs into
+   *
+   * @return The supplied {@code context} with BTP codecs registered into it.
+   */
+  public static CodecContext register(CodecContext context) {
+    // For encoding this into a `data` field.
+    context.register(IldcpResponse.class, AsnIldcpResponseCodec::new);
+
+    context.register(InterledgerPacket.class, AsnIldcpPacketCodec::new);
+    context.register(IldcpRequestPacket.class, AsnIldcpRequestPacketCodec::new);",64,2019-03-17 00:15:35,https://api.github.com/repos/hyperledger/quilt/pulls/comments/266011438,https://github.com/hyperledger/quilt/pull/183#discussion_r266011438,sappenin
https://github.com/hyperledger/quilt/pull/182,https://github.com/hyperledger/quilt/pull/182,Immutable doesn't play nicely with Java 8 default interface methods ? ,eecd4633a8067094f8f4cf2e71a385817b604672,2019-03-04 07:26:41,261944028,"@@ -36,11 +38,19 @@ static IldcpRequestBuilder builder() {
   /**
    * An arbitrary expiration date for this packet, as configured by the sender.
    */
-  Instant getExpiresAt();
+  default Instant getExpiresAt() {
+    return Instant.now().plusSeconds(30);
+  }
 
   @Immutable
   abstract class AbstractIldcpRequest implements IldcpRequest {
 
+    @Override
+    @Default
+    public Instant getExpiresAt() {",28,2019-03-04 07:26:41,https://api.github.com/repos/hyperledger/quilt/pulls/comments/261944028,https://github.com/hyperledger/quilt/pull/182#discussion_r261944028,sublimator
https://github.com/hyperledger/quilt/pull/182,https://github.com/hyperledger/quilt/pull/182,So basically `new byte[32]` ,eecd4633a8067094f8f4cf2e71a385817b604672,2019-03-04 07:28:49,261944428,"@@ -2,24 +2,29 @@
 
 import org.interledger.annotations.Immutable;
 import org.interledger.core.InterledgerAddress;
+import org.interledger.core.InterledgerAddressPrefix;
 import org.interledger.core.InterledgerCondition;
 import org.interledger.core.InterledgerPreparePacket;
 
+import org.immutables.value.Value.Default;
 import org.immutables.value.Value.Derived;
 
 import java.math.BigInteger;
+import java.time.Instant;
 import java.util.Base64;
 import java.util.Objects;
 
 /**
- * An extension of {@link InterledgerPreparePacket} that can be used as an IL-DCP request over
- * Interledger.
+ * An extension of {@link InterledgerPreparePacket} that can be used as an IL-DCP request over Interledger.
  */
 public interface IldcpRequestPacket extends InterledgerPreparePacket {
 
+  InterledgerAddress PEER_DOT_CONFIG = InterledgerAddress.of(InterledgerAddressPrefix.PEER.with(""config"").getValue());
+
   InterledgerCondition EXECUTION_CONDITION = InterledgerCondition.of(",25,2019-03-04 07:28:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/261944428,https://github.com/hyperledger/quilt/pull/182#discussion_r261944428,sublimator
https://github.com/hyperledger/quilt/pull/182,https://github.com/hyperledger/quilt/pull/182,"Just maintaining the existing style of the project.

I think the original intent was to define interfaces that had no mention of Immutables, and then define an `abstract` class extension of the interfaces so that future code could create alternative implementations, potentially without needing to depend on the `immutables` library.

That said, as a pattern, it has mostly just created code-duplication. The `immutables` dependency isn't strictly needed at runtime, and having it as a `provided` dependency isn't that big of a deal. I wouldn't be opposed to moving to the ""interface-only"" style, but it's probably something we should do in another ticket, all at once.",eecd4633a8067094f8f4cf2e71a385817b604672,2019-03-04 14:45:34,262087282,"@@ -36,11 +38,19 @@ static IldcpRequestBuilder builder() {
   /**
    * An arbitrary expiration date for this packet, as configured by the sender.
    */
-  Instant getExpiresAt();
+  default Instant getExpiresAt() {
+    return Instant.now().plusSeconds(30);
+  }
 
   @Immutable
   abstract class AbstractIldcpRequest implements IldcpRequest {
 
+    @Override
+    @Default
+    public Instant getExpiresAt() {",28,2019-03-04 14:45:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/262087282,https://github.com/hyperledger/quilt/pull/182#discussion_r262087282,sappenin
https://github.com/hyperledger/quilt/pull/182,https://github.com/hyperledger/quilt/pull/182,"Yep, though I _suppose_ what is currently there is [a bit more explicit](https://github.com/interledger/rfcs/blob/master/0031-dynamic-configuration-protocol/0031-dynamic-configuration-protocol.md#packet) to show spec-conformance, and the hashing is only done once in the JVM so not hurting performance.",eecd4633a8067094f8f4cf2e71a385817b604672,2019-03-04 14:48:56,262088800,"@@ -2,24 +2,29 @@
 
 import org.interledger.annotations.Immutable;
 import org.interledger.core.InterledgerAddress;
+import org.interledger.core.InterledgerAddressPrefix;
 import org.interledger.core.InterledgerCondition;
 import org.interledger.core.InterledgerPreparePacket;
 
+import org.immutables.value.Value.Default;
 import org.immutables.value.Value.Derived;
 
 import java.math.BigInteger;
+import java.time.Instant;
 import java.util.Base64;
 import java.util.Objects;
 
 /**
- * An extension of {@link InterledgerPreparePacket} that can be used as an IL-DCP request over
- * Interledger.
+ * An extension of {@link InterledgerPreparePacket} that can be used as an IL-DCP request over Interledger.
  */
 public interface IldcpRequestPacket extends InterledgerPreparePacket {
 
+  InterledgerAddress PEER_DOT_CONFIG = InterledgerAddress.of(InterledgerAddressPrefix.PEER.with(""config"").getValue());
+
   InterledgerCondition EXECUTION_CONDITION = InterledgerCondition.of(",25,2019-03-04 14:48:57,https://api.github.com/repos/hyperledger/quilt/pulls/comments/262088800,https://github.com/hyperledger/quilt/pull/182#discussion_r262088800,sappenin
https://github.com/hyperledger/quilt/pull/182,https://github.com/hyperledger/quilt/pull/182,Thanks the info,eecd4633a8067094f8f4cf2e71a385817b604672,2019-03-06 04:52:28,262791158,"@@ -36,11 +38,19 @@ static IldcpRequestBuilder builder() {
   /**
    * An arbitrary expiration date for this packet, as configured by the sender.
    */
-  Instant getExpiresAt();
+  default Instant getExpiresAt() {
+    return Instant.now().plusSeconds(30);
+  }
 
   @Immutable
   abstract class AbstractIldcpRequest implements IldcpRequest {
 
+    @Override
+    @Default
+    public Instant getExpiresAt() {",28,2019-03-06 04:52:28,https://api.github.com/repos/hyperledger/quilt/pulls/comments/262791158,https://github.com/hyperledger/quilt/pull/182#discussion_r262791158,sublimator
https://github.com/hyperledger/quilt/pull/182,https://github.com/hyperledger/quilt/pull/182,"Ah, ok, might be nice to have a named constant then. I personally can't read base64 :)
I see elsewhere comments about what it is:
```
  /**
   * The execution_condition of an ILP packet for IL-DCP is always	   * The execution_condition of an ILP packet for IL-DCP is always
   * <tt>Zmh6rfhivXdsj8GLjp+OIAiXFIVu4jOzkCpZHQ1fKSU=</tt> in Base64 format.	   * <tt>Zmh6rfhivXdsj8GLjp+OIAiXFIVu4jOzkCpZHQ1fKSU=</tt> in Base64 format, which is the SHA-256 hash of a 32-byte
   * array with all 0 values.
   */	   */
```

Of course not really related to this pull request. Just commenting as I was scanning",eecd4633a8067094f8f4cf2e71a385817b604672,2019-03-06 04:54:45,262791458,"@@ -2,24 +2,29 @@
 
 import org.interledger.annotations.Immutable;
 import org.interledger.core.InterledgerAddress;
+import org.interledger.core.InterledgerAddressPrefix;
 import org.interledger.core.InterledgerCondition;
 import org.interledger.core.InterledgerPreparePacket;
 
+import org.immutables.value.Value.Default;
 import org.immutables.value.Value.Derived;
 
 import java.math.BigInteger;
+import java.time.Instant;
 import java.util.Base64;
 import java.util.Objects;
 
 /**
- * An extension of {@link InterledgerPreparePacket} that can be used as an IL-DCP request over
- * Interledger.
+ * An extension of {@link InterledgerPreparePacket} that can be used as an IL-DCP request over Interledger.
  */
 public interface IldcpRequestPacket extends InterledgerPreparePacket {
 
+  InterledgerAddress PEER_DOT_CONFIG = InterledgerAddress.of(InterledgerAddressPrefix.PEER.with(""config"").getValue());
+
   InterledgerCondition EXECUTION_CONDITION = InterledgerCondition.of(",25,2019-03-06 04:54:46,https://api.github.com/repos/hyperledger/quilt/pulls/comments/262791458,https://github.com/hyperledger/quilt/pull/182#discussion_r262791458,sublimator
https://github.com/hyperledger/quilt/pull/174,https://github.com/hyperledger/quilt/pull/174,Oooooh! Didn't know about the intern feature ,e49179834652f2da9ab686a6732ddf3be56f7180,2018-09-17 05:02:32,217949235,"@@ -0,0 +1,298 @@
+package org.interledger.core;
+
+import org.interledger.core.InterledgerAddress.AllocationScheme;
+
+import org.immutables.value.Value;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+/**
+ * <p>Represents a prefix for an {@link InterledgerAddress}. This class differs only slightly from
+ * {@link InterledgerAddress} in that is allows any valid Interledger address as well as allocation
+ * schemes, whereas {@link InterledgerAddress} requires both an {@link AllocationScheme} as well as
+ * a segment in order to be valid.</p>
+ */
+public interface InterledgerAddressPrefix {
+
+  // Prefixes for all Allocation Schemes.
+  InterledgerAddressPrefix GLOBAL = InterledgerAddressPrefix.from(AllocationScheme.GLOBAL);
+  InterledgerAddressPrefix PRIVATE = InterledgerAddressPrefix.from(AllocationScheme.PRIVATE);
+  InterledgerAddressPrefix EXAMPLE = InterledgerAddressPrefix.from(AllocationScheme.EXAMPLE);
+  InterledgerAddressPrefix PEER = InterledgerAddressPrefix.from(AllocationScheme.PEER);
+  InterledgerAddressPrefix SELF = InterledgerAddressPrefix.from(AllocationScheme.SELF);
+  InterledgerAddressPrefix TEST = InterledgerAddressPrefix.from(AllocationScheme.TEST);
+  InterledgerAddressPrefix TEST1 = InterledgerAddressPrefix.from(AllocationScheme.TEST1);
+  InterledgerAddressPrefix TEST2 = InterledgerAddressPrefix.from(AllocationScheme.TEST2);
+  InterledgerAddressPrefix TEST3 = InterledgerAddressPrefix.from(AllocationScheme.TEST3);
+
+  /**
+   * Constructor to allow quick construction from a {@link String}.
+   *
+   * @param value String representation of an Interledger Address
+   *
+   * @return an {@link InterledgerAddress} instance.
+   *
+   * @throws NullPointerException if {@code value} is <tt>null</tt>.
+   */
+  static InterledgerAddressPrefix of(final String value) {
+    Objects.requireNonNull(value, ""value must not be null!"");
+    return builder().value(value).build();
+  }
+
+  /**
+   * Convert from an {@link InterledgerAddress} into an {@link InterledgerAddressPrefix}.
+   *
+   * @param interledgerAddress An {@link InterledgerAddress} to convert from.
+   *
+   * @return A corresponding {@link InterledgerAddressPrefix}.
+   */
+  static InterledgerAddressPrefix from(final InterledgerAddress interledgerAddress) {
+    return builder().value(interledgerAddress.getValue()).build();
+  }
+
+  /**
+   * Convert from an {@link AllocationScheme} into an {@link InterledgerAddressPrefix}.
+   *
+   * @param allocationScheme An {@link AllocationScheme} to convert from.
+   *
+   * @return A corresponding {@link InterledgerAddressPrefix}.
+   */
+  static InterledgerAddressPrefix from(final AllocationScheme allocationScheme) {
+    return builder().value(allocationScheme.getValue()).build();
+  }
+
+  /**
+   * <p>Construct a default builder.</p>
+   *
+   * @return An {@link InterledgerAddressBuilder} instance.
+   */
+  static InterledgerAddressPrefixBuilder builder() {
+    return new InterledgerAddressPrefixBuilder();
+  }
+
+  /**
+   * <p>Accessor for this address's value as a non-null {@link String}. For example:
+   * <code>us.usd.bank.account</code></p>
+   *
+   * @return A {@link String} representation of this Interledger address.
+   */
+  String getValue();
+
+  /**
+   * <p>Tests if this InterledgerAddress starts with the specified {@code addressSegment}.</p>
+   *
+   * @param addressSegment An {@link String} prefix to compare against.
+   *
+   * @return {@code true} if this InterledgerAddress begins with the specified prefix.
+   */
+  @SuppressWarnings(""unused"")
+  default boolean startsWith(final String addressSegment) {
+    Objects.requireNonNull(addressSegment, ""addressSegment must not be null!"");
+    return this.getValue().startsWith(addressSegment);
+  }
+
+  /**
+   * <p>Tests if this InterledgerAddress starts with the specified {@code addressPrefix}.</p>
+   *
+   * @param addressPrefix An {@link InterledgerAddress} prefix to compare against.
+   *
+   * @return {@code true} if the supplied {@code addressPrefix} begins with the specified prefix.
+   */
+  @SuppressWarnings(""unused"")
+  default boolean startsWith(final InterledgerAddressPrefix addressPrefix) {
+    Objects.requireNonNull(addressPrefix, ""addressPrefix must not be null!"");
+    return this.getValue().startsWith(addressPrefix.getValue());
+  }
+
+  /**
+   * <p>Return a new {@link InterledgerAddress} by suffixing the supplied {@code addressSegment}
+   * onto the current address.</p>
+   *
+   * @param addressSegment A {@link String} to be appended to this address as an additional
+   *                       segment.
+   *
+   * @return A new instance representing the original address with a newly specified final segment.
+   */
+  default InterledgerAddressPrefix with(final String addressSegment) {
+    Objects.requireNonNull(addressSegment, ""addressSegment must not be null!"");
+
+    // `+` operator uses StringBuilder internally, so for small numbers of appends, `+` is
+    // equivalent in performance, but provides better code readability.
+    return InterledgerAddressPrefix.of(this.getValue() + ""."" + addressSegment);
+  }
+
+  /**
+   * <p>Return this address's prefix.</p>
+   *
+   * <p>If this address has only a single segment after the allocation scheme, then this method
+   * returns {@link Optional#empty()}. Otherwise, this method returns a new {@link
+   * InterledgerAddress} containing the characters inside of {@link #getValue()}, up-to but
+   * excluding last period.</p>
+   *
+   * <p>For example, calling this method on an address <tt>g.example.alice</tt> would yield a new
+   * address containing <tt>g.example</tt>. However, calling this method on an address like
+   * <tt>g.example</tt> would yield {@link Optional#empty()}.</p>
+   *
+   * @return An optionally present parent-prefix as an {@link InterledgerAddress}.
+   */
+  default Optional<InterledgerAddressPrefix> getPrefix() {
+    // An address will always contain at least one period (.), so we can always
+    final String value = getValue();
+    final boolean hasDot = value.contains(""."");
+    if (hasDot) {
+      return Optional.of(
+          InterledgerAddressPrefix.builder()
+              .value(value.substring(0, value.lastIndexOf(""."")))
+              .build()
+      );
+    } else {
+      return Optional.empty();
+    }
+  }
+
+  /**
+   * <p>Determines if this ILP Address has a parent-prefix.</p>
+   *
+   * @return {@code true} if this address has more than two segments after the allocation scheme.
+   *     Otherwise return {@code false}.
+   */
+  @SuppressWarnings(""unused"")
+  default boolean hasPrefix() {
+    return getPrefix().isPresent();
+  }
+
+  /**
+   * Compute the root-prefix of the supplied {@code address}. If this prefix is already a
+   * root-prefix (i.e., an AllocationScheme) then this prefix is returned.
+   *
+   * @return An {@link InterledgerAddressPrefix} representing the root prefix for the supplied
+   *     Interledger address.
+   */
+  default InterledgerAddressPrefix getRootPrefix() {
+    return this.getPrefix()
+        .map(InterledgerAddressPrefix::getRootPrefix)
+        .orElse(this);
+  }
+
+  /**
+   * <p>An implementation of {@link InterledgerAddress} that enforces allowed value per
+   * RFC-15.</p>
+   *
+   * <p>This immutable is interned because it only holds a {@link String} value, which itself is
+   * interned via the Java String pool.</p>
+   */
+  @Value.Immutable
+  @Value.Style(
+      typeBuilder = ""*Builder"",
+      visibility = Value.Style.ImplementationVisibility.PRIVATE,
+      builderVisibility = Value.Style.BuilderVisibility.PUBLIC,
+      defaults = @Value.Immutable(intern = true))",199,2018-10-10 13:42:22,https://api.github.com/repos/hyperledger/quilt/pulls/comments/217949235,https://github.com/hyperledger/quilt/pull/174#discussion_r217949235,sublimator
https://github.com/hyperledger/quilt/pull/174,https://github.com/hyperledger/quilt/pull/174,"infi-nit:
```
@param message                 The detail message.
```",e49179834652f2da9ab686a6732ddf3be56f7180,2018-09-17 05:04:15,217949363,"@@ -35,20 +35,20 @@
    * Required-args constructor.
    *
    * @param interledgerRejectPacket An instance of {@link InterledgerRejectPacket} that is the
-   *                                 underlying error encapsulated by this exception.
+   *                                underlying error encapsulated by this exception.
    */
   public InterledgerProtocolException(final InterledgerRejectPacket interledgerRejectPacket) {
-    super(""Interledger Rejection."");
+    super(String.format(""Interledger Rejection: %s"", interledgerRejectPacket.getMessage()));
     this.interledgerRejectPacket = fillInterledgerRejectPacket(interledgerRejectPacket);
   }
 
   /**
-   * Constructs a new Interledger protocol exception with the specified reject packet and
-   * detail message.
+   * Constructs a new Interledger protocol exception with the specified reject packet and detail
+   * message.
    *
    * @param interledgerRejectPacket An instance of {@link InterledgerRejectPacket} that is the
-   *                                 underlying error encapsulated by this exception.
-   * @param message The detail message.
+   *                                underlying error encapsulated by this exception.
+   * @param message                 The detail message.",35,2018-10-10 13:42:22,https://api.github.com/repos/hyperledger/quilt/pulls/comments/217949363,https://github.com/hyperledger/quilt/pull/174#discussion_r217949363,sublimator
https://github.com/hyperledger/quilt/pull/174,https://github.com/hyperledger/quilt/pull/174,No win in precompiling the regexes ?,e49179834652f2da9ab686a6732ddf3be56f7180,2018-09-17 05:06:17,217949495,"@@ -0,0 +1,298 @@
+package org.interledger.core;
+
+import org.interledger.core.InterledgerAddress.AllocationScheme;
+
+import org.immutables.value.Value;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+/**
+ * <p>Represents a prefix for an {@link InterledgerAddress}. This class differs only slightly from
+ * {@link InterledgerAddress} in that is allows any valid Interledger address as well as allocation
+ * schemes, whereas {@link InterledgerAddress} requires both an {@link AllocationScheme} as well as
+ * a segment in order to be valid.</p>
+ */
+public interface InterledgerAddressPrefix {
+
+  // Prefixes for all Allocation Schemes.
+  InterledgerAddressPrefix GLOBAL = InterledgerAddressPrefix.from(AllocationScheme.GLOBAL);
+  InterledgerAddressPrefix PRIVATE = InterledgerAddressPrefix.from(AllocationScheme.PRIVATE);
+  InterledgerAddressPrefix EXAMPLE = InterledgerAddressPrefix.from(AllocationScheme.EXAMPLE);
+  InterledgerAddressPrefix PEER = InterledgerAddressPrefix.from(AllocationScheme.PEER);
+  InterledgerAddressPrefix SELF = InterledgerAddressPrefix.from(AllocationScheme.SELF);
+  InterledgerAddressPrefix TEST = InterledgerAddressPrefix.from(AllocationScheme.TEST);
+  InterledgerAddressPrefix TEST1 = InterledgerAddressPrefix.from(AllocationScheme.TEST1);
+  InterledgerAddressPrefix TEST2 = InterledgerAddressPrefix.from(AllocationScheme.TEST2);
+  InterledgerAddressPrefix TEST3 = InterledgerAddressPrefix.from(AllocationScheme.TEST3);
+
+  /**
+   * Constructor to allow quick construction from a {@link String}.
+   *
+   * @param value String representation of an Interledger Address
+   *
+   * @return an {@link InterledgerAddress} instance.
+   *
+   * @throws NullPointerException if {@code value} is <tt>null</tt>.
+   */
+  static InterledgerAddressPrefix of(final String value) {
+    Objects.requireNonNull(value, ""value must not be null!"");
+    return builder().value(value).build();
+  }
+
+  /**
+   * Convert from an {@link InterledgerAddress} into an {@link InterledgerAddressPrefix}.
+   *
+   * @param interledgerAddress An {@link InterledgerAddress} to convert from.
+   *
+   * @return A corresponding {@link InterledgerAddressPrefix}.
+   */
+  static InterledgerAddressPrefix from(final InterledgerAddress interledgerAddress) {
+    return builder().value(interledgerAddress.getValue()).build();
+  }
+
+  /**
+   * Convert from an {@link AllocationScheme} into an {@link InterledgerAddressPrefix}.
+   *
+   * @param allocationScheme An {@link AllocationScheme} to convert from.
+   *
+   * @return A corresponding {@link InterledgerAddressPrefix}.
+   */
+  static InterledgerAddressPrefix from(final AllocationScheme allocationScheme) {
+    return builder().value(allocationScheme.getValue()).build();
+  }
+
+  /**
+   * <p>Construct a default builder.</p>
+   *
+   * @return An {@link InterledgerAddressBuilder} instance.
+   */
+  static InterledgerAddressPrefixBuilder builder() {
+    return new InterledgerAddressPrefixBuilder();
+  }
+
+  /**
+   * <p>Accessor for this address's value as a non-null {@link String}. For example:
+   * <code>us.usd.bank.account</code></p>
+   *
+   * @return A {@link String} representation of this Interledger address.
+   */
+  String getValue();
+
+  /**
+   * <p>Tests if this InterledgerAddress starts with the specified {@code addressSegment}.</p>
+   *
+   * @param addressSegment An {@link String} prefix to compare against.
+   *
+   * @return {@code true} if this InterledgerAddress begins with the specified prefix.
+   */
+  @SuppressWarnings(""unused"")
+  default boolean startsWith(final String addressSegment) {
+    Objects.requireNonNull(addressSegment, ""addressSegment must not be null!"");
+    return this.getValue().startsWith(addressSegment);
+  }
+
+  /**
+   * <p>Tests if this InterledgerAddress starts with the specified {@code addressPrefix}.</p>
+   *
+   * @param addressPrefix An {@link InterledgerAddress} prefix to compare against.
+   *
+   * @return {@code true} if the supplied {@code addressPrefix} begins with the specified prefix.
+   */
+  @SuppressWarnings(""unused"")
+  default boolean startsWith(final InterledgerAddressPrefix addressPrefix) {
+    Objects.requireNonNull(addressPrefix, ""addressPrefix must not be null!"");
+    return this.getValue().startsWith(addressPrefix.getValue());
+  }
+
+  /**
+   * <p>Return a new {@link InterledgerAddress} by suffixing the supplied {@code addressSegment}
+   * onto the current address.</p>
+   *
+   * @param addressSegment A {@link String} to be appended to this address as an additional
+   *                       segment.
+   *
+   * @return A new instance representing the original address with a newly specified final segment.
+   */
+  default InterledgerAddressPrefix with(final String addressSegment) {
+    Objects.requireNonNull(addressSegment, ""addressSegment must not be null!"");
+
+    // `+` operator uses StringBuilder internally, so for small numbers of appends, `+` is
+    // equivalent in performance, but provides better code readability.
+    return InterledgerAddressPrefix.of(this.getValue() + ""."" + addressSegment);
+  }
+
+  /**
+   * <p>Return this address's prefix.</p>
+   *
+   * <p>If this address has only a single segment after the allocation scheme, then this method
+   * returns {@link Optional#empty()}. Otherwise, this method returns a new {@link
+   * InterledgerAddress} containing the characters inside of {@link #getValue()}, up-to but
+   * excluding last period.</p>
+   *
+   * <p>For example, calling this method on an address <tt>g.example.alice</tt> would yield a new
+   * address containing <tt>g.example</tt>. However, calling this method on an address like
+   * <tt>g.example</tt> would yield {@link Optional#empty()}.</p>
+   *
+   * @return An optionally present parent-prefix as an {@link InterledgerAddress}.
+   */
+  default Optional<InterledgerAddressPrefix> getPrefix() {
+    // An address will always contain at least one period (.), so we can always
+    final String value = getValue();
+    final boolean hasDot = value.contains(""."");
+    if (hasDot) {
+      return Optional.of(
+          InterledgerAddressPrefix.builder()
+              .value(value.substring(0, value.lastIndexOf(""."")))
+              .build()
+      );
+    } else {
+      return Optional.empty();
+    }
+  }
+
+  /**
+   * <p>Determines if this ILP Address has a parent-prefix.</p>
+   *
+   * @return {@code true} if this address has more than two segments after the allocation scheme.
+   *     Otherwise return {@code false}.
+   */
+  @SuppressWarnings(""unused"")
+  default boolean hasPrefix() {
+    return getPrefix().isPresent();
+  }
+
+  /**
+   * Compute the root-prefix of the supplied {@code address}. If this prefix is already a
+   * root-prefix (i.e., an AllocationScheme) then this prefix is returned.
+   *
+   * @return An {@link InterledgerAddressPrefix} representing the root prefix for the supplied
+   *     Interledger address.
+   */
+  default InterledgerAddressPrefix getRootPrefix() {
+    return this.getPrefix()
+        .map(InterledgerAddressPrefix::getRootPrefix)
+        .orElse(this);
+  }
+
+  /**
+   * <p>An implementation of {@link InterledgerAddress} that enforces allowed value per
+   * RFC-15.</p>
+   *
+   * <p>This immutable is interned because it only holds a {@link String} value, which itself is
+   * interned via the Java String pool.</p>
+   */
+  @Value.Immutable
+  @Value.Style(
+      typeBuilder = ""*Builder"",
+      visibility = Value.Style.ImplementationVisibility.PRIVATE,
+      builderVisibility = Value.Style.BuilderVisibility.PUBLIC,
+      defaults = @Value.Immutable(intern = true))
+  abstract class AbstractInterledgerAddressPrefix implements InterledgerAddressPrefix {
+
+    private static final String VALID_ADDRESS_PREFIX_REGEX
+        = ""(?=^.{1,1023}$)^(g|private|example|peer|self|test[1-3]?|local)([.][a-zA-Z0-9_~-]+)*$"";
+    private static final Pattern VALID_ADDRESS_PATTERN = Pattern
+        .compile(VALID_ADDRESS_PREFIX_REGEX);
+
+    private static final int ADDRESS_MIN_SEGMENTS = 1;
+    private static final String SCHEME_REGEX = ""(g|private|example|peer|self|test[1-3]?)"";
+    private static final String SEGMENT_REGEX = ""[a-zA-Z0-9_~-]+"";
+    private static final String SEPARATOR_REGEX = ""[.]"";
+    private static final String ADDRESS_LENGTH_BOUNDARIES_REGEX = ""(?=^.{1,1021}$)"";
+
+    /**
+     * Precondition enforcer that ensures the value is a valid Interledger Address.
+     *
+     * @see ""https://github.com/interledger/rfcs/blob/master/0015-ilp-addresses/0015-ilp-addresses.md""
+     */
+    @Value.Check
+    void check() {
+      if (!VALID_ADDRESS_PATTERN.matcher(getValue()).matches()) {
+        // For performance reasons, we only do we do deeper introspection of the error if the input
+        // fails the VALID_ADDRESS_PATTERN check.
+        throw new IllegalArgumentException(getFirstInvalidityCause(getValue()));
+      }
+    }
+
+    /**
+     * Inspect an invalid Address String and determine the cause.
+     *
+     * @param invalidAddressString A {@link String} containing an invalid Interledger Address.
+     *
+     * @return An error String.
+     */
+    private String getFirstInvalidityCause(final String invalidAddressString) {
+      // validate no trailing period.
+      if (invalidAddressString.endsWith(""."")) {
+        return Error.ILLEGAL_ENDING.getMessageFormat();
+      }
+
+      final List<String> schemeAndSegments = Arrays.asList(
+          invalidAddressString.split(SEPARATOR_REGEX, -1)
+      );
+      // validates scheme prefix format
+      final String schemePrefix = schemeAndSegments.get(0);
+      if (!Pattern.compile(SCHEME_REGEX).matcher(schemePrefix).matches()) {
+        return String.format(Error.INVALID_SCHEME_PREFIX.getMessageFormat(), schemePrefix);",246,2018-10-10 13:42:22,https://api.github.com/repos/hyperledger/quilt/pulls/comments/217949495,https://github.com/hyperledger/quilt/pull/174#discussion_r217949495,sublimator
https://github.com/hyperledger/quilt/pull/174,https://github.com/hyperledger/quilt/pull/174,I think the spacing is purposeful -- it aligns with the description of the `message` field.,e49179834652f2da9ab686a6732ddf3be56f7180,2018-09-18 13:43:02,218436733,"@@ -35,20 +35,20 @@
    * Required-args constructor.
    *
    * @param interledgerRejectPacket An instance of {@link InterledgerRejectPacket} that is the
-   *                                 underlying error encapsulated by this exception.
+   *                                underlying error encapsulated by this exception.
    */
   public InterledgerProtocolException(final InterledgerRejectPacket interledgerRejectPacket) {
-    super(""Interledger Rejection."");
+    super(String.format(""Interledger Rejection: %s"", interledgerRejectPacket.getMessage()));
     this.interledgerRejectPacket = fillInterledgerRejectPacket(interledgerRejectPacket);
   }
 
   /**
-   * Constructs a new Interledger protocol exception with the specified reject packet and
-   * detail message.
+   * Constructs a new Interledger protocol exception with the specified reject packet and detail
+   * message.
    *
    * @param interledgerRejectPacket An instance of {@link InterledgerRejectPacket} that is the
-   *                                 underlying error encapsulated by this exception.
-   * @param message The detail message.
+   *                                underlying error encapsulated by this exception.
+   * @param message                 The detail message.",35,2018-10-10 13:42:22,https://api.github.com/repos/hyperledger/quilt/pulls/comments/218436733,https://github.com/hyperledger/quilt/pull/174#discussion_r218436733,sappenin
https://github.com/hyperledger/quilt/pull/174,https://github.com/hyperledger/quilt/pull/174,That's a great point - this code was part of an external submission in `InterledgerAddress` that I mostly just adapted here. I'll try that out.,e49179834652f2da9ab686a6732ddf3be56f7180,2018-09-18 14:00:00,218443826,"@@ -0,0 +1,298 @@
+package org.interledger.core;
+
+import org.interledger.core.InterledgerAddress.AllocationScheme;
+
+import org.immutables.value.Value;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+/**
+ * <p>Represents a prefix for an {@link InterledgerAddress}. This class differs only slightly from
+ * {@link InterledgerAddress} in that is allows any valid Interledger address as well as allocation
+ * schemes, whereas {@link InterledgerAddress} requires both an {@link AllocationScheme} as well as
+ * a segment in order to be valid.</p>
+ */
+public interface InterledgerAddressPrefix {
+
+  // Prefixes for all Allocation Schemes.
+  InterledgerAddressPrefix GLOBAL = InterledgerAddressPrefix.from(AllocationScheme.GLOBAL);
+  InterledgerAddressPrefix PRIVATE = InterledgerAddressPrefix.from(AllocationScheme.PRIVATE);
+  InterledgerAddressPrefix EXAMPLE = InterledgerAddressPrefix.from(AllocationScheme.EXAMPLE);
+  InterledgerAddressPrefix PEER = InterledgerAddressPrefix.from(AllocationScheme.PEER);
+  InterledgerAddressPrefix SELF = InterledgerAddressPrefix.from(AllocationScheme.SELF);
+  InterledgerAddressPrefix TEST = InterledgerAddressPrefix.from(AllocationScheme.TEST);
+  InterledgerAddressPrefix TEST1 = InterledgerAddressPrefix.from(AllocationScheme.TEST1);
+  InterledgerAddressPrefix TEST2 = InterledgerAddressPrefix.from(AllocationScheme.TEST2);
+  InterledgerAddressPrefix TEST3 = InterledgerAddressPrefix.from(AllocationScheme.TEST3);
+
+  /**
+   * Constructor to allow quick construction from a {@link String}.
+   *
+   * @param value String representation of an Interledger Address
+   *
+   * @return an {@link InterledgerAddress} instance.
+   *
+   * @throws NullPointerException if {@code value} is <tt>null</tt>.
+   */
+  static InterledgerAddressPrefix of(final String value) {
+    Objects.requireNonNull(value, ""value must not be null!"");
+    return builder().value(value).build();
+  }
+
+  /**
+   * Convert from an {@link InterledgerAddress} into an {@link InterledgerAddressPrefix}.
+   *
+   * @param interledgerAddress An {@link InterledgerAddress} to convert from.
+   *
+   * @return A corresponding {@link InterledgerAddressPrefix}.
+   */
+  static InterledgerAddressPrefix from(final InterledgerAddress interledgerAddress) {
+    return builder().value(interledgerAddress.getValue()).build();
+  }
+
+  /**
+   * Convert from an {@link AllocationScheme} into an {@link InterledgerAddressPrefix}.
+   *
+   * @param allocationScheme An {@link AllocationScheme} to convert from.
+   *
+   * @return A corresponding {@link InterledgerAddressPrefix}.
+   */
+  static InterledgerAddressPrefix from(final AllocationScheme allocationScheme) {
+    return builder().value(allocationScheme.getValue()).build();
+  }
+
+  /**
+   * <p>Construct a default builder.</p>
+   *
+   * @return An {@link InterledgerAddressBuilder} instance.
+   */
+  static InterledgerAddressPrefixBuilder builder() {
+    return new InterledgerAddressPrefixBuilder();
+  }
+
+  /**
+   * <p>Accessor for this address's value as a non-null {@link String}. For example:
+   * <code>us.usd.bank.account</code></p>
+   *
+   * @return A {@link String} representation of this Interledger address.
+   */
+  String getValue();
+
+  /**
+   * <p>Tests if this InterledgerAddress starts with the specified {@code addressSegment}.</p>
+   *
+   * @param addressSegment An {@link String} prefix to compare against.
+   *
+   * @return {@code true} if this InterledgerAddress begins with the specified prefix.
+   */
+  @SuppressWarnings(""unused"")
+  default boolean startsWith(final String addressSegment) {
+    Objects.requireNonNull(addressSegment, ""addressSegment must not be null!"");
+    return this.getValue().startsWith(addressSegment);
+  }
+
+  /**
+   * <p>Tests if this InterledgerAddress starts with the specified {@code addressPrefix}.</p>
+   *
+   * @param addressPrefix An {@link InterledgerAddress} prefix to compare against.
+   *
+   * @return {@code true} if the supplied {@code addressPrefix} begins with the specified prefix.
+   */
+  @SuppressWarnings(""unused"")
+  default boolean startsWith(final InterledgerAddressPrefix addressPrefix) {
+    Objects.requireNonNull(addressPrefix, ""addressPrefix must not be null!"");
+    return this.getValue().startsWith(addressPrefix.getValue());
+  }
+
+  /**
+   * <p>Return a new {@link InterledgerAddress} by suffixing the supplied {@code addressSegment}
+   * onto the current address.</p>
+   *
+   * @param addressSegment A {@link String} to be appended to this address as an additional
+   *                       segment.
+   *
+   * @return A new instance representing the original address with a newly specified final segment.
+   */
+  default InterledgerAddressPrefix with(final String addressSegment) {
+    Objects.requireNonNull(addressSegment, ""addressSegment must not be null!"");
+
+    // `+` operator uses StringBuilder internally, so for small numbers of appends, `+` is
+    // equivalent in performance, but provides better code readability.
+    return InterledgerAddressPrefix.of(this.getValue() + ""."" + addressSegment);
+  }
+
+  /**
+   * <p>Return this address's prefix.</p>
+   *
+   * <p>If this address has only a single segment after the allocation scheme, then this method
+   * returns {@link Optional#empty()}. Otherwise, this method returns a new {@link
+   * InterledgerAddress} containing the characters inside of {@link #getValue()}, up-to but
+   * excluding last period.</p>
+   *
+   * <p>For example, calling this method on an address <tt>g.example.alice</tt> would yield a new
+   * address containing <tt>g.example</tt>. However, calling this method on an address like
+   * <tt>g.example</tt> would yield {@link Optional#empty()}.</p>
+   *
+   * @return An optionally present parent-prefix as an {@link InterledgerAddress}.
+   */
+  default Optional<InterledgerAddressPrefix> getPrefix() {
+    // An address will always contain at least one period (.), so we can always
+    final String value = getValue();
+    final boolean hasDot = value.contains(""."");
+    if (hasDot) {
+      return Optional.of(
+          InterledgerAddressPrefix.builder()
+              .value(value.substring(0, value.lastIndexOf(""."")))
+              .build()
+      );
+    } else {
+      return Optional.empty();
+    }
+  }
+
+  /**
+   * <p>Determines if this ILP Address has a parent-prefix.</p>
+   *
+   * @return {@code true} if this address has more than two segments after the allocation scheme.
+   *     Otherwise return {@code false}.
+   */
+  @SuppressWarnings(""unused"")
+  default boolean hasPrefix() {
+    return getPrefix().isPresent();
+  }
+
+  /**
+   * Compute the root-prefix of the supplied {@code address}. If this prefix is already a
+   * root-prefix (i.e., an AllocationScheme) then this prefix is returned.
+   *
+   * @return An {@link InterledgerAddressPrefix} representing the root prefix for the supplied
+   *     Interledger address.
+   */
+  default InterledgerAddressPrefix getRootPrefix() {
+    return this.getPrefix()
+        .map(InterledgerAddressPrefix::getRootPrefix)
+        .orElse(this);
+  }
+
+  /**
+   * <p>An implementation of {@link InterledgerAddress} that enforces allowed value per
+   * RFC-15.</p>
+   *
+   * <p>This immutable is interned because it only holds a {@link String} value, which itself is
+   * interned via the Java String pool.</p>
+   */
+  @Value.Immutable
+  @Value.Style(
+      typeBuilder = ""*Builder"",
+      visibility = Value.Style.ImplementationVisibility.PRIVATE,
+      builderVisibility = Value.Style.BuilderVisibility.PUBLIC,
+      defaults = @Value.Immutable(intern = true))
+  abstract class AbstractInterledgerAddressPrefix implements InterledgerAddressPrefix {
+
+    private static final String VALID_ADDRESS_PREFIX_REGEX
+        = ""(?=^.{1,1023}$)^(g|private|example|peer|self|test[1-3]?|local)([.][a-zA-Z0-9_~-]+)*$"";
+    private static final Pattern VALID_ADDRESS_PATTERN = Pattern
+        .compile(VALID_ADDRESS_PREFIX_REGEX);
+
+    private static final int ADDRESS_MIN_SEGMENTS = 1;
+    private static final String SCHEME_REGEX = ""(g|private|example|peer|self|test[1-3]?)"";
+    private static final String SEGMENT_REGEX = ""[a-zA-Z0-9_~-]+"";
+    private static final String SEPARATOR_REGEX = ""[.]"";
+    private static final String ADDRESS_LENGTH_BOUNDARIES_REGEX = ""(?=^.{1,1021}$)"";
+
+    /**
+     * Precondition enforcer that ensures the value is a valid Interledger Address.
+     *
+     * @see ""https://github.com/interledger/rfcs/blob/master/0015-ilp-addresses/0015-ilp-addresses.md""
+     */
+    @Value.Check
+    void check() {
+      if (!VALID_ADDRESS_PATTERN.matcher(getValue()).matches()) {
+        // For performance reasons, we only do we do deeper introspection of the error if the input
+        // fails the VALID_ADDRESS_PATTERN check.
+        throw new IllegalArgumentException(getFirstInvalidityCause(getValue()));
+      }
+    }
+
+    /**
+     * Inspect an invalid Address String and determine the cause.
+     *
+     * @param invalidAddressString A {@link String} containing an invalid Interledger Address.
+     *
+     * @return An error String.
+     */
+    private String getFirstInvalidityCause(final String invalidAddressString) {
+      // validate no trailing period.
+      if (invalidAddressString.endsWith(""."")) {
+        return Error.ILLEGAL_ENDING.getMessageFormat();
+      }
+
+      final List<String> schemeAndSegments = Arrays.asList(
+          invalidAddressString.split(SEPARATOR_REGEX, -1)
+      );
+      // validates scheme prefix format
+      final String schemePrefix = schemeAndSegments.get(0);
+      if (!Pattern.compile(SCHEME_REGEX).matcher(schemePrefix).matches()) {
+        return String.format(Error.INVALID_SCHEME_PREFIX.getMessageFormat(), schemePrefix);",246,2018-10-10 13:42:22,https://api.github.com/repos/hyperledger/quilt/pulls/comments/218443826,https://github.com/hyperledger/quilt/pull/174#discussion_r218443826,sappenin
https://github.com/hyperledger/quilt/pull/174,https://github.com/hyperledger/quilt/pull/174,Fixed.,e49179834652f2da9ab686a6732ddf3be56f7180,2018-09-18 14:00:34,218444043,"@@ -0,0 +1,298 @@
+package org.interledger.core;
+
+import org.interledger.core.InterledgerAddress.AllocationScheme;
+
+import org.immutables.value.Value;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+/**
+ * <p>Represents a prefix for an {@link InterledgerAddress}. This class differs only slightly from
+ * {@link InterledgerAddress} in that is allows any valid Interledger address as well as allocation
+ * schemes, whereas {@link InterledgerAddress} requires both an {@link AllocationScheme} as well as
+ * a segment in order to be valid.</p>
+ */
+public interface InterledgerAddressPrefix {
+
+  // Prefixes for all Allocation Schemes.
+  InterledgerAddressPrefix GLOBAL = InterledgerAddressPrefix.from(AllocationScheme.GLOBAL);
+  InterledgerAddressPrefix PRIVATE = InterledgerAddressPrefix.from(AllocationScheme.PRIVATE);
+  InterledgerAddressPrefix EXAMPLE = InterledgerAddressPrefix.from(AllocationScheme.EXAMPLE);
+  InterledgerAddressPrefix PEER = InterledgerAddressPrefix.from(AllocationScheme.PEER);
+  InterledgerAddressPrefix SELF = InterledgerAddressPrefix.from(AllocationScheme.SELF);
+  InterledgerAddressPrefix TEST = InterledgerAddressPrefix.from(AllocationScheme.TEST);
+  InterledgerAddressPrefix TEST1 = InterledgerAddressPrefix.from(AllocationScheme.TEST1);
+  InterledgerAddressPrefix TEST2 = InterledgerAddressPrefix.from(AllocationScheme.TEST2);
+  InterledgerAddressPrefix TEST3 = InterledgerAddressPrefix.from(AllocationScheme.TEST3);
+
+  /**
+   * Constructor to allow quick construction from a {@link String}.
+   *
+   * @param value String representation of an Interledger Address
+   *
+   * @return an {@link InterledgerAddress} instance.
+   *
+   * @throws NullPointerException if {@code value} is <tt>null</tt>.
+   */
+  static InterledgerAddressPrefix of(final String value) {
+    Objects.requireNonNull(value, ""value must not be null!"");
+    return builder().value(value).build();
+  }
+
+  /**
+   * Convert from an {@link InterledgerAddress} into an {@link InterledgerAddressPrefix}.
+   *
+   * @param interledgerAddress An {@link InterledgerAddress} to convert from.
+   *
+   * @return A corresponding {@link InterledgerAddressPrefix}.
+   */
+  static InterledgerAddressPrefix from(final InterledgerAddress interledgerAddress) {
+    return builder().value(interledgerAddress.getValue()).build();
+  }
+
+  /**
+   * Convert from an {@link AllocationScheme} into an {@link InterledgerAddressPrefix}.
+   *
+   * @param allocationScheme An {@link AllocationScheme} to convert from.
+   *
+   * @return A corresponding {@link InterledgerAddressPrefix}.
+   */
+  static InterledgerAddressPrefix from(final AllocationScheme allocationScheme) {
+    return builder().value(allocationScheme.getValue()).build();
+  }
+
+  /**
+   * <p>Construct a default builder.</p>
+   *
+   * @return An {@link InterledgerAddressBuilder} instance.
+   */
+  static InterledgerAddressPrefixBuilder builder() {
+    return new InterledgerAddressPrefixBuilder();
+  }
+
+  /**
+   * <p>Accessor for this address's value as a non-null {@link String}. For example:
+   * <code>us.usd.bank.account</code></p>
+   *
+   * @return A {@link String} representation of this Interledger address.
+   */
+  String getValue();
+
+  /**
+   * <p>Tests if this InterledgerAddress starts with the specified {@code addressSegment}.</p>
+   *
+   * @param addressSegment An {@link String} prefix to compare against.
+   *
+   * @return {@code true} if this InterledgerAddress begins with the specified prefix.
+   */
+  @SuppressWarnings(""unused"")
+  default boolean startsWith(final String addressSegment) {
+    Objects.requireNonNull(addressSegment, ""addressSegment must not be null!"");
+    return this.getValue().startsWith(addressSegment);
+  }
+
+  /**
+   * <p>Tests if this InterledgerAddress starts with the specified {@code addressPrefix}.</p>
+   *
+   * @param addressPrefix An {@link InterledgerAddress} prefix to compare against.
+   *
+   * @return {@code true} if the supplied {@code addressPrefix} begins with the specified prefix.
+   */
+  @SuppressWarnings(""unused"")
+  default boolean startsWith(final InterledgerAddressPrefix addressPrefix) {
+    Objects.requireNonNull(addressPrefix, ""addressPrefix must not be null!"");
+    return this.getValue().startsWith(addressPrefix.getValue());
+  }
+
+  /**
+   * <p>Return a new {@link InterledgerAddress} by suffixing the supplied {@code addressSegment}
+   * onto the current address.</p>
+   *
+   * @param addressSegment A {@link String} to be appended to this address as an additional
+   *                       segment.
+   *
+   * @return A new instance representing the original address with a newly specified final segment.
+   */
+  default InterledgerAddressPrefix with(final String addressSegment) {
+    Objects.requireNonNull(addressSegment, ""addressSegment must not be null!"");
+
+    // `+` operator uses StringBuilder internally, so for small numbers of appends, `+` is
+    // equivalent in performance, but provides better code readability.
+    return InterledgerAddressPrefix.of(this.getValue() + ""."" + addressSegment);
+  }
+
+  /**
+   * <p>Return this address's prefix.</p>
+   *
+   * <p>If this address has only a single segment after the allocation scheme, then this method
+   * returns {@link Optional#empty()}. Otherwise, this method returns a new {@link
+   * InterledgerAddress} containing the characters inside of {@link #getValue()}, up-to but
+   * excluding last period.</p>
+   *
+   * <p>For example, calling this method on an address <tt>g.example.alice</tt> would yield a new
+   * address containing <tt>g.example</tt>. However, calling this method on an address like
+   * <tt>g.example</tt> would yield {@link Optional#empty()}.</p>
+   *
+   * @return An optionally present parent-prefix as an {@link InterledgerAddress}.
+   */
+  default Optional<InterledgerAddressPrefix> getPrefix() {
+    // An address will always contain at least one period (.), so we can always
+    final String value = getValue();
+    final boolean hasDot = value.contains(""."");
+    if (hasDot) {
+      return Optional.of(
+          InterledgerAddressPrefix.builder()
+              .value(value.substring(0, value.lastIndexOf(""."")))
+              .build()
+      );
+    } else {
+      return Optional.empty();
+    }
+  }
+
+  /**
+   * <p>Determines if this ILP Address has a parent-prefix.</p>
+   *
+   * @return {@code true} if this address has more than two segments after the allocation scheme.
+   *     Otherwise return {@code false}.
+   */
+  @SuppressWarnings(""unused"")
+  default boolean hasPrefix() {
+    return getPrefix().isPresent();
+  }
+
+  /**
+   * Compute the root-prefix of the supplied {@code address}. If this prefix is already a
+   * root-prefix (i.e., an AllocationScheme) then this prefix is returned.
+   *
+   * @return An {@link InterledgerAddressPrefix} representing the root prefix for the supplied
+   *     Interledger address.
+   */
+  default InterledgerAddressPrefix getRootPrefix() {
+    return this.getPrefix()
+        .map(InterledgerAddressPrefix::getRootPrefix)
+        .orElse(this);
+  }
+
+  /**
+   * <p>An implementation of {@link InterledgerAddress} that enforces allowed value per
+   * RFC-15.</p>
+   *
+   * <p>This immutable is interned because it only holds a {@link String} value, which itself is
+   * interned via the Java String pool.</p>
+   */
+  @Value.Immutable
+  @Value.Style(
+      typeBuilder = ""*Builder"",
+      visibility = Value.Style.ImplementationVisibility.PRIVATE,
+      builderVisibility = Value.Style.BuilderVisibility.PUBLIC,
+      defaults = @Value.Immutable(intern = true))
+  abstract class AbstractInterledgerAddressPrefix implements InterledgerAddressPrefix {
+
+    private static final String VALID_ADDRESS_PREFIX_REGEX
+        = ""(?=^.{1,1023}$)^(g|private|example|peer|self|test[1-3]?|local)([.][a-zA-Z0-9_~-]+)*$"";
+    private static final Pattern VALID_ADDRESS_PATTERN = Pattern
+        .compile(VALID_ADDRESS_PREFIX_REGEX);
+
+    private static final int ADDRESS_MIN_SEGMENTS = 1;
+    private static final String SCHEME_REGEX = ""(g|private|example|peer|self|test[1-3]?)"";
+    private static final String SEGMENT_REGEX = ""[a-zA-Z0-9_~-]+"";
+    private static final String SEPARATOR_REGEX = ""[.]"";
+    private static final String ADDRESS_LENGTH_BOUNDARIES_REGEX = ""(?=^.{1,1021}$)"";
+
+    /**
+     * Precondition enforcer that ensures the value is a valid Interledger Address.
+     *
+     * @see ""https://github.com/interledger/rfcs/blob/master/0015-ilp-addresses/0015-ilp-addresses.md""
+     */
+    @Value.Check
+    void check() {
+      if (!VALID_ADDRESS_PATTERN.matcher(getValue()).matches()) {
+        // For performance reasons, we only do we do deeper introspection of the error if the input
+        // fails the VALID_ADDRESS_PATTERN check.
+        throw new IllegalArgumentException(getFirstInvalidityCause(getValue()));
+      }
+    }
+
+    /**
+     * Inspect an invalid Address String and determine the cause.
+     *
+     * @param invalidAddressString A {@link String} containing an invalid Interledger Address.
+     *
+     * @return An error String.
+     */
+    private String getFirstInvalidityCause(final String invalidAddressString) {
+      // validate no trailing period.
+      if (invalidAddressString.endsWith(""."")) {
+        return Error.ILLEGAL_ENDING.getMessageFormat();
+      }
+
+      final List<String> schemeAndSegments = Arrays.asList(
+          invalidAddressString.split(SEPARATOR_REGEX, -1)
+      );
+      // validates scheme prefix format
+      final String schemePrefix = schemeAndSegments.get(0);
+      if (!Pattern.compile(SCHEME_REGEX).matcher(schemePrefix).matches()) {
+        return String.format(Error.INVALID_SCHEME_PREFIX.getMessageFormat(), schemePrefix);",246,2018-10-10 13:42:22,https://api.github.com/repos/hyperledger/quilt/pulls/comments/218444043,https://github.com/hyperledger/quilt/pull/174#discussion_r218444043,sappenin
https://github.com/hyperledger/quilt/pull/167,https://github.com/hyperledger/quilt/pull/167,"BTP isn't using the 'new skool' fixed length sizes ?
https://github.com/interledger/rfcs/issues/440#issuecomment-405197100",bf54762cd250b9d7c1a201694e949f0bb3234914,2018-08-12 02:44:17,209441881,"@@ -43,7 +44,7 @@ public AsnBtpErrorDataCodec(long requestId) {
         requestId,
         new AsnUtf8StringCodec(new AsnSizeConstraint(3)), //Code
         new AsnUtf8StringCodec(AsnSizeConstraint.UNCONSTRAINED), //Name
-        new AsnIA5StringCodec(AsnSizeConstraint.UNCONSTRAINED), //TODO Parse time
+        new AsnIA5StringCodec(AsnSizeConstraint.UNCONSTRAINED), //TriggeredAt",33,2018-08-18 22:08:07,https://api.github.com/repos/hyperledger/quilt/pulls/comments/209441881,https://github.com/hyperledger/quilt/pull/167#discussion_r209441881,sublimator
https://github.com/hyperledger/quilt/pull/167,https://github.com/hyperledger/quilt/pull/167,typo,bf54762cd250b9d7c1a201694e949f0bb3234914,2018-08-12 02:50:51,209441955,"@@ -26,12 +26,11 @@
    * Construct an instance of this parameterized test with the supplied inputs.
    *
    * @param expectedUint         The expected value, as a {@link BigInteger}, of {@code
-   *                             expectedEncodedBytes}, once encoded.
+   *                             exptedEncodedBytes}, once encoded.",,2018-08-18 22:08:07,https://api.github.com/repos/hyperledger/quilt/pulls/comments/209441955,https://github.com/hyperledger/quilt/pull/167#discussion_r209441955,sublimator
https://github.com/hyperledger/quilt/pull/167,https://github.com/hyperledger/quilt/pull/167,Guess not: https://github.com/interledger/rfcs/blob/master/asn1/BilateralTransferProtocol.asn#L72,bf54762cd250b9d7c1a201694e949f0bb3234914,2018-08-14 01:55:51,209809620,"@@ -43,7 +44,7 @@ public AsnBtpErrorDataCodec(long requestId) {
         requestId,
         new AsnUtf8StringCodec(new AsnSizeConstraint(3)), //Code
         new AsnUtf8StringCodec(AsnSizeConstraint.UNCONSTRAINED), //Name
-        new AsnIA5StringCodec(AsnSizeConstraint.UNCONSTRAINED), //TODO Parse time
+        new AsnIA5StringCodec(AsnSizeConstraint.UNCONSTRAINED), //TriggeredAt",33,2018-08-18 22:08:07,https://api.github.com/repos/hyperledger/quilt/pulls/comments/209809620,https://github.com/hyperledger/quilt/pull/167#discussion_r209809620,sublimator
https://github.com/hyperledger/quilt/pull/167,https://github.com/hyperledger/quilt/pull/167,"There is a lot of stuff in there that is outdated. Many of the BTP message types are never used, including `Prepare`.

https://github.com/interledger/rfcs/issues/445#issuecomment-409651286",bf54762cd250b9d7c1a201694e949f0bb3234914,2018-08-14 06:01:52,209836278,"@@ -43,7 +44,7 @@ public AsnBtpErrorDataCodec(long requestId) {
         requestId,
         new AsnUtf8StringCodec(new AsnSizeConstraint(3)), //Code
         new AsnUtf8StringCodec(AsnSizeConstraint.UNCONSTRAINED), //Name
-        new AsnIA5StringCodec(AsnSizeConstraint.UNCONSTRAINED), //TODO Parse time
+        new AsnIA5StringCodec(AsnSizeConstraint.UNCONSTRAINED), //TriggeredAt",33,2018-08-18 22:08:07,https://api.github.com/repos/hyperledger/quilt/pulls/comments/209836278,https://github.com/hyperledger/quilt/pull/167#discussion_r209836278,adrianhopebailie
https://github.com/hyperledger/quilt/pull/167,https://github.com/hyperledger/quilt/pull/167,Fixed.,bf54762cd250b9d7c1a201694e949f0bb3234914,2018-08-18 22:07:48,211086643,"@@ -26,12 +26,11 @@
    * Construct an instance of this parameterized test with the supplied inputs.
    *
    * @param expectedUint         The expected value, as a {@link BigInteger}, of {@code
-   *                             expectedEncodedBytes}, once encoded.
+   *                             exptedEncodedBytes}, once encoded.",,2018-08-18 22:08:07,https://api.github.com/repos/hyperledger/quilt/pulls/comments/211086643,https://github.com/hyperledger/quilt/pull/167#discussion_r211086643,sappenin
https://github.com/hyperledger/quilt/pull/165,https://github.com/hyperledger/quilt/pull/165,"Just an observation :)
1. getX() seems to be the convention for other types
2. kotlin does automagical property stuff if you follow getX()",edfd884211ba45ebe9bc47084f6a864797ed4612,2018-08-05 06:07:20,207726244,"@@ -37,6 +37,6 @@ public InterledgerAddress decode() {
 
   @Override
   public void encode(InterledgerAddress value) {
-    setCharString(value.getValue());
+    setCharString(value.value());",17,2018-08-05 21:57:52,https://api.github.com/repos/hyperledger/quilt/pulls/comments/207726244,https://github.com/hyperledger/quilt/pull/165#discussion_r207726244,sublimator
https://github.com/hyperledger/quilt/pull/165,https://github.com/hyperledger/quilt/pull/165,"So, the author of the immtuables library suggest not using the `get`/`set` prefix on immtuable property values because it collides with the Java POJO standard, but immutables are expressly _not_ POJOs (I only recently came across this information, which is why you see `getX` employed everywhere else in this project).

That said, if there some usefulness in providing a `getX`, I wouldn't be opposed to it. What's the magic that it gives us?",edfd884211ba45ebe9bc47084f6a864797ed4612,2018-08-05 21:55:11,207749641,"@@ -37,6 +37,6 @@ public InterledgerAddress decode() {
 
   @Override
   public void encode(InterledgerAddress value) {
-    setCharString(value.getValue());
+    setCharString(value.value());",17,2018-08-05 21:57:52,https://api.github.com/repos/hyperledger/quilt/pulls/comments/207749641,https://github.com/hyperledger/quilt/pull/165#discussion_r207749641,sappenin
https://github.com/hyperledger/quilt/pull/165,https://github.com/hyperledger/quilt/pull/165,"I'm going to merge this PR as-is. If you want me to add `getValue`, mind creating an issue for it?",edfd884211ba45ebe9bc47084f6a864797ed4612,2018-08-05 22:00:49,207749764,"@@ -37,6 +37,6 @@ public InterledgerAddress decode() {
 
   @Override
   public void encode(InterledgerAddress value) {
-    setCharString(value.getValue());
+    setCharString(value.value());",17,2018-08-05 22:00:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/207749764,https://github.com/hyperledger/quilt/pull/165#discussion_r207749764,sappenin
https://github.com/hyperledger/quilt/pull/165,https://github.com/hyperledger/quilt/pull/165,"Sorry, been busy, just reading this in more detail now

> What's the magic that it gives us?

Kotlin will allows access to `.getSomeValue()` as `.someValue` 

> which is why you see getX employed everywhere else in this projec

So the plan is to refactor to use x() everywhere ? or ?",edfd884211ba45ebe9bc47084f6a864797ed4612,2018-08-07 08:22:23,208139187,"@@ -37,6 +37,6 @@ public InterledgerAddress decode() {
 
   @Override
   public void encode(InterledgerAddress value) {
-    setCharString(value.getValue());
+    setCharString(value.value());",17,2018-08-07 08:22:35,https://api.github.com/repos/hyperledger/quilt/pulls/comments/208139187,https://github.com/hyperledger/quilt/pull/165#discussion_r208139187,sublimator
https://github.com/hyperledger/quilt/pull/165,https://github.com/hyperledger/quilt/pull/165,"That’s a good question - any opinion? Should we use getXyz(), or just .xyz()? Seems like if we chose .xyz(), it would still work with Kotlin, but it does feel weird to not be using “get” as a prefix...",edfd884211ba45ebe9bc47084f6a864797ed4612,2018-08-16 22:37:17,210762037,"@@ -37,6 +37,6 @@ public InterledgerAddress decode() {
 
   @Override
   public void encode(InterledgerAddress value) {
-    setCharString(value.getValue());
+    setCharString(value.value());",17,2018-08-16 22:38:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/210762037,https://github.com/hyperledger/quilt/pull/165#discussion_r210762037,sappenin
https://github.com/hyperledger/quilt/pull/165,https://github.com/hyperledger/quilt/pull/165,"To start with, I'd say consistency trumps any convention, be it Kotlins or Immutables. ""Kotlins"" is really a Java convention as well, hence it feeling weird to you, and is likely what is expected by most Java programmers? Given that, and the fact you are already using `getX()`, I'd say go with that? Can always be revisited later anyway? i.e. be consistent until you make a definitive decision?",edfd884211ba45ebe9bc47084f6a864797ed4612,2018-08-17 04:42:20,210803401,"@@ -37,6 +37,6 @@ public InterledgerAddress decode() {
 
   @Override
   public void encode(InterledgerAddress value) {
-    setCharString(value.getValue());
+    setCharString(value.value());",17,2018-08-17 04:42:20,https://api.github.com/repos/hyperledger/quilt/pulls/comments/210803401,https://github.com/hyperledger/quilt/pull/165#discussion_r210803401,sublimator
https://github.com/hyperledger/quilt/pull/165,https://github.com/hyperledger/quilt/pull/165,"Yeah, I agree - I'll make a new PR to add the `get` syntax.",edfd884211ba45ebe9bc47084f6a864797ed4612,2018-08-18 22:08:44,211086654,"@@ -37,6 +37,6 @@ public InterledgerAddress decode() {
 
   @Override
   public void encode(InterledgerAddress value) {
-    setCharString(value.getValue());
+    setCharString(value.value());",17,2018-08-18 22:08:45,https://api.github.com/repos/hyperledger/quilt/pulls/comments/211086654,https://github.com/hyperledger/quilt/pull/165#discussion_r211086654,sappenin
https://github.com/hyperledger/quilt/pull/163,https://github.com/hyperledger/quilt/pull/163,"ooooh, ouch",4a42f79e6953c2d81d1db10aca184a8fab87981d,2018-07-23 04:33:43,204279991,"@@ -38,18 +38,19 @@ public BigInteger decode() {
   }
 
   @Override
-  public void encode(BigInteger value) {
-
+  public void encode(final BigInteger value) {
 
     if (value.compareTo(BigInteger.ZERO) < 0) {
       throw new IllegalArgumentException(""value must be positive or zero"");
     }
 
     byte[] bytes = value.toByteArray();
 
-    // BigInteger's toByteArray writes data in two's complement,
-    // so positive values may have a leading 0x00 byte.
-    if (bytes[0] == 0x00) {
+    // BigInteger's toByteArray writes data in two's complement, so positive values may have a
+    // leading 0x00 byte, which we want to strip off. However, we only want to strip these
+    // leading values off if the number of bytes is greater than 1 so that we don't produce an
+    // empty array when the BigInteger value is 0.
+    if (bytes[0] == 0x00 && bytes.length > 1) {",33,2018-07-30 15:02:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/204279991,https://github.com/hyperledger/quilt/pull/163#discussion_r204279991,sublimator
https://github.com/hyperledger/quilt/pull/163,https://github.com/hyperledger/quilt/pull/163,Why not use hex literals ? 0x4001L etc ?,4a42f79e6953c2d81d1db10aca184a8fab87981d,2018-07-23 04:34:41,204280064,"@@ -0,0 +1,111 @@
+package org.interledger.encoding.asn.codecs;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.core.Is.is;
+
+import com.google.common.io.BaseEncoding;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.math.BigInteger;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Objects;
+
+@RunWith(Parameterized.class)
+public class AsnUintCodecTest {
+
+  private final BigInteger expectedUint;
+  private final byte[] exptedEncodedBytes;
+
+  private AsnUintCodec codec;
+
+  /**
+   * Construct an instance of this parameterized test with the supplied inputs.
+   *
+   * @param expectedUint       The expected value, as a {@link BigInteger}, of {@code
+   *                           exptedEncodedBytes}, once encoded.
+   * @param exptedEncodedBytes The expected encoded value, in bytes, of {@code expectedUint}.
+   */
+  public AsnUintCodecTest(
+      final BigInteger expectedUint, final byte[] exptedEncodedBytes) {
+    this.expectedUint = Objects.requireNonNull(expectedUint);
+    this.exptedEncodedBytes = Objects.requireNonNull(exptedEncodedBytes);
+  }
+
+  /**
+   * The data for this test...
+   */
+  @Parameterized.Parameters
+  public static Collection<Object[]> data() {
+    return Arrays.asList(new Object[][] {
+        {
+            BigInteger.ZERO,
+            BaseEncoding.base16().decode(""00"")
+        },
+        {
+            BigInteger.valueOf(1L),
+            BaseEncoding.base16().decode(""01"")
+        },
+        {
+            BigInteger.TEN,
+            BaseEncoding.base16().decode(""0A"")
+        },
+        {
+            BigInteger.valueOf(15L),
+            BaseEncoding.base16().decode(""0F"")
+        },
+        {
+            BigInteger.valueOf(255L),
+            BaseEncoding.base16().decode(""FF"")
+        },
+        {
+            BigInteger.valueOf(1024L),
+            BaseEncoding.base16().decode(""0400"")
+        },
+        {
+            BigInteger.valueOf(16385L),",70,2018-07-30 15:02:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/204280064,https://github.com/hyperledger/quilt/pull/163#discussion_r204280064,sublimator
https://github.com/hyperledger/quilt/pull/163,https://github.com/hyperledger/quilt/pull/163,"> exptedEncodedBytes

typo",4a42f79e6953c2d81d1db10aca184a8fab87981d,2018-07-23 04:36:19,204280166,"@@ -0,0 +1,111 @@
+package org.interledger.encoding.asn.codecs;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.core.Is.is;
+
+import com.google.common.io.BaseEncoding;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.math.BigInteger;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Objects;
+
+@RunWith(Parameterized.class)
+public class AsnUintCodecTest {
+
+  private final BigInteger expectedUint;
+  private final byte[] exptedEncodedBytes;
+
+  private AsnUintCodec codec;
+
+  /**
+   * Construct an instance of this parameterized test with the supplied inputs.
+   *
+   * @param expectedUint       The expected value, as a {@link BigInteger}, of {@code
+   *                           exptedEncodedBytes}, once encoded.",,2018-07-30 15:02:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/204280166,https://github.com/hyperledger/quilt/pull/163#discussion_r204280166,sublimator
https://github.com/hyperledger/quilt/pull/163,https://github.com/hyperledger/quilt/pull/163,"Good question - I think the test is clearer if we use Base10 numbers here because the purpose of this test is to ensure that a `BigInteger` will encode into binary. Since `BigInteger` is always operated upon in Base10, I want to be sure that the B10 number properly encodes/decodes. So, the `expectedUint` value is always represented in Base10 on purpose, and we only use the HEX value to construct the byte-array.",4a42f79e6953c2d81d1db10aca184a8fab87981d,2018-07-28 20:44:24,205953498,"@@ -0,0 +1,111 @@
+package org.interledger.encoding.asn.codecs;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.core.Is.is;
+
+import com.google.common.io.BaseEncoding;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.math.BigInteger;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Objects;
+
+@RunWith(Parameterized.class)
+public class AsnUintCodecTest {
+
+  private final BigInteger expectedUint;
+  private final byte[] exptedEncodedBytes;
+
+  private AsnUintCodec codec;
+
+  /**
+   * Construct an instance of this parameterized test with the supplied inputs.
+   *
+   * @param expectedUint       The expected value, as a {@link BigInteger}, of {@code
+   *                           exptedEncodedBytes}, once encoded.
+   * @param exptedEncodedBytes The expected encoded value, in bytes, of {@code expectedUint}.
+   */
+  public AsnUintCodecTest(
+      final BigInteger expectedUint, final byte[] exptedEncodedBytes) {
+    this.expectedUint = Objects.requireNonNull(expectedUint);
+    this.exptedEncodedBytes = Objects.requireNonNull(exptedEncodedBytes);
+  }
+
+  /**
+   * The data for this test...
+   */
+  @Parameterized.Parameters
+  public static Collection<Object[]> data() {
+    return Arrays.asList(new Object[][] {
+        {
+            BigInteger.ZERO,
+            BaseEncoding.base16().decode(""00"")
+        },
+        {
+            BigInteger.valueOf(1L),
+            BaseEncoding.base16().decode(""01"")
+        },
+        {
+            BigInteger.TEN,
+            BaseEncoding.base16().decode(""0A"")
+        },
+        {
+            BigInteger.valueOf(15L),
+            BaseEncoding.base16().decode(""0F"")
+        },
+        {
+            BigInteger.valueOf(255L),
+            BaseEncoding.base16().decode(""FF"")
+        },
+        {
+            BigInteger.valueOf(1024L),
+            BaseEncoding.base16().decode(""0400"")
+        },
+        {
+            BigInteger.valueOf(16385L),",70,2018-07-30 15:02:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/205953498,https://github.com/hyperledger/quilt/pull/163#discussion_r205953498,sappenin
https://github.com/hyperledger/quilt/pull/163,https://github.com/hyperledger/quilt/pull/163,Fixed.,4a42f79e6953c2d81d1db10aca184a8fab87981d,2018-07-28 20:45:11,205953510,"@@ -0,0 +1,111 @@
+package org.interledger.encoding.asn.codecs;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.core.Is.is;
+
+import com.google.common.io.BaseEncoding;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.math.BigInteger;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Objects;
+
+@RunWith(Parameterized.class)
+public class AsnUintCodecTest {
+
+  private final BigInteger expectedUint;
+  private final byte[] exptedEncodedBytes;
+
+  private AsnUintCodec codec;
+
+  /**
+   * Construct an instance of this parameterized test with the supplied inputs.
+   *
+   * @param expectedUint       The expected value, as a {@link BigInteger}, of {@code
+   *                           exptedEncodedBytes}, once encoded.",,2018-07-30 15:02:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/205953510,https://github.com/hyperledger/quilt/pull/163#discussion_r205953510,sappenin
https://github.com/hyperledger/quilt/pull/163,https://github.com/hyperledger/quilt/pull/163,"Actually, looking more closely at this test, @adrianhopebailie, we seem to be treating this like a Uint64, but instead the `AsnUintCodec` should be using a length-prefix, no? (since the number of octets can be arbitrary)",4a42f79e6953c2d81d1db10aca184a8fab87981d,2018-07-28 20:57:27,205953736,"@@ -0,0 +1,111 @@
+package org.interledger.encoding.asn.codecs;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.core.Is.is;
+
+import com.google.common.io.BaseEncoding;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.math.BigInteger;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Objects;
+
+@RunWith(Parameterized.class)
+public class AsnUintCodecTest {
+
+  private final BigInteger expectedUint;
+  private final byte[] exptedEncodedBytes;
+
+  private AsnUintCodec codec;
+
+  /**
+   * Construct an instance of this parameterized test with the supplied inputs.
+   *
+   * @param expectedUint       The expected value, as a {@link BigInteger}, of {@code
+   *                           exptedEncodedBytes}, once encoded.
+   * @param exptedEncodedBytes The expected encoded value, in bytes, of {@code expectedUint}.
+   */
+  public AsnUintCodecTest(
+      final BigInteger expectedUint, final byte[] exptedEncodedBytes) {
+    this.expectedUint = Objects.requireNonNull(expectedUint);
+    this.exptedEncodedBytes = Objects.requireNonNull(exptedEncodedBytes);
+  }
+
+  /**
+   * The data for this test...
+   */
+  @Parameterized.Parameters
+  public static Collection<Object[]> data() {
+    return Arrays.asList(new Object[][] {
+        {
+            BigInteger.ZERO,
+            BaseEncoding.base16().decode(""00"")
+        },
+        {
+            BigInteger.valueOf(1L),
+            BaseEncoding.base16().decode(""01"")
+        },
+        {
+            BigInteger.TEN,
+            BaseEncoding.base16().decode(""0A"")
+        },
+        {
+            BigInteger.valueOf(15L),
+            BaseEncoding.base16().decode(""0F"")
+        },
+        {
+            BigInteger.valueOf(255L),
+            BaseEncoding.base16().decode(""FF"")
+        },
+        {
+            BigInteger.valueOf(1024L),
+            BaseEncoding.base16().decode(""0400"")
+        },
+        {
+            BigInteger.valueOf(16385L),",70,2018-07-30 15:02:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/205953736,https://github.com/hyperledger/quilt/pull/163#discussion_r205953736,sappenin
https://github.com/hyperledger/quilt/pull/163,https://github.com/hyperledger/quilt/pull/163,I think the serializer classes handle that right ? (checking ... ),4a42f79e6953c2d81d1db10aca184a8fab87981d,2018-07-30 04:33:21,206012951,"@@ -0,0 +1,111 @@
+package org.interledger.encoding.asn.codecs;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.core.Is.is;
+
+import com.google.common.io.BaseEncoding;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.math.BigInteger;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Objects;
+
+@RunWith(Parameterized.class)
+public class AsnUintCodecTest {
+
+  private final BigInteger expectedUint;
+  private final byte[] exptedEncodedBytes;
+
+  private AsnUintCodec codec;
+
+  /**
+   * Construct an instance of this parameterized test with the supplied inputs.
+   *
+   * @param expectedUint       The expected value, as a {@link BigInteger}, of {@code
+   *                           exptedEncodedBytes}, once encoded.
+   * @param exptedEncodedBytes The expected encoded value, in bytes, of {@code expectedUint}.
+   */
+  public AsnUintCodecTest(
+      final BigInteger expectedUint, final byte[] exptedEncodedBytes) {
+    this.expectedUint = Objects.requireNonNull(expectedUint);
+    this.exptedEncodedBytes = Objects.requireNonNull(exptedEncodedBytes);
+  }
+
+  /**
+   * The data for this test...
+   */
+  @Parameterized.Parameters
+  public static Collection<Object[]> data() {
+    return Arrays.asList(new Object[][] {
+        {
+            BigInteger.ZERO,
+            BaseEncoding.base16().decode(""00"")
+        },
+        {
+            BigInteger.valueOf(1L),
+            BaseEncoding.base16().decode(""01"")
+        },
+        {
+            BigInteger.TEN,
+            BaseEncoding.base16().decode(""0A"")
+        },
+        {
+            BigInteger.valueOf(15L),
+            BaseEncoding.base16().decode(""0F"")
+        },
+        {
+            BigInteger.valueOf(255L),
+            BaseEncoding.base16().decode(""FF"")
+        },
+        {
+            BigInteger.valueOf(1024L),
+            BaseEncoding.base16().decode(""0400"")
+        },
+        {
+            BigInteger.valueOf(16385L),",70,2018-07-30 15:02:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/206012951,https://github.com/hyperledger/quilt/pull/163#discussion_r206012951,sublimator
https://github.com/hyperledger/quilt/pull/163,https://github.com/hyperledger/quilt/pull/163,"Hrmmm, this codec doesn't actually seem to be registered at all for the OER rules? ",4a42f79e6953c2d81d1db10aca184a8fab87981d,2018-07-30 04:36:42,206013206,"@@ -0,0 +1,111 @@
+package org.interledger.encoding.asn.codecs;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.core.Is.is;
+
+import com.google.common.io.BaseEncoding;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.math.BigInteger;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Objects;
+
+@RunWith(Parameterized.class)
+public class AsnUintCodecTest {
+
+  private final BigInteger expectedUint;
+  private final byte[] exptedEncodedBytes;
+
+  private AsnUintCodec codec;
+
+  /**
+   * Construct an instance of this parameterized test with the supplied inputs.
+   *
+   * @param expectedUint       The expected value, as a {@link BigInteger}, of {@code
+   *                           exptedEncodedBytes}, once encoded.
+   * @param exptedEncodedBytes The expected encoded value, in bytes, of {@code expectedUint}.
+   */
+  public AsnUintCodecTest(
+      final BigInteger expectedUint, final byte[] exptedEncodedBytes) {
+    this.expectedUint = Objects.requireNonNull(expectedUint);
+    this.exptedEncodedBytes = Objects.requireNonNull(exptedEncodedBytes);
+  }
+
+  /**
+   * The data for this test...
+   */
+  @Parameterized.Parameters
+  public static Collection<Object[]> data() {
+    return Arrays.asList(new Object[][] {
+        {
+            BigInteger.ZERO,
+            BaseEncoding.base16().decode(""00"")
+        },
+        {
+            BigInteger.valueOf(1L),
+            BaseEncoding.base16().decode(""01"")
+        },
+        {
+            BigInteger.TEN,
+            BaseEncoding.base16().decode(""0A"")
+        },
+        {
+            BigInteger.valueOf(15L),
+            BaseEncoding.base16().decode(""0F"")
+        },
+        {
+            BigInteger.valueOf(255L),
+            BaseEncoding.base16().decode(""FF"")
+        },
+        {
+            BigInteger.valueOf(1024L),
+            BaseEncoding.base16().decode(""0400"")
+        },
+        {
+            BigInteger.valueOf(16385L),",70,2018-07-30 15:02:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/206013206,https://github.com/hyperledger/quilt/pull/163#discussion_r206013206,sublimator
https://github.com/hyperledger/quilt/pull/163,https://github.com/hyperledger/quilt/pull/163,"re: hex literals, I just thought they'd more easily eyeball match the hex encoding ",4a42f79e6953c2d81d1db10aca184a8fab87981d,2018-07-30 04:38:07,206013327,"@@ -0,0 +1,111 @@
+package org.interledger.encoding.asn.codecs;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.core.Is.is;
+
+import com.google.common.io.BaseEncoding;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.math.BigInteger;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Objects;
+
+@RunWith(Parameterized.class)
+public class AsnUintCodecTest {
+
+  private final BigInteger expectedUint;
+  private final byte[] exptedEncodedBytes;
+
+  private AsnUintCodec codec;
+
+  /**
+   * Construct an instance of this parameterized test with the supplied inputs.
+   *
+   * @param expectedUint       The expected value, as a {@link BigInteger}, of {@code
+   *                           exptedEncodedBytes}, once encoded.
+   * @param exptedEncodedBytes The expected encoded value, in bytes, of {@code expectedUint}.
+   */
+  public AsnUintCodecTest(
+      final BigInteger expectedUint, final byte[] exptedEncodedBytes) {
+    this.expectedUint = Objects.requireNonNull(expectedUint);
+    this.exptedEncodedBytes = Objects.requireNonNull(exptedEncodedBytes);
+  }
+
+  /**
+   * The data for this test...
+   */
+  @Parameterized.Parameters
+  public static Collection<Object[]> data() {
+    return Arrays.asList(new Object[][] {
+        {
+            BigInteger.ZERO,
+            BaseEncoding.base16().decode(""00"")
+        },
+        {
+            BigInteger.valueOf(1L),
+            BaseEncoding.base16().decode(""01"")
+        },
+        {
+            BigInteger.TEN,
+            BaseEncoding.base16().decode(""0A"")
+        },
+        {
+            BigInteger.valueOf(15L),
+            BaseEncoding.base16().decode(""0F"")
+        },
+        {
+            BigInteger.valueOf(255L),
+            BaseEncoding.base16().decode(""FF"")
+        },
+        {
+            BigInteger.valueOf(1024L),
+            BaseEncoding.base16().decode(""0400"")
+        },
+        {
+            BigInteger.valueOf(16385L),",70,2018-07-30 15:02:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/206013327,https://github.com/hyperledger/quilt/pull/163#discussion_r206013327,sublimator
https://github.com/hyperledger/quilt/pull/163,https://github.com/hyperledger/quilt/pull/163,"@sappenin 

Yeah, it seems I recalled correctly, and that the serializers handle all the length prefix encoding. 

See:
https://github.com/hyperledger/quilt/blob/b53a0511007c005c1f5455ec7f59639fb935e5b6/codec-framework/src/main/java/org/interledger/encoding/asn/framework/CodecContextFactory.java#L65
https://github.com/hyperledger/quilt/blob/b53a0511007c005c1f5455ec7f59639fb935e5b6/codec-framework/src/main/java/org/interledger/encoding/asn/serializers/oer/AsnOctetStringOerSerializer.java#L88",4a42f79e6953c2d81d1db10aca184a8fab87981d,2018-07-30 04:41:52,206013639,"@@ -0,0 +1,111 @@
+package org.interledger.encoding.asn.codecs;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.core.Is.is;
+
+import com.google.common.io.BaseEncoding;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.math.BigInteger;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Objects;
+
+@RunWith(Parameterized.class)
+public class AsnUintCodecTest {
+
+  private final BigInteger expectedUint;
+  private final byte[] exptedEncodedBytes;
+
+  private AsnUintCodec codec;
+
+  /**
+   * Construct an instance of this parameterized test with the supplied inputs.
+   *
+   * @param expectedUint       The expected value, as a {@link BigInteger}, of {@code
+   *                           exptedEncodedBytes}, once encoded.
+   * @param exptedEncodedBytes The expected encoded value, in bytes, of {@code expectedUint}.
+   */
+  public AsnUintCodecTest(
+      final BigInteger expectedUint, final byte[] exptedEncodedBytes) {
+    this.expectedUint = Objects.requireNonNull(expectedUint);
+    this.exptedEncodedBytes = Objects.requireNonNull(exptedEncodedBytes);
+  }
+
+  /**
+   * The data for this test...
+   */
+  @Parameterized.Parameters
+  public static Collection<Object[]> data() {
+    return Arrays.asList(new Object[][] {
+        {
+            BigInteger.ZERO,
+            BaseEncoding.base16().decode(""00"")
+        },
+        {
+            BigInteger.valueOf(1L),
+            BaseEncoding.base16().decode(""01"")
+        },
+        {
+            BigInteger.TEN,
+            BaseEncoding.base16().decode(""0A"")
+        },
+        {
+            BigInteger.valueOf(15L),
+            BaseEncoding.base16().decode(""0F"")
+        },
+        {
+            BigInteger.valueOf(255L),
+            BaseEncoding.base16().decode(""FF"")
+        },
+        {
+            BigInteger.valueOf(1024L),
+            BaseEncoding.base16().decode(""0400"")
+        },
+        {
+            BigInteger.valueOf(16385L),",70,2018-07-30 15:02:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/206013639,https://github.com/hyperledger/quilt/pull/163#discussion_r206013639,sublimator
https://github.com/hyperledger/quilt/pull/163,https://github.com/hyperledger/quilt/pull/163,"Oh dang, you're totally right. I've been spending so much time in the Codecs I forgot about the Serializers.

Kk - I think this PR is good to go. ",4a42f79e6953c2d81d1db10aca184a8fab87981d,2018-07-30 15:03:25,206179890,"@@ -0,0 +1,111 @@
+package org.interledger.encoding.asn.codecs;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.core.Is.is;
+
+import com.google.common.io.BaseEncoding;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.math.BigInteger;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Objects;
+
+@RunWith(Parameterized.class)
+public class AsnUintCodecTest {
+
+  private final BigInteger expectedUint;
+  private final byte[] exptedEncodedBytes;
+
+  private AsnUintCodec codec;
+
+  /**
+   * Construct an instance of this parameterized test with the supplied inputs.
+   *
+   * @param expectedUint       The expected value, as a {@link BigInteger}, of {@code
+   *                           exptedEncodedBytes}, once encoded.
+   * @param exptedEncodedBytes The expected encoded value, in bytes, of {@code expectedUint}.
+   */
+  public AsnUintCodecTest(
+      final BigInteger expectedUint, final byte[] exptedEncodedBytes) {
+    this.expectedUint = Objects.requireNonNull(expectedUint);
+    this.exptedEncodedBytes = Objects.requireNonNull(exptedEncodedBytes);
+  }
+
+  /**
+   * The data for this test...
+   */
+  @Parameterized.Parameters
+  public static Collection<Object[]> data() {
+    return Arrays.asList(new Object[][] {
+        {
+            BigInteger.ZERO,
+            BaseEncoding.base16().decode(""00"")
+        },
+        {
+            BigInteger.valueOf(1L),
+            BaseEncoding.base16().decode(""01"")
+        },
+        {
+            BigInteger.TEN,
+            BaseEncoding.base16().decode(""0A"")
+        },
+        {
+            BigInteger.valueOf(15L),
+            BaseEncoding.base16().decode(""0F"")
+        },
+        {
+            BigInteger.valueOf(255L),
+            BaseEncoding.base16().decode(""FF"")
+        },
+        {
+            BigInteger.valueOf(1024L),
+            BaseEncoding.base16().decode(""0400"")
+        },
+        {
+            BigInteger.valueOf(16385L),",70,2018-07-30 15:03:25,https://api.github.com/repos/hyperledger/quilt/pulls/comments/206179890,https://github.com/hyperledger/quilt/pull/163#discussion_r206179890,sappenin
https://github.com/hyperledger/quilt/pull/161,https://github.com/hyperledger/quilt/pull/161,This is required to deploy the DevOps artifacts to Sonatype Nexus.,7f65dee25986001e27628dedab4270403758d033,2018-07-18 15:43:09,203430104,"@@ -112,4 +112,11 @@
     </plugins>
   </build>
 
+  <distributionManagement>",4,2018-07-28 15:33:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/203430104,https://github.com/hyperledger/quilt/pull/161#discussion_r203430104,sappenin
https://github.com/hyperledger/quilt/pull/161,https://github.com/hyperledger/quilt/pull/161,https://github.com/hyperledger/quilt/blob/master/pom.xml#L9,7f65dee25986001e27628dedab4270403758d033,2018-07-21 08:25:52,204205822,"@@ -95,7 +95,7 @@ Next, import this library as a dependency, like this:
 ```
 dependencies {
     ...
-    compile group: 'org.interledger', name: 'java-ilp-core', version: '0.7.0-SNAPSHOT'
+    compile group: 'org.interledger', name: 'java-ilp-core', version: '0.12.0-SNAPSHOT'",5,2018-07-28 15:33:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/204205822,https://github.com/hyperledger/quilt/pull/161#discussion_r204205822,sublimator
https://github.com/hyperledger/quilt/pull/161,https://github.com/hyperledger/quilt/pull/161,@sublimator Can you clarify what you mean?,7f65dee25986001e27628dedab4270403758d033,2018-07-21 20:56:48,204221621,"@@ -95,7 +95,7 @@ Next, import this library as a dependency, like this:
 ```
 dependencies {
     ...
-    compile group: 'org.interledger', name: 'java-ilp-core', version: '0.7.0-SNAPSHOT'
+    compile group: 'org.interledger', name: 'java-ilp-core', version: '0.12.0-SNAPSHOT'",5,2018-07-28 15:33:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/204221621,https://github.com/hyperledger/quilt/pull/161#discussion_r204221621,sappenin
https://github.com/hyperledger/quilt/pull/161,https://github.com/hyperledger/quilt/pull/161,That this seems correct :),7f65dee25986001e27628dedab4270403758d033,2018-07-23 04:38:53,204280425,"@@ -95,7 +95,7 @@ Next, import this library as a dependency, like this:
 ```
 dependencies {
     ...
-    compile group: 'org.interledger', name: 'java-ilp-core', version: '0.7.0-SNAPSHOT'
+    compile group: 'org.interledger', name: 'java-ilp-core', version: '0.12.0-SNAPSHOT'",5,2018-07-28 15:33:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/204280425,https://github.com/hyperledger/quilt/pull/161#discussion_r204280425,sublimator
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,hash vs hashBytes,2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-15 05:11:35,202531592,"@@ -24,68 +24,74 @@
 import java.util.Objects;
 
 /**
- * Represents an Interledger Condition (as present in an ILP Prepare packet).
+ * <p>Represents an Interledger Condition (as present in an ILP Prepare packet).</p>
  *
- * <p>This is a wrapper around a 32 byte SHA-256 hash digest providing an immutable implementation.
+ * <p>This is a wrapper around a 32 byte SHA-256 hash digest providing an immutable
+ * implementation.</p>
  *
  * @see InterledgerFulfillment
  */
 public interface InterledgerCondition extends Comparable<InterledgerCondition> {
 
   /**
-   * Create a new immutable InterledgerCondition from the provided 32-bytes.
+   * <p>Create a new immutable {@link InterledgerCondition} from the provided 32-hash.</p>
+   *
+   * <p>This method is typically only used during deserialization. To generate a condition based
+   * on an fulfillment use {@link InterledgerFulfillment#getCondition()}.</p>
    *
-   * <p>This method is predominantly used during deserialization. To generate a condition based on an fulfillment
-   * use {@link InterledgerFulfillment#getCondition()}.
+   * @param hashBytes A 32-byte SHA-256 hash digest.
    *
-   * @param bytes 32-byte SHA-256 hash digest
-   * @return the condition containing these bytes
+   * @return The {@link InterledgerCondition} containing the supplied hash.
    */
-  static InterledgerCondition from(byte[] bytes) {
-    Objects.requireNonNull(bytes, ""bytes cannot be null"");
-    return new ImmutableInterledgerCondition(bytes);
+  static InterledgerCondition from(final byte[] hashBytes) {
+    Objects.requireNonNull(hashBytes, ""hash cannot be null"");",,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/202531592,https://github.com/hyperledger/quilt/pull/160#discussion_r202531592,sublimator
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,`32-hash`,2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-15 05:13:09,202531607,"@@ -26,99 +26,103 @@
 import java.util.Objects;
 
 /**
- * Represents an Interledger Fulfillment (as present in an ILP Fulfill packet).
+ * <p>Represents an Interledger Fulfillment that can be used in an {@link
+ * InterledgerFulfillPacket}.</p>
  *
- * <p>This is a wrapper around the 32 byte pre-image from a SHA-256 hash digest.
+ * <p>This is a wrapper around the 32 byte pre-image of a SHA-256 hash digest.</p>
  *
  * @see InterledgerCondition
  */
 public interface InterledgerFulfillment extends Comparable<InterledgerFulfillment> {
 
   /**
-   * Create a new immutable InterledgerFulfillment from the provided 32-bytes.
+   * Create a new immutable InterledgerFulfillment from the provided 32-hash.",,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/202531607,https://github.com/hyperledger/quilt/pull/160#discussion_r202531607,sublimator
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,`hash` vs `preImage ` ?,2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-15 05:14:46,202531633,"@@ -26,99 +26,103 @@
 import java.util.Objects;
 
 /**
- * Represents an Interledger Fulfillment (as present in an ILP Fulfill packet).
+ * <p>Represents an Interledger Fulfillment that can be used in an {@link
+ * InterledgerFulfillPacket}.</p>
  *
- * <p>This is a wrapper around the 32 byte pre-image from a SHA-256 hash digest.
+ * <p>This is a wrapper around the 32 byte pre-image of a SHA-256 hash digest.</p>
  *
  * @see InterledgerCondition
  */
 public interface InterledgerFulfillment extends Comparable<InterledgerFulfillment> {
 
   /**
-   * Create a new immutable InterledgerFulfillment from the provided 32-bytes.
+   * Create a new immutable InterledgerFulfillment from the provided 32-hash.
    *
    * @param bytes 32-byte preimage
-   * @return the fulfillment containing these bytes
+   *
+   * @return the fulfillment containing these byteAsnConditionCodecs
    */
   static InterledgerFulfillment from(byte[] bytes) {
-    Objects.requireNonNull(bytes, ""bytes cannot be null"");
+    Objects.requireNonNull(bytes, ""hash cannot be null"");
     return new ImmutableInterledgerFulfillment(bytes);
   }
 
   /**
-   * Get the internal bytes from the fulfillment.
+   * <p>Get the internal hash from the fulfillment.</p>",,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/202531633,https://github.com/hyperledger/quilt/pull/160#discussion_r202531633,sublimator
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,"`Fulfillment.of -> InterledgerFulfillment.from`
`Condition.of -> InterledgerCondition.from`

`InterledgerAddress.of -> InterledgerAddress.of` 

?",2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-16 06:35:08,202582444,"@@ -74,20 +74,20 @@
         {InterledgerPreparePacket.builder()
             .destination(InterledgerAddress.of(""test3.foo.bar""))",24,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/202582444,https://github.com/hyperledger/quilt/pull/160#discussion_r202582444,sublimator
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,"It's a pre-image, not a hash right?",2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-16 06:36:06,202582547,"@@ -26,99 +26,103 @@
 import java.util.Objects;
 
 /**
- * Represents an Interledger Fulfillment (as present in an ILP Fulfill packet).
+ * <p>Represents an Interledger Fulfillment that can be used in an {@link
+ * InterledgerFulfillPacket}.</p>
  *
- * <p>This is a wrapper around the 32 byte pre-image from a SHA-256 hash digest.
+ * <p>This is a wrapper around the 32 byte pre-image of a SHA-256 hash digest.</p>
  *
  * @see InterledgerCondition
  */
 public interface InterledgerFulfillment extends Comparable<InterledgerFulfillment> {
 
   /**
-   * Create a new immutable InterledgerFulfillment from the provided 32-bytes.
+   * Create a new immutable InterledgerFulfillment from the provided 32-hash.",,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/202582547,https://github.com/hyperledger/quilt/pull/160#discussion_r202582547,sublimator
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,Yep. Looks like a find-replace mistake.,2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-16 14:38:23,202706961,"@@ -26,99 +26,103 @@
 import java.util.Objects;
 
 /**
- * Represents an Interledger Fulfillment (as present in an ILP Fulfill packet).
+ * <p>Represents an Interledger Fulfillment that can be used in an {@link
+ * InterledgerFulfillPacket}.</p>
  *
- * <p>This is a wrapper around the 32 byte pre-image from a SHA-256 hash digest.
+ * <p>This is a wrapper around the 32 byte pre-image of a SHA-256 hash digest.</p>
  *
  * @see InterledgerCondition
  */
 public interface InterledgerFulfillment extends Comparable<InterledgerFulfillment> {
 
   /**
-   * Create a new immutable InterledgerFulfillment from the provided 32-bytes.
+   * Create a new immutable InterledgerFulfillment from the provided 32-hash.",,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/202706961,https://github.com/hyperledger/quilt/pull/160#discussion_r202706961,adrianhopebailie
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,At first glance I think these do different things. `.of` is a constructor from simple input and `.from` is a clone.,2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-16 14:56:22,202714046,"@@ -74,20 +74,20 @@
         {InterledgerPreparePacket.builder()
             .destination(InterledgerAddress.of(""test3.foo.bar""))",24,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/202714046,https://github.com/hyperledger/quilt/pull/160#discussion_r202714046,adrianhopebailie
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,"@adrianhopebailie 
Hrmmm, seems using from for `simple inputs` too: 
e.g.
InterledgerCondition.from(conditionBytes)",2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-18 07:42:34,203279359,"@@ -74,20 +74,20 @@
         {InterledgerPreparePacket.builder()
             .destination(InterledgerAddress.of(""test3.foo.bar""))",24,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/203279359,https://github.com/hyperledger/quilt/pull/160#discussion_r203279359,sublimator
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,"We did try to have a convention but it's possible things have gotten mixed up with time.

@sappenin WDYT?",2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-18 08:40:41,203295933,"@@ -74,20 +74,20 @@
         {InterledgerPreparePacket.builder()
             .destination(InterledgerAddress.of(""test3.foo.bar""))",24,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/203295933,https://github.com/hyperledger/quilt/pull/160#discussion_r203295933,adrianhopebailie
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,Nic catch! Fixed by 17bf18ea2f212a06aa3b73a9db69ddd1ced7b051,2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-18 14:51:32,203409880,"@@ -24,68 +24,74 @@
 import java.util.Objects;
 
 /**
- * Represents an Interledger Condition (as present in an ILP Prepare packet).
+ * <p>Represents an Interledger Condition (as present in an ILP Prepare packet).</p>
  *
- * <p>This is a wrapper around a 32 byte SHA-256 hash digest providing an immutable implementation.
+ * <p>This is a wrapper around a 32 byte SHA-256 hash digest providing an immutable
+ * implementation.</p>
  *
  * @see InterledgerFulfillment
  */
 public interface InterledgerCondition extends Comparable<InterledgerCondition> {
 
   /**
-   * Create a new immutable InterledgerCondition from the provided 32-bytes.
+   * <p>Create a new immutable {@link InterledgerCondition} from the provided 32-hash.</p>
+   *
+   * <p>This method is typically only used during deserialization. To generate a condition based
+   * on an fulfillment use {@link InterledgerFulfillment#getCondition()}.</p>
    *
-   * <p>This method is predominantly used during deserialization. To generate a condition based on an fulfillment
-   * use {@link InterledgerFulfillment#getCondition()}.
+   * @param hashBytes A 32-byte SHA-256 hash digest.
    *
-   * @param bytes 32-byte SHA-256 hash digest
-   * @return the condition containing these bytes
+   * @return The {@link InterledgerCondition} containing the supplied hash.
    */
-  static InterledgerCondition from(byte[] bytes) {
-    Objects.requireNonNull(bytes, ""bytes cannot be null"");
-    return new ImmutableInterledgerCondition(bytes);
+  static InterledgerCondition from(final byte[] hashBytes) {
+    Objects.requireNonNull(hashBytes, ""hash cannot be null"");",,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/203409880,https://github.com/hyperledger/quilt/pull/160#discussion_r203409880,sappenin
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,"Yeah, there are some typos in the code. Should be `.of` for construction with inputs, and `.from` for copy-constructor-like behavior. I'll fix the code.",2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-18 14:54:42,203411233,"@@ -74,20 +74,20 @@
         {InterledgerPreparePacket.builder()
             .destination(InterledgerAddress.of(""test3.foo.bar""))",24,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/203411233,https://github.com/hyperledger/quilt/pull/160#discussion_r203411233,sappenin
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,Fixed by c387f11431c2f1904d8b5bf3729568e3f95959b6,2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-18 15:18:05,203420738,"@@ -26,99 +26,103 @@
 import java.util.Objects;
 
 /**
- * Represents an Interledger Fulfillment (as present in an ILP Fulfill packet).
+ * <p>Represents an Interledger Fulfillment that can be used in an {@link
+ * InterledgerFulfillPacket}.</p>
  *
- * <p>This is a wrapper around the 32 byte pre-image from a SHA-256 hash digest.
+ * <p>This is a wrapper around the 32 byte pre-image of a SHA-256 hash digest.</p>
  *
  * @see InterledgerCondition
  */
 public interface InterledgerFulfillment extends Comparable<InterledgerFulfillment> {
 
   /**
-   * Create a new immutable InterledgerFulfillment from the provided 32-bytes.
+   * Create a new immutable InterledgerFulfillment from the provided 32-hash.",,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/203420738,https://github.com/hyperledger/quilt/pull/160#discussion_r203420738,sappenin
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,Fixed by c387f11,2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-18 15:19:01,203421154,"@@ -26,99 +26,103 @@
 import java.util.Objects;
 
 /**
- * Represents an Interledger Fulfillment (as present in an ILP Fulfill packet).
+ * <p>Represents an Interledger Fulfillment that can be used in an {@link
+ * InterledgerFulfillPacket}.</p>
  *
- * <p>This is a wrapper around the 32 byte pre-image from a SHA-256 hash digest.
+ * <p>This is a wrapper around the 32 byte pre-image of a SHA-256 hash digest.</p>
  *
  * @see InterledgerCondition
  */
 public interface InterledgerFulfillment extends Comparable<InterledgerFulfillment> {
 
   /**
-   * Create a new immutable InterledgerFulfillment from the provided 32-bytes.
+   * Create a new immutable InterledgerFulfillment from the provided 32-hash.
    *
    * @param bytes 32-byte preimage
-   * @return the fulfillment containing these bytes
+   *
+   * @return the fulfillment containing these byteAsnConditionCodecs
    */
   static InterledgerFulfillment from(byte[] bytes) {
-    Objects.requireNonNull(bytes, ""bytes cannot be null"");
+    Objects.requireNonNull(bytes, ""hash cannot be null"");
     return new ImmutableInterledgerFulfillment(bytes);
   }
 
   /**
-   * Get the internal bytes from the fulfillment.
+   * <p>Get the internal hash from the fulfillment.</p>",,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/203421154,https://github.com/hyperledger/quilt/pull/160#discussion_r203421154,sappenin
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,Fixed in 8f8b44d9e9bfc2df359a668d75548dbb03b6a0e2 and 552a691651a658126c85f1bc0d14487c04b5a0a2,2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-18 15:19:22,203421281,"@@ -74,20 +74,20 @@
         {InterledgerPreparePacket.builder()
             .destination(InterledgerAddress.of(""test3.foo.bar""))",24,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/203421281,https://github.com/hyperledger/quilt/pull/160#discussion_r203421281,sappenin
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,This should fix #156 ,2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-18 15:23:38,203422868,"@@ -8,7 +8,6 @@
     <version>0.12.0-SNAPSHOT</version>
   </parent>
   <modelVersion>4.0.0</modelVersion>
-  <packaging>pom</packaging>",4,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/203422868,https://github.com/hyperledger/quilt/pull/160#discussion_r203422868,sappenin
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,> must be exactly 32 preimageBytes.,2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-19 02:51:12,203588530,"@@ -26,99 +26,103 @@
 import java.util.Objects;
 
 /**
- * Represents an Interledger Fulfillment (as present in an ILP Fulfill packet).
+ * <p>Represents an Interledger Fulfillment that can be used in an {@link
+ * InterledgerFulfillPacket}.</p>
  *
- * <p>This is a wrapper around the 32 byte pre-image from a SHA-256 hash digest.
+ * <p>This is a wrapper around the 32 byte pre-image of a SHA-256 hash digest.</p>
  *
  * @see InterledgerCondition
  */
 public interface InterledgerFulfillment extends Comparable<InterledgerFulfillment> {
 
   /**
-   * Create a new immutable InterledgerFulfillment from the provided 32-bytes.
+   * Create a new immutable InterledgerFulfillment using the provided 32-byte pre-image.
    *
-   * @param bytes 32-byte preimage
-   * @return the fulfillment containing these bytes
+   * @param preimage 32-byte pre-image
+   *
+   * @return the fulfillment containing the supplied pre-image.
    */
-  static InterledgerFulfillment from(byte[] bytes) {
-    Objects.requireNonNull(bytes, ""bytes cannot be null"");
-    return new ImmutableInterledgerFulfillment(bytes);
+  static InterledgerFulfillment of(byte[] preimage) {
+    Objects.requireNonNull(preimage, ""preimage cannot be null"");
+    return new ImmutableInterledgerFulfillment(preimage);
   }
 
   /**
-   * Get the internal bytes from the fulfillment.
+   * <p>Get the internal pre-image from the fulfillment.</p>
    *
-   * <p>Implementations should return a safe copy from the data to preserve the immutability from the fulfillment.
+   * <p>Implementations should return a safe copy from the data to preserve the immutability from
+   * the fulfillment.</p>
    *
    * @return the 32 byte preimage
    */
-  byte[] getBytes();
+  byte[] getPreimage();
 
   /**
-   * Get the condition that is valid for this fulfillment.
+   * <p>Get the condition that is valid for this fulfillment.</p>
    *
-   * <p>Implementations MUST ensure that <code>f.validateCondition(f.getCondition())</code> always returns
-   * <code>true</code>.
+   * <p>Implementations MUST ensure that <code>f.validateCondition(f.getCondition())</code> always
+   * returns <code>true</code>.</p>
    *
    * @return the condition for this fulfillment.
    */
   InterledgerCondition getCondition();
 
   /**
-   * Check that the provided condition is valid for this fulfillment.
+   * <p>Check that the provided condition is valid for this fulfillment.</p>
    *
-   * <p>A valid condition is the 32 byte SHA-256 hash digest from the 32 byte opreimage represented by this fulfillment.
+   * <p>A valid condition is the 32-byte SHA-256 hash digest of the 32-byte pre-image represented
+   * by this fulfillment.</p>
    *
    * @param condition an InterledgerCondition
+   *
    * @return tru if this condition is valid for this fulfillment.
    */
   boolean validateCondition(InterledgerCondition condition);
 
   /**
-   * An immutable implementation from InterledgerFulfillment optimized for efficient operations that only create copies
-   * from the internal data as required and only performs late generation from the hash when required.
+   * An immutable implementation of InterledgerFulfillment optimized for efficient operations that
+   * only create copies of the internal data as required and only performs late generation of the
+   * hash when required.
    */
   class ImmutableInterledgerFulfillment implements InterledgerFulfillment {
 
-    private final byte[] bytes = new byte[32];
+    private final byte[] preimageBytes = new byte[32];
+    private final InterledgerCondition condition;
 
-    private InterledgerCondition condition;
-    private byte[] conditionBytes;
-
-    protected ImmutableInterledgerFulfillment(byte[] bytes) {
-      if (bytes.length != 32) {
-        throw new IllegalArgumentException(""InterledgerFulfillment must be exactly 32 bytes."");
+    protected ImmutableInterledgerFulfillment(byte[] preimageBytes) {
+      if (preimageBytes.length != 32) {
+        throw new IllegalArgumentException(
+            ""Interledger preimages must be exactly 32 preimageBytes."");",,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/203588530,https://github.com/hyperledger/quilt/pull/160#discussion_r203588530,sublimator
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160," //Only call getHash()

 //Only call getPreimage()",2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-19 02:52:03,203588633,"@@ -152,18 +156,18 @@ public int compareTo(InterledgerFulfillment other) {
         return 0;
       }
 
-      //Only call getBytes() if we have to (avoid array copy)
+      //Only call getHash() if we have to (avoid array copy)",,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/203588633,https://github.com/hyperledger/quilt/pull/160#discussion_r203588633,sublimator
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,testGetHash ?,2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-19 02:52:37,203588703,"@@ -62,39 +63,55 @@
 
   @Test
   public void testGetBytes() {
-    assertArrayEquals(InterledgerCondition.from(BYTES_1).getBytes(), BYTES_1);
+    assertArrayEquals(InterledgerCondition.of(BYTES_1).getHash(), BYTES_1);",,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/203588703,https://github.com/hyperledger/quilt/pull/160#discussion_r203588703,sublimator
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,This is fixed.,2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-21 20:59:00,204221659,"@@ -26,99 +26,103 @@
 import java.util.Objects;
 
 /**
- * Represents an Interledger Fulfillment (as present in an ILP Fulfill packet).
+ * <p>Represents an Interledger Fulfillment that can be used in an {@link
+ * InterledgerFulfillPacket}.</p>
  *
- * <p>This is a wrapper around the 32 byte pre-image from a SHA-256 hash digest.
+ * <p>This is a wrapper around the 32 byte pre-image of a SHA-256 hash digest.</p>
  *
  * @see InterledgerCondition
  */
 public interface InterledgerFulfillment extends Comparable<InterledgerFulfillment> {
 
   /**
-   * Create a new immutable InterledgerFulfillment from the provided 32-bytes.
+   * Create a new immutable InterledgerFulfillment using the provided 32-byte pre-image.
    *
-   * @param bytes 32-byte preimage
-   * @return the fulfillment containing these bytes
+   * @param preimage 32-byte pre-image
+   *
+   * @return the fulfillment containing the supplied pre-image.
    */
-  static InterledgerFulfillment from(byte[] bytes) {
-    Objects.requireNonNull(bytes, ""bytes cannot be null"");
-    return new ImmutableInterledgerFulfillment(bytes);
+  static InterledgerFulfillment of(byte[] preimage) {
+    Objects.requireNonNull(preimage, ""preimage cannot be null"");
+    return new ImmutableInterledgerFulfillment(preimage);
   }
 
   /**
-   * Get the internal bytes from the fulfillment.
+   * <p>Get the internal pre-image from the fulfillment.</p>
    *
-   * <p>Implementations should return a safe copy from the data to preserve the immutability from the fulfillment.
+   * <p>Implementations should return a safe copy from the data to preserve the immutability from
+   * the fulfillment.</p>
    *
    * @return the 32 byte preimage
    */
-  byte[] getBytes();
+  byte[] getPreimage();
 
   /**
-   * Get the condition that is valid for this fulfillment.
+   * <p>Get the condition that is valid for this fulfillment.</p>
    *
-   * <p>Implementations MUST ensure that <code>f.validateCondition(f.getCondition())</code> always returns
-   * <code>true</code>.
+   * <p>Implementations MUST ensure that <code>f.validateCondition(f.getCondition())</code> always
+   * returns <code>true</code>.</p>
    *
    * @return the condition for this fulfillment.
    */
   InterledgerCondition getCondition();
 
   /**
-   * Check that the provided condition is valid for this fulfillment.
+   * <p>Check that the provided condition is valid for this fulfillment.</p>
    *
-   * <p>A valid condition is the 32 byte SHA-256 hash digest from the 32 byte opreimage represented by this fulfillment.
+   * <p>A valid condition is the 32-byte SHA-256 hash digest of the 32-byte pre-image represented
+   * by this fulfillment.</p>
    *
    * @param condition an InterledgerCondition
+   *
    * @return tru if this condition is valid for this fulfillment.
    */
   boolean validateCondition(InterledgerCondition condition);
 
   /**
-   * An immutable implementation from InterledgerFulfillment optimized for efficient operations that only create copies
-   * from the internal data as required and only performs late generation from the hash when required.
+   * An immutable implementation of InterledgerFulfillment optimized for efficient operations that
+   * only create copies of the internal data as required and only performs late generation of the
+   * hash when required.
    */
   class ImmutableInterledgerFulfillment implements InterledgerFulfillment {
 
-    private final byte[] bytes = new byte[32];
+    private final byte[] preimageBytes = new byte[32];
+    private final InterledgerCondition condition;
 
-    private InterledgerCondition condition;
-    private byte[] conditionBytes;
-
-    protected ImmutableInterledgerFulfillment(byte[] bytes) {
-      if (bytes.length != 32) {
-        throw new IllegalArgumentException(""InterledgerFulfillment must be exactly 32 bytes."");
+    protected ImmutableInterledgerFulfillment(byte[] preimageBytes) {
+      if (preimageBytes.length != 32) {
+        throw new IllegalArgumentException(
+            ""Interledger preimages must be exactly 32 preimageBytes."");",,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/204221659,https://github.com/hyperledger/quilt/pull/160#discussion_r204221659,sappenin
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,This is fixed.,2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-21 21:00:16,204221684,"@@ -152,18 +156,18 @@ public int compareTo(InterledgerFulfillment other) {
         return 0;
       }
 
-      //Only call getBytes() if we have to (avoid array copy)
+      //Only call getHash() if we have to (avoid array copy)",,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/204221684,https://github.com/hyperledger/quilt/pull/160#discussion_r204221684,sappenin
https://github.com/hyperledger/quilt/pull/160,https://github.com/hyperledger/quilt/pull/160,This is fixed.,2c8f4d753e9c734d4046a4278dd94c0a2108262a,2018-07-21 21:03:19,204221774,"@@ -62,39 +63,55 @@
 
   @Test
   public void testGetBytes() {
-    assertArrayEquals(InterledgerCondition.from(BYTES_1).getBytes(), BYTES_1);
+    assertArrayEquals(InterledgerCondition.of(BYTES_1).getHash(), BYTES_1);",,2018-07-21 21:05:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/204221774,https://github.com/hyperledger/quilt/pull/160#discussion_r204221774,sappenin
https://github.com/hyperledger/quilt/pull/150,https://github.com/hyperledger/quilt/pull/150,nit (add hyphen): `community-led`,d0a37b12c3ce3c701b5d5a6085cf11a059462b7c,2018-06-24 16:31:17,197645479,"@@ -0,0 +1,66 @@
+# Contributing
+
+Hyperledger Quilt is a truly open source project. It is a community led effort to provide the components developers need to work with the [Interledger Protocol](https://interledger.org).",,2018-07-11 09:02:49,https://api.github.com/repos/hyperledger/quilt/pulls/comments/197645479,https://github.com/hyperledger/quilt/pull/150#discussion_r197645479,sappenin
https://github.com/hyperledger/quilt/pull/150,https://github.com/hyperledger/quilt/pull/150,"nit (add comma): `To use Interledger, an`",d0a37b12c3ce3c701b5d5a6085cf11a059462b7c,2018-06-24 16:32:15,197645500,"@@ -0,0 +1,66 @@
+# Contributing
+
+Hyperledger Quilt is a truly open source project. It is a community led effort to provide the components developers need to work with the [Interledger Protocol](https://interledger.org).
+
+The initial versions of Quilt are *_Java_* implementations however any other language implementation is welcomed. Please log an issue if you'd like to contribute using a new lnaguage/stack and we'll get the necessary repo changes made so you can.
+
+First time contributors can either find a module that has not yet been implemented and try that or look for a [""Good First Issue""](https://github.com/hyperledger/quilt/issues?q=is%3Aissue+is%3Aopen+label%3A""good+first+issue"") 
+
+## Goals
+
+To use Interledger an application requires one or more of the following components:",,2018-07-11 09:02:49,https://api.github.com/repos/hyperledger/quilt/pulls/comments/197645500,https://github.com/hyperledger/quilt/pull/150#discussion_r197645500,sappenin
https://github.com/hyperledger/quilt/pull/150,https://github.com/hyperledger/quilt/pull/150,Is there a link for ILDCP?,d0a37b12c3ce3c701b5d5a6085cf11a059462b7c,2018-06-24 16:32:43,197645515,"@@ -0,0 +1,66 @@
+# Contributing
+
+Hyperledger Quilt is a truly open source project. It is a community led effort to provide the components developers need to work with the [Interledger Protocol](https://interledger.org).
+
+The initial versions of Quilt are *_Java_* implementations however any other language implementation is welcomed. Please log an issue if you'd like to contribute using a new lnaguage/stack and we'll get the necessary repo changes made so you can.
+
+First time contributors can either find a module that has not yet been implemented and try that or look for a [""Good First Issue""](https://github.com/hyperledger/quilt/issues?q=is%3Aissue+is%3Aopen+label%3A""good+first+issue"") 
+
+## Goals
+
+To use Interledger an application requires one or more of the following components:
+
+  1. Interledger Protocol Codecs
+  1. ILDCP Protocol Codecs",,2018-07-11 09:02:49,https://api.github.com/repos/hyperledger/quilt/pulls/comments/197645515,https://github.com/hyperledger/quilt/pull/150#discussion_r197645515,sappenin
https://github.com/hyperledger/quilt/pull/150,https://github.com/hyperledger/quilt/pull/150,Add links to BTP (https://github.com/interledger/rfcs/blob/master/0023-bilateral-transfer-protocol/0023-bilateral-transfer-protocol.md) and Stream (https://github.com/interledger/rfcs/blob/master/0029-stream/0029-stream.md),d0a37b12c3ce3c701b5d5a6085cf11a059462b7c,2018-06-24 16:33:49,197645544,"@@ -0,0 +1,66 @@
+# Contributing
+
+Hyperledger Quilt is a truly open source project. It is a community led effort to provide the components developers need to work with the [Interledger Protocol](https://interledger.org).
+
+The initial versions of Quilt are *_Java_* implementations however any other language implementation is welcomed. Please log an issue if you'd like to contribute using a new lnaguage/stack and we'll get the necessary repo changes made so you can.
+
+First time contributors can either find a module that has not yet been implemented and try that or look for a [""Good First Issue""](https://github.com/hyperledger/quilt/issues?q=is%3Aissue+is%3Aopen+label%3A""good+first+issue"") 
+
+## Goals
+
+To use Interledger an application requires one or more of the following components:
+
+  1. Interledger Protocol Codecs
+  1. ILDCP Protocol Codecs
+  1. Bilateral Transfer Protocol Codecs",,2018-07-11 09:02:49,https://api.github.com/repos/hyperledger/quilt/pulls/comments/197645544,https://github.com/hyperledger/quilt/pull/150#discussion_r197645544,sappenin
https://github.com/hyperledger/quilt/pull/150,https://github.com/hyperledger/quilt/pull/150,add link (https://github.com/hyperledger/quilt/wiki/Codec-Framework) to the text `codec framework` that is in the phrase `leveraging the codec framework.`,d0a37b12c3ce3c701b5d5a6085cf11a059462b7c,2018-06-24 16:34:45,197645577,"@@ -0,0 +1,66 @@
+# Contributing
+
+Hyperledger Quilt is a truly open source project. It is a community led effort to provide the components developers need to work with the [Interledger Protocol](https://interledger.org).
+
+The initial versions of Quilt are *_Java_* implementations however any other language implementation is welcomed. Please log an issue if you'd like to contribute using a new lnaguage/stack and we'll get the necessary repo changes made so you can.
+
+First time contributors can either find a module that has not yet been implemented and try that or look for a [""Good First Issue""](https://github.com/hyperledger/quilt/issues?q=is%3Aissue+is%3Aopen+label%3A""good+first+issue"") 
+
+## Goals
+
+To use Interledger an application requires one or more of the following components:
+
+  1. Interledger Protocol Codecs
+  1. ILDCP Protocol Codecs
+  1. Bilateral Transfer Protocol Codecs
+  1. STREAM Protocol Codecs, Sender and Receiver
+
+Our goal is to provide these componenets for as many languages/platforms as possible.
+
+## Structure and Conventions
+
+For each protocol in the stack there is a module that defines the domain objects and another module that provides the codecs for those objects, leveraging the codec framework. New protocols should follow the same convention.",,2018-07-11 09:02:49,https://api.github.com/repos/hyperledger/quilt/pulls/comments/197645577,https://github.com/hyperledger/quilt/pull/150#discussion_r197645577,sappenin
https://github.com/hyperledger/quilt/pull/150,https://github.com/hyperledger/quilt/pull/150,"add link (https://immutables.github.io/) to text `Immutables library` so that it read likes this:

>  with internal abstract class definitions that use the [Immutables library](https://immutables.github.io/) to generate immutable",d0a37b12c3ce3c701b5d5a6085cf11a059462b7c,2018-06-24 16:36:21,197645651,"@@ -0,0 +1,66 @@
+# Contributing
+
+Hyperledger Quilt is a truly open source project. It is a community led effort to provide the components developers need to work with the [Interledger Protocol](https://interledger.org).
+
+The initial versions of Quilt are *_Java_* implementations however any other language implementation is welcomed. Please log an issue if you'd like to contribute using a new lnaguage/stack and we'll get the necessary repo changes made so you can.
+
+First time contributors can either find a module that has not yet been implemented and try that or look for a [""Good First Issue""](https://github.com/hyperledger/quilt/issues?q=is%3Aissue+is%3Aopen+label%3A""good+first+issue"") 
+
+## Goals
+
+To use Interledger an application requires one or more of the following components:
+
+  1. Interledger Protocol Codecs
+  1. ILDCP Protocol Codecs
+  1. Bilateral Transfer Protocol Codecs
+  1. STREAM Protocol Codecs, Sender and Receiver
+
+Our goal is to provide these componenets for as many languages/platforms as possible.
+
+## Structure and Conventions
+
+For each protocol in the stack there is a module that defines the domain objects and another module that provides the codecs for those objects, leveraging the codec framework. New protocols should follow the same convention.
+
+Domain objects are defined as interfaces with internal abstract class definitions that use the Immutables library to generate immutable implementations with handy builders.",,2018-07-11 09:02:49,https://api.github.com/repos/hyperledger/quilt/pulls/comments/197645651,https://github.com/hyperledger/quilt/pull/150#discussion_r197645651,sappenin
https://github.com/hyperledger/quilt/pull/150,https://github.com/hyperledger/quilt/pull/150,Add link again for STREAM RFC?,d0a37b12c3ce3c701b5d5a6085cf11a059462b7c,2018-06-24 16:37:31,197645676,"@@ -0,0 +1,66 @@
+# Contributing
+
+Hyperledger Quilt is a truly open source project. It is a community led effort to provide the components developers need to work with the [Interledger Protocol](https://interledger.org).
+
+The initial versions of Quilt are *_Java_* implementations however any other language implementation is welcomed. Please log an issue if you'd like to contribute using a new lnaguage/stack and we'll get the necessary repo changes made so you can.
+
+First time contributors can either find a module that has not yet been implemented and try that or look for a [""Good First Issue""](https://github.com/hyperledger/quilt/issues?q=is%3Aissue+is%3Aopen+label%3A""good+first+issue"") 
+
+## Goals
+
+To use Interledger an application requires one or more of the following components:
+
+  1. Interledger Protocol Codecs
+  1. ILDCP Protocol Codecs
+  1. Bilateral Transfer Protocol Codecs
+  1. STREAM Protocol Codecs, Sender and Receiver
+
+Our goal is to provide these componenets for as many languages/platforms as possible.
+
+## Structure and Conventions
+
+For each protocol in the stack there is a module that defines the domain objects and another module that provides the codecs for those objects, leveraging the codec framework. New protocols should follow the same convention.
+
+Domain objects are defined as interfaces with internal abstract class definitions that use the Immutables library to generate immutable implementations with handy builders.
+
+The standard Immutables config is encapsulated in a custom annotation which should be used on the abstract class definitions. See the interfaces in [ilp-core](ilp-core) as an example.
+
+## Code Style
+
+We are using checkstyle to enforce our style rules which are defined in the [dev-ops](dev-ops) project.
+
+## Codec Framework
+
+See: [codec-framework](codec-framework)
+
+All ILP protocols use Octet Encoding Rules for encoding data on the wire. The message definitions are in ASN.1 notation and the Quilt project provides language native domain objects for these.
+
+The library also provides a framework that can be used to define ASN.1 representations of the domain objects and serializers to encode/decode the objects on/off the wire.
+
+If there are any generic ASN.1 types that are not provided in the codec framework, these should be implemented as required in the framework. Protocol specific types are implemented in their own sub-modules. 
+
+### Interledger Protocol
+
+See: [ilp-core](ilp-core)
+
+This project defines the doamin objects required for the core protocol.
+Codecs are in [ilp-core-codecs](ilp-core-codecs).
+
+### Interledger Dynamip Configuration Protocol
+
+See: [ildcp-core](ildcp-core)
+
+This project defines the domain objects required for the IL-DCP messages exchange inside ILP packets between peers using the IL-DCP protocol.
+Codecs are in [ildcp-core-codecs](ildcp-core-codecs).
+
+### Bilateral Transfer Protocol
+
+See: [btp-core](btp-core)
+
+BTP is a protocol commonly used between peers to carry ILP packets and also negotiate reconciliation and settlement.
+It is most commonly used over Websockets but any transport that is able to frame messages would work.
+
+### STREAM Protocol
+
+STREAM is the transport protocol that is used to establish a connection between two enitities on the Interledger and exchange money and data between them.",65,2018-07-11 09:02:49,https://api.github.com/repos/hyperledger/quilt/pulls/comments/197645676,https://github.com/hyperledger/quilt/pull/150#discussion_r197645676,sappenin
https://github.com/hyperledger/quilt/pull/146,https://github.com/hyperledger/quilt/pull/146,I believe this is what is causing the build to fail on CI.,87bb770ab10a0b4fa275a16f7afdd55ddb4ddc89,2018-06-11 18:55:39,194510961,"@@ -1,6 +1,11 @@
 <?xml version=""1.0"" encoding=""UTF-8""?>
 <project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
          xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+  <parent>",,2018-06-13 08:33:22,https://api.github.com/repos/hyperledger/quilt/pulls/comments/194510961,https://github.com/hyperledger/quilt/pull/146#discussion_r194510961,adrianhopebailie
https://github.com/hyperledger/quilt/pull/127,https://github.com/hyperledger/quilt/pull/127,"One minor nit with this implementation -- it allows a caller to make the following call without an error:

```
InterledgerAddress.requireAddressPrefix(address, null);
```

This should throw an error, because we don't want our public API contracts to be operating on [null values](https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained).

This can be rectified by inverting the calls between the two methods. So, if `requireAddressPrefix(address)` is called, it should internally call `requireAddressPrefix(address, ""addressPrefix must not be null!"")`. Then we can add an `Objects.requireNotNull` check inside of `requireAddressPrefix(address, message)` on line 115 for the message.",b28eec537261599328a995d144a43ab6cc943eae,2018-03-14 16:48:08,174530122,"@@ -81,15 +81,46 @@ static boolean isValid(final String value) {
    * @throws IllegalArgumentException if the supplied Interledger address is not a ledger-prefix.
    */
   static InterledgerAddress requireAddressPrefix(final InterledgerAddress addressPrefix) {
-    Objects.requireNonNull(addressPrefix, ""addressPrefix must not be null!"");
-    if (!addressPrefix.isLedgerPrefix()) {
-      throw new IllegalArgumentException(
-          String.format(""InterledgerAddress '%s' must be an Address Prefix ending with a dot (.)"",
-              addressPrefix.getValue()
+    return requireAddressPrefix(addressPrefix, null);
+  }
+
+  /**
+   * Checks and requires that the specified {@code addressPrefix} is an address prefix per {@link
+   * InterledgerAddress#isLedgerPrefix()}, providing an error message upon invalidation.
+   *
+   * <p>This method is designed primarily for doing parameter validation in methods and
+   * constructors, as demonstrated below:</p> <blockquote>
+   * <pre>
+   * public Foo(InterledgerAddress bar) {
+   *     this.ledgerPrefix = InterledgerAddress.requireAddressPrefix(bar,
+   *         bar + "" must be an address prefix);
+   * }
+   * </pre>
+   * </blockquote>
+   *
+   * @param address A {@link InterledgerAddress} to check.
+   * @param errorMessage An error message to output upon invalidation.
+   *
+   * @return {@code ledgerPrefix} if its value ends with a dot (.).
+   *
+   * @throws IllegalArgumentException if the supplied Interledger address is not a
+   *     ledger-prefix. Embeds the {@code errorMessage}.
+   */
+  static InterledgerAddress requireAddressPrefix(final InterledgerAddress address,",61,2018-03-17 18:09:21,https://api.github.com/repos/hyperledger/quilt/pulls/comments/174530122,https://github.com/hyperledger/quilt/pull/127#discussion_r174530122,sappenin
https://github.com/hyperledger/quilt/pull/127,https://github.com/hyperledger/quilt/pull/127,"I'm gonna refactor accordingly.

However, there are 2 default error messages in `#requireAddressPrefix(InterledgerAddress)` currently: `""InterledgerAddress must not be null!""` and `String.format(""InterledgerAddress '%s' must be an Address Prefix ending with a dot (.)"",address.getValue())`.

As a consequence, a `private` `#checkAddressPrefix(InterledgerAddress, String, String)` will probably be needed in order for `#requireAddressPrefix(InterledgerAddress, String)` to comply with the error messages multiplicity (i.e. to override any error message of the base method).",b28eec537261599328a995d144a43ab6cc943eae,2018-03-14 17:46:27,174550735,"@@ -81,15 +81,46 @@ static boolean isValid(final String value) {
    * @throws IllegalArgumentException if the supplied Interledger address is not a ledger-prefix.
    */
   static InterledgerAddress requireAddressPrefix(final InterledgerAddress addressPrefix) {
-    Objects.requireNonNull(addressPrefix, ""addressPrefix must not be null!"");
-    if (!addressPrefix.isLedgerPrefix()) {
-      throw new IllegalArgumentException(
-          String.format(""InterledgerAddress '%s' must be an Address Prefix ending with a dot (.)"",
-              addressPrefix.getValue()
+    return requireAddressPrefix(addressPrefix, null);
+  }
+
+  /**
+   * Checks and requires that the specified {@code addressPrefix} is an address prefix per {@link
+   * InterledgerAddress#isLedgerPrefix()}, providing an error message upon invalidation.
+   *
+   * <p>This method is designed primarily for doing parameter validation in methods and
+   * constructors, as demonstrated below:</p> <blockquote>
+   * <pre>
+   * public Foo(InterledgerAddress bar) {
+   *     this.ledgerPrefix = InterledgerAddress.requireAddressPrefix(bar,
+   *         bar + "" must be an address prefix);
+   * }
+   * </pre>
+   * </blockquote>
+   *
+   * @param address A {@link InterledgerAddress} to check.
+   * @param errorMessage An error message to output upon invalidation.
+   *
+   * @return {@code ledgerPrefix} if its value ends with a dot (.).
+   *
+   * @throws IllegalArgumentException if the supplied Interledger address is not a
+   *     ledger-prefix. Embeds the {@code errorMessage}.
+   */
+  static InterledgerAddress requireAddressPrefix(final InterledgerAddress address,",61,2018-03-17 18:09:21,https://api.github.com/repos/hyperledger/quilt/pulls/comments/174550735,https://github.com/hyperledger/quilt/pull/127#discussion_r174550735,pascalav
https://github.com/hyperledger/quilt/pull/127,https://github.com/hyperledger/quilt/pull/127,"Finally I did not find a simple refactor in order to put the overriden message in place of defaults. 

Made this through the `InterledgerAddressParser`, since the `InterledgerAddress` interface cannot have both `private` and `static` methods. I didn't want to put additional weigh on that facade class also.",b28eec537261599328a995d144a43ab6cc943eae,2018-03-14 20:25:18,174598780,"@@ -81,15 +81,46 @@ static boolean isValid(final String value) {
    * @throws IllegalArgumentException if the supplied Interledger address is not a ledger-prefix.
    */
   static InterledgerAddress requireAddressPrefix(final InterledgerAddress addressPrefix) {
-    Objects.requireNonNull(addressPrefix, ""addressPrefix must not be null!"");
-    if (!addressPrefix.isLedgerPrefix()) {
-      throw new IllegalArgumentException(
-          String.format(""InterledgerAddress '%s' must be an Address Prefix ending with a dot (.)"",
-              addressPrefix.getValue()
+    return requireAddressPrefix(addressPrefix, null);
+  }
+
+  /**
+   * Checks and requires that the specified {@code addressPrefix} is an address prefix per {@link
+   * InterledgerAddress#isLedgerPrefix()}, providing an error message upon invalidation.
+   *
+   * <p>This method is designed primarily for doing parameter validation in methods and
+   * constructors, as demonstrated below:</p> <blockquote>
+   * <pre>
+   * public Foo(InterledgerAddress bar) {
+   *     this.ledgerPrefix = InterledgerAddress.requireAddressPrefix(bar,
+   *         bar + "" must be an address prefix);
+   * }
+   * </pre>
+   * </blockquote>
+   *
+   * @param address A {@link InterledgerAddress} to check.
+   * @param errorMessage An error message to output upon invalidation.
+   *
+   * @return {@code ledgerPrefix} if its value ends with a dot (.).
+   *
+   * @throws IllegalArgumentException if the supplied Interledger address is not a
+   *     ledger-prefix. Embeds the {@code errorMessage}.
+   */
+  static InterledgerAddress requireAddressPrefix(final InterledgerAddress address,",61,2018-03-17 18:09:21,https://api.github.com/repos/hyperledger/quilt/pulls/comments/174598780,https://github.com/hyperledger/quilt/pull/127#discussion_r174598780,pascalav
https://github.com/hyperledger/quilt/pull/127,https://github.com/hyperledger/quilt/pull/127,"Ah, yes, seeing that now. OK, LGTM!",b28eec537261599328a995d144a43ab6cc943eae,2018-03-17 18:09:11,175265526,"@@ -81,15 +81,46 @@ static boolean isValid(final String value) {
    * @throws IllegalArgumentException if the supplied Interledger address is not a ledger-prefix.
    */
   static InterledgerAddress requireAddressPrefix(final InterledgerAddress addressPrefix) {
-    Objects.requireNonNull(addressPrefix, ""addressPrefix must not be null!"");
-    if (!addressPrefix.isLedgerPrefix()) {
-      throw new IllegalArgumentException(
-          String.format(""InterledgerAddress '%s' must be an Address Prefix ending with a dot (.)"",
-              addressPrefix.getValue()
+    return requireAddressPrefix(addressPrefix, null);
+  }
+
+  /**
+   * Checks and requires that the specified {@code addressPrefix} is an address prefix per {@link
+   * InterledgerAddress#isLedgerPrefix()}, providing an error message upon invalidation.
+   *
+   * <p>This method is designed primarily for doing parameter validation in methods and
+   * constructors, as demonstrated below:</p> <blockquote>
+   * <pre>
+   * public Foo(InterledgerAddress bar) {
+   *     this.ledgerPrefix = InterledgerAddress.requireAddressPrefix(bar,
+   *         bar + "" must be an address prefix);
+   * }
+   * </pre>
+   * </blockquote>
+   *
+   * @param address A {@link InterledgerAddress} to check.
+   * @param errorMessage An error message to output upon invalidation.
+   *
+   * @return {@code ledgerPrefix} if its value ends with a dot (.).
+   *
+   * @throws IllegalArgumentException if the supplied Interledger address is not a
+   *     ledger-prefix. Embeds the {@code errorMessage}.
+   */
+  static InterledgerAddress requireAddressPrefix(final InterledgerAddress address,",61,2018-03-17 18:09:21,https://api.github.com/repos/hyperledger/quilt/pulls/comments/175265526,https://github.com/hyperledger/quilt/pull/127#discussion_r175265526,sappenin
https://github.com/hyperledger/quilt/pull/123,https://github.com/hyperledger/quilt/pull/123,"I think we should keep the error message assertions. Primarily, it validates that the `IllegalArgumentException` that was thrown was actually what we expected, as opposed to being some _other_ IllegalArgumentException. 

Thoughts?",14ac4dd72a9913cf0e4deb9d7bd0d9f6fed81613,2018-02-26 16:32:23,170652074,"@@ -72,46 +69,22 @@ public void testConstruction_LedgerPrefix() {
 
   @Test(expected = IllegalArgumentException.class)
   public void test_empty_address() {
-    final String value = """";
-    try {
-      InterledgerAddress.builder().value(value).build();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage(), is(String.format(EXPECTED_ERROR_MESSAGE, value)));
-      throw e;
-    }
+    InterledgerAddress.builder().value("""").build();
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void test_blank_address() {
-    final String value = ""  "";
-    try {
-      InterledgerAddress.builder().value(value).build();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage(), is(String.format(EXPECTED_ERROR_MESSAGE, value)));",,2018-02-28 17:54:31,https://api.github.com/repos/hyperledger/quilt/pulls/comments/170652074,https://github.com/hyperledger/quilt/pull/123#discussion_r170652074,sappenin
https://github.com/hyperledger/quilt/pull/123,https://github.com/hyperledger/quilt/pull/123,"I don't think so. Here is my point of view, through another domain use-case:

`doorKeeper#canStartBlackFriday` // possible catches: `goodsUnavailableException(pendingDeliveryException)`, `goodsUnavailableException(supplierOutOfStockException)`, `tooEarlyException(""Disallowed before 9AM"")`
__-> `warehouseManager#areGoodsAvailable` // possible catches: `pendingDeliveryException, supplierOutOfStockException`
____-> `transportPartner#isOrderDelivered`
____-> `supplier#isSerialNumberInStock`
__-> `timeService#isGTE9AM`

By separating concerns, the `doorKeeper` may:
* Either, delay the doors opening until all lights are green
* Either, contact the `storeOwner` and forward him the underlying `goodsUnavailableException` or `tooEarlyException` for decision
* Either, delay the doors opening in case of a `goodsUnavailableException`
* Either, bypass restriction with a tolerance threshold in case of a `tooEarlyException`

That is, he has a shallow view of the situation, and should probably not be given a deeper visibility on nested events (i.e. knowing that goods are not available due to a supplier shortage or to a transport issue is too much knowledge for his business imo).

Put back in our situation, PR is currently:

`test-caller` // catches: `illegalArgumentException(""Address has no scheme prefix"")`
__-> addressBuilder#build // forwards / passes through the unaltered: `illegalArgumentException(""Address has no scheme prefix"")`
____-> `addressParser#validate`

Just now, I would change this into:

`test-caller` // catches: `illegalArgumentException(""Address is invalid"", illegalArgumentException)` (and we may imagine other causes such as `""Address has no route to destination""` even if it seems unsuitable to be managed so early at runtime)
__-> `addressBuilder#build` // catches `illegalArgumentException(""Address has no scheme prefix"")` and mixes it into a new `illegalArgumentException(""Address is invalid"", illegalArgumentException)`
____-> `addressParser#validate`

And the `addressBuilder` test-class would check for the `Address is invalid` error message, rather than digging into the parser internals (which are already checked in the parser test-class, therefore would be redundant in here).

In the long run, rather than relying on error messages only, I would subclass `InterledgerRuntimeException` into `InvalidAddressException`, `AnotherCauseException` and so on.
`test-caller` would then shallow-check the exception type only.",14ac4dd72a9913cf0e4deb9d7bd0d9f6fed81613,2018-02-26 18:32:49,170690221,"@@ -72,46 +69,22 @@ public void testConstruction_LedgerPrefix() {
 
   @Test(expected = IllegalArgumentException.class)
   public void test_empty_address() {
-    final String value = """";
-    try {
-      InterledgerAddress.builder().value(value).build();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage(), is(String.format(EXPECTED_ERROR_MESSAGE, value)));
-      throw e;
-    }
+    InterledgerAddress.builder().value("""").build();
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void test_blank_address() {
-    final String value = ""  "";
-    try {
-      InterledgerAddress.builder().value(value).build();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage(), is(String.format(EXPECTED_ERROR_MESSAGE, value)));",,2018-02-28 17:54:31,https://api.github.com/repos/hyperledger/quilt/pulls/comments/170690221,https://github.com/hyperledger/quilt/pull/123#discussion_r170690221,pascalav
https://github.com/hyperledger/quilt/pull/123,https://github.com/hyperledger/quilt/pull/123,"Do you think that the method signature - as well as its Javadoc - should state `throws IllegalArgumentException`?

I think so, even if mentionning unchecked exceptions in method signatures is bad practice (because most of time, they are not checked/catched by caller). This way, a dev doesn't have to dig into the method's logic to finally find that validation gets rejected through a `RuntimeException`.",14ac4dd72a9913cf0e4deb9d7bd0d9f6fed81613,2018-02-26 18:37:59,170691718,"@@ -0,0 +1,133 @@
+package org.interledger.core;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+/**
+ * An {@link org.interledger.core.InterledgerAddress}es parser.
+ */
+final class InterledgerAddressParser {
+
+  static enum Error {
+    ADDRESS_OVERFLOW(""Address is too long""),
+    INVALID_SEGMENT(""The '%s' segment has an invalid format""),
+    INVALID_SCHEME_PREFIX(""The '%s' scheme prefix has an invalid format""),
+    MISSING_SCHEME_PREFIX(""Address does not start with a scheme prefix""),
+    SEGMENTS_UNDERFLOW(""Destination address has too few segments"");
+
+    private String messageFormat;
+
+    private Error(final String messageFormat) {
+      this.messageFormat = messageFormat;
+    }
+
+    public String getMessageFormat() {
+      return messageFormat;
+    }
+  }
+
+  private static final int MIN_ADDRESS_LENGTH = 1;
+  private static final int MAX_ADDRESS_LENGTH = 1023;
+  private static final int DESTINATION_ADDRESS_MIN_SEGMENTS = 2;
+
+  private static final String SCHEME_REGEX = ""(g|private|example|peer|self|test[1-3]?)"";
+  private static final String SEGMENT_REGEX = ""[a-zA-Z0-9_~-]+"";
+  private static final String SEPARATOR_CHARACTER = ""."";
+  private static final String SEPARATOR_REGEX = ""["" + SEPARATOR_CHARACTER + ""]"";
+  private static final String SCHEME_PREFIX_REGEX = SCHEME_REGEX + SEPARATOR_REGEX;
+  private static final String SEGMENT_PREFIX_REGEX = SEGMENT_REGEX + SEPARATOR_REGEX;
+  private static final String ADDRESS_LENGTH_BOUNDARIES_REGEX = ""(?=^.{"" + MIN_ADDRESS_LENGTH + "",""
+      + MAX_ADDRESS_LENGTH + ""}$)"";
+
+  private static final String ADDRESS_PREFIX_REGEX = ADDRESS_LENGTH_BOUNDARIES_REGEX
+      + ""^"" + SCHEME_PREFIX_REGEX + ""("" + SEGMENT_PREFIX_REGEX + "")*$"";
+  private static final Pattern ADDRESS_PREFIX_PATTERN = Pattern.compile(ADDRESS_PREFIX_REGEX);
+
+  private static final String DESTINATION_ADDRESS_REGEX = ADDRESS_LENGTH_BOUNDARIES_REGEX
+      + ""^"" + SCHEME_PREFIX_REGEX + ""("" + SEGMENT_PREFIX_REGEX + "")+""
+      + SEGMENT_REGEX + ""$"";
+  private static final Pattern DESTINATION_ADDRESS_PATTERN = Pattern.compile(
+      DESTINATION_ADDRESS_REGEX
+  );
+
+  private static final String SCHEME_PREFIX_ONLY_REGEX = ""^"" + SCHEME_PREFIX_REGEX + ""$"";
+  private static final Pattern SCHEME_PREFIX_ONLY_PATTERN = Pattern.compile(
+      SCHEME_PREFIX_ONLY_REGEX
+  );
+
+  /**
+   * Validates an ILP address.
+   * 
+   * @param addressString The ILP address to validate
+   */
+  void validate(final String addressString) {",,2018-02-28 17:54:31,https://api.github.com/repos/hyperledger/quilt/pulls/comments/170691718,https://github.com/hyperledger/quilt/pull/123#discussion_r170691718,pascalav
https://github.com/hyperledger/quilt/pull/123,https://github.com/hyperledger/quilt/pull/123,"Anyway, I can do as you suggested (which also ends up in redundancy of the address-invalidity cause check among test-classes), just confirm and I'll do so.",14ac4dd72a9913cf0e4deb9d7bd0d9f6fed81613,2018-02-26 18:40:53,170692526,"@@ -72,46 +69,22 @@ public void testConstruction_LedgerPrefix() {
 
   @Test(expected = IllegalArgumentException.class)
   public void test_empty_address() {
-    final String value = """";
-    try {
-      InterledgerAddress.builder().value(value).build();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage(), is(String.format(EXPECTED_ERROR_MESSAGE, value)));
-      throw e;
-    }
+    InterledgerAddress.builder().value("""").build();
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void test_blank_address() {
-    final String value = ""  "";
-    try {
-      InterledgerAddress.builder().value(value).build();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage(), is(String.format(EXPECTED_ERROR_MESSAGE, value)));",,2018-02-28 17:54:31,https://api.github.com/repos/hyperledger/quilt/pulls/comments/170692526,https://github.com/hyperledger/quilt/pull/123#discussion_r170692526,pascalav
https://github.com/hyperledger/quilt/pull/123,https://github.com/hyperledger/quilt/pull/123,"To illustrate the discussion about the ""cause of `IllegalArgumentException`"" check in the `InterledgerAddressBuilderTest` class, I would change this line into:

> try {
>   ADDRESS_PARSER.validate(value);
> } catch (final IllegalArgumentException e) {
>   throw new IllegalArgumentException(""Address is invalid"", e);
> }

Then `InterledgerAddressBuilderTest` would only rely on that later message.",14ac4dd72a9913cf0e4deb9d7bd0d9f6fed81613,2018-02-26 18:56:54,170697627,"@@ -67,9 +57,8 @@ static InterledgerAddress of(final String value) {
    */
   static boolean isValid(final String value) {
     Objects.requireNonNull(value);
-    return (value.endsWith(""."") ? ADDRESS_PREFIX_PATTERN : DESTINATION_ADDRESS_PATTERN)
-        .matcher(value)
-        .matches();
+    ADDRESS_PARSER.validate(value);",33,2018-02-28 17:54:31,https://api.github.com/repos/hyperledger/quilt/pulls/comments/170697627,https://github.com/hyperledger/quilt/pull/123#discussion_r170697627,pascalav
https://github.com/hyperledger/quilt/pull/123,https://github.com/hyperledger/quilt/pull/123,Sounds fine to me.,14ac4dd72a9913cf0e4deb9d7bd0d9f6fed81613,2018-02-28 03:02:01,171132328,"@@ -0,0 +1,133 @@
+package org.interledger.core;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+/**
+ * An {@link org.interledger.core.InterledgerAddress}es parser.
+ */
+final class InterledgerAddressParser {
+
+  static enum Error {
+    ADDRESS_OVERFLOW(""Address is too long""),
+    INVALID_SEGMENT(""The '%s' segment has an invalid format""),
+    INVALID_SCHEME_PREFIX(""The '%s' scheme prefix has an invalid format""),
+    MISSING_SCHEME_PREFIX(""Address does not start with a scheme prefix""),
+    SEGMENTS_UNDERFLOW(""Destination address has too few segments"");
+
+    private String messageFormat;
+
+    private Error(final String messageFormat) {
+      this.messageFormat = messageFormat;
+    }
+
+    public String getMessageFormat() {
+      return messageFormat;
+    }
+  }
+
+  private static final int MIN_ADDRESS_LENGTH = 1;
+  private static final int MAX_ADDRESS_LENGTH = 1023;
+  private static final int DESTINATION_ADDRESS_MIN_SEGMENTS = 2;
+
+  private static final String SCHEME_REGEX = ""(g|private|example|peer|self|test[1-3]?)"";
+  private static final String SEGMENT_REGEX = ""[a-zA-Z0-9_~-]+"";
+  private static final String SEPARATOR_CHARACTER = ""."";
+  private static final String SEPARATOR_REGEX = ""["" + SEPARATOR_CHARACTER + ""]"";
+  private static final String SCHEME_PREFIX_REGEX = SCHEME_REGEX + SEPARATOR_REGEX;
+  private static final String SEGMENT_PREFIX_REGEX = SEGMENT_REGEX + SEPARATOR_REGEX;
+  private static final String ADDRESS_LENGTH_BOUNDARIES_REGEX = ""(?=^.{"" + MIN_ADDRESS_LENGTH + "",""
+      + MAX_ADDRESS_LENGTH + ""}$)"";
+
+  private static final String ADDRESS_PREFIX_REGEX = ADDRESS_LENGTH_BOUNDARIES_REGEX
+      + ""^"" + SCHEME_PREFIX_REGEX + ""("" + SEGMENT_PREFIX_REGEX + "")*$"";
+  private static final Pattern ADDRESS_PREFIX_PATTERN = Pattern.compile(ADDRESS_PREFIX_REGEX);
+
+  private static final String DESTINATION_ADDRESS_REGEX = ADDRESS_LENGTH_BOUNDARIES_REGEX
+      + ""^"" + SCHEME_PREFIX_REGEX + ""("" + SEGMENT_PREFIX_REGEX + "")+""
+      + SEGMENT_REGEX + ""$"";
+  private static final Pattern DESTINATION_ADDRESS_PATTERN = Pattern.compile(
+      DESTINATION_ADDRESS_REGEX
+  );
+
+  private static final String SCHEME_PREFIX_ONLY_REGEX = ""^"" + SCHEME_PREFIX_REGEX + ""$"";
+  private static final Pattern SCHEME_PREFIX_ONLY_PATTERN = Pattern.compile(
+      SCHEME_PREFIX_ONLY_REGEX
+  );
+
+  /**
+   * Validates an ILP address.
+   * 
+   * @param addressString The ILP address to validate
+   */
+  void validate(final String addressString) {",,2018-02-28 17:54:31,https://api.github.com/repos/hyperledger/quilt/pulls/comments/171132328,https://github.com/hyperledger/quilt/pull/123#discussion_r171132328,sappenin
https://github.com/hyperledger/quilt/pull/123,https://github.com/hyperledger/quilt/pull/123,"Ok, I'll make that small modification shortly.",14ac4dd72a9913cf0e4deb9d7bd0d9f6fed81613,2018-02-28 17:37:15,171325024,"@@ -0,0 +1,133 @@
+package org.interledger.core;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+/**
+ * An {@link org.interledger.core.InterledgerAddress}es parser.
+ */
+final class InterledgerAddressParser {
+
+  static enum Error {
+    ADDRESS_OVERFLOW(""Address is too long""),
+    INVALID_SEGMENT(""The '%s' segment has an invalid format""),
+    INVALID_SCHEME_PREFIX(""The '%s' scheme prefix has an invalid format""),
+    MISSING_SCHEME_PREFIX(""Address does not start with a scheme prefix""),
+    SEGMENTS_UNDERFLOW(""Destination address has too few segments"");
+
+    private String messageFormat;
+
+    private Error(final String messageFormat) {
+      this.messageFormat = messageFormat;
+    }
+
+    public String getMessageFormat() {
+      return messageFormat;
+    }
+  }
+
+  private static final int MIN_ADDRESS_LENGTH = 1;
+  private static final int MAX_ADDRESS_LENGTH = 1023;
+  private static final int DESTINATION_ADDRESS_MIN_SEGMENTS = 2;
+
+  private static final String SCHEME_REGEX = ""(g|private|example|peer|self|test[1-3]?)"";
+  private static final String SEGMENT_REGEX = ""[a-zA-Z0-9_~-]+"";
+  private static final String SEPARATOR_CHARACTER = ""."";
+  private static final String SEPARATOR_REGEX = ""["" + SEPARATOR_CHARACTER + ""]"";
+  private static final String SCHEME_PREFIX_REGEX = SCHEME_REGEX + SEPARATOR_REGEX;
+  private static final String SEGMENT_PREFIX_REGEX = SEGMENT_REGEX + SEPARATOR_REGEX;
+  private static final String ADDRESS_LENGTH_BOUNDARIES_REGEX = ""(?=^.{"" + MIN_ADDRESS_LENGTH + "",""
+      + MAX_ADDRESS_LENGTH + ""}$)"";
+
+  private static final String ADDRESS_PREFIX_REGEX = ADDRESS_LENGTH_BOUNDARIES_REGEX
+      + ""^"" + SCHEME_PREFIX_REGEX + ""("" + SEGMENT_PREFIX_REGEX + "")*$"";
+  private static final Pattern ADDRESS_PREFIX_PATTERN = Pattern.compile(ADDRESS_PREFIX_REGEX);
+
+  private static final String DESTINATION_ADDRESS_REGEX = ADDRESS_LENGTH_BOUNDARIES_REGEX
+      + ""^"" + SCHEME_PREFIX_REGEX + ""("" + SEGMENT_PREFIX_REGEX + "")+""
+      + SEGMENT_REGEX + ""$"";
+  private static final Pattern DESTINATION_ADDRESS_PATTERN = Pattern.compile(
+      DESTINATION_ADDRESS_REGEX
+  );
+
+  private static final String SCHEME_PREFIX_ONLY_REGEX = ""^"" + SCHEME_PREFIX_REGEX + ""$"";
+  private static final Pattern SCHEME_PREFIX_ONLY_PATTERN = Pattern.compile(
+      SCHEME_PREFIX_ONLY_REGEX
+  );
+
+  /**
+   * Validates an ILP address.
+   * 
+   * @param addressString The ILP address to validate
+   */
+  void validate(final String addressString) {",,2018-02-28 17:54:31,https://api.github.com/repos/hyperledger/quilt/pulls/comments/171325024,https://github.com/hyperledger/quilt/pull/123#discussion_r171325024,pascalav
https://github.com/hyperledger/quilt/pull/123,https://github.com/hyperledger/quilt/pull/123,This point is now adressed.,14ac4dd72a9913cf0e4deb9d7bd0d9f6fed81613,2018-03-01 19:11:39,171662741,"@@ -0,0 +1,133 @@
+package org.interledger.core;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+/**
+ * An {@link org.interledger.core.InterledgerAddress}es parser.
+ */
+final class InterledgerAddressParser {
+
+  static enum Error {
+    ADDRESS_OVERFLOW(""Address is too long""),
+    INVALID_SEGMENT(""The '%s' segment has an invalid format""),
+    INVALID_SCHEME_PREFIX(""The '%s' scheme prefix has an invalid format""),
+    MISSING_SCHEME_PREFIX(""Address does not start with a scheme prefix""),
+    SEGMENTS_UNDERFLOW(""Destination address has too few segments"");
+
+    private String messageFormat;
+
+    private Error(final String messageFormat) {
+      this.messageFormat = messageFormat;
+    }
+
+    public String getMessageFormat() {
+      return messageFormat;
+    }
+  }
+
+  private static final int MIN_ADDRESS_LENGTH = 1;
+  private static final int MAX_ADDRESS_LENGTH = 1023;
+  private static final int DESTINATION_ADDRESS_MIN_SEGMENTS = 2;
+
+  private static final String SCHEME_REGEX = ""(g|private|example|peer|self|test[1-3]?)"";
+  private static final String SEGMENT_REGEX = ""[a-zA-Z0-9_~-]+"";
+  private static final String SEPARATOR_CHARACTER = ""."";
+  private static final String SEPARATOR_REGEX = ""["" + SEPARATOR_CHARACTER + ""]"";
+  private static final String SCHEME_PREFIX_REGEX = SCHEME_REGEX + SEPARATOR_REGEX;
+  private static final String SEGMENT_PREFIX_REGEX = SEGMENT_REGEX + SEPARATOR_REGEX;
+  private static final String ADDRESS_LENGTH_BOUNDARIES_REGEX = ""(?=^.{"" + MIN_ADDRESS_LENGTH + "",""
+      + MAX_ADDRESS_LENGTH + ""}$)"";
+
+  private static final String ADDRESS_PREFIX_REGEX = ADDRESS_LENGTH_BOUNDARIES_REGEX
+      + ""^"" + SCHEME_PREFIX_REGEX + ""("" + SEGMENT_PREFIX_REGEX + "")*$"";
+  private static final Pattern ADDRESS_PREFIX_PATTERN = Pattern.compile(ADDRESS_PREFIX_REGEX);
+
+  private static final String DESTINATION_ADDRESS_REGEX = ADDRESS_LENGTH_BOUNDARIES_REGEX
+      + ""^"" + SCHEME_PREFIX_REGEX + ""("" + SEGMENT_PREFIX_REGEX + "")+""
+      + SEGMENT_REGEX + ""$"";
+  private static final Pattern DESTINATION_ADDRESS_PATTERN = Pattern.compile(
+      DESTINATION_ADDRESS_REGEX
+  );
+
+  private static final String SCHEME_PREFIX_ONLY_REGEX = ""^"" + SCHEME_PREFIX_REGEX + ""$"";
+  private static final Pattern SCHEME_PREFIX_ONLY_PATTERN = Pattern.compile(
+      SCHEME_PREFIX_ONLY_REGEX
+  );
+
+  /**
+   * Validates an ILP address.
+   * 
+   * @param addressString The ILP address to validate
+   */
+  void validate(final String addressString) {",,2018-03-01 19:11:39,https://api.github.com/repos/hyperledger/quilt/pulls/comments/171662741,https://github.com/hyperledger/quilt/pull/123#discussion_r171662741,pascalav
https://github.com/hyperledger/quilt/pull/123,https://github.com/hyperledger/quilt/pull/123,This point is now adressed: I restored the `IllegalArgumentException` checks in test-classes that use the `InterledgerAddressBuilder`.,14ac4dd72a9913cf0e4deb9d7bd0d9f6fed81613,2018-03-01 19:13:43,171663391,"@@ -72,46 +69,22 @@ public void testConstruction_LedgerPrefix() {
 
   @Test(expected = IllegalArgumentException.class)
   public void test_empty_address() {
-    final String value = """";
-    try {
-      InterledgerAddress.builder().value(value).build();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage(), is(String.format(EXPECTED_ERROR_MESSAGE, value)));
-      throw e;
-    }
+    InterledgerAddress.builder().value("""").build();
   }
 
   @Test(expected = IllegalArgumentException.class)
   public void test_blank_address() {
-    final String value = ""  "";
-    try {
-      InterledgerAddress.builder().value(value).build();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage(), is(String.format(EXPECTED_ERROR_MESSAGE, value)));",,2018-03-01 19:13:43,https://api.github.com/repos/hyperledger/quilt/pulls/comments/171663391,https://github.com/hyperledger/quilt/pull/123#discussion_r171663391,pascalav
https://github.com/hyperledger/quilt/pull/105,https://github.com/hyperledger/quilt/pull/105,"I think I prefer `sendPacket` instead -- it's surprising to see a method called ""sendRequest"" and then see that I don't actually do anything with an object that refers to a ""request"" anywhere.",0f5440813e8a9eca32a03173b2836f1f1261dd7d,2018-02-14 16:07:01,168222777,"@@ -0,0 +1,182 @@
+package org.interledger.node.channels;
+
+import org.interledger.core.InterledgerFulfillPacket;
+import org.interledger.core.InterledgerPreparePacket;
+import org.interledger.core.InterledgerProtocolException;
+import org.interledger.node.events.ChannelClosedEvent;
+import org.interledger.node.events.ChannelErrorEvent;
+import org.interledger.node.events.ChannelOpenedEvent;
+import org.interledger.node.events.IncomingRequestEvent;
+import org.interledger.node.events.IncomingTransferEvent;
+import org.interledger.node.exceptions.ChannelNotOpenException;
+import org.interledger.node.handlers.ChannelClosedEventHandler;
+import org.interledger.node.handlers.ChannelErrorEventHandler;
+import org.interledger.node.handlers.ChannelOpenedEventHandler;
+import org.interledger.node.handlers.IncomingRequestHandler;
+import org.interledger.node.handlers.IncomingTransferEventHandler;
+
+import java.io.Closeable;
+import java.util.concurrent.Future;
+
+/**
+ * Defines an abstraction that is meant to be plugged-in to an ILP node system in order
+ * for it to communicate with a another node.
+ *
+ * <p>Based on IL-RFC-24, the general contract for a channels is that, for a single account, it can
+ * send ILP packets and transfers from to the destination node all of which impact the an account
+ * linked to this channel.
+ *
+ * <p>Additionally, channel plugins can also emit events received from the peer, such as incoming
+ * ILP packets or transfers.
+ *
+ * <p>An ILP node will have a unique instance of a channels for each account.
+ *
+ * <p>The following high-level component diagram illustrates how ledger plugins are used by a
+ * connector:
+ *
+ * @see ""https://interledger.org/rfcs/0024-ledger-plugin-interface-2/""
+ */
+public interface Channel extends Closeable {
+
+  /**
+   * Called to open the channel.
+   *
+   * <p>This should initiate event subscriptions and establish a connection to the peer.
+   *
+   * <p>Once this method is called, the channels MUST attempt to subscribe to and report events,
+   * including the ""open"" event immediately after a successful connection is established. If the
+   * connection is lost, the ledger channels SHOULD emit the ""closed"" event.
+   *
+   */
+  void open();
+
+  /**
+   * Called to disconnect this channel from the peer.
+   *
+   * @throws ChannelNotOpenException if the channels is not connected.
+   *
+   */
+  void close();
+
+  /**
+   * Query whether the channel is currently open.
+   *
+   * @return {@code true} if the channel is open, {@code false} otherwise.
+   */
+  boolean isOpen();
+
+  /**
+   * Initiate a transfer of money to the peer.
+   *
+   * <p>The ILP node will reduce the balance on the account linked to this channels if this call
+   * completes successfully.
+   *
+   * <p>Example: If this channels is used to make transfers over a payment channel then this should
+   * result in a new claim being sent over the channel.
+   *
+   * @param amount The amount to credit the account in favour of the sender.
+   *
+   * @throws ChannelNotOpenException if the channel is not open.
+   *
+   * @return a Future that resolves when the transfer has been sent.
+   */
+  Future<Void> sendTransfer(long amount);
+
+  /**
+   * Sends an ILP request packet to the peer and returns the response packet.
+   *
+   * @param request The request to send to the peer.
+   *
+   * @throws ChannelNotOpenException if the channels is not connected.
+   * @throws InterledgerProtocolException if the request is rejected by the peer.
+   *
+   * @return A Future that resolves to the ILP response from the peer.
+   */
+  Future<InterledgerFulfillPacket> sendRequest(InterledgerPreparePacket request);",95,2018-02-14 16:07:01,https://api.github.com/repos/hyperledger/quilt/pulls/comments/168222777,https://github.com/hyperledger/quilt/pull/105#discussion_r168222777,sappenin
https://github.com/hyperledger/quilt/pull/105,https://github.com/hyperledger/quilt/pull/105,"The naming of this and `sendRequest` are a little confusing/surprising to me, especially after having looked at the [LPI2](https://interledger.org/rfcs/0024-ledger-plugin-interface-2/) for so long.

This operation doesn't _quite_ feel like a transfer (I could be wrong there) -- though I don't really like `sendMoney` either. 

I don't have a good replacement name here, but am wondering what this method is actually doing? I mean, conceptually, ""sending money"" or even ""transferring money from one account to another"" makes sense to me (though I would like to be less currency-focused in ILP, so don't like the term `money`). But is this more like clearing or settlement? Or something else? I don't think we should use those terms either (clearing,settle, etc), but am instead trying to figure out -- in layman's terms -- what this operation _does_.

Is it just transferring value from one account to another, across a channel?

If yes, then `sendTransfer` seems a little more appropriate, until I see that I can send an ILP packet below and that's _also_ transferring value...",0f5440813e8a9eca32a03173b2836f1f1261dd7d,2018-02-14 16:08:56,168223595,"@@ -0,0 +1,182 @@
+package org.interledger.node.channels;
+
+import org.interledger.core.InterledgerFulfillPacket;
+import org.interledger.core.InterledgerPreparePacket;
+import org.interledger.core.InterledgerProtocolException;
+import org.interledger.node.events.ChannelClosedEvent;
+import org.interledger.node.events.ChannelErrorEvent;
+import org.interledger.node.events.ChannelOpenedEvent;
+import org.interledger.node.events.IncomingRequestEvent;
+import org.interledger.node.events.IncomingTransferEvent;
+import org.interledger.node.exceptions.ChannelNotOpenException;
+import org.interledger.node.handlers.ChannelClosedEventHandler;
+import org.interledger.node.handlers.ChannelErrorEventHandler;
+import org.interledger.node.handlers.ChannelOpenedEventHandler;
+import org.interledger.node.handlers.IncomingRequestHandler;
+import org.interledger.node.handlers.IncomingTransferEventHandler;
+
+import java.io.Closeable;
+import java.util.concurrent.Future;
+
+/**
+ * Defines an abstraction that is meant to be plugged-in to an ILP node system in order
+ * for it to communicate with a another node.
+ *
+ * <p>Based on IL-RFC-24, the general contract for a channels is that, for a single account, it can
+ * send ILP packets and transfers from to the destination node all of which impact the an account
+ * linked to this channel.
+ *
+ * <p>Additionally, channel plugins can also emit events received from the peer, such as incoming
+ * ILP packets or transfers.
+ *
+ * <p>An ILP node will have a unique instance of a channels for each account.
+ *
+ * <p>The following high-level component diagram illustrates how ledger plugins are used by a
+ * connector:
+ *
+ * @see ""https://interledger.org/rfcs/0024-ledger-plugin-interface-2/""
+ */
+public interface Channel extends Closeable {
+
+  /**
+   * Called to open the channel.
+   *
+   * <p>This should initiate event subscriptions and establish a connection to the peer.
+   *
+   * <p>Once this method is called, the channels MUST attempt to subscribe to and report events,
+   * including the ""open"" event immediately after a successful connection is established. If the
+   * connection is lost, the ledger channels SHOULD emit the ""closed"" event.
+   *
+   */
+  void open();
+
+  /**
+   * Called to disconnect this channel from the peer.
+   *
+   * @throws ChannelNotOpenException if the channels is not connected.
+   *
+   */
+  void close();
+
+  /**
+   * Query whether the channel is currently open.
+   *
+   * @return {@code true} if the channel is open, {@code false} otherwise.
+   */
+  boolean isOpen();
+
+  /**
+   * Initiate a transfer of money to the peer.
+   *
+   * <p>The ILP node will reduce the balance on the account linked to this channels if this call
+   * completes successfully.
+   *
+   * <p>Example: If this channels is used to make transfers over a payment channel then this should
+   * result in a new claim being sent over the channel.
+   *
+   * @param amount The amount to credit the account in favour of the sender.
+   *
+   * @throws ChannelNotOpenException if the channel is not open.
+   *
+   * @return a Future that resolves when the transfer has been sent.
+   */
+  Future<Void> sendTransfer(long amount);",83,2018-02-14 16:10:04,https://api.github.com/repos/hyperledger/quilt/pulls/comments/168223595,https://github.com/hyperledger/quilt/pull/105#discussion_r168223595,sappenin
https://github.com/hyperledger/quilt/pull/105,https://github.com/hyperledger/quilt/pull/105,"The node should call this when it has made an adjustment to the balances it is keeping for the account. So imagine the following flow:

  1. Node sends multiple ILP Prepare packets down the Channel to a total value of X.
  2. Balance on the Account for that Channel is now -X.
  3. Node wants to bring the balance back to 0 so it calls `sendTransfer(X)` and adjusts the balance to 0.

As discussed on the call I think we can model this better by separating these functions. I'm going to have an attempt at that today.",0f5440813e8a9eca32a03173b2836f1f1261dd7d,2018-02-15 08:55:41,168410355,"@@ -0,0 +1,182 @@
+package org.interledger.node.channels;
+
+import org.interledger.core.InterledgerFulfillPacket;
+import org.interledger.core.InterledgerPreparePacket;
+import org.interledger.core.InterledgerProtocolException;
+import org.interledger.node.events.ChannelClosedEvent;
+import org.interledger.node.events.ChannelErrorEvent;
+import org.interledger.node.events.ChannelOpenedEvent;
+import org.interledger.node.events.IncomingRequestEvent;
+import org.interledger.node.events.IncomingTransferEvent;
+import org.interledger.node.exceptions.ChannelNotOpenException;
+import org.interledger.node.handlers.ChannelClosedEventHandler;
+import org.interledger.node.handlers.ChannelErrorEventHandler;
+import org.interledger.node.handlers.ChannelOpenedEventHandler;
+import org.interledger.node.handlers.IncomingRequestHandler;
+import org.interledger.node.handlers.IncomingTransferEventHandler;
+
+import java.io.Closeable;
+import java.util.concurrent.Future;
+
+/**
+ * Defines an abstraction that is meant to be plugged-in to an ILP node system in order
+ * for it to communicate with a another node.
+ *
+ * <p>Based on IL-RFC-24, the general contract for a channels is that, for a single account, it can
+ * send ILP packets and transfers from to the destination node all of which impact the an account
+ * linked to this channel.
+ *
+ * <p>Additionally, channel plugins can also emit events received from the peer, such as incoming
+ * ILP packets or transfers.
+ *
+ * <p>An ILP node will have a unique instance of a channels for each account.
+ *
+ * <p>The following high-level component diagram illustrates how ledger plugins are used by a
+ * connector:
+ *
+ * @see ""https://interledger.org/rfcs/0024-ledger-plugin-interface-2/""
+ */
+public interface Channel extends Closeable {
+
+  /**
+   * Called to open the channel.
+   *
+   * <p>This should initiate event subscriptions and establish a connection to the peer.
+   *
+   * <p>Once this method is called, the channels MUST attempt to subscribe to and report events,
+   * including the ""open"" event immediately after a successful connection is established. If the
+   * connection is lost, the ledger channels SHOULD emit the ""closed"" event.
+   *
+   */
+  void open();
+
+  /**
+   * Called to disconnect this channel from the peer.
+   *
+   * @throws ChannelNotOpenException if the channels is not connected.
+   *
+   */
+  void close();
+
+  /**
+   * Query whether the channel is currently open.
+   *
+   * @return {@code true} if the channel is open, {@code false} otherwise.
+   */
+  boolean isOpen();
+
+  /**
+   * Initiate a transfer of money to the peer.
+   *
+   * <p>The ILP node will reduce the balance on the account linked to this channels if this call
+   * completes successfully.
+   *
+   * <p>Example: If this channels is used to make transfers over a payment channel then this should
+   * result in a new claim being sent over the channel.
+   *
+   * @param amount The amount to credit the account in favour of the sender.
+   *
+   * @throws ChannelNotOpenException if the channel is not open.
+   *
+   * @return a Future that resolves when the transfer has been sent.
+   */
+  Future<Void> sendTransfer(long amount);",83,2018-02-15 08:55:41,https://api.github.com/repos/hyperledger/quilt/pulls/comments/168410355,https://github.com/hyperledger/quilt/pull/105#discussion_r168410355,adrianhopebailie
https://github.com/hyperledger/quilt/pull/105,https://github.com/hyperledger/quilt/pull/105,"This is interesting because when I discussed this with @emschwartz we concluded that an ILP Prepare is a request and an ILP Fulfill is a response.

The LPIv2 model is to treat this as raw data and the plugins assume it can be serialized/deserialized into an ILP packet.

I have a thought to wrapping this in a Request/Response which for now might only have the ILP packet but in future might contain the raw request bytes to allow the nodes to have very fast in-place replacement of data rather than a deserialization and then serialization step.",0f5440813e8a9eca32a03173b2836f1f1261dd7d,2018-02-15 09:00:12,168411509,"@@ -0,0 +1,182 @@
+package org.interledger.node.channels;
+
+import org.interledger.core.InterledgerFulfillPacket;
+import org.interledger.core.InterledgerPreparePacket;
+import org.interledger.core.InterledgerProtocolException;
+import org.interledger.node.events.ChannelClosedEvent;
+import org.interledger.node.events.ChannelErrorEvent;
+import org.interledger.node.events.ChannelOpenedEvent;
+import org.interledger.node.events.IncomingRequestEvent;
+import org.interledger.node.events.IncomingTransferEvent;
+import org.interledger.node.exceptions.ChannelNotOpenException;
+import org.interledger.node.handlers.ChannelClosedEventHandler;
+import org.interledger.node.handlers.ChannelErrorEventHandler;
+import org.interledger.node.handlers.ChannelOpenedEventHandler;
+import org.interledger.node.handlers.IncomingRequestHandler;
+import org.interledger.node.handlers.IncomingTransferEventHandler;
+
+import java.io.Closeable;
+import java.util.concurrent.Future;
+
+/**
+ * Defines an abstraction that is meant to be plugged-in to an ILP node system in order
+ * for it to communicate with a another node.
+ *
+ * <p>Based on IL-RFC-24, the general contract for a channels is that, for a single account, it can
+ * send ILP packets and transfers from to the destination node all of which impact the an account
+ * linked to this channel.
+ *
+ * <p>Additionally, channel plugins can also emit events received from the peer, such as incoming
+ * ILP packets or transfers.
+ *
+ * <p>An ILP node will have a unique instance of a channels for each account.
+ *
+ * <p>The following high-level component diagram illustrates how ledger plugins are used by a
+ * connector:
+ *
+ * @see ""https://interledger.org/rfcs/0024-ledger-plugin-interface-2/""
+ */
+public interface Channel extends Closeable {
+
+  /**
+   * Called to open the channel.
+   *
+   * <p>This should initiate event subscriptions and establish a connection to the peer.
+   *
+   * <p>Once this method is called, the channels MUST attempt to subscribe to and report events,
+   * including the ""open"" event immediately after a successful connection is established. If the
+   * connection is lost, the ledger channels SHOULD emit the ""closed"" event.
+   *
+   */
+  void open();
+
+  /**
+   * Called to disconnect this channel from the peer.
+   *
+   * @throws ChannelNotOpenException if the channels is not connected.
+   *
+   */
+  void close();
+
+  /**
+   * Query whether the channel is currently open.
+   *
+   * @return {@code true} if the channel is open, {@code false} otherwise.
+   */
+  boolean isOpen();
+
+  /**
+   * Initiate a transfer of money to the peer.
+   *
+   * <p>The ILP node will reduce the balance on the account linked to this channels if this call
+   * completes successfully.
+   *
+   * <p>Example: If this channels is used to make transfers over a payment channel then this should
+   * result in a new claim being sent over the channel.
+   *
+   * @param amount The amount to credit the account in favour of the sender.
+   *
+   * @throws ChannelNotOpenException if the channel is not open.
+   *
+   * @return a Future that resolves when the transfer has been sent.
+   */
+  Future<Void> sendTransfer(long amount);
+
+  /**
+   * Sends an ILP request packet to the peer and returns the response packet.
+   *
+   * @param request The request to send to the peer.
+   *
+   * @throws ChannelNotOpenException if the channels is not connected.
+   * @throws InterledgerProtocolException if the request is rejected by the peer.
+   *
+   * @return A Future that resolves to the ILP response from the peer.
+   */
+  Future<InterledgerFulfillPacket> sendRequest(InterledgerPreparePacket request);",95,2018-02-15 09:00:12,https://api.github.com/repos/hyperledger/quilt/pulls/comments/168411509,https://github.com/hyperledger/quilt/pull/105#discussion_r168411509,adrianhopebailie
https://github.com/hyperledger/quilt/pull/105,https://github.com/hyperledger/quilt/pull/105,Makes sense - this is fine for now - maybe in future have two methods - one that takes the packet (like you have now) and one takes a request with bytes?,0f5440813e8a9eca32a03173b2836f1f1261dd7d,2018-02-17 19:23:22,168930494,"@@ -0,0 +1,182 @@
+package org.interledger.node.channels;
+
+import org.interledger.core.InterledgerFulfillPacket;
+import org.interledger.core.InterledgerPreparePacket;
+import org.interledger.core.InterledgerProtocolException;
+import org.interledger.node.events.ChannelClosedEvent;
+import org.interledger.node.events.ChannelErrorEvent;
+import org.interledger.node.events.ChannelOpenedEvent;
+import org.interledger.node.events.IncomingRequestEvent;
+import org.interledger.node.events.IncomingTransferEvent;
+import org.interledger.node.exceptions.ChannelNotOpenException;
+import org.interledger.node.handlers.ChannelClosedEventHandler;
+import org.interledger.node.handlers.ChannelErrorEventHandler;
+import org.interledger.node.handlers.ChannelOpenedEventHandler;
+import org.interledger.node.handlers.IncomingRequestHandler;
+import org.interledger.node.handlers.IncomingTransferEventHandler;
+
+import java.io.Closeable;
+import java.util.concurrent.Future;
+
+/**
+ * Defines an abstraction that is meant to be plugged-in to an ILP node system in order
+ * for it to communicate with a another node.
+ *
+ * <p>Based on IL-RFC-24, the general contract for a channels is that, for a single account, it can
+ * send ILP packets and transfers from to the destination node all of which impact the an account
+ * linked to this channel.
+ *
+ * <p>Additionally, channel plugins can also emit events received from the peer, such as incoming
+ * ILP packets or transfers.
+ *
+ * <p>An ILP node will have a unique instance of a channels for each account.
+ *
+ * <p>The following high-level component diagram illustrates how ledger plugins are used by a
+ * connector:
+ *
+ * @see ""https://interledger.org/rfcs/0024-ledger-plugin-interface-2/""
+ */
+public interface Channel extends Closeable {
+
+  /**
+   * Called to open the channel.
+   *
+   * <p>This should initiate event subscriptions and establish a connection to the peer.
+   *
+   * <p>Once this method is called, the channels MUST attempt to subscribe to and report events,
+   * including the ""open"" event immediately after a successful connection is established. If the
+   * connection is lost, the ledger channels SHOULD emit the ""closed"" event.
+   *
+   */
+  void open();
+
+  /**
+   * Called to disconnect this channel from the peer.
+   *
+   * @throws ChannelNotOpenException if the channels is not connected.
+   *
+   */
+  void close();
+
+  /**
+   * Query whether the channel is currently open.
+   *
+   * @return {@code true} if the channel is open, {@code false} otherwise.
+   */
+  boolean isOpen();
+
+  /**
+   * Initiate a transfer of money to the peer.
+   *
+   * <p>The ILP node will reduce the balance on the account linked to this channels if this call
+   * completes successfully.
+   *
+   * <p>Example: If this channels is used to make transfers over a payment channel then this should
+   * result in a new claim being sent over the channel.
+   *
+   * @param amount The amount to credit the account in favour of the sender.
+   *
+   * @throws ChannelNotOpenException if the channel is not open.
+   *
+   * @return a Future that resolves when the transfer has been sent.
+   */
+  Future<Void> sendTransfer(long amount);
+
+  /**
+   * Sends an ILP request packet to the peer and returns the response packet.
+   *
+   * @param request The request to send to the peer.
+   *
+   * @throws ChannelNotOpenException if the channels is not connected.
+   * @throws InterledgerProtocolException if the request is rejected by the peer.
+   *
+   * @return A Future that resolves to the ILP response from the peer.
+   */
+  Future<InterledgerFulfillPacket> sendRequest(InterledgerPreparePacket request);",95,2018-02-17 19:23:22,https://api.github.com/repos/hyperledger/quilt/pulls/comments/168930494,https://github.com/hyperledger/quilt/pull/105#discussion_r168930494,sappenin
https://github.com/hyperledger/quilt/pull/103,https://github.com/hyperledger/quilt/pull/103,"Sounds fine to me, but while we're at it, we should probably expand our ignores.

For example, here's the [Checkstyle project's .gitignore](https://github.com/checkstyle/checkstyle/blob/master/.gitignore), which maybe we should just emulate because it has more ignores that would be useful, IMHO. ",ea1c28122392ab1e5bd7a620861b102c5e8bdfdd,2018-02-08 16:56:24,166999789,"@@ -105,6 +105,12 @@ cmake-build-debug/
 # IntelliJ
 out/
 
+# eclipse",,2018-02-12 11:10:26,https://api.github.com/repos/hyperledger/quilt/pulls/comments/166999789,https://github.com/hyperledger/quilt/pull/103#discussion_r166999789,sappenin
https://github.com/hyperledger/quilt/pull/103,https://github.com/hyperledger/quilt/pull/103,"I added modifications you pointed out @sappenin.

Sideways, it seems the current ignores-list for eclipse was sourced from https://github.com/github/gitignore/blob/master/Global/Eclipse.gitignore . So I appended a few missing bits to that template.",ea1c28122392ab1e5bd7a620861b102c5e8bdfdd,2018-02-08 21:23:41,167071764,"@@ -105,6 +105,12 @@ cmake-build-debug/
 # IntelliJ
 out/
 
+# eclipse",,2018-02-12 11:10:26,https://api.github.com/repos/hyperledger/quilt/pulls/comments/167071764,https://github.com/hyperledger/quilt/pull/103#discussion_r167071764,pascalav
https://github.com/hyperledger/quilt/pull/103,https://github.com/hyperledger/quilt/pull/103,"If of any interest, here are the eclipse non-ignored files I spotted before the PR:
`.project`
`codec-framework/.checkstyle`
`codec-framework/.classpath`
`codec-framework/.project`
`connector-examples/.project`
`crypto-conditions/.checkstyle`
`crypto-conditions/.classpath`
`crypto-conditions/.project`
`dev-ops/.classpath`
`dev-ops/.project`
`ilp-annotations/.checkstyle`
`ilp-annotations/.classpath`
`ilp-annotations/.project`
`ilp-core/.checkstyle`
`ilp-core/.classpath`
`ilp-core/.project`
`ilp-core-codecs/.checkstyle`
`ilp-core-codecs/.classpath`
`ilp-core-codecs/.project`
`jackson-datatypes/.project`
`jackson-datatypes/jackson-datatype-cryptoconditions/.checkstyle`
`jackson-datatypes/jackson-datatype-cryptoconditions/.classpath`
`jackson-datatypes/jackson-datatype-cryptoconditions/.project`
`jackson-datatypes/jackson-datatype-interledger-address/.checkstyle`
`jackson-datatypes/jackson-datatype-interledger-address/.classpath`
`jackson-datatypes/jackson-datatype-interledger-address/.project`
`jackson-datatypes/jackson-datatype-interledger/.checkstyle`
`jackson-datatypes/jackson-datatype-interledger/.classpath`
`jackson-datatypes/jackson-datatype-interledger/.project`",ea1c28122392ab1e5bd7a620861b102c5e8bdfdd,2018-02-08 21:30:35,167073542,"@@ -178,6 +172,16 @@ local.properties
 .scala_dependencies
 .worksheet
 
+# Project files
+**/.classpath
+**/.project
+
+# m2e-code-quality for Eclipse CS Checkstyle / PMD / FindBugs Plug-Ins
+**/.checkstyle
+**/.pmd
+**/.pmdruleset.xml
+**/.fbExcludeFilterFile
+
 ### Kotlin template
 # Compiled class file
 ",16,2018-02-12 11:10:26,https://api.github.com/repos/hyperledger/quilt/pulls/comments/167073542,https://github.com/hyperledger/quilt/pull/103#discussion_r167073542,pascalav
https://github.com/hyperledger/quilt/pull/102,https://github.com/hyperledger/quilt/pull/102,"Minor nit, but let's spell out the constant names so they're clearer...

```
String ADDRESS_PREFIX_REGEX = ...
Pattern ADDRESS_PREFIX_PATTERN = ...

String DESTINATION_ADDRESS_REGEX = ...
Pattern DESTINATION_ADDRESS_PATTERN = ...
```",6ea83a2e77ba7078224e002d54adab939c0dfe68,2018-02-08 02:04:40,166814897,"@@ -34,10 +34,13 @@
  */
 public interface InterledgerAddress {
 
-  String REGEX = ""(?=^.{1,1023}$)""
-      + ""^(g|private|example|peer|self|test[1-3])[.]([a-zA-Z0-9_~-]+[.])*([a-zA-Z0-9_~-]+)?$"";
+  String ADDRPRFX_REGEX = ""(?=^.{1,1023}$)""",6,2018-02-08 16:48:26,https://api.github.com/repos/hyperledger/quilt/pulls/comments/166814897,https://github.com/hyperledger/quilt/pull/102#discussion_r166814897,sappenin
https://github.com/hyperledger/quilt/pull/99,https://github.com/hyperledger/quilt/pull/99,"As discussed in #89 I think we should revert this.

If an external application needs the Base64 (not Bse64Url) encoded form it should convert between them",4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-06 23:33:26,166477298,"@@ -24,7 +24,7 @@
    */
   static PreimageSha256Fulfillment from(final byte[] preimage) {
     Objects.requireNonNull(preimage);
-    final String encodedPreimage = Base64.getUrlEncoder().encodeToString(preimage);
+    final String encodedPreimage = Base64.getEncoder().encodeToString(preimage);
 ",6,2018-02-06 23:33:26,https://api.github.com/repos/hyperledger/quilt/pulls/comments/166477298,https://github.com/hyperledger/quilt/pull/99#discussion_r166477298,adrianhopebailie
https://github.com/hyperledger/quilt/pull/99,https://github.com/hyperledger/quilt/pull/99,We can revert this too as it's addressed in #90 ,4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-06 23:33:47,166477361,"@@ -35,7 +35,7 @@
 public interface InterledgerAddress {
 
   String REGEX = ""(?=^.{1,1023}$)""
-      + ""^(g|private|example|peer|self|test[1-3])[.]([a-zA-Z0-9_~-]+[.])*([a-zA-Z0-9_~-]+)?$"";
+      + ""^(g|private|example|peer|self|test([1-3])?)[.]([a-zA-Z0-9_~-]+[.])*([a-zA-Z0-9_~-]+)?$"";
 ",6,2018-02-06 23:33:47,https://api.github.com/repos/hyperledger/quilt/pulls/comments/166477361,https://github.com/hyperledger/quilt/pull/99#discussion_r166477361,adrianhopebailie
https://github.com/hyperledger/quilt/pull/99,https://github.com/hyperledger/quilt/pull/99,As discussed in #89 I think this should include the value of `this.getMessage()`,4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-06 23:34:38,166477518,"@@ -27,4 +27,10 @@ public InterledgerProtocolException(final InterledgerRejectPacket interledgerRej
   public InterledgerRejectPacket getInterledgerRejectPacket() {
     return interledgerRejectPacket;
   }
+
+  @Override
+  public String toString(){
+      return interledgerRejectPacket.toString();
+  }
+
 }",10,2018-02-06 23:34:39,https://api.github.com/repos/hyperledger/quilt/pulls/comments/166477518,https://github.com/hyperledger/quilt/pull/99#discussion_r166477518,adrianhopebailie
https://github.com/hyperledger/quilt/pull/99,https://github.com/hyperledger/quilt/pull/99,Agree. Let's revert for now and discuss in #100.,4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-07 16:53:31,166681983,"@@ -24,7 +24,7 @@
    */
   static PreimageSha256Fulfillment from(final byte[] preimage) {
     Objects.requireNonNull(preimage);
-    final String encodedPreimage = Base64.getUrlEncoder().encodeToString(preimage);
+    final String encodedPreimage = Base64.getEncoder().encodeToString(preimage);
 ",6,2018-02-07 16:53:31,https://api.github.com/repos/hyperledger/quilt/pulls/comments/166681983,https://github.com/hyperledger/quilt/pull/99#discussion_r166681983,sappenin
https://github.com/hyperledger/quilt/pull/90,https://github.com/hyperledger/quilt/pull/90,"Constantly changing SNAPSHOT version can just cause trouble.

Some code can inadvertently work for long time with a old 0.x.x-SNAPSHOT just because we forgot to update the dependency and the outdate artifact was still available in a remote repository. Then suddenly everything fails when changing the dependency version or the old artifact dissapears from the repo :(

I think it's just simpler (and less buggy) to just default to `1.0.0-SNAPSHOT`. -SNAPSHOT suffix is designed to reflect the intention to release a future (1.0.0) version. This way all software depending on the snapshot will stop compiling when a new 1.0.0-SNAPSHOT is published if there are API breaks (and that's what, most probably, everybody wants to get notified as soon as possible of the problem). Changing the minor version just indicates the intention to release a future stable 0.9... version, then a future stable 0.10.... version, and so on. But I do not think this is the intention right now. Since those version will be automatically deprecated by any new -SNAPSHOT release.

The common ""acepted-by-most-developpers"" way of working is similar to:
  - During development of a new version, feature enhacement or bug fix point to  `MajorVersion.MinorVersion.IncrementalVersion-SNAPSHOT` future realease.
  - At release time remove -SNAPSHOT. (future to present)
  - For bug-fix after release (non SNAPHOT that can be used by production enviroments)  point to `MajorVersion.MinorVersion.++IncrementalVersion-SNAPSHOT`
  - During feature enhancement point to release version `version.++MinorVersion.0 (-SNAPSHOT)`
  - For breaking API point to `++MajorVersion.0.0-SNAPSHOT`

[This blog](https://www.dontpanicblog.co.uk/2011/12/13/maven-release-plugin/)  contains some more info about how maven-release-plugin expect versions to be handled.",178642b4780f25fff10c8adf1533e8c26e41860d,2018-02-05 10:39:41,165934950,"@@ -10,7 +10,7 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>org.interledger</groupId>
     <artifactId>ilp-core</artifactId>
-    <version>0.9.2-SNAPSHOT</version>",,2018-02-17 18:24:44,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165934950,https://github.com/hyperledger/quilt/pull/90#discussion_r165934950,earizon
https://github.com/hyperledger/quilt/pull/90,https://github.com/hyperledger/quilt/pull/90,"@earizon the process you propose is how I see things working once we have a `1.0.x` release. 

For now, we should either have _real_ dot-releases, or else keep the current system of just incrementing the SNAPSHOT builds. If we have consensus around creating dot-releases (non-SNAPSHOTs) then I don't mind doing that.

But currently, we're not releasing pre-1.0 _release_ artifacts (only SNAPSHOTS), so the reason we _MUST_ increment the SNAPSHOT versions is because we expressly _do not_ want to force any developer using a SNAPSHOT to update code. We want to give developers the choice -- either keep using the outdated SNAPSHOT, or update to a newer SNAPSHOT.

To your point about missing SNAPSHOTs, have you encountered this issue with Quilt artifacts?
 I'm only publishing these once to Sonatype, so there should never be a time (using the current system) that code stops working due to a misssing or changed SNAPSHOT. If that's not the case, we should figure out why.

I guess we need to take a quick vote before we push or adjust this PR:

- [x] Keep the current system (update SNAPSHOT every time we make a change).
- [x] Create an actual pre-1.0 release everytime we change something (e.g., `0.9.2`, `0.10.0`, etc).
- [ ] Just use `1.0.0-SNAPSHOT` and break anyone using older SNAPSHOT code.

I vote to keep the current system. @adrianhopebailie @earizon or anyone else? ",178642b4780f25fff10c8adf1533e8c26e41860d,2018-02-05 17:00:04,166038223,"@@ -10,7 +10,7 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>org.interledger</groupId>
     <artifactId>ilp-core</artifactId>
-    <version>0.9.2-SNAPSHOT</version>",,2018-02-17 18:24:44,https://api.github.com/repos/hyperledger/quilt/pulls/comments/166038223,https://github.com/hyperledger/quilt/pull/90#discussion_r166038223,sappenin
https://github.com/hyperledger/quilt/pull/90,https://github.com/hyperledger/quilt/pull/90,"@sappenin ""We want to give developers the choice -- either keep using the outdated SNAPSHOT, or update to a newer SNAPSHOT""
Why giving the choice to do the non-standard thing? Git tags are much better suited for that. If a developer just wants to use an outdated image (in my experience that's not a good idea most of the times) all he has to do is to ""git checkout"" to the given tag and install  locally (dev-ops/util/quick_local_install_mvn_package.sh allows to compile in a couple of seconds bypassing tests, format,...). That also can be used when working with local branches.

""have you encountered this issue with Quilt artifacts?""
At this moment any project dependent of Quilt  will need to constantly check what's in the quilt pom and then update its pom dependencies just to be able to use the latest published artifact. Using a constant 1.0.0-SNAPSHOT fix de problem. An -alpha- | -beta- | -pre- is commonly used to warn that maybe 1.0.0-alpha-SNAPSHOT is far away from stable.",178642b4780f25fff10c8adf1533e8c26e41860d,2018-02-06 09:41:15,166234651,"@@ -10,7 +10,7 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>org.interledger</groupId>
     <artifactId>ilp-core</artifactId>
-    <version>0.9.2-SNAPSHOT</version>",,2018-02-17 18:24:44,https://api.github.com/repos/hyperledger/quilt/pulls/comments/166234651,https://github.com/hyperledger/quilt/pull/90#discussion_r166234651,earizon
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,👍 - depends on https://github.com/interledger/rfcs/pull/376,4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-01 17:00:03,165420902,"@@ -35,7 +35,7 @@
 public interface InterledgerAddress {
 
   String REGEX = ""(?=^.{1,1023}$)""
-      + ""^(g|private|example|peer|self|test[1-3])[.]([a-zA-Z0-9_~-]+[.])*([a-zA-Z0-9_~-]+)?$"";
+      + ""^(g|private|example|peer|self|test([1-3])?)[.]([a-zA-Z0-9_~-]+[.])*([a-zA-Z0-9_~-]+)?$"";
 ",12,2018-02-06 23:28:49,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165420902,https://github.com/hyperledger/quilt/pull/89#discussion_r165420902,adrianhopebailie
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,"We should decide if we are using Base64Url or Base64 and be consistent.

Personally I agree with @earizon that we should use Base64 as it is the most common.",4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-01 17:00:50,165421147,"@@ -24,7 +24,7 @@
    */
   static PreimageSha256Fulfillment from(final byte[] preimage) {
     Objects.requireNonNull(preimage);
-    final String encodedPreimage = Base64.getUrlEncoder().encodeToString(preimage);
+    final String encodedPreimage = Base64.getEncoder().encodeToString(preimage);
 ",6,2018-02-06 23:28:49,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165421147,https://github.com/hyperledger/quilt/pull/89#discussion_r165421147,adrianhopebailie
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,Should also print the result of `getMessage()`?,4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-01 17:02:20,165421587,"@@ -27,4 +27,10 @@ public InterledgerProtocolException(final InterledgerRejectPacket interledgerRej
   public InterledgerRejectPacket getInterledgerRejectPacket() {
     return interledgerRejectPacket;
   }
+
+  @Override
+  public String toString(){
+      return interledgerRejectPacket.toString();
+  }",34,2018-02-06 23:28:49,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165421587,https://github.com/hyperledger/quilt/pull/89#discussion_r165421587,adrianhopebailie
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,Rather use: https://interledger.org/rfcs/asn1/InterledgerProtocol.asn.html,4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-01 17:03:46,165422031,"@@ -4,6 +4,10 @@
 
 import java.util.Arrays;
 
+/**
+ * <p>REF: https://github.com/interledger/rfcs/blob/master/asn1/InterledgerProtocol.asn</p>
+ */",,2018-02-06 23:28:49,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165422031,https://github.com/hyperledger/quilt/pull/89#discussion_r165422031,adrianhopebailie
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,"This change isn't enough to make this work -- we would also need to change the `PREFIX_REGEX`. I made this change (and added unit tests) in a new PR #90. 

I suggest we remove this change from this PR, and use #90 instead.",4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-02 05:01:07,165558845,"@@ -35,7 +35,7 @@
 public interface InterledgerAddress {
 
   String REGEX = ""(?=^.{1,1023}$)""
-      + ""^(g|private|example|peer|self|test[1-3])[.]([a-zA-Z0-9_~-]+[.])*([a-zA-Z0-9_~-]+)?$"";
+      + ""^(g|private|example|peer|self|test([1-3])?)[.]([a-zA-Z0-9_~-]+[.])*([a-zA-Z0-9_~-]+)?$"";
 ",12,2018-02-06 23:28:49,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165558845,https://github.com/hyperledger/quilt/pull/89#discussion_r165558845,sappenin
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,"@earizon did something happen in your test code to prompt this change? I guess I'm not intrinsically opposed to the change (using Base64), although in my mind it feels like defaulting to Base64Url is better for anyone who might want to put a String into a URL -- so I find myself always defaulting to that instead.

That said, I'm not aware of any use-cases where somebody would want to put the encoded preimage from a Fulfillment into a URL, so in this case, it's probably a non-issue, and moving to Base64 isn't actually a problem. I suppose I'm more interested in what prompted the change.

In any event, this change isn't sufficient because we would need to change the encoding in other places in the project (e.g., see [CryptoConditionWriter#writeTypedFulfillment](https://github.com/hyperledger/quilt/blob/master/crypto-conditions/src/main/java/org/interledger/cryptoconditions/CryptoConditionWriter.java#L159)).

I suggest we pull this change out of this PR, and address it in a different PR because it seems like a bigger change that we would want to vet on its own.",4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-02 05:18:59,165560342,"@@ -24,7 +24,7 @@
    */
   static PreimageSha256Fulfillment from(final byte[] preimage) {
     Objects.requireNonNull(preimage);
-    final String encodedPreimage = Base64.getUrlEncoder().encodeToString(preimage);
+    final String encodedPreimage = Base64.getEncoder().encodeToString(preimage);
 ",6,2018-02-06 23:28:49,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165560342,https://github.com/hyperledger/quilt/pull/89#discussion_r165560342,sappenin
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,"@adrianhopebailie , @sappenin Actually it was a request from @michielbdejong to make it compatible with testnet-of-testnets and ilp-over-http.
",4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-02 11:53:38,165626279,"@@ -24,7 +24,7 @@
    */
   static PreimageSha256Fulfillment from(final byte[] preimage) {
     Objects.requireNonNull(preimage);
-    final String encodedPreimage = Base64.getUrlEncoder().encodeToString(preimage);
+    final String encodedPreimage = Base64.getEncoder().encodeToString(preimage);
 ",6,2018-02-06 23:28:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165626279,https://github.com/hyperledger/quilt/pull/89#discussion_r165626279,earizon
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,"@adrianhopebailie This comes for free in InterledgerRejectPacket::toString defined as:

          return ""InterledgerRejectPacket{""
          + ""  code="" + getCode()
          + "",  triggeredBy="" + getTriggeredBy()
          + "",  message="" + getMessage()
          + "",  data="" + Arrays.toString(getData())
          + '}';",4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-05 10:03:42,165926223,"@@ -27,4 +27,10 @@ public InterledgerProtocolException(final InterledgerRejectPacket interledgerRej
   public InterledgerRejectPacket getInterledgerRejectPacket() {
     return interledgerRejectPacket;
   }
+
+  @Override
+  public String toString(){
+      return interledgerRejectPacket.toString();
+  }",34,2018-02-06 23:28:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165926223,https://github.com/hyperledger/quilt/pull/89#discussion_r165926223,earizon
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,"@sappenin  I agree. #90 fixes it properly. 

I don't think I can remove from the PR (or can I?) but it will be immediate to fix during merge-conflict-resolution.",4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-05 10:08:39,165927457,"@@ -35,7 +35,7 @@
 public interface InterledgerAddress {
 
   String REGEX = ""(?=^.{1,1023}$)""
-      + ""^(g|private|example|peer|self|test[1-3])[.]([a-zA-Z0-9_~-]+[.])*([a-zA-Z0-9_~-]+)?$"";
+      + ""^(g|private|example|peer|self|test([1-3])?)[.]([a-zA-Z0-9_~-]+[.])*([a-zA-Z0-9_~-]+)?$"";
 ",12,2018-02-06 23:28:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165927457,https://github.com/hyperledger/quilt/pull/89#discussion_r165927457,earizon
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,"Ah, cool. @michielbdejong Can you comment here? 

The property in question is just the encoded-preimage of a `PreimageSha256Fulfillment` --
 it's not the OER bytes of the PreimageSha256Fulfillment. Instead, it's literally just a helper-method to access the bytes of the preimage (not the bytes of the Fulfillment itself).

So, I'm surprised that anybody is doing anything with this particular field (enough to care about this encoding). Any thoughts?",4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-05 17:12:10,166041916,"@@ -24,7 +24,7 @@
    */
   static PreimageSha256Fulfillment from(final byte[] preimage) {
     Objects.requireNonNull(preimage);
-    final String encodedPreimage = Base64.getUrlEncoder().encodeToString(preimage);
+    final String encodedPreimage = Base64.getEncoder().encodeToString(preimage);
 ",6,2018-02-06 23:28:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/166041916,https://github.com/hyperledger/quilt/pull/89#discussion_r166041916,sappenin
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,"Also, I've created https://github.com/hyperledger/quilt/issues/92 to correct the Javadoc of this method.",4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-05 17:15:39,166043255,"@@ -24,7 +24,7 @@
    */
   static PreimageSha256Fulfillment from(final byte[] preimage) {
     Objects.requireNonNull(preimage);
-    final String encodedPreimage = Base64.getUrlEncoder().encodeToString(preimage);
+    final String encodedPreimage = Base64.getEncoder().encodeToString(preimage);
 ",6,2018-02-06 23:28:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/166043255,https://github.com/hyperledger/quilt/pull/89#discussion_r166043255,sappenin
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,"Either way is fine - I think you can just remove this change in your branch, and then push another commit (which will just restore this class to its previous state). 

We probably want to do this for the crypto-condition change above as well since these two things have quite a bit of discussion, and are artificially blocking your other changes.",4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-05 17:17:25,166044325,"@@ -35,7 +35,7 @@
 public interface InterledgerAddress {
 
   String REGEX = ""(?=^.{1,1023}$)""
-      + ""^(g|private|example|peer|self|test[1-3])[.]([a-zA-Z0-9_~-]+[.])*([a-zA-Z0-9_~-]+)?$"";
+      + ""^(g|private|example|peer|self|test([1-3])?)[.]([a-zA-Z0-9_~-]+[.])*([a-zA-Z0-9_~-]+)?$"";
 ",12,2018-02-06 23:28:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/166044325,https://github.com/hyperledger/quilt/pull/89#discussion_r166044325,sappenin
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,"@sappenin What's the difference between the bytes of the preimage and the bytes of the Fulfillment?

I'm using it to return the [ilp-over-http](https://github.com/interledger/rfcs/blob/ilp-over-http/0000-ilp-over-http.md) `ILP-Fulfillment` header.",4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-06 09:26:37,166230697,"@@ -24,7 +24,7 @@
    */
   static PreimageSha256Fulfillment from(final byte[] preimage) {
     Objects.requireNonNull(preimage);
-    final String encodedPreimage = Base64.getUrlEncoder().encodeToString(preimage);
+    final String encodedPreimage = Base64.getEncoder().encodeToString(preimage);
 ",6,2018-02-06 23:28:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/166230697,https://github.com/hyperledger/quilt/pull/89#discussion_r166230697,earizon
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,"We should separate the needs of a specific application or protocol (like `ilp-over-http`) from the design of this library which could be a dependency in a variety of projects.

The method name `getEncodedPreimage` doesn't provide any hints as to whether it's Base64 or Base64Url but the Javadoc does say Base64Url so perhaps we should leave it as is.

Remember that the motivation for this was to return a String and not a `byte[]` to avoid mutability issues. What we are really returning is 32-bytes of data but in a form that's immutable so the encoding is not important as long as it's consistent and not surprising to a user.",4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-06 16:24:20,166358479,"@@ -24,7 +24,7 @@
    */
   static PreimageSha256Fulfillment from(final byte[] preimage) {
     Objects.requireNonNull(preimage);
-    final String encodedPreimage = Base64.getUrlEncoder().encodeToString(preimage);
+    final String encodedPreimage = Base64.getEncoder().encodeToString(preimage);
 ",6,2018-02-06 23:28:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/166358479,https://github.com/hyperledger/quilt/pull/89#discussion_r166358479,adrianhopebailie
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,I mean `InterledgerProtocolException::getMessage()` not `InterledgerProtocolException::getInterledgerRejectPacket()::getMessage()`,4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-06 16:26:48,166359332,"@@ -27,4 +27,10 @@ public InterledgerProtocolException(final InterledgerRejectPacket interledgerRej
   public InterledgerRejectPacket getInterledgerRejectPacket() {
     return interledgerRejectPacket;
   }
+
+  @Override
+  public String toString(){
+      return interledgerRejectPacket.toString();
+  }",34,2018-02-06 23:28:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/166359332,https://github.com/hyperledger/quilt/pull/89#discussion_r166359332,adrianhopebailie
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,"@earizon One set of array of bytes is the bytes of the preimage, and the other array of bytes is the bytes of the whole Fulfillment. For example: 

* **Bytes of the preimage**: ""secret preimage"".getBytes()
* **Bytes of the Fulfillment**: CryptoConditionWriter.write(fulfillment);

The first one is the literal bytes of whatever is the preimage. The second one is the OER-encoded bytes of the entire fulfillment, encoded as whatever you wish (probably in the test-net, this would be: a bunch of DER bytes, encoded in Base64).

I think that's where we're missing each other. Checkout the actual bytes that get written when you write an entire fulfillment in [CryptoConditionWriter.java](https://github.com/hyperledger/quilt/blob/master/crypto-conditions/src/main/java/org/interledger/cryptoconditions/CryptoConditionWriter.java#L85).

In the [ilp-over-http](https://github.com/interledger/rfcs/blob/ilp-over-http/0000-ilp-over-http.md) I think you want to return the bytes of the entire fulfillment, like this:

```
byte[] fulfillmentBytes = CryptoConditionWriter.write(fulfillment);
return Base64.getEncoder().getEncode(fulfillmentBytes);
```",4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-06 21:27:36,166447465,"@@ -24,7 +24,7 @@
    */
   static PreimageSha256Fulfillment from(final byte[] preimage) {
     Objects.requireNonNull(preimage);
-    final String encodedPreimage = Base64.getUrlEncoder().encodeToString(preimage);
+    final String encodedPreimage = Base64.getEncoder().encodeToString(preimage);
 ",6,2018-02-06 23:28:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/166447465,https://github.com/hyperledger/quilt/pull/89#discussion_r166447465,sappenin
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,"> The method name getEncodedPreimage doesn't provide any hints as to whether it's Base64 or Base64Url but the Javadoc does say Base64Url so perhaps we should leave it as is.

See #92 and #100 for tracking this one - I'm open to method-name-change suggestions. At the least, we need to cleanup the Javadoc for that method, and probably mention that it's purpose is strictly for immutability, not encoding the entire fulfillment.",4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-06 21:29:00,166447815,"@@ -24,7 +24,7 @@
    */
   static PreimageSha256Fulfillment from(final byte[] preimage) {
     Objects.requireNonNull(preimage);
-    final String encodedPreimage = Base64.getUrlEncoder().encodeToString(preimage);
+    final String encodedPreimage = Base64.getEncoder().encodeToString(preimage);
 ",6,2018-02-07 16:57:11,https://api.github.com/repos/hyperledger/quilt/pulls/comments/166447815,https://github.com/hyperledger/quilt/pull/89#discussion_r166447815,sappenin
https://github.com/hyperledger/quilt/pull/89,https://github.com/hyperledger/quilt/pull/89,"@earizon Oops, my comment above about the difference in encoding (and the encoding you should be using) is _not_ correct for your use-case. 

While my comment is correct from the perspective of the crypto-conditions RFC, [ilp-over-http](https://github.com/interledger/rfcs/blob/ilp-over-http/0000-ilp-over-http.md#request) encodes conditions/fulfillments using a different encoding, which I forgot about.

(My apologies for that oversight).

So, all that to say...you can ignore my comment above where I outline the difference between preimage and fulfillment bytes....in your case, I think you'd want to do one of the following:

```java
PreimageSha256Fulfillment fulfillment = ...;
byte[] preimageBytes = Base64.getUrlDecoder().decode(fulfillment.getEncodedPreimage());
String base64Preimage = Base64.getEncoder().encodeToString(preimageBytes);
```

It's ugly, I know - but let's continue discussing a change to the `crypto-conditions` project in #100.",4e1df2bdbfa03597139f5cb5e2f5a42174555835,2018-02-07 16:52:57,166681803,"@@ -24,7 +24,7 @@
    */
   static PreimageSha256Fulfillment from(final byte[] preimage) {
     Objects.requireNonNull(preimage);
-    final String encodedPreimage = Base64.getUrlEncoder().encodeToString(preimage);
+    final String encodedPreimage = Base64.getEncoder().encodeToString(preimage);
 ",6,2018-02-07 16:52:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/166681803,https://github.com/hyperledger/quilt/pull/89#discussion_r166681803,sappenin
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,"Not a blocker, but we should decide if we're using 2 spaces or 4 spaces for tabs in XML and Java. Some of the poms do it one way, and some of the poms do it the other way. I don't have a strong opinion, other than consistency.",5fe87a02cf039f3cc2197477cd7f14127a476128,2018-01-28 16:13:36,164303772,"@@ -0,0 +1,57 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <parent>
+        <artifactId>quilt-parent</artifactId>
+        <groupId>org.interledger</groupId>
+        <version>0.1.0-SNAPSHOT</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <name>Hyperledger Quilt Codec Framework</name>
+    <description>A framework for writing codecContext.</description>
+
+    <artifactId>codec-framework</artifactId>",,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/164303772,https://github.com/hyperledger/quilt/pull/85#discussion_r164303772,sappenin
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,This import is unused.,5fe87a02cf039f3cc2197477cd7f14127a476128,2018-01-28 16:17:01,164303843,"@@ -0,0 +1,38 @@
+package org.interledger.encoding.asn.framework;
+
+import org.interledger.encoding.asn.codecs.AsnObjectCodecBase;",3,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/164303843,https://github.com/hyperledger/quilt/pull/85#discussion_r164303843,sappenin
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,This import is unused.,5fe87a02cf039f3cc2197477cd7f14127a476128,2018-01-28 16:17:43,164303863,"@@ -0,0 +1,179 @@
+package org.interledger.encoding.asn.framework;
+
+import org.interledger.encoding.asn.codecs.AsnObjectCodecBase;",3,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/164303863,https://github.com/hyperledger/quilt/pull/85#discussion_r164303863,sappenin
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,"Question: Are all of the codecs in this package usable in both DER and OER? I was under the impression that DER would encode Strings and numbers differently from OER. If that's true, we should maybe move these codecs to an OER package? If the above is untrue, then this package-naming makes sense. ",5fe87a02cf039f3cc2197477cd7f14127a476128,2018-01-28 16:31:47,164304209,"@@ -0,0 +1,141 @@
+package org.interledger.encoding.asn.codecs;",1,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/164304209,https://github.com/hyperledger/quilt/pull/85#discussion_r164304209,sappenin
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,"Also, it would be cool to apply this codec-framework to the crypto-conditions code, which uses DER....assuming you were thinking the same?",5fe87a02cf039f3cc2197477cd7f14127a476128,2018-01-28 16:35:41,164304336,"@@ -0,0 +1,141 @@
+package org.interledger.encoding.asn.codecs;",1,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/164304336,https://github.com/hyperledger/quilt/pull/85#discussion_r164304336,sappenin
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,"We should add a comment here that new instances of each Codec are created for each encode/decode operation, so despite some of the properties being non-final, this code is still thread-safe.",5fe87a02cf039f3cc2197477cd7f14127a476128,2018-01-28 16:41:07,164304515,"@@ -0,0 +1,141 @@
+package org.interledger.encoding.asn.codecs;
+
+import static java.lang.String.format;
+
+import org.interledger.encoding.asn.framework.CodecException;
+
+import java.nio.charset.Charset;
+import java.util.Objects;
+import java.util.function.Predicate;
+
+/**
+ * ASN.1 object codec that uses a character string as an intermediary encoding.
+ *
+ * <p>This base class should be used for codecs where the ASN.1 object is a subclass of an ASN.1
+ * string type like IA5String or UTF8String (although the specific subclasses
+ * {@link AsnIA5StringBasedObjectCodec} and {@link AsnUtf8StringBasedObjectCodec} should be used in
+ * the case of those two types).
+ *
+ * <p>Codecs that extend this object can call {@link #getCharString()} and
+ * {@link #setCharString(String)} in their implementations of {@link #decode()} and
+ * {@link #encode(Object)} respectively.
+ *
+ * <p>The serializers for this object must call {@link #getCharString()} and
+ * {@link #setCharString(String)} when reading from a stream. The values passed and returned must
+ * not contain any length prefixes or tags.
+ *
+ */
+public abstract class AsnCharStringBasedObjectCodec<T> extends AsnPrimitiveCodec<T> {
+
+  private final Charset characterSet;
+  private Predicate<String> validator;",31,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/164304515,https://github.com/hyperledger/quilt/pull/85#discussion_r164304515,sappenin
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,We need unit test coverage for this class.,5fe87a02cf039f3cc2197477cd7f14127a476128,2018-01-28 16:46:22,164304670,"@@ -0,0 +1,34 @@
+package org.interledger.core.asn.codecs;
+
+import org.interledger.core.InterledgerFulfillPacket;
+import org.interledger.encoding.asn.codecs.AsnOctetStringCodec;
+import org.interledger.encoding.asn.codecs.AsnSequenceCodec;
+import org.interledger.encoding.asn.codecs.AsnSizeConstraint;
+
+public class AsnInterledgerFulfillPacketDataCodec",8,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/164304670,https://github.com/hyperledger/quilt/pull/85#discussion_r164304670,sappenin
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,"We should add individual unit-tests for each `codec` and `serializer` that aren't currently covered. 

Also, we should make those and any existing tests multithreaded to ensure that all this code works in a concurrent setting (I tried a few samples locally, and it seems to work properly in multi-threaded tests, so this would just be for current correctness, and to guard against future changes breaking things).

We could also add this to a ticket and do this work as a fast-follower (there's pretty good test coverage in here now).",5fe87a02cf039f3cc2197477cd7f14127a476128,2018-01-29 19:50:04,164544299,"@@ -0,0 +1,39 @@
+package org.interledger.encoding.asn.codecs;
+
+/**
+ * An ASN.1 codec for UInt8 objects that decodes them into {@link Integer} values.
+ */
+public class AsnUint8Codec extends AsnPrimitiveCodec<Integer> {",6,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/164544299,https://github.com/hyperledger/quilt/pull/85#discussion_r164544299,sappenin
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,"Let's talk more on Wednesday - I can show you how we can use the multi-threaded framework from the crypto-conditions project.  Also, I don't mind helping with unit tests.",5fe87a02cf039f3cc2197477cd7f14127a476128,2018-01-29 19:50:49,164544534,"@@ -0,0 +1,39 @@
+package org.interledger.encoding.asn.codecs;
+
+/**
+ * An ASN.1 codec for UInt8 objects that decodes them into {@link Integer} values.
+ */
+public class AsnUint8Codec extends AsnPrimitiveCodec<Integer> {",6,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/164544534,https://github.com/hyperledger/quilt/pull/85#discussion_r164544534,sappenin
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,"We should add a performance comparison test to compare the performance of the new Codec framework against the old one. I like the elegance of this new framework, so I might tolerate a slight perf degradation -- but hopefully this is actually faster than the old framework (but we should get a good idea before committing).",5fe87a02cf039f3cc2197477cd7f14127a476128,2018-01-29 19:52:23,164544958,"@@ -1,111 +1,51 @@
-package org.interledger.codecs.oer;
+package org.interledger.encoding.asn.serializers.oer;
 
-import org.interledger.codecs.Codec;
-import org.interledger.codecs.CodecContext;
-import org.interledger.codecs.CodecException;
-import org.interledger.codecs.oer.OerLengthPrefixCodec.OerLengthPrefix;
+import org.interledger.encoding.asn.framework.CodecException;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.Objects;
 
 /**
- * <p>An extension of {@link Codec} for reading and writing an ASN.1 OER Length prefix octets.</p>
- * <p>A length prefix specifies the length of a subsequent encoded object in terms of number of
- * octets required to encoded that object.</p> <p>The following rules apply:</p> <p>If the number of
- * octets required to encode an object is less than 128, then that length is encoded in the
- * lowest-order 7 bit positions of the first and only octet. The highest-order bit of the octet is
- * set to zero.</p> <p>Conversely, the number of octets required to encode an object is greater than
- * 127, then then that length is encoded into 2 or more octets as follows: The first octet will have
- * its highest-order bit set to 1, with the remaining 7 octets representing the number of subsequent
- * octets required to encode a number representing the actual length of the encoded object.
- * Depending on the value of that first length number (called 'N' for now), the next N octets will
- * encode a number representing the number of octets required to encode the actual object.</p>
- * <p>All encodings are in big-endian order.</p>
+ * A serializer with some static utility fucntions for reading and writing length prefixes.
  */
-public class OerLengthPrefixCodec implements Codec<OerLengthPrefix> {
+public class OerLengthSerializer  {
+
+  /**
+   * Read a length prefix from the stream.
+   *
+   * @param inputStream the stream to read from
+   * @return The lenght encoded in the length prefix
+   * @throws IOException if there is an error reading from the stream.
+   */
+  public static int readLength(final InputStream inputStream) throws IOException {
 
-  @Override
-  public OerLengthPrefix read(final CodecContext context, final InputStream inputStream)
-      throws IOException {
-    Objects.requireNonNull(context);
     Objects.requireNonNull(inputStream);
 
+
     // The number of encoded octets that the encoded payload will be stored in.
-    final int numEncodedOctets;
+    final int length;
 
     int initialLengthPrefixOctet = inputStream.read();
     if (initialLengthPrefixOctet >= 0 && initialLengthPrefixOctet < 128) {
-      numEncodedOctets = initialLengthPrefixOctet;
+      length = initialLengthPrefixOctet;
     } else {
       // Truncate the MSB and use the rest as a number...
       final int lengthOfLength = initialLengthPrefixOctet & 0x7f;
 
       // Convert the bytes into an integer...
       byte[] ba = new byte[lengthOfLength];
       int read = inputStream.read(ba, 0, lengthOfLength);
-      
+
       if (read != lengthOfLength) {
         throw new IOException(
             ""error reading "" + lengthOfLength + "" bytes from stream, only read "" + read);
       }
-      
-      numEncodedOctets = toInt(ba);
-    }
-
-    return new OerLengthPrefix(numEncodedOctets);
-  }
-
-  @Override
-  public void write(final CodecContext context, final OerLengthPrefix oerLengthPrefix,",78,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/164544958,https://github.com/hyperledger/quilt/pull/85#discussion_r164544958,sappenin
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,"Not opposed to this change, but isn't our project at 120 lines? Not sure if I'm perhaps using the wrong line-length.l",5fe87a02cf039f3cc2197477cd7f14127a476128,2018-01-29 19:54:05,164545415,"@@ -122,7 +122,8 @@ public static KeyPair constructEd25519KeyPair() {
    * @return A randomly generated {@link KeyPair}.
    */
   public static KeyPair generateRandomEd25519KeyPair() {
-    final net.i2p.crypto.eddsa.KeyPairGenerator edDsaKpg = new net.i2p.crypto.eddsa.KeyPairGenerator();",19,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/164545415,https://github.com/hyperledger/quilt/pull/85#discussion_r164545415,sappenin
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,Oooh...we're close! Is this our RC?,5fe87a02cf039f3cc2197477cd7f14127a476128,2018-01-29 19:55:49,164545916,"@@ -10,7 +10,7 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>org.interledger</groupId>
     <artifactId>ilp-core</artifactId>
-    <version>0.9.2-SNAPSHOT</version>
+    <version>1.0.0-SNAPSHOT</version>",,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/164545916,https://github.com/hyperledger/quilt/pull/85#discussion_r164545916,sappenin
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,"I think we can get rid of all the hashcode, equals, and toStrings for immutables-generated classes, no? It's unclear why these are all overridden.

In the crypto-condition project, there were a few times I overrode the `toString` so I wasn't printing out a big long series of bytes for byte-array properties, but otherwise never had to touch `equals` or `hashcode`.

Thoughts?",5fe87a02cf039f3cc2197477cd7f14127a476128,2018-01-29 19:57:52,164546469,"@@ -87,26 +85,32 @@ public boolean equals(Object obj) {
         return false;
       }
 
-      InterledgerPayment impl = (InterledgerPayment) obj;
+      InterledgerPreparePacket impl = (InterledgerPreparePacket) obj;
 
-      return getDestinationAccount().equals(impl.getDestinationAccount())
-          && getDestinationAmount().equals(impl.getDestinationAmount())
+      return getAmount().equals(impl.getAmount())
+          && getExpiresAt().equals(impl.getExpiresAt())
+          && getExecutionCondition().equals(impl.getExecutionCondition())
+          && getDestination().equals(impl.getDestination())
           && Arrays.equals(getData(), impl.getData());
     }
 
     @Override
     public int hashCode() {
-      int result = getDestinationAccount().hashCode();
-      result = 31 * result + getDestinationAmount().hashCode();
+      int result = getAmount().hashCode();",,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/164546469,https://github.com/hyperledger/quilt/pull/85#discussion_r164546469,sappenin
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,"See my comment above - if there's not something special going on in these overrides, we should remove them to reduce potential for errors.",5fe87a02cf039f3cc2197477cd7f14127a476128,2018-01-29 19:58:33,164546653,"@@ -0,0 +1,86 @@
+package org.interledger.core;
+
+import org.interledger.annotations.Immutable;
+
+import java.util.Arrays;
+
+public interface InterledgerRejectPacket extends InterledgerPacket {
+
+  /**
+   * Get the default builder.
+   *
+   * @return a {@link InterledgerRejectPacketBuilder} instance.
+   */
+  static InterledgerRejectPacketBuilder builder() {
+    return new InterledgerRejectPacketBuilder();
+  }
+
+  /**
+   * The Interledger Error Code for this error.
+   *
+   * @return An {@link InterledgerErrorCode}.
+   */
+  InterledgerErrorCode getCode();
+
+  /**
+   * The {@link InterledgerAddress} of the entity that originally emitted the error.
+   *
+   * @return An {@link InterledgerAddress}.
+   */
+  InterledgerAddress getTriggeredBy();
+
+  /**
+   * The {@link InterledgerAddress} of the entity that originally emitted the error.
+   *
+   * @return An {@link InterledgerAddress}.
+   */
+  String getMessage();
+
+  /**
+   * Machine-readable data. The format is defined for each error code. Implementations MUST follow
+   *     the correct format for the code given in the `code` field.
+   *
+   * @return The optional error data.
+   */
+  byte[] getData();
+
+  @Immutable
+  abstract class AbstractInterledgerRejectPacket implements InterledgerRejectPacket {
+
+    @Override
+    public boolean equals(Object obj) {
+      if (this == obj) {
+        return true;
+      }
+      if (obj == null || getClass() != obj.getClass()) {
+        return false;
+      }
+
+      InterledgerRejectPacket impl = (InterledgerRejectPacket) obj;
+
+      return getCode().equals(impl.getCode())
+          && getTriggeredBy().equals(impl.getTriggeredBy())
+          && getMessage().equals(impl.getMessage())
+          && Arrays.equals(getData(), impl.getData());
+    }
+
+    @Override
+    public int hashCode() {",,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/164546653,https://github.com/hyperledger/quilt/pull/85#discussion_r164546653,sappenin
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,"Haha. Semantic versioning is too confusing. I stick to simply stuff like Interledger. What version do you recommend?

I was trying to indicate that this is a breaking change from 0.9.x",5fe87a02cf039f3cc2197477cd7f14127a476128,2018-02-01 17:07:26,165423127,"@@ -10,7 +10,7 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>org.interledger</groupId>
     <artifactId>ilp-core</artifactId>
-    <version>0.9.2-SNAPSHOT</version>
+    <version>1.0.0-SNAPSHOT</version>",,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165423127,https://github.com/hyperledger/quilt/pull/85#discussion_r165423127,adrianhopebailie
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,👍 - will review the auto-generated code but likely it's good,5fe87a02cf039f3cc2197477cd7f14127a476128,2018-02-01 17:08:10,165423337,"@@ -87,26 +85,32 @@ public boolean equals(Object obj) {
         return false;
       }
 
-      InterledgerPayment impl = (InterledgerPayment) obj;
+      InterledgerPreparePacket impl = (InterledgerPreparePacket) obj;
 
-      return getDestinationAccount().equals(impl.getDestinationAccount())
-          && getDestinationAmount().equals(impl.getDestinationAmount())
+      return getAmount().equals(impl.getAmount())
+          && getExpiresAt().equals(impl.getExpiresAt())
+          && getExecutionCondition().equals(impl.getExecutionCondition())
+          && getDestination().equals(impl.getDestination())
           && Arrays.equals(getData(), impl.getData());
     }
 
     @Override
     public int hashCode() {
-      int result = getDestinationAccount().hashCode();
-      result = 31 * result + getDestinationAmount().hashCode();
+      int result = getAmount().hashCode();",,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165423337,https://github.com/hyperledger/quilt/pull/85#discussion_r165423337,adrianhopebailie
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,"I'd be happy to switch to 120. Will mean changing the CheckStyles rules file.

https://github.com/hyperledger/quilt/blob/master/dev-ops/src/main/resources/org/interledger/dev-ops/checkstyle.xml#L50",5fe87a02cf039f3cc2197477cd7f14127a476128,2018-02-01 17:11:23,165424200,"@@ -122,7 +122,8 @@ public static KeyPair constructEd25519KeyPair() {
    * @return A randomly generated {@link KeyPair}.
    */
   public static KeyPair generateRandomEd25519KeyPair() {
-    final net.i2p.crypto.eddsa.KeyPairGenerator edDsaKpg = new net.i2p.crypto.eddsa.KeyPairGenerator();",19,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165424200,https://github.com/hyperledger/quilt/pull/85#discussion_r165424200,adrianhopebailie
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,"I think that if performance becomes an issue we'll move away from the framework to hardcoded serializers and deserializers like in the Crypto-Conditions lib.

Let's not be premature in trying to optimize this.",5fe87a02cf039f3cc2197477cd7f14127a476128,2018-02-01 17:12:48,165424587,"@@ -1,111 +1,51 @@
-package org.interledger.codecs.oer;
+package org.interledger.encoding.asn.serializers.oer;
 
-import org.interledger.codecs.Codec;
-import org.interledger.codecs.CodecContext;
-import org.interledger.codecs.CodecException;
-import org.interledger.codecs.oer.OerLengthPrefixCodec.OerLengthPrefix;
+import org.interledger.encoding.asn.framework.CodecException;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.Objects;
 
 /**
- * <p>An extension of {@link Codec} for reading and writing an ASN.1 OER Length prefix octets.</p>
- * <p>A length prefix specifies the length of a subsequent encoded object in terms of number of
- * octets required to encoded that object.</p> <p>The following rules apply:</p> <p>If the number of
- * octets required to encode an object is less than 128, then that length is encoded in the
- * lowest-order 7 bit positions of the first and only octet. The highest-order bit of the octet is
- * set to zero.</p> <p>Conversely, the number of octets required to encode an object is greater than
- * 127, then then that length is encoded into 2 or more octets as follows: The first octet will have
- * its highest-order bit set to 1, with the remaining 7 octets representing the number of subsequent
- * octets required to encode a number representing the actual length of the encoded object.
- * Depending on the value of that first length number (called 'N' for now), the next N octets will
- * encode a number representing the number of octets required to encode the actual object.</p>
- * <p>All encodings are in big-endian order.</p>
+ * A serializer with some static utility fucntions for reading and writing length prefixes.
  */
-public class OerLengthPrefixCodec implements Codec<OerLengthPrefix> {
+public class OerLengthSerializer  {
+
+  /**
+   * Read a length prefix from the stream.
+   *
+   * @param inputStream the stream to read from
+   * @return The lenght encoded in the length prefix
+   * @throws IOException if there is an error reading from the stream.
+   */
+  public static int readLength(final InputStream inputStream) throws IOException {
 
-  @Override
-  public OerLengthPrefix read(final CodecContext context, final InputStream inputStream)
-      throws IOException {
-    Objects.requireNonNull(context);
     Objects.requireNonNull(inputStream);
 
+
     // The number of encoded octets that the encoded payload will be stored in.
-    final int numEncodedOctets;
+    final int length;
 
     int initialLengthPrefixOctet = inputStream.read();
     if (initialLengthPrefixOctet >= 0 && initialLengthPrefixOctet < 128) {
-      numEncodedOctets = initialLengthPrefixOctet;
+      length = initialLengthPrefixOctet;
     } else {
       // Truncate the MSB and use the rest as a number...
       final int lengthOfLength = initialLengthPrefixOctet & 0x7f;
 
       // Convert the bytes into an integer...
       byte[] ba = new byte[lengthOfLength];
       int read = inputStream.read(ba, 0, lengthOfLength);
-      
+
       if (read != lengthOfLength) {
         throw new IOException(
             ""error reading "" + lengthOfLength + "" bytes from stream, only read "" + read);
       }
-      
-      numEncodedOctets = toInt(ba);
-    }
-
-    return new OerLengthPrefix(numEncodedOctets);
-  }
-
-  @Override
-  public void write(final CodecContext context, final OerLengthPrefix oerLengthPrefix,",78,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165424587,https://github.com/hyperledger/quilt/pull/85#discussion_r165424587,adrianhopebailie
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,👍 - this PR is definitely adding to technical debt but I think the sooner we have v4 compatible code in `master` the better so people can work on nodes and integrations.,5fe87a02cf039f3cc2197477cd7f14127a476128,2018-02-01 17:14:13,165424978,"@@ -0,0 +1,39 @@
+package org.interledger.encoding.asn.codecs;
+
+/**
+ * An ASN.1 codec for UInt8 objects that decodes them into {@link Integer} values.
+ */
+public class AsnUint8Codec extends AsnPrimitiveCodec<Integer> {",6,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165424978,https://github.com/hyperledger/quilt/pull/85#discussion_r165424978,adrianhopebailie
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,I think a short README on how the framework works would be a good idea. Will put it on the TODO list.,5fe87a02cf039f3cc2197477cd7f14127a476128,2018-02-01 17:14:59,165425229,"@@ -0,0 +1,141 @@
+package org.interledger.encoding.asn.codecs;
+
+import static java.lang.String.format;
+
+import org.interledger.encoding.asn.framework.CodecException;
+
+import java.nio.charset.Charset;
+import java.util.Objects;
+import java.util.function.Predicate;
+
+/**
+ * ASN.1 object codec that uses a character string as an intermediary encoding.
+ *
+ * <p>This base class should be used for codecs where the ASN.1 object is a subclass of an ASN.1
+ * string type like IA5String or UTF8String (although the specific subclasses
+ * {@link AsnIA5StringBasedObjectCodec} and {@link AsnUtf8StringBasedObjectCodec} should be used in
+ * the case of those two types).
+ *
+ * <p>Codecs that extend this object can call {@link #getCharString()} and
+ * {@link #setCharString(String)} in their implementations of {@link #decode()} and
+ * {@link #encode(Object)} respectively.
+ *
+ * <p>The serializers for this object must call {@link #getCharString()} and
+ * {@link #setCharString(String)} when reading from a stream. The values passed and returned must
+ * not contain any length prefixes or tags.
+ *
+ */
+public abstract class AsnCharStringBasedObjectCodec<T> extends AsnPrimitiveCodec<T> {
+
+  private final Charset characterSet;
+  private Predicate<String> validator;",31,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165425229,https://github.com/hyperledger/quilt/pull/85#discussion_r165425229,adrianhopebailie
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,"The codecs should be neutral of serialization rules. They are basically an intermediary state for your data that resembles the ASN.1 form.

In theory you should be able to write serializers for DER too.

> Also, it would be cool to apply this codec-framework to the crypto-conditions code, which uses DER

This would be a good way to test the theory 😄 ",5fe87a02cf039f3cc2197477cd7f14127a476128,2018-02-01 17:16:37,165425649,"@@ -0,0 +1,141 @@
+package org.interledger.encoding.asn.codecs;",1,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165425649,https://github.com/hyperledger/quilt/pull/85#discussion_r165425649,adrianhopebailie
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,"I think we use 2 spaces in code so we should be consistent...

https://www.youtube.com/watch?v=SsoOG6ZeyUI",5fe87a02cf039f3cc2197477cd7f14127a476128,2018-02-01 17:18:23,165426131,"@@ -0,0 +1,57 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <parent>
+        <artifactId>quilt-parent</artifactId>
+        <groupId>org.interledger</groupId>
+        <version>0.1.0-SNAPSHOT</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <name>Hyperledger Quilt Codec Framework</name>
+    <description>A framework for writing codecContext.</description>
+
+    <artifactId>codec-framework</artifactId>",,2018-02-01 19:55:58,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165426131,https://github.com/hyperledger/quilt/pull/85#discussion_r165426131,adrianhopebailie
https://github.com/hyperledger/quilt/pull/85,https://github.com/hyperledger/quilt/pull/85,"Yeah, not something to block on -- more of a thought for a future task, I guess.",5fe87a02cf039f3cc2197477cd7f14127a476128,2018-02-02 05:37:15,165562038,"@@ -1,111 +1,51 @@
-package org.interledger.codecs.oer;
+package org.interledger.encoding.asn.serializers.oer;
 
-import org.interledger.codecs.Codec;
-import org.interledger.codecs.CodecContext;
-import org.interledger.codecs.CodecException;
-import org.interledger.codecs.oer.OerLengthPrefixCodec.OerLengthPrefix;
+import org.interledger.encoding.asn.framework.CodecException;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.Objects;
 
 /**
- * <p>An extension of {@link Codec} for reading and writing an ASN.1 OER Length prefix octets.</p>
- * <p>A length prefix specifies the length of a subsequent encoded object in terms of number of
- * octets required to encoded that object.</p> <p>The following rules apply:</p> <p>If the number of
- * octets required to encode an object is less than 128, then that length is encoded in the
- * lowest-order 7 bit positions of the first and only octet. The highest-order bit of the octet is
- * set to zero.</p> <p>Conversely, the number of octets required to encode an object is greater than
- * 127, then then that length is encoded into 2 or more octets as follows: The first octet will have
- * its highest-order bit set to 1, with the remaining 7 octets representing the number of subsequent
- * octets required to encode a number representing the actual length of the encoded object.
- * Depending on the value of that first length number (called 'N' for now), the next N octets will
- * encode a number representing the number of octets required to encode the actual object.</p>
- * <p>All encodings are in big-endian order.</p>
+ * A serializer with some static utility fucntions for reading and writing length prefixes.
  */
-public class OerLengthPrefixCodec implements Codec<OerLengthPrefix> {
+public class OerLengthSerializer  {
+
+  /**
+   * Read a length prefix from the stream.
+   *
+   * @param inputStream the stream to read from
+   * @return The lenght encoded in the length prefix
+   * @throws IOException if there is an error reading from the stream.
+   */
+  public static int readLength(final InputStream inputStream) throws IOException {
 
-  @Override
-  public OerLengthPrefix read(final CodecContext context, final InputStream inputStream)
-      throws IOException {
-    Objects.requireNonNull(context);
     Objects.requireNonNull(inputStream);
 
+
     // The number of encoded octets that the encoded payload will be stored in.
-    final int numEncodedOctets;
+    final int length;
 
     int initialLengthPrefixOctet = inputStream.read();
     if (initialLengthPrefixOctet >= 0 && initialLengthPrefixOctet < 128) {
-      numEncodedOctets = initialLengthPrefixOctet;
+      length = initialLengthPrefixOctet;
     } else {
       // Truncate the MSB and use the rest as a number...
       final int lengthOfLength = initialLengthPrefixOctet & 0x7f;
 
       // Convert the bytes into an integer...
       byte[] ba = new byte[lengthOfLength];
       int read = inputStream.read(ba, 0, lengthOfLength);
-      
+
       if (read != lengthOfLength) {
         throw new IOException(
             ""error reading "" + lengthOfLength + "" bytes from stream, only read "" + read);
       }
-      
-      numEncodedOctets = toInt(ba);
-    }
-
-    return new OerLengthPrefix(numEncodedOctets);
-  }
-
-  @Override
-  public void write(final CodecContext context, final OerLengthPrefix oerLengthPrefix,",78,2018-02-02 05:37:15,https://api.github.com/repos/hyperledger/quilt/pulls/comments/165562038,https://github.com/hyperledger/quilt/pull/85#discussion_r165562038,sappenin
https://github.com/hyperledger/quilt/pull/75,https://github.com/hyperledger/quilt/pull/75,"This Rocket Chat link syntax only seems to work in the branch root `README.md`. In this module's README, it seems broken.

Here are 2 alternate fixes suggestions:
* Visually identifical to the Rocket Chat link of the root documentation:
`[![Rocket.Chat](https://open.rocket.chat/images/join-chat.svg)](https://chat.hyperledger.org/channel/quilt)`
* Bringing precision (states the `hyperledger` chat server and its `quilt` channel):
`[![Rocket.Chat](https://open.rocket.chat/api/v1/shield.svg?type=channel&name=hyperledger&channel=quilt)](https://chat.hyperledger.org/channel/quilt)`",e322db7fed6c323b9b5fa3a8bf20c96042513255,2018-01-14 14:33:20,161399536,"@@ -109,11 +158,6 @@ Any contribution is very much appreciated!
 
 [![join the chat][rocketchat-image]][rocketchat-url]",69,2018-01-14 14:33:20,https://api.github.com/repos/hyperledger/quilt/pulls/comments/161399536,https://github.com/hyperledger/quilt/pull/75#discussion_r161399536,pascalav
https://github.com/hyperledger/quilt/pull/70,https://github.com/hyperledger/quilt/pull/70,"This PR looks good, except the above comment doesn't make sense to me. I think we should strike the sentence, `This validates the enhancement for Github issue #10 where algorithm is reminded`, and instead add `<p>` tags so the overall Javadoc looks like this:

```
/**
 * <p>Tests the cost computation of a {@link ThresholdSha256Condition}.</p> 
 * 
 * <p>For example, if a threshold crypto-condition contains 5
 * sub-conditions with costs of 64, 84, 82, 64 and 84, and has a
 * threshold of 3, the cost is equal to the sum of the largest three
 * sub-condition costs (82 + 84 + 84 = 250) plus 1024 times the
 * number of sub-conditions (1024 * 5 = 5120): 5370.</p>
 *
 * @see ""https://github.com/hyperledger/quilt/issues/10""
 * @see ""https://github.com/interledger/java-crypto-conditions/issues/78""
 */
```",e992db8beac5c07919d065860bef844c81d1cc60,2018-01-13 04:48:52,161363797,"@@ -58,4 +58,49 @@ public void testConstructionUsingMultipleThreads() throws Exception {
     this.runConcurrent(1, runnableTest);
     this.runConcurrent(runnableTest);
   }
+
+  /**
+   * Tests the cost of a {@link ThresholdSha256Condition}. This test
+   * validates the enhancement for Github issue #10 where algorithm is",,2018-02-07 18:41:52,https://api.github.com/repos/hyperledger/quilt/pulls/comments/161363797,https://github.com/hyperledger/quilt/pull/70#discussion_r161363797,sappenin
https://github.com/hyperledger/quilt/pull/70,https://github.com/hyperledger/quilt/pull/70,Indeed. The PR brings this change in commit https://github.com/hyperledger/quilt/pull/70/commits/cf17438dc0dcaf8a0687bade0f450e9ec6985c5d.,e992db8beac5c07919d065860bef844c81d1cc60,2018-01-14 13:06:54,161396980,"@@ -58,4 +58,49 @@ public void testConstructionUsingMultipleThreads() throws Exception {
     this.runConcurrent(1, runnableTest);
     this.runConcurrent(runnableTest);
   }
+
+  /**
+   * Tests the cost of a {@link ThresholdSha256Condition}. This test
+   * validates the enhancement for Github issue #10 where algorithm is",,2018-02-07 18:41:52,https://api.github.com/repos/hyperledger/quilt/pulls/comments/161396980,https://github.com/hyperledger/quilt/pull/70#discussion_r161396980,pascalav
https://github.com/hyperledger/quilt/pull/69,https://github.com/hyperledger/quilt/pull/69,"This looks good to me, too, although I think we should label this as its own section using separator or a label. How about adding a `###` heading called ""Buliding the Project""? Otherwise, looks good (though you'll need to submit the PR differently like @earizon indicated).",74c1ab975674a5fee42423e91ceea8c1b7721f9b,2018-01-13 05:01:39,161364004,"@@ -48,3 +48,37 @@ using the Octet Encoding Rules (OER).
 Dev-ops is a module for shared build and test tools
 
 [READ MORE](./dev-ops)
+
+### Add Unlimited Strength Encryption Policy Files ",5,2018-01-13 05:02:40,https://api.github.com/repos/hyperledger/quilt/pulls/comments/161364004,https://github.com/hyperledger/quilt/pull/69#discussion_r161364004,sappenin
https://github.com/hyperledger/quilt/pull/60,https://github.com/hyperledger/quilt/pull/60,Looks like a typo from auto-refactor...,82b5167fa9f180697b808543dc5ebb7ba35927fd,2017-12-16 17:21:07,157346502,"@@ -39,7 +39,7 @@
 
       ""Derivative Works"" shall mean any work, whether in Source or Object
       form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
+      editorial revisions, org.interledger.annotations, elaborations, or other modifications",5,2018-01-24 10:44:33,https://api.github.com/repos/hyperledger/quilt/pulls/comments/157346502,https://github.com/hyperledger/quilt/pull/60#discussion_r157346502,sappenin
https://github.com/hyperledger/quilt/pull/55,https://github.com/hyperledger/quilt/pull/55,I get a checkstyle build failure with the addtion of this `<p>` tag (and the ending tag below -- does this build properly on your local machine?,fbcd61c528607d6e227eebb608b39f81a462b36d,2017-11-21 23:53:01,152435154,"@@ -39,7 +38,7 @@
      * A handler for allowing callers to specify logic based upon an unknown result type. This class
      * can be used in the following manner:
      *
-     * <pre>
+     * <p><pre>",,2017-12-11 13:59:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/152435154,https://github.com/hyperledger/quilt/pull/55#discussion_r152435154,sappenin
https://github.com/hyperledger/quilt/pull/55,https://github.com/hyperledger/quilt/pull/55,"First of all, this all looks great - nice work! (this has actually been on my todo list for a while).

One thing I've noticed with Immutables is that if you annotate the interface, then you can't extend that interface with another Immutable. In order to do that, we need to use an `abstract` class. It's a _little_ more code for us, but I think we should do it so that somebody could create an extension of our interfaces, but still be able to use the Immutables library. 

One additional nice effect this has is it allows us to define the `equals` and `hashcode` methods correctly, so that anybody using the library doesn't have to worry about it.

So, `InterledgerAddress.java` would instead look like this:

```
package org.interledger;

import org.immutables.value.Value;

import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Pattern;

/**
 * Interledger Protocol (ILP) Addresses identify Ledger accounts (or groups of Ledger accounts) in
 * an ILP network, and provide a way to route a payment to its intended destination.
 *
 * <p>Interledger Addresses can be subdivided into two categories:</p>
 *
 * <p> <b>Destination Addresses</b> are complete addresses that can receive payments. A destination
 * address always maps to one account in a ledger, though it can also provide more specific
 * information, such as an invoice ID or a sub-account. Destination addresses MUST NOT end in a
 * period (.) character. </p>
 *
 * <p> <b>Address Prefixes</b> are incomplete addresses representing a grouping of destination
 * addresses. Many depths of grouping are possible, for example: groups of accounts or sub-accounts;
 * an individual ledger or sub-ledger; or entire neighborhoods of ledgers. Address prefixes MUST end
 * in a period (.) character. </p>
 *
 * <p> The formal specification for an Interledger Addresses is defined in <a
 * href=""https://github.com/interledger/rfcs/tree/master/0015-ilp-addresses"">Interledger RFC
 * #15</a>. </p>
 *
 * @see ""https://github.com/interledger/rfcs/tree/master/0015-ilp-addresses""
 */
public interface InterledgerAddress {

  String REGEX = ""(?=^.{1,1023}$)""
      + ""^(g|private|example|peer|self|test[1-3])[.]([a-zA-Z0-9_~-]+[.])*([a-zA-Z0-9_~-]+)?$"";

  Pattern PATTERN = Pattern.compile(REGEX);

  /**
   * <p>Constructor to allow quick construction from a String representation of an ILP address.</p>
   *
   * @param value String representation of an Interledger Address
   *
   * @return an {@link InterledgerAddress} instance.
   */
  static InterledgerAddress of(final String value) {
    return builder()
        .value(value)
        .build();
  }

  /**
   * <p>Helper method to determine if an Interledger Address conforms to the specifications outlined
   * in Interledger RFC #15.</p>
   *
   * @param value A {@link String} representing a potential Interledger Address value.
   *
   * @return {@code true} if the supplied {@code value} conforms to the requirements of RFC 15;
   *     {@code false} otherwise.
   *
   * @see ""https://github.com/interledger/rfcs/tree/master/0015-ilp-addresses""
   */
  static boolean isValid(final String value) {
    Objects.requireNonNull(value);
    return PATTERN.matcher(value)
        .matches();
  }

  /**
   * Checks and requires that the specified {@code addressPrefix} is an address prefix per {@link
   * InterledgerAddress#isLedgerPrefix()}.
   *
   * <p>This method is designed primarily for doing parameter validation in methods and
   * constructors, as demonstrated below:</p> <blockquote>
   * <pre>
   * public Foo(InterledgerAddress bar) {
   *     this.ledgerPrefix = InterledgerAddress.requireAddressPrefix(bar);
   * }
   * </pre>
   * </blockquote>
   *
   * @param addressPrefix A {@link InterledgerAddress} to check.
   *
   * @return {@code ledgerPrefix} if its value ends with a dot (.).
   *
   * @throws IllegalArgumentException if the supplied Interledger address is not a ledger-prefix.
   */
  static InterledgerAddress requireAddressPrefix(final InterledgerAddress addressPrefix) {
    Objects.requireNonNull(addressPrefix, ""addressPrefix must not be null!"");
    if (!addressPrefix.isLedgerPrefix()) {
      throw new IllegalArgumentException(
          String.format(""InterledgerAddress '%s' must be an Address Prefix ending with a dot (.)"",
              addressPrefix.getValue()
          )
      );
    } else {
      return addressPrefix;
    }
  }

  /**
   * Checks and requires that the specified {@code addressPrefix} is not an address prefix per
   * {@link InterledgerAddress#isLedgerPrefix()}.
   *
   *
   * <p>This method is designed primarily for doing parameter validation in methods and
   * constructors, as demonstrated below:</p> <blockquote>
   * <pre>
   * public Foo(InterledgerAddress bar) {
   *     this.nonLedgerPrefix = InterledgerAddress.requireNotAddressPrefix(bar);
   * }
   * </pre>
   * </blockquote>
   *
   * @param addressPrefix A {@link InterledgerAddress} to check.
   *
   * @return {@code addressPrefix} if its value ends with a dot (.).
   *
   * @throws IllegalArgumentException if the supplied Interledger address is not a ledger-prefix.
   */
  static InterledgerAddress requireNotAddressPrefix(final InterledgerAddress addressPrefix) {
    Objects.requireNonNull(addressPrefix, ""addressPrefix must not be null!"");
    if (addressPrefix.isLedgerPrefix()) {
      throw new IllegalArgumentException(
          String
              .format(""InterledgerAddress '%s' must NOT be an Address Prefix ending with a dot (.)"",
                  addressPrefix.getValue()
              )
      );
    } else {
      return addressPrefix;
    }
  }

  /**
   * Get the default builder.
   *
   * @return a {@link ImmutableInterledgerAddress.Builder} instance.
   */
  static ImmutableInterledgerAddress.Builder builder() {
    return ImmutableInterledgerAddress.builder();
  }

  /**
   * Return this address's value as a non-null {@link String}. For example:
   * <code>us.usd.bank.account</code>
   *
   * @return A {@link String} representation of this Interledger address.
   */
  String getValue();

  /**
   * Tests if this Interledger address represents a ledger prefix.
   *
   * @return True if the address is a ledger prefix, false otherwise.
   */
  default boolean isLedgerPrefix() {
    return getValue().endsWith(""."");
  }

  /**
   * Tests if this InterledgerAddress starts with the specified {@code addressSegment}.
   *
   * @param addressSegment An {@link String} prefix to compare against.
   *
   * @return {@code true} if this InterledgerAddress begins with the specified prefix.
   */
  default boolean startsWith(final String addressSegment) {
    Objects.requireNonNull(addressSegment, ""addressSegment must not be null!"");
    return this.getValue()
        .startsWith(addressSegment);
  }

  /**
   * Tests if this InterledgerAddress starts with the specified {@code interledgerAddress}.
   *
   * @param interledgerAddress An {@link InterledgerAddress} prefix to compare against.
   *
   * @return {@code true} if this InterledgerAddress begins with the specified prefix.
   */
  default boolean startsWith(final InterledgerAddress interledgerAddress) {
    Objects.requireNonNull(interledgerAddress, ""interledgerAddress must not be null!"");
    return this.startsWith(interledgerAddress.getValue());
  }

  /**
   * <p>Return a new InterledgerAddress by postfixing the supplied {@code segment} to this address.
   * </p>
   *
   * <p>This method can be used to construct both address prefixes and destination addresses. For
   * example, if the value of this address is '<code>us.usd.</code>', then calling this method with
   * an argument of '<code>bob</code>' would result in a new Interledger Address with a value of
   * '<code>us.usd.bob</code>', which is a destination address.</p>
   *
   * <p>Likewise, if the value of this address is '<code>us.usd.pacific.</code>', then calling this
   * method with an argument of '<code>creditunions.</code>' would result in a new Interledger
   * Address with a value of '<code>us.usd.pacific.creditunions.</code>', which is an address
   * prefix.</p>
   *
   * @param addressSegment A {@link String} to be appended to this address as an additional
   *                       segment.
   *
   * @return A new instance representing the original address with a newly specified final segment.
   */
  default InterledgerAddress with(String addressSegment) {
    Objects.requireNonNull(addressSegment, ""addressSegment must not be null!"");

    final StringBuilder sb = new StringBuilder(this.getValue());
    if (!this.isLedgerPrefix()) {
      sb.append(""."");
    }
    sb.append(addressSegment);

    return InterledgerAddress.of(sb.toString());
  }

  /**
   * <p>Return this address's prefix, which is a new {@link InterledgerAddress} containing the
   * characters inside of {@link #getValue()}, up-to and including the last period. If this address
   * is already a prefix, then this instance is instead returned unchanged.</p>
   *
   * <p>For example, calling this method on an address 'g.example.alice' would yield a new address
   * containing 'g.example.'. Conversely, calling this method on an address that is already a
   * prefix, like 'g.example.' would yield the same instance, 'g.example.'.</p>
   *
   * @return A potentially new {@link InterledgerAddress} representing the prefix of this address.
   */
  default InterledgerAddress getPrefix() {
    if (this.isLedgerPrefix()) {
      return this;
    } else {
      return InterledgerAddress.of(getValue().substring(0, this.getValue().lastIndexOf(""."") + 1));
    }
  }

  /**
   * <p>Return this address's parent prefix.</p>
   *
   * <p>If this address is a destination address, then this method returns a new {@link
   * InterledgerAddress} containing the characters inside of {@link #getValue()}, up-to and
   * including last period. If this address is instead a prefix, then this instance returns a new
   * {@link InterledgerAddress} containing the characters inside of {@link #getValue()}, up-to and
   * including second-to-last period, unless this address is a root prefix, in which case, {@link
   * Optional#empty()} is returned.</p>
   *
   * <p>For example, calling this method on an address 'g.example.alice' would yield a new address
   * containing 'g.example.'. Likewise, calling this method on an address that is already a prefix,
   * like 'g.example.' would yield 'g.'. Finally, calling this method on a root prefix, like ""self.""
   * would yield {@link Optional#empty()}.</p>
   *
   * @return An optionally present parent-prefix.
   */
  default Optional<InterledgerAddress> getParentPrefix() {
    // If this address is not a prefix, then just return the prefix. Otherwise, look deeper.
    if (this.isLedgerPrefix()) {
      // If the prefix is a root prefix, return Optional#empty. Otherwise, return the parent prefix.
      if (isRootPrefix()) {
        return Optional.empty();
      } else {
        // Call getParentPrefix with the account portion, which will forward to #getPrefix.
        return InterledgerAddress.of(
            this.getValue().substring(0, this.getValue().lastIndexOf("".""))
        ).getParentPrefix();
      }
    } else {
      return Optional.of(this.getPrefix());
    }
  }

  /**
   * <p>Determines if this ILP Address has a parent-prefix.</p>
   *
   * <p>If this address is a destination address, then it has a parent prefix. However, if the
   * address is a prefix, then it only has a parent if it is _not_ a Root Prefix.</p>
   *
   * @return {@code true} if this address is a destination address. Otherwise (if this address is a
   *     prefix address), then return {@code false} if this address is a Root prefix; otherwise,
   *     return {@code true}.
   */
  default boolean hasParentPrefix() {
    // All ILP addresse have a parent prefix, except for Root prefixes.
    return isRootPrefix() == false;
  }

  String ROOT_REGEX = ""^(g|private|example|peer|self|test[1-3])[.]$"";
  Pattern ROOT_PATTERN = Pattern.compile(ROOT_REGEX);

  /**
   * <p>Determines if this address is a ""root"" prefix, which per ILP-RFC-15, is one of: ""g."",
   * ""private."", ""example."", ""peer."", ""self."", ""test1."", ""test2."", or ""test3."". Any other kind of
   * valid ILP address (e.g. ""g.1"") is not a root prefix.</p>
   *
   * @return {@code true} if this address is a root prefix; {@code false} otherwise.
   */
  default boolean isRootPrefix() {
    // Alternate implementation (Note: A prefix is a root prefix if it has only a single period)
    // final int numPeriods = getValue().length() - getValue().replaceAll(""[.!?]+"", """").length();
    // return numPeriods == 1;
    return ROOT_PATTERN.matcher(this.getValue()).matches();
  }

  @Value.Immutable
  abstract class AbstractInterledgerAddress implements InterledgerAddress {

    /**
     * <p>Compares the specified object with this <tt>InterledgerAddress</tt> for equality.</p>
     *
     * <p>The <tt>InterledgerAddress</tt> interface is essentially a type-safe wrapper around a
     * String value, so implementations should take care to forward equality decisions to the {@link
     * String#equals(Object)} method on the object returned by {@link #getValue()}.</p>
     *
     * @param obj object to be compared for equality with this collection
     *
     * @return <tt>true</tt> if the specified object is equal to this {@link InterledgerAddress}.
     *
     * @see Object#equals(Object)
     * @see Set#equals(Object)
     * @see List#equals(Object)
     */
    @Override
    public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      }
      if (obj == null || getClass() != obj.getClass()) {
        return false;
      }

      InterledgerAddress foo = (InterledgerAddress) obj;

      return getValue().equals(foo.getValue());
    }

    /**
     * <p>Returns the hash code value for this <tt>InterledgerAddress</tt>.</p>
     *
     * <p>The<tt>InterledgerAddress</tt> interface is essentially a type-safe wrapper around a
     * String value, so implementations should take care to forward hashcode decisions to the {@link
     * String#equals(Object)} method on the object returned by {@link #getValue()}.</p>
     *
     * @return the hash code value for this {@link InterledgerAddress}.
     *
     * @see Object#hashCode()
     * @see Object#equals(Object)
     */
    @Override
    public int hashCode() {
      return this.getValue().hashCode();
    }

    /**
     * Precondition enforcer that ensures the value is a valid Interledger Address.
     *
     * @see ""https://github.com/interledger/rfcs/blob/master/0015-ilp-addresses/0015-ilp-addresses.md""
     */
    @Value.Check
    void check() {
      if (!InterledgerAddress.isValid(getValue())) {
        throw new IllegalArgumentException(String.format(""Invalid characters in address: ['%s']. ""
            + ""Reference Interledger ILP-RFC-15 for proper format."", getValue()));
      }
    }
  }
}
``` 

To make the above work, you'll need to edit `CodecContext#lookup` to be as follows:

```
/**
   * Helper method to lookup a {@link Codec} for the specified {@code type}.
   *
   * @param <T>  The specific type of {@link Codec} to return.
   * @param type An instance of {@link Class}.
   */
  @SuppressWarnings(""unchecked"")
  private <T> Codec<T> lookup(final Class<T> type) {
    Objects.requireNonNull(type);

    if (codecs.containsKey(type)) {
      return (Codec<T>) codecs.get(type);
    } else {
      // Check any interfaces...
      return Optional.ofNullable(
          Arrays.stream(type.getInterfaces())
              // Only use codecs that are found...
              .filter(codecs::containsKey)
              // If found, map to the first codec...
              .map(interfaceClass -> (Codec<T>) codecs.get(interfaceClass))
              .findFirst()
              // Otherwise, recurse with the super-class
              .orElseGet(() -> {
                // There were not interfaces, so check the super-classes.
                return (Codec<T>) lookup(type.getSuperclass());
              })
      ).orElseThrow(() -> new CodecException(
          String.format(""No codec registered for %s or its super classes!"",
              type.getName())));
    }
  }
```",fbcd61c528607d6e227eebb608b39f81a462b36d,2017-11-22 01:38:02,152449438,"@@ -1,5 +1,7 @@
 package org.interledger;
 
+import org.immutables.value.Value;",,2017-12-11 13:59:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/152449438,https://github.com/hyperledger/quilt/pull/55#discussion_r152449438,sappenin
https://github.com/hyperledger/quilt/pull/55,https://github.com/hyperledger/quilt/pull/55,"This looks errant, likely due to auto-refactor?",fbcd61c528607d6e227eebb608b39f81a462b36d,2017-12-09 01:44:48,155909253,"@@ -39,7 +39,7 @@
 
       ""Derivative Works"" shall mean any work, whether in Source or Object
       form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
+      editorial revisions, org.interledger.annotations, elaborations, or other modifications",,2017-12-11 13:59:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/155909253,https://github.com/hyperledger/quilt/pull/55#discussion_r155909253,sappenin
https://github.com/hyperledger/quilt/pull/55,https://github.com/hyperledger/quilt/pull/55,Any reason we're overriding `toString` here? Seems like we could just remove this override and use the one generated by immutables?,fbcd61c528607d6e227eebb608b39f81a462b36d,2017-12-09 01:58:14,155909785,"@@ -93,224 +92,97 @@ static InterledgerProtocolError withForwardedAddress(
       final InterledgerProtocolError interledgerProtocolError,
       final InterledgerAddress forwardedByAddress
   ) {
-    return new Builder(interledgerProtocolError).addForwardedByAddress(forwardedByAddress)
+    return new InterledgerProtocolErrorBuilder().from(interledgerProtocolError)
+        .addForwardedByAddresses(forwardedByAddress)
         .build();
   }
 
-  /**
-   * <p>A builder for immutable instances of {@link InterledgerProtocolError}.</p>
-   *
-   * <p>NOTE: This builder class is not thread-safe and generally should not be stored in a field or
-   * collection, but instead used immediately to create instances of {@link
-   * InterledgerProtocolError}.</p>
-   */
-  class Builder {
-
-    private ErrorCode errorCode;
-    private InterledgerAddress triggeredByAddress;
-    private List<InterledgerAddress> forwardedByAddresses;
-    private Instant triggeredAt;
-    private Optional<byte[]> data;
-
-    /**
-     * No-args Constructor.
-     */
-    public Builder() {
-      this.forwardedByAddresses = new LinkedList<>();
-      data = Optional.empty();
-    }
-
-    public Builder(final InterledgerProtocolError interledgerProtocolError) {
-      Objects.requireNonNull(interledgerProtocolError);
-
-      this.errorCode = interledgerProtocolError.getErrorCode();
-      this.triggeredByAddress = interledgerProtocolError.getTriggeredByAddress();
-      // Defensive copy here, just in case the list is taken from an existing
-      // InterledgerProtocolError.
-      this.forwardedByAddresses = interledgerProtocolError.getForwardedByAddresses().stream()
-          .collect(
-              Collectors.toList());
-      this.triggeredAt = interledgerProtocolError.getTriggeredAt();
-      this.data = interledgerProtocolError.getData();
-    }
-
-    /**
-     * Builder method to actually construct an instance of {@link InterledgerProtocolError} of the
-     * data in this builder.
-     *
-     * @return a new instance of {@link InterledgerProtocolError} built using the data in this
-     *         builder.
-     */
-    public InterledgerProtocolError build() {
-      return new Impl(this);
-    }
-
-    public Builder errorCode(final ErrorCode errorCode) {
-      this.errorCode = Objects.requireNonNull(errorCode, ""errorCode must not be null!"");
-      return this;
-    }
-
-    public Builder triggeredByAddress(final InterledgerAddress triggeredByAddress) {
-      this.triggeredByAddress = Objects
-          .requireNonNull(triggeredByAddress, ""triggeredByAddress must not be null!"");
-      return this;
-    }
-
-    public Builder forwardedByAddresses(final List<InterledgerAddress> forwardedByAddresses) {
-      this.forwardedByAddresses = Objects
-          .requireNonNull(forwardedByAddresses, ""forwardedByAddresses must not be null!"");
-      return this;
-    }
-
-    public Builder addForwardedByAddress(final InterledgerAddress forwardedByAddress) {
-      this.forwardedByAddresses
-          .add(Objects
-              .requireNonNull(forwardedByAddress, ""forwardedByAddress must not be null!""));
-      return this;
-    }
-
-
-    public Builder triggeredAt(final Instant triggeredAt) {
-      this.triggeredAt = Objects.requireNonNull(triggeredAt, ""triggeredAt must not be null!"");
-      return this;
-    }
+  @Immutable
+  abstract class AbstractInterledgerProtocolError implements InterledgerProtocolError {
 
-    public Builder data(final byte[] data) {
-      Objects.requireNonNull(data, ""data must not be null!"");
-      this.data = Optional.of(data);
-      return this;
-    }
-
-    /**
-     * A private, immutable implementation of {@link InterledgerProtocolError}. To construct an
-     * instance of this class, use an instance of {@link Builder}.
-     */
-    private static final class Impl implements InterledgerProtocolError {
-
-      private final ErrorCode errorCode;
-      private final InterledgerAddress triggeredByAddress;
-      private final List<InterledgerAddress> forwardedByAddresses;
-      private final Instant triggeredAt;
-      private final Optional<byte[]> data;
-
-      private Impl(final Builder builder) {
-        Objects.requireNonNull(builder);
-
-        this.errorCode = Objects
-            .requireNonNull(builder.errorCode, ""errorCode must not be null!"");
-        this.triggeredByAddress = Objects
-            .requireNonNull(builder.triggeredByAddress, ""triggeredByAddress must not be null!"");
-
-        // Disallow the triggeredBy from being included in the forwardedBy. The rationale is that
-        // the triggering node should not accidentally add itself to the forwarding addresses.
-        // Likewise, if that ever happens with an incoming error, then we should throw an exception.
-        builder.forwardedByAddresses.stream()
-            .filter(interledgerAddress -> interledgerAddress.equals(builder.triggeredByAddress))
-            .findFirst()
-            .ifPresent(interledgerAddress -> {
-                  // Throw an exception here because if this occurs, it indicates a packet loop, and
-                  // we don't want to simply remove the address from the ForwardedBy list and send
-                  // the packet on, because doing so would likely mean it will come back to us.
-                  throw new IllegalArgumentException(String.format(
-                      ""TriggeredByAddress \""%s\"" was found in the ForwardedByAddresses list, which ""
-                          + ""indicates an Interledger packet loop!"", triggeredByAddress));
-            }
-          );
-
-        // Defensively copy the list of addresses so that mutating the builder doesn't affect this.
-        this.forwardedByAddresses = Objects.requireNonNull(
-            builder.forwardedByAddresses.stream().collect(Collectors.toList()),
-            ""forwardedByAddresses must not be null!""
-        );
-
-        this.triggeredAt = Optional.ofNullable(builder.triggeredAt).orElse(Instant.now());
-        this.data = Objects.requireNonNull(builder.data, ""data must not be null!"");
+    @Override
+    public boolean equals(Object object) {
+      if (this == object) {
+        return true;
       }
-
-      @Override
-      public ErrorCode getErrorCode() {
-        return errorCode;
+      if (object == null || getClass() != object.getClass()) {
+        return false;
       }
 
-      @Override
-      public InterledgerAddress getTriggeredByAddress() {
-        return triggeredByAddress;
-      }
+      InterledgerProtocolError impl = (InterledgerProtocolError) object;
 
-      @Override
-      public List<InterledgerAddress> getForwardedByAddresses() {
-        return forwardedByAddresses;
+      if (!getErrorCode().equals(impl.getErrorCode())) {
+        return false;
       }
-
-      @Override
-      public Instant getTriggeredAt() {
-        return triggeredAt;
+      if (!getTriggeredByAddress().equals(impl.getTriggeredByAddress())) {
+        return false;
       }
-
-      @Override
-      public Optional<byte[]> getData() {
-        return data;
+      if (!getForwardedByAddresses().equals(impl.getForwardedByAddresses())) {
+        return false;
       }
-
-      @Override
-      public boolean equals(Object object) {
-        if (this == object) {
-          return true;
-        }
-        if (object == null || getClass() != object.getClass()) {
-          return false;
-        }
-
-        Impl impl = (Impl) object;
-
-        if (!errorCode.equals(impl.errorCode)) {
-          return false;
-        }
-        if (!triggeredByAddress.equals(impl.triggeredByAddress)) {
-          return false;
-        }
-        if (!forwardedByAddresses.equals(impl.forwardedByAddresses)) {
-          return false;
-        }
-        if (!triggeredAt.equals(impl.triggeredAt)) {
-          return false;
-        }
-
-        if (data.isPresent() && impl.getData().isPresent()) {
-          return Arrays.equals(data.get(), impl.getData().get());
-        } else {
-          return data.equals(impl.getData());
-        }
+      if (!getTriggeredAt().equals(impl.getTriggeredAt())) {
+        return false;
       }
 
-      @Override
-      public int hashCode() {
-        int result = errorCode.hashCode();
-        result = 31 * result + triggeredByAddress.hashCode();
-        result = 31 * result + forwardedByAddresses.hashCode();
-        result = 31 * result + triggeredAt.hashCode();
-        result = 31 * result + (data.isPresent() ? data.get().hashCode() : data.hashCode());
-        return result;
+      if (getData().isPresent() && impl.getData().isPresent()) {
+        return Arrays.equals(getData().get(), impl.getData().get());
+      } else {
+        return getData().equals(impl.getData());
       }
+    }
 
-      @Override
-      public String toString() {
-        return ""Impl{""
-            + ""errorCode=""
-            + errorCode
-            + "", triggeredByAddress=""
-            + triggeredByAddress
-            + "", forwardedByAddresses=""
-            + forwardedByAddresses
-            + "", triggeredAt=""
-            + triggeredAt
-            + "", data=""
-            + data
-            + '}';
-      }
+    @Override
+    public int hashCode() {
+      int result = getErrorCode().hashCode();
+      result = 31 * result + getTriggeredByAddress().hashCode();
+      result = 31 * result + getForwardedByAddresses().hashCode();
+      result = 31 * result + getTriggeredAt().hashCode();
+      result = 31 * result + (getData().isPresent()
+          ? Arrays.hashCode(getData().get()) : getData().hashCode());
+      return result;
+    }
+
+    @Override
+    public String toString() {
+      return ""InterledgerProtocolError{""",,2017-12-11 13:59:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/155909785,https://github.com/hyperledger/quilt/pull/55#discussion_r155909785,sappenin
https://github.com/hyperledger/quilt/pull/55,https://github.com/hyperledger/quilt/pull/55,This import doesn't look right -- seems like an internal class in Immutables.,fbcd61c528607d6e227eebb608b39f81a462b36d,2017-12-09 01:58:59,155909812,"@@ -1,26 +1,26 @@
 package org.interledger.ipr;
 
+import org.interledger.annotations.Immutable;
 import org.interledger.cryptoconditions.Condition;
 import org.interledger.ilp.InterledgerPayment;
 
-import java.util.Objects;
+import org.immutables.value.internal.$processor$.meta.$ValueMirrors;",,2017-12-11 13:59:50,https://api.github.com/repos/hyperledger/quilt/pulls/comments/155909812,https://github.com/hyperledger/quilt/pull/55#discussion_r155909812,sappenin
https://github.com/hyperledger/quilt/pull/49,https://github.com/hyperledger/quilt/pull/49,"Inclusion of this property in the checkstyle file breaks the Intellij Checkstyle Plugin. However, if people don't like this, I'm open to restoring the line.",62a10fd6f3096714684908f2c8acbc6e37063d6e,2017-11-14 17:44:30,150909196,"@@ -59,7 +59,7 @@
         </module>
         <module name=""NeedBraces""/>
         <module name=""LeftCurly"">
-            <property name=""maxLineLength"" value=""100""/>
+            <!--<property name=""maxLineLength"" value=""100""/>-->",5,2017-11-14 17:44:30,https://api.github.com/repos/hyperledger/quilt/pulls/comments/150909196,https://github.com/hyperledger/quilt/pull/49#discussion_r150909196,sappenin
https://github.com/hyperledger/quilt/pull/49,https://github.com/hyperledger/quilt/pull/49,"That sucks...
Why do we need it?",62a10fd6f3096714684908f2c8acbc6e37063d6e,2017-11-17 04:12:53,151599994,"@@ -59,7 +59,7 @@
         </module>
         <module name=""NeedBraces""/>
         <module name=""LeftCurly"">
-            <property name=""maxLineLength"" value=""100""/>
+            <!--<property name=""maxLineLength"" value=""100""/>-->",5,2017-11-17 04:13:12,https://api.github.com/repos/hyperledger/quilt/pulls/comments/151599994,https://github.com/hyperledger/quilt/pull/49#discussion_r151599994,adrianhopebailie
https://github.com/hyperledger/quilt/pull/49,https://github.com/hyperledger/quilt/pull/49,"See [here](http://checkstyle.sourceforge.net/apidocs/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.html):
> Checks the placement of left curly braces on types...

Though I suspect the `maxLineLength` property is not really necessary here, but not sure.

",62a10fd6f3096714684908f2c8acbc6e37063d6e,2017-11-18 16:50:09,151841672,"@@ -59,7 +59,7 @@
         </module>
         <module name=""NeedBraces""/>
         <module name=""LeftCurly"">
-            <property name=""maxLineLength"" value=""100""/>
+            <!--<property name=""maxLineLength"" value=""100""/>-->",5,2017-11-18 16:50:10,https://api.github.com/repos/hyperledger/quilt/pulls/comments/151841672,https://github.com/hyperledger/quilt/pull/49#discussion_r151841672,sappenin
https://github.com/hyperledger/quilt/pull/48,https://github.com/hyperledger/quilt/pull/48,"Inclusion of this property in the checkstyle file breaks the Intellij Checkstyle Plugin. However, if people don't like this, I'm open to restoring the line.",c5f24248fc13bc4f14210d07157e3268e30cc609,2017-11-14 17:38:42,150907646,"@@ -59,7 +59,7 @@
         </module>
         <module name=""NeedBraces""/>
         <module name=""LeftCurly"">
-            <property name=""maxLineLength"" value=""100""/>
+            <!--<property name=""maxLineLength"" value=""100""/>-->",5,2017-11-14 17:38:42,https://api.github.com/repos/hyperledger/quilt/pulls/comments/150907646,https://github.com/hyperledger/quilt/pull/48#discussion_r150907646,sappenin
