pull request url html,pull request url,body,commit_id,create at,id,diff_hunk,position,update at,url,html url,user
https://github.com/hyperledger/sawtooth-pbft/pull/125,https://github.com/hyperledger/sawtooth-pbft/pull/125,Empty step?,a620566fcea96bb4a0f2979fa5e33855ed1a30b3,2019-04-02 19:23:48,271459882,"@@ -3570,12 +3672,13 @@ mod tests {
     /// 1. The sequence number will be incremented by 1
     /// 2. The node’s phase will be reset to PrePreparing
     /// 3. The node’s mode will be set to Normal
-    /// 4. The idle timeout will be started
-    /// 5. The view will be incremented by 1 iff the node is at a forced view change
-    /// 6. The primary (and only the primary) will initialize a new block
+    /// 4.",,2019-04-02 19:32:30,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/271459882,https://github.com/hyperledger/sawtooth-pbft/pull/125#discussion_r271459882,jsmitchell
https://github.com/hyperledger/sawtooth-pbft/pull/125,https://github.com/hyperledger/sawtooth-pbft/pull/125,Fixed,a620566fcea96bb4a0f2979fa5e33855ed1a30b3,2019-04-02 19:32:41,271462881,"@@ -3570,12 +3672,13 @@ mod tests {
     /// 1. The sequence number will be incremented by 1
     /// 2. The node’s phase will be reset to PrePreparing
     /// 3. The node’s mode will be set to Normal
-    /// 4. The idle timeout will be started
-    /// 5. The view will be incremented by 1 iff the node is at a forced view change
-    /// 6. The primary (and only the primary) will initialize a new block
+    /// 4.",,2019-04-02 19:32:42,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/271462881,https://github.com/hyperledger/sawtooth-pbft/pull/125#discussion_r271462881,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/120,https://github.com/hyperledger/sawtooth-pbft/pull/120,s/note_enough_votes/not_enough_votes/,d3bc1ad7ffdf810b9664f9b955e7d416d36fc8ff,2019-03-22 19:52:48,268317757,"@@ -1702,149 +1748,2913 @@ mod tests {
         )
     }
 
-    fn panic_with_err(e: PbftError) {
-        panic!(""{}"", e);
+    /// Create a validly-signed PbftSignedVote
+    fn mock_vote(
+        msg_type: PbftMessageType,
+        view: u64,
+        seq_num: u64,
+        block_id: BlockId,
+        signer: &KeyPair,
+    ) -> PbftSignedVote {
+        let info = PbftMessageInfo::new_from(msg_type, view, seq_num, signer.pub_key.clone());
+        let mut msg = PbftMessage::new();
+        msg.set_info(info);
+        msg.set_block_id(block_id);
+        let msg_bytes = msg
+            .write_to_bytes()
+            .expect(""Failed to write msg to bytes for mock vote"");
+
+        let mut header = ConsensusPeerMessageHeader::new();
+        header.set_signer_id(signer.pub_key.clone());
+        header.set_content_sha512(hash_sha512(&msg_bytes));
+
+        let header_bytes = header
+            .write_to_bytes()
+            .expect(""Failed to write header to bytes"");
+        let header_signature = hex::decode(
+            create_context(""secp256k1"")
+                .expect(""Failed to create context"")
+                .sign(
+                    &header_bytes,
+                    &Secp256k1PrivateKey::from_hex(&hex::encode(signer.priv_key.clone()))
+                        .expect(""Failed to create private key from hex""),
+                )
+                .expect(""Failed to sign header""),
+        )
+        .expect(""Failed to decode signed header"");
+
+        let mut vote = PbftSignedVote::new();
+        vote.set_header_bytes(header_bytes);
+        vote.set_header_signature(header_signature);
+        vote.set_message_bytes(msg_bytes.to_vec());
+        vote
+    }
+
+    /// Create a PbftNewView
+    fn mock_new_view(
+        view: u64,
+        seq_num: u64,
+        signer: &KeyPair,
+        votes: Vec<PbftSignedVote>,
+    ) -> PbftNewView {
+        let mut new_view = PbftNewView::new();
+        new_view.set_info(PbftMessageInfo::new_from(
+            PbftMessageType::NewView,
+            view,
+            seq_num,
+            signer.pub_key.clone(),
+        ));
+        new_view.set_view_changes(RepeatedField::from(votes));
+        new_view
     }
 
-    /// Make sure that receiving a `BlockNew` update works as expected for block #1
+    /// Create a PbftSeal
+    fn mock_seal(
+        view: u64,
+        seq_num: u64,
+        block_id: BlockId,
+        signer: &KeyPair,
+        votes: Vec<PbftSignedVote>,
+    ) -> PbftSeal {
+        let mut seal = PbftSeal::new();
+        seal.set_info(PbftMessageInfo::new_from(
+            PbftMessageType::Seal,
+            view,
+            seq_num,
+            signer.pub_key.clone(),
+        ));
+        seal.set_block_id(block_id);
+        seal.set_commit_votes(RepeatedField::from(votes));
+        seal
+    }
+
+    /// This test will verify that when the `PbftNode::new` method is called, it will return a
+    /// `PbftNode` after performing the following actions:
+    ///
+    /// 1. Add the chain head to the log
+    /// 2. Initialize a new block by calling the `Service::initialize_block` method if the node is
+    ///    the primary
     #[test]
-    fn block_new_initial() {
-        // NOTE: Special case for primary node
-        let (mut node0, mut state0, _) = mock_node(&mock_config(4), vec![0], mock_block(0));
-        node0.on_block_new(mock_block(1), &mut state0).unwrap();
-        assert_eq!(state0.phase, PbftPhase::PrePreparing);
-        assert_eq!(state0.seq_num, 1);
-
-        // Try the next block
-        let (mut node1, mut state1, _) = mock_node(&mock_config(4), vec![1], mock_block(0));
-        node1
-            .on_block_new(mock_block(1), &mut state1)
-            .unwrap_or_else(panic_with_err);
-        assert_eq!(state1.phase, PbftPhase::PrePreparing);
-    }
-
-    /// Make sure that a valid `PrePrepare` is accepted
+    fn test_node_init() {
+        // Verify chain head is added to the log and primary calls Service::initialize_block()
+        let head = mock_block(0);
+        let (node0, _, service0) = mock_node(&mock_config(4), vec![0], head.clone());
+        assert!(node0.msg_log.get_block_with_id(&head.block_id).is_some());
+        assert!(service0.was_called_with_args(stringify_func_call!(
+            ""initialize_block"",
+            None as Option<BlockId>
+        )));
+
+        // Verify non-primary does not call Service::initialize_block()
+        let (_, _, service1) = mock_node(&mock_config(4), vec![1], head.clone());
+        assert!(!service1.was_called(""initialize_block""));
+    }
+
+    /// To build a valid consensus seal or a valid `NewView` message, nodes must be able to convert
+    /// a series of `ParsedMessage`s into `PbftSignedVote`s that can be included in the protobuf
+    /// messages. The `PbftNode::signed_votes_from_messages` method is responsible for constructing
+    /// a `RepeatedField` protobuf struct that can be placed directly into the `PbftSeal` and
+    /// `PbftNewView` protobuf messages.
     #[test]
-    fn test_pre_prepare() {
-        let (mut node0, mut state0, _) = mock_node(&mock_config(4), vec![0], mock_block(0));
+    fn test_vote_list_construction() {
+        // Create 3 ParsedMessages with different messages, header bytes, and header signatures
+        let mut msg1 = mock_msg(PbftMessageType::Commit, 0, 1, vec![0], vec![1], false);
+        msg1.header_bytes = vec![0, 1, 2];
+        msg1.header_signature = vec![3, 4, 5];
+        let mut msg2 = mock_msg(PbftMessageType::Commit, 0, 1, vec![1], vec![1], false);
+        msg2.header_bytes = vec![6, 7, 8];
+        msg2.header_signature = vec![9, 10, 11];
+        let mut msg3 = mock_msg(PbftMessageType::Commit, 0, 1, vec![2], vec![1], false);
+        msg3.header_bytes = vec![12, 13, 14];
+        msg3.header_signature = vec![15, 16, 17];
+        let msgs = vec![&msg1, &msg2, &msg3];
+
+        // Create the PbftSignedVotes
+        let votes = PbftNode::signed_votes_from_messages(&msgs).into_vec();
+
+        // Verify that the votes match the original messages
+        msgs.iter().zip(votes.iter()).for_each(|(msg, vote)| {
+            assert_eq!(msg.message_bytes, vote.message_bytes);
+            assert_eq!(msg.header_bytes, vote.header_bytes);
+            assert_eq!(msg.header_signature, vote.header_signature);
+        });
+    }
 
-        // Add block to the log
-        node0.msg_log.add_block(mock_block(1));
+    /// In order to verify that a consensus seal or a `NewView` is correct, nodes must be able to
+    /// verify each of the signed votes that are contained in the seal/`NewView`. `PbftSignedVote`s
+    /// are verified by the `PbftNode::verify_vote` method, which takes as arguments the vote
+    /// itself, the expected vote type, and a closure that evaluates some arbitrary criteria. The
+    /// `verify_vote` method should make sure the vote’s type matches the expected type, the header
+    /// is properly signed, the header’s signer matches the message’s signer, the message hash is
+    /// correct, and that it meets the criteria specified in the closure.
+    ///
+    /// This test verifies that the `verify_vote` method works correctly by testing all cases where
+    /// it should fail and a case where it should succeed.
+    #[test]
+    fn test_vote_verification() {
+        // Generate a public/private key pair
+        let key_pair = mock_signer_network(1).remove(0);
 
-        // Add PrePrepare to log
-        let valid_msg = mock_msg(PbftMessageType::PrePrepare, 0, 1, vec![0], vec![1]);
-        node0
-            .handle_pre_prepare(valid_msg.clone(), &mut state0)
-            .unwrap_or_else(panic_with_err);
+        // Create a validly-signed Commit vote
+        let valid_vote = mock_vote(PbftMessageType::Commit, 0, 1, vec![1], &key_pair);
 
-        // Verify it worked
+        // Test verification of a valid vote
         assert_eq!(
-            node0
-                .msg_log
-                .get_messages_of_type_seq_view_block(
-                    PbftMessageType::PrePrepare,
-                    valid_msg.info().get_seq_num(),
-                    valid_msg.info().get_view(),
-                    &vec![1],
+            key_pair.pub_key,
+            PbftNode::verify_vote(&valid_vote, PbftMessageType::Commit, |_| Ok(()))
+                .expect(""Valid vote was determined to be invalid"")
+        );
+
+        // Test verification of a vote with invalid type
+        assert!(
+            PbftNode::verify_vote(&valid_vote, PbftMessageType::ViewChange, |_| Ok(())).is_err()
+        );
+
+        // Test verification of a vote that doesn't meet the validation_criteria
+        assert!(
+            PbftNode::verify_vote(&valid_vote, PbftMessageType::Commit, |_| Err(
+                PbftError::InvalidMessage("""".into())
+            ))
+            .is_err()
+        );
+
+        // Test verification of a vote with an invalid header signature
+        let mut invalid_header_sig = valid_vote.clone();
+        invalid_header_sig.set_header_signature(vec![0]);
+        assert!(PbftNode::verify_vote(
+            &invalid_header_sig,
+            PbftMessageType::ViewChange,
+            |_| Ok(())
+        )
+        .is_err());
+
+        // Test verification of a vote with an invalid message hash
+        let mut invalid_msg_hash = valid_vote.clone();
+        invalid_msg_hash.set_message_bytes(vec![0]);
+        assert!(
+            PbftNode::verify_vote(&invalid_msg_hash, PbftMessageType::Commit, |_| Ok(())).is_err()
+        );
+
+        // Test verification of a vote where the header's signer doesn't match the message's
+        // signers (the vote signer didn't create the message)
+        let bad_key_pair = mock_signer_network(1).remove(0);
+
+        let other_nodes_message = mock_msg(
+            PbftMessageType::Commit,
+            0,
+            1,
+            key_pair.pub_key.clone(),
+            vec![1],
+            false,
+        );
+
+        let mut header = ConsensusPeerMessageHeader::new();
+        header.set_signer_id(bad_key_pair.pub_key.clone());
+        header.set_content_sha512(hash_sha512(&other_nodes_message.message_bytes));
+        let header_bytes = header
+            .write_to_bytes()
+            .expect(""Failed to write header to bytes"");
+        let header_signature = hex::decode(
+            create_context(""secp256k1"")
+                .expect(""Failed to create context"")
+                .sign(
+                    &header_bytes,
+                    &Secp256k1PrivateKey::from_hex(&hex::encode(bad_key_pair.priv_key.clone()))
+                        .expect(""Failed to create private key from hex""),
                 )
-                .len(),
-            1
+                .expect(""Failed to sign header""),
+        )
+        .expect(""Failed to decode signed header"");
+
+        let mut mismatched_signer = PbftSignedVote::new();
+        mismatched_signer.set_header_bytes(header_bytes);
+        mismatched_signer.set_header_signature(header_signature);
+        mismatched_signer.set_message_bytes(other_nodes_message.message_bytes.clone());
+
+        assert!(
+            PbftNode::verify_vote(&mismatched_signer, PbftMessageType::Commit, |_| Ok(())).is_err()
+        );
+    }
+
+    /// Nodes must be able to verify `NewView` messages to ensure that view changes are valid. To
+    /// do this, nodes use the `PbftNode::verify_new_view` method. A `NewView` message is valid if:
+    ///
+    /// 1. It is for a future view (should never view change backwards)
+    /// 2. It is from the primary for the targeted view
+    /// 3. All of the votes are valid `ViewChange` messages as determined by the `verify_vote`
+    ///    method and the criteria that each vote’s view must match the `NewView` message’s view
+    /// 4. All of the vote’s are from nodes that are members of the network
+    /// 5. None of the votes are from the new primary that sent this `NewView` message (the
+    ///    `NewView` message is an implicit vote from the new primary, so including its own vote
+    ///    would be double-voting)
+    /// 6. There are `2f` votes (again, this is really `2f + 1` since the `NewView` message itself
+    ///    is an implicit vote)
+    ///
+    /// This test ensures that the `verify_new_view` method properly checks the validity of
+    /// `NewView` messages by checking cases where it should fail and a case where it should
+    /// succeed.
+    #[test]
+    fn test_new_view_verification() {
+        // Create signing keys for a new network and instantiate a new node on the network
+        let key_pairs = mock_signer_network(4);
+        let (mut node, mut state, _) = mock_node(
+            &mock_config_from_signer_network(&key_pairs),
+            key_pairs[0].pub_key.clone(),
+            mock_block(0),
+        );
+
+        // Test verification of a valid NewView
+        let valid_msg = mock_new_view(
+            1,
+            1,
+            &key_pairs[1],
+            (2..4)
+                .map(|i| mock_vote(PbftMessageType::ViewChange, 1, 1, vec![], &key_pairs[i]))
+                .collect::<Vec<_>>(),
+        );
+        assert!(node.verify_new_view(&valid_msg, &mut state).is_ok());
+
+        // Test verification of a NewView from a previous view
+        let previous_view = mock_new_view(
+            0,
+            1,
+            &key_pairs[1],
+            (2..4)
+                .map(|i| mock_vote(PbftMessageType::ViewChange, 0, 1, vec![], &key_pairs[i]))
+                .collect::<Vec<_>>(),
+        );
+        assert!(node.verify_new_view(&previous_view, &mut state).is_err());
+
+        // Test verification of a NewView that is not from the primary for that view
+        let not_from_primary = mock_new_view(
+            1,
+            1,
+            &key_pairs[0],
+            (2..4)
+                .map(|i| mock_vote(PbftMessageType::ViewChange, 1, 1, vec![], &key_pairs[i]))
+                .collect::<Vec<_>>(),
+        );
+        assert!(node.verify_new_view(&not_from_primary, &mut state).is_err());
+
+        // Test verification of a NewView where one of the votes isn't a ViewChange
+        let non_view_change_vote = mock_new_view(
+            1,
+            1,
+            &key_pairs[1],
+            vec![
+                mock_vote(PbftMessageType::ViewChange, 1, 1, vec![], &key_pairs[2]),
+                mock_vote(PbftMessageType::Commit, 1, 1, vec![], &key_pairs[3]),
+            ],
+        );
+        assert!(node
+            .verify_new_view(&non_view_change_vote, &mut state)
+            .is_err());
+
+        // Test verification of a NewView that contains a ViewChange vote for a different view
+        let vote_for_different_view = mock_new_view(
+            1,
+            1,
+            &key_pairs[1],
+            vec![
+                mock_vote(PbftMessageType::ViewChange, 1, 1, vec![], &key_pairs[2]),
+                mock_vote(PbftMessageType::ViewChange, 0, 1, vec![], &key_pairs[3]),
+            ],
+        );
+        assert!(node
+            .verify_new_view(&vote_for_different_view, &mut state)
+            .is_err());
+
+        // Test verification of a NewView that contains a vote from an unknown peer
+        let vote_from_unknown_peer = mock_new_view(
+            1,
+            1,
+            &key_pairs[1],
+            vec![
+                mock_vote(PbftMessageType::ViewChange, 1, 1, vec![], &key_pairs[2]),
+                mock_vote(
+                    PbftMessageType::ViewChange,
+                    1,
+                    1,
+                    vec![],
+                    &mock_signer_network(1).remove(0),
+                ),
+            ],
+        );
+        assert!(node
+            .verify_new_view(&vote_from_unknown_peer, &mut state)
+            .is_err());
+
+        // Test verification of a NewView that contains a vote from the new primary
+        let vote_from_primary = mock_new_view(
+            1,
+            1,
+            &key_pairs[1],
+            (1..3)
+                .map(|i| mock_vote(PbftMessageType::ViewChange, 1, 1, vec![], &key_pairs[i]))
+                .collect::<Vec<_>>(),
+        );
+        assert!(node
+            .verify_new_view(&vote_from_primary, &mut state)
+            .is_err());
+
+        // Test verification of a NewView that does not contain enough votes
+        let insufficient_votes = mock_new_view(
+            1,
+            1,
+            &key_pairs[1],
+            vec![mock_vote(
+                PbftMessageType::ViewChange,
+                1,
+                1,
+                vec![],
+                &key_pairs[2],
+            )],
+        );
+        assert!(node
+            .verify_new_view(&insufficient_votes, &mut state)
+            .is_err());
+    }
+
+    /// Nodes must be able to verify consensus seals to ensure that committed blocks contain valid
+    /// seals for future verification and to perform catch-up. To do this, nodes use the
+    /// `PbftNode::verify_consensus_seal` method. A consensus seal is valid if:
+    ///
+    /// 1. All of the votes are valid Commit messages as determined by the `verify_vote` method and
+    ///    the criteria that each vote’s:
+    ///    a. Block ID must match the consensus seal’s block ID
+    ///    b. View must match the consensus seal’s view
+    ///    c. Sequence number must match the consensus seal’s sequence number
+    /// 2. The seal’s signer (as determined by the seal’s `signer_id`) and all of the vote’s
+    ///    signers are nodes that were members of the network at the time the block was voted on
+    ///    (this is checked by getting the on-chain list of peers for the block previous to the one
+    ///    the seal verifies, as specified in the `previous_id` argument to the
+    ///    `verify_consensus_seal` method)
+    /// 3. None of the votes are from the seal’s signer (producing a seal is an implicit vote from
+    ///    the node that constructed it, so including its own vote would be double-voting)
+    /// 4. There are `2f` votes (this is really `2f + 1` voters since the consensus seal itself is
+    ///    an implicit vote)
+    ///
+    /// This test ensures that the `verify_consensus_seal` method properly checks the validity of
+    /// consensus seals by checking cases where it should fail and a case where it should succeed.
+    #[test]
+    fn test_consensus_seal_verification() {
+        // Create signing keys for a new network and instantiate a new node on the network
+        let key_pairs = mock_signer_network(4);
+        let (mut node, mut state, service) = mock_node(
+            &mock_config_from_signer_network(&key_pairs),
+            key_pairs[0].pub_key.clone(),
+            mock_block(0),
+        );
+
+        // Set the MockService to return a different peers list for block_id=[1]
+        let mut block_1_settings = HashMap::new();
+        block_1_settings.insert(
+            ""sawtooth.consensus.pbft.peers"".to_string(),
+            serde_json::to_string(
+                &vec![
+                    key_pairs[0].pub_key.clone(),
+                    key_pairs[2].pub_key.clone(),
+                    key_pairs[3].pub_key.clone(),
+                    mock_signer_network(1).remove(0).pub_key,
+                ]
+                .iter()
+                .map(hex::encode)
+                .collect::<Vec<_>>(),
+            )
+            .unwrap(),
+        );
+        service
+            .settings
+            .borrow_mut()
+            .insert(vec![1], block_1_settings);
+
+        // Test verification of a valid seal/previous_id
+        let valid_seal = mock_seal(
+            0,
+            1,
+            vec![1],
+            &key_pairs[0],
+            (1..3)
+                .map(|i| mock_vote(PbftMessageType::Commit, 0, 1, vec![1], &key_pairs[i]))
+                .collect::<Vec<_>>(),
+        );
+        assert!(node
+            .verify_consensus_seal(&valid_seal, vec![0], &mut state)
+            .is_ok());
+
+        // Test verification of a valid seal that has a vote from a node not in the previous block
+        // (using previous_id=[1] gets the list of peers set above)
+        let vote_not_in_prev_block = mock_seal(
+            0,
+            2,
+            vec![2],
+            &key_pairs[0],
+            (1..3)
+                .map(|i| mock_vote(PbftMessageType::Commit, 0, 2, vec![2], &key_pairs[i]))
+                .collect::<Vec<_>>(),
+        );
+        assert!(node
+            .verify_consensus_seal(&vote_not_in_prev_block, vec![1], &mut state)
+            .is_err());
+
+        // Test verification of a seal that contains a vote that is not a Commit
+        let vote_not_commit = mock_seal(
+            0,
+            1,
+            vec![1],
+            &key_pairs[0],
+            vec![
+                mock_vote(PbftMessageType::Commit, 0, 1, vec![1], &key_pairs[1]),
+                mock_vote(PbftMessageType::ViewChange, 0, 1, vec![1], &key_pairs[2]),
+            ],
+        );
+        assert!(node
+            .verify_consensus_seal(&vote_not_commit, vec![0], &mut state)
+            .is_err());
+
+        // Test verification of a seal that contains a vote for a different block
+        let vote_different_block = mock_seal(
+            0,
+            1,
+            vec![1],
+            &key_pairs[0],
+            vec![
+                mock_vote(PbftMessageType::Commit, 0, 1, vec![1], &key_pairs[1]),
+                mock_vote(PbftMessageType::Commit, 0, 1, vec![2], &key_pairs[2]),
+            ],
+        );
+        assert!(node
+            .verify_consensus_seal(&vote_different_block, vec![0], &mut state)
+            .is_err());
+
+        // Test verification of a seal that contains a vote from a different view
+        let vote_different_view = mock_seal(
+            0,
+            1,
+            vec![1],
+            &key_pairs[0],
+            vec![
+                mock_vote(PbftMessageType::Commit, 0, 1, vec![1], &key_pairs[1]),
+                mock_vote(PbftMessageType::Commit, 1, 1, vec![1], &key_pairs[2]),
+            ],
+        );
+        assert!(node
+            .verify_consensus_seal(&vote_different_view, vec![0], &mut state)
+            .is_err());
+
+        // Test verification of a seal that contains a vote from a different sequence number
+        let vote_different_seq_num = mock_seal(
+            0,
+            1,
+            vec![1],
+            &key_pairs[0],
+            vec![
+                mock_vote(PbftMessageType::Commit, 0, 1, vec![1], &key_pairs[1]),
+                mock_vote(PbftMessageType::Commit, 0, 2, vec![1], &key_pairs[2]),
+            ],
+        );
+        assert!(node
+            .verify_consensus_seal(&vote_different_seq_num, vec![0], &mut state)
+            .is_err());
+
+        // Test verification of a seal that contains a vote from the seal's signer
+        let vote_from_signer = mock_seal(
+            0,
+            1,
+            vec![1],
+            &key_pairs[0],
+            (0..2)
+                .map(|i| mock_vote(PbftMessageType::Commit, 0, 2, vec![2], &key_pairs[i]))
+                .collect::<Vec<_>>(),
+        );
+        assert!(node
+            .verify_consensus_seal(&vote_from_signer, vec![0], &mut state)
+            .is_err());
+
+        // Test verification of a seal that doesn't contain enough votes
+        let note_enough_votes = mock_seal(",,2019-03-22 20:11:27,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/268317757,https://github.com/hyperledger/sawtooth-pbft/pull/120#discussion_r268317757,jsmitchell
https://github.com/hyperledger/sawtooth-pbft/pull/115,https://github.com/hyperledger/sawtooth-pbft/pull/115,"You don't need to clone this, since you can compare it as a reference.",e7b4ba2112ead90e5241226aadd81e7d881b8dad,2019-03-04 20:03:04,262220924,"@@ -151,16 +151,19 @@ fn handle_update(
             info!(""Received BlockValid or BlockInvalid message; ignoring"");
         }
         Ok(Update::BlockCommit(block_id)) => node.on_block_commit(block_id, state)?,
-        Ok(Update::PeerMessage(message, sender_id)) => {
-            // Since the signer ID is verified by the validator, we can use it to ensure that this
-            // message was generated by the sender
+        Ok(Update::PeerMessage(message, _)) => {
+            // Since the signer ID in the PeerMessageHeader is verified by the validator, it can be
+            // ensured that the PbftMessage was in fact created and signed by the node that it
+            // claims to be from by comparing the header's signer and the PbftMessage's signer
+            let verified_signer_id = message.header.signer_id.clone();",11,2019-03-04 20:03:10,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/262220924,https://github.com/hyperledger/sawtooth-pbft/pull/115#discussion_r262220924,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/115,https://github.com/hyperledger/sawtooth-pbft/pull/115,The message is moved into `ParsedMessage::from_peer_message` though,e7b4ba2112ead90e5241226aadd81e7d881b8dad,2019-03-04 20:13:09,262224431,"@@ -151,16 +151,19 @@ fn handle_update(
             info!(""Received BlockValid or BlockInvalid message; ignoring"");
         }
         Ok(Update::BlockCommit(block_id)) => node.on_block_commit(block_id, state)?,
-        Ok(Update::PeerMessage(message, sender_id)) => {
-            // Since the signer ID is verified by the validator, we can use it to ensure that this
-            // message was generated by the sender
+        Ok(Update::PeerMessage(message, _)) => {
+            // Since the signer ID in the PeerMessageHeader is verified by the validator, it can be
+            // ensured that the PbftMessage was in fact created and signed by the node that it
+            // claims to be from by comparing the header's signer and the PbftMessage's signer
+            let verified_signer_id = message.header.signer_id.clone();",11,2019-03-04 20:13:09,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/262224431,https://github.com/hyperledger/sawtooth-pbft/pull/115#discussion_r262224431,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/115,https://github.com/hyperledger/sawtooth-pbft/pull/115,"Yeah, that makes sense.",e7b4ba2112ead90e5241226aadd81e7d881b8dad,2019-03-04 20:27:06,262228912,"@@ -151,16 +151,19 @@ fn handle_update(
             info!(""Received BlockValid or BlockInvalid message; ignoring"");
         }
         Ok(Update::BlockCommit(block_id)) => node.on_block_commit(block_id, state)?,
-        Ok(Update::PeerMessage(message, sender_id)) => {
-            // Since the signer ID is verified by the validator, we can use it to ensure that this
-            // message was generated by the sender
+        Ok(Update::PeerMessage(message, _)) => {
+            // Since the signer ID in the PeerMessageHeader is verified by the validator, it can be
+            // ensured that the PbftMessage was in fact created and signed by the node that it
+            // claims to be from by comparing the header's signer and the PbftMessage's signer
+            let verified_signer_id = message.header.signer_id.clone();",11,2019-03-04 20:27:06,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/262228912,https://github.com/hyperledger/sawtooth-pbft/pull/115#discussion_r262228912,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/112,https://github.com/hyperledger/sawtooth-pbft/pull/112,Should this be Cargill and 2019?,865121bed57c44f437e373423895260127e91c4d,2019-03-01 15:20:30,261642267,"@@ -0,0 +1,77 @@
+/*
+ * Copyright 2018 Bitwise IO, Inc.",,2019-03-04 21:12:43,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/261642267,https://github.com/hyperledger/sawtooth-pbft/pull/112#discussion_r261642267,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/112,https://github.com/hyperledger/sawtooth-pbft/pull/112,"double ""a""",865121bed57c44f437e373423895260127e91c4d,2019-03-01 15:23:00,261643355,"@@ -268,3 +268,161 @@ impl From<PbftMessageType> for String {
         format!(""{:?}"", msg_type)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    /// PBFT-04: A valid ParsedMessage can be constructed from a PbftMessage, a a PbftSignedVote,",,2019-03-04 21:12:43,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/261643355,https://github.com/hyperledger/sawtooth-pbft/pull/112#discussion_r261643355,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/112,https://github.com/hyperledger/sawtooth-pbft/pull/112,I don't think we should include the document identifier in the comments. The comment should describe the test case as required without needing to reference something external.,865121bed57c44f437e373423895260127e91c4d,2019-03-01 18:52:55,261717840,"@@ -207,103 +207,111 @@ impl PbftLog {
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::config;
-    use crate::protos::pbft_message::PbftMessage;
-    use sawtooth_sdk::consensus::engine::PeerId;
+    use crate::test_helpers::*;
 
-    /// Create a PbftMessage, given its type, view, sequence number, and who it's from
-    fn make_msg(
-        msg_type: PbftMessageType,
-        view: u64,
-        seq_num: u64,
-        signer_id: PeerId,
-    ) -> ParsedMessage {
-        let mut info = PbftMessageInfo::new();
-        info.set_msg_type(String::from(msg_type));
-        info.set_view(view);
-        info.set_seq_num(seq_num);
-        info.set_signer_id(Vec::<u8>::from(signer_id.clone()));
-
-        let mut msg = PbftMessage::new();
-        msg.set_info(info);
-        msg.set_block_id(vec![]);
-
-        ParsedMessage::from_pbft_message(msg).expect(""Failed to parse PbftMessage"")
-    }
-
-    /// Obtain the PeerId for node `which`
-    fn get_peer_id(cfg: &PbftConfig, which: usize) -> PeerId {
-        cfg.peers[which].clone()
-    }
-
-    /// Test that adding one message works as expected
+    /// PBFT-02: The log properly stores and retrieves blocks",,2019-03-04 21:12:43,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/261717840,https://github.com/hyperledger/sawtooth-pbft/pull/112#discussion_r261717840,jsmitchell
https://github.com/hyperledger/sawtooth-pbft/pull/112,https://github.com/hyperledger/sawtooth-pbft/pull/112,"@vaporos had suggested that we include the identifiers so it's easy to reference the motivation/intent of the test. Shawn, what are your thoughts?",865121bed57c44f437e373423895260127e91c4d,2019-03-01 22:09:19,261774308,"@@ -207,103 +207,111 @@ impl PbftLog {
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::config;
-    use crate::protos::pbft_message::PbftMessage;
-    use sawtooth_sdk::consensus::engine::PeerId;
+    use crate::test_helpers::*;
 
-    /// Create a PbftMessage, given its type, view, sequence number, and who it's from
-    fn make_msg(
-        msg_type: PbftMessageType,
-        view: u64,
-        seq_num: u64,
-        signer_id: PeerId,
-    ) -> ParsedMessage {
-        let mut info = PbftMessageInfo::new();
-        info.set_msg_type(String::from(msg_type));
-        info.set_view(view);
-        info.set_seq_num(seq_num);
-        info.set_signer_id(Vec::<u8>::from(signer_id.clone()));
-
-        let mut msg = PbftMessage::new();
-        msg.set_info(info);
-        msg.set_block_id(vec![]);
-
-        ParsedMessage::from_pbft_message(msg).expect(""Failed to parse PbftMessage"")
-    }
-
-    /// Obtain the PeerId for node `which`
-    fn get_peer_id(cfg: &PbftConfig, which: usize) -> PeerId {
-        cfg.peers[which].clone()
-    }
-
-    /// Test that adding one message works as expected
+    /// PBFT-02: The log properly stores and retrieves blocks",,2019-03-04 21:12:43,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/261774308,https://github.com/hyperledger/sawtooth-pbft/pull/112#discussion_r261774308,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/112,https://github.com/hyperledger/sawtooth-pbft/pull/112,"After a conversation with Shawn, we agreed to remove external references from the unit tests in favor of including more detailed information with the tests.",865121bed57c44f437e373423895260127e91c4d,2019-03-04 16:35:06,262141231,"@@ -207,103 +207,111 @@ impl PbftLog {
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::config;
-    use crate::protos::pbft_message::PbftMessage;
-    use sawtooth_sdk::consensus::engine::PeerId;
+    use crate::test_helpers::*;
 
-    /// Create a PbftMessage, given its type, view, sequence number, and who it's from
-    fn make_msg(
-        msg_type: PbftMessageType,
-        view: u64,
-        seq_num: u64,
-        signer_id: PeerId,
-    ) -> ParsedMessage {
-        let mut info = PbftMessageInfo::new();
-        info.set_msg_type(String::from(msg_type));
-        info.set_view(view);
-        info.set_seq_num(seq_num);
-        info.set_signer_id(Vec::<u8>::from(signer_id.clone()));
-
-        let mut msg = PbftMessage::new();
-        msg.set_info(info);
-        msg.set_block_id(vec![]);
-
-        ParsedMessage::from_pbft_message(msg).expect(""Failed to parse PbftMessage"")
-    }
-
-    /// Obtain the PeerId for node `which`
-    fn get_peer_id(cfg: &PbftConfig, which: usize) -> PeerId {
-        cfg.peers[which].clone()
-    }
-
-    /// Test that adding one message works as expected
+    /// PBFT-02: The log properly stores and retrieves blocks",,2019-03-04 21:12:43,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/262141231,https://github.com/hyperledger/sawtooth-pbft/pull/112#discussion_r262141231,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/102,https://github.com/hyperledger/sawtooth-pbft/pull/102,"typo in commit "" sequencen""",bab09698646018ebbc3a3ac4af538c325cfafa13,2019-02-26 16:04:30,260358508,"@@ -119,8 +119,8 @@ impl PbftLog {
 
     /// Check if the log has a PrePrepare at the node's current view and sequence number that
     /// matches the given block ID
-    pub fn has_pre_prepare(&self, state: &PbftState, block_id: &[u8]) -> bool {
-        self.get_messages_of_type_seq_view(PbftMessageType::PrePrepare, state.seq_num, state.view)
+    pub fn has_pre_prepare(&self, seq_num: u64, view: u64, block_id: &[u8]) -> bool {",6,2019-02-26 16:16:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/260358508,https://github.com/hyperledger/sawtooth-pbft/pull/102#discussion_r260358508,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/101,https://github.com/hyperledger/sawtooth-pbft/pull/101,"""...responsible for garbage collection of the log."" sounds better IMO",7a452fb69126f5e171dbb84734d018c7e08e75f4,2019-02-22 15:38:20,259392757,"@@ -241,11 +241,11 @@ two modes:
 
 .. note::
 
-   The original PBFT algorithm also defines a Checkpointing (garbage collection)
-   mode to prune log messages after a certain number of blocks have been
-   committed. Sawtooth PBFT does not implement checkpointing. Instead, it uses
-   the on-chain setting ``sawtooth.consensus.pbft.max_log_size`` to trigger
-   log pruning on each node.
+   The original PBFT definition includes a checkpointing procedure that is
+   responsible for log message garbage collection. Sawtooth PBFT does not",,2019-02-26 16:42:57,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/259392757,https://github.com/hyperledger/sawtooth-pbft/pull/101#discussion_r259392757,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/101,https://github.com/hyperledger/sawtooth-pbft/pull/101,"Like above, ""garbage collection of log messages"" should be re-worded. Kind of sounds like you're talking about cleaning up the logging.",7a452fb69126f5e171dbb84734d018c7e08e75f4,2019-02-22 15:39:49,259393457,"@@ -367,6 +367,26 @@ with the validators. N1 is the primary node; N2, N3, and N4 are secondary nodes.
     :alt: PBFT messages passed during normal operation
 
 
+.. _log-pruning-label:
+
+Log Pruning in Normal Mode
+--------------------------
+
+Sawtooth PBFT does not implement a checkpointing procedure (garbage collection
+for log messages). Instead, each node cleans the log periodically during normal",,2019-02-26 16:42:57,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/259393457,https://github.com/hyperledger/sawtooth-pbft/pull/101#discussion_r259393457,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/101,https://github.com/hyperledger/sawtooth-pbft/pull/101,"""Keep blocks and messages that are for the sequence number of the block that was just committed or higher"" sounds more understandable (to me at least)",7a452fb69126f5e171dbb84734d018c7e08e75f4,2019-02-25 19:07:10,259973653,"@@ -367,6 +367,26 @@ with the validators. N1 is the primary node; N2, N3, and N4 are secondary nodes.
     :alt: PBFT messages passed during normal operation
 
 
+.. _log-pruning-label:
+
+Log Pruning in Normal Mode
+--------------------------
+
+Sawtooth PBFT does not implement a checkpointing procedure (garbage collection
+for log messages). Instead, each node cleans the log periodically during normal
+operation.
+
+Log size is controlled by a configurable setting, as determined by the on-chain
+setting ``sawtooth.consensus.pbft.max_log_size``. When a block is committed,
+each node compares the size of its log against the maximum size. If the log
+exceeds this value, Sawtooth PBFT uses these rules to prune the log:
+
+- Keep blocks and messages for that sequence number (for the block that",,2019-02-26 16:42:57,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/259973653,https://github.com/hyperledger/sawtooth-pbft/pull/101#discussion_r259973653,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/101,https://github.com/hyperledger/sawtooth-pbft/pull/101,"Alas, ""higher"" is too far away from ""sequence number"" to be totally clear.  I'll try to find wording that works for us both.",7a452fb69126f5e171dbb84734d018c7e08e75f4,2019-02-25 22:49:51,260053854,"@@ -367,6 +367,26 @@ with the validators. N1 is the primary node; N2, N3, and N4 are secondary nodes.
     :alt: PBFT messages passed during normal operation
 
 
+.. _log-pruning-label:
+
+Log Pruning in Normal Mode
+--------------------------
+
+Sawtooth PBFT does not implement a checkpointing procedure (garbage collection
+for log messages). Instead, each node cleans the log periodically during normal
+operation.
+
+Log size is controlled by a configurable setting, as determined by the on-chain
+setting ``sawtooth.consensus.pbft.max_log_size``. When a block is committed,
+each node compares the size of its log against the maximum size. If the log
+exceeds this value, Sawtooth PBFT uses these rules to prune the log:
+
+- Keep blocks and messages for that sequence number (for the block that",,2019-02-26 16:42:57,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/260053854,https://github.com/hyperledger/sawtooth-pbft/pull/101#discussion_r260053854,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/96,https://github.com/hyperledger/sawtooth-pbft/pull/96,should the next number be decremented? ,452cf28c8727217e968f23bd9507642105db0095,2019-02-25 14:46:04,259856035,"@@ -69,9 +69,6 @@ message PbftSeal {
   // ID of the block this seal verifies
   bytes block_id = 2;
 
-  // ID of the previous block
-  bytes previous_id = 3;
-",,2019-02-25 15:01:32,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/259856035,https://github.com/hyperledger/sawtooth-pbft/pull/96#discussion_r259856035,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/96,https://github.com/hyperledger/sawtooth-pbft/pull/96,"Yes, good catch!",452cf28c8727217e968f23bd9507642105db0095,2019-02-25 15:01:04,259863219,"@@ -69,9 +69,6 @@ message PbftSeal {
   // ID of the block this seal verifies
   bytes block_id = 2;
 
-  // ID of the previous block
-  bytes previous_id = 3;
-",,2019-02-25 15:01:32,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/259863219,https://github.com/hyperledger/sawtooth-pbft/pull/96#discussion_r259863219,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/93,https://github.com/hyperledger/sawtooth-pbft/pull/93,"""contains""",07fea581c66efc7af2ac96100807d3be0d9feec0,2019-02-14 16:10:09,256901385,"@@ -274,8 +266,8 @@ agree (send their own ``ViewChange`` messages).
 View changing mode has the following steps:
 
 1. Any node who decides the primary is faulty sends a ``ViewChange`` message to
-   all nodes. This message contain the node’s current sequence number, its
-   current view, and proof of the previous checkpoint.
+   all nodes. This message contain the node’s current sequence number (block",,2019-02-14 19:54:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/256901385,https://github.com/hyperledger/sawtooth-pbft/pull/93#discussion_r256901385,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/93,https://github.com/hyperledger/sawtooth-pbft/pull/93,Fixed.  Thanks for catching this!,07fea581c66efc7af2ac96100807d3be0d9feec0,2019-02-14 16:13:37,256903052,"@@ -274,8 +266,8 @@ agree (send their own ``ViewChange`` messages).
 View changing mode has the following steps:
 
 1. Any node who decides the primary is faulty sends a ``ViewChange`` message to
-   all nodes. This message contain the node’s current sequence number, its
-   current view, and proof of the previous checkpoint.
+   all nodes. This message contain the node’s current sequence number (block",,2019-02-14 19:54:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/256903052,https://github.com/hyperledger/sawtooth-pbft/pull/93#discussion_r256903052,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/92,https://github.com/hyperledger/sawtooth-pbft/pull/92,2019,e74509d3eafa1541e86c4cf61539ee3f3cf24b98,2019-02-13 20:53:26,256584503,"@@ -0,0 +1,29 @@
+# Copyright 2018 Cargill Incorporated",,2019-02-13 22:35:14,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/256584503,https://github.com/hyperledger/sawtooth-pbft/pull/92#discussion_r256584503,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"""out of order"" could probably be rephrased to be more specific of what the issue would be ",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-11 15:28:13,255555743,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/255555743,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r255555743,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"""that that""",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-11 15:28:59,255556128,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given
+time.
+
+For example, a four-node network (the minimum required number of nodes)
+can tolerate one faulty node. Increasing the size of the network reduces the
+likelihood that that all :math:`\frac{n - 1}{3}` nodes would be faulty at the",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/255556128,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r255556128,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"""at least a third""",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-11 15:29:18,255556290,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given
+time.
+
+For example, a four-node network (the minimum required number of nodes)
+can tolerate one faulty node. Increasing the size of the network reduces the
+likelihood that that all :math:`\frac{n - 1}{3}` nodes would be faulty at the
+same time.
+
+Network `liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+is guaranteed as long as there are less than :math:`2f+1` unreachable nodes,
+counting both node and network failures. That is, at least third of the nodes",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/255556290,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r255556290,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,I don't think this is true; can you explain where this information is from?,09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-11 17:23:20,255609848,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given
+time.
+
+For example, a four-node network (the minimum required number of nodes)
+can tolerate one faulty node. Increasing the size of the network reduces the
+likelihood that that all :math:`\frac{n - 1}{3}` nodes would be faulty at the
+same time.
+
+Network `liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+is guaranteed as long as there are less than :math:`2f+1` unreachable nodes,",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/255609848,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r255609848,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,Requested some changes to wording similar to this in the previous PR; can you make similar changes here? Let me know if you have any questions about specifics.,09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-11 17:24:54,255610490,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/255610490,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r255610490,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"Might be useful here to mention that the ordering is determined by the list in the on-chain setting (mentioned later, but I think it's useful to call it out early for those that might wondering how the order is determined here).",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-11 17:27:52,255611791,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where",53,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/255611791,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r255611791,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"Would be helpful to specify, parenthetically, which node is node 0, node 1, etc. I.e. the 0th node in the list, the 1st node in the list, etc.",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-11 17:29:34,255612500,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given
+time.
+
+For example, a four-node network (the minimum required number of nodes)
+can tolerate one faulty node. Increasing the size of the network reduces the
+likelihood that that all :math:`\frac{n - 1}{3}` nodes would be faulty at the
+same time.
+
+Network `liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+is guaranteed as long as there are less than :math:`2f+1` unreachable nodes,
+counting both node and network failures. That is, at least third of the nodes
+(rounded up) must be reachable at all times.
+
+View Changes: Choosing a New Primary
+------------------------------------
+
+A PBFT network has one leader, called the `primary node`. All other nodes on the
+network are called `secondary nodes`.
+
+* The primary requests new blocks from the validator, notifies the network when
+  a new block is available, and reports consensus results (commit or fail) back
+  to the validator.
+
+* The secondary nodes monitor the health of the primary and request a change
+  if the primary appears out of order or malicious.
+
+A `view` is the period of time that a given node is the primary. The next
+primary is selected in a round-robin (circular) fashion, according to the order
+of nodes listed in the ``sawtooth.consensus.pbft.peers``
+:doc:`on-chain setting <on-chain-setting>`.
+In a four-node network, for example, node 0 is the primary at view 0,",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/255612500,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r255612500,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,I would simplify the requests new blocks/notifies the network bit to just saying that the primary builds and publishes new blocks.,09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-11 17:34:44,255614646,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given
+time.
+
+For example, a four-node network (the minimum required number of nodes)
+can tolerate one faulty node. Increasing the size of the network reduces the
+likelihood that that all :math:`\frac{n - 1}{3}` nodes would be faulty at the
+same time.
+
+Network `liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+is guaranteed as long as there are less than :math:`2f+1` unreachable nodes,
+counting both node and network failures. That is, at least third of the nodes
+(rounded up) must be reachable at all times.
+
+View Changes: Choosing a New Primary
+------------------------------------
+
+A PBFT network has one leader, called the `primary node`. All other nodes on the
+network are called `secondary nodes`.
+
+* The primary requests new blocks from the validator, notifies the network when",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/255614646,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r255614646,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"While reporting the results to the validator is technically true, all nodes do this with their own validator, so I don't think it's helpful to mention that here.",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-11 17:36:00,255615135,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given
+time.
+
+For example, a four-node network (the minimum required number of nodes)
+can tolerate one faulty node. Increasing the size of the network reduces the
+likelihood that that all :math:`\frac{n - 1}{3}` nodes would be faulty at the
+same time.
+
+Network `liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+is guaranteed as long as there are less than :math:`2f+1` unreachable nodes,
+counting both node and network failures. That is, at least third of the nodes
+(rounded up) must be reachable at all times.
+
+View Changes: Choosing a New Primary
+------------------------------------
+
+A PBFT network has one leader, called the `primary node`. All other nodes on the
+network are called `secondary nodes`.
+
+* The primary requests new blocks from the validator, notifies the network when
+  a new block is available, and reports consensus results (commit or fail) back",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/255615135,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r255615135,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"The most important role of the secondaries is to vote on blocks, which I think is worth mentioning here. Also, ""monitor the health of the primary"" might be a bit misreading, since that may suggest they something more than what they actually do. All they're doing is checking if the primary is malicious (sent a bad message) or faulty (doesn't do it's job in time), or if the network somehow gets stuck (doesn't make progress for a while). It's really kind of ""dumb"" in that it's not doing particularly intelligent ""monitoring"".",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-11 17:50:54,255621387,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given
+time.
+
+For example, a four-node network (the minimum required number of nodes)
+can tolerate one faulty node. Increasing the size of the network reduces the
+likelihood that that all :math:`\frac{n - 1}{3}` nodes would be faulty at the
+same time.
+
+Network `liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+is guaranteed as long as there are less than :math:`2f+1` unreachable nodes,
+counting both node and network failures. That is, at least third of the nodes
+(rounded up) must be reachable at all times.
+
+View Changes: Choosing a New Primary
+------------------------------------
+
+A PBFT network has one leader, called the `primary node`. All other nodes on the
+network are called `secondary nodes`.
+
+* The primary requests new blocks from the validator, notifies the network when
+  a new block is available, and reports consensus results (commit or fail) back
+  to the validator.
+
+* The secondary nodes monitor the health of the primary and request a change",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/255621387,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r255621387,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"The primary doesn't really *assign* a sequence number in Sawtooth PBFT (unlike traditional PBFT), because the sequence number is already defined as the block number.",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-11 17:53:26,255622418,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given
+time.
+
+For example, a four-node network (the minimum required number of nodes)
+can tolerate one faulty node. Increasing the size of the network reduces the
+likelihood that that all :math:`\frac{n - 1}{3}` nodes would be faulty at the
+same time.
+
+Network `liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+is guaranteed as long as there are less than :math:`2f+1` unreachable nodes,
+counting both node and network failures. That is, at least third of the nodes
+(rounded up) must be reachable at all times.
+
+View Changes: Choosing a New Primary
+------------------------------------
+
+A PBFT network has one leader, called the `primary node`. All other nodes on the
+network are called `secondary nodes`.
+
+* The primary requests new blocks from the validator, notifies the network when
+  a new block is available, and reports consensus results (commit or fail) back
+  to the validator.
+
+* The secondary nodes monitor the health of the primary and request a change
+  if the primary appears out of order or malicious.
+
+A `view` is the period of time that a given node is the primary. The next
+primary is selected in a round-robin (circular) fashion, according to the order
+of nodes listed in the ``sawtooth.consensus.pbft.peers``
+:doc:`on-chain setting <on-chain-setting>`.
+In a four-node network, for example, node 0 is the primary at view 0,
+node 1 is the primary at view 1, and so on.  When the network gets to view 4,
+it will ""wrap back around"" so that node 0 is the primary again.
+
+The algorithm uses the formula `p = v mod n` to determine the next
+primary. In this formula, `p` is the primary, `v` is the view number, and `n` is
+the total number of nodes in the network. For example, if a four-node network is
+at view 7, the formula `7 mod 4` determines that node 3 is the primary.
+
+The Sawtooth PBFT algorithm changes the primary at regular intervals, as well as
+when the secondary nodes determine that the current primary is faulty.
+See :ref:`view-changing-mode-label` for a description of this process.
+
+Sequence Numbers
+----------------
+
+The primary assigns a `sequence number` for each new block (called a ""candidate",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/255622418,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r255622418,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"@agunde406 or @ltseeley : How about ""unreachable""?",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-11 20:56:24,255689171,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/255689171,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r255689171,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"@ltseeley - It's adapted from this source: http://ug93tad.github.io/pbft/  (I was trying to find a way to work in the ""2f +1"" formula from an earlier draft of the PBFT architecture document.)

I shall remove this paragraph.
",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-11 20:59:50,255690371,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given
+time.
+
+For example, a four-node network (the minimum required number of nodes)
+can tolerate one faulty node. Increasing the size of the network reduces the
+likelihood that that all :math:`\frac{n - 1}{3}` nodes would be faulty at the
+same time.
+
+Network `liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+is guaranteed as long as there are less than :math:`2f+1` unreachable nodes,",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/255690371,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r255690371,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,I'm not sure what you are trying to say here? ,09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-12 16:27:46,256035081,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/256035081,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r256035081,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"I was trying to avoid saying that the primary node publishes the new blocks.  My understanding is that ~the primary~ each node (the PBFT consensus engine piece, that is) tells its validator that it's okay for the validator to publish the block. ",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-12 19:48:37,256119206,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given
+time.
+
+For example, a four-node network (the minimum required number of nodes)
+can tolerate one faulty node. Increasing the size of the network reduces the
+likelihood that that all :math:`\frac{n - 1}{3}` nodes would be faulty at the
+same time.
+
+Network `liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+is guaranteed as long as there are less than :math:`2f+1` unreachable nodes,
+counting both node and network failures. That is, at least third of the nodes
+(rounded up) must be reachable at all times.
+
+View Changes: Choosing a New Primary
+------------------------------------
+
+A PBFT network has one leader, called the `primary node`. All other nodes on the
+network are called `secondary nodes`.
+
+* The primary requests new blocks from the validator, notifies the network when",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/256119206,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r256119206,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,~Or does the consensus engine actually handle the mechanics of publishing a block?~,09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-12 19:50:39,256120031,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given
+time.
+
+For example, a four-node network (the minimum required number of nodes)
+can tolerate one faulty node. Increasing the size of the network reduces the
+likelihood that that all :math:`\frac{n - 1}{3}` nodes would be faulty at the
+same time.
+
+Network `liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+is guaranteed as long as there are less than :math:`2f+1` unreachable nodes,
+counting both node and network failures. That is, at least third of the nodes
+(rounded up) must be reachable at all times.
+
+View Changes: Choosing a New Primary
+------------------------------------
+
+A PBFT network has one leader, called the `primary node`. All other nodes on the
+network are called `secondary nodes`.
+
+* The primary requests new blocks from the validator, notifies the network when",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/256120031,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r256120031,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"I think this sentence (which was in the original doc) is referring to the general PBFT algorithm. I propose rewording it thusly:

~""The PBFT algorithm specifies that each new block has a `sequence number`. Sawtooth PBFT uses the block number as the sequence number.""~

""With PBFT, each block has a _sequence number_. Sawtooth PBFT uses the block number as the sequence number.""",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-12 21:20:20,256151626,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given
+time.
+
+For example, a four-node network (the minimum required number of nodes)
+can tolerate one faulty node. Increasing the size of the network reduces the
+likelihood that that all :math:`\frac{n - 1}{3}` nodes would be faulty at the
+same time.
+
+Network `liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+is guaranteed as long as there are less than :math:`2f+1` unreachable nodes,
+counting both node and network failures. That is, at least third of the nodes
+(rounded up) must be reachable at all times.
+
+View Changes: Choosing a New Primary
+------------------------------------
+
+A PBFT network has one leader, called the `primary node`. All other nodes on the
+network are called `secondary nodes`.
+
+* The primary requests new blocks from the validator, notifies the network when
+  a new block is available, and reports consensus results (commit or fail) back
+  to the validator.
+
+* The secondary nodes monitor the health of the primary and request a change
+  if the primary appears out of order or malicious.
+
+A `view` is the period of time that a given node is the primary. The next
+primary is selected in a round-robin (circular) fashion, according to the order
+of nodes listed in the ``sawtooth.consensus.pbft.peers``
+:doc:`on-chain setting <on-chain-setting>`.
+In a four-node network, for example, node 0 is the primary at view 0,
+node 1 is the primary at view 1, and so on.  When the network gets to view 4,
+it will ""wrap back around"" so that node 0 is the primary again.
+
+The algorithm uses the formula `p = v mod n` to determine the next
+primary. In this formula, `p` is the primary, `v` is the view number, and `n` is
+the total number of nodes in the network. For example, if a four-node network is
+at view 7, the formula `7 mod 4` determines that node 3 is the primary.
+
+The Sawtooth PBFT algorithm changes the primary at regular intervals, as well as
+when the secondary nodes determine that the current primary is faulty.
+See :ref:`view-changing-mode-label` for a description of this process.
+
+Sequence Numbers
+----------------
+
+The primary assigns a `sequence number` for each new block (called a ""candidate",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/256151626,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r256151626,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"I'll change this to:

""The secondary nodes vote on the new blocks and send messages if the primary   
  appears unreachable or malicious."" ",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-12 21:24:03,256152893,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given
+time.
+
+For example, a four-node network (the minimum required number of nodes)
+can tolerate one faulty node. Increasing the size of the network reduces the
+likelihood that that all :math:`\frac{n - 1}{3}` nodes would be faulty at the
+same time.
+
+Network `liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+is guaranteed as long as there are less than :math:`2f+1` unreachable nodes,
+counting both node and network failures. That is, at least third of the nodes
+(rounded up) must be reachable at all times.
+
+View Changes: Choosing a New Primary
+------------------------------------
+
+A PBFT network has one leader, called the `primary node`. All other nodes on the
+network are called `secondary nodes`.
+
+* The primary requests new blocks from the validator, notifies the network when
+  a new block is available, and reports consensus results (commit or fail) back
+  to the validator.
+
+* The secondary nodes monitor the health of the primary and request a change",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/256152893,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r256152893,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,Done.,09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-13 01:40:52,256218467,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where",53,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/256218467,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r256218467,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,Done,09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-13 01:41:31,256218614,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given
+time.
+
+For example, a four-node network (the minimum required number of nodes)
+can tolerate one faulty node. Increasing the size of the network reduces the
+likelihood that that all :math:`\frac{n - 1}{3}` nodes would be faulty at the",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/256218614,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r256218614,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,Done,09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-13 22:35:17,256619114,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/256619114,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r256619114,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"The ""In other words"" sentence is explaining the formula in words.  I changed ""out of order"" to ""unreachable"" (in the sense that either the node isn't working or there's a network problem).",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-13 22:38:06,256619986,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/256619986,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r256619986,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"After chatting, I agree that we don't need to make this distinction at the beginning of the section. (It's described in more detail later.) ",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-14 15:57:45,256895538,"@@ -1,17 +1,142 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
+
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+All nodes on the network participate in the consensus process by verifying
+candidate blocks and exchanging consensus messages to communicate their progress
+and report on the health of the network. A `primary node` leads the network for
+a period of time, and `secondary nodes` monitor the health of the primary.
+The network switches to a new primary (called a `view change`) at regular
+intervals, as well as when the current primary is faulty.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be out of order or dishonest at any given
+time.
+
+For example, a four-node network (the minimum required number of nodes)
+can tolerate one faulty node. Increasing the size of the network reduces the
+likelihood that that all :math:`\frac{n - 1}{3}` nodes would be faulty at the
+same time.
+
+Network `liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+is guaranteed as long as there are less than :math:`2f+1` unreachable nodes,
+counting both node and network failures. That is, at least third of the nodes
+(rounded up) must be reachable at all times.
+
+View Changes: Choosing a New Primary
+------------------------------------
+
+A PBFT network has one leader, called the `primary node`. All other nodes on the
+network are called `secondary nodes`.
+
+* The primary requests new blocks from the validator, notifies the network when",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/256895538,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r256895538,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"I would reword this to just be ""vote on blocks"" instead of ""vote on the new blocks"". Also, I think ""send messages if the primary appears unreachable or malicious"" is too vague in that ""send messages"" doesn't really tell you anything about what they're doing if the primary is unreachable or malicious (they send messages for just about everything). Not totally sure what the best way to word this is, though.",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-14 21:39:16,257023248,"@@ -1,17 +1,134 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
 
-The Sawtooth PBFT algorithm provides practical Byzantine fault tolerant (PBFT)
-consensus for Hyperledger Sawtooth. All nodes on the network participate in the
-consensus process by exchanging messages. One node, called the :term:`primary`,
-is the leader. All other nodes are called :term:`secondary nodes <secondaries>`.
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+The nodes on the network send many messages to reach consensus, commit blocks,
+and maintain a healthy leader node, called a `primary node`. The network
+switches to a new primary (called a `view change`) at regular intervals, as well
+as when the current primary is faulty.
+
+* The primary node builds and publishes blocks.
+
+* The other nodes (called `secondary nodes`) vote on the new blocks and send",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/257023248,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r257023248,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,I think calling out that node 3 is the fourth node here could be a little confusing and is unnecessary.,09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-14 21:41:11,257023852,"@@ -1,17 +1,134 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
 
-The Sawtooth PBFT algorithm provides practical Byzantine fault tolerant (PBFT)
-consensus for Hyperledger Sawtooth. All nodes on the network participate in the
-consensus process by exchanging messages. One node, called the :term:`primary`,
-is the leader. All other nodes are called :term:`secondary nodes <secondaries>`.
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+The nodes on the network send many messages to reach consensus, commit blocks,
+and maintain a healthy leader node, called a `primary node`. The network
+switches to a new primary (called a `view change`) at regular intervals, as well
+as when the current primary is faulty.
+
+* The primary node builds and publishes blocks.
+
+* The other nodes (called `secondary nodes`) vote on the new blocks and send
+  messages if the primary appears unreachable or malicious.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network. The
+:doc:`on-chain setting <on-chain-settings>` ``sawtooth.consensus.pbft.peers``
+lists all nodes and determines the node order.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be unreachable or dishonest at any given
+time.
+
+For example, a four-node network can tolerate one faulty node. (PBFT requires a
+minimum of four nodes in order to maintain Byzantine fault tolerance.)
+Increasing the size of the network reduces the likelihood that all
+:math:`\frac{n - 1}{3}` nodes would be faulty at the same time.
+
+View Changes: Choosing a New Primary
+------------------------------------
+
+A `view` is the period of time that a given node is the primary, so a `view
+change` means switching to a different primary node. The next primary is
+selected in a round-robin (circular) fashion, according to the order of nodes
+listed in the :doc:`on-chain setting <on-chain-settings>`
+``sawtooth.consensus.pbft.peers``.
+
+In a four-node network, for example, the first node (node 0) is the primary at
+view 0, the second node (node 1) is the primary at view 1, and so on.  When the
+network gets to view 4, it will ""wrap back around"" so that node 0 is the primary
+again.
+
+The algorithm uses the formula `p = v mod n` to determine the next
+primary. In this formula, `p` is the primary, `v` is the view number, and `n` is
+the total number of nodes in the network. For example, if a four-node network is
+at view 7, the formula `7 mod 4` determines that node 3 (the fourth node) is the",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/257023852,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r257023852,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"I'd remove this sentence; we never really refer to a block as the ""11th"" block, we'd just refer to it as block 10.",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-14 21:42:13,257024166,"@@ -1,17 +1,134 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
 
-The Sawtooth PBFT algorithm provides practical Byzantine fault tolerant (PBFT)
-consensus for Hyperledger Sawtooth. All nodes on the network participate in the
-consensus process by exchanging messages. One node, called the :term:`primary`,
-is the leader. All other nodes are called :term:`secondary nodes <secondaries>`.
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+The nodes on the network send many messages to reach consensus, commit blocks,
+and maintain a healthy leader node, called a `primary node`. The network
+switches to a new primary (called a `view change`) at regular intervals, as well
+as when the current primary is faulty.
+
+* The primary node builds and publishes blocks.
+
+* The other nodes (called `secondary nodes`) vote on the new blocks and send
+  messages if the primary appears unreachable or malicious.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network. The
+:doc:`on-chain setting <on-chain-settings>` ``sawtooth.consensus.pbft.peers``
+lists all nodes and determines the node order.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be unreachable or dishonest at any given
+time.
+
+For example, a four-node network can tolerate one faulty node. (PBFT requires a
+minimum of four nodes in order to maintain Byzantine fault tolerance.)
+Increasing the size of the network reduces the likelihood that all
+:math:`\frac{n - 1}{3}` nodes would be faulty at the same time.
+
+View Changes: Choosing a New Primary
+------------------------------------
+
+A `view` is the period of time that a given node is the primary, so a `view
+change` means switching to a different primary node. The next primary is
+selected in a round-robin (circular) fashion, according to the order of nodes
+listed in the :doc:`on-chain setting <on-chain-settings>`
+``sawtooth.consensus.pbft.peers``.
+
+In a four-node network, for example, the first node (node 0) is the primary at
+view 0, the second node (node 1) is the primary at view 1, and so on.  When the
+network gets to view 4, it will ""wrap back around"" so that node 0 is the primary
+again.
+
+The algorithm uses the formula `p = v mod n` to determine the next
+primary. In this formula, `p` is the primary, `v` is the view number, and `n` is
+the total number of nodes in the network. For example, if a four-node network is
+at view 7, the formula `7 mod 4` determines that node 3 (the fourth node) is the
+primary.
+
+The Sawtooth PBFT algorithm changes the primary at regular intervals, as well as
+when the secondary nodes determine that the current primary is faulty.
+See :ref:`view-changing-mode-label` for a description of this process.
+
+Sequence Numbers
+----------------
+
+With PBFT, each new block has a `sequence number`. Sawtooth PBFT uses the block
+number as the sequence number.
+
+For example, a node that is on sequence 10 is evaluating block 10.
+Note that this is actually the 11th block, because both sequence and block",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/257024166,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r257024166,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"Blocks don't actually have sequence numbers. The notion of a ""sequence number"" is really only relevant to the PBFT nodes themselves; i.e. you would say that the node is on sequence number 10, and that it is attempting to commit block 10 at sequence number 10.",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-14 21:44:57,257025013,"@@ -1,17 +1,134 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
 
-The Sawtooth PBFT algorithm provides practical Byzantine fault tolerant (PBFT)
-consensus for Hyperledger Sawtooth. All nodes on the network participate in the
-consensus process by exchanging messages. One node, called the :term:`primary`,
-is the leader. All other nodes are called :term:`secondary nodes <secondaries>`.
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+The nodes on the network send many messages to reach consensus, commit blocks,
+and maintain a healthy leader node, called a `primary node`. The network
+switches to a new primary (called a `view change`) at regular intervals, as well
+as when the current primary is faulty.
+
+* The primary node builds and publishes blocks.
+
+* The other nodes (called `secondary nodes`) vote on the new blocks and send
+  messages if the primary appears unreachable or malicious.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network. The
+:doc:`on-chain setting <on-chain-settings>` ``sawtooth.consensus.pbft.peers``
+lists all nodes and determines the node order.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be unreachable or dishonest at any given
+time.
+
+For example, a four-node network can tolerate one faulty node. (PBFT requires a
+minimum of four nodes in order to maintain Byzantine fault tolerance.)
+Increasing the size of the network reduces the likelihood that all
+:math:`\frac{n - 1}{3}` nodes would be faulty at the same time.
+
+View Changes: Choosing a New Primary
+------------------------------------
+
+A `view` is the period of time that a given node is the primary, so a `view
+change` means switching to a different primary node. The next primary is
+selected in a round-robin (circular) fashion, according to the order of nodes
+listed in the :doc:`on-chain setting <on-chain-settings>`
+``sawtooth.consensus.pbft.peers``.
+
+In a four-node network, for example, the first node (node 0) is the primary at
+view 0, the second node (node 1) is the primary at view 1, and so on.  When the
+network gets to view 4, it will ""wrap back around"" so that node 0 is the primary
+again.
+
+The algorithm uses the formula `p = v mod n` to determine the next
+primary. In this formula, `p` is the primary, `v` is the view number, and `n` is
+the total number of nodes in the network. For example, if a four-node network is
+at view 7, the formula `7 mod 4` determines that node 3 (the fourth node) is the
+primary.
+
+The Sawtooth PBFT algorithm changes the primary at regular intervals, as well as
+when the secondary nodes determine that the current primary is faulty.
+See :ref:`view-changing-mode-label` for a description of this process.
+
+Sequence Numbers
+----------------
+
+With PBFT, each new block has a `sequence number`. Sawtooth PBFT uses the block",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/257025013,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r257025013,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"""ID 0"", ""ID 1"", etc. is outdated information; this was from back in the beginning where nodes had numbered ID's. Now, the only concept of a node ID is the node's public key. This paragraph should be updated to reflect that and match what's in the ""View Changes: Choosing a New Primary"" section",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-14 21:47:12,257025747,"@@ -276,11 +393,10 @@ View changing mode has the following steps:
    operation.
 
 The next primary node is determined by the node ID, in sequential order, based
-based on the order of nodes in the ``sawtooth.consensus.pbft.peers`` on-chain
-setting. The first node on the list has ID 0 and is the first primary for view
-0; the next node has ID 1 and is the second primary for view 1; and so on.
-After all nodes on the list have been the primary, the algorithm returns to
-node 0.
+on the order of nodes in the ``sawtooth.consensus.pbft.peers`` on-chain setting.
+The first node on the list has ID 0 and is the first primary for view 0; the",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/257025747,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r257025747,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"How about ""The other nodes ... vote on new blocks and the health of the leader."" 

Is this adequate, given that there's a previous sentence about all nodes sending messages?  (""The nodes on the network send many messages to reach consensus, commit blocks, and maintain a healthy leader node..."")",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-14 23:07:09,257049973,"@@ -1,17 +1,134 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
 
-The Sawtooth PBFT algorithm provides practical Byzantine fault tolerant (PBFT)
-consensus for Hyperledger Sawtooth. All nodes on the network participate in the
-consensus process by exchanging messages. One node, called the :term:`primary`,
-is the leader. All other nodes are called :term:`secondary nodes <secondaries>`.
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+The nodes on the network send many messages to reach consensus, commit blocks,
+and maintain a healthy leader node, called a `primary node`. The network
+switches to a new primary (called a `view change`) at regular intervals, as well
+as when the current primary is faulty.
+
+* The primary node builds and publishes blocks.
+
+* The other nodes (called `secondary nodes`) vote on the new blocks and send",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/257049973,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r257049973,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,I'll change it to use similar wording to the PBFT blog post.,09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-14 23:17:55,257053008,"@@ -1,17 +1,134 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
 
-The Sawtooth PBFT algorithm provides practical Byzantine fault tolerant (PBFT)
-consensus for Hyperledger Sawtooth. All nodes on the network participate in the
-consensus process by exchanging messages. One node, called the :term:`primary`,
-is the leader. All other nodes are called :term:`secondary nodes <secondaries>`.
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+The nodes on the network send many messages to reach consensus, commit blocks,
+and maintain a healthy leader node, called a `primary node`. The network
+switches to a new primary (called a `view change`) at regular intervals, as well
+as when the current primary is faulty.
+
+* The primary node builds and publishes blocks.
+
+* The other nodes (called `secondary nodes`) vote on the new blocks and send
+  messages if the primary appears unreachable or malicious.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network. The
+:doc:`on-chain setting <on-chain-settings>` ``sawtooth.consensus.pbft.peers``
+lists all nodes and determines the node order.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be unreachable or dishonest at any given
+time.
+
+For example, a four-node network can tolerate one faulty node. (PBFT requires a
+minimum of four nodes in order to maintain Byzantine fault tolerance.)
+Increasing the size of the network reduces the likelihood that all
+:math:`\frac{n - 1}{3}` nodes would be faulty at the same time.
+
+View Changes: Choosing a New Primary
+------------------------------------
+
+A `view` is the period of time that a given node is the primary, so a `view
+change` means switching to a different primary node. The next primary is
+selected in a round-robin (circular) fashion, according to the order of nodes
+listed in the :doc:`on-chain setting <on-chain-settings>`
+``sawtooth.consensus.pbft.peers``.
+
+In a four-node network, for example, the first node (node 0) is the primary at
+view 0, the second node (node 1) is the primary at view 1, and so on.  When the
+network gets to view 4, it will ""wrap back around"" so that node 0 is the primary
+again.
+
+The algorithm uses the formula `p = v mod n` to determine the next
+primary. In this formula, `p` is the primary, `v` is the view number, and `n` is
+the total number of nodes in the network. For example, if a four-node network is
+at view 7, the formula `7 mod 4` determines that node 3 (the fourth node) is the
+primary.
+
+The Sawtooth PBFT algorithm changes the primary at regular intervals, as well as
+when the secondary nodes determine that the current primary is faulty.
+See :ref:`view-changing-mode-label` for a description of this process.
+
+Sequence Numbers
+----------------
+
+With PBFT, each new block has a `sequence number`. Sawtooth PBFT uses the block",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/257053008,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r257053008,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"In order to avoid duplicated text, I'll replace this info with a link to the (correct) info in ""View Changes: Choosing a New Primary"". (This isn't ideal, but duplicated content can cause difficulties down the road.)",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-14 23:24:56,257054602,"@@ -276,11 +393,10 @@ View changing mode has the following steps:
    operation.
 
 The next primary node is determined by the node ID, in sequential order, based
-based on the order of nodes in the ``sawtooth.consensus.pbft.peers`` on-chain
-setting. The first node on the list has ID 0 and is the first primary for view
-0; the next node has ID 1 and is the second primary for view 1; and so on.
-After all nodes on the list have been the primary, the algorithm returns to
-node 0.
+on the order of nodes in the ``sawtooth.consensus.pbft.peers`` on-chain setting.
+The first node on the list has ID 0 and is the first primary for view 0; the",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/257054602,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r257054602,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"Missing ""the"": ""same as block number""",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-18 18:48:31,257798924,"@@ -1,17 +1,136 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
 
-The Sawtooth PBFT algorithm provides practical Byzantine fault tolerant (PBFT)
-consensus for Hyperledger Sawtooth. All nodes on the network participate in the
-consensus process by exchanging messages. One node, called the :term:`primary`,
-is the leader. All other nodes are called :term:`secondary nodes <secondaries>`.
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+The nodes on the network send many messages to reach consensus, commit blocks,
+and maintain a healthy leader node, called a `primary node`. The network
+switches to a new primary (called a `view change`) at regular intervals, as well
+as when the current primary is faulty.
+
+* The primary node builds and publishes blocks.
+
+* The other nodes (called `secondary nodes`) vote on blocks and the health of
+  the leader.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network. The
+:doc:`on-chain setting <on-chain-settings>` ``sawtooth.consensus.pbft.peers``
+lists all nodes and determines the node order.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be unreachable or dishonest at any given
+time.
+
+For example, a four-node network can tolerate one faulty node. (PBFT requires a
+minimum of four nodes in order to maintain Byzantine fault tolerance.)
+Increasing the size of the network reduces the likelihood that all
+:math:`\frac{n - 1}{3}` nodes would be faulty at the same time.
+
+.. _view-changes-choosing-primary-label:
+
+View Changes: Choosing a New Primary
+------------------------------------
+
+A `view` is the period of time that a given node is the primary, so a `view
+change` means switching to a different primary node. The next primary is
+selected in a round-robin (circular) fashion, according to the order of nodes
+listed in the :doc:`on-chain setting <on-chain-settings>`
+``sawtooth.consensus.pbft.peers``.
+
+In a four-node network, for example, the first node (node 0) is the primary at
+view 0, the second node (node 1) is the primary at view 1, and so on.  When the
+network gets to view 4, it will return to node 0 as the primary.
+
+The algorithm uses the formula `p = v mod n` to determine the next
+primary. In this formula, `p` is the primary, `v` is the view number, and `n` is
+the total number of nodes in the network. For example, if a four-node network is
+at view 7, the formula `7 mod 4` determines that node 3 is the primary.
+
+The Sawtooth PBFT algorithm changes the primary at regular intervals, as well as
+when the secondary nodes determine that the current primary is faulty.
+See :ref:`view-changing-mode-label` for a description of this process.
+
+Sequence Numbers
+----------------
+
+In addition to moving through a series of views, the network moves through a
+series of `sequence numbers`. In Sawtooth PBFT, a node's sequence number is
+the same as block number of the next block in the chain. For example, a node",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/257798924,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r257798924,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/89,https://github.com/hyperledger/sawtooth-pbft/pull/89,"I'd say ""sequence number 10"", not ""sequence 10""",09f3c6a8e33eb0ae258d3cc03a778c95ce6e3a6c,2019-02-18 18:48:46,257798967,"@@ -1,17 +1,136 @@
-*****************
-PBFT Architecture
-*****************
+Architecture
+************
 
-The Sawtooth PBFT algorithm provides practical Byzantine fault tolerant (PBFT)
-consensus for Hyperledger Sawtooth. All nodes on the network participate in the
-consensus process by exchanging messages. One node, called the :term:`primary`,
-is the leader. All other nodes are called :term:`secondary nodes <secondaries>`.
+The Sawtooth PBFT algorithm is a voting-based consensus algorithm with Byzantine
+fault tolerance, which ensures `safety and liveness
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__.
+The network can tolerate a certain number of ""bad"" nodes. As long as this number
+is not exceeded, the network will work properly. In addition, blocks committed
+by nodes are final, so there are no forks in the network.
+
+The nodes on the network send many messages to reach consensus, commit blocks,
+and maintain a healthy leader node, called a `primary node`. The network
+switches to a new primary (called a `view change`) at regular intervals, as well
+as when the current primary is faulty.
+
+* The primary node builds and publishes blocks.
+
+* The other nodes (called `secondary nodes`) vote on blocks and the health of
+  the leader.
+
+Sawtooth PBFT runs on each node in the network as a `consensus engine`, a
+separate process that handles consensus-related functionality and communicates
+with the validator through the consensus API.
+
+The following sections describe Sawtooth PBFT architecture:
+
+* :ref:`Network overview <network-overview-label>`: Describes PBFT fault
+  tolerance, view changes, sequence numbers, and the information stored
+  by each node
+
+* :ref:`Consensus messages <consensus-messages-label>`: Explains consensus
+  message structures and message types
+
+* :ref:`Sawtooth PBFT operation <pbft-operation-label>`: Shows how the
+  algorithm handles initialization, normal mode (block processing), and view
+  changes
+
+.. _network-overview-label:
+
+Network Overview
+================
+
+Fault Tolerance
+---------------
+
+A PBFT network consists of nodes that are ordered from 0 to `n-1`, where
+`n` is the total number of nodes in the network. The
+:doc:`on-chain setting <on-chain-settings>` ``sawtooth.consensus.pbft.peers``
+lists all nodes and determines the node order.
+
+The PBFT algorithm guarantees network `safety
+<https://en.wikipedia.org/wiki/Liveness#Liveness_and_safety>`__
+as long as the number of faulty nodes remains below the required percentage.
+The maximum number of faulty nodes that the network can tolerate is determined
+by the formula :math:`f = \frac{n - 1}{3}`. In other words, no more than one
+third of the nodes (rounded down) can be unreachable or dishonest at any given
+time.
+
+For example, a four-node network can tolerate one faulty node. (PBFT requires a
+minimum of four nodes in order to maintain Byzantine fault tolerance.)
+Increasing the size of the network reduces the likelihood that all
+:math:`\frac{n - 1}{3}` nodes would be faulty at the same time.
+
+.. _view-changes-choosing-primary-label:
+
+View Changes: Choosing a New Primary
+------------------------------------
+
+A `view` is the period of time that a given node is the primary, so a `view
+change` means switching to a different primary node. The next primary is
+selected in a round-robin (circular) fashion, according to the order of nodes
+listed in the :doc:`on-chain setting <on-chain-settings>`
+``sawtooth.consensus.pbft.peers``.
+
+In a four-node network, for example, the first node (node 0) is the primary at
+view 0, the second node (node 1) is the primary at view 1, and so on.  When the
+network gets to view 4, it will return to node 0 as the primary.
+
+The algorithm uses the formula `p = v mod n` to determine the next
+primary. In this formula, `p` is the primary, `v` is the view number, and `n` is
+the total number of nodes in the network. For example, if a four-node network is
+at view 7, the formula `7 mod 4` determines that node 3 is the primary.
+
+The Sawtooth PBFT algorithm changes the primary at regular intervals, as well as
+when the secondary nodes determine that the current primary is faulty.
+See :ref:`view-changing-mode-label` for a description of this process.
+
+Sequence Numbers
+----------------
+
+In addition to moving through a series of views, the network moves through a
+series of `sequence numbers`. In Sawtooth PBFT, a node's sequence number is
+the same as block number of the next block in the chain. For example, a node
+that is on sequence 10 has already committed block 9 and is evaluating block 10.",,2019-02-18 19:42:28,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/257798967,https://github.com/hyperledger/sawtooth-pbft/pull/89#discussion_r257798967,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/87,https://github.com/hyperledger/sawtooth-pbft/pull/87,Setting faulty_primary_timeout: twice here,6e7305f98f2dbc41504c9f915c4c06fd34d94185,2019-02-06 17:30:31,254372294,"@@ -152,6 +156,7 @@ impl PbftState {
             f,
             peer_ids: config.peers.clone(),
             faulty_primary_timeout: Timeout::new(config.faulty_primary_timeout),
+            faulty_primary_timeout: Timeout::new(config.commit_timeout),",,2019-02-08 22:25:37,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/254372294,https://github.com/hyperledger/sawtooth-pbft/pull/87#discussion_r254372294,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/85,https://github.com/hyperledger/sawtooth-pbft/pull/85,We should probably just implement retry on our own. ,9958c709636e10850ba898e177b4659bbffd83cd,2019-02-01 19:59:14,253181385,"@@ -50,6 +50,7 @@ log4rs = ""0.8""
 log4rs-syslog = ""3.0""
 openssl = ""0.10""
 protobuf = { version = ""2"", features = [""with-serde""] }
+retry = ""0.4.0""",,2019-02-08 21:08:22,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/253181385,https://github.com/hyperledger/sawtooth-pbft/pull/85#discussion_r253181385,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/85,https://github.com/hyperledger/sawtooth-pbft/pull/85,We should not use magic numbers and should use exponential backoff. ,9958c709636e10850ba898e177b4659bbffd83cd,2019-02-01 20:01:48,253182152,"@@ -92,20 +93,27 @@ impl PbftConfig {
 pub fn load_pbft_config(block_id: BlockId, service: &mut Service) -> PbftConfig {
     let mut config = PbftConfig::default();
 
-    let settings: HashMap<String, String> = service
-        .get_settings(
-            block_id,
-            vec![
-                String::from(""sawtooth.consensus.pbft.peers""),
-                String::from(""sawtooth.consensus.pbft.block_duration""),
-                String::from(""sawtooth.consensus.pbft.faulty_primary_timeout""),
-                String::from(""sawtooth.consensus.pbft.view_change_duration""),
-                String::from(""sawtooth.consensus.pbft.forced_view_change_period""),
-                String::from(""sawtooth.consensus.pbft.message_timeout""),
-                String::from(""sawtooth.consensus.pbft.max_log_size""),
-            ],
-        )
-        .unwrap_or_else(|err| panic!(""Failed to load on-chain settings due to error: {:?}"", err));
+    let settings: HashMap<String, String> = Retry::new(
+        &mut || {
+            service.get_settings(
+                block_id.clone(),
+                vec![
+                    String::from(""sawtooth.consensus.pbft.peers""),
+                    String::from(""sawtooth.consensus.pbft.block_duration""),
+                    String::from(""sawtooth.consensus.pbft.faulty_primary_timeout""),
+                    String::from(""sawtooth.consensus.pbft.view_change_duration""),
+                    String::from(""sawtooth.consensus.pbft.forced_view_change_period""),
+                    String::from(""sawtooth.consensus.pbft.message_timeout""),
+                    String::from(""sawtooth.consensus.pbft.max_log_size""),
+                ],
+            )
+        },
+        &mut |response| response.is_ok(),
+    )
+    .wait(1000)",,2019-02-08 21:08:22,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/253182152,https://github.com/hyperledger/sawtooth-pbft/pull/85#discussion_r253182152,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/85,https://github.com/hyperledger/sawtooth-pbft/pull/85,Same for the other instances ,9958c709636e10850ba898e177b4659bbffd83cd,2019-02-01 20:02:07,253182226,"@@ -92,20 +93,27 @@ impl PbftConfig {
 pub fn load_pbft_config(block_id: BlockId, service: &mut Service) -> PbftConfig {
     let mut config = PbftConfig::default();
 
-    let settings: HashMap<String, String> = service
-        .get_settings(
-            block_id,
-            vec![
-                String::from(""sawtooth.consensus.pbft.peers""),
-                String::from(""sawtooth.consensus.pbft.block_duration""),
-                String::from(""sawtooth.consensus.pbft.faulty_primary_timeout""),
-                String::from(""sawtooth.consensus.pbft.view_change_duration""),
-                String::from(""sawtooth.consensus.pbft.forced_view_change_period""),
-                String::from(""sawtooth.consensus.pbft.message_timeout""),
-                String::from(""sawtooth.consensus.pbft.max_log_size""),
-            ],
-        )
-        .unwrap_or_else(|err| panic!(""Failed to load on-chain settings due to error: {:?}"", err));
+    let settings: HashMap<String, String> = Retry::new(
+        &mut || {
+            service.get_settings(
+                block_id.clone(),
+                vec![
+                    String::from(""sawtooth.consensus.pbft.peers""),
+                    String::from(""sawtooth.consensus.pbft.block_duration""),
+                    String::from(""sawtooth.consensus.pbft.faulty_primary_timeout""),
+                    String::from(""sawtooth.consensus.pbft.view_change_duration""),
+                    String::from(""sawtooth.consensus.pbft.forced_view_change_period""),
+                    String::from(""sawtooth.consensus.pbft.message_timeout""),
+                    String::from(""sawtooth.consensus.pbft.max_log_size""),
+                ],
+            )
+        },
+        &mut |response| response.is_ok(),
+    )
+    .wait(1000)",,2019-02-08 21:08:22,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/253182226,https://github.com/hyperledger/sawtooth-pbft/pull/85#discussion_r253182226,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/85,https://github.com/hyperledger/sawtooth-pbft/pull/85,This is a very quick increase. I would instead use multiply by 2 (what we use for authorization attempts in the validator) and adding a maximum time to the config. ,9958c709636e10850ba898e177b4659bbffd83cd,2019-02-04 19:12:18,253604395,"@@ -93,6 +94,20 @@ impl Timeout {
     }
 }
 
+/// With exponential backoff, repeatedly try the callback until the result is `Ok`
+pub fn retry_until_ok<T, E, F: FnMut() -> Result<T, E>>(base: u64, mut callback: F) -> T {
+    let mut delay = base;
+    loop {
+        match callback() {
+            Ok(res) => return res,
+            Err(_) => {
+                sleep(Duration::from_millis(delay));
+                delay *= base;",,2019-02-08 21:08:22,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/253604395,https://github.com/hyperledger/sawtooth-pbft/pull/85#discussion_r253604395,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/85,https://github.com/hyperledger/sawtooth-pbft/pull/85,It would be good to add a log statement before you start the retry loop so you can see if we get stuck on a step. Same for other places you use retry_until_ok,9958c709636e10850ba898e177b4659bbffd83cd,2019-02-04 19:13:30,253604939,"@@ -92,20 +99,21 @@ impl PbftConfig {
 pub fn load_pbft_config(block_id: BlockId, service: &mut Service) -> PbftConfig {
     let mut config = PbftConfig::default();
 
-    let settings: HashMap<String, String> = service
-        .get_settings(
-            block_id,
+    let settings: HashMap<String, String> = retry_until_ok(config.exponential_retry_base, || {",,2019-02-08 21:08:22,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/253604939,https://github.com/hyperledger/sawtooth-pbft/pull/85#discussion_r253604939,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/85,https://github.com/hyperledger/sawtooth-pbft/pull/85,"There should be a maximum amount of time (it is not desirable to have a backoff time go to hours or days).  For example, to from 1s to a maximum of 5m by multiplying by 2 each iteration; and making maximum configurable.",9958c709636e10850ba898e177b4659bbffd83cd,2019-02-04 22:19:40,253669299,"@@ -93,6 +94,20 @@ impl Timeout {
     }
 }
 
+/// With exponential backoff, repeatedly try the callback until the result is `Ok`
+pub fn retry_until_ok<T, E, F: FnMut() -> Result<T, E>>(base: u64, mut callback: F) -> T {",,2019-02-08 21:08:22,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/253669299,https://github.com/hyperledger/sawtooth-pbft/pull/85#discussion_r253669299,vaporos
https://github.com/hyperledger/sawtooth-pbft/pull/85,https://github.com/hyperledger/sawtooth-pbft/pull/85,Isn't this a retry that is based around the local configuration? I.e. it's a timeout for the messaging between the  consensus engine and the validator.,9958c709636e10850ba898e177b4659bbffd83cd,2019-02-06 16:37:28,254350037,"@@ -92,20 +104,27 @@ impl PbftConfig {
 pub fn load_pbft_config(block_id: BlockId, service: &mut Service) -> PbftConfig {
     let mut config = PbftConfig::default();
 
-    let settings: HashMap<String, String> = service
-        .get_settings(
-            block_id,
-            vec![
-                String::from(""sawtooth.consensus.pbft.peers""),
-                String::from(""sawtooth.consensus.pbft.block_duration""),
-                String::from(""sawtooth.consensus.pbft.faulty_primary_timeout""),
-                String::from(""sawtooth.consensus.pbft.view_change_duration""),
-                String::from(""sawtooth.consensus.pbft.forced_view_change_period""),
-                String::from(""sawtooth.consensus.pbft.message_timeout""),
-                String::from(""sawtooth.consensus.pbft.max_log_size""),
-            ],
-        )
-        .unwrap_or_else(|err| panic!(""Failed to load on-chain settings due to error: {:?}"", err));
+    debug!(""Getting on-chain settings for config"");
+    let settings: HashMap<String, String> = retry_until_ok(
+        config.exponential_retry_base,
+        config.exponential_retry_max,
+        || {
+            service.get_settings(
+                block_id.clone(),
+                vec![
+                    String::from(""sawtooth.consensus.pbft.peers""),
+                    String::from(""sawtooth.consensus.pbft.block_duration""),
+                    String::from(""sawtooth.consensus.pbft.exponential_retry_base""),",,2019-02-08 21:08:22,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/254350037,https://github.com/hyperledger/sawtooth-pbft/pull/85#discussion_r254350037,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/85,https://github.com/hyperledger/sawtooth-pbft/pull/85,"I think you should pass in the pbft config here and keep the args used only in main.rs. Otherwise, it would be awkward to use PbftEngine as library code.",9958c709636e10850ba898e177b4659bbffd83cd,2019-02-08 20:19:36,255222815,"@@ -28,13 +28,15 @@ use crate::node::PbftNode;
 use crate::state::{PbftMode, PbftState};
 use crate::storage::get_storage;
 use crate::timing;
+use crate::PbftCliArgs;
 
-#[derive(Default)]
-pub struct PbftEngine {}
+pub struct PbftEngine {
+    cli_args: PbftCliArgs,
+}
 
 impl PbftEngine {
-    pub fn new() -> Self {
-        PbftEngine {}
+    pub fn new(cli_args: PbftCliArgs) -> Self {",,2019-02-08 21:08:22,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/255222815,https://github.com/hyperledger/sawtooth-pbft/pull/85#discussion_r255222815,vaporos
https://github.com/hyperledger/sawtooth-pbft/pull/85,https://github.com/hyperledger/sawtooth-pbft/pull/85,Fixed,9958c709636e10850ba898e177b4659bbffd83cd,2019-02-08 21:15:00,255237628,"@@ -28,13 +28,15 @@ use crate::node::PbftNode;
 use crate::state::{PbftMode, PbftState};
 use crate::storage::get_storage;
 use crate::timing;
+use crate::PbftCliArgs;
 
-#[derive(Default)]
-pub struct PbftEngine {}
+pub struct PbftEngine {
+    cli_args: PbftCliArgs,
+}
 
 impl PbftEngine {
-    pub fn new() -> Self {
-        PbftEngine {}
+    pub fn new(cli_args: PbftCliArgs) -> Self {",,2019-02-08 21:15:00,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/255237628,https://github.com/hyperledger/sawtooth-pbft/pull/85#discussion_r255237628,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/83,https://github.com/hyperledger/sawtooth-pbft/pull/83,missing Creative Commons license,7bef6f53949b03b02624a4bee3fb49661b807715,2019-01-30 17:49:14,252366415,"@@ -0,0 +1,42 @@
+
+.. _pbft-on-chain-settings-label:
+
+On-Chain Settings
+=================
+
+The following on-chain settings are configurable, using the `settings
+transaction family
+<https://sawtooth.hyperledger.org/docs/core/releases/latest/transaction_family_specifications/settings_transaction_family.html>`__:
+
+
+- ``sawtooth.consensus.pbft.peers`` (required):
+
+  List of the peers in a Sawtooth PBFT network; a JSON-formatted string of
+  ``[<public-key-1>, <public-key-2>, ..., <public-key-n>]``.
+  ``sawtooth.consensus.pbft.peers`` could look something like this in a
+  four-node network:
+
+  .. code-block:: console
+
+    [
+      ""0203f3a0f914c9d80825b72346eeae42e884094ae3d0bd3c544c4c7e8ed37a3e6c"",
+      ""02f83c8fb57bb8dc4c72a4ba0846e5c14bc02228e1d627f5c2dcafa209b7c5ffd2"",
+      ""dc26a7099e81bb02869cc8ae57da030fbe4cf276b38ab37d2cc815fec63a14ab"",
+      ""df8e8388ced559bd35c2b05199ca9f8fbebb420979715003355dcb7363016c1d""
+    ]
+
+- | ``sawtooth.consensus.pbft.block_duration`` (optional, default 200 ms):
+  | How often to try to publish a block
+
+- | ``sawtooth.consensus.pbft.checkpoint_period`` (optional, default 100 blocks):
+  | How many committed blocks in between each checkpoint
+
+- | ``sawtooth.consensus.pbft.commit_timeout`` (optional, default 4000 ms):
+  | How long to wait between block commits before deeming a primary node faulty
+
+- | ``sawtooth.consensus.pbft.message_timeout`` (optional, default 10 ms):
+  | How long to wait for updates from the Consensus API
+
+- | ``sawtooth.consensus.pbft.max_log_size`` (optional, default 1000 messages):
+  | The maximum number of messages that can be in the log
+",43,2019-01-31 00:49:20,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/252366415,https://github.com/hyperledger/sawtooth-pbft/pull/83#discussion_r252366415,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/83,https://github.com/hyperledger/sawtooth-pbft/pull/83,Fixed.,7bef6f53949b03b02624a4bee3fb49661b807715,2019-01-31 01:01:32,252500489,"@@ -0,0 +1,42 @@
+
+.. _pbft-on-chain-settings-label:
+
+On-Chain Settings
+=================
+
+The following on-chain settings are configurable, using the `settings
+transaction family
+<https://sawtooth.hyperledger.org/docs/core/releases/latest/transaction_family_specifications/settings_transaction_family.html>`__:
+
+
+- ``sawtooth.consensus.pbft.peers`` (required):
+
+  List of the peers in a Sawtooth PBFT network; a JSON-formatted string of
+  ``[<public-key-1>, <public-key-2>, ..., <public-key-n>]``.
+  ``sawtooth.consensus.pbft.peers`` could look something like this in a
+  four-node network:
+
+  .. code-block:: console
+
+    [
+      ""0203f3a0f914c9d80825b72346eeae42e884094ae3d0bd3c544c4c7e8ed37a3e6c"",
+      ""02f83c8fb57bb8dc4c72a4ba0846e5c14bc02228e1d627f5c2dcafa209b7c5ffd2"",
+      ""dc26a7099e81bb02869cc8ae57da030fbe4cf276b38ab37d2cc815fec63a14ab"",
+      ""df8e8388ced559bd35c2b05199ca9f8fbebb420979715003355dcb7363016c1d""
+    ]
+
+- | ``sawtooth.consensus.pbft.block_duration`` (optional, default 200 ms):
+  | How often to try to publish a block
+
+- | ``sawtooth.consensus.pbft.checkpoint_period`` (optional, default 100 blocks):
+  | How many committed blocks in between each checkpoint
+
+- | ``sawtooth.consensus.pbft.commit_timeout`` (optional, default 4000 ms):
+  | How long to wait between block commits before deeming a primary node faulty
+
+- | ``sawtooth.consensus.pbft.message_timeout`` (optional, default 10 ms):
+  | How long to wait for updates from the Consensus API
+
+- | ``sawtooth.consensus.pbft.max_log_size`` (optional, default 1000 messages):
+  | The maximum number of messages that can be in the log
+",43,2019-01-31 01:01:32,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/252500489,https://github.com/hyperledger/sawtooth-pbft/pull/83#discussion_r252500489,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/82,https://github.com/hyperledger/sawtooth-pbft/pull/82,"Won't this crash the consensus engine? I understand this is already the current behavior, but it likely means that the consensus engine will crash if the validator crashes as well.",3ac622f79819c141fc9c29bcd6fa2a81ddb30305,2019-01-25 22:34:12,251157684,"@@ -976,6 +973,23 @@ impl PbftNode {
             )));
         }
 
+        // Verify the seal itself
+        self.verify_consensus_seal(&seal, block.signer_id.clone(), state)?;
+
+        Ok(())
+    }
+
+    /// Verify the given consenus seal
+    ///
+    /// # Panics
+    /// + If the node is unable to query the validator for on-chain settings",370,2019-01-29 16:55:51,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/251157684,https://github.com/hyperledger/sawtooth-pbft/pull/82#discussion_r251157684,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/82,https://github.com/hyperledger/sawtooth-pbft/pull/82,"Probably can just implement `From` for this error, given the number of times you've done this.",3ac622f79819c141fc9c29bcd6fa2a81ddb30305,2019-01-25 22:35:53,251158025,"@@ -1409,7 +1410,11 @@ mod tests {
             node.msg_log.add_message(message, state).unwrap();
         }
 
-        block.payload = node.build_seal(state).unwrap();
+        let seal = node.build_seal(state).unwrap();
+        block.payload = seal
+            .write_to_bytes()
+            .map_err(|err| PbftError::SerializationError(""Error writing seal to bytes"".into(), err))",509,2019-01-29 16:55:51,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/251158025,https://github.com/hyperledger/sawtooth-pbft/pull/82#discussion_r251158025,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/82,https://github.com/hyperledger/sawtooth-pbft/pull/82,"Yes, this is true. I think the correct way to handle this would be to try again until the validator responds. However, I think that this may actually be getting the peers from the wrong block; it should be getting the peers from the block previous to the one the seal is for, since that's when the votes were actually cast. I will need to rethink that bit, but the question about how to properly handle when the validator isn't available still stands.",3ac622f79819c141fc9c29bcd6fa2a81ddb30305,2019-01-29 16:53:36,251921931,"@@ -976,6 +973,23 @@ impl PbftNode {
             )));
         }
 
+        // Verify the seal itself
+        self.verify_consensus_seal(&seal, block.signer_id.clone(), state)?;
+
+        Ok(())
+    }
+
+    /// Verify the given consenus seal
+    ///
+    /// # Panics
+    /// + If the node is unable to query the validator for on-chain settings",370,2019-01-29 16:55:51,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/251921931,https://github.com/hyperledger/sawtooth-pbft/pull/82#discussion_r251921931,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/82,https://github.com/hyperledger/sawtooth-pbft/pull/82,"Okay if I include implementing `From` for error types in a different PR, or would you prefer I do that in this one?",3ac622f79819c141fc9c29bcd6fa2a81ddb30305,2019-01-29 16:54:11,251922193,"@@ -1409,7 +1410,11 @@ mod tests {
             node.msg_log.add_message(message, state).unwrap();
         }
 
-        block.payload = node.build_seal(state).unwrap();
+        let seal = node.build_seal(state).unwrap();
+        block.payload = seal
+            .write_to_bytes()
+            .map_err(|err| PbftError::SerializationError(""Error writing seal to bytes"".into(), err))",509,2019-01-29 16:55:51,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/251922193,https://github.com/hyperledger/sawtooth-pbft/pull/82#discussion_r251922193,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/79,https://github.com/hyperledger/sawtooth-pbft/pull/79,"If this is meant to sort the terms, it does not work as is currently. Please either remove this line or figure out what is missing. ",84b323c186a8a9be1cc002e527d19d49acfb22a6,2019-01-23 19:26:32,250339243,"@@ -1,84 +1,88 @@
 Glossary
 ========
 
-+-------------------+--------------------------------------------------+
-| Term              | Definition                                       |
-+===================+==================================================+
-| Node              | Machine running all the components necessary for |
-|                   | a working blockchain (including the Validator,   |
-|                   | the REST API, at least one transaction           |
-|                   | processor, and the PBFT algorithm itself). In    |
-|                   | this RFC, unless otherwise specified, it can be  |
-|                   | assumed that *Node* refers to the PBFT component |
-|                   | of the machine.                                  |
-+-------------------+--------------------------------------------------+
-| Server            | Synonym for node.                                |
-+-------------------+--------------------------------------------------+
-| Replica           | Synonym for node.                                |
-+-------------------+--------------------------------------------------+
-| Validator         | Component of a node responsible for interactions |
-|                   | with the blockchain. Interactions with the       |
-|                   | validator are abstracted by the Consensus API.   |
-+-------------------+--------------------------------------------------+
-| Block             | A part of the                                    |
-|                   | `blockchain <https://en.wikipedia.org/wiki/Block |
-|                   | chain>`__,                                       |
-|                   | containing some operations and a link to the     |
-|                   | previous block.                                  |
-+-------------------+--------------------------------------------------+
-| Primary           | Node in charge of making the final consensus     |
-|                   | decisions and committing to the blockchain.      |
-|                   | Additionally is responsible for publishing the   |
-|                   | blocks given to it by the Consensus API, and     |
-|                   | starting the consensus process.                  |
-+-------------------+--------------------------------------------------+
-| Secondaries       | Auxiliary nodes used for consensus.              |
-+-------------------+--------------------------------------------------+
-| Client            | Machine that sends requests to and receives      |
-|                   | replies from the network of nodes. PBFT has no   |
-|                   | direct interaction with clients; the Validator   |
-|                   | bundles all client requests into blocks and      |
-|                   | sends them through the Consensus API to the      |
-|                   | consensus algorithm.                             |
-+-------------------+--------------------------------------------------+
-| Checkpoint        | Mode when log messages can be garbage collected. |
-|                   | Checkpointing is triggered when a certain number |
-|                   | of blocks have been committed.                   |
-+-------------------+--------------------------------------------------+
-| Checkpoint period | How many blocks are published in between each    |
-|                   | checkpoint.                                      |
-+-------------------+--------------------------------------------------+
-| Consensus seal    | Proof that a block underwent consensus           |
-+-------------------+--------------------------------------------------+
-| Block duration    | How many seconds to wait before trying to        |
-|                   | publish a block.                                 |
-+-------------------+--------------------------------------------------+
-| Message           | Block, with additional information (see `Message |
-|                   | Types <message-types.html>`__).                  |
-+-------------------+--------------------------------------------------+
-| Working block     | The block that has been initialized but not      |
-|                   | finalized, and is currently being committed to.  |
-+-------------------+--------------------------------------------------+
-| Low water mark    | The sequence number of the last stable           |
-|                   | checkpoint.                                      |
-+-------------------+--------------------------------------------------+
-| High water mark   | Low water mark plus the desired maximum size of  |
-|                   | nodes’ message logs.                             |
-+-------------------+--------------------------------------------------+
-| View              | The period of time of PBFT when the current      |
-|                   | primary is in charge. The view changes when the  |
-|                   | primary is deemed faulty, as described in        |
-|                   | `View Changes <#view-changes>`__.                |
-+-------------------+--------------------------------------------------+
-| :math:`n`         | The total number of nodes in the network.        |
-+-------------------+--------------------------------------------------+
-| :math:`f`         | The maximum number of faulty nodes.              |
-+-------------------+--------------------------------------------------+
-| :math:`v`         | The current view number (how many primary node   |
-|                   | changes have occurred).                          |
-+-------------------+--------------------------------------------------+
-| :math:`p`         | The primary server number; :math:`p = v \mod n`. |
-+-------------------+--------------------------------------------------+
+.. glossary::
+   :sorted:",,2019-01-23 21:50:33,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/250339243,https://github.com/hyperledger/sawtooth-pbft/pull/79#discussion_r250339243,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/79,https://github.com/hyperledger/sawtooth-pbft/pull/79,Done. (I removed the line.),84b323c186a8a9be1cc002e527d19d49acfb22a6,2019-01-23 21:51:31,250386483,"@@ -1,84 +1,88 @@
 Glossary
 ========
 
-+-------------------+--------------------------------------------------+
-| Term              | Definition                                       |
-+===================+==================================================+
-| Node              | Machine running all the components necessary for |
-|                   | a working blockchain (including the Validator,   |
-|                   | the REST API, at least one transaction           |
-|                   | processor, and the PBFT algorithm itself). In    |
-|                   | this RFC, unless otherwise specified, it can be  |
-|                   | assumed that *Node* refers to the PBFT component |
-|                   | of the machine.                                  |
-+-------------------+--------------------------------------------------+
-| Server            | Synonym for node.                                |
-+-------------------+--------------------------------------------------+
-| Replica           | Synonym for node.                                |
-+-------------------+--------------------------------------------------+
-| Validator         | Component of a node responsible for interactions |
-|                   | with the blockchain. Interactions with the       |
-|                   | validator are abstracted by the Consensus API.   |
-+-------------------+--------------------------------------------------+
-| Block             | A part of the                                    |
-|                   | `blockchain <https://en.wikipedia.org/wiki/Block |
-|                   | chain>`__,                                       |
-|                   | containing some operations and a link to the     |
-|                   | previous block.                                  |
-+-------------------+--------------------------------------------------+
-| Primary           | Node in charge of making the final consensus     |
-|                   | decisions and committing to the blockchain.      |
-|                   | Additionally is responsible for publishing the   |
-|                   | blocks given to it by the Consensus API, and     |
-|                   | starting the consensus process.                  |
-+-------------------+--------------------------------------------------+
-| Secondaries       | Auxiliary nodes used for consensus.              |
-+-------------------+--------------------------------------------------+
-| Client            | Machine that sends requests to and receives      |
-|                   | replies from the network of nodes. PBFT has no   |
-|                   | direct interaction with clients; the Validator   |
-|                   | bundles all client requests into blocks and      |
-|                   | sends them through the Consensus API to the      |
-|                   | consensus algorithm.                             |
-+-------------------+--------------------------------------------------+
-| Checkpoint        | Mode when log messages can be garbage collected. |
-|                   | Checkpointing is triggered when a certain number |
-|                   | of blocks have been committed.                   |
-+-------------------+--------------------------------------------------+
-| Checkpoint period | How many blocks are published in between each    |
-|                   | checkpoint.                                      |
-+-------------------+--------------------------------------------------+
-| Consensus seal    | Proof that a block underwent consensus           |
-+-------------------+--------------------------------------------------+
-| Block duration    | How many seconds to wait before trying to        |
-|                   | publish a block.                                 |
-+-------------------+--------------------------------------------------+
-| Message           | Block, with additional information (see `Message |
-|                   | Types <message-types.html>`__).                  |
-+-------------------+--------------------------------------------------+
-| Working block     | The block that has been initialized but not      |
-|                   | finalized, and is currently being committed to.  |
-+-------------------+--------------------------------------------------+
-| Low water mark    | The sequence number of the last stable           |
-|                   | checkpoint.                                      |
-+-------------------+--------------------------------------------------+
-| High water mark   | Low water mark plus the desired maximum size of  |
-|                   | nodes’ message logs.                             |
-+-------------------+--------------------------------------------------+
-| View              | The period of time of PBFT when the current      |
-|                   | primary is in charge. The view changes when the  |
-|                   | primary is deemed faulty, as described in        |
-|                   | `View Changes <#view-changes>`__.                |
-+-------------------+--------------------------------------------------+
-| :math:`n`         | The total number of nodes in the network.        |
-+-------------------+--------------------------------------------------+
-| :math:`f`         | The maximum number of faulty nodes.              |
-+-------------------+--------------------------------------------------+
-| :math:`v`         | The current view number (how many primary node   |
-|                   | changes have occurred).                          |
-+-------------------+--------------------------------------------------+
-| :math:`p`         | The primary server number; :math:`p = v \mod n`. |
-+-------------------+--------------------------------------------------+
+.. glossary::
+   :sorted:",,2019-01-23 21:59:16,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/250386483,https://github.com/hyperledger/sawtooth-pbft/pull/79#discussion_r250386483,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/75,https://github.com/hyperledger/sawtooth-pbft/pull/75,"While this is more readable, we are performing this more expensive check before the less expensive check of `block.block_num != state.seq_num`.  Consider a way to reorder this.",04972899750727ecf9a0b3325c9f3632d17c2d25,2019-01-22 16:56:34,249870901,"@@ -472,6 +472,26 @@ impl PbftNode {
             return Ok(());
         }
 
+        // Make sure the node already has the previous block, since the consensus seal can't be
+        // verified without it; the node has the previous block if 1) this block is for the current
+        // sequence number (previous block is already committed), or 2) the previous block is in
+        // the log
+        let has_previous_block_in_log = self",,2019-01-23 15:35:09,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/249870901,https://github.com/hyperledger/sawtooth-pbft/pull/75#discussion_r249870901,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/75,https://github.com/hyperledger/sawtooth-pbft/pull/75,"Added two commits (""Rename `log_has_required_msgs`"" and ""Refactor checking for block in log behind method""), and updated ""Enforce that previous BlockNew has been received"" and ""Remove PbftBlock protobuf"" to fix this.",04972899750727ecf9a0b3325c9f3632d17c2d25,2019-01-22 17:49:46,249891365,"@@ -472,6 +472,26 @@ impl PbftNode {
             return Ok(());
         }
 
+        // Make sure the node already has the previous block, since the consensus seal can't be
+        // verified without it; the node has the previous block if 1) this block is for the current
+        // sequence number (previous block is already committed), or 2) the previous block is in
+        // the log
+        let has_previous_block_in_log = self",,2019-01-23 15:35:09,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/249891365,https://github.com/hyperledger/sawtooth-pbft/pull/75#discussion_r249891365,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/73,https://github.com/hyperledger/sawtooth-pbft/pull/73,"What's the content of the message? If it is a peer ID, it may be useful to add it to the log message.",b01076f739e0673b6fc2f6a42120d7b49726572c,2019-01-14 23:11:40,247702275,"@@ -142,20 +146,23 @@ fn handle_update(
 
             if signer_id != sender_id {
                 return Err(PbftError::InternalError(format!(
-                    ""Mismatch between sender ID ({:?}) and signer ID ({:?})!"",
-                    sender_id, signer_id
+                    ""Mismatch between sender ID ({:?}) and signer ID ({:?}) of peer message: {:?}"",
+                    sender_id, signer_id, parsed_message
                 )));
             }
 
             node.on_peer_message(parsed_message, state)?
         }
-        Ok(Update::Shutdown) => return Ok(false),
+        Ok(Update::Shutdown) => {
+            info!(""Received shutdown; stopping PBFT"");
+            return Ok(false);
+        }
         Ok(Update::PeerConnected(_)) | Ok(Update::PeerDisconnected(_)) => {
-            debug!(""Received PeerConnected/PeerDisconnected message"");
+            info!(""Received PeerConnected/PeerDisconnected message"");",,2019-01-16 23:04:37,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/247702275,https://github.com/hyperledger/sawtooth-pbft/pull/73#discussion_r247702275,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/73,https://github.com/hyperledger/sawtooth-pbft/pull/73,Would probably be useful to include the message type in the warning message,b01076f739e0673b6fc2f6a42120d7b49726572c,2019-01-15 16:36:20,247968399,"@@ -105,7 +104,7 @@ impl PbftNode {
             PbftMessageType::Commit => self.handle_commit(msg, state)?,
             PbftMessageType::ViewChange => self.handle_view_change(&msg, state)?,
             PbftMessageType::NewView => self.handle_new_view(&msg, state)?,
-            _ => warn!(""Message type not implemented""),
+            _ => warn!(""Received message with unknown type""),",,2019-01-16 23:04:37,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/247968399,https://github.com/hyperledger/sawtooth-pbft/pull/73#discussion_r247968399,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/73,https://github.com/hyperledger/sawtooth-pbft/pull/73,Fixed,b01076f739e0673b6fc2f6a42120d7b49726572c,2019-01-15 18:12:23,248004503,"@@ -142,20 +146,23 @@ fn handle_update(
 
             if signer_id != sender_id {
                 return Err(PbftError::InternalError(format!(
-                    ""Mismatch between sender ID ({:?}) and signer ID ({:?})!"",
-                    sender_id, signer_id
+                    ""Mismatch between sender ID ({:?}) and signer ID ({:?}) of peer message: {:?}"",
+                    sender_id, signer_id, parsed_message
                 )));
             }
 
             node.on_peer_message(parsed_message, state)?
         }
-        Ok(Update::Shutdown) => return Ok(false),
+        Ok(Update::Shutdown) => {
+            info!(""Received shutdown; stopping PBFT"");
+            return Ok(false);
+        }
         Ok(Update::PeerConnected(_)) | Ok(Update::PeerDisconnected(_)) => {
-            debug!(""Received PeerConnected/PeerDisconnected message"");
+            info!(""Received PeerConnected/PeerDisconnected message"");",,2019-01-16 23:04:37,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/248004503,https://github.com/hyperledger/sawtooth-pbft/pull/73#discussion_r248004503,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/73,https://github.com/hyperledger/sawtooth-pbft/pull/73,Fixed,b01076f739e0673b6fc2f6a42120d7b49726572c,2019-01-15 18:12:29,248004548,"@@ -105,7 +104,7 @@ impl PbftNode {
             PbftMessageType::Commit => self.handle_commit(msg, state)?,
             PbftMessageType::ViewChange => self.handle_view_change(&msg, state)?,
             PbftMessageType::NewView => self.handle_new_view(&msg, state)?,
-            _ => warn!(""Message type not implemented""),
+            _ => warn!(""Received message with unknown type""),",,2019-01-16 23:04:37,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/248004548,https://github.com/hyperledger/sawtooth-pbft/pull/73#discussion_r248004548,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/73,https://github.com/hyperledger/sawtooth-pbft/pull/73,"These log_any_error() calls seem a bit awkward. In any case, this might be a good use for a macro.",b01076f739e0673b6fc2f6a42120d7b49726572c,2019-01-16 21:20:42,248454585,"@@ -94,7 +94,7 @@ impl Engine for PbftEngine {
                 // ViewChange if necessary
                 if node.check_faulty_primary_timeout_expired(state) {
                     warn!(""Faulty primary timeout expired; proposing view change"");
-                    handle_pbft_result(node.start_view_change(state, state.view + 1));
+                    log_any_error(node.start_view_change(state, state.view + 1));",64,2019-01-16 23:04:37,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/248454585,https://github.com/hyperledger/sawtooth-pbft/pull/73#discussion_r248454585,vaporos
https://github.com/hyperledger/sawtooth-pbft/pull/73,https://github.com/hyperledger/sawtooth-pbft/pull/73,"Could you explain what makes this a good use for a macro? Or do you have other suggestions for how to make this less awkward? The only thing I can think of at the moment would be to just call `.unwrap_or_else(|err| error!(""{}"", err)` in these situations.",b01076f739e0673b6fc2f6a42120d7b49726572c,2019-01-16 23:43:58,248493620,"@@ -94,7 +94,7 @@ impl Engine for PbftEngine {
                 // ViewChange if necessary
                 if node.check_faulty_primary_timeout_expired(state) {
                     warn!(""Faulty primary timeout expired; proposing view change"");
-                    handle_pbft_result(node.start_view_change(state, state.view + 1));
+                    log_any_error(node.start_view_change(state, state.view + 1));",64,2019-01-16 23:43:58,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/248493620,https://github.com/hyperledger/sawtooth-pbft/pull/73#discussion_r248493620,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,"Looking at the history the license should only be for Bitwise, We only add Cargill if there was a significant change to the file. ",eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-08 19:11:19,246117031,"@@ -1,3 +1,21 @@
+/*
+ * Copyright 2019 Bitwise IO, Inc.
+ * Copyright 2019 Cargill Incorporated",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/246117031,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r246117031,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,Fixed,eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-08 19:32:30,246123812,"@@ -1,3 +1,21 @@
+/*
+ * Copyright 2019 Bitwise IO, Inc.
+ * Copyright 2019 Cargill Incorporated",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/246123812,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r246123812,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,"If this has clippy complaining about the `ParsedMessage` parameter, just make it a reference, instead of ignoring it.",eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-08 22:28:54,246174621,"@@ -386,6 +293,125 @@ impl PbftNode {
         Ok(())
     }
 
+    /// Handle a `ViewChange` message
+    ///
+    /// When a `ViewChange` is received, check that it isn't outdated and add it to the log. If the
+    /// node isn't already view changing but it now has f + 1 ViewChange messages, start view
+    /// changing early. If the node is the primary and has 2f view change messages now, broadcast
+    /// the NewView message to the rest of the nodes to move to the new view.
+    #[allow(clippy::needless_pass_by_value)]",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/246174621,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r246174621,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,Why not just `new`?,eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-08 22:38:10,246179307,"@@ -109,3 +109,19 @@ impl From<Block> for PbftBlock {
         pbft_block
     }
 }
+
+impl PbftMessageInfo {
+    pub fn new_from(",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/246179307,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r246179307,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,"I think the date should be 2018, if that's when the file was added.",eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-08 22:43:08,246182475,"@@ -1,3 +1,20 @@
+/*
+ * Copyright 2019 Bitwise IO, Inc.",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/246182475,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r246182475,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,"If you split `filter_map` to a separate `filter` and `map` call, you can do this call to `cloned` after you've filtered the results. ",eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-08 22:45:29,246184007,"@@ -698,15 +699,39 @@ impl PbftNode {
     fn build_seal(&mut self, state: &PbftState, summary: Vec<u8>) -> Result<Vec<u8>, PbftError> {
         info!(""{}: Building seal for block {}"", state, state.seq_num - 1);
 
-        let min_votes = 2 * state.f;
+        // The previous block may have been committed in a different view, so the node will need
+        // find the view that contains the required 2f Commit messages for building the seal
         let messages = self
             .msg_log
-            .get_enough_messages(PbftMessageType::Commit, state.seq_num - 1, min_votes)
+            .get_messages_of_type_seq(PbftMessageType::Commit, state.seq_num - 1)
+            .iter()
+            .cloned()",1063,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/246184007,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r246184007,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,`get_first_msg` seems like a better name.,eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-08 22:47:05,246184988,"@@ -123,29 +127,19 @@ impl PbftLog {
         msgs.len() as u64 >= required
     }
 
-    /// Add a generic PBFT message to the log
-    pub fn add_message(&mut self, msg: ParsedMessage, state: &PbftState) -> Result<(), PbftError> {
-        // Except for ViewChanges, the message must be for the current view to be accepted
-        let msg_type = PbftMessageType::from(msg.info().get_msg_type());
-        if msg_type != PbftMessageType::ViewChange && msg.info().get_view() != state.view {
-            error!(
-                ""Got message with mismatched view number; {} != {}"",
-                msg.info().get_view(),
-                state.view,
-            );
-            return Err(PbftError::ViewMismatch(
-                msg.info().get_view() as usize,
-                state.view as usize,
-            ));
-        }
-
-        self.messages.insert(msg);
-        trace!(""{}"", self);
-
-        Ok(())
+    /// Get the first message matching the type, view, and sequence number of the `info` (if one
+    /// exists)
+    pub fn get_one_msg(",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/246184988,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r246184988,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,"This method should maybe be changed to panic if the wrong phase is passed in, instead of being removed.  It's guarding the state transitions (the PBFT state machine should only transition in specific ways).",eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-08 22:55:09,246189978,"@@ -192,26 +192,6 @@ impl PbftState {
         self.id == self.get_primary_id_at_view(view)
     }
 
-    /// Go to a phase and return new phase, if successfully changed
-    /// Enforces sequential ordering of PBFT phases in normal mode.
-    pub fn switch_phase(&mut self, desired_phase: PbftPhase) -> Option<PbftPhase> {",96,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/246189978,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r246189978,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,"Protobuf automatically generates a `new` method that gives you an empty struct, so I had to use a different name for a pre-populated one.",eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-09 15:37:29,246428333,"@@ -109,3 +109,19 @@ impl From<Block> for PbftBlock {
         pbft_block
     }
 }
+
+impl PbftMessageInfo {
+    pub fn new_from(",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/246428333,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r246428333,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,"I don't think it's necessarily fatal to transition in an invalid way; for instance, if somehow we were to switch from `PrePreparing` to `Committing` and skip the `Preparing` phase, as long as we eventually get 2f + 1 `Prepare` messages, we can just continue on as usual. In my opinion, as long as there's good logging to be able to detect the cause of a fault when things break (the subject of a future PR) and these kinds of errors don't lead to violating the rules of the algorithm (other guards like # of required messages ensure that), then panicking probably isn't the right choice.",eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-09 15:56:27,246436655,"@@ -192,26 +192,6 @@ impl PbftState {
         self.id == self.get_primary_id_at_view(view)
     }
 
-    /// Go to a phase and return new phase, if successfully changed
-    /// Enforces sequential ordering of PBFT phases in normal mode.
-    pub fn switch_phase(&mut self, desired_phase: PbftPhase) -> Option<PbftPhase> {",96,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/246436655,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r246436655,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,Fixed,eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-09 15:57:20,246437031,"@@ -386,6 +293,125 @@ impl PbftNode {
         Ok(())
     }
 
+    /// Handle a `ViewChange` message
+    ///
+    /// When a `ViewChange` is received, check that it isn't outdated and add it to the log. If the
+    /// node isn't already view changing but it now has f + 1 ViewChange messages, start view
+    /// changing early. If the node is the primary and has 2f view change messages now, broadcast
+    /// the NewView message to the rest of the nodes to move to the new view.
+    #[allow(clippy::needless_pass_by_value)]",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/246437031,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r246437031,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,Fixed,eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-09 15:57:29,246437105,"@@ -1,3 +1,20 @@
+/*
+ * Copyright 2019 Bitwise IO, Inc.",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/246437105,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r246437105,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,Fixed,eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-09 15:57:35,246437146,"@@ -698,15 +699,39 @@ impl PbftNode {
     fn build_seal(&mut self, state: &PbftState, summary: Vec<u8>) -> Result<Vec<u8>, PbftError> {
         info!(""{}: Building seal for block {}"", state, state.seq_num - 1);
 
-        let min_votes = 2 * state.f;
+        // The previous block may have been committed in a different view, so the node will need
+        // find the view that contains the required 2f Commit messages for building the seal
         let messages = self
             .msg_log
-            .get_enough_messages(PbftMessageType::Commit, state.seq_num - 1, min_votes)
+            .get_messages_of_type_seq(PbftMessageType::Commit, state.seq_num - 1)
+            .iter()
+            .cloned()",1063,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/246437146,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r246437146,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,Fixed,eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-09 15:57:41,246437197,"@@ -123,29 +127,19 @@ impl PbftLog {
         msgs.len() as u64 >= required
     }
 
-    /// Add a generic PBFT message to the log
-    pub fn add_message(&mut self, msg: ParsedMessage, state: &PbftState) -> Result<(), PbftError> {
-        // Except for ViewChanges, the message must be for the current view to be accepted
-        let msg_type = PbftMessageType::from(msg.info().get_msg_type());
-        if msg_type != PbftMessageType::ViewChange && msg.info().get_view() != state.view {
-            error!(
-                ""Got message with mismatched view number; {} != {}"",
-                msg.info().get_view(),
-                state.view,
-            );
-            return Err(PbftError::ViewMismatch(
-                msg.info().get_view() as usize,
-                state.view as usize,
-            ));
-        }
-
-        self.messages.insert(msg);
-        trace!(""{}"", self);
-
-        Ok(())
+    /// Get the first message matching the type, view, and sequence number of the `info` (if one
+    /// exists)
+    pub fn get_one_msg(",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/246437197,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r246437197,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,"Faulty state transitions could be considered programming errors.  The incorrect state request, as a result of an incoming message should be ignored and logged at that point.  If the call to switch state is being made with the wrong state transition, it means the developer hasn't properly vetted the inputs before attempting the state transition.",eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-09 16:00:51,246438609,"@@ -192,26 +192,6 @@ impl PbftState {
         self.id == self.get_primary_id_at_view(view)
     }
 
-    /// Go to a phase and return new phase, if successfully changed
-    /// Enforces sequential ordering of PBFT phases in normal mode.
-    pub fn switch_phase(&mut self, desired_phase: PbftPhase) -> Option<PbftPhase> {",96,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/246438609,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r246438609,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,"Makes sense; I've updated the method to panic and explained the change in a new commit that replaces the old one: ""Update switch_phase method to panic""",eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-09 16:21:42,246447066,"@@ -192,26 +192,6 @@ impl PbftState {
         self.id == self.get_primary_id_at_view(view)
     }
 
-    /// Go to a phase and return new phase, if successfully changed
-    /// Enforces sequential ordering of PBFT phases in normal mode.
-    pub fn switch_phase(&mut self, desired_phase: PbftPhase) -> Option<PbftPhase> {",96,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/246447066,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r246447066,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,Isn't &[ better here?,eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-14 17:48:46,247591306,"@@ -384,25 +384,22 @@ mod tests {
         log.garbage_collect(5);
 
         for old in 1..3 {
-            for msg_type in &[
+            for msg_type in vec![",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/247591306,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r247591306,vaporos
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,"Why do we need to warn here, if we are propagating the error up? Won't the caller likely log this too?",eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-14 17:55:48,247593607,"@@ -411,520 +412,549 @@ impl PbftNode {
         Ok(())
     }
 
-    /// Verify that the vote is properly signed
-    fn verify_vote_signer(vote: &PbftSignedVote) -> Result<(), PbftError> {
-        let header: ConsensusPeerMessageHeader =
-            protobuf::parse_from_bytes(&vote.get_header_bytes())
-                .map_err(PbftError::SerializationError)?;
-
-        let key = Secp256k1PublicKey::from_hex(&hex::encode(&header.signer_id)).unwrap();
+    /// Handle a `BlockNew` update from the Validator
+    ///
+    /// The validator has received a new block; verify the block's consensus seal and add the
+    /// BlockNew to the message log. If this is the block we are waiting for: set it as the working
+    /// block, update the idle & commit timers, and broadcast a PrePrepare if this node is the
+    /// primary. If this is the block after the one this node is working on, use it to catch up.
+    pub fn on_block_new(&mut self, block: Block, state: &mut PbftState) -> Result<(), PbftError> {
+        info!(
+            ""{}: Got BlockNew: {} / {}"",
+            state,
+            block.block_num,
+            hex::encode(&block.block_id[..3]),
+        );
 
-        let context = create_context(""secp256k1"")
-            .map_err(|err| PbftError::InternalError(format!(""Couldn't create context: {}"", err)))?;
+        if block.block_num < state.seq_num {
+            info!(
+                ""Ignoring block ({}) that's older than current sequence number ({})."",
+                block.block_num, state.seq_num
+            );
+            return Ok(());
+        }
 
-        match context.verify(
-            &hex::encode(vote.get_header_signature()),
-            vote.get_header_bytes(),
-            &key,
-        ) {
-            Ok(true) => {}
-            Ok(false) => {
-                return Err(PbftError::InternalError(
-                    ""Header failed verification!"".into(),
-                ))
-            }
+        match self.verify_consensus_seal(&block, state) {
+            Ok(_) => {}
             Err(err) => {
-                return Err(PbftError::InternalError(format!(
-                    ""Error while verifying header: {:?}"",
+                warn!(",717,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/247593607,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r247593607,vaporos
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,"Same here, shouldn't the caller log the error?",eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-14 17:57:12,247594141,"@@ -411,520 +412,549 @@ impl PbftNode {
         Ok(())
     }
 
-    /// Verify that the vote is properly signed
-    fn verify_vote_signer(vote: &PbftSignedVote) -> Result<(), PbftError> {
-        let header: ConsensusPeerMessageHeader =
-            protobuf::parse_from_bytes(&vote.get_header_bytes())
-                .map_err(PbftError::SerializationError)?;
-
-        let key = Secp256k1PublicKey::from_hex(&hex::encode(&header.signer_id)).unwrap();
+    /// Handle a `BlockNew` update from the Validator
+    ///
+    /// The validator has received a new block; verify the block's consensus seal and add the
+    /// BlockNew to the message log. If this is the block we are waiting for: set it as the working
+    /// block, update the idle & commit timers, and broadcast a PrePrepare if this node is the
+    /// primary. If this is the block after the one this node is working on, use it to catch up.
+    pub fn on_block_new(&mut self, block: Block, state: &mut PbftState) -> Result<(), PbftError> {
+        info!(
+            ""{}: Got BlockNew: {} / {}"",
+            state,
+            block.block_num,
+            hex::encode(&block.block_id[..3]),
+        );
 
-        let context = create_context(""secp256k1"")
-            .map_err(|err| PbftError::InternalError(format!(""Couldn't create context: {}"", err)))?;
+        if block.block_num < state.seq_num {
+            info!(
+                ""Ignoring block ({}) that's older than current sequence number ({})."",
+                block.block_num, state.seq_num
+            );
+            return Ok(());
+        }
 
-        match context.verify(
-            &hex::encode(vote.get_header_signature()),
-            vote.get_header_bytes(),
-            &key,
-        ) {
-            Ok(true) => {}
-            Ok(false) => {
-                return Err(PbftError::InternalError(
-                    ""Header failed verification!"".into(),
-                ))
-            }
+        match self.verify_consensus_seal(&block, state) {
+            Ok(_) => {}
             Err(err) => {
-                return Err(PbftError::InternalError(format!(
-                    ""Error while verifying header: {:?}"",
+                warn!(
+                    ""Failing block due to failed consensus seal verification and \
+                     proposing view change! Error was {}"",
                     err
-                )))
+                );
+                self.service.fail_block(block.block_id).map_err(|err| {
+                    PbftError::InternalError(format!(""Couldn't fail block: {}"", err))
+                })?;
+                self.propose_view_change(state, state.view + 1)?;
+                return Err(err);
             }
         }
 
-        verify_sha512(vote.get_message_bytes(), header.get_content_sha512())?;
+        // Create PBFT message for BlockNew and add it to the log
+        let mut msg = PbftMessage::new();
+        msg.set_info(handlers::make_msg_info(
+            &PbftMessageType::BlockNew,
+            state.view,
+            block.block_num,
+            state.id.clone(),
+        ));
 
-        Ok(())
-    }
+        let pbft_block = pbft_block_from_block(block.clone());
+        msg.set_block(pbft_block.clone());
 
-    /// Verify an individual view change vote
-    ///
-    /// Return the signer ID of the wrapped PbftMessage for use in further verification
-    fn verify_view_change_vote(vote: &PbftSignedVote, view: u64) -> Result<PeerId, PbftError> {
-        let message: PbftMessage = protobuf::parse_from_bytes(&vote.get_message_bytes())
-            .map_err(PbftError::SerializationError)?;
+        self.msg_log
+            .add_message(ParsedMessage::from_pbft_message(msg.clone()), state)?;
 
-        if PbftMessageType::from(message.get_info().get_msg_type()) != PbftMessageType::ViewChange {
-            return Err(PbftError::InternalError(format!(
-                ""Received view change vote that is not a ViewChange: {:?}"",
-                message
-            )));
-        }
+        // We can use this block's seal to commit the next block (i.e. catch-up) if it's the block
+        // after the one we're waiting for and we haven't already told the validator to commit the
+        // block we're waiting for
+        if block.block_num == state.seq_num + 1 && state.phase != PbftPhase::Finished {
+            self.catchup(state, &block)?;
+        } else if block.block_num == state.seq_num {
+            // This is the block we're waiting for, so we update state
+            state.working_block = Some(msg.get_block().clone());
 
-        if message.get_info().get_view() != view {
-            return Err(PbftError::InternalError(format!(
-                ""ViewChange's view ({:?}) does not match NewView's view ({:?})"",
-                message.get_info().get_view(),
-                view,
-            )));
+            // Send PrePrepare messages if we're the primary
+            if state.is_primary() {
+                let s = state.seq_num;
+                self._broadcast_pbft_message(s, &PbftMessageType::PrePrepare, pbft_block, state)?;
+            }
         }
 
-        Self::verify_vote_signer(vote)?;
-
-        Ok(PeerId::from(message.get_info().get_signer_id()))
+        Ok(())
     }
 
-    /// Verifies that the NewView messsage is valid
-    fn verify_new_view(
-        &mut self,
-        new_view: &PbftNewView,
-        state: &mut PbftState,
-    ) -> Result<(), PbftError> {
-        // Make sure this is from the new primary
-        if PeerId::from(new_view.get_info().get_signer_id())
-            != state.get_primary_id_at_view(new_view.get_info().get_view())
-        {
-            error!(
-                ""Got NewView message ({:?}) from node that is not primary for new view"",
-                new_view,
-            );
-            return Err(PbftError::NotFromPrimary);
-        }
-
-        // Verify each individual vote, and extract the signer ID from each ViewChange that
-        // it contains so we can verify the IDs themselves
-        let voter_ids =
-            new_view
-                .get_view_changes()
-                .iter()
-                .try_fold(HashSet::new(), |mut ids, v| {
-                    Self::verify_view_change_vote(v, new_view.get_info().get_view())
-                        .and_then(|vid| Ok(ids.insert(vid)))?;
-                    Ok(ids)
-                })?;
-
-        // All of the votes must come from known peers, and the new primary can't
-        // explicitly vote itself, since broacasting the NewView is an implicit vote. Check
-        // that the votes we've received are a subset of ""peers - primary"".
-        let peer_ids: HashSet<_> = state
-            .peer_ids
-            .iter()
-            .cloned()
-            .filter(|pid| pid != &PeerId::from(new_view.get_info().get_signer_id()))
-            .collect();
+    /// Use the given block's consensus seal to verify and commit the block this node is working on
+    fn catchup(&mut self, state: &mut PbftState, block: &Block) -> Result<(), PbftError> {
+        info!(
+            ""{}: Trying catchup to #{} from BlockNew message #{}"",
+            state, state.seq_num, block.block_num,
+        );
 
-        if !voter_ids.is_subset(&peer_ids) {
-            return Err(PbftError::InternalError(format!(
-                ""Got unexpected vote IDs when verifying NewView: {:?}"",
-                voter_ids.difference(&peer_ids).collect::<Vec<_>>()
-            )));
-        }
+        match state.working_block {
+            Some(ref working_block) => {
+                let block_num_matches = block.block_num == working_block.get_block_num() + 1;
+                let block_id_matches = block.previous_id == working_block.get_block_id();
 
-        // Check that we've received 2f votes, since the primary vote is implicit
-        if voter_ids.len() < 2 * state.f as usize {
-            return Err(PbftError::InternalError(format!(
-                ""Need {} votes, only found {}!"",
-                2 * state.f,
-                voter_ids.len()
-            )));
+                if !block_num_matches || !block_id_matches {
+                    error!(",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/247594141,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r247594141,vaporos
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,"This is a poor logging message as it includes no unique information; but also, shouldn't this be logged by the caller?",eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-14 17:58:53,247594779,"@@ -411,520 +412,549 @@ impl PbftNode {
         Ok(())
     }
 
-    /// Verify that the vote is properly signed
-    fn verify_vote_signer(vote: &PbftSignedVote) -> Result<(), PbftError> {
-        let header: ConsensusPeerMessageHeader =
-            protobuf::parse_from_bytes(&vote.get_header_bytes())
-                .map_err(PbftError::SerializationError)?;
-
-        let key = Secp256k1PublicKey::from_hex(&hex::encode(&header.signer_id)).unwrap();
+    /// Handle a `BlockNew` update from the Validator
+    ///
+    /// The validator has received a new block; verify the block's consensus seal and add the
+    /// BlockNew to the message log. If this is the block we are waiting for: set it as the working
+    /// block, update the idle & commit timers, and broadcast a PrePrepare if this node is the
+    /// primary. If this is the block after the one this node is working on, use it to catch up.
+    pub fn on_block_new(&mut self, block: Block, state: &mut PbftState) -> Result<(), PbftError> {
+        info!(
+            ""{}: Got BlockNew: {} / {}"",
+            state,
+            block.block_num,
+            hex::encode(&block.block_id[..3]),
+        );
 
-        let context = create_context(""secp256k1"")
-            .map_err(|err| PbftError::InternalError(format!(""Couldn't create context: {}"", err)))?;
+        if block.block_num < state.seq_num {
+            info!(
+                ""Ignoring block ({}) that's older than current sequence number ({})."",
+                block.block_num, state.seq_num
+            );
+            return Ok(());
+        }
 
-        match context.verify(
-            &hex::encode(vote.get_header_signature()),
-            vote.get_header_bytes(),
-            &key,
-        ) {
-            Ok(true) => {}
-            Ok(false) => {
-                return Err(PbftError::InternalError(
-                    ""Header failed verification!"".into(),
-                ))
-            }
+        match self.verify_consensus_seal(&block, state) {
+            Ok(_) => {}
             Err(err) => {
-                return Err(PbftError::InternalError(format!(
-                    ""Error while verifying header: {:?}"",
+                warn!(
+                    ""Failing block due to failed consensus seal verification and \
+                     proposing view change! Error was {}"",
                     err
-                )))
+                );
+                self.service.fail_block(block.block_id).map_err(|err| {
+                    PbftError::InternalError(format!(""Couldn't fail block: {}"", err))
+                })?;
+                self.propose_view_change(state, state.view + 1)?;
+                return Err(err);
             }
         }
 
-        verify_sha512(vote.get_message_bytes(), header.get_content_sha512())?;
+        // Create PBFT message for BlockNew and add it to the log
+        let mut msg = PbftMessage::new();
+        msg.set_info(handlers::make_msg_info(
+            &PbftMessageType::BlockNew,
+            state.view,
+            block.block_num,
+            state.id.clone(),
+        ));
 
-        Ok(())
-    }
+        let pbft_block = pbft_block_from_block(block.clone());
+        msg.set_block(pbft_block.clone());
 
-    /// Verify an individual view change vote
-    ///
-    /// Return the signer ID of the wrapped PbftMessage for use in further verification
-    fn verify_view_change_vote(vote: &PbftSignedVote, view: u64) -> Result<PeerId, PbftError> {
-        let message: PbftMessage = protobuf::parse_from_bytes(&vote.get_message_bytes())
-            .map_err(PbftError::SerializationError)?;
+        self.msg_log
+            .add_message(ParsedMessage::from_pbft_message(msg.clone()), state)?;
 
-        if PbftMessageType::from(message.get_info().get_msg_type()) != PbftMessageType::ViewChange {
-            return Err(PbftError::InternalError(format!(
-                ""Received view change vote that is not a ViewChange: {:?}"",
-                message
-            )));
-        }
+        // We can use this block's seal to commit the next block (i.e. catch-up) if it's the block
+        // after the one we're waiting for and we haven't already told the validator to commit the
+        // block we're waiting for
+        if block.block_num == state.seq_num + 1 && state.phase != PbftPhase::Finished {
+            self.catchup(state, &block)?;
+        } else if block.block_num == state.seq_num {
+            // This is the block we're waiting for, so we update state
+            state.working_block = Some(msg.get_block().clone());
 
-        if message.get_info().get_view() != view {
-            return Err(PbftError::InternalError(format!(
-                ""ViewChange's view ({:?}) does not match NewView's view ({:?})"",
-                message.get_info().get_view(),
-                view,
-            )));
+            // Send PrePrepare messages if we're the primary
+            if state.is_primary() {
+                let s = state.seq_num;
+                self._broadcast_pbft_message(s, &PbftMessageType::PrePrepare, pbft_block, state)?;
+            }
         }
 
-        Self::verify_vote_signer(vote)?;
-
-        Ok(PeerId::from(message.get_info().get_signer_id()))
+        Ok(())
     }
 
-    /// Verifies that the NewView messsage is valid
-    fn verify_new_view(
-        &mut self,
-        new_view: &PbftNewView,
-        state: &mut PbftState,
-    ) -> Result<(), PbftError> {
-        // Make sure this is from the new primary
-        if PeerId::from(new_view.get_info().get_signer_id())
-            != state.get_primary_id_at_view(new_view.get_info().get_view())
-        {
-            error!(
-                ""Got NewView message ({:?}) from node that is not primary for new view"",
-                new_view,
-            );
-            return Err(PbftError::NotFromPrimary);
-        }
-
-        // Verify each individual vote, and extract the signer ID from each ViewChange that
-        // it contains so we can verify the IDs themselves
-        let voter_ids =
-            new_view
-                .get_view_changes()
-                .iter()
-                .try_fold(HashSet::new(), |mut ids, v| {
-                    Self::verify_view_change_vote(v, new_view.get_info().get_view())
-                        .and_then(|vid| Ok(ids.insert(vid)))?;
-                    Ok(ids)
-                })?;
-
-        // All of the votes must come from known peers, and the new primary can't
-        // explicitly vote itself, since broacasting the NewView is an implicit vote. Check
-        // that the votes we've received are a subset of ""peers - primary"".
-        let peer_ids: HashSet<_> = state
-            .peer_ids
-            .iter()
-            .cloned()
-            .filter(|pid| pid != &PeerId::from(new_view.get_info().get_signer_id()))
-            .collect();
+    /// Use the given block's consensus seal to verify and commit the block this node is working on
+    fn catchup(&mut self, state: &mut PbftState, block: &Block) -> Result<(), PbftError> {
+        info!(
+            ""{}: Trying catchup to #{} from BlockNew message #{}"",
+            state, state.seq_num, block.block_num,
+        );
 
-        if !voter_ids.is_subset(&peer_ids) {
-            return Err(PbftError::InternalError(format!(
-                ""Got unexpected vote IDs when verifying NewView: {:?}"",
-                voter_ids.difference(&peer_ids).collect::<Vec<_>>()
-            )));
-        }
+        match state.working_block {
+            Some(ref working_block) => {
+                let block_num_matches = block.block_num == working_block.get_block_num() + 1;
+                let block_id_matches = block.previous_id == working_block.get_block_id();
 
-        // Check that we've received 2f votes, since the primary vote is implicit
-        if voter_ids.len() < 2 * state.f as usize {
-            return Err(PbftError::InternalError(format!(
-                ""Need {} votes, only found {}!"",
-                2 * state.f,
-                voter_ids.len()
-            )));
+                if !block_num_matches || !block_id_matches {
+                    error!(
+                        ""Block didn't match for catchup: {:?} {:?}"",
+                        block, working_block
+                    );
+                    return Err(PbftError::MismatchedBlocks(vec![
+                        pbft_block_from_block(block.clone()),
+                        working_block.clone(),
+                    ]));
+                }
+            }
+            None => {
+                error!(
+                    ""Trying to catch up, but node does not have block #{} yet"",
+                    state.seq_num
+                );
+                return Err(PbftError::NoWorkingBlock);
+            }
         }
 
-        Ok(())
-    }
+        // Parse messages from the seal
+        let seal: PbftSeal =
+            protobuf::parse_from_bytes(&block.payload).map_err(PbftError::SerializationError)?;
 
-    /// Verifies an individual consensus vote
-    ///
-    /// Returns the signer ID of the wrapped PbftMessage, for use in further verification
-    fn verify_consensus_vote(vote: &PbftSignedVote, seal: &PbftSeal) -> Result<Vec<u8>, PbftError> {
-        let message: PbftMessage = protobuf::parse_from_bytes(&vote.get_message_bytes())
-            .map_err(PbftError::SerializationError)?;
+        let messages =
+            seal.get_previous_commit_votes()
+                .iter()
+                .try_fold(Vec::new(), |mut msgs, v| {
+                    msgs.push(ParsedMessage::from_pbft_message(
+                        protobuf::parse_from_bytes(&v.get_message_bytes())
+                            .map_err(PbftError::SerializationError)?,
+                    ));
+                    Ok(msgs)
+                })?;
 
-        if PbftMessageType::from(message.get_info().get_msg_type()) != PbftMessageType::Commit {
-            return Err(PbftError::InternalError(format!(
-                ""Received consensus vote that is not a Commit: {:?}"",
-                message
-            )));
+        // Update our view if necessary
+        let view = messages[0].info().get_view();
+        if view > state.view {
+            info!(""Updating view from {} to {}."", state.view, view);
+            state.view = view;
         }
 
-        if message.get_block().block_id != seal.previous_id {
-            return Err(PbftError::InternalError(format!(
-                ""PbftMessage block ID ({:?}) doesn't match seal's previous id ({:?})!"",
-                message.get_block().get_block_id(),
-                seal.previous_id
-            )));
+        // Add messages to the log
+        for message in &messages {
+            self.msg_log.add_message(message.clone(), state)?;
         }
 
-        Self::verify_vote_signer(vote)?;
+        // Commit the new block using one of the parsed messages and skip straight to Finished
+        self.service
+            .commit_block(messages[0].get_block().block_id.clone())
+            .map_err(|e| PbftError::InternalError(format!(""Failed to commit block: {:?}"", e)))?;
+        state.phase = PbftPhase::Finished;
 
-        Ok(message.get_info().get_signer_id().to_vec())
+        // Call on_block_commit right away so we're ready to catch up again if necessary
+        self.on_block_commit(BlockId::from(messages[0].get_block().get_block_id()), state);
+
+        Ok(())
     }
 
-    /// Verifies the consensus seal from the current block, for the previous block
-    fn verify_consensus_seal(
+    /// Handle a `BlockValid` update from the Validator
+    ///
+    /// This message arrives after `check_blocks` is called, signifying that the validator has
+    /// successfully checked a block with this `BlockId`. Once a `BlockValid` is received for the
+    /// working block, transition to the Preparing phase.
+    #[allow(clippy::ptr_arg)]
+    pub fn on_block_valid(
         &mut self,
-        block: &Block,
+        block_id: &BlockId,
         state: &mut PbftState,
     ) -> Result<(), PbftError> {
-        // We don't publish a consensus seal until block 1, so we don't verify it
-        // until block 2
-        if block.block_num < 2 {
-            return Ok(());
-        }
+        debug!(""{}: <<<<<< BlockValid: {:?}"", state, block_id);
+        let block = match state.working_block {
+            Some(ref block) => {
+                if &BlockId::from(block.get_block_id()) == block_id {
+                    Ok(block.clone())
+                } else {
+                    warn!(""Got BlockValid that doesn't match the working block"");
+                    Err(PbftError::NotReadyForMessage)
+                }
+            }
+            None => {
+                warn!(""Got BlockValid with no working block"");",912,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/247594779,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r247594779,vaporos
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,Couldn't we just pass in a slice here?,eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-14 18:00:42,247595363,"@@ -411,520 +412,549 @@ impl PbftNode {
         Ok(())
     }
 
-    /// Verify that the vote is properly signed
-    fn verify_vote_signer(vote: &PbftSignedVote) -> Result<(), PbftError> {
-        let header: ConsensusPeerMessageHeader =
-            protobuf::parse_from_bytes(&vote.get_header_bytes())
-                .map_err(PbftError::SerializationError)?;
-
-        let key = Secp256k1PublicKey::from_hex(&hex::encode(&header.signer_id)).unwrap();
+    /// Handle a `BlockNew` update from the Validator
+    ///
+    /// The validator has received a new block; verify the block's consensus seal and add the
+    /// BlockNew to the message log. If this is the block we are waiting for: set it as the working
+    /// block, update the idle & commit timers, and broadcast a PrePrepare if this node is the
+    /// primary. If this is the block after the one this node is working on, use it to catch up.
+    pub fn on_block_new(&mut self, block: Block, state: &mut PbftState) -> Result<(), PbftError> {
+        info!(
+            ""{}: Got BlockNew: {} / {}"",
+            state,
+            block.block_num,
+            hex::encode(&block.block_id[..3]),
+        );
 
-        let context = create_context(""secp256k1"")
-            .map_err(|err| PbftError::InternalError(format!(""Couldn't create context: {}"", err)))?;
+        if block.block_num < state.seq_num {
+            info!(
+                ""Ignoring block ({}) that's older than current sequence number ({})."",
+                block.block_num, state.seq_num
+            );
+            return Ok(());
+        }
 
-        match context.verify(
-            &hex::encode(vote.get_header_signature()),
-            vote.get_header_bytes(),
-            &key,
-        ) {
-            Ok(true) => {}
-            Ok(false) => {
-                return Err(PbftError::InternalError(
-                    ""Header failed verification!"".into(),
-                ))
-            }
+        match self.verify_consensus_seal(&block, state) {
+            Ok(_) => {}
             Err(err) => {
-                return Err(PbftError::InternalError(format!(
-                    ""Error while verifying header: {:?}"",
+                warn!(
+                    ""Failing block due to failed consensus seal verification and \
+                     proposing view change! Error was {}"",
                     err
-                )))
+                );
+                self.service.fail_block(block.block_id).map_err(|err| {
+                    PbftError::InternalError(format!(""Couldn't fail block: {}"", err))
+                })?;
+                self.propose_view_change(state, state.view + 1)?;
+                return Err(err);
             }
         }
 
-        verify_sha512(vote.get_message_bytes(), header.get_content_sha512())?;
+        // Create PBFT message for BlockNew and add it to the log
+        let mut msg = PbftMessage::new();
+        msg.set_info(handlers::make_msg_info(
+            &PbftMessageType::BlockNew,
+            state.view,
+            block.block_num,
+            state.id.clone(),
+        ));
 
-        Ok(())
-    }
+        let pbft_block = pbft_block_from_block(block.clone());
+        msg.set_block(pbft_block.clone());
 
-    /// Verify an individual view change vote
-    ///
-    /// Return the signer ID of the wrapped PbftMessage for use in further verification
-    fn verify_view_change_vote(vote: &PbftSignedVote, view: u64) -> Result<PeerId, PbftError> {
-        let message: PbftMessage = protobuf::parse_from_bytes(&vote.get_message_bytes())
-            .map_err(PbftError::SerializationError)?;
+        self.msg_log
+            .add_message(ParsedMessage::from_pbft_message(msg.clone()), state)?;
 
-        if PbftMessageType::from(message.get_info().get_msg_type()) != PbftMessageType::ViewChange {
-            return Err(PbftError::InternalError(format!(
-                ""Received view change vote that is not a ViewChange: {:?}"",
-                message
-            )));
-        }
+        // We can use this block's seal to commit the next block (i.e. catch-up) if it's the block
+        // after the one we're waiting for and we haven't already told the validator to commit the
+        // block we're waiting for
+        if block.block_num == state.seq_num + 1 && state.phase != PbftPhase::Finished {
+            self.catchup(state, &block)?;
+        } else if block.block_num == state.seq_num {
+            // This is the block we're waiting for, so we update state
+            state.working_block = Some(msg.get_block().clone());
 
-        if message.get_info().get_view() != view {
-            return Err(PbftError::InternalError(format!(
-                ""ViewChange's view ({:?}) does not match NewView's view ({:?})"",
-                message.get_info().get_view(),
-                view,
-            )));
+            // Send PrePrepare messages if we're the primary
+            if state.is_primary() {
+                let s = state.seq_num;
+                self._broadcast_pbft_message(s, &PbftMessageType::PrePrepare, pbft_block, state)?;
+            }
         }
 
-        Self::verify_vote_signer(vote)?;
-
-        Ok(PeerId::from(message.get_info().get_signer_id()))
+        Ok(())
     }
 
-    /// Verifies that the NewView messsage is valid
-    fn verify_new_view(
-        &mut self,
-        new_view: &PbftNewView,
-        state: &mut PbftState,
-    ) -> Result<(), PbftError> {
-        // Make sure this is from the new primary
-        if PeerId::from(new_view.get_info().get_signer_id())
-            != state.get_primary_id_at_view(new_view.get_info().get_view())
-        {
-            error!(
-                ""Got NewView message ({:?}) from node that is not primary for new view"",
-                new_view,
-            );
-            return Err(PbftError::NotFromPrimary);
-        }
-
-        // Verify each individual vote, and extract the signer ID from each ViewChange that
-        // it contains so we can verify the IDs themselves
-        let voter_ids =
-            new_view
-                .get_view_changes()
-                .iter()
-                .try_fold(HashSet::new(), |mut ids, v| {
-                    Self::verify_view_change_vote(v, new_view.get_info().get_view())
-                        .and_then(|vid| Ok(ids.insert(vid)))?;
-                    Ok(ids)
-                })?;
-
-        // All of the votes must come from known peers, and the new primary can't
-        // explicitly vote itself, since broacasting the NewView is an implicit vote. Check
-        // that the votes we've received are a subset of ""peers - primary"".
-        let peer_ids: HashSet<_> = state
-            .peer_ids
-            .iter()
-            .cloned()
-            .filter(|pid| pid != &PeerId::from(new_view.get_info().get_signer_id()))
-            .collect();
+    /// Use the given block's consensus seal to verify and commit the block this node is working on
+    fn catchup(&mut self, state: &mut PbftState, block: &Block) -> Result<(), PbftError> {
+        info!(
+            ""{}: Trying catchup to #{} from BlockNew message #{}"",
+            state, state.seq_num, block.block_num,
+        );
 
-        if !voter_ids.is_subset(&peer_ids) {
-            return Err(PbftError::InternalError(format!(
-                ""Got unexpected vote IDs when verifying NewView: {:?}"",
-                voter_ids.difference(&peer_ids).collect::<Vec<_>>()
-            )));
-        }
+        match state.working_block {
+            Some(ref working_block) => {
+                let block_num_matches = block.block_num == working_block.get_block_num() + 1;
+                let block_id_matches = block.previous_id == working_block.get_block_id();
 
-        // Check that we've received 2f votes, since the primary vote is implicit
-        if voter_ids.len() < 2 * state.f as usize {
-            return Err(PbftError::InternalError(format!(
-                ""Need {} votes, only found {}!"",
-                2 * state.f,
-                voter_ids.len()
-            )));
+                if !block_num_matches || !block_id_matches {
+                    error!(
+                        ""Block didn't match for catchup: {:?} {:?}"",
+                        block, working_block
+                    );
+                    return Err(PbftError::MismatchedBlocks(vec![
+                        pbft_block_from_block(block.clone()),
+                        working_block.clone(),
+                    ]));
+                }
+            }
+            None => {
+                error!(
+                    ""Trying to catch up, but node does not have block #{} yet"",
+                    state.seq_num
+                );
+                return Err(PbftError::NoWorkingBlock);
+            }
         }
 
-        Ok(())
-    }
+        // Parse messages from the seal
+        let seal: PbftSeal =
+            protobuf::parse_from_bytes(&block.payload).map_err(PbftError::SerializationError)?;
 
-    /// Verifies an individual consensus vote
-    ///
-    /// Returns the signer ID of the wrapped PbftMessage, for use in further verification
-    fn verify_consensus_vote(vote: &PbftSignedVote, seal: &PbftSeal) -> Result<Vec<u8>, PbftError> {
-        let message: PbftMessage = protobuf::parse_from_bytes(&vote.get_message_bytes())
-            .map_err(PbftError::SerializationError)?;
+        let messages =
+            seal.get_previous_commit_votes()
+                .iter()
+                .try_fold(Vec::new(), |mut msgs, v| {
+                    msgs.push(ParsedMessage::from_pbft_message(
+                        protobuf::parse_from_bytes(&v.get_message_bytes())
+                            .map_err(PbftError::SerializationError)?,
+                    ));
+                    Ok(msgs)
+                })?;
 
-        if PbftMessageType::from(message.get_info().get_msg_type()) != PbftMessageType::Commit {
-            return Err(PbftError::InternalError(format!(
-                ""Received consensus vote that is not a Commit: {:?}"",
-                message
-            )));
+        // Update our view if necessary
+        let view = messages[0].info().get_view();
+        if view > state.view {
+            info!(""Updating view from {} to {}."", state.view, view);
+            state.view = view;
         }
 
-        if message.get_block().block_id != seal.previous_id {
-            return Err(PbftError::InternalError(format!(
-                ""PbftMessage block ID ({:?}) doesn't match seal's previous id ({:?})!"",
-                message.get_block().get_block_id(),
-                seal.previous_id
-            )));
+        // Add messages to the log
+        for message in &messages {
+            self.msg_log.add_message(message.clone(), state)?;
         }
 
-        Self::verify_vote_signer(vote)?;
+        // Commit the new block using one of the parsed messages and skip straight to Finished
+        self.service
+            .commit_block(messages[0].get_block().block_id.clone())
+            .map_err(|e| PbftError::InternalError(format!(""Failed to commit block: {:?}"", e)))?;
+        state.phase = PbftPhase::Finished;
 
-        Ok(message.get_info().get_signer_id().to_vec())
+        // Call on_block_commit right away so we're ready to catch up again if necessary
+        self.on_block_commit(BlockId::from(messages[0].get_block().get_block_id()), state);
+
+        Ok(())
     }
 
-    /// Verifies the consensus seal from the current block, for the previous block
-    fn verify_consensus_seal(
+    /// Handle a `BlockValid` update from the Validator
+    ///
+    /// This message arrives after `check_blocks` is called, signifying that the validator has
+    /// successfully checked a block with this `BlockId`. Once a `BlockValid` is received for the
+    /// working block, transition to the Preparing phase.
+    #[allow(clippy::ptr_arg)]
+    pub fn on_block_valid(
         &mut self,
-        block: &Block,
+        block_id: &BlockId,
         state: &mut PbftState,
     ) -> Result<(), PbftError> {
-        // We don't publish a consensus seal until block 1, so we don't verify it
-        // until block 2
-        if block.block_num < 2 {
-            return Ok(());
-        }
+        debug!(""{}: <<<<<< BlockValid: {:?}"", state, block_id);
+        let block = match state.working_block {
+            Some(ref block) => {
+                if &BlockId::from(block.get_block_id()) == block_id {
+                    Ok(block.clone())
+                } else {
+                    warn!(""Got BlockValid that doesn't match the working block"");
+                    Err(PbftError::NotReadyForMessage)
+                }
+            }
+            None => {
+                warn!(""Got BlockValid with no working block"");
+                Err(PbftError::NoWorkingBlock)
+            }
+        }?;
 
-        if block.payload.is_empty() {
-            return Err(PbftError::InternalError(
-                ""Got empty payload for non-genesis block!"".into(),
-            ));
-        }
+        state.switch_phase(PbftPhase::Preparing);
+        self._broadcast_pbft_message(
+            state.seq_num,
+            &PbftMessageType::Prepare,
+            block.clone(),
+            state,
+        )?;
+        Ok(())
+    }
 
-        let seal: PbftSeal =
-            protobuf::parse_from_bytes(&block.payload).map_err(PbftError::SerializationError)?;
+    /// Handle a `BlockCommit` update from the Validator
+    ///
+    /// A block was sucessfully committed; update state to be ready for the next block, make any
+    /// necessary view and membership changes, garbage collect the logs, update the commit & idle
+    /// timers, and start a new block if this node is the primary.
+    #[allow(clippy::needless_pass_by_value)]
+    pub fn on_block_commit(&mut self, block_id: BlockId, state: &mut PbftState) {
+        debug!(""{}: <<<<<< BlockCommit: {:?}"", state, block_id);
 
-        if seal.previous_id != &block.previous_id[..] {
-            return Err(PbftError::InternalError(format!(
-                ""Consensus seal failed verification. Seal's previous ID `{}` doesn't match block's previous ID `{}`"",
-                hex::encode(&seal.previous_id[..3]), hex::encode(&block.previous_id[..3])
-            )));
+        let is_working_block = match state.working_block {
+            Some(ref block) => BlockId::from(block.get_block_id()) == block_id,
+            None => false,
+        };
+
+        if state.phase != PbftPhase::Finished || !is_working_block {
+            info!(
+                ""{}: Got BlockCommit for a block that isn't the working block"",
+                state
+            );
+            return;
         }
 
-        if seal.summary != &block.summary[..] {
-            return Err(PbftError::InternalError(format!(
-                ""Consensus seal failed verification. Seal's summary {:?} doesn't match block's summary {:?}"",
-                seal.summary, block.summary
-            )));
+        // Update state to be ready for next block
+        state.switch_phase(PbftPhase::PrePreparing);
+        state.seq_num += 1;
+
+        // If we already have a BlockNew for the next block, we can make it the working block;
+        // otherwise just set the working block to None
+        state.working_block = self
+            .msg_log
+            .get_messages_of_type_seq(&PbftMessageType::BlockNew, state.seq_num)
+            .first()
+            .map(|msg| msg.get_block().clone());
+
+        // Increment the view if we need to force a view change for fairness or if membership
+        // has changed
+        if state.at_forced_view_change() || self.update_membership(block_id.clone(), state) {
+            state.view += 1;
         }
 
-        // Verify each individual vote, and extract the signer ID from each PbftMessage that
-        // it contains, so that we can do some sanity checks on those IDs.
-        let voter_ids =
-            seal.get_previous_commit_votes()
-                .iter()
-                .try_fold(HashSet::new(), |mut ids, v| {
-                    Self::verify_consensus_vote(v, &seal).and_then(|vid| Ok(ids.insert(vid)))?;
-                    Ok(ids)
-                })?;
+        // Tell the log to garbage collect if it needs to
+        self.msg_log.garbage_collect(state.seq_num);
 
-        // All of the votes must come from known peers, and the primary can't explicitly
-        // vote itself, since publishing a block is an implicit vote. Check that the votes
-        // we've received are a subset of ""peers - primary"". We need to use the list of
-        // peers from the block we're verifying the seal for, since it may have changed.
+        // Restart the faulty primary timeout for the next block
+        state.faulty_primary_timeout.start();
+
+        if state.is_primary() && state.working_block.is_none() {
+            info!(
+                ""{}: Initializing block with previous ID {:?}"",
+                state, block_id
+            );
+            self.service
+                .initialize_block(Some(block_id.clone()))
+                .unwrap_or_else(|err| error!(""Couldn't initialize block: {}"", err));
+        }
+    }
+
+    /// Check the on-chain list of peers; if it has changed, update peers list and return true.
+    fn update_membership(&mut self, block_id: BlockId, state: &mut PbftState) -> bool {
+        // Get list of peers from settings
         let settings = self
             .service
             .get_settings(
-                block.previous_id.clone(),
+                block_id,
                 vec![String::from(""sawtooth.consensus.pbft.peers"")],
             )
             .expect(""Failed to get settings"");
         let peers = get_peers_from_settings(&settings);
+        let new_peers_set: HashSet<PeerId> = peers.iter().cloned().collect();
 
-        let peer_ids: HashSet<_> = peers
-            .iter()
-            .cloned()
-            .filter(|pid| pid != &block.signer_id)
-            .collect();
-
-        if !voter_ids.is_subset(&peer_ids) {
-            return Err(PbftError::InternalError(format!(
-                ""Got unexpected vote IDs: {:?}"",
-                voter_ids.difference(&peer_ids).collect::<Vec<_>>()
-            )));
-        }
+        // Check if membership has changed
+        let old_peers_set: HashSet<PeerId> = state.peer_ids.iter().cloned().collect();
 
-        // Check that we've received 2f votes, since the primary vote is implicit
-        if voter_ids.len() < 2 * state.f as usize {
-            return Err(PbftError::InternalError(format!(
-                ""Need {} votes, only found {}!"",
-                2 * state.f,
-                voter_ids.len()
-            )));
+        if new_peers_set != old_peers_set {
+            state.peer_ids = peers;
+            let f = ((state.peer_ids.len() - 1) / 3) as u64;
+            if f == 0 {
+                panic!(""This network no longer contains enough nodes to be fault tolerant"");
+            }
+            state.f = f;
+            return true;
         }
 
-        Ok(())
+        false
     }
 
-    /// Use the given block's consensus seal to verify and commit the block this node is working on
-    fn catchup(&mut self, state: &mut PbftState, block: &Block) -> Result<(), PbftError> {
-        info!(
-            ""{}: Trying catchup to #{} from BlockNew message #{}"",
-            state, state.seq_num, block.block_num,
-        );
+    // ---------- Methods for building & verifying proofs and signed messages from other nodes ----------
 
-        match state.working_block {
-            Some(ref working_block) => {
-                let block_num_matches = block.block_num == working_block.get_block_num() + 1;
-                let block_id_matches = block.previous_id == working_block.get_block_id();
-
-                if !block_num_matches || !block_id_matches {
-                    error!(
-                        ""Block didn't match for catchup: {:?} {:?}"",
-                        block, working_block
-                    );
-                    return Err(PbftError::MismatchedBlocks(vec![
-                        pbft_block_from_block(block.clone()),
-                        working_block.clone(),
-                    ]));
-                }
-            }
-            None => {
-                error!(
-                    ""Trying to catch up, but node does not have block #{} yet"",
-                    state.seq_num
-                );
-                return Err(PbftError::NoWorkingBlock);
-            }
-        }
+    /// Generate a `protobuf::RepeatedField` of signed votes from a list of parsed messages
+    #[allow(clippy::needless_pass_by_value)]",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/247595363,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r247595363,vaporos
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,Can't we just pass in the reference?,eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-14 18:01:25,247595599,"@@ -411,520 +412,549 @@ impl PbftNode {
         Ok(())
     }
 
-    /// Verify that the vote is properly signed
-    fn verify_vote_signer(vote: &PbftSignedVote) -> Result<(), PbftError> {
-        let header: ConsensusPeerMessageHeader =
-            protobuf::parse_from_bytes(&vote.get_header_bytes())
-                .map_err(PbftError::SerializationError)?;
-
-        let key = Secp256k1PublicKey::from_hex(&hex::encode(&header.signer_id)).unwrap();
+    /// Handle a `BlockNew` update from the Validator
+    ///
+    /// The validator has received a new block; verify the block's consensus seal and add the
+    /// BlockNew to the message log. If this is the block we are waiting for: set it as the working
+    /// block, update the idle & commit timers, and broadcast a PrePrepare if this node is the
+    /// primary. If this is the block after the one this node is working on, use it to catch up.
+    pub fn on_block_new(&mut self, block: Block, state: &mut PbftState) -> Result<(), PbftError> {
+        info!(
+            ""{}: Got BlockNew: {} / {}"",
+            state,
+            block.block_num,
+            hex::encode(&block.block_id[..3]),
+        );
 
-        let context = create_context(""secp256k1"")
-            .map_err(|err| PbftError::InternalError(format!(""Couldn't create context: {}"", err)))?;
+        if block.block_num < state.seq_num {
+            info!(
+                ""Ignoring block ({}) that's older than current sequence number ({})."",
+                block.block_num, state.seq_num
+            );
+            return Ok(());
+        }
 
-        match context.verify(
-            &hex::encode(vote.get_header_signature()),
-            vote.get_header_bytes(),
-            &key,
-        ) {
-            Ok(true) => {}
-            Ok(false) => {
-                return Err(PbftError::InternalError(
-                    ""Header failed verification!"".into(),
-                ))
-            }
+        match self.verify_consensus_seal(&block, state) {
+            Ok(_) => {}
             Err(err) => {
-                return Err(PbftError::InternalError(format!(
-                    ""Error while verifying header: {:?}"",
+                warn!(
+                    ""Failing block due to failed consensus seal verification and \
+                     proposing view change! Error was {}"",
                     err
-                )))
+                );
+                self.service.fail_block(block.block_id).map_err(|err| {
+                    PbftError::InternalError(format!(""Couldn't fail block: {}"", err))
+                })?;
+                self.propose_view_change(state, state.view + 1)?;
+                return Err(err);
             }
         }
 
-        verify_sha512(vote.get_message_bytes(), header.get_content_sha512())?;
+        // Create PBFT message for BlockNew and add it to the log
+        let mut msg = PbftMessage::new();
+        msg.set_info(handlers::make_msg_info(
+            &PbftMessageType::BlockNew,
+            state.view,
+            block.block_num,
+            state.id.clone(),
+        ));
 
-        Ok(())
-    }
+        let pbft_block = pbft_block_from_block(block.clone());
+        msg.set_block(pbft_block.clone());
 
-    /// Verify an individual view change vote
-    ///
-    /// Return the signer ID of the wrapped PbftMessage for use in further verification
-    fn verify_view_change_vote(vote: &PbftSignedVote, view: u64) -> Result<PeerId, PbftError> {
-        let message: PbftMessage = protobuf::parse_from_bytes(&vote.get_message_bytes())
-            .map_err(PbftError::SerializationError)?;
+        self.msg_log
+            .add_message(ParsedMessage::from_pbft_message(msg.clone()), state)?;
 
-        if PbftMessageType::from(message.get_info().get_msg_type()) != PbftMessageType::ViewChange {
-            return Err(PbftError::InternalError(format!(
-                ""Received view change vote that is not a ViewChange: {:?}"",
-                message
-            )));
-        }
+        // We can use this block's seal to commit the next block (i.e. catch-up) if it's the block
+        // after the one we're waiting for and we haven't already told the validator to commit the
+        // block we're waiting for
+        if block.block_num == state.seq_num + 1 && state.phase != PbftPhase::Finished {
+            self.catchup(state, &block)?;
+        } else if block.block_num == state.seq_num {
+            // This is the block we're waiting for, so we update state
+            state.working_block = Some(msg.get_block().clone());
 
-        if message.get_info().get_view() != view {
-            return Err(PbftError::InternalError(format!(
-                ""ViewChange's view ({:?}) does not match NewView's view ({:?})"",
-                message.get_info().get_view(),
-                view,
-            )));
+            // Send PrePrepare messages if we're the primary
+            if state.is_primary() {
+                let s = state.seq_num;
+                self._broadcast_pbft_message(s, &PbftMessageType::PrePrepare, pbft_block, state)?;
+            }
         }
 
-        Self::verify_vote_signer(vote)?;
-
-        Ok(PeerId::from(message.get_info().get_signer_id()))
+        Ok(())
     }
 
-    /// Verifies that the NewView messsage is valid
-    fn verify_new_view(
-        &mut self,
-        new_view: &PbftNewView,
-        state: &mut PbftState,
-    ) -> Result<(), PbftError> {
-        // Make sure this is from the new primary
-        if PeerId::from(new_view.get_info().get_signer_id())
-            != state.get_primary_id_at_view(new_view.get_info().get_view())
-        {
-            error!(
-                ""Got NewView message ({:?}) from node that is not primary for new view"",
-                new_view,
-            );
-            return Err(PbftError::NotFromPrimary);
-        }
-
-        // Verify each individual vote, and extract the signer ID from each ViewChange that
-        // it contains so we can verify the IDs themselves
-        let voter_ids =
-            new_view
-                .get_view_changes()
-                .iter()
-                .try_fold(HashSet::new(), |mut ids, v| {
-                    Self::verify_view_change_vote(v, new_view.get_info().get_view())
-                        .and_then(|vid| Ok(ids.insert(vid)))?;
-                    Ok(ids)
-                })?;
-
-        // All of the votes must come from known peers, and the new primary can't
-        // explicitly vote itself, since broacasting the NewView is an implicit vote. Check
-        // that the votes we've received are a subset of ""peers - primary"".
-        let peer_ids: HashSet<_> = state
-            .peer_ids
-            .iter()
-            .cloned()
-            .filter(|pid| pid != &PeerId::from(new_view.get_info().get_signer_id()))
-            .collect();
+    /// Use the given block's consensus seal to verify and commit the block this node is working on
+    fn catchup(&mut self, state: &mut PbftState, block: &Block) -> Result<(), PbftError> {
+        info!(
+            ""{}: Trying catchup to #{} from BlockNew message #{}"",
+            state, state.seq_num, block.block_num,
+        );
 
-        if !voter_ids.is_subset(&peer_ids) {
-            return Err(PbftError::InternalError(format!(
-                ""Got unexpected vote IDs when verifying NewView: {:?}"",
-                voter_ids.difference(&peer_ids).collect::<Vec<_>>()
-            )));
-        }
+        match state.working_block {
+            Some(ref working_block) => {
+                let block_num_matches = block.block_num == working_block.get_block_num() + 1;
+                let block_id_matches = block.previous_id == working_block.get_block_id();
 
-        // Check that we've received 2f votes, since the primary vote is implicit
-        if voter_ids.len() < 2 * state.f as usize {
-            return Err(PbftError::InternalError(format!(
-                ""Need {} votes, only found {}!"",
-                2 * state.f,
-                voter_ids.len()
-            )));
+                if !block_num_matches || !block_id_matches {
+                    error!(
+                        ""Block didn't match for catchup: {:?} {:?}"",
+                        block, working_block
+                    );
+                    return Err(PbftError::MismatchedBlocks(vec![
+                        pbft_block_from_block(block.clone()),
+                        working_block.clone(),
+                    ]));
+                }
+            }
+            None => {
+                error!(
+                    ""Trying to catch up, but node does not have block #{} yet"",
+                    state.seq_num
+                );
+                return Err(PbftError::NoWorkingBlock);
+            }
         }
 
-        Ok(())
-    }
+        // Parse messages from the seal
+        let seal: PbftSeal =
+            protobuf::parse_from_bytes(&block.payload).map_err(PbftError::SerializationError)?;
 
-    /// Verifies an individual consensus vote
-    ///
-    /// Returns the signer ID of the wrapped PbftMessage, for use in further verification
-    fn verify_consensus_vote(vote: &PbftSignedVote, seal: &PbftSeal) -> Result<Vec<u8>, PbftError> {
-        let message: PbftMessage = protobuf::parse_from_bytes(&vote.get_message_bytes())
-            .map_err(PbftError::SerializationError)?;
+        let messages =
+            seal.get_previous_commit_votes()
+                .iter()
+                .try_fold(Vec::new(), |mut msgs, v| {
+                    msgs.push(ParsedMessage::from_pbft_message(
+                        protobuf::parse_from_bytes(&v.get_message_bytes())
+                            .map_err(PbftError::SerializationError)?,
+                    ));
+                    Ok(msgs)
+                })?;
 
-        if PbftMessageType::from(message.get_info().get_msg_type()) != PbftMessageType::Commit {
-            return Err(PbftError::InternalError(format!(
-                ""Received consensus vote that is not a Commit: {:?}"",
-                message
-            )));
+        // Update our view if necessary
+        let view = messages[0].info().get_view();
+        if view > state.view {
+            info!(""Updating view from {} to {}."", state.view, view);
+            state.view = view;
         }
 
-        if message.get_block().block_id != seal.previous_id {
-            return Err(PbftError::InternalError(format!(
-                ""PbftMessage block ID ({:?}) doesn't match seal's previous id ({:?})!"",
-                message.get_block().get_block_id(),
-                seal.previous_id
-            )));
+        // Add messages to the log
+        for message in &messages {
+            self.msg_log.add_message(message.clone(), state)?;
         }
 
-        Self::verify_vote_signer(vote)?;
+        // Commit the new block using one of the parsed messages and skip straight to Finished
+        self.service
+            .commit_block(messages[0].get_block().block_id.clone())
+            .map_err(|e| PbftError::InternalError(format!(""Failed to commit block: {:?}"", e)))?;
+        state.phase = PbftPhase::Finished;
 
-        Ok(message.get_info().get_signer_id().to_vec())
+        // Call on_block_commit right away so we're ready to catch up again if necessary
+        self.on_block_commit(BlockId::from(messages[0].get_block().get_block_id()), state);
+
+        Ok(())
     }
 
-    /// Verifies the consensus seal from the current block, for the previous block
-    fn verify_consensus_seal(
+    /// Handle a `BlockValid` update from the Validator
+    ///
+    /// This message arrives after `check_blocks` is called, signifying that the validator has
+    /// successfully checked a block with this `BlockId`. Once a `BlockValid` is received for the
+    /// working block, transition to the Preparing phase.
+    #[allow(clippy::ptr_arg)]
+    pub fn on_block_valid(
         &mut self,
-        block: &Block,
+        block_id: &BlockId,
         state: &mut PbftState,
     ) -> Result<(), PbftError> {
-        // We don't publish a consensus seal until block 1, so we don't verify it
-        // until block 2
-        if block.block_num < 2 {
-            return Ok(());
-        }
+        debug!(""{}: <<<<<< BlockValid: {:?}"", state, block_id);
+        let block = match state.working_block {
+            Some(ref block) => {
+                if &BlockId::from(block.get_block_id()) == block_id {
+                    Ok(block.clone())
+                } else {
+                    warn!(""Got BlockValid that doesn't match the working block"");
+                    Err(PbftError::NotReadyForMessage)
+                }
+            }
+            None => {
+                warn!(""Got BlockValid with no working block"");
+                Err(PbftError::NoWorkingBlock)
+            }
+        }?;
 
-        if block.payload.is_empty() {
-            return Err(PbftError::InternalError(
-                ""Got empty payload for non-genesis block!"".into(),
-            ));
-        }
+        state.switch_phase(PbftPhase::Preparing);
+        self._broadcast_pbft_message(
+            state.seq_num,
+            &PbftMessageType::Prepare,
+            block.clone(),
+            state,
+        )?;
+        Ok(())
+    }
 
-        let seal: PbftSeal =
-            protobuf::parse_from_bytes(&block.payload).map_err(PbftError::SerializationError)?;
+    /// Handle a `BlockCommit` update from the Validator
+    ///
+    /// A block was sucessfully committed; update state to be ready for the next block, make any
+    /// necessary view and membership changes, garbage collect the logs, update the commit & idle
+    /// timers, and start a new block if this node is the primary.
+    #[allow(clippy::needless_pass_by_value)]",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/247595599,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r247595599,vaporos
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,"I'm not familiar with the advantages of one or the other; if we use a slice here, the `msg_type` will just have to 
be deref'd. Can you or @peterschwarz explain what the impact would be one way or the other?",eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-14 19:12:32,247620582,"@@ -384,25 +384,22 @@ mod tests {
         log.garbage_collect(5);
 
         for old in 1..3 {
-            for msg_type in &[
+            for msg_type in vec![",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/247620582,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r247620582,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,This was just moved as-is; I've updated this in a future PR that's focused on logging and error handling.,eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-14 19:18:30,247622583,"@@ -411,520 +412,549 @@ impl PbftNode {
         Ok(())
     }
 
-    /// Verify that the vote is properly signed
-    fn verify_vote_signer(vote: &PbftSignedVote) -> Result<(), PbftError> {
-        let header: ConsensusPeerMessageHeader =
-            protobuf::parse_from_bytes(&vote.get_header_bytes())
-                .map_err(PbftError::SerializationError)?;
-
-        let key = Secp256k1PublicKey::from_hex(&hex::encode(&header.signer_id)).unwrap();
+    /// Handle a `BlockNew` update from the Validator
+    ///
+    /// The validator has received a new block; verify the block's consensus seal and add the
+    /// BlockNew to the message log. If this is the block we are waiting for: set it as the working
+    /// block, update the idle & commit timers, and broadcast a PrePrepare if this node is the
+    /// primary. If this is the block after the one this node is working on, use it to catch up.
+    pub fn on_block_new(&mut self, block: Block, state: &mut PbftState) -> Result<(), PbftError> {
+        info!(
+            ""{}: Got BlockNew: {} / {}"",
+            state,
+            block.block_num,
+            hex::encode(&block.block_id[..3]),
+        );
 
-        let context = create_context(""secp256k1"")
-            .map_err(|err| PbftError::InternalError(format!(""Couldn't create context: {}"", err)))?;
+        if block.block_num < state.seq_num {
+            info!(
+                ""Ignoring block ({}) that's older than current sequence number ({})."",
+                block.block_num, state.seq_num
+            );
+            return Ok(());
+        }
 
-        match context.verify(
-            &hex::encode(vote.get_header_signature()),
-            vote.get_header_bytes(),
-            &key,
-        ) {
-            Ok(true) => {}
-            Ok(false) => {
-                return Err(PbftError::InternalError(
-                    ""Header failed verification!"".into(),
-                ))
-            }
+        match self.verify_consensus_seal(&block, state) {
+            Ok(_) => {}
             Err(err) => {
-                return Err(PbftError::InternalError(format!(
-                    ""Error while verifying header: {:?}"",
+                warn!(
+                    ""Failing block due to failed consensus seal verification and \
+                     proposing view change! Error was {}"",
                     err
-                )))
+                );
+                self.service.fail_block(block.block_id).map_err(|err| {
+                    PbftError::InternalError(format!(""Couldn't fail block: {}"", err))
+                })?;
+                self.propose_view_change(state, state.view + 1)?;
+                return Err(err);
             }
         }
 
-        verify_sha512(vote.get_message_bytes(), header.get_content_sha512())?;
+        // Create PBFT message for BlockNew and add it to the log
+        let mut msg = PbftMessage::new();
+        msg.set_info(handlers::make_msg_info(
+            &PbftMessageType::BlockNew,
+            state.view,
+            block.block_num,
+            state.id.clone(),
+        ));
 
-        Ok(())
-    }
+        let pbft_block = pbft_block_from_block(block.clone());
+        msg.set_block(pbft_block.clone());
 
-    /// Verify an individual view change vote
-    ///
-    /// Return the signer ID of the wrapped PbftMessage for use in further verification
-    fn verify_view_change_vote(vote: &PbftSignedVote, view: u64) -> Result<PeerId, PbftError> {
-        let message: PbftMessage = protobuf::parse_from_bytes(&vote.get_message_bytes())
-            .map_err(PbftError::SerializationError)?;
+        self.msg_log
+            .add_message(ParsedMessage::from_pbft_message(msg.clone()), state)?;
 
-        if PbftMessageType::from(message.get_info().get_msg_type()) != PbftMessageType::ViewChange {
-            return Err(PbftError::InternalError(format!(
-                ""Received view change vote that is not a ViewChange: {:?}"",
-                message
-            )));
-        }
+        // We can use this block's seal to commit the next block (i.e. catch-up) if it's the block
+        // after the one we're waiting for and we haven't already told the validator to commit the
+        // block we're waiting for
+        if block.block_num == state.seq_num + 1 && state.phase != PbftPhase::Finished {
+            self.catchup(state, &block)?;
+        } else if block.block_num == state.seq_num {
+            // This is the block we're waiting for, so we update state
+            state.working_block = Some(msg.get_block().clone());
 
-        if message.get_info().get_view() != view {
-            return Err(PbftError::InternalError(format!(
-                ""ViewChange's view ({:?}) does not match NewView's view ({:?})"",
-                message.get_info().get_view(),
-                view,
-            )));
+            // Send PrePrepare messages if we're the primary
+            if state.is_primary() {
+                let s = state.seq_num;
+                self._broadcast_pbft_message(s, &PbftMessageType::PrePrepare, pbft_block, state)?;
+            }
         }
 
-        Self::verify_vote_signer(vote)?;
-
-        Ok(PeerId::from(message.get_info().get_signer_id()))
+        Ok(())
     }
 
-    /// Verifies that the NewView messsage is valid
-    fn verify_new_view(
-        &mut self,
-        new_view: &PbftNewView,
-        state: &mut PbftState,
-    ) -> Result<(), PbftError> {
-        // Make sure this is from the new primary
-        if PeerId::from(new_view.get_info().get_signer_id())
-            != state.get_primary_id_at_view(new_view.get_info().get_view())
-        {
-            error!(
-                ""Got NewView message ({:?}) from node that is not primary for new view"",
-                new_view,
-            );
-            return Err(PbftError::NotFromPrimary);
-        }
-
-        // Verify each individual vote, and extract the signer ID from each ViewChange that
-        // it contains so we can verify the IDs themselves
-        let voter_ids =
-            new_view
-                .get_view_changes()
-                .iter()
-                .try_fold(HashSet::new(), |mut ids, v| {
-                    Self::verify_view_change_vote(v, new_view.get_info().get_view())
-                        .and_then(|vid| Ok(ids.insert(vid)))?;
-                    Ok(ids)
-                })?;
-
-        // All of the votes must come from known peers, and the new primary can't
-        // explicitly vote itself, since broacasting the NewView is an implicit vote. Check
-        // that the votes we've received are a subset of ""peers - primary"".
-        let peer_ids: HashSet<_> = state
-            .peer_ids
-            .iter()
-            .cloned()
-            .filter(|pid| pid != &PeerId::from(new_view.get_info().get_signer_id()))
-            .collect();
+    /// Use the given block's consensus seal to verify and commit the block this node is working on
+    fn catchup(&mut self, state: &mut PbftState, block: &Block) -> Result<(), PbftError> {
+        info!(
+            ""{}: Trying catchup to #{} from BlockNew message #{}"",
+            state, state.seq_num, block.block_num,
+        );
 
-        if !voter_ids.is_subset(&peer_ids) {
-            return Err(PbftError::InternalError(format!(
-                ""Got unexpected vote IDs when verifying NewView: {:?}"",
-                voter_ids.difference(&peer_ids).collect::<Vec<_>>()
-            )));
-        }
+        match state.working_block {
+            Some(ref working_block) => {
+                let block_num_matches = block.block_num == working_block.get_block_num() + 1;
+                let block_id_matches = block.previous_id == working_block.get_block_id();
 
-        // Check that we've received 2f votes, since the primary vote is implicit
-        if voter_ids.len() < 2 * state.f as usize {
-            return Err(PbftError::InternalError(format!(
-                ""Need {} votes, only found {}!"",
-                2 * state.f,
-                voter_ids.len()
-            )));
+                if !block_num_matches || !block_id_matches {
+                    error!(",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/247622583,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r247622583,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,This was moved as-is; it's also removed in PR #71,eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-14 19:19:55,247623137,"@@ -411,520 +412,549 @@ impl PbftNode {
         Ok(())
     }
 
-    /// Verify that the vote is properly signed
-    fn verify_vote_signer(vote: &PbftSignedVote) -> Result<(), PbftError> {
-        let header: ConsensusPeerMessageHeader =
-            protobuf::parse_from_bytes(&vote.get_header_bytes())
-                .map_err(PbftError::SerializationError)?;
-
-        let key = Secp256k1PublicKey::from_hex(&hex::encode(&header.signer_id)).unwrap();
+    /// Handle a `BlockNew` update from the Validator
+    ///
+    /// The validator has received a new block; verify the block's consensus seal and add the
+    /// BlockNew to the message log. If this is the block we are waiting for: set it as the working
+    /// block, update the idle & commit timers, and broadcast a PrePrepare if this node is the
+    /// primary. If this is the block after the one this node is working on, use it to catch up.
+    pub fn on_block_new(&mut self, block: Block, state: &mut PbftState) -> Result<(), PbftError> {
+        info!(
+            ""{}: Got BlockNew: {} / {}"",
+            state,
+            block.block_num,
+            hex::encode(&block.block_id[..3]),
+        );
 
-        let context = create_context(""secp256k1"")
-            .map_err(|err| PbftError::InternalError(format!(""Couldn't create context: {}"", err)))?;
+        if block.block_num < state.seq_num {
+            info!(
+                ""Ignoring block ({}) that's older than current sequence number ({})."",
+                block.block_num, state.seq_num
+            );
+            return Ok(());
+        }
 
-        match context.verify(
-            &hex::encode(vote.get_header_signature()),
-            vote.get_header_bytes(),
-            &key,
-        ) {
-            Ok(true) => {}
-            Ok(false) => {
-                return Err(PbftError::InternalError(
-                    ""Header failed verification!"".into(),
-                ))
-            }
+        match self.verify_consensus_seal(&block, state) {
+            Ok(_) => {}
             Err(err) => {
-                return Err(PbftError::InternalError(format!(
-                    ""Error while verifying header: {:?}"",
+                warn!(
+                    ""Failing block due to failed consensus seal verification and \
+                     proposing view change! Error was {}"",
                     err
-                )))
+                );
+                self.service.fail_block(block.block_id).map_err(|err| {
+                    PbftError::InternalError(format!(""Couldn't fail block: {}"", err))
+                })?;
+                self.propose_view_change(state, state.view + 1)?;
+                return Err(err);
             }
         }
 
-        verify_sha512(vote.get_message_bytes(), header.get_content_sha512())?;
+        // Create PBFT message for BlockNew and add it to the log
+        let mut msg = PbftMessage::new();
+        msg.set_info(handlers::make_msg_info(
+            &PbftMessageType::BlockNew,
+            state.view,
+            block.block_num,
+            state.id.clone(),
+        ));
 
-        Ok(())
-    }
+        let pbft_block = pbft_block_from_block(block.clone());
+        msg.set_block(pbft_block.clone());
 
-    /// Verify an individual view change vote
-    ///
-    /// Return the signer ID of the wrapped PbftMessage for use in further verification
-    fn verify_view_change_vote(vote: &PbftSignedVote, view: u64) -> Result<PeerId, PbftError> {
-        let message: PbftMessage = protobuf::parse_from_bytes(&vote.get_message_bytes())
-            .map_err(PbftError::SerializationError)?;
+        self.msg_log
+            .add_message(ParsedMessage::from_pbft_message(msg.clone()), state)?;
 
-        if PbftMessageType::from(message.get_info().get_msg_type()) != PbftMessageType::ViewChange {
-            return Err(PbftError::InternalError(format!(
-                ""Received view change vote that is not a ViewChange: {:?}"",
-                message
-            )));
-        }
+        // We can use this block's seal to commit the next block (i.e. catch-up) if it's the block
+        // after the one we're waiting for and we haven't already told the validator to commit the
+        // block we're waiting for
+        if block.block_num == state.seq_num + 1 && state.phase != PbftPhase::Finished {
+            self.catchup(state, &block)?;
+        } else if block.block_num == state.seq_num {
+            // This is the block we're waiting for, so we update state
+            state.working_block = Some(msg.get_block().clone());
 
-        if message.get_info().get_view() != view {
-            return Err(PbftError::InternalError(format!(
-                ""ViewChange's view ({:?}) does not match NewView's view ({:?})"",
-                message.get_info().get_view(),
-                view,
-            )));
+            // Send PrePrepare messages if we're the primary
+            if state.is_primary() {
+                let s = state.seq_num;
+                self._broadcast_pbft_message(s, &PbftMessageType::PrePrepare, pbft_block, state)?;
+            }
         }
 
-        Self::verify_vote_signer(vote)?;
-
-        Ok(PeerId::from(message.get_info().get_signer_id()))
+        Ok(())
     }
 
-    /// Verifies that the NewView messsage is valid
-    fn verify_new_view(
-        &mut self,
-        new_view: &PbftNewView,
-        state: &mut PbftState,
-    ) -> Result<(), PbftError> {
-        // Make sure this is from the new primary
-        if PeerId::from(new_view.get_info().get_signer_id())
-            != state.get_primary_id_at_view(new_view.get_info().get_view())
-        {
-            error!(
-                ""Got NewView message ({:?}) from node that is not primary for new view"",
-                new_view,
-            );
-            return Err(PbftError::NotFromPrimary);
-        }
-
-        // Verify each individual vote, and extract the signer ID from each ViewChange that
-        // it contains so we can verify the IDs themselves
-        let voter_ids =
-            new_view
-                .get_view_changes()
-                .iter()
-                .try_fold(HashSet::new(), |mut ids, v| {
-                    Self::verify_view_change_vote(v, new_view.get_info().get_view())
-                        .and_then(|vid| Ok(ids.insert(vid)))?;
-                    Ok(ids)
-                })?;
-
-        // All of the votes must come from known peers, and the new primary can't
-        // explicitly vote itself, since broacasting the NewView is an implicit vote. Check
-        // that the votes we've received are a subset of ""peers - primary"".
-        let peer_ids: HashSet<_> = state
-            .peer_ids
-            .iter()
-            .cloned()
-            .filter(|pid| pid != &PeerId::from(new_view.get_info().get_signer_id()))
-            .collect();
+    /// Use the given block's consensus seal to verify and commit the block this node is working on
+    fn catchup(&mut self, state: &mut PbftState, block: &Block) -> Result<(), PbftError> {
+        info!(
+            ""{}: Trying catchup to #{} from BlockNew message #{}"",
+            state, state.seq_num, block.block_num,
+        );
 
-        if !voter_ids.is_subset(&peer_ids) {
-            return Err(PbftError::InternalError(format!(
-                ""Got unexpected vote IDs when verifying NewView: {:?}"",
-                voter_ids.difference(&peer_ids).collect::<Vec<_>>()
-            )));
-        }
+        match state.working_block {
+            Some(ref working_block) => {
+                let block_num_matches = block.block_num == working_block.get_block_num() + 1;
+                let block_id_matches = block.previous_id == working_block.get_block_id();
 
-        // Check that we've received 2f votes, since the primary vote is implicit
-        if voter_ids.len() < 2 * state.f as usize {
-            return Err(PbftError::InternalError(format!(
-                ""Need {} votes, only found {}!"",
-                2 * state.f,
-                voter_ids.len()
-            )));
+                if !block_num_matches || !block_id_matches {
+                    error!(
+                        ""Block didn't match for catchup: {:?} {:?}"",
+                        block, working_block
+                    );
+                    return Err(PbftError::MismatchedBlocks(vec![
+                        pbft_block_from_block(block.clone()),
+                        working_block.clone(),
+                    ]));
+                }
+            }
+            None => {
+                error!(
+                    ""Trying to catch up, but node does not have block #{} yet"",
+                    state.seq_num
+                );
+                return Err(PbftError::NoWorkingBlock);
+            }
         }
 
-        Ok(())
-    }
+        // Parse messages from the seal
+        let seal: PbftSeal =
+            protobuf::parse_from_bytes(&block.payload).map_err(PbftError::SerializationError)?;
 
-    /// Verifies an individual consensus vote
-    ///
-    /// Returns the signer ID of the wrapped PbftMessage, for use in further verification
-    fn verify_consensus_vote(vote: &PbftSignedVote, seal: &PbftSeal) -> Result<Vec<u8>, PbftError> {
-        let message: PbftMessage = protobuf::parse_from_bytes(&vote.get_message_bytes())
-            .map_err(PbftError::SerializationError)?;
+        let messages =
+            seal.get_previous_commit_votes()
+                .iter()
+                .try_fold(Vec::new(), |mut msgs, v| {
+                    msgs.push(ParsedMessage::from_pbft_message(
+                        protobuf::parse_from_bytes(&v.get_message_bytes())
+                            .map_err(PbftError::SerializationError)?,
+                    ));
+                    Ok(msgs)
+                })?;
 
-        if PbftMessageType::from(message.get_info().get_msg_type()) != PbftMessageType::Commit {
-            return Err(PbftError::InternalError(format!(
-                ""Received consensus vote that is not a Commit: {:?}"",
-                message
-            )));
+        // Update our view if necessary
+        let view = messages[0].info().get_view();
+        if view > state.view {
+            info!(""Updating view from {} to {}."", state.view, view);
+            state.view = view;
         }
 
-        if message.get_block().block_id != seal.previous_id {
-            return Err(PbftError::InternalError(format!(
-                ""PbftMessage block ID ({:?}) doesn't match seal's previous id ({:?})!"",
-                message.get_block().get_block_id(),
-                seal.previous_id
-            )));
+        // Add messages to the log
+        for message in &messages {
+            self.msg_log.add_message(message.clone(), state)?;
         }
 
-        Self::verify_vote_signer(vote)?;
+        // Commit the new block using one of the parsed messages and skip straight to Finished
+        self.service
+            .commit_block(messages[0].get_block().block_id.clone())
+            .map_err(|e| PbftError::InternalError(format!(""Failed to commit block: {:?}"", e)))?;
+        state.phase = PbftPhase::Finished;
 
-        Ok(message.get_info().get_signer_id().to_vec())
+        // Call on_block_commit right away so we're ready to catch up again if necessary
+        self.on_block_commit(BlockId::from(messages[0].get_block().get_block_id()), state);
+
+        Ok(())
     }
 
-    /// Verifies the consensus seal from the current block, for the previous block
-    fn verify_consensus_seal(
+    /// Handle a `BlockValid` update from the Validator
+    ///
+    /// This message arrives after `check_blocks` is called, signifying that the validator has
+    /// successfully checked a block with this `BlockId`. Once a `BlockValid` is received for the
+    /// working block, transition to the Preparing phase.
+    #[allow(clippy::ptr_arg)]
+    pub fn on_block_valid(
         &mut self,
-        block: &Block,
+        block_id: &BlockId,
         state: &mut PbftState,
     ) -> Result<(), PbftError> {
-        // We don't publish a consensus seal until block 1, so we don't verify it
-        // until block 2
-        if block.block_num < 2 {
-            return Ok(());
-        }
+        debug!(""{}: <<<<<< BlockValid: {:?}"", state, block_id);
+        let block = match state.working_block {
+            Some(ref block) => {
+                if &BlockId::from(block.get_block_id()) == block_id {
+                    Ok(block.clone())
+                } else {
+                    warn!(""Got BlockValid that doesn't match the working block"");
+                    Err(PbftError::NotReadyForMessage)
+                }
+            }
+            None => {
+                warn!(""Got BlockValid with no working block"");",912,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/247623137,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r247623137,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,"Copied as-is, will be fixed in logging update PR",eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-14 19:29:13,247626295,"@@ -411,520 +412,549 @@ impl PbftNode {
         Ok(())
     }
 
-    /// Verify that the vote is properly signed
-    fn verify_vote_signer(vote: &PbftSignedVote) -> Result<(), PbftError> {
-        let header: ConsensusPeerMessageHeader =
-            protobuf::parse_from_bytes(&vote.get_header_bytes())
-                .map_err(PbftError::SerializationError)?;
-
-        let key = Secp256k1PublicKey::from_hex(&hex::encode(&header.signer_id)).unwrap();
+    /// Handle a `BlockNew` update from the Validator
+    ///
+    /// The validator has received a new block; verify the block's consensus seal and add the
+    /// BlockNew to the message log. If this is the block we are waiting for: set it as the working
+    /// block, update the idle & commit timers, and broadcast a PrePrepare if this node is the
+    /// primary. If this is the block after the one this node is working on, use it to catch up.
+    pub fn on_block_new(&mut self, block: Block, state: &mut PbftState) -> Result<(), PbftError> {
+        info!(
+            ""{}: Got BlockNew: {} / {}"",
+            state,
+            block.block_num,
+            hex::encode(&block.block_id[..3]),
+        );
 
-        let context = create_context(""secp256k1"")
-            .map_err(|err| PbftError::InternalError(format!(""Couldn't create context: {}"", err)))?;
+        if block.block_num < state.seq_num {
+            info!(
+                ""Ignoring block ({}) that's older than current sequence number ({})."",
+                block.block_num, state.seq_num
+            );
+            return Ok(());
+        }
 
-        match context.verify(
-            &hex::encode(vote.get_header_signature()),
-            vote.get_header_bytes(),
-            &key,
-        ) {
-            Ok(true) => {}
-            Ok(false) => {
-                return Err(PbftError::InternalError(
-                    ""Header failed verification!"".into(),
-                ))
-            }
+        match self.verify_consensus_seal(&block, state) {
+            Ok(_) => {}
             Err(err) => {
-                return Err(PbftError::InternalError(format!(
-                    ""Error while verifying header: {:?}"",
+                warn!(",717,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/247626295,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r247626295,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,"Was copied as-is, fixed in new commit: ""Remove needless_pass_by_value allows""",eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-14 19:33:26,247627717,"@@ -411,520 +412,549 @@ impl PbftNode {
         Ok(())
     }
 
-    /// Verify that the vote is properly signed
-    fn verify_vote_signer(vote: &PbftSignedVote) -> Result<(), PbftError> {
-        let header: ConsensusPeerMessageHeader =
-            protobuf::parse_from_bytes(&vote.get_header_bytes())
-                .map_err(PbftError::SerializationError)?;
-
-        let key = Secp256k1PublicKey::from_hex(&hex::encode(&header.signer_id)).unwrap();
+    /// Handle a `BlockNew` update from the Validator
+    ///
+    /// The validator has received a new block; verify the block's consensus seal and add the
+    /// BlockNew to the message log. If this is the block we are waiting for: set it as the working
+    /// block, update the idle & commit timers, and broadcast a PrePrepare if this node is the
+    /// primary. If this is the block after the one this node is working on, use it to catch up.
+    pub fn on_block_new(&mut self, block: Block, state: &mut PbftState) -> Result<(), PbftError> {
+        info!(
+            ""{}: Got BlockNew: {} / {}"",
+            state,
+            block.block_num,
+            hex::encode(&block.block_id[..3]),
+        );
 
-        let context = create_context(""secp256k1"")
-            .map_err(|err| PbftError::InternalError(format!(""Couldn't create context: {}"", err)))?;
+        if block.block_num < state.seq_num {
+            info!(
+                ""Ignoring block ({}) that's older than current sequence number ({})."",
+                block.block_num, state.seq_num
+            );
+            return Ok(());
+        }
 
-        match context.verify(
-            &hex::encode(vote.get_header_signature()),
-            vote.get_header_bytes(),
-            &key,
-        ) {
-            Ok(true) => {}
-            Ok(false) => {
-                return Err(PbftError::InternalError(
-                    ""Header failed verification!"".into(),
-                ))
-            }
+        match self.verify_consensus_seal(&block, state) {
+            Ok(_) => {}
             Err(err) => {
-                return Err(PbftError::InternalError(format!(
-                    ""Error while verifying header: {:?}"",
+                warn!(
+                    ""Failing block due to failed consensus seal verification and \
+                     proposing view change! Error was {}"",
                     err
-                )))
+                );
+                self.service.fail_block(block.block_id).map_err(|err| {
+                    PbftError::InternalError(format!(""Couldn't fail block: {}"", err))
+                })?;
+                self.propose_view_change(state, state.view + 1)?;
+                return Err(err);
             }
         }
 
-        verify_sha512(vote.get_message_bytes(), header.get_content_sha512())?;
+        // Create PBFT message for BlockNew and add it to the log
+        let mut msg = PbftMessage::new();
+        msg.set_info(handlers::make_msg_info(
+            &PbftMessageType::BlockNew,
+            state.view,
+            block.block_num,
+            state.id.clone(),
+        ));
 
-        Ok(())
-    }
+        let pbft_block = pbft_block_from_block(block.clone());
+        msg.set_block(pbft_block.clone());
 
-    /// Verify an individual view change vote
-    ///
-    /// Return the signer ID of the wrapped PbftMessage for use in further verification
-    fn verify_view_change_vote(vote: &PbftSignedVote, view: u64) -> Result<PeerId, PbftError> {
-        let message: PbftMessage = protobuf::parse_from_bytes(&vote.get_message_bytes())
-            .map_err(PbftError::SerializationError)?;
+        self.msg_log
+            .add_message(ParsedMessage::from_pbft_message(msg.clone()), state)?;
 
-        if PbftMessageType::from(message.get_info().get_msg_type()) != PbftMessageType::ViewChange {
-            return Err(PbftError::InternalError(format!(
-                ""Received view change vote that is not a ViewChange: {:?}"",
-                message
-            )));
-        }
+        // We can use this block's seal to commit the next block (i.e. catch-up) if it's the block
+        // after the one we're waiting for and we haven't already told the validator to commit the
+        // block we're waiting for
+        if block.block_num == state.seq_num + 1 && state.phase != PbftPhase::Finished {
+            self.catchup(state, &block)?;
+        } else if block.block_num == state.seq_num {
+            // This is the block we're waiting for, so we update state
+            state.working_block = Some(msg.get_block().clone());
 
-        if message.get_info().get_view() != view {
-            return Err(PbftError::InternalError(format!(
-                ""ViewChange's view ({:?}) does not match NewView's view ({:?})"",
-                message.get_info().get_view(),
-                view,
-            )));
+            // Send PrePrepare messages if we're the primary
+            if state.is_primary() {
+                let s = state.seq_num;
+                self._broadcast_pbft_message(s, &PbftMessageType::PrePrepare, pbft_block, state)?;
+            }
         }
 
-        Self::verify_vote_signer(vote)?;
-
-        Ok(PeerId::from(message.get_info().get_signer_id()))
+        Ok(())
     }
 
-    /// Verifies that the NewView messsage is valid
-    fn verify_new_view(
-        &mut self,
-        new_view: &PbftNewView,
-        state: &mut PbftState,
-    ) -> Result<(), PbftError> {
-        // Make sure this is from the new primary
-        if PeerId::from(new_view.get_info().get_signer_id())
-            != state.get_primary_id_at_view(new_view.get_info().get_view())
-        {
-            error!(
-                ""Got NewView message ({:?}) from node that is not primary for new view"",
-                new_view,
-            );
-            return Err(PbftError::NotFromPrimary);
-        }
-
-        // Verify each individual vote, and extract the signer ID from each ViewChange that
-        // it contains so we can verify the IDs themselves
-        let voter_ids =
-            new_view
-                .get_view_changes()
-                .iter()
-                .try_fold(HashSet::new(), |mut ids, v| {
-                    Self::verify_view_change_vote(v, new_view.get_info().get_view())
-                        .and_then(|vid| Ok(ids.insert(vid)))?;
-                    Ok(ids)
-                })?;
-
-        // All of the votes must come from known peers, and the new primary can't
-        // explicitly vote itself, since broacasting the NewView is an implicit vote. Check
-        // that the votes we've received are a subset of ""peers - primary"".
-        let peer_ids: HashSet<_> = state
-            .peer_ids
-            .iter()
-            .cloned()
-            .filter(|pid| pid != &PeerId::from(new_view.get_info().get_signer_id()))
-            .collect();
+    /// Use the given block's consensus seal to verify and commit the block this node is working on
+    fn catchup(&mut self, state: &mut PbftState, block: &Block) -> Result<(), PbftError> {
+        info!(
+            ""{}: Trying catchup to #{} from BlockNew message #{}"",
+            state, state.seq_num, block.block_num,
+        );
 
-        if !voter_ids.is_subset(&peer_ids) {
-            return Err(PbftError::InternalError(format!(
-                ""Got unexpected vote IDs when verifying NewView: {:?}"",
-                voter_ids.difference(&peer_ids).collect::<Vec<_>>()
-            )));
-        }
+        match state.working_block {
+            Some(ref working_block) => {
+                let block_num_matches = block.block_num == working_block.get_block_num() + 1;
+                let block_id_matches = block.previous_id == working_block.get_block_id();
 
-        // Check that we've received 2f votes, since the primary vote is implicit
-        if voter_ids.len() < 2 * state.f as usize {
-            return Err(PbftError::InternalError(format!(
-                ""Need {} votes, only found {}!"",
-                2 * state.f,
-                voter_ids.len()
-            )));
+                if !block_num_matches || !block_id_matches {
+                    error!(
+                        ""Block didn't match for catchup: {:?} {:?}"",
+                        block, working_block
+                    );
+                    return Err(PbftError::MismatchedBlocks(vec![
+                        pbft_block_from_block(block.clone()),
+                        working_block.clone(),
+                    ]));
+                }
+            }
+            None => {
+                error!(
+                    ""Trying to catch up, but node does not have block #{} yet"",
+                    state.seq_num
+                );
+                return Err(PbftError::NoWorkingBlock);
+            }
         }
 
-        Ok(())
-    }
+        // Parse messages from the seal
+        let seal: PbftSeal =
+            protobuf::parse_from_bytes(&block.payload).map_err(PbftError::SerializationError)?;
 
-    /// Verifies an individual consensus vote
-    ///
-    /// Returns the signer ID of the wrapped PbftMessage, for use in further verification
-    fn verify_consensus_vote(vote: &PbftSignedVote, seal: &PbftSeal) -> Result<Vec<u8>, PbftError> {
-        let message: PbftMessage = protobuf::parse_from_bytes(&vote.get_message_bytes())
-            .map_err(PbftError::SerializationError)?;
+        let messages =
+            seal.get_previous_commit_votes()
+                .iter()
+                .try_fold(Vec::new(), |mut msgs, v| {
+                    msgs.push(ParsedMessage::from_pbft_message(
+                        protobuf::parse_from_bytes(&v.get_message_bytes())
+                            .map_err(PbftError::SerializationError)?,
+                    ));
+                    Ok(msgs)
+                })?;
 
-        if PbftMessageType::from(message.get_info().get_msg_type()) != PbftMessageType::Commit {
-            return Err(PbftError::InternalError(format!(
-                ""Received consensus vote that is not a Commit: {:?}"",
-                message
-            )));
+        // Update our view if necessary
+        let view = messages[0].info().get_view();
+        if view > state.view {
+            info!(""Updating view from {} to {}."", state.view, view);
+            state.view = view;
         }
 
-        if message.get_block().block_id != seal.previous_id {
-            return Err(PbftError::InternalError(format!(
-                ""PbftMessage block ID ({:?}) doesn't match seal's previous id ({:?})!"",
-                message.get_block().get_block_id(),
-                seal.previous_id
-            )));
+        // Add messages to the log
+        for message in &messages {
+            self.msg_log.add_message(message.clone(), state)?;
         }
 
-        Self::verify_vote_signer(vote)?;
+        // Commit the new block using one of the parsed messages and skip straight to Finished
+        self.service
+            .commit_block(messages[0].get_block().block_id.clone())
+            .map_err(|e| PbftError::InternalError(format!(""Failed to commit block: {:?}"", e)))?;
+        state.phase = PbftPhase::Finished;
 
-        Ok(message.get_info().get_signer_id().to_vec())
+        // Call on_block_commit right away so we're ready to catch up again if necessary
+        self.on_block_commit(BlockId::from(messages[0].get_block().get_block_id()), state);
+
+        Ok(())
     }
 
-    /// Verifies the consensus seal from the current block, for the previous block
-    fn verify_consensus_seal(
+    /// Handle a `BlockValid` update from the Validator
+    ///
+    /// This message arrives after `check_blocks` is called, signifying that the validator has
+    /// successfully checked a block with this `BlockId`. Once a `BlockValid` is received for the
+    /// working block, transition to the Preparing phase.
+    #[allow(clippy::ptr_arg)]
+    pub fn on_block_valid(
         &mut self,
-        block: &Block,
+        block_id: &BlockId,
         state: &mut PbftState,
     ) -> Result<(), PbftError> {
-        // We don't publish a consensus seal until block 1, so we don't verify it
-        // until block 2
-        if block.block_num < 2 {
-            return Ok(());
-        }
+        debug!(""{}: <<<<<< BlockValid: {:?}"", state, block_id);
+        let block = match state.working_block {
+            Some(ref block) => {
+                if &BlockId::from(block.get_block_id()) == block_id {
+                    Ok(block.clone())
+                } else {
+                    warn!(""Got BlockValid that doesn't match the working block"");
+                    Err(PbftError::NotReadyForMessage)
+                }
+            }
+            None => {
+                warn!(""Got BlockValid with no working block"");
+                Err(PbftError::NoWorkingBlock)
+            }
+        }?;
 
-        if block.payload.is_empty() {
-            return Err(PbftError::InternalError(
-                ""Got empty payload for non-genesis block!"".into(),
-            ));
-        }
+        state.switch_phase(PbftPhase::Preparing);
+        self._broadcast_pbft_message(
+            state.seq_num,
+            &PbftMessageType::Prepare,
+            block.clone(),
+            state,
+        )?;
+        Ok(())
+    }
 
-        let seal: PbftSeal =
-            protobuf::parse_from_bytes(&block.payload).map_err(PbftError::SerializationError)?;
+    /// Handle a `BlockCommit` update from the Validator
+    ///
+    /// A block was sucessfully committed; update state to be ready for the next block, make any
+    /// necessary view and membership changes, garbage collect the logs, update the commit & idle
+    /// timers, and start a new block if this node is the primary.
+    #[allow(clippy::needless_pass_by_value)]
+    pub fn on_block_commit(&mut self, block_id: BlockId, state: &mut PbftState) {
+        debug!(""{}: <<<<<< BlockCommit: {:?}"", state, block_id);
 
-        if seal.previous_id != &block.previous_id[..] {
-            return Err(PbftError::InternalError(format!(
-                ""Consensus seal failed verification. Seal's previous ID `{}` doesn't match block's previous ID `{}`"",
-                hex::encode(&seal.previous_id[..3]), hex::encode(&block.previous_id[..3])
-            )));
+        let is_working_block = match state.working_block {
+            Some(ref block) => BlockId::from(block.get_block_id()) == block_id,
+            None => false,
+        };
+
+        if state.phase != PbftPhase::Finished || !is_working_block {
+            info!(
+                ""{}: Got BlockCommit for a block that isn't the working block"",
+                state
+            );
+            return;
         }
 
-        if seal.summary != &block.summary[..] {
-            return Err(PbftError::InternalError(format!(
-                ""Consensus seal failed verification. Seal's summary {:?} doesn't match block's summary {:?}"",
-                seal.summary, block.summary
-            )));
+        // Update state to be ready for next block
+        state.switch_phase(PbftPhase::PrePreparing);
+        state.seq_num += 1;
+
+        // If we already have a BlockNew for the next block, we can make it the working block;
+        // otherwise just set the working block to None
+        state.working_block = self
+            .msg_log
+            .get_messages_of_type_seq(&PbftMessageType::BlockNew, state.seq_num)
+            .first()
+            .map(|msg| msg.get_block().clone());
+
+        // Increment the view if we need to force a view change for fairness or if membership
+        // has changed
+        if state.at_forced_view_change() || self.update_membership(block_id.clone(), state) {
+            state.view += 1;
         }
 
-        // Verify each individual vote, and extract the signer ID from each PbftMessage that
-        // it contains, so that we can do some sanity checks on those IDs.
-        let voter_ids =
-            seal.get_previous_commit_votes()
-                .iter()
-                .try_fold(HashSet::new(), |mut ids, v| {
-                    Self::verify_consensus_vote(v, &seal).and_then(|vid| Ok(ids.insert(vid)))?;
-                    Ok(ids)
-                })?;
+        // Tell the log to garbage collect if it needs to
+        self.msg_log.garbage_collect(state.seq_num);
 
-        // All of the votes must come from known peers, and the primary can't explicitly
-        // vote itself, since publishing a block is an implicit vote. Check that the votes
-        // we've received are a subset of ""peers - primary"". We need to use the list of
-        // peers from the block we're verifying the seal for, since it may have changed.
+        // Restart the faulty primary timeout for the next block
+        state.faulty_primary_timeout.start();
+
+        if state.is_primary() && state.working_block.is_none() {
+            info!(
+                ""{}: Initializing block with previous ID {:?}"",
+                state, block_id
+            );
+            self.service
+                .initialize_block(Some(block_id.clone()))
+                .unwrap_or_else(|err| error!(""Couldn't initialize block: {}"", err));
+        }
+    }
+
+    /// Check the on-chain list of peers; if it has changed, update peers list and return true.
+    fn update_membership(&mut self, block_id: BlockId, state: &mut PbftState) -> bool {
+        // Get list of peers from settings
         let settings = self
             .service
             .get_settings(
-                block.previous_id.clone(),
+                block_id,
                 vec![String::from(""sawtooth.consensus.pbft.peers"")],
             )
             .expect(""Failed to get settings"");
         let peers = get_peers_from_settings(&settings);
+        let new_peers_set: HashSet<PeerId> = peers.iter().cloned().collect();
 
-        let peer_ids: HashSet<_> = peers
-            .iter()
-            .cloned()
-            .filter(|pid| pid != &block.signer_id)
-            .collect();
-
-        if !voter_ids.is_subset(&peer_ids) {
-            return Err(PbftError::InternalError(format!(
-                ""Got unexpected vote IDs: {:?}"",
-                voter_ids.difference(&peer_ids).collect::<Vec<_>>()
-            )));
-        }
+        // Check if membership has changed
+        let old_peers_set: HashSet<PeerId> = state.peer_ids.iter().cloned().collect();
 
-        // Check that we've received 2f votes, since the primary vote is implicit
-        if voter_ids.len() < 2 * state.f as usize {
-            return Err(PbftError::InternalError(format!(
-                ""Need {} votes, only found {}!"",
-                2 * state.f,
-                voter_ids.len()
-            )));
+        if new_peers_set != old_peers_set {
+            state.peer_ids = peers;
+            let f = ((state.peer_ids.len() - 1) / 3) as u64;
+            if f == 0 {
+                panic!(""This network no longer contains enough nodes to be fault tolerant"");
+            }
+            state.f = f;
+            return true;
         }
 
-        Ok(())
+        false
     }
 
-    /// Use the given block's consensus seal to verify and commit the block this node is working on
-    fn catchup(&mut self, state: &mut PbftState, block: &Block) -> Result<(), PbftError> {
-        info!(
-            ""{}: Trying catchup to #{} from BlockNew message #{}"",
-            state, state.seq_num, block.block_num,
-        );
+    // ---------- Methods for building & verifying proofs and signed messages from other nodes ----------
 
-        match state.working_block {
-            Some(ref working_block) => {
-                let block_num_matches = block.block_num == working_block.get_block_num() + 1;
-                let block_id_matches = block.previous_id == working_block.get_block_id();
-
-                if !block_num_matches || !block_id_matches {
-                    error!(
-                        ""Block didn't match for catchup: {:?} {:?}"",
-                        block, working_block
-                    );
-                    return Err(PbftError::MismatchedBlocks(vec![
-                        pbft_block_from_block(block.clone()),
-                        working_block.clone(),
-                    ]));
-                }
-            }
-            None => {
-                error!(
-                    ""Trying to catch up, but node does not have block #{} yet"",
-                    state.seq_num
-                );
-                return Err(PbftError::NoWorkingBlock);
-            }
-        }
+    /// Generate a `protobuf::RepeatedField` of signed votes from a list of parsed messages
+    #[allow(clippy::needless_pass_by_value)]",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/247627717,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r247627717,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,"Was copied as-is, fixed in new commit: ""Remove needless_pass_by_value allows""",eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-14 19:33:28,247627734,"@@ -411,520 +412,549 @@ impl PbftNode {
         Ok(())
     }
 
-    /// Verify that the vote is properly signed
-    fn verify_vote_signer(vote: &PbftSignedVote) -> Result<(), PbftError> {
-        let header: ConsensusPeerMessageHeader =
-            protobuf::parse_from_bytes(&vote.get_header_bytes())
-                .map_err(PbftError::SerializationError)?;
-
-        let key = Secp256k1PublicKey::from_hex(&hex::encode(&header.signer_id)).unwrap();
+    /// Handle a `BlockNew` update from the Validator
+    ///
+    /// The validator has received a new block; verify the block's consensus seal and add the
+    /// BlockNew to the message log. If this is the block we are waiting for: set it as the working
+    /// block, update the idle & commit timers, and broadcast a PrePrepare if this node is the
+    /// primary. If this is the block after the one this node is working on, use it to catch up.
+    pub fn on_block_new(&mut self, block: Block, state: &mut PbftState) -> Result<(), PbftError> {
+        info!(
+            ""{}: Got BlockNew: {} / {}"",
+            state,
+            block.block_num,
+            hex::encode(&block.block_id[..3]),
+        );
 
-        let context = create_context(""secp256k1"")
-            .map_err(|err| PbftError::InternalError(format!(""Couldn't create context: {}"", err)))?;
+        if block.block_num < state.seq_num {
+            info!(
+                ""Ignoring block ({}) that's older than current sequence number ({})."",
+                block.block_num, state.seq_num
+            );
+            return Ok(());
+        }
 
-        match context.verify(
-            &hex::encode(vote.get_header_signature()),
-            vote.get_header_bytes(),
-            &key,
-        ) {
-            Ok(true) => {}
-            Ok(false) => {
-                return Err(PbftError::InternalError(
-                    ""Header failed verification!"".into(),
-                ))
-            }
+        match self.verify_consensus_seal(&block, state) {
+            Ok(_) => {}
             Err(err) => {
-                return Err(PbftError::InternalError(format!(
-                    ""Error while verifying header: {:?}"",
+                warn!(
+                    ""Failing block due to failed consensus seal verification and \
+                     proposing view change! Error was {}"",
                     err
-                )))
+                );
+                self.service.fail_block(block.block_id).map_err(|err| {
+                    PbftError::InternalError(format!(""Couldn't fail block: {}"", err))
+                })?;
+                self.propose_view_change(state, state.view + 1)?;
+                return Err(err);
             }
         }
 
-        verify_sha512(vote.get_message_bytes(), header.get_content_sha512())?;
+        // Create PBFT message for BlockNew and add it to the log
+        let mut msg = PbftMessage::new();
+        msg.set_info(handlers::make_msg_info(
+            &PbftMessageType::BlockNew,
+            state.view,
+            block.block_num,
+            state.id.clone(),
+        ));
 
-        Ok(())
-    }
+        let pbft_block = pbft_block_from_block(block.clone());
+        msg.set_block(pbft_block.clone());
 
-    /// Verify an individual view change vote
-    ///
-    /// Return the signer ID of the wrapped PbftMessage for use in further verification
-    fn verify_view_change_vote(vote: &PbftSignedVote, view: u64) -> Result<PeerId, PbftError> {
-        let message: PbftMessage = protobuf::parse_from_bytes(&vote.get_message_bytes())
-            .map_err(PbftError::SerializationError)?;
+        self.msg_log
+            .add_message(ParsedMessage::from_pbft_message(msg.clone()), state)?;
 
-        if PbftMessageType::from(message.get_info().get_msg_type()) != PbftMessageType::ViewChange {
-            return Err(PbftError::InternalError(format!(
-                ""Received view change vote that is not a ViewChange: {:?}"",
-                message
-            )));
-        }
+        // We can use this block's seal to commit the next block (i.e. catch-up) if it's the block
+        // after the one we're waiting for and we haven't already told the validator to commit the
+        // block we're waiting for
+        if block.block_num == state.seq_num + 1 && state.phase != PbftPhase::Finished {
+            self.catchup(state, &block)?;
+        } else if block.block_num == state.seq_num {
+            // This is the block we're waiting for, so we update state
+            state.working_block = Some(msg.get_block().clone());
 
-        if message.get_info().get_view() != view {
-            return Err(PbftError::InternalError(format!(
-                ""ViewChange's view ({:?}) does not match NewView's view ({:?})"",
-                message.get_info().get_view(),
-                view,
-            )));
+            // Send PrePrepare messages if we're the primary
+            if state.is_primary() {
+                let s = state.seq_num;
+                self._broadcast_pbft_message(s, &PbftMessageType::PrePrepare, pbft_block, state)?;
+            }
         }
 
-        Self::verify_vote_signer(vote)?;
-
-        Ok(PeerId::from(message.get_info().get_signer_id()))
+        Ok(())
     }
 
-    /// Verifies that the NewView messsage is valid
-    fn verify_new_view(
-        &mut self,
-        new_view: &PbftNewView,
-        state: &mut PbftState,
-    ) -> Result<(), PbftError> {
-        // Make sure this is from the new primary
-        if PeerId::from(new_view.get_info().get_signer_id())
-            != state.get_primary_id_at_view(new_view.get_info().get_view())
-        {
-            error!(
-                ""Got NewView message ({:?}) from node that is not primary for new view"",
-                new_view,
-            );
-            return Err(PbftError::NotFromPrimary);
-        }
-
-        // Verify each individual vote, and extract the signer ID from each ViewChange that
-        // it contains so we can verify the IDs themselves
-        let voter_ids =
-            new_view
-                .get_view_changes()
-                .iter()
-                .try_fold(HashSet::new(), |mut ids, v| {
-                    Self::verify_view_change_vote(v, new_view.get_info().get_view())
-                        .and_then(|vid| Ok(ids.insert(vid)))?;
-                    Ok(ids)
-                })?;
-
-        // All of the votes must come from known peers, and the new primary can't
-        // explicitly vote itself, since broacasting the NewView is an implicit vote. Check
-        // that the votes we've received are a subset of ""peers - primary"".
-        let peer_ids: HashSet<_> = state
-            .peer_ids
-            .iter()
-            .cloned()
-            .filter(|pid| pid != &PeerId::from(new_view.get_info().get_signer_id()))
-            .collect();
+    /// Use the given block's consensus seal to verify and commit the block this node is working on
+    fn catchup(&mut self, state: &mut PbftState, block: &Block) -> Result<(), PbftError> {
+        info!(
+            ""{}: Trying catchup to #{} from BlockNew message #{}"",
+            state, state.seq_num, block.block_num,
+        );
 
-        if !voter_ids.is_subset(&peer_ids) {
-            return Err(PbftError::InternalError(format!(
-                ""Got unexpected vote IDs when verifying NewView: {:?}"",
-                voter_ids.difference(&peer_ids).collect::<Vec<_>>()
-            )));
-        }
+        match state.working_block {
+            Some(ref working_block) => {
+                let block_num_matches = block.block_num == working_block.get_block_num() + 1;
+                let block_id_matches = block.previous_id == working_block.get_block_id();
 
-        // Check that we've received 2f votes, since the primary vote is implicit
-        if voter_ids.len() < 2 * state.f as usize {
-            return Err(PbftError::InternalError(format!(
-                ""Need {} votes, only found {}!"",
-                2 * state.f,
-                voter_ids.len()
-            )));
+                if !block_num_matches || !block_id_matches {
+                    error!(
+                        ""Block didn't match for catchup: {:?} {:?}"",
+                        block, working_block
+                    );
+                    return Err(PbftError::MismatchedBlocks(vec![
+                        pbft_block_from_block(block.clone()),
+                        working_block.clone(),
+                    ]));
+                }
+            }
+            None => {
+                error!(
+                    ""Trying to catch up, but node does not have block #{} yet"",
+                    state.seq_num
+                );
+                return Err(PbftError::NoWorkingBlock);
+            }
         }
 
-        Ok(())
-    }
+        // Parse messages from the seal
+        let seal: PbftSeal =
+            protobuf::parse_from_bytes(&block.payload).map_err(PbftError::SerializationError)?;
 
-    /// Verifies an individual consensus vote
-    ///
-    /// Returns the signer ID of the wrapped PbftMessage, for use in further verification
-    fn verify_consensus_vote(vote: &PbftSignedVote, seal: &PbftSeal) -> Result<Vec<u8>, PbftError> {
-        let message: PbftMessage = protobuf::parse_from_bytes(&vote.get_message_bytes())
-            .map_err(PbftError::SerializationError)?;
+        let messages =
+            seal.get_previous_commit_votes()
+                .iter()
+                .try_fold(Vec::new(), |mut msgs, v| {
+                    msgs.push(ParsedMessage::from_pbft_message(
+                        protobuf::parse_from_bytes(&v.get_message_bytes())
+                            .map_err(PbftError::SerializationError)?,
+                    ));
+                    Ok(msgs)
+                })?;
 
-        if PbftMessageType::from(message.get_info().get_msg_type()) != PbftMessageType::Commit {
-            return Err(PbftError::InternalError(format!(
-                ""Received consensus vote that is not a Commit: {:?}"",
-                message
-            )));
+        // Update our view if necessary
+        let view = messages[0].info().get_view();
+        if view > state.view {
+            info!(""Updating view from {} to {}."", state.view, view);
+            state.view = view;
         }
 
-        if message.get_block().block_id != seal.previous_id {
-            return Err(PbftError::InternalError(format!(
-                ""PbftMessage block ID ({:?}) doesn't match seal's previous id ({:?})!"",
-                message.get_block().get_block_id(),
-                seal.previous_id
-            )));
+        // Add messages to the log
+        for message in &messages {
+            self.msg_log.add_message(message.clone(), state)?;
         }
 
-        Self::verify_vote_signer(vote)?;
+        // Commit the new block using one of the parsed messages and skip straight to Finished
+        self.service
+            .commit_block(messages[0].get_block().block_id.clone())
+            .map_err(|e| PbftError::InternalError(format!(""Failed to commit block: {:?}"", e)))?;
+        state.phase = PbftPhase::Finished;
 
-        Ok(message.get_info().get_signer_id().to_vec())
+        // Call on_block_commit right away so we're ready to catch up again if necessary
+        self.on_block_commit(BlockId::from(messages[0].get_block().get_block_id()), state);
+
+        Ok(())
     }
 
-    /// Verifies the consensus seal from the current block, for the previous block
-    fn verify_consensus_seal(
+    /// Handle a `BlockValid` update from the Validator
+    ///
+    /// This message arrives after `check_blocks` is called, signifying that the validator has
+    /// successfully checked a block with this `BlockId`. Once a `BlockValid` is received for the
+    /// working block, transition to the Preparing phase.
+    #[allow(clippy::ptr_arg)]
+    pub fn on_block_valid(
         &mut self,
-        block: &Block,
+        block_id: &BlockId,
         state: &mut PbftState,
     ) -> Result<(), PbftError> {
-        // We don't publish a consensus seal until block 1, so we don't verify it
-        // until block 2
-        if block.block_num < 2 {
-            return Ok(());
-        }
+        debug!(""{}: <<<<<< BlockValid: {:?}"", state, block_id);
+        let block = match state.working_block {
+            Some(ref block) => {
+                if &BlockId::from(block.get_block_id()) == block_id {
+                    Ok(block.clone())
+                } else {
+                    warn!(""Got BlockValid that doesn't match the working block"");
+                    Err(PbftError::NotReadyForMessage)
+                }
+            }
+            None => {
+                warn!(""Got BlockValid with no working block"");
+                Err(PbftError::NoWorkingBlock)
+            }
+        }?;
 
-        if block.payload.is_empty() {
-            return Err(PbftError::InternalError(
-                ""Got empty payload for non-genesis block!"".into(),
-            ));
-        }
+        state.switch_phase(PbftPhase::Preparing);
+        self._broadcast_pbft_message(
+            state.seq_num,
+            &PbftMessageType::Prepare,
+            block.clone(),
+            state,
+        )?;
+        Ok(())
+    }
 
-        let seal: PbftSeal =
-            protobuf::parse_from_bytes(&block.payload).map_err(PbftError::SerializationError)?;
+    /// Handle a `BlockCommit` update from the Validator
+    ///
+    /// A block was sucessfully committed; update state to be ready for the next block, make any
+    /// necessary view and membership changes, garbage collect the logs, update the commit & idle
+    /// timers, and start a new block if this node is the primary.
+    #[allow(clippy::needless_pass_by_value)]",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/247627734,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r247627734,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,"This particular usage is in a test, so it's impact is low, but in many cases there's an allocation for a vec on the heap, versus a stack allocation, so there are different performance/memory implications for one over the other.

For this test, you should have to change the list, but you can (I think) do `*msg_type` when using the message type later.  This should work because it is `Copy`.",eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-14 19:40:17,247630087,"@@ -384,25 +384,22 @@ mod tests {
         log.garbage_collect(5);
 
         for old in 1..3 {
-            for msg_type in &[
+            for msg_type in vec![",,2019-01-14 20:04:07,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/247630087,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r247630087,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/70,https://github.com/hyperledger/sawtooth-pbft/pull/70,Updated to use a slice,eb57088945be4facb4ce6418b964a0ff3b99f8af,2019-01-14 20:05:49,247639214,"@@ -384,25 +384,22 @@ mod tests {
         log.garbage_collect(5);
 
         for old in 1..3 {
-            for msg_type in &[
+            for msg_type in vec![",,2019-01-14 20:05:49,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/247639214,https://github.com/hyperledger/sawtooth-pbft/pull/70#discussion_r247639214,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/69,https://github.com/hyperledger/sawtooth-pbft/pull/69,"For clarity, maybe ""ViewChange messages, of length 2f"" to make it clearer that '2f' is in reference to the length.",90a06deb15915c6ce150620ce943a4afca23e665,2019-01-08 16:06:36,246054271,"@@ -52,35 +52,34 @@ message PbftMessage {
   PbftBlock block = 2;
 }
 
-
-// View change message, for when a node suspects the primary node is faulty
-message PbftViewChange {
+// A message sent by the new primary to signify that the new view should be
+// started
+message PbftNewView {
   // Message information
   PbftMessageInfo info = 1;
 
-  // Consensus seal proving the correctness of the block committed at the
-  // sequence number specified in the message info
-  PbftSeal seal = 2;
+  // 2f ViewChange messages",,2019-01-08 16:56:30,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/246054271,https://github.com/hyperledger/sawtooth-pbft/pull/69#discussion_r246054271,vaporos
https://github.com/hyperledger/sawtooth-pbft/pull/68,https://github.com/hyperledger/sawtooth-pbft/pull/68,You could just use `Duration::from_secs`,552f8ffea70244fac103ef1868514ef4c17b96b8,2019-01-03 16:30:07,245055673,"@@ -64,8 +60,7 @@ impl PbftConfig {
             peers: Vec::new(),
             block_duration: Duration::from_millis(200),
             message_timeout: Duration::from_millis(10),
-            commit_timeout: Duration::from_millis(4000),
-            idle_timeout: Duration::from_millis(30_000),
+            faulty_primary_timeout: Duration::from_millis(30_000),",,2019-01-03 18:50:50,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/245055673,https://github.com/hyperledger/sawtooth-pbft/pull/68#discussion_r245055673,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/68,https://github.com/hyperledger/sawtooth-pbft/pull/68,Updated,552f8ffea70244fac103ef1868514ef4c17b96b8,2019-01-03 16:53:41,245063390,"@@ -64,8 +60,7 @@ impl PbftConfig {
             peers: Vec::new(),
             block_duration: Duration::from_millis(200),
             message_timeout: Duration::from_millis(10),
-            commit_timeout: Duration::from_millis(4000),
-            idle_timeout: Duration::from_millis(30_000),
+            faulty_primary_timeout: Duration::from_millis(30_000),",,2019-01-03 18:50:50,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/245063390,https://github.com/hyperledger/sawtooth-pbft/pull/68#discussion_r245063390,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/67,https://github.com/hyperledger/sawtooth-pbft/pull/67,rename this to `working_block`. `wb` is too obtuse.,2f1ed3e7002f06a251926b7cb2c5a6a48a019617,2019-01-03 16:19:12,245052035,"@@ -358,71 +358,36 @@ impl PbftNode {
         Ok(Some(seal))
     }
 
-    /// Attempts to catch this node up with its peers, if necessary
-    ///
-    /// Returns true if catching up was required, and false otherwise
-    fn try_catchup(
-        &mut self,
-        state: &mut PbftState,
-        block: &Block,
-        msg: &PbftMessage,
-    ) -> Result<bool, PbftError> {
+    /// Use the given block's consensus seal to verify and commit the block this node is working on
+    fn catchup(&mut self, state: &mut PbftState, block: &Block) -> Result<(), PbftError> {
         info!(
-            ""{}: Trying catchup from to #{}, from BlockNew message #{}"",
+            ""{}: Trying catchup to #{} from BlockNew message #{}"",
             state, state.seq_num, block.block_num,
         );
 
-        // Don't catch up from block 0 -> 1, since there's no consensus seal.
-        if block.block_num < 2 {
-            return Ok(false);
-        }
-
-        // If we've got a working block, and the new block is immediately subsequent to it, then
-        // we're able to catch up. Otherwise, return false to signify that no catching up occurred.
-        match state.working_block.clone() {
-            Some(wb) => {
+        match state.working_block {
+            Some(ref wb) => {",,2019-01-03 17:35:20,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/245052035,https://github.com/hyperledger/sawtooth-pbft/pull/67#discussion_r245052035,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/67,https://github.com/hyperledger/sawtooth-pbft/pull/67,"Typo in the log statement ""catchup from to """,2f1ed3e7002f06a251926b7cb2c5a6a48a019617,2019-01-03 16:48:28,245061703,"@@ -366,14 +366,10 @@ impl PbftNode {
         state: &mut PbftState,
         block: &Block,
         msg: &PbftMessage,
-        head: &Block,
     ) -> Result<bool, PbftError> {
         info!(
-            ""{}: Trying catchup from head #{} to #{}, from BlockNew message #{}"",
-            state,
-            head.block_num,
-            head.block_num + 1,
-            block.block_num,
+            ""{}: Trying catchup from to #{}, from BlockNew message #{}"",",,2019-01-03 17:35:20,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/245061703,https://github.com/hyperledger/sawtooth-pbft/pull/67#discussion_r245061703,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/67,https://github.com/hyperledger/sawtooth-pbft/pull/67,"Fix wording in the commit message: ""Check that the block this BlockCommit message"" and ""find out it should no longer the primary because of a forced view change.""",2f1ed3e7002f06a251926b7cb2c5a6a48a019617,2019-01-03 16:52:41,245063050,"@@ -132,7 +132,7 @@ fn handle_update(
             warn!(""{}: BlockInvalid received, starting view change"", state);",1,2019-01-03 17:35:20,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/245063050,https://github.com/hyperledger/sawtooth-pbft/pull/67#discussion_r245063050,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/67,https://github.com/hyperledger/sawtooth-pbft/pull/67,Fixed,2f1ed3e7002f06a251926b7cb2c5a6a48a019617,2019-01-03 16:53:22,245063267,"@@ -358,71 +358,36 @@ impl PbftNode {
         Ok(Some(seal))
     }
 
-    /// Attempts to catch this node up with its peers, if necessary
-    ///
-    /// Returns true if catching up was required, and false otherwise
-    fn try_catchup(
-        &mut self,
-        state: &mut PbftState,
-        block: &Block,
-        msg: &PbftMessage,
-    ) -> Result<bool, PbftError> {
+    /// Use the given block's consensus seal to verify and commit the block this node is working on
+    fn catchup(&mut self, state: &mut PbftState, block: &Block) -> Result<(), PbftError> {
         info!(
-            ""{}: Trying catchup from to #{}, from BlockNew message #{}"",
+            ""{}: Trying catchup to #{} from BlockNew message #{}"",
             state, state.seq_num, block.block_num,
         );
 
-        // Don't catch up from block 0 -> 1, since there's no consensus seal.
-        if block.block_num < 2 {
-            return Ok(false);
-        }
-
-        // If we've got a working block, and the new block is immediately subsequent to it, then
-        // we're able to catch up. Otherwise, return false to signify that no catching up occurred.
-        match state.working_block.clone() {
-            Some(wb) => {
+        match state.working_block {
+            Some(ref wb) => {",,2019-01-03 17:35:20,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/245063267,https://github.com/hyperledger/sawtooth-pbft/pull/67#discussion_r245063267,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/60,https://github.com/hyperledger/sawtooth-pbft/pull/60,"TBH, it makes more sense to me to just inline these functions and add a relevant comment for each block, like the `// If the blocks don't match between two ...` comment. This is starting to feel too much like Java :P",68d03c5de94efedb74d1e7d9947cd6fa9f2f03dd,2018-12-17 21:27:54,242322363,"@@ -32,86 +32,82 @@ use protos::pbft_message::{PbftBlock, PbftMessageInfo};
 use state::{PbftPhase, PbftState, WorkingBlockOption};
 
 /// Handle a `PrePrepare` message
-/// A `PrePrepare` message with this view and sequence number must not already exist in the log.
-/// Make sure there's a corresponding BlockNew message.
+///
+/// A `PrePrepare` message is accepted and added to the log if the following are true:
+/// - The message signature is valid (already verified by validator)
+/// - The message is from the primary
+/// - There is a matching BlockNew message
+/// - A `PrePrepare` message does not already exist at this view and sequence number with a
+///   different block
+/// - The message's view matches the node's current view (handled by message log)
+/// - The sequence number is between the low and high watermarks (handled by message log)
+///
+/// If a `PrePrepare` message is accepted, we update the phase, working block, and sequence number
 pub fn pre_prepare(
     state: &mut PbftState,
     msg_log: &mut PbftLog,
     message: &ParsedMessage,
 ) -> Result<(), PbftError> {
-    let info = message.info();
+    check_from_primary(message.info(), state)?;
+    check_for_original_block_new(msg_log, message)?;
+    check_mismatched_pre_prepare_does_not_exist(msg_log, message)?;",,2018-12-18 00:17:53,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/242322363,https://github.com/hyperledger/sawtooth-pbft/pull/60#discussion_r242322363,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/58,https://github.com/hyperledger/sawtooth-pbft/pull/58,"I think we don't need to unwrap here, could just use `?`.",611dc3b2754c9ef19e18478a42903f9e2cd0bad4,2018-12-10 18:34:45,240329587,"@@ -131,131 +118,89 @@ impl PbftLog {
     ///  + A `PrePrepare` message matching the original message (in the current view)
     ///  + `2f + 1` matching `Prepare` messages from different nodes that match
     ///    `PrePrepare` message above (including its own)
-    pub fn check_prepared(&self, pbft_message: &ParsedMessage, f: u64) -> Result<(), PbftError> {
-        if check_msg_has_type(pbft_message, &PbftMessageType::Prepare) {
-            return Err(PbftError::NotReadyForMessage);
-        }
-        let info = pbft_message.info();
-        let block_new_msgs = self.check_log_has_one_block_new_msg(info)?;
-        let pre_prep_msgs = self.check_log_has_one_pre_prepared_msg(info)?;
-        self.check_log_prepare_msgs_match(&block_new_msgs, &pre_prep_msgs, info)?;
-
-        self.check_msg_against_log(&pbft_message, true, 2 * f + 1)?;
+    pub fn check_prepared(&self, info: &PbftMessageInfo, f: u64) -> Result<bool, PbftError> {
+        // Check if we have both BlockNew and PrePrepare
+        let block_new_msg = self.get_one_msg(info, &PbftMessageType::BlockNew);
+        let preprep_msg = self.get_one_msg(info, &PbftMessageType::PrePrepare);
 
-        Ok(())
-    }
-
-    fn check_log_has_one_block_new_msg(
-        &self,
-        info: &PbftMessageInfo,
-    ) -> Result<Vec<&ParsedMessage>, PbftError> {
-        let block_new_msgs = self.get_messages_of_type(
-            &PbftMessageType::BlockNew,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        if block_new_msgs.len() != 1 {
-            Err(PbftError::WrongNumMessages(
-                PbftMessageType::BlockNew,
-                1,
-                block_new_msgs.len(),
-            ))
-        } else {
-            Ok(block_new_msgs)
+        if block_new_msg.is_none() || preprep_msg.is_none() {
+            return Ok(false);
         }
-    }
 
-    fn check_log_has_one_pre_prepared_msg(
-        &self,
-        info: &PbftMessageInfo,
-    ) -> Result<Vec<&ParsedMessage>, PbftError> {
-        let pre_prep_msgs = self.get_messages_of_type(
-            &PbftMessageType::PrePrepare,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        if pre_prep_msgs.len() != 1 {
-            Err(PbftError::WrongNumMessages(
-                PbftMessageType::PrePrepare,
-                1,
-                pre_prep_msgs.len(),
-            ))
-        } else {
-            Ok(pre_prep_msgs)
-        }
-    }
+        let block_new_msg = block_new_msg.unwrap();
+        let preprep_msg = preprep_msg.unwrap();
 
-    fn check_log_prepare_msgs_match(
-        &self,
-        block_new_msgs: &[&ParsedMessage],
-        pre_prep_msgs: &[&ParsedMessage],
-        info: &PbftMessageInfo,
-    ) -> Result<(), PbftError> {
-        let prep_msgs = self.get_messages_of_type(
-            &PbftMessageType::Prepare,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        for prep_msg in prep_msgs {
-            // Make sure the contents match
-            if (!infos_match(prep_msg.info(), &pre_prep_msgs[0].info())
-                && prep_msg.get_block() != pre_prep_msgs[0].get_block())
-                || (!infos_match(prep_msg.info(), block_new_msgs[0].info())
-                    && prep_msg.get_block() != block_new_msgs[0].get_block())
-            {
-                return Err(PbftError::MessageMismatch(PbftMessageType::Prepare));
-            }
+        // Ensure BlockNew and PrePrepare match
+        if block_new_msg.get_block() != preprep_msg.get_block() {
+            error!(
+                ""BlockNew {:?} does not match PrePrepare {:?}"",
+                block_new_msg, preprep_msg
+            );
+            return Err(PbftError::MessageMismatch(PbftMessageType::PrePrepare));
         }
-        Ok(())
+
+        // Check if we have 2f + 1 matching Prepares
+        Ok(self.log_has_required_msgs(&PbftMessageType::Prepare, &preprep_msg, true, 2 * f + 1))
     }
 
     /// Checks if the node is ready to enter the `Committing` phase based on the `PbftMessage` received
     ///
     /// `check_committable` is true if for this node:
     ///   + `check_prepared` is true
-    ///   + This node has accepted `2f + 1` `Commit` messages, including its own
-    pub fn check_committable(&self, pbft_message: &ParsedMessage, f: u64) -> Result<(), PbftError> {
-        if check_msg_has_type(pbft_message, &PbftMessageType::Commit) {
-            return Err(PbftError::NotReadyForMessage);
+    ///   + This node has accepted `2f + 1` `Commit` messages, including its own, that match the
+    ///     corresponding `PrePrepare` message
+    pub fn check_committable(&self, info: &PbftMessageInfo, f: u64) -> Result<bool, PbftError> {
+        // Check if Prepared predicate is true
+        if !self.check_prepared(info, f)? {
+            return Ok(false);
         }
-        self.check_msg_against_log(&pbft_message, true, 2 * f + 1)?;
 
-        self.check_prepared(&pbft_message.as_msg_type(PbftMessageType::Prepare), f)?;
-        Ok(())
+        // Check if we have 2f + 1 matching Commits
+        let preprep_msg = self
+            .get_one_msg(info, &PbftMessageType::PrePrepare)
+            .unwrap();",172,2018-12-10 23:09:11,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240329587,https://github.com/hyperledger/sawtooth-pbft/pull/58#discussion_r240329587,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/58,https://github.com/hyperledger/sawtooth-pbft/pull/58,"This is potato/potato, but I am generally not a fan of the free-floating tiny functions that we've got in places, particularly when we have a tiny function that's used in exactly one place (e.g. a lot of stuff over in handlers.rs). We could write this as this, as long as we're modifying `num_unique_signers` anyways:

```rust
let unique_signers: HashSet<_> = msgs
    .iter()
    .filter_map(|m| if !check_block || m.get_block() == ref_msg.get_block() {
        Ok(m.info().get_signer_id().clone())
    } else {
        None
    })
    .collect();

unique_signers.len() >= required
```

Which at least for me means I don't have to jump away from the code that I'm reading to figure out how that's calculated",611dc3b2754c9ef19e18478a42903f9e2cd0bad4,2018-12-10 18:49:24,240334647,"@@ -131,131 +118,89 @@ impl PbftLog {
     ///  + A `PrePrepare` message matching the original message (in the current view)
     ///  + `2f + 1` matching `Prepare` messages from different nodes that match
     ///    `PrePrepare` message above (including its own)
-    pub fn check_prepared(&self, pbft_message: &ParsedMessage, f: u64) -> Result<(), PbftError> {
-        if check_msg_has_type(pbft_message, &PbftMessageType::Prepare) {
-            return Err(PbftError::NotReadyForMessage);
-        }
-        let info = pbft_message.info();
-        let block_new_msgs = self.check_log_has_one_block_new_msg(info)?;
-        let pre_prep_msgs = self.check_log_has_one_pre_prepared_msg(info)?;
-        self.check_log_prepare_msgs_match(&block_new_msgs, &pre_prep_msgs, info)?;
-
-        self.check_msg_against_log(&pbft_message, true, 2 * f + 1)?;
+    pub fn check_prepared(&self, info: &PbftMessageInfo, f: u64) -> Result<bool, PbftError> {
+        // Check if we have both BlockNew and PrePrepare
+        let block_new_msg = self.get_one_msg(info, &PbftMessageType::BlockNew);
+        let preprep_msg = self.get_one_msg(info, &PbftMessageType::PrePrepare);
 
-        Ok(())
-    }
-
-    fn check_log_has_one_block_new_msg(
-        &self,
-        info: &PbftMessageInfo,
-    ) -> Result<Vec<&ParsedMessage>, PbftError> {
-        let block_new_msgs = self.get_messages_of_type(
-            &PbftMessageType::BlockNew,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        if block_new_msgs.len() != 1 {
-            Err(PbftError::WrongNumMessages(
-                PbftMessageType::BlockNew,
-                1,
-                block_new_msgs.len(),
-            ))
-        } else {
-            Ok(block_new_msgs)
+        if block_new_msg.is_none() || preprep_msg.is_none() {
+            return Ok(false);
         }
-    }
 
-    fn check_log_has_one_pre_prepared_msg(
-        &self,
-        info: &PbftMessageInfo,
-    ) -> Result<Vec<&ParsedMessage>, PbftError> {
-        let pre_prep_msgs = self.get_messages_of_type(
-            &PbftMessageType::PrePrepare,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        if pre_prep_msgs.len() != 1 {
-            Err(PbftError::WrongNumMessages(
-                PbftMessageType::PrePrepare,
-                1,
-                pre_prep_msgs.len(),
-            ))
-        } else {
-            Ok(pre_prep_msgs)
-        }
-    }
+        let block_new_msg = block_new_msg.unwrap();
+        let preprep_msg = preprep_msg.unwrap();
 
-    fn check_log_prepare_msgs_match(
-        &self,
-        block_new_msgs: &[&ParsedMessage],
-        pre_prep_msgs: &[&ParsedMessage],
-        info: &PbftMessageInfo,
-    ) -> Result<(), PbftError> {
-        let prep_msgs = self.get_messages_of_type(
-            &PbftMessageType::Prepare,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        for prep_msg in prep_msgs {
-            // Make sure the contents match
-            if (!infos_match(prep_msg.info(), &pre_prep_msgs[0].info())
-                && prep_msg.get_block() != pre_prep_msgs[0].get_block())
-                || (!infos_match(prep_msg.info(), block_new_msgs[0].info())
-                    && prep_msg.get_block() != block_new_msgs[0].get_block())
-            {
-                return Err(PbftError::MessageMismatch(PbftMessageType::Prepare));
-            }
+        // Ensure BlockNew and PrePrepare match
+        if block_new_msg.get_block() != preprep_msg.get_block() {
+            error!(
+                ""BlockNew {:?} does not match PrePrepare {:?}"",
+                block_new_msg, preprep_msg
+            );
+            return Err(PbftError::MessageMismatch(PbftMessageType::PrePrepare));
         }
-        Ok(())
+
+        // Check if we have 2f + 1 matching Prepares
+        Ok(self.log_has_required_msgs(&PbftMessageType::Prepare, &preprep_msg, true, 2 * f + 1))
     }
 
     /// Checks if the node is ready to enter the `Committing` phase based on the `PbftMessage` received
     ///
     /// `check_committable` is true if for this node:
     ///   + `check_prepared` is true
-    ///   + This node has accepted `2f + 1` `Commit` messages, including its own
-    pub fn check_committable(&self, pbft_message: &ParsedMessage, f: u64) -> Result<(), PbftError> {
-        if check_msg_has_type(pbft_message, &PbftMessageType::Commit) {
-            return Err(PbftError::NotReadyForMessage);
+    ///   + This node has accepted `2f + 1` `Commit` messages, including its own, that match the
+    ///     corresponding `PrePrepare` message
+    pub fn check_committable(&self, info: &PbftMessageInfo, f: u64) -> Result<bool, PbftError> {
+        // Check if Prepared predicate is true
+        if !self.check_prepared(info, f)? {
+            return Ok(false);
         }
-        self.check_msg_against_log(&pbft_message, true, 2 * f + 1)?;
 
-        self.check_prepared(&pbft_message.as_msg_type(PbftMessageType::Prepare), f)?;
-        Ok(())
+        // Check if we have 2f + 1 matching Commits
+        let preprep_msg = self
+            .get_one_msg(info, &PbftMessageType::PrePrepare)
+            .unwrap();
+        Ok(self.log_has_required_msgs(&PbftMessageType::Commit, &preprep_msg, true, 2 * f + 1))
     }
 
-    /// Check an incoming message against its counterparts in the message log
-    pub fn check_msg_against_log(
+    /// Get one message matching the type, view number, and sequence number
+    fn get_one_msg(
         &self,
-        message: &ParsedMessage,
-        check_match: bool,
-        num_cutoff: u64,
-    ) -> Result<(), PbftError> {
-        let info = message.info();
-        let msg_type = PbftMessageType::from(info.get_msg_type());
-
-        let msg_infos: Vec<&PbftMessageInfo> =
-            self.get_message_infos(&msg_type, info.get_seq_num(), info.get_view());
-
-        let num_cp_msgs = num_unique_signers(&msg_infos);
-        if num_cp_msgs < num_cutoff {
-            return Err(PbftError::WrongNumMessages(
-                msg_type,
-                num_cutoff as usize,
-                num_cp_msgs as usize,
-            ));
+        info: &PbftMessageInfo,
+        msg_type: &PbftMessageType,
+    ) -> Option<&ParsedMessage> {
+        let msgs = self.get_messages_of_type(msg_type, info.get_seq_num(), info.get_view());
+        if msgs.is_empty() {
+            None
+        } else {
+            Some(msgs[0])
         }
+    }
 
-        if check_match {
-            let non_matches: usize = msg_infos
-                .iter()
-                .filter(|&m| !infos_match(message.info(), m))
-                .count();
-            if non_matches > 0 {
-                return Err(PbftError::MessageMismatch(msg_type));
-            }
-        }
-        Ok(())
+    /// Check if the log contains `required` number of messages with type `msg_type` that match the
+    /// sequence and view number of the provided `ref_msg`, as well as its block (optional)
+    pub fn log_has_required_msgs(
+        &self,
+        msg_type: &PbftMessageType,
+        ref_msg: &ParsedMessage,
+        check_block: bool,
+        required: u64,
+    ) -> bool {
+        let msgs = self.get_messages_of_type(
+            msg_type,
+            ref_msg.info().get_seq_num(),
+            ref_msg.info().get_view(),
+        );
+
+        let msgs = if check_block {
+            msgs.iter()
+                .filter(|msg| msg.get_block() == ref_msg.get_block())
+                .cloned()
+                .collect()
+        } else {
+            msgs
+        };
+
+        num_unique_signers(msgs) >= required",,2018-12-10 23:09:11,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240334647,https://github.com/hyperledger/sawtooth-pbft/pull/58#discussion_r240334647,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/58,https://github.com/hyperledger/sawtooth-pbft/pull/58,"We might want to handle no vs tentative working block differently here, I can see the error message below being confusing if the state was a tentative working block.",611dc3b2754c9ef19e18478a42903f9e2cd0bad4,2018-12-10 21:16:26,240383077,"@@ -754,32 +760,33 @@ impl PbftNode {
     /// This message arrives after `check_blocks` is called, signifying that the validator has
     /// successfully checked a block with this `BlockId`.
     /// Once a `BlockValid` is received, transition to committing blocks.
+    #[allow(clippy::ptr_arg)]
     pub fn on_block_valid(
         &mut self,
-        block_id: BlockId,
+        block_id: &BlockId,
         state: &mut PbftState,
     ) -> Result<(), PbftError> {
         debug!(""{}: <<<<<< BlockValid: {:?}"", state, block_id);
-        state.switch_phase(PbftPhase::Committing);
-
-        debug!(""{}: Getting blocks"", state);
-        let valid_blocks: Vec<Block> = self
-            .service
-            .get_blocks(vec![block_id])
-            .unwrap_or_default()
-            .into_iter()
-            .map(|(_block_id, block)| block)
-            .collect();
-
-        if valid_blocks.is_empty() {
-            return Err(PbftError::WrongNumBlocks);
-        }
+        let block = match state.working_block {
+            WorkingBlockOption::WorkingBlock(ref block) => {
+                if &BlockId::from(block.get_block_id()) == block_id {
+                    Ok(block.clone())
+                } else {
+                    warn!(""Got BlockValid that doesn't match the working block"");
+                    Err(PbftError::NotReadyForMessage)
+                }
+            }
+            _ => {",117,2018-12-10 23:09:11,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240383077,https://github.com/hyperledger/sawtooth-pbft/pull/58#discussion_r240383077,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/58,https://github.com/hyperledger/sawtooth-pbft/pull/58,"I think we could replace this with a call to `.first().cloned()`, instead of manually indexing into it",611dc3b2754c9ef19e18478a42903f9e2cd0bad4,2018-12-10 21:28:25,240387085,"@@ -131,131 +118,89 @@ impl PbftLog {
     ///  + A `PrePrepare` message matching the original message (in the current view)
     ///  + `2f + 1` matching `Prepare` messages from different nodes that match
     ///    `PrePrepare` message above (including its own)
-    pub fn check_prepared(&self, pbft_message: &ParsedMessage, f: u64) -> Result<(), PbftError> {
-        if check_msg_has_type(pbft_message, &PbftMessageType::Prepare) {
-            return Err(PbftError::NotReadyForMessage);
-        }
-        let info = pbft_message.info();
-        let block_new_msgs = self.check_log_has_one_block_new_msg(info)?;
-        let pre_prep_msgs = self.check_log_has_one_pre_prepared_msg(info)?;
-        self.check_log_prepare_msgs_match(&block_new_msgs, &pre_prep_msgs, info)?;
-
-        self.check_msg_against_log(&pbft_message, true, 2 * f + 1)?;
+    pub fn check_prepared(&self, info: &PbftMessageInfo, f: u64) -> Result<bool, PbftError> {
+        // Check if we have both BlockNew and PrePrepare
+        let block_new_msg = self.get_one_msg(info, &PbftMessageType::BlockNew);
+        let preprep_msg = self.get_one_msg(info, &PbftMessageType::PrePrepare);
 
-        Ok(())
-    }
-
-    fn check_log_has_one_block_new_msg(
-        &self,
-        info: &PbftMessageInfo,
-    ) -> Result<Vec<&ParsedMessage>, PbftError> {
-        let block_new_msgs = self.get_messages_of_type(
-            &PbftMessageType::BlockNew,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        if block_new_msgs.len() != 1 {
-            Err(PbftError::WrongNumMessages(
-                PbftMessageType::BlockNew,
-                1,
-                block_new_msgs.len(),
-            ))
-        } else {
-            Ok(block_new_msgs)
+        if block_new_msg.is_none() || preprep_msg.is_none() {
+            return Ok(false);
         }
-    }
 
-    fn check_log_has_one_pre_prepared_msg(
-        &self,
-        info: &PbftMessageInfo,
-    ) -> Result<Vec<&ParsedMessage>, PbftError> {
-        let pre_prep_msgs = self.get_messages_of_type(
-            &PbftMessageType::PrePrepare,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        if pre_prep_msgs.len() != 1 {
-            Err(PbftError::WrongNumMessages(
-                PbftMessageType::PrePrepare,
-                1,
-                pre_prep_msgs.len(),
-            ))
-        } else {
-            Ok(pre_prep_msgs)
-        }
-    }
+        let block_new_msg = block_new_msg.unwrap();
+        let preprep_msg = preprep_msg.unwrap();
 
-    fn check_log_prepare_msgs_match(
-        &self,
-        block_new_msgs: &[&ParsedMessage],
-        pre_prep_msgs: &[&ParsedMessage],
-        info: &PbftMessageInfo,
-    ) -> Result<(), PbftError> {
-        let prep_msgs = self.get_messages_of_type(
-            &PbftMessageType::Prepare,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        for prep_msg in prep_msgs {
-            // Make sure the contents match
-            if (!infos_match(prep_msg.info(), &pre_prep_msgs[0].info())
-                && prep_msg.get_block() != pre_prep_msgs[0].get_block())
-                || (!infos_match(prep_msg.info(), block_new_msgs[0].info())
-                    && prep_msg.get_block() != block_new_msgs[0].get_block())
-            {
-                return Err(PbftError::MessageMismatch(PbftMessageType::Prepare));
-            }
+        // Ensure BlockNew and PrePrepare match
+        if block_new_msg.get_block() != preprep_msg.get_block() {
+            error!(
+                ""BlockNew {:?} does not match PrePrepare {:?}"",
+                block_new_msg, preprep_msg
+            );
+            return Err(PbftError::MessageMismatch(PbftMessageType::PrePrepare));
         }
-        Ok(())
+
+        // Check if we have 2f + 1 matching Prepares
+        Ok(self.log_has_required_msgs(&PbftMessageType::Prepare, &preprep_msg, true, 2 * f + 1))
     }
 
     /// Checks if the node is ready to enter the `Committing` phase based on the `PbftMessage` received
     ///
     /// `check_committable` is true if for this node:
     ///   + `check_prepared` is true
-    ///   + This node has accepted `2f + 1` `Commit` messages, including its own
-    pub fn check_committable(&self, pbft_message: &ParsedMessage, f: u64) -> Result<(), PbftError> {
-        if check_msg_has_type(pbft_message, &PbftMessageType::Commit) {
-            return Err(PbftError::NotReadyForMessage);
+    ///   + This node has accepted `2f + 1` `Commit` messages, including its own, that match the
+    ///     corresponding `PrePrepare` message
+    pub fn check_committable(&self, info: &PbftMessageInfo, f: u64) -> Result<bool, PbftError> {
+        // Check if Prepared predicate is true
+        if !self.check_prepared(info, f)? {
+            return Ok(false);
         }
-        self.check_msg_against_log(&pbft_message, true, 2 * f + 1)?;
 
-        self.check_prepared(&pbft_message.as_msg_type(PbftMessageType::Prepare), f)?;
-        Ok(())
+        // Check if we have 2f + 1 matching Commits
+        let preprep_msg = self
+            .get_one_msg(info, &PbftMessageType::PrePrepare)
+            .unwrap();
+        Ok(self.log_has_required_msgs(&PbftMessageType::Commit, &preprep_msg, true, 2 * f + 1))
     }
 
-    /// Check an incoming message against its counterparts in the message log
-    pub fn check_msg_against_log(
+    /// Get one message matching the type, view number, and sequence number
+    fn get_one_msg(
         &self,
-        message: &ParsedMessage,
-        check_match: bool,
-        num_cutoff: u64,
-    ) -> Result<(), PbftError> {
-        let info = message.info();
-        let msg_type = PbftMessageType::from(info.get_msg_type());
-
-        let msg_infos: Vec<&PbftMessageInfo> =
-            self.get_message_infos(&msg_type, info.get_seq_num(), info.get_view());
-
-        let num_cp_msgs = num_unique_signers(&msg_infos);
-        if num_cp_msgs < num_cutoff {
-            return Err(PbftError::WrongNumMessages(
-                msg_type,
-                num_cutoff as usize,
-                num_cp_msgs as usize,
-            ));
+        info: &PbftMessageInfo,
+        msg_type: &PbftMessageType,
+    ) -> Option<&ParsedMessage> {
+        let msgs = self.get_messages_of_type(msg_type, info.get_seq_num(), info.get_view());
+        if msgs.is_empty() {
+            None
+        } else {
+            Some(msgs[0])",,2018-12-10 23:09:11,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240387085,https://github.com/hyperledger/sawtooth-pbft/pull/58#discussion_r240387085,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/58,https://github.com/hyperledger/sawtooth-pbft/pull/58,"`get_one_msg` returns an `Option`, which you can't use a `?` for. And `unwrap` is safe here; we know this message exists because `check_preprepared` requires it.",611dc3b2754c9ef19e18478a42903f9e2cd0bad4,2018-12-10 23:10:18,240417338,"@@ -131,131 +118,89 @@ impl PbftLog {
     ///  + A `PrePrepare` message matching the original message (in the current view)
     ///  + `2f + 1` matching `Prepare` messages from different nodes that match
     ///    `PrePrepare` message above (including its own)
-    pub fn check_prepared(&self, pbft_message: &ParsedMessage, f: u64) -> Result<(), PbftError> {
-        if check_msg_has_type(pbft_message, &PbftMessageType::Prepare) {
-            return Err(PbftError::NotReadyForMessage);
-        }
-        let info = pbft_message.info();
-        let block_new_msgs = self.check_log_has_one_block_new_msg(info)?;
-        let pre_prep_msgs = self.check_log_has_one_pre_prepared_msg(info)?;
-        self.check_log_prepare_msgs_match(&block_new_msgs, &pre_prep_msgs, info)?;
-
-        self.check_msg_against_log(&pbft_message, true, 2 * f + 1)?;
+    pub fn check_prepared(&self, info: &PbftMessageInfo, f: u64) -> Result<bool, PbftError> {
+        // Check if we have both BlockNew and PrePrepare
+        let block_new_msg = self.get_one_msg(info, &PbftMessageType::BlockNew);
+        let preprep_msg = self.get_one_msg(info, &PbftMessageType::PrePrepare);
 
-        Ok(())
-    }
-
-    fn check_log_has_one_block_new_msg(
-        &self,
-        info: &PbftMessageInfo,
-    ) -> Result<Vec<&ParsedMessage>, PbftError> {
-        let block_new_msgs = self.get_messages_of_type(
-            &PbftMessageType::BlockNew,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        if block_new_msgs.len() != 1 {
-            Err(PbftError::WrongNumMessages(
-                PbftMessageType::BlockNew,
-                1,
-                block_new_msgs.len(),
-            ))
-        } else {
-            Ok(block_new_msgs)
+        if block_new_msg.is_none() || preprep_msg.is_none() {
+            return Ok(false);
         }
-    }
 
-    fn check_log_has_one_pre_prepared_msg(
-        &self,
-        info: &PbftMessageInfo,
-    ) -> Result<Vec<&ParsedMessage>, PbftError> {
-        let pre_prep_msgs = self.get_messages_of_type(
-            &PbftMessageType::PrePrepare,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        if pre_prep_msgs.len() != 1 {
-            Err(PbftError::WrongNumMessages(
-                PbftMessageType::PrePrepare,
-                1,
-                pre_prep_msgs.len(),
-            ))
-        } else {
-            Ok(pre_prep_msgs)
-        }
-    }
+        let block_new_msg = block_new_msg.unwrap();
+        let preprep_msg = preprep_msg.unwrap();
 
-    fn check_log_prepare_msgs_match(
-        &self,
-        block_new_msgs: &[&ParsedMessage],
-        pre_prep_msgs: &[&ParsedMessage],
-        info: &PbftMessageInfo,
-    ) -> Result<(), PbftError> {
-        let prep_msgs = self.get_messages_of_type(
-            &PbftMessageType::Prepare,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        for prep_msg in prep_msgs {
-            // Make sure the contents match
-            if (!infos_match(prep_msg.info(), &pre_prep_msgs[0].info())
-                && prep_msg.get_block() != pre_prep_msgs[0].get_block())
-                || (!infos_match(prep_msg.info(), block_new_msgs[0].info())
-                    && prep_msg.get_block() != block_new_msgs[0].get_block())
-            {
-                return Err(PbftError::MessageMismatch(PbftMessageType::Prepare));
-            }
+        // Ensure BlockNew and PrePrepare match
+        if block_new_msg.get_block() != preprep_msg.get_block() {
+            error!(
+                ""BlockNew {:?} does not match PrePrepare {:?}"",
+                block_new_msg, preprep_msg
+            );
+            return Err(PbftError::MessageMismatch(PbftMessageType::PrePrepare));
         }
-        Ok(())
+
+        // Check if we have 2f + 1 matching Prepares
+        Ok(self.log_has_required_msgs(&PbftMessageType::Prepare, &preprep_msg, true, 2 * f + 1))
     }
 
     /// Checks if the node is ready to enter the `Committing` phase based on the `PbftMessage` received
     ///
     /// `check_committable` is true if for this node:
     ///   + `check_prepared` is true
-    ///   + This node has accepted `2f + 1` `Commit` messages, including its own
-    pub fn check_committable(&self, pbft_message: &ParsedMessage, f: u64) -> Result<(), PbftError> {
-        if check_msg_has_type(pbft_message, &PbftMessageType::Commit) {
-            return Err(PbftError::NotReadyForMessage);
+    ///   + This node has accepted `2f + 1` `Commit` messages, including its own, that match the
+    ///     corresponding `PrePrepare` message
+    pub fn check_committable(&self, info: &PbftMessageInfo, f: u64) -> Result<bool, PbftError> {
+        // Check if Prepared predicate is true
+        if !self.check_prepared(info, f)? {
+            return Ok(false);
         }
-        self.check_msg_against_log(&pbft_message, true, 2 * f + 1)?;
 
-        self.check_prepared(&pbft_message.as_msg_type(PbftMessageType::Prepare), f)?;
-        Ok(())
+        // Check if we have 2f + 1 matching Commits
+        let preprep_msg = self
+            .get_one_msg(info, &PbftMessageType::PrePrepare)
+            .unwrap();",172,2018-12-10 23:10:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240417338,https://github.com/hyperledger/sawtooth-pbft/pull/58#discussion_r240417338,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/58,https://github.com/hyperledger/sawtooth-pbft/pull/58,"I agree with this and have been eliminating these kinds of functions as I've been improving things. I actually just removed the function altogether. The log doesn't allow duplicates, and at this point we only have blocks that match the sequence, view, type, and block; that means the only variable between these messages will be the signer id, and since there are no duplicates, all of these messages are from unique signers.",611dc3b2754c9ef19e18478a42903f9e2cd0bad4,2018-12-10 23:12:02,240417759,"@@ -131,131 +118,89 @@ impl PbftLog {
     ///  + A `PrePrepare` message matching the original message (in the current view)
     ///  + `2f + 1` matching `Prepare` messages from different nodes that match
     ///    `PrePrepare` message above (including its own)
-    pub fn check_prepared(&self, pbft_message: &ParsedMessage, f: u64) -> Result<(), PbftError> {
-        if check_msg_has_type(pbft_message, &PbftMessageType::Prepare) {
-            return Err(PbftError::NotReadyForMessage);
-        }
-        let info = pbft_message.info();
-        let block_new_msgs = self.check_log_has_one_block_new_msg(info)?;
-        let pre_prep_msgs = self.check_log_has_one_pre_prepared_msg(info)?;
-        self.check_log_prepare_msgs_match(&block_new_msgs, &pre_prep_msgs, info)?;
-
-        self.check_msg_against_log(&pbft_message, true, 2 * f + 1)?;
+    pub fn check_prepared(&self, info: &PbftMessageInfo, f: u64) -> Result<bool, PbftError> {
+        // Check if we have both BlockNew and PrePrepare
+        let block_new_msg = self.get_one_msg(info, &PbftMessageType::BlockNew);
+        let preprep_msg = self.get_one_msg(info, &PbftMessageType::PrePrepare);
 
-        Ok(())
-    }
-
-    fn check_log_has_one_block_new_msg(
-        &self,
-        info: &PbftMessageInfo,
-    ) -> Result<Vec<&ParsedMessage>, PbftError> {
-        let block_new_msgs = self.get_messages_of_type(
-            &PbftMessageType::BlockNew,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        if block_new_msgs.len() != 1 {
-            Err(PbftError::WrongNumMessages(
-                PbftMessageType::BlockNew,
-                1,
-                block_new_msgs.len(),
-            ))
-        } else {
-            Ok(block_new_msgs)
+        if block_new_msg.is_none() || preprep_msg.is_none() {
+            return Ok(false);
         }
-    }
 
-    fn check_log_has_one_pre_prepared_msg(
-        &self,
-        info: &PbftMessageInfo,
-    ) -> Result<Vec<&ParsedMessage>, PbftError> {
-        let pre_prep_msgs = self.get_messages_of_type(
-            &PbftMessageType::PrePrepare,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        if pre_prep_msgs.len() != 1 {
-            Err(PbftError::WrongNumMessages(
-                PbftMessageType::PrePrepare,
-                1,
-                pre_prep_msgs.len(),
-            ))
-        } else {
-            Ok(pre_prep_msgs)
-        }
-    }
+        let block_new_msg = block_new_msg.unwrap();
+        let preprep_msg = preprep_msg.unwrap();
 
-    fn check_log_prepare_msgs_match(
-        &self,
-        block_new_msgs: &[&ParsedMessage],
-        pre_prep_msgs: &[&ParsedMessage],
-        info: &PbftMessageInfo,
-    ) -> Result<(), PbftError> {
-        let prep_msgs = self.get_messages_of_type(
-            &PbftMessageType::Prepare,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        for prep_msg in prep_msgs {
-            // Make sure the contents match
-            if (!infos_match(prep_msg.info(), &pre_prep_msgs[0].info())
-                && prep_msg.get_block() != pre_prep_msgs[0].get_block())
-                || (!infos_match(prep_msg.info(), block_new_msgs[0].info())
-                    && prep_msg.get_block() != block_new_msgs[0].get_block())
-            {
-                return Err(PbftError::MessageMismatch(PbftMessageType::Prepare));
-            }
+        // Ensure BlockNew and PrePrepare match
+        if block_new_msg.get_block() != preprep_msg.get_block() {
+            error!(
+                ""BlockNew {:?} does not match PrePrepare {:?}"",
+                block_new_msg, preprep_msg
+            );
+            return Err(PbftError::MessageMismatch(PbftMessageType::PrePrepare));
         }
-        Ok(())
+
+        // Check if we have 2f + 1 matching Prepares
+        Ok(self.log_has_required_msgs(&PbftMessageType::Prepare, &preprep_msg, true, 2 * f + 1))
     }
 
     /// Checks if the node is ready to enter the `Committing` phase based on the `PbftMessage` received
     ///
     /// `check_committable` is true if for this node:
     ///   + `check_prepared` is true
-    ///   + This node has accepted `2f + 1` `Commit` messages, including its own
-    pub fn check_committable(&self, pbft_message: &ParsedMessage, f: u64) -> Result<(), PbftError> {
-        if check_msg_has_type(pbft_message, &PbftMessageType::Commit) {
-            return Err(PbftError::NotReadyForMessage);
+    ///   + This node has accepted `2f + 1` `Commit` messages, including its own, that match the
+    ///     corresponding `PrePrepare` message
+    pub fn check_committable(&self, info: &PbftMessageInfo, f: u64) -> Result<bool, PbftError> {
+        // Check if Prepared predicate is true
+        if !self.check_prepared(info, f)? {
+            return Ok(false);
         }
-        self.check_msg_against_log(&pbft_message, true, 2 * f + 1)?;
 
-        self.check_prepared(&pbft_message.as_msg_type(PbftMessageType::Prepare), f)?;
-        Ok(())
+        // Check if we have 2f + 1 matching Commits
+        let preprep_msg = self
+            .get_one_msg(info, &PbftMessageType::PrePrepare)
+            .unwrap();
+        Ok(self.log_has_required_msgs(&PbftMessageType::Commit, &preprep_msg, true, 2 * f + 1))
     }
 
-    /// Check an incoming message against its counterparts in the message log
-    pub fn check_msg_against_log(
+    /// Get one message matching the type, view number, and sequence number
+    fn get_one_msg(
         &self,
-        message: &ParsedMessage,
-        check_match: bool,
-        num_cutoff: u64,
-    ) -> Result<(), PbftError> {
-        let info = message.info();
-        let msg_type = PbftMessageType::from(info.get_msg_type());
-
-        let msg_infos: Vec<&PbftMessageInfo> =
-            self.get_message_infos(&msg_type, info.get_seq_num(), info.get_view());
-
-        let num_cp_msgs = num_unique_signers(&msg_infos);
-        if num_cp_msgs < num_cutoff {
-            return Err(PbftError::WrongNumMessages(
-                msg_type,
-                num_cutoff as usize,
-                num_cp_msgs as usize,
-            ));
+        info: &PbftMessageInfo,
+        msg_type: &PbftMessageType,
+    ) -> Option<&ParsedMessage> {
+        let msgs = self.get_messages_of_type(msg_type, info.get_seq_num(), info.get_view());
+        if msgs.is_empty() {
+            None
+        } else {
+            Some(msgs[0])
         }
+    }
 
-        if check_match {
-            let non_matches: usize = msg_infos
-                .iter()
-                .filter(|&m| !infos_match(message.info(), m))
-                .count();
-            if non_matches > 0 {
-                return Err(PbftError::MessageMismatch(msg_type));
-            }
-        }
-        Ok(())
+    /// Check if the log contains `required` number of messages with type `msg_type` that match the
+    /// sequence and view number of the provided `ref_msg`, as well as its block (optional)
+    pub fn log_has_required_msgs(
+        &self,
+        msg_type: &PbftMessageType,
+        ref_msg: &ParsedMessage,
+        check_block: bool,
+        required: u64,
+    ) -> bool {
+        let msgs = self.get_messages_of_type(
+            msg_type,
+            ref_msg.info().get_seq_num(),
+            ref_msg.info().get_view(),
+        );
+
+        let msgs = if check_block {
+            msgs.iter()
+                .filter(|msg| msg.get_block() == ref_msg.get_block())
+                .cloned()
+                .collect()
+        } else {
+            msgs
+        };
+
+        num_unique_signers(msgs) >= required",,2018-12-10 23:12:02,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240417759,https://github.com/hyperledger/sawtooth-pbft/pull/58#discussion_r240417759,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/58,https://github.com/hyperledger/sawtooth-pbft/pull/58,Added a different log message for tentative working blocks,611dc3b2754c9ef19e18478a42903f9e2cd0bad4,2018-12-10 23:12:35,240417924,"@@ -754,32 +760,33 @@ impl PbftNode {
     /// This message arrives after `check_blocks` is called, signifying that the validator has
     /// successfully checked a block with this `BlockId`.
     /// Once a `BlockValid` is received, transition to committing blocks.
+    #[allow(clippy::ptr_arg)]
     pub fn on_block_valid(
         &mut self,
-        block_id: BlockId,
+        block_id: &BlockId,
         state: &mut PbftState,
     ) -> Result<(), PbftError> {
         debug!(""{}: <<<<<< BlockValid: {:?}"", state, block_id);
-        state.switch_phase(PbftPhase::Committing);
-
-        debug!(""{}: Getting blocks"", state);
-        let valid_blocks: Vec<Block> = self
-            .service
-            .get_blocks(vec![block_id])
-            .unwrap_or_default()
-            .into_iter()
-            .map(|(_block_id, block)| block)
-            .collect();
-
-        if valid_blocks.is_empty() {
-            return Err(PbftError::WrongNumBlocks);
-        }
+        let block = match state.working_block {
+            WorkingBlockOption::WorkingBlock(ref block) => {
+                if &BlockId::from(block.get_block_id()) == block_id {
+                    Ok(block.clone())
+                } else {
+                    warn!(""Got BlockValid that doesn't match the working block"");
+                    Err(PbftError::NotReadyForMessage)
+                }
+            }
+            _ => {",117,2018-12-10 23:12:35,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240417924,https://github.com/hyperledger/sawtooth-pbft/pull/58#discussion_r240417924,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/58,https://github.com/hyperledger/sawtooth-pbft/pull/58,Nice and elegant. Thanks!,611dc3b2754c9ef19e18478a42903f9e2cd0bad4,2018-12-10 23:12:49,240417985,"@@ -131,131 +118,89 @@ impl PbftLog {
     ///  + A `PrePrepare` message matching the original message (in the current view)
     ///  + `2f + 1` matching `Prepare` messages from different nodes that match
     ///    `PrePrepare` message above (including its own)
-    pub fn check_prepared(&self, pbft_message: &ParsedMessage, f: u64) -> Result<(), PbftError> {
-        if check_msg_has_type(pbft_message, &PbftMessageType::Prepare) {
-            return Err(PbftError::NotReadyForMessage);
-        }
-        let info = pbft_message.info();
-        let block_new_msgs = self.check_log_has_one_block_new_msg(info)?;
-        let pre_prep_msgs = self.check_log_has_one_pre_prepared_msg(info)?;
-        self.check_log_prepare_msgs_match(&block_new_msgs, &pre_prep_msgs, info)?;
-
-        self.check_msg_against_log(&pbft_message, true, 2 * f + 1)?;
+    pub fn check_prepared(&self, info: &PbftMessageInfo, f: u64) -> Result<bool, PbftError> {
+        // Check if we have both BlockNew and PrePrepare
+        let block_new_msg = self.get_one_msg(info, &PbftMessageType::BlockNew);
+        let preprep_msg = self.get_one_msg(info, &PbftMessageType::PrePrepare);
 
-        Ok(())
-    }
-
-    fn check_log_has_one_block_new_msg(
-        &self,
-        info: &PbftMessageInfo,
-    ) -> Result<Vec<&ParsedMessage>, PbftError> {
-        let block_new_msgs = self.get_messages_of_type(
-            &PbftMessageType::BlockNew,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        if block_new_msgs.len() != 1 {
-            Err(PbftError::WrongNumMessages(
-                PbftMessageType::BlockNew,
-                1,
-                block_new_msgs.len(),
-            ))
-        } else {
-            Ok(block_new_msgs)
+        if block_new_msg.is_none() || preprep_msg.is_none() {
+            return Ok(false);
         }
-    }
 
-    fn check_log_has_one_pre_prepared_msg(
-        &self,
-        info: &PbftMessageInfo,
-    ) -> Result<Vec<&ParsedMessage>, PbftError> {
-        let pre_prep_msgs = self.get_messages_of_type(
-            &PbftMessageType::PrePrepare,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        if pre_prep_msgs.len() != 1 {
-            Err(PbftError::WrongNumMessages(
-                PbftMessageType::PrePrepare,
-                1,
-                pre_prep_msgs.len(),
-            ))
-        } else {
-            Ok(pre_prep_msgs)
-        }
-    }
+        let block_new_msg = block_new_msg.unwrap();
+        let preprep_msg = preprep_msg.unwrap();
 
-    fn check_log_prepare_msgs_match(
-        &self,
-        block_new_msgs: &[&ParsedMessage],
-        pre_prep_msgs: &[&ParsedMessage],
-        info: &PbftMessageInfo,
-    ) -> Result<(), PbftError> {
-        let prep_msgs = self.get_messages_of_type(
-            &PbftMessageType::Prepare,
-            info.get_seq_num(),
-            info.get_view(),
-        );
-        for prep_msg in prep_msgs {
-            // Make sure the contents match
-            if (!infos_match(prep_msg.info(), &pre_prep_msgs[0].info())
-                && prep_msg.get_block() != pre_prep_msgs[0].get_block())
-                || (!infos_match(prep_msg.info(), block_new_msgs[0].info())
-                    && prep_msg.get_block() != block_new_msgs[0].get_block())
-            {
-                return Err(PbftError::MessageMismatch(PbftMessageType::Prepare));
-            }
+        // Ensure BlockNew and PrePrepare match
+        if block_new_msg.get_block() != preprep_msg.get_block() {
+            error!(
+                ""BlockNew {:?} does not match PrePrepare {:?}"",
+                block_new_msg, preprep_msg
+            );
+            return Err(PbftError::MessageMismatch(PbftMessageType::PrePrepare));
         }
-        Ok(())
+
+        // Check if we have 2f + 1 matching Prepares
+        Ok(self.log_has_required_msgs(&PbftMessageType::Prepare, &preprep_msg, true, 2 * f + 1))
     }
 
     /// Checks if the node is ready to enter the `Committing` phase based on the `PbftMessage` received
     ///
     /// `check_committable` is true if for this node:
     ///   + `check_prepared` is true
-    ///   + This node has accepted `2f + 1` `Commit` messages, including its own
-    pub fn check_committable(&self, pbft_message: &ParsedMessage, f: u64) -> Result<(), PbftError> {
-        if check_msg_has_type(pbft_message, &PbftMessageType::Commit) {
-            return Err(PbftError::NotReadyForMessage);
+    ///   + This node has accepted `2f + 1` `Commit` messages, including its own, that match the
+    ///     corresponding `PrePrepare` message
+    pub fn check_committable(&self, info: &PbftMessageInfo, f: u64) -> Result<bool, PbftError> {
+        // Check if Prepared predicate is true
+        if !self.check_prepared(info, f)? {
+            return Ok(false);
         }
-        self.check_msg_against_log(&pbft_message, true, 2 * f + 1)?;
 
-        self.check_prepared(&pbft_message.as_msg_type(PbftMessageType::Prepare), f)?;
-        Ok(())
+        // Check if we have 2f + 1 matching Commits
+        let preprep_msg = self
+            .get_one_msg(info, &PbftMessageType::PrePrepare)
+            .unwrap();
+        Ok(self.log_has_required_msgs(&PbftMessageType::Commit, &preprep_msg, true, 2 * f + 1))
     }
 
-    /// Check an incoming message against its counterparts in the message log
-    pub fn check_msg_against_log(
+    /// Get one message matching the type, view number, and sequence number
+    fn get_one_msg(
         &self,
-        message: &ParsedMessage,
-        check_match: bool,
-        num_cutoff: u64,
-    ) -> Result<(), PbftError> {
-        let info = message.info();
-        let msg_type = PbftMessageType::from(info.get_msg_type());
-
-        let msg_infos: Vec<&PbftMessageInfo> =
-            self.get_message_infos(&msg_type, info.get_seq_num(), info.get_view());
-
-        let num_cp_msgs = num_unique_signers(&msg_infos);
-        if num_cp_msgs < num_cutoff {
-            return Err(PbftError::WrongNumMessages(
-                msg_type,
-                num_cutoff as usize,
-                num_cp_msgs as usize,
-            ));
+        info: &PbftMessageInfo,
+        msg_type: &PbftMessageType,
+    ) -> Option<&ParsedMessage> {
+        let msgs = self.get_messages_of_type(msg_type, info.get_seq_num(), info.get_view());
+        if msgs.is_empty() {
+            None
+        } else {
+            Some(msgs[0])",,2018-12-10 23:12:50,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240417985,https://github.com/hyperledger/sawtooth-pbft/pull/58#discussion_r240417985,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/55,https://github.com/hyperledger/sawtooth-pbft/pull/55,Can you explain this change? This is not a logging change,ad16dacfac6bb452daec0e2fa01ff9aaf8bdff4d,2018-12-10 13:46:58,240214177,"@@ -487,11 +487,20 @@ impl PbftNode {
                 let block_id_matches = block.previous_id == wb.get_block_id();
 
                 if !block_num_matches || !block_id_matches {
-                    debug!(
-                        ""Block didn't match for catchup, skipping: {} {}"",
-                        block_num_matches, block_id_matches
-                    );
-                    return Ok(false);
+                    if block.block_num == head.block_num + 2 {
+                        debug!(
+                            ""Block didn't match for catchup, adjusting: {} {}"",
+                            block_num_matches, block_id_matches
+                        );
+                        state.working_block =",,2018-12-10 16:38:33,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240214177,https://github.com/hyperledger/sawtooth-pbft/pull/55#discussion_r240214177,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/55,https://github.com/hyperledger/sawtooth-pbft/pull/55,"@agunde406: I was testing a fix in Jenkins for something that I couldn't reproduce locally, and I was using the verbose logging in this PR to do it. The fix seems to be working, so I've pulled it out of this PR.",ad16dacfac6bb452daec0e2fa01ff9aaf8bdff4d,2018-12-10 16:40:05,240287026,"@@ -487,11 +487,20 @@ impl PbftNode {
                 let block_id_matches = block.previous_id == wb.get_block_id();
 
                 if !block_num_matches || !block_id_matches {
-                    debug!(
-                        ""Block didn't match for catchup, skipping: {} {}"",
-                        block_num_matches, block_id_matches
-                    );
-                    return Ok(false);
+                    if block.block_num == head.block_num + 2 {
+                        debug!(
+                            ""Block didn't match for catchup, adjusting: {} {}"",
+                            block_num_matches, block_id_matches
+                        );
+                        state.working_block =",,2018-12-10 16:40:06,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240287026,https://github.com/hyperledger/sawtooth-pbft/pull/55#discussion_r240287026,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/54,https://github.com/hyperledger/sawtooth-pbft/pull/54,"Can we just inline this? I don't think we need to have a function for this, and I think it's the wrong abstraction (if we really wanted it, it would be more like `state.set_working_block(message)`).",08514bd71d9566f86a386b617e1f7e5768362f72,2018-12-10 22:18:37,240403110,"@@ -28,32 +28,28 @@ use error::PbftError;
 use message_log::PbftLog;
 use message_type::ParsedMessage;
 use message_type::{PbftHint, PbftMessageType};
-use protos::pbft_message::{PbftBlock, PbftMessage, PbftMessageInfo};
+use protos::pbft_message::{PbftBlock, PbftMessageInfo};
 use state::{PbftPhase, PbftState, WorkingBlockOption};
 
 /// Handle a `PrePrepare` message
-/// A `PrePrepare` message with this view and sequence number must not already exist in the log. If
-/// this node is a primary, make sure there's a corresponding BlockNew message. If this node is a
-/// secondary, then it takes the sequence number from this message as its own.
+/// A `PrePrepare` message with this view and sequence number must not already exist in the log.
+/// Make sure there's a corresponding BlockNew message.
 pub fn pre_prepare(
     state: &mut PbftState,
     msg_log: &mut PbftLog,
     message: &ParsedMessage,
 ) -> Result<(), PbftError> {
-    let pbft_message = message.get_pbft_message();
     let info = message.info();
 
     check_view_mismatch(state, info)?;
 
     check_pre_prepare_does_not_exist(msg_log, info)?;
 
-    if state.is_primary() {
-        check_pre_prepare_matches_original_block_new(msg_log, pbft_message, info)?;
-    } else {
-        set_seq_num_and_fix_block_new_seq_num(state, msg_log, &pbft_message, info)?;
-    }
+    check_pre_prepare_matches_original_block_new(msg_log, message)?;
 
-    set_current_working_block(state, pbft_message);
+    set_current_working_block(state, message);",34,2018-12-11 19:40:25,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240403110,https://github.com/hyperledger/sawtooth-pbft/pull/54#discussion_r240403110,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/54,https://github.com/hyperledger/sawtooth-pbft/pull/54,"Is this fixing something in particular? We should already be syncing `state.seq_num` over in `BlockNew`, so it seems like this isn't necessary. We should honestly probably just move away from storing `seq_num` on `state`, and declare it to be the block number of head, though that's out of scope of this PR.",08514bd71d9566f86a386b617e1f7e5768362f72,2018-12-11 17:11:35,240706504,"@@ -47,14 +46,12 @@ pub fn pre_prepare(
 
     check_pre_prepare_does_not_exist(msg_log, info)?;
 
-    if state.is_primary() {
-        check_pre_prepare_matches_original_block_new(msg_log, pbft_message, info)?;
-    } else {
-        set_seq_num_and_fix_block_new_seq_num(state, msg_log, &pbft_message, info)?;
-    }
+    check_pre_prepare_matches_original_block_new(msg_log, pbft_message, info)?;
 
     set_current_working_block(state, pbft_message);
 
+    state.seq_num = info.get_seq_num();",36,2018-12-11 19:40:25,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240706504,https://github.com/hyperledger/sawtooth-pbft/pull/54#discussion_r240706504,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/54,https://github.com/hyperledger/sawtooth-pbft/pull/54,Do we need to check that we're not receiving a message from self here?,08514bd71d9566f86a386b617e1f7e5768362f72,2018-12-11 17:15:30,240708291,"@@ -268,6 +268,22 @@ impl PbftLog {
         }
     }
 
+    /// Obtain all messages from the log that match a given type and sequence_number
+    pub fn get_messages_of_type_seq(
+        &self,
+        msg_type: &PbftMessageType,
+        sequence_number: u64,
+    ) -> Vec<&ParsedMessage> {
+        self.messages
+            .iter()
+            .filter(|&msg| {
+                let info = (*msg).info();
+                info.get_msg_type() == String::from(msg_type)",112,2018-12-11 19:40:25,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240708291,https://github.com/hyperledger/sawtooth-pbft/pull/54#discussion_r240708291,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/54,https://github.com/hyperledger/sawtooth-pbft/pull/54,"Should we be adding this message to the backlog instead of just not adding it to the set of messages? Alternatively, we might want to return a `Result` for whether or not the message was actually added, since over in `on_peer_message` it doesn't seem like we'd want to continue processing the message if we haven't added it to the log.",08514bd71d9566f86a386b617e1f7e5768362f72,2018-12-11 18:20:38,240732967,"@@ -216,6 +217,21 @@ impl PbftLog {
             return;
         }
 
+        // Except for Checkpoints and ViewChanges, the message must be for the current view to be
+        // accepted
+        let msg_type = PbftMessageType::from(msg.info().get_msg_type());
+        if msg_type != PbftMessageType::Checkpoint
+            && msg_type != PbftMessageType::ViewChange
+            && msg.info().get_view() != state.view
+        {
+            warn!(
+                ""Not adding message with view number {}; does not match node's view: {}"",
+                msg.info().get_view(),
+                state.view,
+            );
+            return;",69,2018-12-11 19:40:25,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240732967,https://github.com/hyperledger/sawtooth-pbft/pull/54#discussion_r240732967,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/54,https://github.com/hyperledger/sawtooth-pbft/pull/54,"It's a shame we can't do optional keyword parameters here, but can we just make `view` an `Option<u64>` and call this `filter_messages` or somesuch and have it cover both cases? If we wanted to get fancy, we could make `view` an `Into<Option<u64>>`, which would let us keep the calls that include the view parameter the same.",08514bd71d9566f86a386b617e1f7e5768362f72,2018-12-11 18:32:05,240737363,"@@ -268,7 +269,7 @@ impl PbftLog {
     }
 
     /// Obtain messages from the log that match a given type, sequence number, and view
-    pub fn get_messages_of_type(
+    pub fn get_messages_of_type_seq_view(",120,2018-12-11 19:40:25,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240737363,https://github.com/hyperledger/sawtooth-pbft/pull/54#discussion_r240737363,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/54,https://github.com/hyperledger/sawtooth-pbft/pull/54,Extra space getting added here,08514bd71d9566f86a386b617e1f7e5768362f72,2018-12-11 18:33:32,240737908,"@@ -92,7 +92,7 @@ fn check_pre_prepare_matches_original_block_new(
     pbft_message: &PbftMessage,
     info: &PbftMessageInfo,
 ) -> Result<(), PbftError> {
-    let block_new_msgs = msg_log.get_messages_of_type(
+    let block_new_msgs =  msg_log.get_messages_of_type_seq_view(",,2018-12-11 19:40:25,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240737908,https://github.com/hyperledger/sawtooth-pbft/pull/54#discussion_r240737908,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/54,https://github.com/hyperledger/sawtooth-pbft/pull/54,"I have that update on a different branch, so you'll see it in another PR.",08514bd71d9566f86a386b617e1f7e5768362f72,2018-12-11 18:44:20,240741799,"@@ -28,32 +28,28 @@ use error::PbftError;
 use message_log::PbftLog;
 use message_type::ParsedMessage;
 use message_type::{PbftHint, PbftMessageType};
-use protos::pbft_message::{PbftBlock, PbftMessage, PbftMessageInfo};
+use protos::pbft_message::{PbftBlock, PbftMessageInfo};
 use state::{PbftPhase, PbftState, WorkingBlockOption};
 
 /// Handle a `PrePrepare` message
-/// A `PrePrepare` message with this view and sequence number must not already exist in the log. If
-/// this node is a primary, make sure there's a corresponding BlockNew message. If this node is a
-/// secondary, then it takes the sequence number from this message as its own.
+/// A `PrePrepare` message with this view and sequence number must not already exist in the log.
+/// Make sure there's a corresponding BlockNew message.
 pub fn pre_prepare(
     state: &mut PbftState,
     msg_log: &mut PbftLog,
     message: &ParsedMessage,
 ) -> Result<(), PbftError> {
-    let pbft_message = message.get_pbft_message();
     let info = message.info();
 
     check_view_mismatch(state, info)?;
 
     check_pre_prepare_does_not_exist(msg_log, info)?;
 
-    if state.is_primary() {
-        check_pre_prepare_matches_original_block_new(msg_log, pbft_message, info)?;
-    } else {
-        set_seq_num_and_fix_block_new_seq_num(state, msg_log, &pbft_message, info)?;
-    }
+    check_pre_prepare_matches_original_block_new(msg_log, message)?;
 
-    set_current_working_block(state, pbft_message);
+    set_current_working_block(state, message);",34,2018-12-11 19:40:25,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240741799,https://github.com/hyperledger/sawtooth-pbft/pull/54#discussion_r240741799,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/54,https://github.com/hyperledger/sawtooth-pbft/pull/54,"This was being done in the `set_seq_num_and_fix_block_new_seq_num` method that this PR eliminates; it is necessary because it is the only place that increments the sequence number for a secondary. The current sequence number is actually not the block number of head; it is the block number of head +1, because it's the sequence number that we are currently performing consensus on. I do agree that we should just use the block number of head + 1 as the source of truth for the sequence number though; in fact, I think we should generally use on-chain information as much as possible when the PBFT state directly mirrors it. I will make a note of this and change it in a future PR.",08514bd71d9566f86a386b617e1f7e5768362f72,2018-12-11 18:48:52,240743428,"@@ -47,14 +46,12 @@ pub fn pre_prepare(
 
     check_pre_prepare_does_not_exist(msg_log, info)?;
 
-    if state.is_primary() {
-        check_pre_prepare_matches_original_block_new(msg_log, pbft_message, info)?;
-    } else {
-        set_seq_num_and_fix_block_new_seq_num(state, msg_log, &pbft_message, info)?;
-    }
+    check_pre_prepare_matches_original_block_new(msg_log, pbft_message, info)?;
 
     set_current_working_block(state, pbft_message);
 
+    state.seq_num = info.get_seq_num();",36,2018-12-11 19:40:25,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240743428,https://github.com/hyperledger/sawtooth-pbft/pull/54#discussion_r240743428,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/54,https://github.com/hyperledger/sawtooth-pbft/pull/54,"Nope. With the exception of the consensus seal (which has its own function for getting messages), a node's own message always counts towards whatever type of message it's counting.",08514bd71d9566f86a386b617e1f7e5768362f72,2018-12-11 18:54:08,240745456,"@@ -268,6 +268,22 @@ impl PbftLog {
         }
     }
 
+    /// Obtain all messages from the log that match a given type and sequence_number
+    pub fn get_messages_of_type_seq(
+        &self,
+        msg_type: &PbftMessageType,
+        sequence_number: u64,
+    ) -> Vec<&ParsedMessage> {
+        self.messages
+            .iter()
+            .filter(|&msg| {
+                let info = (*msg).info();
+                info.get_msg_type() == String::from(msg_type)",112,2018-12-11 19:40:25,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240745456,https://github.com/hyperledger/sawtooth-pbft/pull/54#discussion_r240745456,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/54,https://github.com/hyperledger/sawtooth-pbft/pull/54,"I don't believe adding the message to the backlog is necessary; the only scenario in which it could be possible for a legitimate message to be rejected here would be if a node somehow missed a view change, so the other nodes are on the same sequence number but the next view. In this scenario the node can't do anything and it's just faulty, because it can't update its view until it has some proof of the view change; currently the only proof of a view change comes from the consensus seal, but we could possibly implement some other proof (say if we get 2f+1 matching `Prepare`s with a different view). I think this scenario is extremely unlikely though, so it's probably not worth worrying about unless we see otherwise.

As far as returning a result to stop processing the message, this is done in another PR that will follow.",08514bd71d9566f86a386b617e1f7e5768362f72,2018-12-11 19:11:23,240752193,"@@ -216,6 +217,21 @@ impl PbftLog {
             return;
         }
 
+        // Except for Checkpoints and ViewChanges, the message must be for the current view to be
+        // accepted
+        let msg_type = PbftMessageType::from(msg.info().get_msg_type());
+        if msg_type != PbftMessageType::Checkpoint
+            && msg_type != PbftMessageType::ViewChange
+            && msg.info().get_view() != state.view
+        {
+            warn!(
+                ""Not adding message with view number {}; does not match node's view: {}"",
+                msg.info().get_view(),
+                state.view,
+            );
+            return;",69,2018-12-11 19:40:25,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240752193,https://github.com/hyperledger/sawtooth-pbft/pull/54#discussion_r240752193,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/54,https://github.com/hyperledger/sawtooth-pbft/pull/54,Fixed,08514bd71d9566f86a386b617e1f7e5768362f72,2018-12-11 19:14:57,240753500,"@@ -92,7 +92,7 @@ fn check_pre_prepare_matches_original_block_new(
     pbft_message: &PbftMessage,
     info: &PbftMessageInfo,
 ) -> Result<(), PbftError> {
-    let block_new_msgs = msg_log.get_messages_of_type(
+    let block_new_msgs =  msg_log.get_messages_of_type_seq_view(",,2018-12-11 19:40:25,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240753500,https://github.com/hyperledger/sawtooth-pbft/pull/54#discussion_r240753500,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/54,https://github.com/hyperledger/sawtooth-pbft/pull/54,"It is a shame, but I personally prefer to leave it as-is; because these are relatively simple and straightforward functions, I'd rather make two easy-to-use functions than one more robust function that requires extra stuff (e.g. wrapping an argument in an `Option`)",08514bd71d9566f86a386b617e1f7e5768362f72,2018-12-11 19:39:13,240762558,"@@ -268,7 +269,7 @@ impl PbftLog {
     }
 
     /// Obtain messages from the log that match a given type, sequence number, and view
-    pub fn get_messages_of_type(
+    pub fn get_messages_of_type_seq_view(",120,2018-12-11 19:40:25,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/240762558,https://github.com/hyperledger/sawtooth-pbft/pull/54#discussion_r240762558,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/52,https://github.com/hyperledger/sawtooth-pbft/pull/52,Remove the exclamation point. ,92337ef15e87ae37d33ac4b246978391a3038dac,2018-12-07 20:14:22,239933570,"@@ -510,7 +510,28 @@ impl PbftNode {
                 }
             }
             WorkingBlockOption::NoWorkingBlock => {
-                return Ok(false);
+                // If we've crashed and don't have persistent logs, we'll end up getting a
+                // new block with no working block. Or if the timing is right during regular
+                // catchup, we could end up with no working block during a BlockNew. However,
+                // we also have no working block here in the normal course of operations. So,
+                // we check to see if there's any logs for the new block. If there are, then
+                // we skip catchup since the node will process this new block normally.
+                // Otherwise, we've fallen behind and need to catch up.
+                let any_messages = self
+                    .msg_log
+                    .get_enough_messages(&PbftMessageType::Commit, head.block_num + 1, 2 * state.f)
+                    .is_some();
+
+                if block.block_num == head.block_num + 2
+                    && !block.payload.is_empty()
+                    && !any_messages
+                {
+                    info!(""{}: Catching up from no working block!"", state);",,2018-12-07 20:33:55,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/239933570,https://github.com/hyperledger/sawtooth-pbft/pull/52#discussion_r239933570,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/50,https://github.com/hyperledger/sawtooth-pbft/pull/50,cc @RyanLassigBanks @rberg2 on this bit ^^. Solves an issue with the workspace name starting with `-`,feb098f5234ae75e10dfb481b7f8f200193482ea,2018-12-05 16:01:15,239127137,"@@ -17,7 +17,10 @@
 
 pipeline {
     agent {
-        label 'master'
+        node {
+            label 'master'
+            customWorkspace ""workspace/${env.BUILD_TAG}""",7,2018-12-07 18:59:02,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/239127137,https://github.com/hyperledger/sawtooth-pbft/pull/50#discussion_r239127137,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/50,https://github.com/hyperledger/sawtooth-pbft/pull/50,"Could we keep a section on running PBFT? Even if it's just something that says ""look at these scripts in `tests/`"" or ""here's a link to the hosted documentation that says how to run it"", it would be nice to provide new users some guidance in the README.",feb098f5234ae75e10dfb481b7f8f200193482ea,2018-12-05 16:02:51,239127932,"@@ -39,89 +39,3 @@ development). PoET is only crash fault tolerant, so if any nodes in the
 network exhibit [Byzantine
 behaviour](https://en.wikipedia.org/wiki/Byzantine_fault_tolerance#Byzantine_Generals'_Problem),
 it causes issues with consensus.
-
-
-## Features
-The following features have been implemented:
-
-+ [x] **Normal case operation:** Handling transactions when the network is functioning normally
-+ [x] **View changes:** When a primary node is considered faulty (crashed or
-  malicious), the network changes views and a new primary is elected.
-+ [x] **Log garbage collection:** Every so often, message logs should be garbage
-  collected so as to not take up too much space.
-+ [x] **Testing improvements:** Presently, a liveness test up to 55 blocks has
-  been performed on a network of four nodes. Unit tests are also included for
-  each individual component of the algorithm.
-
-The following features are desired (not a comprehensive list):
-+ [ ] **Allow network changes:** Right now, the network is assumed to be
-  static. Peers are introduced through on-chain settings, and the peer list
-  does not change during network operation.
-+ [ ] **Persistent storage:** Nodes should be able to recover from crashes by
-  saving their logs in persistent storage instead of keeping everything in
-  memory
-+ [ ] **Documentation:** Use existing Sawtooth doc generation to create
-  documentation for this project
-
-## Running PBFT",41,2018-12-07 18:59:02,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/239127932,https://github.com/hyperledger/sawtooth-pbft/pull/50#discussion_r239127932,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/50,https://github.com/hyperledger/sawtooth-pbft/pull/50,"We'll link to the documentation from the README, but the documentation isn't hosted yet. When it is, we'll include the link here.",feb098f5234ae75e10dfb481b7f8f200193482ea,2018-12-05 16:22:41,239136430,"@@ -39,89 +39,3 @@ development). PoET is only crash fault tolerant, so if any nodes in the
 network exhibit [Byzantine
 behaviour](https://en.wikipedia.org/wiki/Byzantine_fault_tolerance#Byzantine_Generals'_Problem),
 it causes issues with consensus.
-
-
-## Features
-The following features have been implemented:
-
-+ [x] **Normal case operation:** Handling transactions when the network is functioning normally
-+ [x] **View changes:** When a primary node is considered faulty (crashed or
-  malicious), the network changes views and a new primary is elected.
-+ [x] **Log garbage collection:** Every so often, message logs should be garbage
-  collected so as to not take up too much space.
-+ [x] **Testing improvements:** Presently, a liveness test up to 55 blocks has
-  been performed on a network of four nodes. Unit tests are also included for
-  each individual component of the algorithm.
-
-The following features are desired (not a comprehensive list):
-+ [ ] **Allow network changes:** Right now, the network is assumed to be
-  static. Peers are introduced through on-chain settings, and the peer list
-  does not change during network operation.
-+ [ ] **Persistent storage:** Nodes should be able to recover from crashes by
-  saving their logs in persistent storage instead of keeping everything in
-  memory
-+ [ ] **Documentation:** Use existing Sawtooth doc generation to create
-  documentation for this project
-
-## Running PBFT",41,2018-12-07 18:59:02,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/239136430,https://github.com/hyperledger/sawtooth-pbft/pull/50#discussion_r239136430,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/50,https://github.com/hyperledger/sawtooth-pbft/pull/50,"Actually, it looks like we may want to instead pass in `-Djenkins.branch.WorkspaceLocatorImpl.PATH_MAX=0` to Jenkins to just stop the path truncation behavior:

https://issues.jenkins-ci.org/browse/JENKINS-38706?focusedCommentId=274531&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-274531",feb098f5234ae75e10dfb481b7f8f200193482ea,2018-12-05 16:49:06,239147981,"@@ -17,7 +17,10 @@
 
 pipeline {
     agent {
-        label 'master'
+        node {
+            label 'master'
+            customWorkspace ""workspace/${env.BUILD_TAG}""",7,2018-12-07 18:59:02,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/239147981,https://github.com/hyperledger/sawtooth-pbft/pull/50#discussion_r239147981,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/50,https://github.com/hyperledger/sawtooth-pbft/pull/50,@RyanLassigBanks says we should use the method you've got here instead of passing in the flag at startup,feb098f5234ae75e10dfb481b7f8f200193482ea,2018-12-07 15:54:22,239854983,"@@ -17,7 +17,10 @@
 
 pipeline {
     agent {
-        label 'master'
+        node {
+            label 'master'
+            customWorkspace ""workspace/${env.BUILD_TAG}""",7,2018-12-07 18:59:02,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/239854983,https://github.com/hyperledger/sawtooth-pbft/pull/50#discussion_r239854983,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/48,https://github.com/hyperledger/sawtooth-pbft/pull/48,"@aludvik do we want to use the `tests/pbft.sh` script, or should we be recommending people use `bin/run_docker_test` instead? Either way, we should decide and be consistent, since these two scripts do essentially the same thing.",fa0844e6321f2162cfb9dc5977f075acade80d81,2018-11-28 15:29:15,237132381,"@@ -1,62 +1,98 @@
 ***************************
-Installing and Running PBFT
+Installing and Testing PBFT
 ***************************
 
-Prerequisites: `Docker and Docker Compose <https://www.docker.com/>`__ must be installed.
+This procedure describes how to install PBFT, start a four-node network in
+Docker containers, and run a basic liveness test.
 
-Use the following steps to start a four-node network and run a liveness test:
+**Prerequisites:** `Docker and Docker Compose <https://www.docker.com/>`__ must
+be installed.
 
-1.  Clone the PBFT repo: ``git clone https://github.com/bitwiseio/sawtooth-pbft.git``
+1. Clone the PBFT repository.
 
-#.  Run the following commands to connect to the ``sawtooth-dev-pbft``
-    interactive shell:
+     .. code-block:: console
 
-    .. code-block:: console
+        $ git clone https://github.com/hyperledger/sawtooth-pbft.git
 
-       cd sawtooth-pbft
+#. Run the following commands to install the dependencies for PBFT and connect
+   to the interactive shell container, ``sawtooth-dev-pbft``.
 
-       docker build . -f Dockerfile -t sawtooth-dev-pbft
+     .. code-block:: console
 
-       docker run -v $(pwd):/project/sawtooth-pbft -it sawtooth-dev-pbft bash
+        $ cd sawtooth-pbft
+        $ docker build . -f Dockerfile -t sawtooth-dev-pbft
+        $ docker run -v $(pwd):/project/sawtooth-pbft -it sawtooth-dev-pbft bash
 
-       # You can optionally use this to speed up your build times, if you have a cargo-registry Docker volume set up:
-       docker run -v $(pwd):/project/sawtooth-pbft -v cargo-registry:/root/.cargo/registry -it sawtooth-dev-pbft bash
+   .. tip::
 
-#.  Once you have the ``sawtooth-dev-pbft`` interactive shell up, run:
+      If you have already configured a ``cargo-registry`` Docker volume, use
+      the following ``docker run`` command to speed up the build time in the
+      next step.
 
-    .. code-block:: console
+       .. code-block:: console
+
+          $ docker run -v $(pwd):/project/sawtooth-pbft \
+          -v cargo-registry:/root/.cargo/registry \
+          -it sawtooth-dev-pbft bash
+
+#.  Build the PBFT project.
+
+      .. code-block:: console
+
+         $ cargo build
 
-       cargo build
+#. After the project has finished building, exit the ``sawtooth-dev-pbft``
+   shell container.
 
-#.  Once the project finishes building, exit the interactive shell and run
+#. Run the PBFT test script on your host system from the ``sawtooth-pbft``
+   directory.
+
+     .. code-block:: console
+
+        % tests/pbft.sh",68,2018-11-28 15:29:22,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237132381,https://github.com/hyperledger/sawtooth-pbft/pull/48#discussion_r237132381,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/48,https://github.com/hyperledger/sawtooth-pbft/pull/48,I am in favor of run_docker_test as it solves a lot of problems we have come across. (I also wrote most of it so I am a little biased.),fa0844e6321f2162cfb9dc5977f075acade80d81,2018-11-28 18:55:47,237216498,"@@ -1,62 +1,98 @@
 ***************************
-Installing and Running PBFT
+Installing and Testing PBFT
 ***************************
 
-Prerequisites: `Docker and Docker Compose <https://www.docker.com/>`__ must be installed.
+This procedure describes how to install PBFT, start a four-node network in
+Docker containers, and run a basic liveness test.
 
-Use the following steps to start a four-node network and run a liveness test:
+**Prerequisites:** `Docker and Docker Compose <https://www.docker.com/>`__ must
+be installed.
 
-1.  Clone the PBFT repo: ``git clone https://github.com/bitwiseio/sawtooth-pbft.git``
+1. Clone the PBFT repository.
 
-#.  Run the following commands to connect to the ``sawtooth-dev-pbft``
-    interactive shell:
+     .. code-block:: console
 
-    .. code-block:: console
+        $ git clone https://github.com/hyperledger/sawtooth-pbft.git
 
-       cd sawtooth-pbft
+#. Run the following commands to install the dependencies for PBFT and connect
+   to the interactive shell container, ``sawtooth-dev-pbft``.
 
-       docker build . -f Dockerfile -t sawtooth-dev-pbft
+     .. code-block:: console
 
-       docker run -v $(pwd):/project/sawtooth-pbft -it sawtooth-dev-pbft bash
+        $ cd sawtooth-pbft
+        $ docker build . -f Dockerfile -t sawtooth-dev-pbft
+        $ docker run -v $(pwd):/project/sawtooth-pbft -it sawtooth-dev-pbft bash
 
-       # You can optionally use this to speed up your build times, if you have a cargo-registry Docker volume set up:
-       docker run -v $(pwd):/project/sawtooth-pbft -v cargo-registry:/root/.cargo/registry -it sawtooth-dev-pbft bash
+   .. tip::
 
-#.  Once you have the ``sawtooth-dev-pbft`` interactive shell up, run:
+      If you have already configured a ``cargo-registry`` Docker volume, use
+      the following ``docker run`` command to speed up the build time in the
+      next step.
 
-    .. code-block:: console
+       .. code-block:: console
+
+          $ docker run -v $(pwd):/project/sawtooth-pbft \
+          -v cargo-registry:/root/.cargo/registry \
+          -it sawtooth-dev-pbft bash
+
+#.  Build the PBFT project.
+
+      .. code-block:: console
+
+         $ cargo build
 
-       cargo build
+#. After the project has finished building, exit the ``sawtooth-dev-pbft``
+   shell container.
 
-#.  Once the project finishes building, exit the interactive shell and run
+#. Run the PBFT test script on your host system from the ``sawtooth-pbft``
+   directory.
+
+     .. code-block:: console
+
+        % tests/pbft.sh",68,2018-11-28 18:55:47,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237216498,https://github.com/hyperledger/sawtooth-pbft/pull/48#discussion_r237216498,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/48,https://github.com/hyperledger/sawtooth-pbft/pull/48,"We have consensus! I'll make the run_docker_test change in a separate PR, so that this one can stay focused on editorial (non-technical) changes.",fa0844e6321f2162cfb9dc5977f075acade80d81,2018-11-28 19:03:02,237219250,"@@ -1,62 +1,98 @@
 ***************************
-Installing and Running PBFT
+Installing and Testing PBFT
 ***************************
 
-Prerequisites: `Docker and Docker Compose <https://www.docker.com/>`__ must be installed.
+This procedure describes how to install PBFT, start a four-node network in
+Docker containers, and run a basic liveness test.
 
-Use the following steps to start a four-node network and run a liveness test:
+**Prerequisites:** `Docker and Docker Compose <https://www.docker.com/>`__ must
+be installed.
 
-1.  Clone the PBFT repo: ``git clone https://github.com/bitwiseio/sawtooth-pbft.git``
+1. Clone the PBFT repository.
 
-#.  Run the following commands to connect to the ``sawtooth-dev-pbft``
-    interactive shell:
+     .. code-block:: console
 
-    .. code-block:: console
+        $ git clone https://github.com/hyperledger/sawtooth-pbft.git
 
-       cd sawtooth-pbft
+#. Run the following commands to install the dependencies for PBFT and connect
+   to the interactive shell container, ``sawtooth-dev-pbft``.
 
-       docker build . -f Dockerfile -t sawtooth-dev-pbft
+     .. code-block:: console
 
-       docker run -v $(pwd):/project/sawtooth-pbft -it sawtooth-dev-pbft bash
+        $ cd sawtooth-pbft
+        $ docker build . -f Dockerfile -t sawtooth-dev-pbft
+        $ docker run -v $(pwd):/project/sawtooth-pbft -it sawtooth-dev-pbft bash
 
-       # You can optionally use this to speed up your build times, if you have a cargo-registry Docker volume set up:
-       docker run -v $(pwd):/project/sawtooth-pbft -v cargo-registry:/root/.cargo/registry -it sawtooth-dev-pbft bash
+   .. tip::
 
-#.  Once you have the ``sawtooth-dev-pbft`` interactive shell up, run:
+      If you have already configured a ``cargo-registry`` Docker volume, use
+      the following ``docker run`` command to speed up the build time in the
+      next step.
 
-    .. code-block:: console
+       .. code-block:: console
+
+          $ docker run -v $(pwd):/project/sawtooth-pbft \
+          -v cargo-registry:/root/.cargo/registry \
+          -it sawtooth-dev-pbft bash
+
+#.  Build the PBFT project.
+
+      .. code-block:: console
+
+         $ cargo build
 
-       cargo build
+#. After the project has finished building, exit the ``sawtooth-dev-pbft``
+   shell container.
 
-#.  Once the project finishes building, exit the interactive shell and run
+#. Run the PBFT test script on your host system from the ``sawtooth-pbft``
+   directory.
+
+     .. code-block:: console
+
+        % tests/pbft.sh",68,2018-11-28 19:03:02,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237219250,https://github.com/hyperledger/sawtooth-pbft/pull/48#discussion_r237219250,chenette
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,"just curious, why is pass by value required here?",d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-26 18:36:06,236376362,"@@ -193,6 +193,23 @@ impl ParsedMessage {
 
         Self::from_peer_message(peer_message, true)
     }
+
+    /// Constructs a copy of this message with the given message type
+    #[allow(needless_pass_by_value)]",6,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/236376362,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r236376362,dcmiddle
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,"The overall correct thing to do is going to be deriving `Copy` for `PbftMessageType`, see https://stackoverflow.com/a/44695401 for some rationale on that. However, making that change is a little out-of-scope for this PR, as it's going to involve changing a fair number of lines of code that are currently passing by reference. Passing by value is used here in anticipation of making that change, though.",d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-26 19:35:28,236396913,"@@ -193,6 +193,23 @@ impl ParsedMessage {
 
         Self::from_peer_message(peer_message, true)
     }
+
+    /// Constructs a copy of this message with the given message type
+    #[allow(needless_pass_by_value)]",6,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/236396913,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r236396913,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,thx,d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-26 20:31:56,236415036,"@@ -193,6 +193,23 @@ impl ParsedMessage {
 
         Self::from_peer_message(peer_message, true)
     }
+
+    /// Constructs a copy of this message with the given message type
+    #[allow(needless_pass_by_value)]",6,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/236415036,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r236415036,dcmiddle
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,"This commit should be reworded to explain what defects are being fixed. What is interesting to the reader is not that the test now passes, but what was broken before that you have fixed. This might need to be broken up into several commits to accomplish that, if there is more than one fix contained here.",d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-26 21:52:32,236441370,"@@ -78,6 +78,8 @@ impl PbftNode {
         msg: ParsedMessage,
         state: &mut PbftState,
     ) -> Result<(), PbftError> {
+        info!(""{}: Got peer message: {}"", state, msg.info());",4,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/236441370,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r236441370,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,"@aludvik: Does it suffice to say that these fixes are really just implementing node catchup part II due to rushing the previous code out the door for a deadline? They would've been squashed into the previous PR if there had been time. There isn't really a 1:1 correlation between a line of code change and a bug fixed, or a list of exact bugs that are fixed - I just wrote it correctly this time 😛 ",d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-26 22:03:55,236444986,"@@ -78,6 +78,8 @@ impl PbftNode {
         msg: ParsedMessage,
         state: &mut PbftState,
     ) -> Result<(), PbftError> {
+        info!(""{}: Got peer message: {}"", state, msg.info());",4,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/236444986,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r236444986,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,"I think it is important that the commit message be helpful in understanding what the commit is doing and why. ""Fix CFT tests"" gives me the impression the commit is modifying the tests. In reality it is making changes to the implementation in order to pass the tests, fixing a number of bugs in the process, so I think it is misleading.

To give you something more concrete, based on the commit description, I would suggest having one commit like this:
```
Synchronize sequence number on new block

Ensures that the sequence number doesn't get out of sync with actual state by
syncing them whenever a new block is received. This is required to pass the
liveness test.
```

and another like this:
```
Handle missing state after crash in catch up

Provides a more hardy version of catchup that is tolerant of booting up 
without any old state after a crash. This is required to pass the liveness test.
```",d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-26 23:30:08,236468475,"@@ -78,6 +78,8 @@ impl PbftNode {
         msg: ParsedMessage,
         state: &mut PbftState,
     ) -> Result<(), PbftError> {
+        info!(""{}: Got peer message: {}"", state, msg.info());",4,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/236468475,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r236468475,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,Could you explain why this change is necessary? What makes this the correct behavior vs. proposing a view change or doing both?,d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-27 15:30:52,236715146,"@@ -571,10 +571,12 @@ impl PbftNode {
             Ok(()) => {}
             Err(err) => {
                 warn!(
-                    ""Proposing view change due to failed consensus seal verification! Error was {}"",
+                    ""Failing block due to failed consensus seal verification! Error was {}"",
                     err
                 );
-                self.propose_view_change(state)?;
+                self.service.fail_block(block.block_id).map_err(|err| {",204,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/236715146,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r236715146,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,"Fail block is necessary to inform the validator that the block is no longer being considered and uphold the contract that for every new block sent to the engine a commit, fail, or ignore will be sent back to the validator for the block.

I am also curious about why we no longer want to do a view change though.",d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-27 16:54:08,236754447,"@@ -571,10 +571,12 @@ impl PbftNode {
             Ok(()) => {}
             Err(err) => {
                 warn!(
-                    ""Proposing view change due to failed consensus seal verification! Error was {}"",
+                    ""Failing block due to failed consensus seal verification! Error was {}"",
                     err
                 );
-                self.propose_view_change(state)?;
+                self.service.fail_block(block.block_id).map_err(|err| {",204,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/236754447,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r236754447,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,"Good catch, now we've got both a block fail and view change.",d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-27 18:22:41,236787862,"@@ -571,10 +571,12 @@ impl PbftNode {
             Ok(()) => {}
             Err(err) => {
                 warn!(
-                    ""Proposing view change due to failed consensus seal verification! Error was {}"",
+                    ""Failing block due to failed consensus seal verification! Error was {}"",
                     err
                 );
-                self.propose_view_change(state)?;
+                self.service.fail_block(block.block_id).map_err(|err| {",204,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/236787862,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r236787862,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,"@aludvik, @ltseeley: In the interest of getting this merged I'm not going to add more unit tests beyond this to this PR, but it would be really useful to start writing some unit tests around various conditions such as catching up after having crashed without saving state.",d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-29 16:04:20,237549335,"@@ -1270,6 +1321,84 @@ mod tests {
         assert_eq!(state1.seq_num, 0);
     }
 
+    #[test]
+    fn block_new_first_10_blocks() {",337,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237549335,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r237549335,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,This change should be in the commit where you change the signature for this method,d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-29 16:46:17,237568364,"@@ -1316,7 +1445,7 @@ mod tests {
             node.msg_log.add_message(message);
         }
 
-        let seal = node.build_seal(&mut state, vec![1, 2, 3], head).unwrap();
+        let seal = node.build_seal(&state, vec![1, 2, 3], head).unwrap();",422,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237568364,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r237568364,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,Not returning early when the node is primary seems like a pretty significant change that isn't really captured by the commit message; this should probably be in its own commit.,d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-29 16:48:28,237569219,"@@ -466,11 +466,19 @@ impl PbftNode {
         &mut self,
         state: &mut PbftState,
         block: &Block,
-        msg: PbftMessage,
+        msg: &PbftMessage,
+        head: &Block,
     ) -> Result<bool, PbftError> {
-        // Don't catch up if we're the primary, since we're the ones who publish.
-        // Also don't catch up from block 0 -> 1, since there's no consensus seal.
-        if state.is_primary() || block.block_num < 2 {
+        info!(
+            ""{}: Trying catchup from head #{} to #{}, from BlockNew message #{}"",
+            state,
+            head.block_num,
+            head.block_num + 1,
+            block.block_num,
+        );
+
+        // Don't catch up from block 0 -> 1, since there's no consensus seal.
+        if block.block_num < 2 {",52,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237569219,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r237569219,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,"There are a lot of logging updates in this commit; perhaps these should be to moved to the ""logging improvement"" commit that's a part of this PR to keep this commit clean.",d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-29 16:49:04,237569482,"@@ -483,14 +491,25 @@ impl PbftNode {
                 let block_id_matches = block.previous_id == wb.get_block_id();
 
                 if !block_num_matches || !block_id_matches {
+                    debug!(",60,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237569482,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r237569482,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,"This block of code was added in an earlier commit in this PR, so you should just fix it up with that commit to remove it altogether.",d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-29 16:49:54,237569830,"@@ -516,43 +535,51 @@ impl PbftNode {
                     Ok(msgs)
                 })?;
 
-        // Sync local state with actual state. We re-sync the sequence number with head
-        // again, even though we already did that in `on_block_new`, since if we're
-        // catching up as the primary, the sequence number should actually just be
-        // the head's block num, and not that+1.
-        if state.seq_num != head.block_num {",,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237569830,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r237569830,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,"Again, this seems like a fairly self-contained change that isn't properly captured by the commit message. Probably better off with its own commit.",d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-29 16:52:07,237570771,"@@ -566,7 +593,27 @@ impl PbftNode {
             return Ok(());
         }
 
-        info!(""{}: Got BlockNew: {:?}"", state, block.block_id);
+        let head = self
+            .service
+            .get_chain_head()
+            .map_err(|e| PbftError::InternalError(e.description().to_string()))?;
+
+        info!(
+            ""{}: Got BlockNew: {} / {}"",
+            state,
+            block.block_num,
+            hex::encode(&block.block_id[..6]),
+        );
+
+        debug!(""Head is currently at {}"", head.block_num);
+
+        if block.block_num <= head.block_num {",166,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237570771,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r237570771,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,"I don't think this commit is necessary, since we can already run the tests locally with `bin/run_docker_test` which is the recommended way of running it. Also, it makes the output of the test rather messy, and from my experience the containers aren't cleaned up properly when using `run_docker_test`",d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-29 16:55:42,237572389,"@@ -20,29 +20,51 @@
 # a node, verifying all nodes reach block 20, restarting the node, and
 # verifying that all nodes reach block 30.
 
-if [ -z ""$ISOLATION_ID "" ]; then export ISOLATION_ID=latest; fi
+if [ -z ""$ISOLATION_ID"" ]; then export ISOLATION_ID=latest; fi",5,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237572389,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r237572389,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,The Jenkins tests should be run using `bin/run_docker_test` (see https://github.com/hyperledger/sawtooth-raft/blob/master/Jenkinsfile),d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-29 16:56:33,237572799,"@@ -94,6 +94,23 @@ pipeline {
             }
         }
 
+        stage('Run CFT tests') {
+            options {
+                timeout(time: 10, unit: 'MINUTES')
+            }
+            steps {
+                sh 'tests/test_crash_fault_tolerance.sh'",18,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237572799,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r237572799,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,Self-contained change,d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-29 16:58:00,237573358,"@@ -516,43 +535,51 @@ impl PbftNode {
                     Ok(msgs)
                 })?;
 
-        // Sync local state with actual state. We re-sync the sequence number with head
-        // again, even though we already did that in `on_block_new`, since if we're
-        // catching up as the primary, the sequence number should actually just be
-        // the head's block num, and not that+1.
-        if state.seq_num != head.block_num {
-            info!(
-                ""Updating sequence number from {} to {}."",
-                state.seq_num, head.block_num
-            );
-            state.seq_num = head.block_num;
-        }
-
         let view = messages[0].info().get_view();
         if state.view != view {
             info!(""Updating view from {} to {}."", state.view, view);
             state.view = view;
         }
 
+        // Add messages to backlog so that `handlers::commit` can process a commit
+        // message normally
         for message in &messages {
             self.msg_log.add_message(message.clone());
         }
 
-        // Commit the new block, using one of the parsed commit messages to simulate
+        // Commit the new block, using one of the parsed messages to simulate
         // having received a regular commit message.
-        handlers::commit(state, &mut self.msg_log, &mut *self.service, &messages[0])?;
+        handlers::commit(
+            state,
+            &mut self.msg_log,
+            &mut *self.service,
+            &messages[0].as_msg_type(PbftMessageType::Commit),
+        )?;
 
         // Start a view change if we need to force one for fairness
         if state.at_forced_view_change() {
             self.force_view_change(state);
         }
 
+        // Ensure that the message that we generated from the BlockNew message
+        // has the right sequence number.
+        let mut fixed_msg = msg.clone();",126,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237573358,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r237573358,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,Self-contained change,d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-29 16:58:09,237573417,"@@ -516,43 +535,51 @@ impl PbftNode {
                     Ok(msgs)
                 })?;
 
-        // Sync local state with actual state. We re-sync the sequence number with head
-        // again, even though we already did that in `on_block_new`, since if we're
-        // catching up as the primary, the sequence number should actually just be
-        // the head's block num, and not that+1.
-        if state.seq_num != head.block_num {
-            info!(
-                ""Updating sequence number from {} to {}."",
-                state.seq_num, head.block_num
-            );
-            state.seq_num = head.block_num;
-        }
-
         let view = messages[0].info().get_view();
         if state.view != view {
             info!(""Updating view from {} to {}."", state.view, view);
             state.view = view;
         }
 
+        // Add messages to backlog so that `handlers::commit` can process a commit
+        // message normally
         for message in &messages {
             self.msg_log.add_message(message.clone());
         }
 
-        // Commit the new block, using one of the parsed commit messages to simulate
+        // Commit the new block, using one of the parsed messages to simulate
         // having received a regular commit message.
-        handlers::commit(state, &mut self.msg_log, &mut *self.service, &messages[0])?;
+        handlers::commit(
+            state,
+            &mut self.msg_log,
+            &mut *self.service,
+            &messages[0].as_msg_type(PbftMessageType::Commit),
+        )?;
 
         // Start a view change if we need to force one for fairness
         if state.at_forced_view_change() {
             self.force_view_change(state);
         }
 
+        // Ensure that the message that we generated from the BlockNew message
+        // has the right sequence number.
+        let mut fixed_msg = msg.clone();
+        let mut fixed_info = fixed_msg.take_info();
+        fixed_info.set_seq_num(head.block_num);
+        fixed_msg.set_info(fixed_info);
+
         self.msg_log
-            .add_message(ParsedMessage::from_pbft_message(msg));
+            .add_message(ParsedMessage::from_pbft_message(fixed_msg));
         state.working_block = WorkingBlockOption::TentativeWorkingBlock(block.block_id.clone());
         state.idle_timeout.stop();
         state.commit_timeout.start();
 
+        if state.is_primary() {",138,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237573417,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r237573417,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,Another self-contained change that's not captured by the commit message.,d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-29 16:58:23,237573525,"@@ -516,43 +535,51 @@ impl PbftNode {
                     Ok(msgs)
                 })?;
 
-        // Sync local state with actual state. We re-sync the sequence number with head
-        // again, even though we already did that in `on_block_new`, since if we're
-        // catching up as the primary, the sequence number should actually just be
-        // the head's block num, and not that+1.
-        if state.seq_num != head.block_num {
-            info!(
-                ""Updating sequence number from {} to {}."",
-                state.seq_num, head.block_num
-            );
-            state.seq_num = head.block_num;
-        }
-
         let view = messages[0].info().get_view();
         if state.view != view {
             info!(""Updating view from {} to {}."", state.view, view);
             state.view = view;
         }
 
+        // Add messages to backlog so that `handlers::commit` can process a commit
+        // message normally
         for message in &messages {
             self.msg_log.add_message(message.clone());
         }
 
-        // Commit the new block, using one of the parsed commit messages to simulate
+        // Commit the new block, using one of the parsed messages to simulate
         // having received a regular commit message.
-        handlers::commit(state, &mut self.msg_log, &mut *self.service, &messages[0])?;
+        handlers::commit(
+            state,
+            &mut self.msg_log,
+            &mut *self.service,
+            &messages[0].as_msg_type(PbftMessageType::Commit),",115,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237573525,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r237573525,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,"I really think we should move away from the docker-in-docker thing, I don't see the value-add for the complexity that it brings.",d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-29 17:02:12,237575079,"@@ -20,29 +20,51 @@
 # a node, verifying all nodes reach block 20, restarting the node, and
 # verifying that all nodes reach block 30.
 
-if [ -z ""$ISOLATION_ID "" ]; then export ISOLATION_ID=latest; fi
+if [ -z ""$ISOLATION_ID"" ]; then export ISOLATION_ID=latest; fi",5,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237575079,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r237575079,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,"There isn't really a single bug that each of these changes fix, so I don't see what splitting it up gives us - the commit message would just be something like ""part of making catchup more robust"".",d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-29 17:03:58,237575791,"@@ -516,43 +535,51 @@ impl PbftNode {
                     Ok(msgs)
                 })?;
 
-        // Sync local state with actual state. We re-sync the sequence number with head
-        // again, even though we already did that in `on_block_new`, since if we're
-        // catching up as the primary, the sequence number should actually just be
-        // the head's block num, and not that+1.
-        if state.seq_num != head.block_num {
-            info!(
-                ""Updating sequence number from {} to {}."",
-                state.seq_num, head.block_num
-            );
-            state.seq_num = head.block_num;
-        }
-
         let view = messages[0].info().get_view();
         if state.view != view {
             info!(""Updating view from {} to {}."", state.view, view);
             state.view = view;
         }
 
+        // Add messages to backlog so that `handlers::commit` can process a commit
+        // message normally
         for message in &messages {
             self.msg_log.add_message(message.clone());
         }
 
-        // Commit the new block, using one of the parsed commit messages to simulate
+        // Commit the new block, using one of the parsed messages to simulate
         // having received a regular commit message.
-        handlers::commit(state, &mut self.msg_log, &mut *self.service, &messages[0])?;
+        handlers::commit(
+            state,
+            &mut self.msg_log,
+            &mut *self.service,
+            &messages[0].as_msg_type(PbftMessageType::Commit),
+        )?;
 
         // Start a view change if we need to force one for fairness
         if state.at_forced_view_change() {
             self.force_view_change(state);
         }
 
+        // Ensure that the message that we generated from the BlockNew message
+        // has the right sequence number.
+        let mut fixed_msg = msg.clone();",126,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237575791,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r237575791,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,@aludvik could you weigh in on this?,d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-29 17:05:42,237576477,"@@ -20,29 +20,51 @@
 # a node, verifying all nodes reach block 20, restarting the node, and
 # verifying that all nodes reach block 30.
 
-if [ -z ""$ISOLATION_ID "" ]; then export ISOLATION_ID=latest; fi
+if [ -z ""$ISOLATION_ID"" ]; then export ISOLATION_ID=latest; fi",5,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237576477,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r237576477,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,"That's okay, 1 commit != 1 bug fix. Generally speaking, 1 PR should be 1 bug fix. Best practice from my experience is that the smallest self-contained change that results in runnable, improved code should be its own commit. Each of these changes is distinct; they are all in service of fixing the same bug, but they are distinct changes nonetheless. For this change, the comment you provided is already a pretty good commit message. In my opinion, it's a lot easier to understand what's going on when each of the changes is described, rather than all being lumped together and just saying ""this makes it more robust.""",d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-29 17:19:33,237581555,"@@ -516,43 +535,51 @@ impl PbftNode {
                     Ok(msgs)
                 })?;
 
-        // Sync local state with actual state. We re-sync the sequence number with head
-        // again, even though we already did that in `on_block_new`, since if we're
-        // catching up as the primary, the sequence number should actually just be
-        // the head's block num, and not that+1.
-        if state.seq_num != head.block_num {
-            info!(
-                ""Updating sequence number from {} to {}."",
-                state.seq_num, head.block_num
-            );
-            state.seq_num = head.block_num;
-        }
-
         let view = messages[0].info().get_view();
         if state.view != view {
             info!(""Updating view from {} to {}."", state.view, view);
             state.view = view;
         }
 
+        // Add messages to backlog so that `handlers::commit` can process a commit
+        // message normally
         for message in &messages {
             self.msg_log.add_message(message.clone());
         }
 
-        // Commit the new block, using one of the parsed commit messages to simulate
+        // Commit the new block, using one of the parsed messages to simulate
         // having received a regular commit message.
-        handlers::commit(state, &mut self.msg_log, &mut *self.service, &messages[0])?;
+        handlers::commit(
+            state,
+            &mut self.msg_log,
+            &mut *self.service,
+            &messages[0].as_msg_type(PbftMessageType::Commit),
+        )?;
 
         // Start a view change if we need to force one for fairness
         if state.at_forced_view_change() {
             self.force_view_change(state);
         }
 
+        // Ensure that the message that we generated from the BlockNew message
+        // has the right sequence number.
+        let mut fixed_msg = msg.clone();",126,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237581555,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r237581555,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/46,https://github.com/hyperledger/sawtooth-pbft/pull/46,"@ltseeley I think this commit has a number of changes that are good, regardless of whether the test is ultimately run under docker or with run_docker_test. I would not say they are unnecessary and I don't think using `bin/run_docker_test` fixes the problems.

@knkski I would like to hear more about your opinions on why docker is bad and what you think some better alternatives are. I agree it can get complex, but the state of things is derived from a number of somewhat conflicting requirements on how we build up our integration tests such as:
1. Must be able to run the tests from any host, with a minimal set of requirements (usually docker, bash, and python).
2. Must be able to run the tests on Jenkins without separate jobs and tests interfering with each other.
3. Must not do docker-in-docker (this is why we mount the docker socket into the container, it is more of a docker-alongside-docker solution, I think this is the article I read when coming up with the solution: https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)",d7f41d396942ff51a3cf40c572bb6873b539d29d,2018-11-29 17:24:11,237583252,"@@ -20,29 +20,51 @@
 # a node, verifying all nodes reach block 20, restarting the node, and
 # verifying that all nodes reach block 30.
 
-if [ -z ""$ISOLATION_ID "" ]; then export ISOLATION_ID=latest; fi
+if [ -z ""$ISOLATION_ID"" ]; then export ISOLATION_ID=latest; fi",5,2018-11-29 19:20:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/237583252,https://github.com/hyperledger/sawtooth-pbft/pull/46#discussion_r237583252,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/44,https://github.com/hyperledger/sawtooth-pbft/pull/44,"It looks like we don't use `difference` other than checking that it's non-empty, so we could probably just do `if new_peers_set != old_peers_set {`.",8028209eab1c930532ffef85f14c1db50b95d3fc,2018-11-20 20:36:29,235160118,"@@ -891,6 +905,38 @@ impl PbftNode {
         self._broadcast_message(&PbftMessageType::ViewChange, msg_bytes, state)
     }
 
+    /// Check the on-chain list of peers; if it has changed, update peers list and return true.
+    fn update_membership(&mut self, block_id: BlockId, state: &mut PbftState) -> bool {
+        // Get list of peers from settings
+        let settings = self
+            .service
+            .get_settings(
+                block_id,
+                vec![String::from(""sawtooth.consensus.pbft.peers"")],
+            ).expect(""Failed to get settings"");
+        let peers = get_peers_from_settings(&settings);
+        let new_peers_set: HashSet<PeerId> = HashSet::from_iter(peers.clone());
+
+        // Check if membership has changed
+        let old_peers_set: HashSet<PeerId> = HashSet::from_iter(state.peer_ids.iter().cloned());
+        let difference: HashSet<PeerId> = new_peers_set",,2018-11-21 18:28:33,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/235160118,https://github.com/hyperledger/sawtooth-pbft/pull/44#discussion_r235160118,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/44,https://github.com/hyperledger/sawtooth-pbft/pull/44,"We could just call `.collect()` here, which may also avoid the `FromIterator` import.",8028209eab1c930532ffef85f14c1db50b95d3fc,2018-11-20 20:38:15,235160640,"@@ -891,6 +905,38 @@ impl PbftNode {
         self._broadcast_message(&PbftMessageType::ViewChange, msg_bytes, state)
     }
 
+    /// Check the on-chain list of peers; if it has changed, update peers list and return true.
+    fn update_membership(&mut self, block_id: BlockId, state: &mut PbftState) -> bool {
+        // Get list of peers from settings
+        let settings = self
+            .service
+            .get_settings(
+                block_id,
+                vec![String::from(""sawtooth.consensus.pbft.peers"")],
+            ).expect(""Failed to get settings"");
+        let peers = get_peers_from_settings(&settings);
+        let new_peers_set: HashSet<PeerId> = HashSet::from_iter(peers.clone());
+
+        // Check if membership has changed
+        let old_peers_set: HashSet<PeerId> = HashSet::from_iter(state.peer_ids.iter().cloned());",,2018-11-21 18:28:33,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/235160640,https://github.com/hyperledger/sawtooth-pbft/pull/44#discussion_r235160640,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/44,https://github.com/hyperledger/sawtooth-pbft/pull/44,Do we want to reject the block instead of panicking if it doesn't have enough peers for PBFT? It seems sane to just consider that a bad attempt at publishing a block.,8028209eab1c930532ffef85f14c1db50b95d3fc,2018-11-20 20:40:12,235161196,"@@ -891,6 +905,38 @@ impl PbftNode {
         self._broadcast_message(&PbftMessageType::ViewChange, msg_bytes, state)
     }
 
+    /// Check the on-chain list of peers; if it has changed, update peers list and return true.
+    fn update_membership(&mut self, block_id: BlockId, state: &mut PbftState) -> bool {
+        // Get list of peers from settings
+        let settings = self
+            .service
+            .get_settings(
+                block_id,
+                vec![String::from(""sawtooth.consensus.pbft.peers"")],
+            ).expect(""Failed to get settings"");
+        let peers = get_peers_from_settings(&settings);
+        let new_peers_set: HashSet<PeerId> = HashSet::from_iter(peers.clone());
+
+        // Check if membership has changed
+        let old_peers_set: HashSet<PeerId> = HashSet::from_iter(state.peer_ids.iter().cloned());
+        let difference: HashSet<PeerId> = new_peers_set
+            .symmetric_difference(&old_peers_set)
+            .cloned()
+            .collect();
+
+        if !difference.is_empty() {
+            state.peer_ids = peers;
+            let f = ((state.peer_ids.len() - 1) / 3) as u64;
+            if f == 0 {
+                panic!(""This network no longer contains enough nodes to be fault tolerant"");",139,2018-11-21 18:28:33,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/235161196,https://github.com/hyperledger/sawtooth-pbft/pull/44#discussion_r235161196,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/44,https://github.com/hyperledger/sawtooth-pbft/pull/44,"We can't reject the block; this is called from on_block_commit, so the block has already been committed.",8028209eab1c930532ffef85f14c1db50b95d3fc,2018-11-20 22:49:56,235198492,"@@ -891,6 +905,38 @@ impl PbftNode {
         self._broadcast_message(&PbftMessageType::ViewChange, msg_bytes, state)
     }
 
+    /// Check the on-chain list of peers; if it has changed, update peers list and return true.
+    fn update_membership(&mut self, block_id: BlockId, state: &mut PbftState) -> bool {
+        // Get list of peers from settings
+        let settings = self
+            .service
+            .get_settings(
+                block_id,
+                vec![String::from(""sawtooth.consensus.pbft.peers"")],
+            ).expect(""Failed to get settings"");
+        let peers = get_peers_from_settings(&settings);
+        let new_peers_set: HashSet<PeerId> = HashSet::from_iter(peers.clone());
+
+        // Check if membership has changed
+        let old_peers_set: HashSet<PeerId> = HashSet::from_iter(state.peer_ids.iter().cloned());
+        let difference: HashSet<PeerId> = new_peers_set
+            .symmetric_difference(&old_peers_set)
+            .cloned()
+            .collect();
+
+        if !difference.is_empty() {
+            state.peer_ids = peers;
+            let f = ((state.peer_ids.len() - 1) / 3) as u64;
+            if f == 0 {
+                panic!(""This network no longer contains enough nodes to be fault tolerant"");",139,2018-11-21 18:28:33,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/235198492,https://github.com/hyperledger/sawtooth-pbft/pull/44#discussion_r235198492,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/44,https://github.com/hyperledger/sawtooth-pbft/pull/44,Should this be `vec![1]`?,8028209eab1c930532ffef85f14c1db50b95d3fc,2018-11-21 19:18:20,235511694,"@@ -303,8 +287,8 @@ mod tests {
     #[test]
     fn initial_config() {
         let config = mock_config(4);
-        let state0 = PbftState::new(0, &config);
-        let state1 = PbftState::new(1, &config);
+        let state0 = PbftState::new(vec![0], &config);
+        let state1 = PbftState::new(vec![], &config);",106,2018-11-21 19:18:50,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/235511694,https://github.com/hyperledger/sawtooth-pbft/pull/44#discussion_r235511694,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/44,https://github.com/hyperledger/sawtooth-pbft/pull/44,"Is there a reason we're specifying the particular hasher that we'll accept here? If so, can we add a comment to that effect? Otherwise, it should be possible to just accept `HashMap<String, String>`.",8028209eab1c930532ffef85f14c1db50b95d3fc,2018-11-21 19:18:37,235511779,"@@ -212,17 +202,30 @@ fn merge_millis_setting_if_set(
     )
 }
 
+/// Get the peers as a Vec<PeerId> from settings
+pub fn get_peers_from_settings<S: std::hash::BuildHasher>(",24,2018-11-21 19:18:50,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/235511779,https://github.com/hyperledger/sawtooth-pbft/pull/44#discussion_r235511779,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/44,https://github.com/hyperledger/sawtooth-pbft/pull/44,"Clippy told me to generalize it, because there's nothing in the code that's specific to HashMap. I can ignore the lint or add a comment if you think that's necessary though.",8028209eab1c930532ffef85f14c1db50b95d3fc,2018-11-21 19:54:29,235521686,"@@ -212,17 +202,30 @@ fn merge_millis_setting_if_set(
     )
 }
 
+/// Get the peers as a Vec<PeerId> from settings
+pub fn get_peers_from_settings<S: std::hash::BuildHasher>(",24,2018-11-21 19:54:29,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/235521686,https://github.com/hyperledger/sawtooth-pbft/pull/44#discussion_r235521686,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/44,https://github.com/hyperledger/sawtooth-pbft/pull/44,"It shouldn't matter, it never really gets used.",8028209eab1c930532ffef85f14c1db50b95d3fc,2018-11-21 19:54:51,235521778,"@@ -303,8 +287,8 @@ mod tests {
     #[test]
     fn initial_config() {
         let config = mock_config(4);
-        let state0 = PbftState::new(0, &config);
-        let state1 = PbftState::new(1, &config);
+        let state0 = PbftState::new(vec![0], &config);
+        let state1 = PbftState::new(vec![], &config);",106,2018-11-21 19:54:51,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/235521778,https://github.com/hyperledger/sawtooth-pbft/pull/44#discussion_r235521778,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/42,https://github.com/hyperledger/sawtooth-pbft/pull/42,"I think you can use `into_iter().map()` here and collect into `Result<Vec<ParsedMessage>, PbftError>`. collect knows how to convert `Vec<Result<T, E>>` into `Result<Vec<T>, E>`.",20315bc1091bb2017cd631351e0a8e6482efa662,2018-11-19 16:58:04,234700400,"@@ -445,6 +445,84 @@ impl PbftNode {
         Ok(())
     }
 
+    /// Attempts to catch this node up with its peers, if necessary
+    ///
+    /// Returns true if catching up was required, and false otherwise
+    fn try_catchup(
+        &mut self,
+        state: &mut PbftState,
+        block: &Block,
+        msg: PbftMessage,
+    ) -> Result<bool, PbftError> {
+        if state.is_primary() {
+            return Ok(false);
+        }
+
+        // If we've got a (Tentative)WorkingBlock, and the new block is immediately
+        // subsequent to it, then we're able to catch up. Otherwise, return false
+        // to signify that no catching up occurred.
+        match state.working_block.clone() {
+            WorkingBlockOption::WorkingBlock(wb) => {
+                let block_num_matches = block.block_num == wb.get_block_num() + 1;
+                let block_id_matches = block.previous_id == wb.get_block_id();
+
+                if !block_num_matches || !block_id_matches {
+                    return Ok(false);
+                }
+            }
+            WorkingBlockOption::TentativeWorkingBlock(bid) => {
+                if block.previous_id == bid {
+                    // If we've got a tentative working block, replace it with a regular working block
+                    state.working_block = WorkingBlockOption::WorkingBlock(msg.get_block().clone());
+                } else {
+                    return Ok(false);
+                }
+            }
+            WorkingBlockOption::NoWorkingBlock => {
+                return Ok(false);
+            }
+        };
+
+        info!(""Catching up to block #{}"", block.block_num);
+
+        // Parse messages from seal, and add them to the backlog
+        let seal: PbftSeal =
+            protobuf::parse_from_bytes(&block.payload).map_err(PbftError::SerializationError)?;
+
+        let messages =
+            seal.get_previous_commit_votes()
+                .iter()
+                .try_fold(Vec::new(), |mut msgs, v| {
+                    msgs.push(ParsedMessage::from_pbft_message(
+                        protobuf::parse_from_bytes(&v.get_message_bytes())
+                            .map_err(PbftError::SerializationError)?,
+                    ));
+                    Ok(msgs)
+                })?;",59,2018-11-19 22:32:13,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/234700400,https://github.com/hyperledger/sawtooth-pbft/pull/42#discussion_r234700400,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/42,https://github.com/hyperledger/sawtooth-pbft/pull/42,"It is not clear to me why we don't want to do catchup when we have a TentativeWorkingBlock. From what I can tell, this just means we haven't received any pre-prepare messages from the rest of the network about this block. Receiving a valid block built on the tentative working block would indicate that those messages do in fact exist and that we just haven't received them yet.",20315bc1091bb2017cd631351e0a8e6482efa662,2018-11-19 17:40:02,234715441,"@@ -445,6 +445,84 @@ impl PbftNode {
         Ok(())
     }
 
+    /// Attempts to catch this node up with its peers, if necessary
+    ///
+    /// Returns true if catching up was required, and false otherwise
+    fn try_catchup(
+        &mut self,
+        state: &mut PbftState,
+        block: &Block,
+        msg: PbftMessage,
+    ) -> Result<bool, PbftError> {
+        if state.is_primary() {
+            return Ok(false);
+        }
+
+        // If we've got a (Tentative)WorkingBlock, and the new block is immediately
+        // subsequent to it, then we're able to catch up. Otherwise, return false
+        // to signify that no catching up occurred.
+        match state.working_block.clone() {
+            WorkingBlockOption::WorkingBlock(wb) => {
+                let block_num_matches = block.block_num == wb.get_block_num() + 1;
+                let block_id_matches = block.previous_id == wb.get_block_id();
+
+                if !block_num_matches || !block_id_matches {
+                    return Ok(false);
+                }
+            }
+            WorkingBlockOption::TentativeWorkingBlock(bid) => {
+                if block.previous_id == bid {
+                    // If we've got a tentative working block, replace it with a regular working block
+                    state.working_block = WorkingBlockOption::WorkingBlock(msg.get_block().clone());
+                } else {
+                    return Ok(false);",36,2018-11-19 22:32:13,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/234715441,https://github.com/hyperledger/sawtooth-pbft/pull/42#discussion_r234715441,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/42,https://github.com/hyperledger/sawtooth-pbft/pull/42,"Lol, nevermind I just realized I was misreading this.",20315bc1091bb2017cd631351e0a8e6482efa662,2018-11-19 18:07:39,234724559,"@@ -445,6 +445,84 @@ impl PbftNode {
         Ok(())
     }
 
+    /// Attempts to catch this node up with its peers, if necessary
+    ///
+    /// Returns true if catching up was required, and false otherwise
+    fn try_catchup(
+        &mut self,
+        state: &mut PbftState,
+        block: &Block,
+        msg: PbftMessage,
+    ) -> Result<bool, PbftError> {
+        if state.is_primary() {
+            return Ok(false);
+        }
+
+        // If we've got a (Tentative)WorkingBlock, and the new block is immediately
+        // subsequent to it, then we're able to catch up. Otherwise, return false
+        // to signify that no catching up occurred.
+        match state.working_block.clone() {
+            WorkingBlockOption::WorkingBlock(wb) => {
+                let block_num_matches = block.block_num == wb.get_block_num() + 1;
+                let block_id_matches = block.previous_id == wb.get_block_id();
+
+                if !block_num_matches || !block_id_matches {
+                    return Ok(false);
+                }
+            }
+            WorkingBlockOption::TentativeWorkingBlock(bid) => {
+                if block.previous_id == bid {
+                    // If we've got a tentative working block, replace it with a regular working block
+                    state.working_block = WorkingBlockOption::WorkingBlock(msg.get_block().clone());
+                } else {
+                    return Ok(false);",36,2018-11-19 22:32:13,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/234724559,https://github.com/hyperledger/sawtooth-pbft/pull/42#discussion_r234724559,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,"@aludvik: This is here due to the fact that the `ConsensusPeerMessage` type should be treated as opaque and not constructed by PBFT code, but we still need to calculate the primary's approval of the consensus seal. Would it make sense to instead just assume that the primary is OK with the block, and not include its vote in the consensus seal, and require `2f` votes?",ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-10 16:56:58,232458592,"@@ -17,7 +17,152 @@
 
 //! Message types for PeerMessages
 
+#![allow(unknown_lints, derive_hash_xor_eq)]
+
 use std::fmt;
+use std::hash::{Hash, Hasher};
+
+use hex;
+use sawtooth_sdk::consensus::engine::PeerMessage;
+
+use crypto::digest::Digest;
+use crypto::sha2::Sha512;
+use error::PbftError;
+use protos::pbft_message::{PbftBlock, PbftMessage, PbftMessageInfo, PbftViewChange};
+
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub enum PbftMessageWrapper {
+    PbftMessage(PbftMessage),
+    PbftViewChange(PbftViewChange),
+}
+
+#[derive(Debug, PartialEq, Eq, Clone)]
+pub struct ParsedPeerMessage {
+    pub header_bytes: Vec<u8>,
+    pub header_signature: Vec<u8>,
+    pub message: PbftMessageWrapper,
+    pub message_bytes: Vec<u8>,
+}
+
+impl Hash for ParsedPeerMessage {
+    fn hash<H: Hasher>(&self, state: &mut H) {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => m.hash(state),
+            PbftMessageWrapper::PbftViewChange(m) => m.hash(state),
+        }
+    }
+}
+
+impl ParsedPeerMessage {
+    pub fn from_pbft_message(message: PbftMessage) -> Self {
+        Self {
+            message: PbftMessageWrapper::PbftMessage(message),
+            message_bytes: vec![],
+            header_bytes: vec![],
+            header_signature: vec![],
+        }
+    }
+
+    pub fn from_view_change_message(message: PbftViewChange) -> Self {
+        Self {
+            header_bytes: vec![],
+            header_signature: vec![],
+            message: PbftMessageWrapper::PbftViewChange(message),
+            message_bytes: vec![],
+        }
+    }
+
+    pub fn get_info(&self) -> &PbftMessageInfo {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => &m.get_info(),
+            PbftMessageWrapper::PbftViewChange(m) => &m.get_info(),
+        }
+    }
+
+    pub fn set_info(&mut self, info: PbftMessageInfo) {
+        match self.message {
+            PbftMessageWrapper::PbftMessage(ref mut m) => m.set_info(info),
+            PbftMessageWrapper::PbftViewChange(ref mut m) => m.set_info(info),
+        }
+    }
+
+    pub fn get_block(&self) -> &PbftBlock {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => m.get_block(),
+            PbftMessageWrapper::PbftViewChange(_) => {
+                panic!(""ParsedPeerMessage.get_block found a view change message!"")
+            }
+        }
+    }
+
+    pub fn get_pbft_message(&self) -> &PbftMessage {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => m,
+            PbftMessageWrapper::PbftViewChange(_) => {
+                panic!(""ParsedPeerMessage.get_pbft_message found a view change message!"")
+            }
+        }
+    }
+
+    pub fn get_view_change_message(&self) -> &PbftViewChange {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(_) => {
+                panic!(""ParsedPeerMessage.get_view_change_message found a pbft message!"")
+            }
+            PbftMessageWrapper::PbftViewChange(m) => m,
+        }
+    }
+
+    pub fn from_peer_message(message: PeerMessage) -> Result<Self, PbftError> {
+        verify_peer_message_hash(&message.content, &message.header.content_sha512)?;
+
+        let parsed_message = match protobuf::parse_from_bytes::<PbftMessage>(&message.content) {
+            Ok(m) => PbftMessageWrapper::PbftMessage(m),
+            Err(_) => match protobuf::parse_from_bytes::<PbftViewChange>(&message.content) {
+                Ok(m) => PbftMessageWrapper::PbftViewChange(m),
+                Err(_) => return Err(PbftError::InternalError(""Couldn't parse message!"".into())),
+            },
+        };
+
+        Ok(Self {
+            header_bytes: message.header_bytes,
+            header_signature: message.header_signature,
+            message: parsed_message,
+            message_bytes: message.content.clone(),
+        })
+    }
+
+    pub fn from_bytes(message: Vec<u8>) -> Result<Self, PbftError> {
+        let peer_message = PeerMessage {
+            content: message,
+            header_bytes: b""myself"".to_vec(),",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232458592,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232458592,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,I'm not sure I understand this change; could you explain this a little further?,ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-12 15:58:40,232713506,"@@ -56,9 +56,9 @@ message PbftMessage {
 // View change message, for when a node suspects the primary node is faulty
 message PbftViewChange {
   // Message information
-  PbftMessageInfo info = 1;
+  PbftMessageInfo info = 10;",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232713506,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232713506,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,We should probably move away from using rust-crypto altogether and use openssl instead; see this PR for more details: https://github.com/hyperledger/sawtooth-core/pull/1904,ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-12 16:01:20,232714633,"@@ -42,6 +42,7 @@ with-serde = []
 [dependencies]
 atomicwrites = ""0.2""
 clap = ""2.31""
+rust-crypto = ""0.2""",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232714633,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232714633,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,Is skipping the appropriate behavior? Shouldn't this message be rejected or handled in some way if it's not formatted properly?,ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-12 16:35:51,232728377,"@@ -17,7 +17,152 @@
 
 //! Message types for PeerMessages
 
+#![allow(unknown_lints, derive_hash_xor_eq)]
+
 use std::fmt;
+use std::hash::{Hash, Hasher};
+
+use hex;
+use sawtooth_sdk::consensus::engine::PeerMessage;
+
+use crypto::digest::Digest;
+use crypto::sha2::Sha512;
+use error::PbftError;
+use protos::pbft_message::{PbftBlock, PbftMessage, PbftMessageInfo, PbftViewChange};
+
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub enum PbftMessageWrapper {
+    PbftMessage(PbftMessage),
+    PbftViewChange(PbftViewChange),
+}
+
+#[derive(Debug, PartialEq, Eq, Clone)]
+pub struct ParsedPeerMessage {
+    pub header_bytes: Vec<u8>,
+    pub header_signature: Vec<u8>,
+    pub message: PbftMessageWrapper,
+    pub message_bytes: Vec<u8>,
+}
+
+impl Hash for ParsedPeerMessage {
+    fn hash<H: Hasher>(&self, state: &mut H) {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => m.hash(state),
+            PbftMessageWrapper::PbftViewChange(m) => m.hash(state),
+        }
+    }
+}
+
+impl ParsedPeerMessage {
+    pub fn from_pbft_message(message: PbftMessage) -> Self {
+        Self {
+            message: PbftMessageWrapper::PbftMessage(message),
+            message_bytes: vec![],
+            header_bytes: vec![],
+            header_signature: vec![],
+        }
+    }
+
+    pub fn from_view_change_message(message: PbftViewChange) -> Self {
+        Self {
+            header_bytes: vec![],
+            header_signature: vec![],
+            message: PbftMessageWrapper::PbftViewChange(message),
+            message_bytes: vec![],
+        }
+    }
+
+    pub fn get_info(&self) -> &PbftMessageInfo {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => &m.get_info(),
+            PbftMessageWrapper::PbftViewChange(m) => &m.get_info(),
+        }
+    }
+
+    pub fn set_info(&mut self, info: PbftMessageInfo) {
+        match self.message {
+            PbftMessageWrapper::PbftMessage(ref mut m) => m.set_info(info),
+            PbftMessageWrapper::PbftViewChange(ref mut m) => m.set_info(info),
+        }
+    }
+
+    pub fn get_block(&self) -> &PbftBlock {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => m.get_block(),
+            PbftMessageWrapper::PbftViewChange(_) => {
+                panic!(""ParsedPeerMessage.get_block found a view change message!"")
+            }
+        }
+    }
+
+    pub fn get_pbft_message(&self) -> &PbftMessage {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => m,
+            PbftMessageWrapper::PbftViewChange(_) => {
+                panic!(""ParsedPeerMessage.get_pbft_message found a view change message!"")
+            }
+        }
+    }
+
+    pub fn get_view_change_message(&self) -> &PbftViewChange {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(_) => {
+                panic!(""ParsedPeerMessage.get_view_change_message found a pbft message!"")
+            }
+            PbftMessageWrapper::PbftViewChange(m) => m,
+        }
+    }
+
+    pub fn from_peer_message(message: PeerMessage) -> Result<Self, PbftError> {
+        verify_peer_message_hash(&message.content, &message.header.content_sha512)?;
+
+        let parsed_message = match protobuf::parse_from_bytes::<PbftMessage>(&message.content) {
+            Ok(m) => PbftMessageWrapper::PbftMessage(m),
+            Err(_) => match protobuf::parse_from_bytes::<PbftViewChange>(&message.content) {
+                Ok(m) => PbftMessageWrapper::PbftViewChange(m),
+                Err(_) => return Err(PbftError::InternalError(""Couldn't parse message!"".into())),
+            },
+        };
+
+        Ok(Self {
+            header_bytes: message.header_bytes,
+            header_signature: message.header_signature,
+            message: parsed_message,
+            message_bytes: message.content.clone(),
+        })
+    }
+
+    pub fn from_bytes(message: Vec<u8>) -> Result<Self, PbftError> {
+        let peer_message = PeerMessage {
+            content: message,
+            header_bytes: b""myself"".to_vec(),
+            ..Default::default()
+        };
+
+        Self::from_peer_message(peer_message)
+    }
+}
+
+/// Verifies that the SHA-512 hash of the given content matches the given hash
+pub fn verify_peer_message_hash(content: &[u8], content_hash: &[u8]) -> Result<(), PbftError> {
+    let mut sha = Sha512::new();
+    sha.input(&content);
+    let computed_sha512 = hex::decode(sha.result_str()).unwrap();
+
+    if content_hash.is_empty() {
+        warn!(""Skipping hash verification due to empty content hash!"");",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232728377,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232728377,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,"Is there a reason for switching to early returns instead of nesting everything under the if statement? I think early returns should generally be avoided, but I don't have a real strong opinion about this.",ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-12 16:57:17,232736881,"@@ -465,29 +468,110 @@ impl PbftNode {
     /// Panics if `finalize_block` fails. This is necessary because it means the validator wasn't
     /// able to publish the new block.
     pub fn try_publish(&mut self, state: &mut PbftState) -> Result<(), PbftError> {
-        // Try to finalize a block
-        if state.is_primary() && state.phase == PbftPhase::NotStarted {
-            debug!(""{}: Summarizing block"", state);
-            if let Err(e) = self.service.summarize_block() {
-                debug!(
+        // Only the primary takes care of this",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232736881,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232736881,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,"I don't think this should return an error. `try_publish` gets run on every loop of the engine regardless of the node's state, so it's expected that this code will be run when the phase is NotStarted under normal conditions.",ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-12 16:58:35,232737398,"@@ -465,29 +468,110 @@ impl PbftNode {
     /// Panics if `finalize_block` fails. This is necessary because it means the validator wasn't
     /// able to publish the new block.
     pub fn try_publish(&mut self, state: &mut PbftState) -> Result<(), PbftError> {
-        // Try to finalize a block
-        if state.is_primary() && state.phase == PbftPhase::NotStarted {
-            debug!(""{}: Summarizing block"", state);
-            if let Err(e) = self.service.summarize_block() {
-                debug!(
+        // Only the primary takes care of this
+        if !state.is_primary() {
+            return Ok(());
+        }
+
+        if state.phase != PbftPhase::NotStarted {
+            return Err(PbftError::InternalError(format!(",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232737398,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232737398,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,"This condition (where `summarize_block` returns an error) should still log with `debug` and should not return an error. This is not a true error, it's just a check; it just means the block isn't ready to be finalized yet so we need to wait longer.",ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-12 17:01:16,232738443,"@@ -465,29 +468,110 @@ impl PbftNode {
     /// Panics if `finalize_block` fails. This is necessary because it means the validator wasn't
     /// able to publish the new block.
     pub fn try_publish(&mut self, state: &mut PbftState) -> Result<(), PbftError> {
-        // Try to finalize a block
-        if state.is_primary() && state.phase == PbftPhase::NotStarted {
-            debug!(""{}: Summarizing block"", state);
-            if let Err(e) = self.service.summarize_block() {
-                debug!(
+        // Only the primary takes care of this
+        if !state.is_primary() {
+            return Ok(());
+        }
+
+        if state.phase != PbftPhase::NotStarted {
+            return Err(PbftError::InternalError(format!(
+                ""Node.try_publish requires phase PbftPhase::NotStarted, got {:?}!"",
+                state.phase
+            )));
+        }
+
+        info!(""{}: Summarizing block"", state);
+
+        let summary = match self.service.summarize_block() {
+            Ok(bytes) => bytes,
+            Err(e) => {
+                warn!(
                     ""{}: Couldn't summarize, so not finalizing: {}"",
                     state,
                     e.description().to_string()",645,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232738443,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232738443,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,"Two things that aren't being checked here but should be:
1. We are not verifying the number of votes (we need to make sure there are 2f+1)
2. We are not verifying that all of the votes are from nodes in the network (we need to check this against the list of node ids stored in the node's state)",ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-12 17:09:39,232741200,"@@ -321,6 +321,87 @@ impl PbftNode {
         }
     }
 
+    /// Verifies the consensus seal from the current block, for the previous block
+    fn verify_consensus_seal(&mut self, block: &Block) -> Result<(), PbftError> {
+        // We don't publish a consensus seal until block 2, so we don't verify it
+        // until block 3
+        if block.block_num < 3 {
+            return Ok(());
+        }
+
+        if block.payload.is_empty() {
+            return Err(PbftError::InternalError(
+                ""Got empty payload for non-genesis block!"".into(),
+            ));
+        }
+
+        let seal: PbftSeal =
+            protobuf::parse_from_bytes(&block.payload).map_err(PbftError::SerializationError)?;
+
+        let id_matches = seal.previous_id == &block.previous_id[..];
+        let summary_matches = seal.summary == &block.summary[..];
+
+        if !(id_matches && summary_matches) {
+            warn!(
+                ""Consensus seal failed verification. ID matched? {} Summary matched? {}"",
+                id_matches, summary_matches
+            );
+
+            return Err(PbftError::InternalError(
+                ""Consensus seal verification error!"".into(),
+            ));
+        }
+
+        let context = create_context(""secp256k1"").unwrap();
+
+        for vote in seal.get_previous_commit_votes() {",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232741200,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232741200,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,Could you describe the purpose of this wrapper type? Is it for convenience or does it provide necessary functionality?,ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-12 17:11:32,232741797,"@@ -17,7 +17,164 @@
 
 //! Message types for PeerMessages
 
+#![allow(unknown_lints, derive_hash_xor_eq)]
+
 use std::fmt;
+use std::hash::{Hash, Hasher};
+
+use hex;
+use sawtooth_sdk::consensus::engine::PeerMessage;
+
+use crypto::digest::Digest;
+use crypto::sha2::Sha512;
+use error::PbftError;
+use protos::pbft_message::{PbftBlock, PbftMessage, PbftMessageInfo, PbftViewChange};
+
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub enum PbftMessageWrapper {
+    PbftMessage(PbftMessage),
+    PbftViewChange(PbftViewChange),
+}
+
+#[derive(Debug, PartialEq, Eq, Clone)]
+pub struct ParsedPeerMessage {",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232741797,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232741797,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,Rust convention is to not use the `get_` prefix for accessors (https://rust-lang-nursery.github.io/api-guidelines/naming.html#getter-names-follow-rust-convention-c-getter),ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-12 17:11:52,232742015,"@@ -17,7 +17,164 @@
 
 //! Message types for PeerMessages
 
+#![allow(unknown_lints, derive_hash_xor_eq)]
+
 use std::fmt;
+use std::hash::{Hash, Hasher};
+
+use hex;
+use sawtooth_sdk::consensus::engine::PeerMessage;
+
+use crypto::digest::Digest;
+use crypto::sha2::Sha512;
+use error::PbftError;
+use protos::pbft_message::{PbftBlock, PbftMessage, PbftMessageInfo, PbftViewChange};
+
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub enum PbftMessageWrapper {
+    PbftMessage(PbftMessage),
+    PbftViewChange(PbftViewChange),
+}
+
+#[derive(Debug, PartialEq, Eq, Clone)]
+pub struct ParsedPeerMessage {
+    pub header_bytes: Vec<u8>,
+    pub header_signature: Vec<u8>,
+    pub message: PbftMessageWrapper,
+    pub message_bytes: Vec<u8>,
+}
+
+impl Hash for ParsedPeerMessage {
+    fn hash<H: Hasher>(&self, state: &mut H) {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => m.hash(state),
+            PbftMessageWrapper::PbftViewChange(m) => m.hash(state),
+        }
+    }
+}
+
+impl ParsedPeerMessage {
+    pub fn from_pbft_message(message: PbftMessage) -> Self {
+        Self {
+            message: PbftMessageWrapper::PbftMessage(message),
+            message_bytes: vec![],
+            header_bytes: vec![],
+            header_signature: vec![],
+        }
+    }
+
+    pub fn from_view_change_message(message: PbftViewChange) -> Self {
+        Self {
+            header_bytes: vec![],
+            header_signature: vec![],
+            message: PbftMessageWrapper::PbftViewChange(message),
+            message_bytes: vec![],
+        }
+    }
+
+    pub fn get_info(&self) -> &PbftMessageInfo {",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232742015,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232742015,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,"Avoiding early returns comes from languages like C that make it easy to forget to clean up resources before returning from a function ([some history](https://softwareengineering.stackexchange.com/questions/118703/where-did-the-notion-of-one-return-only-come-from)). I don't think we need to borrow that pattern for safer languages, and IMO nested conditionals tend to cause unreadable heavy indentation.",ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-12 17:29:21,232747767,"@@ -465,29 +468,110 @@ impl PbftNode {
     /// Panics if `finalize_block` fails. This is necessary because it means the validator wasn't
     /// able to publish the new block.
     pub fn try_publish(&mut self, state: &mut PbftState) -> Result<(), PbftError> {
-        // Try to finalize a block
-        if state.is_primary() && state.phase == PbftPhase::NotStarted {
-            debug!(""{}: Summarizing block"", state);
-            if let Err(e) = self.service.summarize_block() {
-                debug!(
+        // Only the primary takes care of this",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232747767,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232747767,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,"I went with `get_info` to minimize the diff generated, since a fair number of places in the code already do something like `msg.get_info()`, and we're able to substitute the wrapper type without changing those. If people don't care about the larger diff I can switch that.",ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-12 17:33:26,232749179,"@@ -17,7 +17,164 @@
 
 //! Message types for PeerMessages
 
+#![allow(unknown_lints, derive_hash_xor_eq)]
+
 use std::fmt;
+use std::hash::{Hash, Hasher};
+
+use hex;
+use sawtooth_sdk::consensus::engine::PeerMessage;
+
+use crypto::digest::Digest;
+use crypto::sha2::Sha512;
+use error::PbftError;
+use protos::pbft_message::{PbftBlock, PbftMessage, PbftMessageInfo, PbftViewChange};
+
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub enum PbftMessageWrapper {
+    PbftMessage(PbftMessage),
+    PbftViewChange(PbftViewChange),
+}
+
+#[derive(Debug, PartialEq, Eq, Clone)]
+pub struct ParsedPeerMessage {
+    pub header_bytes: Vec<u8>,
+    pub header_signature: Vec<u8>,
+    pub message: PbftMessageWrapper,
+    pub message_bytes: Vec<u8>,
+}
+
+impl Hash for ParsedPeerMessage {
+    fn hash<H: Hasher>(&self, state: &mut H) {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => m.hash(state),
+            PbftMessageWrapper::PbftViewChange(m) => m.hash(state),
+        }
+    }
+}
+
+impl ParsedPeerMessage {
+    pub fn from_pbft_message(message: PbftMessage) -> Self {
+        Self {
+            message: PbftMessageWrapper::PbftMessage(message),
+            message_bytes: vec![],
+            header_bytes: vec![],
+            header_signature: vec![],
+        }
+    }
+
+    pub fn from_view_change_message(message: PbftViewChange) -> Self {
+        Self {
+            header_bytes: vec![],
+            header_signature: vec![],
+            message: PbftMessageWrapper::PbftViewChange(message),
+            message_bytes: vec![],
+        }
+    }
+
+    pub fn get_info(&self) -> &PbftMessageInfo {",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232749179,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232749179,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,"It's necessary, as it holds information that we need to use to generate the consensus seal.",ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-12 17:35:45,232749920,"@@ -17,7 +17,164 @@
 
 //! Message types for PeerMessages
 
+#![allow(unknown_lints, derive_hash_xor_eq)]
+
 use std::fmt;
+use std::hash::{Hash, Hasher};
+
+use hex;
+use sawtooth_sdk::consensus::engine::PeerMessage;
+
+use crypto::digest::Digest;
+use crypto::sha2::Sha512;
+use error::PbftError;
+use protos::pbft_message::{PbftBlock, PbftMessage, PbftMessageInfo, PbftViewChange};
+
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub enum PbftMessageWrapper {
+    PbftMessage(PbftMessage),
+    PbftViewChange(PbftViewChange),
+}
+
+#[derive(Debug, PartialEq, Eq, Clone)]
+pub struct ParsedPeerMessage {",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232749920,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232749920,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,I personally would prefer to adhere to Rust convention vs a smaller diff.,ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-12 17:57:18,232756632,"@@ -17,7 +17,164 @@
 
 //! Message types for PeerMessages
 
+#![allow(unknown_lints, derive_hash_xor_eq)]
+
 use std::fmt;
+use std::hash::{Hash, Hasher};
+
+use hex;
+use sawtooth_sdk::consensus::engine::PeerMessage;
+
+use crypto::digest::Digest;
+use crypto::sha2::Sha512;
+use error::PbftError;
+use protos::pbft_message::{PbftBlock, PbftMessage, PbftMessageInfo, PbftViewChange};
+
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub enum PbftMessageWrapper {
+    PbftMessage(PbftMessage),
+    PbftViewChange(PbftViewChange),
+}
+
+#[derive(Debug, PartialEq, Eq, Clone)]
+pub struct ParsedPeerMessage {
+    pub header_bytes: Vec<u8>,
+    pub header_signature: Vec<u8>,
+    pub message: PbftMessageWrapper,
+    pub message_bytes: Vec<u8>,
+}
+
+impl Hash for ParsedPeerMessage {
+    fn hash<H: Hasher>(&self, state: &mut H) {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => m.hash(state),
+            PbftMessageWrapper::PbftViewChange(m) => m.hash(state),
+        }
+    }
+}
+
+impl ParsedPeerMessage {
+    pub fn from_pbft_message(message: PbftMessage) -> Self {
+        Self {
+            message: PbftMessageWrapper::PbftMessage(message),
+            message_bytes: vec![],
+            header_bytes: vec![],
+            header_signature: vec![],
+        }
+    }
+
+    pub fn from_view_change_message(message: PbftViewChange) -> Self {
+        Self {
+            header_bytes: vec![],
+            header_signature: vec![],
+            message: PbftMessageWrapper::PbftViewChange(message),
+            message_bytes: vec![],
+        }
+    }
+
+    pub fn get_info(&self) -> &PbftMessageInfo {",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232756632,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232756632,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,"@aludvik: Since we can't/shouldn't create the `Consensus*` protobuf messages ourselves, we can't test this without having logic in the test function specific to unit tests, which isn't great. On the other hand, if we allowed PBFT to create `Consensus*` protobuf messages, that would allow testing here, as well as fixing the issue elsewhere where a node will send itself a message and we currently just insert a special `""myself""` value to indicate where the message came from.",ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-12 19:34:01,232785382,"@@ -1012,15 +1084,16 @@ mod tests {
         );
         assert_eq!(state1.seq_num, 0);
 
-        // Try a block way in the future (push to backlog)
-        let mut node1 = mock_node(1);
-        let mut state1 = PbftState::new(1, &cfg);
-        node1
-            .on_block_new(mock_block(7), &mut state1)
-            .unwrap_or_else(handle_pbft_err);
-        assert_eq!(state1.phase, PbftPhase::NotStarted);
-        assert_eq!(state1.working_block, WorkingBlockOption::NoWorkingBlock);
-        assert_eq!(state1.seq_num, 0);
+        // TODO: Currently broken",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232785382,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232785382,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,"This is happening due to us constructing messages that the nodes send to themselves, and we shouldn't be constructing `Consensus*` protobuf messages from within PBFT, so e.g. the header_signature is just an empty vec of bytes. This will hopefully go away, depending on the results of that discussion.",ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-12 19:39:01,232786909,"@@ -17,7 +17,152 @@
 
 //! Message types for PeerMessages
 
+#![allow(unknown_lints, derive_hash_xor_eq)]
+
 use std::fmt;
+use std::hash::{Hash, Hasher};
+
+use hex;
+use sawtooth_sdk::consensus::engine::PeerMessage;
+
+use crypto::digest::Digest;
+use crypto::sha2::Sha512;
+use error::PbftError;
+use protos::pbft_message::{PbftBlock, PbftMessage, PbftMessageInfo, PbftViewChange};
+
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub enum PbftMessageWrapper {
+    PbftMessage(PbftMessage),
+    PbftViewChange(PbftViewChange),
+}
+
+#[derive(Debug, PartialEq, Eq, Clone)]
+pub struct ParsedPeerMessage {
+    pub header_bytes: Vec<u8>,
+    pub header_signature: Vec<u8>,
+    pub message: PbftMessageWrapper,
+    pub message_bytes: Vec<u8>,
+}
+
+impl Hash for ParsedPeerMessage {
+    fn hash<H: Hasher>(&self, state: &mut H) {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => m.hash(state),
+            PbftMessageWrapper::PbftViewChange(m) => m.hash(state),
+        }
+    }
+}
+
+impl ParsedPeerMessage {
+    pub fn from_pbft_message(message: PbftMessage) -> Self {
+        Self {
+            message: PbftMessageWrapper::PbftMessage(message),
+            message_bytes: vec![],
+            header_bytes: vec![],
+            header_signature: vec![],
+        }
+    }
+
+    pub fn from_view_change_message(message: PbftViewChange) -> Self {
+        Self {
+            header_bytes: vec![],
+            header_signature: vec![],
+            message: PbftMessageWrapper::PbftViewChange(message),
+            message_bytes: vec![],
+        }
+    }
+
+    pub fn get_info(&self) -> &PbftMessageInfo {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => &m.get_info(),
+            PbftMessageWrapper::PbftViewChange(m) => &m.get_info(),
+        }
+    }
+
+    pub fn set_info(&mut self, info: PbftMessageInfo) {
+        match self.message {
+            PbftMessageWrapper::PbftMessage(ref mut m) => m.set_info(info),
+            PbftMessageWrapper::PbftViewChange(ref mut m) => m.set_info(info),
+        }
+    }
+
+    pub fn get_block(&self) -> &PbftBlock {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => m.get_block(),
+            PbftMessageWrapper::PbftViewChange(_) => {
+                panic!(""ParsedPeerMessage.get_block found a view change message!"")
+            }
+        }
+    }
+
+    pub fn get_pbft_message(&self) -> &PbftMessage {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => m,
+            PbftMessageWrapper::PbftViewChange(_) => {
+                panic!(""ParsedPeerMessage.get_pbft_message found a view change message!"")
+            }
+        }
+    }
+
+    pub fn get_view_change_message(&self) -> &PbftViewChange {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(_) => {
+                panic!(""ParsedPeerMessage.get_view_change_message found a pbft message!"")
+            }
+            PbftMessageWrapper::PbftViewChange(m) => m,
+        }
+    }
+
+    pub fn from_peer_message(message: PeerMessage) -> Result<Self, PbftError> {
+        verify_peer_message_hash(&message.content, &message.header.content_sha512)?;
+
+        let parsed_message = match protobuf::parse_from_bytes::<PbftMessage>(&message.content) {
+            Ok(m) => PbftMessageWrapper::PbftMessage(m),
+            Err(_) => match protobuf::parse_from_bytes::<PbftViewChange>(&message.content) {
+                Ok(m) => PbftMessageWrapper::PbftViewChange(m),
+                Err(_) => return Err(PbftError::InternalError(""Couldn't parse message!"".into())),
+            },
+        };
+
+        Ok(Self {
+            header_bytes: message.header_bytes,
+            header_signature: message.header_signature,
+            message: parsed_message,
+            message_bytes: message.content.clone(),
+        })
+    }
+
+    pub fn from_bytes(message: Vec<u8>) -> Result<Self, PbftError> {
+        let peer_message = PeerMessage {
+            content: message,
+            header_bytes: b""myself"".to_vec(),
+            ..Default::default()
+        };
+
+        Self::from_peer_message(peer_message)
+    }
+}
+
+/// Verifies that the SHA-512 hash of the given content matches the given hash
+pub fn verify_peer_message_hash(content: &[u8], content_hash: &[u8]) -> Result<(), PbftError> {
+    let mut sha = Sha512::new();
+    sha.input(&content);
+    let computed_sha512 = hex::decode(sha.result_str()).unwrap();
+
+    if content_hash.is_empty() {
+        warn!(""Skipping hash verification due to empty content hash!"");",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232786909,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232786909,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,I also do not understand this change. Typically we want to avoid re-numbering these fields.,ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-12 20:01:23,232793683,"@@ -56,9 +56,9 @@ message PbftMessage {
 // View change message, for when a node suspects the primary node is faulty
 message PbftViewChange {
   // Message information
-  PbftMessageInfo info = 1;
+  PbftMessageInfo info = 10;",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232793683,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232793683,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,Constructing the seal should be handled in a separate function.,ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-13 00:35:23,232859349,"@@ -465,29 +466,110 @@ impl PbftNode {
     /// Panics if `finalize_block` fails. This is necessary because it means the validator wasn't
     /// able to publish the new block.
     pub fn try_publish(&mut self, state: &mut PbftState) -> Result<(), PbftError> {
-        // Try to finalize a block
-        if state.is_primary() && state.phase == PbftPhase::NotStarted {
-            debug!(""{}: Summarizing block"", state);
-            if let Err(e) = self.service.summarize_block() {
-                debug!(
+        // Only the primary takes care of this
+        if !state.is_primary() {
+            return Ok(());
+        }
+
+        if state.phase != PbftPhase::NotStarted {
+            return Err(PbftError::InternalError(format!(
+                ""Node.try_publish requires phase PbftPhase::NotStarted, got {:?}!"",
+                state.phase
+            )));
+        }
+
+        info!(""{}: Summarizing block"", state);
+
+        let summary = match self.service.summarize_block() {
+            Ok(bytes) => bytes,
+            Err(e) => {
+                warn!(
                     ""{}: Couldn't summarize, so not finalizing: {}"",
                     state,
                     e.description().to_string()
                 );
-            } else {
-                debug!(""{}: Trying to finalize block"", state);
-                match self.service.finalize_block(vec![]) {
-                    Ok(block_id) => {
-                        info!(""{}: Publishing block {:?}"", state, block_id);
-                    }
-                    Err(EngineError::BlockNotReady) => {
-                        debug!(""{}: Block not ready"", state);
-                    }
-                    Err(err) => panic!(""Failed to finalize block: {:?}"", err),
-                }
+                return Err(PbftError::InternalError(""Couldn't summarize block!"".into()));
+            }
+        };
+
+        let head = self
+            .service
+            .get_chain_head()
+            .map_err(|err| PbftError::InternalError(format!(""Couldn't get chain head: {}"", err)))?;
+
+        // We don't publish a consensus seal until block 2, since we never receive any
+        // votes on the genesis block. Leave payload blank for these early blocks.
+        let data = if head.block_num < 2 {",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232859349,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232859349,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,"Using ""myself"" here is actually a bigger problem than I first thought, because if you try to include your own vote in the consensus seal, other nodes validating it will fail.",ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-13 00:46:34,232861258,"@@ -17,7 +17,152 @@
 
 //! Message types for PeerMessages
 
+#![allow(unknown_lints, derive_hash_xor_eq)]
+
 use std::fmt;
+use std::hash::{Hash, Hasher};
+
+use hex;
+use sawtooth_sdk::consensus::engine::PeerMessage;
+
+use crypto::digest::Digest;
+use crypto::sha2::Sha512;
+use error::PbftError;
+use protos::pbft_message::{PbftBlock, PbftMessage, PbftMessageInfo, PbftViewChange};
+
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub enum PbftMessageWrapper {
+    PbftMessage(PbftMessage),
+    PbftViewChange(PbftViewChange),
+}
+
+#[derive(Debug, PartialEq, Eq, Clone)]
+pub struct ParsedPeerMessage {
+    pub header_bytes: Vec<u8>,
+    pub header_signature: Vec<u8>,
+    pub message: PbftMessageWrapper,
+    pub message_bytes: Vec<u8>,
+}
+
+impl Hash for ParsedPeerMessage {
+    fn hash<H: Hasher>(&self, state: &mut H) {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => m.hash(state),
+            PbftMessageWrapper::PbftViewChange(m) => m.hash(state),
+        }
+    }
+}
+
+impl ParsedPeerMessage {
+    pub fn from_pbft_message(message: PbftMessage) -> Self {
+        Self {
+            message: PbftMessageWrapper::PbftMessage(message),
+            message_bytes: vec![],
+            header_bytes: vec![],
+            header_signature: vec![],
+        }
+    }
+
+    pub fn from_view_change_message(message: PbftViewChange) -> Self {
+        Self {
+            header_bytes: vec![],
+            header_signature: vec![],
+            message: PbftMessageWrapper::PbftViewChange(message),
+            message_bytes: vec![],
+        }
+    }
+
+    pub fn get_info(&self) -> &PbftMessageInfo {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => &m.get_info(),
+            PbftMessageWrapper::PbftViewChange(m) => &m.get_info(),
+        }
+    }
+
+    pub fn set_info(&mut self, info: PbftMessageInfo) {
+        match self.message {
+            PbftMessageWrapper::PbftMessage(ref mut m) => m.set_info(info),
+            PbftMessageWrapper::PbftViewChange(ref mut m) => m.set_info(info),
+        }
+    }
+
+    pub fn get_block(&self) -> &PbftBlock {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => m.get_block(),
+            PbftMessageWrapper::PbftViewChange(_) => {
+                panic!(""ParsedPeerMessage.get_block found a view change message!"")
+            }
+        }
+    }
+
+    pub fn get_pbft_message(&self) -> &PbftMessage {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(m) => m,
+            PbftMessageWrapper::PbftViewChange(_) => {
+                panic!(""ParsedPeerMessage.get_pbft_message found a view change message!"")
+            }
+        }
+    }
+
+    pub fn get_view_change_message(&self) -> &PbftViewChange {
+        match &self.message {
+            PbftMessageWrapper::PbftMessage(_) => {
+                panic!(""ParsedPeerMessage.get_view_change_message found a pbft message!"")
+            }
+            PbftMessageWrapper::PbftViewChange(m) => m,
+        }
+    }
+
+    pub fn from_peer_message(message: PeerMessage) -> Result<Self, PbftError> {
+        verify_peer_message_hash(&message.content, &message.header.content_sha512)?;
+
+        let parsed_message = match protobuf::parse_from_bytes::<PbftMessage>(&message.content) {
+            Ok(m) => PbftMessageWrapper::PbftMessage(m),
+            Err(_) => match protobuf::parse_from_bytes::<PbftViewChange>(&message.content) {
+                Ok(m) => PbftMessageWrapper::PbftViewChange(m),
+                Err(_) => return Err(PbftError::InternalError(""Couldn't parse message!"".into())),
+            },
+        };
+
+        Ok(Self {
+            header_bytes: message.header_bytes,
+            header_signature: message.header_signature,
+            message: parsed_message,
+            message_bytes: message.content.clone(),
+        })
+    }
+
+    pub fn from_bytes(message: Vec<u8>) -> Result<Self, PbftError> {
+        let peer_message = PeerMessage {
+            content: message,
+            header_bytes: b""myself"".to_vec(),",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/232861258,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r232861258,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,"It was an attempt at having the protobuf parsing be easier, since protobuf will happily parse one message type with `PbftMessageInfo info = 1;` as another message type with the same field. Unfortunately since we're using `proto3`, this didn't end up making the parsing easier, since any missing fields will just get silently ignored, and proto3 dropped support for `required`. Long story short, it didn't end up improving parsing at all, and has been removed.",ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-13 16:21:21,233116804,"@@ -56,9 +56,9 @@ message PbftMessage {
 // View change message, for when a node suspects the primary node is faulty
 message PbftViewChange {
   // Message information
-  PbftMessageInfo info = 1;
+  PbftMessageInfo info = 10;",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/233116804,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r233116804,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,"I think you need to validate the seal starting at block 2.
Block 0 - Genesis
Block 1 - First PBFT block
Block 2 - Second PBFT block, should contain votes for block 1",ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-14 20:08:35,233601578,"@@ -315,6 +319,132 @@ impl PbftNode {
         }
     }
 
+    /// Verifies an individual consensus vote
+    ///
+    /// Returns the signer ID of the wrapped PbftMessage, for use in further verification
+    fn verify_consensus_vote(
+        vote: &PbftSignedCommitVote,
+        seal: &PbftSeal,
+    ) -> Result<Vec<u8>, PbftError> {
+        let message: PbftMessage = protobuf::parse_from_bytes(&vote.get_message_bytes())
+            .map_err(PbftError::SerializationError)?;
+
+        if message.get_block().block_id != seal.previous_id {
+            return Err(PbftError::InternalError(format!(
+                ""PbftMessage block ID ({:?}) doesn't match seal's previous id ({:?})!"",
+                message.get_block().get_block_id(),
+                seal.previous_id
+            )));
+        }
+
+        let header: ConsensusPeerMessageHeader =
+            protobuf::parse_from_bytes(&vote.get_header_bytes())
+                .map_err(PbftError::SerializationError)?;
+
+        let key = Secp256k1PublicKey::from_hex(&hex::encode(&header.signer_id)).unwrap();
+
+        let context = create_context(""secp256k1"")
+            .map_err(|err| PbftError::InternalError(format!(""Couldn't create context: {}"", err)))?;
+
+        match context.verify(
+            &hex::encode(vote.get_header_signature()),
+            vote.get_header_bytes(),
+            &key,
+        ) {
+            Ok(true) => {}
+            Ok(false) => {
+                return Err(PbftError::InternalError(
+                    ""Header failed verification!"".into(),
+                ))
+            }
+            Err(err) => {
+                return Err(PbftError::InternalError(format!(
+                    ""Error while verifying header: {:?}"",
+                    err
+                )))
+            }
+        }
+
+        verify_sha512(vote.get_message_bytes(), header.get_content_sha512())?;
+
+        Ok(message.get_info().get_signer_id().to_vec())
+    }
+
+    /// Verifies the consensus seal from the current block, for the previous block
+    fn verify_consensus_seal(
+        &mut self,
+        block: &Block,
+        state: &mut PbftState,
+    ) -> Result<(), PbftError> {
+        // We don't publish a consensus seal until block 2, so we don't verify it
+        // until block 3
+        if block.block_num < 3 {",,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/233601578,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r233601578,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,This looks like a lint fix; should be in a separate commit (also line 228).,ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-14 20:22:21,233605834,"@@ -142,11 +142,7 @@ impl PbftLog {
     ///  + A `PrePrepare` message matching the original message (in the current view)
     ///  + `2f + 1` matching `Prepare` messages from different nodes that match
     ///    `PrePrepare` message above (including its own)
-    pub fn check_prepared(
-        &self,
-        pbft_message: &ParsedMessage,
-        f: u64,
-    ) -> Result<(), PbftError> {
+    pub fn check_prepared(&self, pbft_message: &ParsedMessage, f: u64) -> Result<(), PbftError> {",75,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/233605834,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r233605834,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,This looks like a lint fix; should be in a separate commit.,ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-14 20:22:46,233605978,"@@ -23,8 +23,8 @@ use std::fmt;
 use std::hash::{Hash, Hasher};
 
 use hash::verify_sha512;
-use sawtooth_sdk::consensus::engine::PeerMessage;
 use protobuf::Message;
+use sawtooth_sdk::consensus::engine::PeerMessage;",11,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/233605978,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r233605978,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,"I'm not sure I understand, as this is just introducing new code. Did the review get weird with force pushing up new commits maybe?",ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-14 20:39:24,233611108,"@@ -23,8 +23,8 @@ use std::fmt;
 use std::hash::{Hash, Hasher};
 
 use hash::verify_sha512;
-use sawtooth_sdk::consensus::engine::PeerMessage;
 use protobuf::Message;
+use sawtooth_sdk::consensus::engine::PeerMessage;",11,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/233611108,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r233611108,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/38,https://github.com/hyperledger/sawtooth-pbft/pull/38,"Ah sorry. When this comment is viewed from the main conversation, it shows all of the commits together, which makes it look like the comment is sitting in the middle of all new code",ae815c1ee4864b1f8ae8e9f58bd6f9f5ed652984,2018-11-14 20:44:33,233612650,"@@ -23,8 +23,8 @@ use std::fmt;
 use std::hash::{Hash, Hasher};
 
 use hash::verify_sha512;
-use sawtooth_sdk::consensus::engine::PeerMessage;
 use protobuf::Message;
+use sawtooth_sdk::consensus::engine::PeerMessage;",11,2018-11-14 20:46:18,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/233612650,https://github.com/hyperledger/sawtooth-pbft/pull/38#discussion_r233612650,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/33,https://github.com/hyperledger/sawtooth-pbft/pull/33,"These and the below changes will go away as soon as we've published the latest Go SDK packages, and shouldn't be merged as-is.",263a4f4766282f936d8bac7d5bf0e8c010b2a867,2018-11-01 16:06:58,230098443,"@@ -35,12 +38,18 @@ RUN echo ""deb [arch=amd64] http://repo.sawtooth.me/ubuntu/nightly xenial univers
     python3-requests \
     python3-nose2 \
     sawtooth-smallbank-workload \
-    sawtooth-smallbank-tp-go \
-    sawtooth-xo-tp-go \
+#    sawtooth-smallbank-tp-go \",21,2018-11-01 16:06:58,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/230098443,https://github.com/hyperledger/sawtooth-pbft/pull/33#discussion_r230098443,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/30,https://github.com/hyperledger/sawtooth-pbft/pull/30,Should be `Popping message {:?} from backlog`,d142c446a21163db74c0cbb905effcc7886a362a,2018-10-31 17:27:57,229793863,"@@ -600,8 +612,8 @@ impl PbftNode {
         let mut peer_res = Ok(());
         if let Some((msg, sender_id)) = self.msg_log.pop_backlog() {
             debug!(
-                ""{}: Popping from backlog {} from {:?}"",
-                state, msg.message_type, sender_id
+                ""{}: Popping message from {:?} from backlog"",",102,2018-11-01 18:08:51,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/229793863,https://github.com/hyperledger/sawtooth-pbft/pull/30#discussion_r229793863,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/30,https://github.com/hyperledger/sawtooth-pbft/pull/30,"The `{:?}` here is the sender ID, so it should end up looking like `Popping message from $SENDERID from backlog`, which seems correct (or at least readable) to me",d142c446a21163db74c0cbb905effcc7886a362a,2018-10-31 17:31:06,229795086,"@@ -600,8 +612,8 @@ impl PbftNode {
         let mut peer_res = Ok(());
         if let Some((msg, sender_id)) = self.msg_log.pop_backlog() {
             debug!(
-                ""{}: Popping from backlog {} from {:?}"",
-                state, msg.message_type, sender_id
+                ""{}: Popping message from {:?} from backlog"",",102,2018-11-01 18:08:51,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/229795086,https://github.com/hyperledger/sawtooth-pbft/pull/30#discussion_r229795086,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/30,https://github.com/hyperledger/sawtooth-pbft/pull/30,My bad!,d142c446a21163db74c0cbb905effcc7886a362a,2018-10-31 17:36:24,229797071,"@@ -600,8 +612,8 @@ impl PbftNode {
         let mut peer_res = Ok(());
         if let Some((msg, sender_id)) = self.msg_log.pop_backlog() {
             debug!(
-                ""{}: Popping from backlog {} from {:?}"",
-                state, msg.message_type, sender_id
+                ""{}: Popping message from {:?} from backlog"",",102,2018-11-01 18:08:51,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/229797071,https://github.com/hyperledger/sawtooth-pbft/pull/30#discussion_r229797071,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/28,https://github.com/hyperledger/sawtooth-pbft/pull/28,"I think this description might be slightly misleading - the `committed` predicate is only checking if it's ready to enter the  `Committing` phase, right? Not necessarily anything to do with committing blocks yet?",994ce87a90b08ad5844951a240e57853e910f85e,2018-10-31 01:33:14,229540509,"@@ -217,17 +217,18 @@ impl PbftLog {
         Ok(())
     }
 
-    /// ""committed"" predicate
-    /// `committed` is true if for this node:
-    ///   + `prepared` is true
+    /// Checks whether or not a block referred to by the given message is able to be committed",,2018-11-01 18:33:15,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/229540509,https://github.com/hyperledger/sawtooth-pbft/pull/28#discussion_r229540509,bridger-herman
https://github.com/hyperledger/sawtooth-pbft/pull/28,https://github.com/hyperledger/sawtooth-pbft/pull/28,"Do you have better phrasing for that? I just meant that it checks that we can move forward with committing the current working block, but my phrasing is definitely a little vague, and potentially incorrect",994ce87a90b08ad5844951a240e57853e910f85e,2018-10-31 04:46:10,229562657,"@@ -217,17 +217,18 @@ impl PbftLog {
         Ok(())
     }
 
-    /// ""committed"" predicate
-    /// `committed` is true if for this node:
-    ///   + `prepared` is true
+    /// Checks whether or not a block referred to by the given message is able to be committed",,2018-11-01 18:33:15,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/229562657,https://github.com/hyperledger/sawtooth-pbft/pull/28#discussion_r229562657,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/28,https://github.com/hyperledger/sawtooth-pbft/pull/28,"How about ""Checks if the node is ready to enter the `Committing` phase based on the `PbftMessage` received""?",994ce87a90b08ad5844951a240e57853e910f85e,2018-10-31 18:07:52,229809800,"@@ -217,17 +217,18 @@ impl PbftLog {
         Ok(())
     }
 
-    /// ""committed"" predicate
-    /// `committed` is true if for this node:
-    ///   + `prepared` is true
+    /// Checks whether or not a block referred to by the given message is able to be committed",,2018-11-01 18:33:15,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/229809800,https://github.com/hyperledger/sawtooth-pbft/pull/28#discussion_r229809800,bridger-herman
https://github.com/hyperledger/sawtooth-pbft/pull/28,https://github.com/hyperledger/sawtooth-pbft/pull/28,👍 updated,994ce87a90b08ad5844951a240e57853e910f85e,2018-10-31 18:44:14,229822870,"@@ -217,17 +217,18 @@ impl PbftLog {
         Ok(())
     }
 
-    /// ""committed"" predicate
-    /// `committed` is true if for this node:
-    ///   + `prepared` is true
+    /// Checks whether or not a block referred to by the given message is able to be committed",,2018-11-01 18:33:15,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/229822870,https://github.com/hyperledger/sawtooth-pbft/pull/28#discussion_r229822870,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/21,https://github.com/hyperledger/sawtooth-pbft/pull/21,I do wonder why this chown was added.,7e5e2053839e0dff9012596d9cea5fbbeda38501,2018-11-08 16:30:13,231965430,"@@ -94,10 +94,9 @@ pipeline {
             }
         }
 
-        stage('Build deb') {
-            steps {
-                sh ""docker-compose run --rm sawtooth-pbft bash -c \""cargo deb && cp target/debian/*.deb ./ && chown ${JENKINS_UID} ./*.deb\""""",7,2018-11-09 20:16:19,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/231965430,https://github.com/hyperledger/sawtooth-pbft/pull/21#discussion_r231965430,rberg2
https://github.com/hyperledger/sawtooth-pbft/pull/15,https://github.com/hyperledger/sawtooth-pbft/pull/15,"Is there a need for this file? I avoided using the existing `Dockerfile-installed` in the Jenkinsfile due to the fact that `cargo deb` ran just fine in the regular `Dockerfile`. It also seems like we'll be introducing dockerfiles built for pushing to docker hub at some point given that we're doing that currently for other projects, so it seems like we can get away without this, and removing the `Dockerfile-installed` as well.",5c23aac160dbe94c7a40ebab9ea0d4026dc8264f,2018-10-24 18:50:16,227916774,"@@ -0,0 +1,28 @@
+# Copyright 2018 Cargill Incorporated",1,2018-10-24 19:28:04,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/227916774,https://github.com/hyperledger/sawtooth-pbft/pull/15#discussion_r227916774,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/15,https://github.com/hyperledger/sawtooth-pbft/pull/15,"I would argue that we should start going the other way and move `handlers.rs` into this file. Yeah it's going to be a big file (though we can cut the size down a bit by moving the tests around), but splitting the definition of an object over multiple files just because it's big rubs me the wrong way.",5c23aac160dbe94c7a40ebab9ea0d4026dc8264f,2018-10-24 19:02:34,227920745,"@@ -598,10 +614,15 @@ impl PbftNode {
         peer_res
     }
 
+    pub fn force_view_change(&mut self, state: &mut PbftState) {
+        info!(""{}: Forcing view change"", state);
+        handlers::force_view_change(state, &mut *self.service)",94,2018-10-24 19:28:04,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/227920745,https://github.com/hyperledger/sawtooth-pbft/pull/15#discussion_r227920745,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/15,https://github.com/hyperledger/sawtooth-pbft/pull/15,"Yes. Including a local and an installed Dockerfile is the standard, recommended pattern for all packages. Proving a docker-compose file to build each is also standard and should be the expected way to build docker images for a repo.",5c23aac160dbe94c7a40ebab9ea0d4026dc8264f,2018-10-24 19:39:20,227932366,"@@ -0,0 +1,28 @@
+# Copyright 2018 Cargill Incorporated",1,2018-10-24 19:39:20,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/227932366,https://github.com/hyperledger/sawtooth-pbft/pull/15#discussion_r227932366,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/15,https://github.com/hyperledger/sawtooth-pbft/pull/15,"As far as I can tell right now, there is no clean separation of concerns between the engine, node, state, and handlers. This is as consistent with the existing organization as I could get without embarking on a large scale refactoring to better separate concerns. I'd be up for having a discussion about to do the reorganization.",5c23aac160dbe94c7a40ebab9ea0d4026dc8264f,2018-10-24 19:40:58,227932886,"@@ -598,10 +614,15 @@ impl PbftNode {
         peer_res
     }
 
+    pub fn force_view_change(&mut self, state: &mut PbftState) {
+        info!(""{}: Forcing view change"", state);
+        handlers::force_view_change(state, &mut *self.service)",94,2018-10-24 19:40:58,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/227932886,https://github.com/hyperledger/sawtooth-pbft/pull/15#discussion_r227932886,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/15,https://github.com/hyperledger/sawtooth-pbft/pull/15,"@rbuysse helpfully explained what the purpose of the `*-installed` dockerfiles are for, and I've got a proposal over in #19 that would eliminate the `installed` dockerfile (but not the `installed` docker compose file). At any rate, that doesn't affect this PR at all, so 👍.",5c23aac160dbe94c7a40ebab9ea0d4026dc8264f,2018-10-25 19:27:56,228304943,"@@ -0,0 +1,28 @@
+# Copyright 2018 Cargill Incorporated",1,2018-10-25 19:27:56,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/228304943,https://github.com/hyperledger/sawtooth-pbft/pull/15#discussion_r228304943,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/15,https://github.com/hyperledger/sawtooth-pbft/pull/15,"I was just thinking of having the logic over here (or keeping the logic over in `handlers` and calling `handlers::force_view_change` directly from other code instead of creating the `Node::force_view_change` proxy), not advocating for a large-scale refactoring right now.",5c23aac160dbe94c7a40ebab9ea0d4026dc8264f,2018-10-25 19:31:26,228305926,"@@ -598,10 +614,15 @@ impl PbftNode {
         peer_res
     }
 
+    pub fn force_view_change(&mut self, state: &mut PbftState) {
+        info!(""{}: Forcing view change"", state);
+        handlers::force_view_change(state, &mut *self.service)",94,2018-10-25 19:31:26,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/228305926,https://github.com/hyperledger/sawtooth-pbft/pull/15#discussion_r228305926,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/13,https://github.com/hyperledger/sawtooth-pbft/pull/13,"I think these formatting fixes can get merged into the previous commit, it looks like that's the one that introduced this line",61dcd405b50cb7159d6c9a7227b4084f33de7fcf,2018-10-23 15:29:54,227446920,"@@ -95,18 +95,19 @@ fn main() {
 
     let (driver, _stop) = ZmqDriver::new();
 
-    driver.start(&args.endpoint, pbft_engine).unwrap_or_else(|err| {
-        error!(""{}"", err);
-        process::exit(1);
-    });
+    driver
+        .start(&args.endpoint, pbft_engine)
+        .unwrap_or_else(|err| {
+            error!(""{}"", err);
+            process::exit(1);
+        });
 }
 
 fn get_console_config(log_level: log::LevelFilter) -> Config {
     let stdout = ConsoleAppender::builder()
         .encoder(Box::new(PatternEncoder::new(
             ""{h({l:5.5})} | {({M}:{L}):20.20} | {m}{n}"",
-        )))
-        .build();
+        ))).build();",76,2018-10-23 15:38:13,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/227446920,https://github.com/hyperledger/sawtooth-pbft/pull/13#discussion_r227446920,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/13,https://github.com/hyperledger/sawtooth-pbft/pull/13,Fixed,61dcd405b50cb7159d6c9a7227b4084f33de7fcf,2018-10-23 15:35:43,227449345,"@@ -95,18 +95,19 @@ fn main() {
 
     let (driver, _stop) = ZmqDriver::new();
 
-    driver.start(&args.endpoint, pbft_engine).unwrap_or_else(|err| {
-        error!(""{}"", err);
-        process::exit(1);
-    });
+    driver
+        .start(&args.endpoint, pbft_engine)
+        .unwrap_or_else(|err| {
+            error!(""{}"", err);
+            process::exit(1);
+        });
 }
 
 fn get_console_config(log_level: log::LevelFilter) -> Config {
     let stdout = ConsoleAppender::builder()
         .encoder(Box::new(PatternEncoder::new(
             ""{h({l:5.5})} | {({M}:{L}):20.20} | {m}{n}"",
-        )))
-        .build();
+        ))).build();",76,2018-10-23 15:38:13,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/227449345,https://github.com/hyperledger/sawtooth-pbft/pull/13#discussion_r227449345,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/9,https://github.com/hyperledger/sawtooth-pbft/pull/9,Copy pasta: should be `$SAWTOOTH_PBFT`,5548fcb3bf0c2d15a04eef376eb3ac9011940811,2018-10-19 15:48:47,226694773,"@@ -0,0 +1,138 @@
+# Copyright 2018 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+# ------------------------------------------------------------------------------
+
+version: ""3.6""
+
+# Validators across all compose files join this docker network for inter-node
+# communication
+networks:
+  validators:
+    external:
+      name: pbft_validators
+  rest_apis:
+    external:
+      name: pbft_rest_apis
+
+volumes:
+  pbft_shared_data:
+    external: true
+
+services:
+
+  validator:
+    image: sawtooth-validator
+    labels:
+      - ""com.sawtooth.isolation_id=${ISOLATION_ID:-}""
+    command: ""bash -c \""\
+      if [ ! -e /etc/sawtooth/keys/validator.pub ]; then sawadm keygen; fi && \
+      if [ ! -e /shared_data/validators/$$(hostname) ]; then \
+        cat /etc/sawtooth/keys/validator.pub > /shared_data/validators/$$(hostname); \
+      fi && \
+      echo \\\""-- /var/lib/sawtooth\\\"" && ls /var/lib/sawtooth && \
+      echo \\\""-- /shared_data/validators \\\"" && ls /shared_data/validators && \
+      if [ ${GENESIS:-0} != 0 -a ! -e /shared_data/genesis.batch ]; then \
+        echo \\\""Running Genesis\\\"" && \
+        sawset genesis \
+          -k /shared_data/keys/settings.priv \
+          -o config-genesis.batch && \
+        sawset proposal create \
+          -k /shared_data/keys/settings.priv \
+          sawtooth.consensus.algorithm=pbft \
+          sawtooth.consensus.pbft.peers=\\['\\\""'$$(cd /shared_data/validators && paste $$(ls -1) -d , | sed s/,/\\\\\\\"",\\\\\\\""/g)'\\\""'\\]
+          -o config.batch && \
+        sawadm genesis \
+          config-genesis.batch config.batch && \
+        cp /var/lib/sawtooth/genesis.batch /shared_data/genesis.batch && \
+        ls /var/lib/sawtooth; \
+      fi && \
+      export PEERS=$$(for host in $$(ls /shared_data/validators -1); do \
+            if [ $$host != $$(hostname) ]; then \
+              echo \\\""tcp://$$host:8800\\\""; \
+            fi; done | tr \\\""\n\\\"" \\\"",\\\"" | sed s\\/,$$\\/\\\n\\/); \
+      echo \\\""-- PEERS \\\"" && echo \\\""PEERS=$$PEERS\\\""; \
+      if [ \\\""$$PEERS\\\"" = \\\""\\\"" ]; then \
+        echo \\\""No peers to connect to...\\\"";
+        sawtooth-validator -vv \
+            --endpoint tcp://$$(hostname):8800 \
+            --bind component:tcp://eth0:4004 \
+            --bind network:tcp://eth1:8800 \
+            --bind consensus:tcp://eth0:5050 \
+            --peering static \
+            --scheduler parallel; \
+      else \
+        echo \\\""Connecting to $$PEERS\\\"";
+        sawtooth-validator -vv \
+            --endpoint tcp://$$(hostname):8800 \
+            --bind component:tcp://eth0:4004 \
+            --bind network:tcp://eth1:8800 \
+            --bind consensus:tcp://eth0:5050 \
+            --peering static \
+            --peers $$PEERS \
+            --scheduler parallel; \
+      fi \
+    \""""
+    volumes:
+      - pbft_shared_data:/shared_data
+    networks:
+      default:
+      validators:
+    expose:
+      - 8800
+    stop_signal: SIGKILL
+
+  pbft:
+    image: sawtooth-pbft-engine-local
+    labels:
+      - ""com.sawtooth.isolation_id=${ISOLATION_ID:-}""
+    build:
+      context: .
+      dockerfile: ../Dockerfile
+    volumes:
+      - ${SAWOOTH_RAFT:-..}:/project/sawtooth-pbft",,2018-10-19 15:53:43,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/226694773,https://github.com/hyperledger/sawtooth-pbft/pull/9#discussion_r226694773,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/7,https://github.com/hyperledger/sawtooth-pbft/pull/7,Just opened https://github.com/hyperledger/sawtooth-core/pull/1905 to be able to do `msg.clone()`,dabce661fec7c3c8ce544abca8c92bfcb7d2293a,2018-10-17 20:04:23,226075633,"@@ -265,13 +315,16 @@ impl PbftNode {
         }
     }
 
-    fn check_if_checkpoint_started(&mut self, msg: &PeerMessage) -> bool {
+    fn check_if_checkpoint_started(&mut self, msg: &PeerMessage, sender_id: &PeerId) -> bool {
         // Not ready to receive checkpoint yet; only acceptable in NotStarted
         if self.state.phase != PbftPhase::NotStarted {
-            self.msg_log.push_backlog(PeerMessage {
-                message_type: msg.message_type.clone(),
-                content: msg.content.clone(),
-            });
+            self.msg_log.push_backlog(
+                PeerMessage {",,2018-10-18 17:38:38,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/226075633,https://github.com/hyperledger/sawtooth-pbft/pull/7#discussion_r226075633,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/7,https://github.com/hyperledger/sawtooth-pbft/pull/7,"Haven't we already rejected the message by the time `check_if_checkpoint_started` is called? Wondering if we can avoid pushing messages to the backlog that have invalid sender IDs, since I assume them having those invalid IDs won't change in the future",dabce661fec7c3c8ce544abca8c92bfcb7d2293a,2018-10-17 20:31:26,226083759,"@@ -265,13 +315,16 @@ impl PbftNode {
         }
     }
 
-    fn check_if_checkpoint_started(&mut self, msg: &PeerMessage) -> bool {
+    fn check_if_checkpoint_started(&mut self, msg: &PeerMessage, sender_id: &PeerId) -> bool {",157,2018-10-18 17:38:38,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/226083759,https://github.com/hyperledger/sawtooth-pbft/pull/7#discussion_r226083759,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/7,https://github.com/hyperledger/sawtooth-pbft/pull/7,"Wildly out of scope for this PR, but I opened https://bitwiseio.atlassian.net/browse/IP-72 to track refactoring protobuf messages so that we don't have to have this check in each branch of the match statement, we could just have `extract_message` and `verify_message_sender` called once at the start of `on_peer_message`.",dabce661fec7c3c8ce544abca8c92bfcb7d2293a,2018-10-17 21:28:17,226101193,"@@ -89,12 +94,21 @@ impl PbftNode {
             PbftMessageType::PrePrepare => {
                 let pbft_message: PbftMessage = extract_message(&msg)?;
 
+                if !verify_message_sender(&&pbft_message, sender_id) {",34,2018-10-18 17:38:38,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/226101193,https://github.com/hyperledger/sawtooth-pbft/pull/7#discussion_r226101193,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/7,https://github.com/hyperledger/sawtooth-pbft/pull/7,"That's correct, the message should already be rejected before this point; no messages with invalid sender IDs will get pushed to the backlog. However, we still need to hold onto that sender ID since `on_peer_message` requires it. If we don't want to have to keep the sender ID at this point, we would have to refactor the main functionality of `on_peer_message` behind another function that doesn't need the sender ID and essentially just check the sender ID in `on_peer_message` itself.",dabce661fec7c3c8ce544abca8c92bfcb7d2293a,2018-10-18 17:35:11,226398526,"@@ -265,13 +315,16 @@ impl PbftNode {
         }
     }
 
-    fn check_if_checkpoint_started(&mut self, msg: &PeerMessage) -> bool {
+    fn check_if_checkpoint_started(&mut self, msg: &PeerMessage, sender_id: &PeerId) -> bool {",157,2018-10-18 17:38:38,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/226398526,https://github.com/hyperledger/sawtooth-pbft/pull/7#discussion_r226398526,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/7,https://github.com/hyperledger/sawtooth-pbft/pull/7,"Good to know! It is a bit cumbersome to have to make the same call in so many places, so that will be a nice improvement.",dabce661fec7c3c8ce544abca8c92bfcb7d2293a,2018-10-18 17:37:31,226399282,"@@ -89,12 +94,21 @@ impl PbftNode {
             PbftMessageType::PrePrepare => {
                 let pbft_message: PbftMessage = extract_message(&msg)?;
 
+                if !verify_message_sender(&&pbft_message, sender_id) {",34,2018-10-18 17:38:38,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/226399282,https://github.com/hyperledger/sawtooth-pbft/pull/7#discussion_r226399282,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/7,https://github.com/hyperledger/sawtooth-pbft/pull/7,Updated this to take advantage of the `.clone()` method,dabce661fec7c3c8ce544abca8c92bfcb7d2293a,2018-10-18 17:38:55,226399685,"@@ -265,13 +315,16 @@ impl PbftNode {
         }
     }
 
-    fn check_if_checkpoint_started(&mut self, msg: &PeerMessage) -> bool {
+    fn check_if_checkpoint_started(&mut self, msg: &PeerMessage, sender_id: &PeerId) -> bool {
         // Not ready to receive checkpoint yet; only acceptable in NotStarted
         if self.state.phase != PbftPhase::NotStarted {
-            self.msg_log.push_backlog(PeerMessage {
-                message_type: msg.message_type.clone(),
-                content: msg.content.clone(),
-            });
+            self.msg_log.push_backlog(
+                PeerMessage {",,2018-10-18 17:38:55,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/226399685,https://github.com/hyperledger/sawtooth-pbft/pull/7#discussion_r226399685,ltseeley
https://github.com/hyperledger/sawtooth-pbft/pull/7,https://github.com/hyperledger/sawtooth-pbft/pull/7,"Ah cool, makes sense. I think as a companion to https://bitwiseio.atlassian.net/browse/IP-72, we could refactor the protobuf decoding to happen in the `engine.rs` loop, and reject messages with bad sender IDs before they even hit `on_peer_message`. That's also quite out-of-scope for this PR though, so ✅ ",dabce661fec7c3c8ce544abca8c92bfcb7d2293a,2018-10-18 18:32:13,226418502,"@@ -265,13 +315,16 @@ impl PbftNode {
         }
     }
 
-    fn check_if_checkpoint_started(&mut self, msg: &PeerMessage) -> bool {
+    fn check_if_checkpoint_started(&mut self, msg: &PeerMessage, sender_id: &PeerId) -> bool {",157,2018-10-18 18:32:13,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/226418502,https://github.com/hyperledger/sawtooth-pbft/pull/7#discussion_r226418502,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,TODO should be removed,cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-12 16:11:38,224839953,"@@ -0,0 +1,195 @@
+use serde::de::DeserializeOwned;
+use serde::Serialize;
+use serde_json::{from_str, to_string};
+use std::fs::{File, OpenOptions};
+use std::io::{Read, Write, Seek, SeekFrom};
+use std::ops::{Deref, DerefMut};
+use std::fmt;
+
+/// TODO: Write some docs",,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/224839953,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r224839953,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,"This, and the `Cargo.toml` changes should be it's own commit.",cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-12 16:15:04,224841016,"@@ -36,7 +36,10 @@ fn main() {
         out_dir: &dest_path.to_str().unwrap(),
         input: &[proto_path.join(""pbft_message.proto"").to_str().unwrap()],
         includes: &[proto_path.to_str().unwrap()],
-        customize: Customize::default(),
+        customize: Customize {",5,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/224841016,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r224841016,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,Another TODO to remove (or do),cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-12 16:17:28,224841619,"@@ -94,101 +121,226 @@ impl<T: Serialize + DeserializeOwned> Storage<T> {
                 f.read_to_string(&mut contents)
                     .map_err(|err| format!(""Couldn't read file: {}"", err))?;
 
-                from_str(&contents)
-                    .map_err(|err| format!(""Couldn't read file: {}"", err))?
+                from_str(&contents).map_err(|err| format!(""Couldn't read file: {}"", err))?
             }
-            Err(_) => default()
+            Err(_) => default(),
         };
 
         // Then open the file again and truncate, preparing it to be written to
-        Ok(Self { data, file: OpenOptions::new()
-            .read(true)
-            .write(true)
-            .truncate(true)
-            .create(true)
-            .open(path)
-            .map_err(|err| format!(""Couldn't open file: {}"", err))? })
+        Ok(Self {
+            data,
+            file: OpenOptions::new()
+                .read(true)
+                .write(true)
+                .truncate(true)
+                .create(true)
+                .open(path)
+                .map_err(|err| format!(""Couldn't open file: {}"", err))?,
+        })
+    }
+}
+
+impl<T: fmt::Display + Serialize + DeserializeOwned> fmt::Display for DiskStorage<T> {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        (*self).data.fmt(f)
+    }
+}
+
+impl<'a, T: 'a + Serialize + DeserializeOwned + fmt::Display> Storage<'a> for DiskStorage<T> {
+    type S = T;
+
+    fn read(&'a self) -> Box<StorageReadGuard<'a, T, Target = T> + 'a> {
+        Box::new(DiskStorageReadGuard::new(self))
+    }
+
+    fn write(&'a mut self) -> Box<StorageWriteGuard<'a, T, Target = T> + 'a> {
+        Box::new(DiskStorageWriteGuard::new(self))
+    }
+}
+
+// Mem Storage-related structs and impls
+/// TODO: Write some docs",,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/224841619,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r224841619,peterschwarz
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,"I realize this is WIP, but I still think a name more descriptive than `""test.json""` may be in order here",cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-12 23:31:24,224938036,"@@ -60,29 +62,33 @@ impl Engine for PbftEngine {
             .expect(""This node is not in the peers list, which is necessary"")
             as u64;
 
+        let mut pbft_state =
+            DiskStorage::new_with_default(""test.json"", || PbftState::new(node_id, &config))",,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/224938036,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r224938036,bridger-herman
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,What is the purpose of the leading underscores on this variable?,cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-12 23:39:40,224938921,"@@ -94,101 +121,226 @@ impl<T: Serialize + DeserializeOwned> Storage<T> {
                 f.read_to_string(&mut contents)
                     .map_err(|err| format!(""Couldn't read file: {}"", err))?;
 
-                from_str(&contents)
-                    .map_err(|err| format!(""Couldn't read file: {}"", err))?
+                from_str(&contents).map_err(|err| format!(""Couldn't read file: {}"", err))?
             }
-            Err(_) => default()
+            Err(_) => default(),
         };
 
         // Then open the file again and truncate, preparing it to be written to
-        Ok(Self { data, file: OpenOptions::new()
-            .read(true)
-            .write(true)
-            .truncate(true)
-            .create(true)
-            .open(path)
-            .map_err(|err| format!(""Couldn't open file: {}"", err))? })
+        Ok(Self {
+            data,
+            file: OpenOptions::new()
+                .read(true)
+                .write(true)
+                .truncate(true)
+                .create(true)
+                .open(path)
+                .map_err(|err| format!(""Couldn't open file: {}"", err))?,
+        })
+    }
+}
+
+impl<T: fmt::Display + Serialize + DeserializeOwned> fmt::Display for DiskStorage<T> {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        (*self).data.fmt(f)
+    }
+}
+
+impl<'a, T: 'a + Serialize + DeserializeOwned + fmt::Display> Storage<'a> for DiskStorage<T> {
+    type S = T;
+
+    fn read(&'a self) -> Box<StorageReadGuard<'a, T, Target = T> + 'a> {
+        Box::new(DiskStorageReadGuard::new(self))
+    }
+
+    fn write(&'a mut self) -> Box<StorageWriteGuard<'a, T, Target = T> + 'a> {
+        Box::new(DiskStorageWriteGuard::new(self))
+    }
+}
+
+// Mem Storage-related structs and impls
+/// TODO: Write some docs
+#[derive(Debug)]
+pub struct MemStorageReadGuard<'a, T: Serialize + DeserializeOwned + 'a> {
+    __storage: &'a MemStorage<T>,",,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/224938921,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r224938921,bridger-herman
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,"Remove todo comment, create story instead",cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-15 15:03:15,225200700,"@@ -0,0 +1,195 @@
+use serde::de::DeserializeOwned;
+use serde::Serialize;
+use serde_json::{from_str, to_string};
+use std::fs::{File, OpenOptions};
+use std::io::{Read, Write, Seek, SeekFrom};
+use std::ops::{Deref, DerefMut};
+use std::fmt;
+
+/// TODO: Write some docs
+#[derive(Debug)]
+pub struct StorageReadGuard<'a, T: Serialize + DeserializeOwned + 'a> {
+    cache: &'a Storage<T>,
+}
+
+impl<'a, T: Serialize + DeserializeOwned> StorageReadGuard<'a, T> {
+    fn new(cache: &'a Storage<T>) -> Self {
+        Self { cache }
+    }
+}
+
+impl<'a, T: Serialize + DeserializeOwned + 'a> Deref for StorageReadGuard<'a, T> {
+    type Target = T;
+
+    fn deref(&self) -> &T {
+        &self.cache.data
+    }
+}
+
+impl<'a, T: 'a + Serialize + DeserializeOwned + fmt::Display> fmt::Display for StorageReadGuard<'a, T> {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        (**self).fmt(f)
+    }
+}
+
+/// TODO: Write some docs",,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/225200700,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r225200700,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,"Remove todo comment, write story instead.",cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-15 15:03:34,225200791,"@@ -0,0 +1,195 @@
+use serde::de::DeserializeOwned;
+use serde::Serialize;
+use serde_json::{from_str, to_string};
+use std::fs::{File, OpenOptions};
+use std::io::{Read, Write, Seek, SeekFrom};
+use std::ops::{Deref, DerefMut};
+use std::fmt;
+
+/// TODO: Write some docs
+#[derive(Debug)]
+pub struct StorageReadGuard<'a, T: Serialize + DeserializeOwned + 'a> {
+    cache: &'a Storage<T>,
+}
+
+impl<'a, T: Serialize + DeserializeOwned> StorageReadGuard<'a, T> {
+    fn new(cache: &'a Storage<T>) -> Self {
+        Self { cache }
+    }
+}
+
+impl<'a, T: Serialize + DeserializeOwned + 'a> Deref for StorageReadGuard<'a, T> {
+    type Target = T;
+
+    fn deref(&self) -> &T {
+        &self.cache.data
+    }
+}
+
+impl<'a, T: 'a + Serialize + DeserializeOwned + fmt::Display> fmt::Display for StorageReadGuard<'a, T> {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        (**self).fmt(f)
+    }
+}
+
+/// TODO: Write some docs
+#[derive(Debug)]
+pub struct StorageWriteGuard<'a, T: Serialize + DeserializeOwned + 'a> {
+    cache: &'a mut Storage<T>,
+}
+
+impl<'a, T: Serialize + DeserializeOwned> StorageWriteGuard<'a, T> {
+    fn new(cache: &'a mut Storage<T>) -> Self {
+        Self { cache }
+    }
+}
+
+impl<'a, T: Serialize + DeserializeOwned> Drop for StorageWriteGuard<'a, T> {
+    fn drop(&mut self) {
+        self.cache.file.seek(SeekFrom::Start(0)).unwrap();
+        self.cache.file.set_len(0).unwrap();
+        self.cache.file.write(to_string(&self.cache.data).unwrap().as_bytes()).unwrap();
+    }
+}
+
+impl<'a, T: Serialize + DeserializeOwned + 'a> Deref for StorageWriteGuard<'a, T> {
+    type Target = T;
+
+    fn deref(&self) -> &T {
+        &self.cache.data
+    }
+}
+
+impl<'a, T: Serialize + DeserializeOwned + 'a> DerefMut for StorageWriteGuard<'a, T> {
+    fn deref_mut(&mut self) -> &mut T {
+        &mut self.cache.data
+    }
+}
+
+impl<'a, T: 'a + Serialize + DeserializeOwned + fmt::Display> fmt::Display for StorageWriteGuard<'a, T> {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        (**self).fmt(f)
+    }
+}
+
+/// TODO: Write some docs",,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/225200791,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r225200791,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,"I do not think truncating the file immediately is a good idea. This would mean that if the process were to crash after reading the file into memory, but before a new value is written, the persisted data would be lost.",cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-15 15:17:37,225206442,"@@ -0,0 +1,195 @@
+use serde::de::DeserializeOwned;
+use serde::Serialize;
+use serde_json::{from_str, to_string};
+use std::fs::{File, OpenOptions};
+use std::io::{Read, Write, Seek, SeekFrom};
+use std::ops::{Deref, DerefMut};
+use std::fmt;
+
+/// TODO: Write some docs
+#[derive(Debug)]
+pub struct StorageReadGuard<'a, T: Serialize + DeserializeOwned + 'a> {
+    cache: &'a Storage<T>,
+}
+
+impl<'a, T: Serialize + DeserializeOwned> StorageReadGuard<'a, T> {
+    fn new(cache: &'a Storage<T>) -> Self {
+        Self { cache }
+    }
+}
+
+impl<'a, T: Serialize + DeserializeOwned + 'a> Deref for StorageReadGuard<'a, T> {
+    type Target = T;
+
+    fn deref(&self) -> &T {
+        &self.cache.data
+    }
+}
+
+impl<'a, T: 'a + Serialize + DeserializeOwned + fmt::Display> fmt::Display for StorageReadGuard<'a, T> {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        (**self).fmt(f)
+    }
+}
+
+/// TODO: Write some docs
+#[derive(Debug)]
+pub struct StorageWriteGuard<'a, T: Serialize + DeserializeOwned + 'a> {
+    cache: &'a mut Storage<T>,
+}
+
+impl<'a, T: Serialize + DeserializeOwned> StorageWriteGuard<'a, T> {
+    fn new(cache: &'a mut Storage<T>) -> Self {
+        Self { cache }
+    }
+}
+
+impl<'a, T: Serialize + DeserializeOwned> Drop for StorageWriteGuard<'a, T> {
+    fn drop(&mut self) {
+        self.cache.file.seek(SeekFrom::Start(0)).unwrap();
+        self.cache.file.set_len(0).unwrap();
+        self.cache.file.write(to_string(&self.cache.data).unwrap().as_bytes()).unwrap();
+    }
+}
+
+impl<'a, T: Serialize + DeserializeOwned + 'a> Deref for StorageWriteGuard<'a, T> {
+    type Target = T;
+
+    fn deref(&self) -> &T {
+        &self.cache.data
+    }
+}
+
+impl<'a, T: Serialize + DeserializeOwned + 'a> DerefMut for StorageWriteGuard<'a, T> {
+    fn deref_mut(&mut self) -> &mut T {
+        &mut self.cache.data
+    }
+}
+
+impl<'a, T: 'a + Serialize + DeserializeOwned + fmt::Display> fmt::Display for StorageWriteGuard<'a, T> {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        (**self).fmt(f)
+    }
+}
+
+/// TODO: Write some docs
+#[derive(Debug)]
+pub struct Storage<T: Serialize + DeserializeOwned> {
+    data: T,
+    file: File,
+}
+
+impl<T: Serialize + DeserializeOwned> Storage<T> {
+    pub fn new_with_default<P: Into<String>, F: Fn() -> T>(
+        path: P,
+        default: F,
+    ) -> Result<Self, String> {
+        let path = path.into();
+
+        // Read the file first, to see if there's any existing data
+        let data = match File::open(path.clone()) {
+            Ok(mut f) => {
+                let mut contents = String::new();
+
+                f.read_to_string(&mut contents)
+                    .map_err(|err| format!(""Couldn't read file: {}"", err))?;
+
+                from_str(&contents)
+                    .map_err(|err| format!(""Couldn't read file: {}"", err))?
+            }
+            Err(_) => default()
+        };
+
+        // Then open the file again and truncate, preparing it to be written to
+        Ok(Self { data, file: OpenOptions::new()
+            .read(true)
+            .write(true)
+            .truncate(true)",,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/225206442,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r225206442,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,"This is what we have done in the past:
https://github.com/hyperledger/sawtooth-raft/blob/master/src/path.rs
https://github.com/hyperledger/sawtooth-raft/blob/master/src/fs_storage.rs#L36

It may also be a good idea to split up the state across several files, so that we are not writing all of state to disk every time we change any part of it.",cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-15 15:21:08,225207943,"@@ -60,29 +62,33 @@ impl Engine for PbftEngine {
             .expect(""This node is not in the peers list, which is necessary"")
             as u64;
 
+        let mut pbft_state =
+            DiskStorage::new_with_default(""test.json"", || PbftState::new(node_id, &config))",,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/225207943,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r225207943,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,Why are you using two underscores in front of the variable name here? The standing convention is to let the compiler enforce public vs. private.,cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-15 15:25:21,225209591,"@@ -1,85 +1,112 @@
 use serde::de::DeserializeOwned;
 use serde::Serialize;
 use serde_json::{from_str, to_string};
+use std::fmt;
 use std::fs::{File, OpenOptions};
-use std::io::{Read, Write, Seek, SeekFrom};
+use std::io::{Read, Seek, SeekFrom, Write};
 use std::ops::{Deref, DerefMut};
-use std::fmt;
 
+// General traits
+pub trait StorageReadGuard<'a, T>: Deref<Target = T> {}
+pub trait StorageWriteGuard<'a, T>: DerefMut<Target = T> {}
+
+pub trait Storage<'a>: fmt::Display {
+    type S;
+
+    fn read(&'a self) -> Box<StorageReadGuard<'a, Self::S, Target = Self::S> + 'a>;
+    fn write(&'a mut self) -> Box<StorageWriteGuard<'a, Self::S, Target = Self::S> + 'a>;
+}
+
+// Disk Storage-related structs and impls
 /// TODO: Write some docs
 #[derive(Debug)]
-pub struct StorageReadGuard<'a, T: Serialize + DeserializeOwned + 'a> {
-    cache: &'a Storage<T>,
+pub struct DiskStorageReadGuard<'a, T: Serialize + DeserializeOwned + 'a> {
+    __storage: &'a DiskStorage<T>,",,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/225209591,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r225209591,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,Why is this lifetime required? I understand that the lifetimes below are needed to guarantee that the guards live as long as the storage.,cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-15 15:25:53,225209803,"@@ -1,85 +1,112 @@
 use serde::de::DeserializeOwned;
 use serde::Serialize;
 use serde_json::{from_str, to_string};
+use std::fmt;
 use std::fs::{File, OpenOptions};
-use std::io::{Read, Write, Seek, SeekFrom};
+use std::io::{Read, Seek, SeekFrom, Write};
 use std::ops::{Deref, DerefMut};
-use std::fmt;
 
+// General traits
+pub trait StorageReadGuard<'a, T>: Deref<Target = T> {}
+pub trait StorageWriteGuard<'a, T>: DerefMut<Target = T> {}
+
+pub trait Storage<'a>: fmt::Display {",,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/225209803,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r225209803,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,"Buried this at the end of the PR description, but I was planning on filling out the doc TODOs before this would get merged, I wanted to get feedback about the general approach first though",cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-15 15:40:27,225215404,"@@ -0,0 +1,195 @@
+use serde::de::DeserializeOwned;
+use serde::Serialize;
+use serde_json::{from_str, to_string};
+use std::fs::{File, OpenOptions};
+use std::io::{Read, Write, Seek, SeekFrom};
+use std::ops::{Deref, DerefMut};
+use std::fmt;
+
+/// TODO: Write some docs
+#[derive(Debug)]
+pub struct StorageReadGuard<'a, T: Serialize + DeserializeOwned + 'a> {
+    cache: &'a Storage<T>,
+}
+
+impl<'a, T: Serialize + DeserializeOwned> StorageReadGuard<'a, T> {
+    fn new(cache: &'a Storage<T>) -> Self {
+        Self { cache }
+    }
+}
+
+impl<'a, T: Serialize + DeserializeOwned + 'a> Deref for StorageReadGuard<'a, T> {
+    type Target = T;
+
+    fn deref(&self) -> &T {
+        &self.cache.data
+    }
+}
+
+impl<'a, T: 'a + Serialize + DeserializeOwned + fmt::Display> fmt::Display for StorageReadGuard<'a, T> {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        (**self).fmt(f)
+    }
+}
+
+/// TODO: Write some docs",,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/225215404,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r225215404,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,"Without the lifetime for this trait, I get this error:

```rust
error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements
   --> src/storage/disk.rs:145:18
    |
145 |         Box::new(DiskStorageReadGuard::new(self))
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 144:5...
   --> src/storage/disk.rs:144:5
    |
144 | /     fn read(&self) -> Box<StorageReadGuard<T, Target = T>> {
145 | |         Box::new(DiskStorageReadGuard::new(self))
146 | |     }
    | |_____^
note: ...so that reference does not outlive borrowed content
   --> src/storage/disk.rs:145:44
    |
145 |         Box::new(DiskStorageReadGuard::new(self))
    |                                            ^^^^
    = note: but, the lifetime must be valid for the static lifetime...
    = note: ...so that the expression is assignable:
            expected std::boxed::Box<(dyn storage::StorageReadGuard<'_, T, Target=T> + 'static)>
               found std::boxed::Box<dyn storage::StorageReadGuard<'_, T, Target=T>>
```

I think we're running into the issue with `Box` from here: https://users.rust-lang.org/t/solved-trait-with-lifetime-parameter-and-compiler-message-i-dont-understand/7409",cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-15 16:21:36,225230545,"@@ -1,85 +1,112 @@
 use serde::de::DeserializeOwned;
 use serde::Serialize;
 use serde_json::{from_str, to_string};
+use std::fmt;
 use std::fs::{File, OpenOptions};
-use std::io::{Read, Write, Seek, SeekFrom};
+use std::io::{Read, Seek, SeekFrom, Write};
 use std::ops::{Deref, DerefMut};
-use std::fmt;
 
+// General traits
+pub trait StorageReadGuard<'a, T>: Deref<Target = T> {}
+pub trait StorageWriteGuard<'a, T>: DerefMut<Target = T> {}
+
+pub trait Storage<'a>: fmt::Display {",,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/225230545,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r225230545,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,"Does this work for you? It works locally for me, but I am just compiling storage.rs because the rest doesn't compile because of the protobuf/serde stuff in the sdk.

https://github.com/aludvik/sawtooth-pbft-1/tree/state-caching-no-lifetime",cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-16 18:34:27,225660125,"@@ -1,85 +1,112 @@
 use serde::de::DeserializeOwned;
 use serde::Serialize;
 use serde_json::{from_str, to_string};
+use std::fmt;
 use std::fs::{File, OpenOptions};
-use std::io::{Read, Write, Seek, SeekFrom};
+use std::io::{Read, Seek, SeekFrom, Write};
 use std::ops::{Deref, DerefMut};
-use std::fmt;
 
+// General traits
+pub trait StorageReadGuard<'a, T>: Deref<Target = T> {}
+pub trait StorageWriteGuard<'a, T>: DerefMut<Target = T> {}
+
+pub trait Storage<'a>: fmt::Display {",,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/225660125,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r225660125,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,"Borrowed from https://doc.rust-lang.org/src/std/sync/rwlock.rs.html#121, but I can't seem to find a solid reason that they do it there, so I'll just switch back to no leading underscores",cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-17 17:01:36,226016126,"@@ -1,85 +1,112 @@
 use serde::de::DeserializeOwned;
 use serde::Serialize;
 use serde_json::{from_str, to_string};
+use std::fmt;
 use std::fs::{File, OpenOptions};
-use std::io::{Read, Write, Seek, SeekFrom};
+use std::io::{Read, Seek, SeekFrom, Write};
 use std::ops::{Deref, DerefMut};
-use std::fmt;
 
+// General traits
+pub trait StorageReadGuard<'a, T>: Deref<Target = T> {}
+pub trait StorageWriteGuard<'a, T>: DerefMut<Target = T> {}
+
+pub trait Storage<'a>: fmt::Display {
+    type S;
+
+    fn read(&'a self) -> Box<StorageReadGuard<'a, Self::S, Target = Self::S> + 'a>;
+    fn write(&'a mut self) -> Box<StorageWriteGuard<'a, Self::S, Target = Self::S> + 'a>;
+}
+
+// Disk Storage-related structs and impls
 /// TODO: Write some docs
 #[derive(Debug)]
-pub struct StorageReadGuard<'a, T: Serialize + DeserializeOwned + 'a> {
-    cache: &'a Storage<T>,
+pub struct DiskStorageReadGuard<'a, T: Serialize + DeserializeOwned + 'a> {
+    __storage: &'a DiskStorage<T>,",,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/226016126,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r226016126,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,I do not think storage type should be an on-chain setting.,cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-19 20:09:25,226767818,"@@ -75,6 +79,7 @@ impl PbftConfig {
 /// + `sawtooth.consensus.pbft.view_change_timeout` (optional, default 4000 ms)
 /// + `sawtooth.consensus.pbft.message_timeout` (optional, default 100 blocks)
 /// + `sawtooth.consensus.pbft.max_log_size` (optional, default 1000 messages)
+/// + `sawtooth.consensus.pbft.storage` (optional, default `""memory""`)",22,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/226767818,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r226767818,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,"Refactoring the codebase to pass state around instead of passing it as an instance variable isn't within the scope of the commit message and should be split into a separate commit. I am also not certain this is a good change, so it would be good to see some reasoning behind it.",cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-19 20:12:03,226768426,"@@ -44,34 +44,26 @@ pub struct PbftNode {
     /// Used for interactions with the validator
     pub service: Box<Service>,
 
-    /// Storage of state information
-    pub state: PbftState,
-",6,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/226768426,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r226768426,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,Deriving serde support should be a separate commit,cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-19 20:12:52,226768595,"@@ -52,10 +52,11 @@ enum TimeoutState {
 
 /// A timer that expires after a given duration
 /// Check back on this timer every so often to see if it's expired
-#[derive(Debug)]
+#[derive(Debug, Serialize, Deserialize)]",23,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/226768595,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r226768595,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,"I borrowed this from where it looked like Raft was going, in that it has storage configuration wrapped up in the `Config` class. Are you thinking of configuring this with a CLI or config file parameter? If config file, would it make sense to have the SDK handle that?",cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-19 21:19:38,226784794,"@@ -75,6 +79,7 @@ impl PbftConfig {
 /// + `sawtooth.consensus.pbft.view_change_timeout` (optional, default 4000 ms)
 /// + `sawtooth.consensus.pbft.message_timeout` (optional, default 100 blocks)
 /// + `sawtooth.consensus.pbft.max_log_size` (optional, default 1000 messages)
+/// + `sawtooth.consensus.pbft.storage` (optional, default `""memory""`)",22,2018-10-23 16:46:31,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/226784794,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r226784794,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,"I've got some reasoning in the PR description, does that allay your concerns?",cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-19 21:23:23,226785621,"@@ -44,34 +44,26 @@ pub struct PbftNode {
     /// Used for interactions with the validator
     pub service: Box<Service>,
 
-    /// Storage of state information
-    pub state: PbftState,
-",6,2018-10-23 16:46:32,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/226785621,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r226785621,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,Moving `PbftState` into the `Storage` wrapper is pretty tied up with moving it into state managed by the engine. Would it make sense to just expand the commit description?,cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-19 21:38:36,226788723,"@@ -44,34 +44,26 @@ pub struct PbftNode {
     /// Used for interactions with the validator
     pub service: Box<Service>,
 
-    /// Storage of state information
-    pub state: PbftState,
-",6,2018-10-23 16:46:32,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/226788723,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r226788723,knkski
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,I don't think the storage type should be a run-time configuration. I think the modularity is helpful to allow us to swap out different implementations later on more easily.,cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-22 16:57:50,227053789,"@@ -75,6 +79,7 @@ impl PbftConfig {
 /// + `sawtooth.consensus.pbft.view_change_timeout` (optional, default 4000 ms)
 /// + `sawtooth.consensus.pbft.message_timeout` (optional, default 100 blocks)
 /// + `sawtooth.consensus.pbft.max_log_size` (optional, default 1000 messages)
+/// + `sawtooth.consensus.pbft.storage` (optional, default `""memory""`)",22,2018-10-23 16:46:32,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/227053789,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r227053789,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,"Yep, I missed the nuance here. Expand the commit description and you are good.",cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-22 17:23:37,227061905,"@@ -44,34 +44,26 @@ pub struct PbftNode {
     /// Used for interactions with the validator
     pub service: Box<Service>,
 
-    /// Storage of state information
-    pub state: PbftState,
-",6,2018-10-23 16:46:32,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/227061905,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r227061905,aludvik
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,Missing license ,cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-23 16:40:49,227474273,"@@ -0,0 +1,149 @@
+//! Disk-backed persistence wrapper",18,2018-10-23 16:46:32,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/227474273,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r227474273,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,Missing license,cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-23 16:41:15,227474428,"@@ -0,0 +1,112 @@
+//! Memory-backed persistence wrapper",18,2018-10-23 16:46:32,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/227474428,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r227474428,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/3,https://github.com/hyperledger/sawtooth-pbft/pull/3,Missing license ,cfbe523d52808a4a16959ddeb9d9d642c6e042e1,2018-10-23 16:41:34,227474516,"@@ -0,0 +1,216 @@
+//! Storage trait for syncing writes to an object to a backing store",18,2018-10-23 16:46:32,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/227474516,https://github.com/hyperledger/sawtooth-pbft/pull/3#discussion_r227474516,agunde406
https://github.com/hyperledger/sawtooth-pbft/pull/2,https://github.com/hyperledger/sawtooth-pbft/pull/2,"This should probably just be fixed up with the other settings merger commit, but otherwise looks good.",a51f169641cbb7d959f2cf746b2532d7e8bcf2fd,2018-10-10 20:23:37,224228484,"@@ -154,9 +154,21 @@ fn merge_setting_if_set<T: ::std::str::FromStr>(
     setting_field: &mut T,
     setting_key: &str,
 ) {
+    merge_setting_if_set_and_map(settings_map, setting_field, setting_key, |setting| setting)
+}
+
+fn merge_setting_if_set_and_map<U, F, T>(",95,2018-10-10 20:36:46,https://api.github.com/repos/hyperledger/sawtooth-pbft/pulls/comments/224228484,https://github.com/hyperledger/sawtooth-pbft/pull/2#discussion_r224228484,ltseeley
