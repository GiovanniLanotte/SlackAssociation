pull request url html,pull request url,body,commit_id,create at,id,diff_hunk,position,update at,url,html url,user
https://github.com/hyperledger/caliper/pull/378,https://github.com/hyperledger/caliper/pull/378,Why is `contract: contract`  removed ? It seems `contract` is still needed [here](https://github.com/hyperledger/caliper/blob/master/src/adapters/fabric/e2eUtils.js#L1247) .,1f733493cbdb5210ef82cc039b6fb8778bd8e26e,2019-03-20 11:30:33,267293550,"@@ -108,12 +108,10 @@ class Fabric extends BlockchainInterface{
             // Retrieve gateway using ccp and options
             const gateway = await e2eUtils.retrieveGateway(fabricSettings.fabric.ccp, opts);
 
-            // Retrieve and return the contract using the network API commands
-            commLogger.info(`Retrieving contract from channel ${context[name].channel} and chaincodeID ${context[name].chaincodeId}`);
-            const network = await gateway.getNetwork(context[name].channel);
-            const contract = await network.getContract(context[name].chaincodeId);
-
-            return {gateway: gateway, contract: contract};
+            // Retrieve and return the network using the network API commands
+            commLogger.info(`Retrieving network from channelName ${context[name]}`);
+            const network = await gateway.getNetwork(context[name]);
+            return {gateway: gateway, network: network, clientIdx};",13,2019-03-21 00:19:38,https://api.github.com/repos/hyperledger/caliper/pulls/comments/267293550,https://github.com/hyperledger/caliper/pull/378#discussion_r267293550,panyu4
https://github.com/hyperledger/caliper/pull/378,https://github.com/hyperledger/caliper/pull/378,"Extraction of the specific contract from the Network object requires knowledge of the chaincode name that the client is to use. At this point in the code flow we only have access to information contained in the ""context"" portion of the network config file, which details the channel:test-tag mapping only. 

There is a requirement for the user wishing to use the network model testing route to perform the contract extraction as part of the `init` phase of the benchmarks. 

This could probably do with some documentation somewhere ðŸ˜‚ I have a fair few tests that I have been running with this network model, so it might be worth me adding these in as a benchmark sample?",1f733493cbdb5210ef82cc039b6fb8778bd8e26e,2019-03-21 08:45:15,267660692,"@@ -108,12 +108,10 @@ class Fabric extends BlockchainInterface{
             // Retrieve gateway using ccp and options
             const gateway = await e2eUtils.retrieveGateway(fabricSettings.fabric.ccp, opts);
 
-            // Retrieve and return the contract using the network API commands
-            commLogger.info(`Retrieving contract from channel ${context[name].channel} and chaincodeID ${context[name].chaincodeId}`);
-            const network = await gateway.getNetwork(context[name].channel);
-            const contract = await network.getContract(context[name].chaincodeId);
-
-            return {gateway: gateway, contract: contract};
+            // Retrieve and return the network using the network API commands
+            commLogger.info(`Retrieving network from channelName ${context[name]}`);
+            const network = await gateway.getNetwork(context[name]);
+            return {gateway: gateway, network: network, clientIdx};",13,2019-03-21 08:45:16,https://api.github.com/repos/hyperledger/caliper/pulls/comments/267660692,https://github.com/hyperledger/caliper/pull/378#discussion_r267660692,nklincoln
https://github.com/hyperledger/caliper/pull/378,https://github.com/hyperledger/caliper/pull/378,"As you said in the current code flow we only needed to access to information contained in the ""context""  portion of the network config file, it would not affect current process. I think I can merge it first then you can start to pack for the npm package and as for the other related network models,  you might add them later :) 
 ",1f733493cbdb5210ef82cc039b6fb8778bd8e26e,2019-03-21 08:59:11,267664834,"@@ -108,12 +108,10 @@ class Fabric extends BlockchainInterface{
             // Retrieve gateway using ccp and options
             const gateway = await e2eUtils.retrieveGateway(fabricSettings.fabric.ccp, opts);
 
-            // Retrieve and return the contract using the network API commands
-            commLogger.info(`Retrieving contract from channel ${context[name].channel} and chaincodeID ${context[name].chaincodeId}`);
-            const network = await gateway.getNetwork(context[name].channel);
-            const contract = await network.getContract(context[name].chaincodeId);
-
-            return {gateway: gateway, contract: contract};
+            // Retrieve and return the network using the network API commands
+            commLogger.info(`Retrieving network from channelName ${context[name]}`);
+            const network = await gateway.getNetwork(context[name]);
+            return {gateway: gateway, network: network, clientIdx};",13,2019-03-21 08:59:11,https://api.github.com/repos/hyperledger/caliper/pulls/comments/267664834,https://github.com/hyperledger/caliper/pull/378#discussion_r267664834,panyu4
https://github.com/hyperledger/caliper/pull/370,https://github.com/hyperledger/caliper/pull/370,"Now it's the same as `composer-v0.19-deps`, so line 17 can be removed",5516c1c6a314a94c0a1eaf2b6a19db9f1f74835d,2019-03-13 07:01:32,264994823,"@@ -15,7 +15,7 @@
     ""startclient"": ""node ./src/comm/client/zoo-client.js"",
     ""burrow-deps"": ""npm install --no-save @monax/burrow@0.23.0 grpc@1.16.1"",
     ""composer-v0.19-deps"": ""npm install --no-save composer-admin@0.19.18 composer-client@0.19.18 composer-common@0.19.18 fabric-ca-client@1.1.0 fabric-client@1.1.0"",
-    ""composer-deps"": ""npm install --no-save composer-admin@0.19.18 composer-client@0.19.18 composer-common@0.19.18 fabric-ca-client@1.2.0 fabric-client@1.2.0"",
+    ""composer-deps"": ""npm install --no-save composer-admin@0.19.18 composer-client@0.19.18 composer-common@0.19.18 fabric-ca-client@1.1.0 fabric-client@1.1.0"",",6,2019-03-13 07:15:56,https://api.github.com/repos/hyperledger/caliper/pulls/comments/264994823,https://github.com/hyperledger/caliper/pull/370#discussion_r264994823,aklenik
https://github.com/hyperledger/caliper/pull/370,https://github.com/hyperledger/caliper/pull/370,"Fixed, please take a look.",5516c1c6a314a94c0a1eaf2b6a19db9f1f74835d,2019-03-13 07:59:58,265007826,"@@ -15,7 +15,7 @@
     ""startclient"": ""node ./src/comm/client/zoo-client.js"",
     ""burrow-deps"": ""npm install --no-save @monax/burrow@0.23.0 grpc@1.16.1"",
     ""composer-v0.19-deps"": ""npm install --no-save composer-admin@0.19.18 composer-client@0.19.18 composer-common@0.19.18 fabric-ca-client@1.1.0 fabric-client@1.1.0"",
-    ""composer-deps"": ""npm install --no-save composer-admin@0.19.18 composer-client@0.19.18 composer-common@0.19.18 fabric-ca-client@1.2.0 fabric-client@1.2.0"",
+    ""composer-deps"": ""npm install --no-save composer-admin@0.19.18 composer-client@0.19.18 composer-common@0.19.18 fabric-ca-client@1.1.0 fabric-client@1.1.0"",",6,2019-03-13 07:59:58,https://api.github.com/repos/hyperledger/caliper/pulls/comments/265007826,https://github.com/hyperledger/caliper/pull/370#discussion_r265007826,feihujiang
https://github.com/hyperledger/caliper/pull/349,https://github.com/hyperledger/caliper/pull/349,"Left out `run` after `npm`:
`npm run bench -- ...`",c393cf03e9777ec462cded62d885eaee21527f3e,2019-03-07 16:54:12,263473669,"@@ -51,19 +51,19 @@ Run `npm install` in Caliper folder to install dependencies locally, the relevan
 ## Run Benchmark
 
 All predefined benchmarks can be found in [*benchmark*](https://github.com/hyperledger/caliper/tree/master/benchmark) folder.
-To start your first benchmark, just run this in root folder
+To start your first benchmark, just run this from the root folder:
 ```bash
-node benchmark/simple/main.js -c yourconfig.json -n yournetwork.json
+npm bench -- -c yourconfig.json -n yournetwork.json",,2019-03-07 17:03:55,https://api.github.com/repos/hyperledger/caliper/pulls/comments/263473669,https://github.com/hyperledger/caliper/pull/349#discussion_r263473669,aklenik
https://github.com/hyperledger/caliper/pull/349,https://github.com/hyperledger/caliper/pull/349,The `simplenetwork` SUT doesn't exist anymore. A sensible and lightweight default would be `network/fabric-v1.1/dev/docker-compose.yaml`,c393cf03e9777ec462cded62d885eaee21527f3e,2019-03-07 16:55:48,263474396,"@@ -51,19 +51,19 @@ Run `npm install` in Caliper folder to install dependencies locally, the relevan
 ## Run Benchmark
 
 All predefined benchmarks can be found in [*benchmark*](https://github.com/hyperledger/caliper/tree/master/benchmark) folder.
-To start your first benchmark, just run this in root folder
+To start your first benchmark, just run this from the root folder:
 ```bash
-node benchmark/simple/main.js -c yourconfig.json -n yournetwork.json
+npm bench -- -c yourconfig.json -n yournetwork.json
 ```
-* -c : specify the config file of the benchmark, if not used,  *config.json* will be used as default.
-* -n : specify the config file of the blockchain network under test. If not used, the file address must be specified in the benchmak config file.
+* -c : specify the config file of the benchmark (required).
+* -n : specify the config file of the blockchain network under test (required).
 
-Some example SUTs are provided in [*network*](https://github.com/hyperledger/caliper/tree/master/network) folder, they can be launched automatically before the test by setting the bootstrap commands in the configuration file, e.g
+Some example SUTs are provided in [*network*](https://github.com/hyperledger/caliper/tree/master/network) folder, they can be launched automatically before the test by setting the bootstrap commands in the configuration file, e.g.
 ```json
 {
   ""command"" : {
-    ""start"": ""docker-compose -f network/fabric/simplenetwork/docker-compose.yaml up -d"",
-    ""end"" : ""docker-compose -f network/fabric/simplenetwork/docker-compose.yaml down;docker rm $(docker ps -aq)""
+    ""start"": ""docker-compose -f network/simplenetwork/docker-compose.yaml up -d"",
+    ""end"" : ""docker-compose -f network/simplenetwork/docker-compose.yaml down;docker rm $(docker ps -aq)""",,2019-03-07 17:03:55,https://api.github.com/repos/hyperledger/caliper/pulls/comments/263474396,https://github.com/hyperledger/caliper/pull/349#discussion_r263474396,aklenik
https://github.com/hyperledger/caliper/pull/332,https://github.com/hyperledger/caliper/pull/332,grpc is also Fabric-specific,8b21a1dd6bc0226c721e3869d412df93469ad78c,2019-02-26 11:29:53,260243316,"@@ -34,9 +34,6 @@
     ""cbor"": ""^3.0.3"",
     ""commander"": ""^2.11.0"",
     ""dockerode"": ""^2.5.0"",
-    ""fabric-ca-client"": ""^1.4.0"",
-    ""fabric-client"": ""^1.4.0"",
-    ""fabric-network"": ""^1.4.0"",
     ""fs-extra"": ""^4.0.2"",
     ""grpc"": ""^1.18.0"",",,2019-02-27 00:52:05,https://api.github.com/repos/hyperledger/caliper/pulls/comments/260243316,https://github.com/hyperledger/caliper/pull/332#discussion_r260243316,aklenik
https://github.com/hyperledger/caliper/pull/330,https://github.com/hyperledger/caliper/pull/330,"Any reason for changing the default? Plus PR #287 will make the parameters mandatory, so there won't be any default values anyway.",6f488bcbd337d7df714947f18d4b567c575adb05,2019-02-25 10:36:46,259764612,"@@ -57,7 +57,7 @@ function main() {
     let absNetworkFile;
     if(typeof networkFile === 'undefined') {
         try{
-            absNetworkFile = Util.resolvePath('network/fabric-v1.1/2org1peergoleveldb/fabric-go-tls.json');
+            absNetworkFile = Util.resolvePath('network/fabric-v1.1/2org1peergoleveldb/fabric-node-tls.json');",,2019-03-04 15:14:16,https://api.github.com/repos/hyperledger/caliper/pulls/comments/259764612,https://github.com/hyperledger/caliper/pull/330#discussion_r259764612,aklenik
https://github.com/hyperledger/caliper/pull/330,https://github.com/hyperledger/caliper/pull/330,"Instead of manually accessing the config file, please use the built-in config mechanism of Caliper. Because this way you could only change these settings through the config file (and we want to avoid changing files, that's the purpose of the PR). You can access the configs this way:

```js
// at the beginning of the file
const config = require('./config.util.js');

// ...
// in the run function
let skipStart = config.getConfigSetting('core:skipStartScript', false);
// because command line options are parsed as strings
skipStart = skipStart === true || skipStart === 'true'; 
let skipEnd = config.getConfigSetting('core:skipEndScript', false);
skipEnd = skipEnd === true || skipEnd === 'true';

// now you can use them in the two if conditions
```",6f488bcbd337d7df714947f18d4b567c575adb05,2019-02-25 10:47:35,259769081,"@@ -331,9 +335,10 @@ module.exports.run = async function(configFile, networkFile) {
     //let configObject = require(absConfigFile);
     let configObject = Util.parseYaml(absConfigFile);
     let networkObject = require(absNetworkFile);
+    let defaultObject = Util.parseYaml(absDefaultConfigFile);",,2019-03-04 15:14:16,https://api.github.com/repos/hyperledger/caliper/pulls/comments/259769081,https://github.com/hyperledger/caliper/pull/330#discussion_r259769081,aklenik
https://github.com/hyperledger/caliper/pull/330,https://github.com/hyperledger/caliper/pull/330,"Line 40-41 is not needed, so this file won't be modified.",6f488bcbd337d7df714947f18d4b567c575adb05,2019-02-26 12:11:56,260256551,"@@ -37,6 +37,8 @@ function main() {
     program.version('0.1')
         .option('-c, --config <file>', 'config file of the benchmark, default is config.json', setConfig)
         .option('-n, --network <file>', 'config file of the blockchain system under test, if not provided, blockchain property in benchmark config is used', setNetwork)
+        .option('-s, --skipstart <argv>', 'argv of starting default fabric network, if not provided, default.yaml will provided')
+        .option('-e, --skipend <argv>', 'argv of ending default network, ,if not provided, default.yaml will provided')",,2019-03-04 15:14:16,https://api.github.com/repos/hyperledger/caliper/pulls/comments/260256551,https://github.com/hyperledger/caliper/pull/330#discussion_r260256551,aklenik
https://github.com/hyperledger/caliper/pull/330,https://github.com/hyperledger/caliper/pull/330,Line 24: commander is not needed in this file,6f488bcbd337d7df714947f18d4b567c575adb05,2019-02-26 12:12:26,260256718,"@@ -20,6 +20,8 @@ const Report  = require('./report.js');
 const Client  = require('./client/client.js');
 const Util = require('./util.js');
 const logger = Util.getLogger('bench-flow.js');
+const config = require('./config-util.js');
+let program = require('commander');",,2019-03-04 15:14:16,https://api.github.com/repos/hyperledger/caliper/pulls/comments/260256718,https://github.com/hyperledger/caliper/pull/330#discussion_r260256718,aklenik
https://github.com/hyperledger/caliper/pull/330,https://github.com/hyperledger/caliper/pull/330,"Line 336-337: the set lines are not needed, `nconf` will set them automatically",6f488bcbd337d7df714947f18d4b567c575adb05,2019-02-26 12:13:10,260256952,"@@ -331,14 +333,21 @@ module.exports.run = async function(configFile, networkFile) {
     //let configObject = require(absConfigFile);
     let configObject = Util.parseYaml(absConfigFile);
     let networkObject = require(absNetworkFile);
+    config.setConfigSetting('core:skipStartScript', program.skipstart);
+    config.setConfigSetting('core:skipEndScript', program.skipend);",,2019-03-04 15:14:16,https://api.github.com/repos/hyperledger/caliper/pulls/comments/260256952,https://github.com/hyperledger/caliper/pull/330#discussion_r260256952,aklenik
https://github.com/hyperledger/caliper/pull/330,https://github.com/hyperledger/caliper/pull/330,I think it should be `if (!skipEnd)`,6f488bcbd337d7df714947f18d4b567c575adb05,2019-02-26 12:14:08,260257240,"@@ -383,8 +392,9 @@ module.exports.run = async function(configFile, networkFile) {
             if (!networkObject.caliper.command.end.trim()) {
                 logger.error('End command is specified but it is empty');
             } else {
-
-                await execAsync(networkObject.caliper.command.end);
+                if(skipEnd){",,2019-03-04 15:14:16,https://api.github.com/repos/hyperledger/caliper/pulls/comments/260257240,https://github.com/hyperledger/caliper/pull/330#discussion_r260257240,aklenik
https://github.com/hyperledger/caliper/pull/330,https://github.com/hyperledger/caliper/pull/330,I think it should be `if (!skipStart)`,6f488bcbd337d7df714947f18d4b567c575adb05,2019-02-26 12:14:10,260257139,"@@ -331,14 +333,21 @@ module.exports.run = async function(configFile, networkFile) {
     //let configObject = require(absConfigFile);
     let configObject = Util.parseYaml(absConfigFile);
     let networkObject = require(absNetworkFile);
+    config.setConfigSetting('core:skipStartScript', program.skipstart);
+    config.setConfigSetting('core:skipEndScript', program.skipend);
+    let skipStart = config.getConfigSetting('core:skipStartScript', false);
+    let skipEnd = config.getConfigSetting('core:skipEndScript', false);
+    skipStart = skipStart === true || skipStart === 'true';
+    skipEnd = skipEnd === true || skipEnd === 'true';
 
     try {
         if (networkObject.hasOwnProperty('caliper') && networkObject.caliper.hasOwnProperty('command') && networkObject.caliper.command.hasOwnProperty('start')) {
             if (!networkObject.caliper.command.start.trim()) {
                 throw new Error('Start command is specified but it is empty');
             }
-
-            await execAsync(networkObject.caliper.command.start);
+            if(skipStart){",,2019-03-04 15:14:16,https://api.github.com/repos/hyperledger/caliper/pulls/comments/260257139,https://github.com/hyperledger/caliper/pull/330#discussion_r260257139,aklenik
https://github.com/hyperledger/caliper/pull/330,https://github.com/hyperledger/caliper/pull/330,"Line 335-336 is confusing, basically, you could set the same setting with two different names. `core:skip(Start/End)Script` will be automatically set when the `config` object is included/created. So please remove these lines.

I know `core:skip(Start/End)Script` is longer than writing `skipStart/End` in the command line, but Caliper will support many configuration points for many modules, so it's critical to identify them hierarchically. 

Fabric also has some really long settings names, but it's intuitive and maintainable :)",6f488bcbd337d7df714947f18d4b567c575adb05,2019-02-27 14:21:22,260769485,"@@ -331,14 +332,21 @@ module.exports.run = async function(configFile, networkFile) {
     //let configObject = require(absConfigFile);
     let configObject = Util.parseYaml(absConfigFile);
     let networkObject = require(absNetworkFile);
+    config.setConfigSetting('core:skipStartScript', config.getConfig()._config.argv().get('skipstart'));
+    config.setConfigSetting('core:skipEndScript', config.getConfig()._config.argv().get('skipend'));",,2019-03-04 15:14:16,https://api.github.com/repos/hyperledger/caliper/pulls/comments/260769485,https://github.com/hyperledger/caliper/pull/330#discussion_r260769485,aklenik
https://github.com/hyperledger/caliper/pull/330,https://github.com/hyperledger/caliper/pull/330,This issue is still not resolved.,6f488bcbd337d7df714947f18d4b567c575adb05,2019-02-27 14:21:51,260769720,"@@ -331,14 +333,21 @@ module.exports.run = async function(configFile, networkFile) {
     //let configObject = require(absConfigFile);
     let configObject = Util.parseYaml(absConfigFile);
     let networkObject = require(absNetworkFile);
+    config.setConfigSetting('core:skipStartScript', program.skipstart);
+    config.setConfigSetting('core:skipEndScript', program.skipend);
+    let skipStart = config.getConfigSetting('core:skipStartScript', false);
+    let skipEnd = config.getConfigSetting('core:skipEndScript', false);
+    skipStart = skipStart === true || skipStart === 'true';
+    skipEnd = skipEnd === true || skipEnd === 'true';
 
     try {
         if (networkObject.hasOwnProperty('caliper') && networkObject.caliper.hasOwnProperty('command') && networkObject.caliper.command.hasOwnProperty('start')) {
             if (!networkObject.caliper.command.start.trim()) {
                 throw new Error('Start command is specified but it is empty');
             }
-
-            await execAsync(networkObject.caliper.command.start);
+            if(skipStart){",,2019-03-04 15:14:16,https://api.github.com/repos/hyperledger/caliper/pulls/comments/260769720,https://github.com/hyperledger/caliper/pull/330#discussion_r260769720,aklenik
https://github.com/hyperledger/caliper/pull/330,https://github.com/hyperledger/caliper/pull/330,This issue is still not resolved,6f488bcbd337d7df714947f18d4b567c575adb05,2019-02-27 14:22:05,260769813,"@@ -383,8 +392,9 @@ module.exports.run = async function(configFile, networkFile) {
             if (!networkObject.caliper.command.end.trim()) {
                 logger.error('End command is specified but it is empty');
             } else {
-
-                await execAsync(networkObject.caliper.command.end);
+                if(skipEnd){",,2019-03-04 15:14:16,https://api.github.com/repos/hyperledger/caliper/pulls/comments/260769813,https://github.com/hyperledger/caliper/pull/330#discussion_r260769813,aklenik
https://github.com/hyperledger/caliper/pull/330,https://github.com/hyperledger/caliper/pull/330,i got it,6f488bcbd337d7df714947f18d4b567c575adb05,2019-02-28 10:13:24,261126633,"@@ -331,14 +333,21 @@ module.exports.run = async function(configFile, networkFile) {
     //let configObject = require(absConfigFile);
     let configObject = Util.parseYaml(absConfigFile);
     let networkObject = require(absNetworkFile);
+    config.setConfigSetting('core:skipStartScript', program.skipstart);
+    config.setConfigSetting('core:skipEndScript', program.skipend);
+    let skipStart = config.getConfigSetting('core:skipStartScript', false);
+    let skipEnd = config.getConfigSetting('core:skipEndScript', false);
+    skipStart = skipStart === true || skipStart === 'true';
+    skipEnd = skipEnd === true || skipEnd === 'true';
 
     try {
         if (networkObject.hasOwnProperty('caliper') && networkObject.caliper.hasOwnProperty('command') && networkObject.caliper.command.hasOwnProperty('start')) {
             if (!networkObject.caliper.command.start.trim()) {
                 throw new Error('Start command is specified but it is empty');
             }
-
-            await execAsync(networkObject.caliper.command.start);
+            if(skipStart){",,2019-03-04 15:14:16,https://api.github.com/repos/hyperledger/caliper/pulls/comments/261126633,https://github.com/hyperledger/caliper/pull/330#discussion_r261126633,clumsky
https://github.com/hyperledger/caliper/pull/330,https://github.com/hyperledger/caliper/pull/330,"Please remove Line 43-44, since they're automatically done by nconf.",6f488bcbd337d7df714947f18d4b567c575adb05,2019-02-28 14:31:44,261219593,"@@ -38,8 +38,10 @@ module.exports.setConfigSetting = (name, value) => {
 //
 //Internal method to get an override setting to the configuration settings
 //
-exports.getConfigSetting = (name, default_value) => {
+module.exports.getConfigSetting = (name, default_value) => {
     const config = exports.getConfig();
+    config.set('core:skipStartScript', config._config.argv().get('skipStartScript'));
+    config.set('core:skipEndScript', config._config.argv().get('skipEndScript'));",,2019-03-04 15:14:16,https://api.github.com/repos/hyperledger/caliper/pulls/comments/261219593,https://github.com/hyperledger/caliper/pull/330#discussion_r261219593,aklenik
https://github.com/hyperledger/caliper/pull/330,https://github.com/hyperledger/caliper/pull/330,"you mean i should modify the function constructor() of Config class in src/comm/Config.js.  but it also need use set function. 
i am not understand about  ""automatically done by nconf""",6f488bcbd337d7df714947f18d4b567c575adb05,2019-03-01 06:08:41,261488238,"@@ -38,8 +38,10 @@ module.exports.setConfigSetting = (name, value) => {
 //
 //Internal method to get an override setting to the configuration settings
 //
-exports.getConfigSetting = (name, default_value) => {
+module.exports.getConfigSetting = (name, default_value) => {
     const config = exports.getConfig();
+    config.set('core:skipStartScript', config._config.argv().get('skipStartScript'));
+    config.set('core:skipEndScript', config._config.argv().get('skipEndScript'));",,2019-03-04 15:14:16,https://api.github.com/repos/hyperledger/caliper/pulls/comments/261488238,https://github.com/hyperledger/caliper/pull/330#discussion_r261488238,clumsky
https://github.com/hyperledger/caliper/pull/330,https://github.com/hyperledger/caliper/pull/330,"@clumsky When you execute the following:
`node main.js -c someconfig.yaml -n somenetwork.yaml --core:skipStartScript=false`
nconf will automatically save every argument (and environment variable, and attributes in the config file, etc.) when it's initialized. So you don't need to set `core:skipStartScript` manually. 

That's the beauty of nconf. If you need some new runtime options (like with this PR), you just: 
1. write the code for reading that setting
2. add its default value to the config file
3. the user can set it from outside the program (like command line argument, env. variable)

So no need to ""parse it"" yourself.",6f488bcbd337d7df714947f18d4b567c575adb05,2019-03-01 10:31:31,261552487,"@@ -38,8 +38,10 @@ module.exports.setConfigSetting = (name, value) => {
 //
 //Internal method to get an override setting to the configuration settings
 //
-exports.getConfigSetting = (name, default_value) => {
+module.exports.getConfigSetting = (name, default_value) => {
     const config = exports.getConfig();
+    config.set('core:skipStartScript', config._config.argv().get('skipStartScript'));
+    config.set('core:skipEndScript', config._config.argv().get('skipEndScript'));",,2019-03-04 15:14:16,https://api.github.com/repos/hyperledger/caliper/pulls/comments/261552487,https://github.com/hyperledger/caliper/pull/330#discussion_r261552487,aklenik
https://github.com/hyperledger/caliper/pull/296,https://github.com/hyperledger/caliper/pull/296,"The commands ""start"" and ""end"" here should use the directory""2org1peergoleveldb"".",60646729d5369e646c3aadbf576e29b1f0d606ab,2019-02-11 05:56:58,255385978,"@@ -0,0 +1,155 @@
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+name: Fabric
+version: ""1.0""
+mutual-tls: false
+
+caliper:
+  blockchain: fabric-ccp
+  command:
+    start: docker-compose -f network/fabric-v1.0/2org1peercouchdb/docker-compose-tls.yaml up -d;sleep 3s",,2019-03-01 14:02:26,https://api.github.com/repos/hyperledger/caliper/pulls/comments/255385978,https://github.com/hyperledger/caliper/pull/296#discussion_r255385978,panyu4
https://github.com/hyperledger/caliper/pull/296,https://github.com/hyperledger/caliper/pull/296,"The commands ""start"" and ""end"" here should use the directory""2org1peergoleveldb"".",60646729d5369e646c3aadbf576e29b1f0d606ab,2019-02-11 05:59:00,255386162,"@@ -0,0 +1,154 @@
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+name: Fabric
+version: ""1.0""
+mutual-tls: true
+
+caliper:
+  blockchain: fabric-ccp
+  command:
+    start: docker-compose -f network/fabric-v1.1/2org1peercouchdb/docker-compose-mutual-tls.yaml up -d;sleep 3s",,2019-03-01 14:02:26,https://api.github.com/repos/hyperledger/caliper/pulls/comments/255386162,https://github.com/hyperledger/caliper/pull/296#discussion_r255386162,panyu4
https://github.com/hyperledger/caliper/pull/296,https://github.com/hyperledger/caliper/pull/296,"The commands ""start"" and ""end"" here should use the directory""2org1peergoleveldb"".",60646729d5369e646c3aadbf576e29b1f0d606ab,2019-02-11 05:59:18,255386190,"@@ -0,0 +1,154 @@
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+name: Fabric
+version: ""1.0""
+mutual-tls: false
+
+caliper:
+  blockchain: fabric-ccp
+  command:
+    start: docker-compose -f network/fabric-v1.1/2org1peercouchdb/docker-compose-tls.yaml up -d;sleep 3s",,2019-03-01 14:02:26,https://api.github.com/repos/hyperledger/caliper/pulls/comments/255386190,https://github.com/hyperledger/caliper/pull/296#discussion_r255386190,panyu4
https://github.com/hyperledger/caliper/pull/296,https://github.com/hyperledger/caliper/pull/296,"The commands ""start"" and ""end"" here should use the directory""2org1peergoleveldb"".",60646729d5369e646c3aadbf576e29b1f0d606ab,2019-02-11 05:59:49,255386237,"@@ -0,0 +1,146 @@
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+name: Fabric
+version: ""1.0""
+mutual-tls: true
+
+caliper:
+  blockchain: fabric-ccp
+  command:
+    start: docker-compose -f network/fabric-v1.1/2org1peercouchdb/docker-compose-mutual-tls.yaml up -d;sleep 3s",,2019-03-01 14:02:26,https://api.github.com/repos/hyperledger/caliper/pulls/comments/255386237,https://github.com/hyperledger/caliper/pull/296#discussion_r255386237,panyu4
https://github.com/hyperledger/caliper/pull/296,https://github.com/hyperledger/caliper/pull/296,"The commands ""start"" and ""end"" here should use the directory""2org1peergoleveldb"".",60646729d5369e646c3aadbf576e29b1f0d606ab,2019-02-11 06:01:14,255386347,"@@ -0,0 +1,154 @@
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+name: Fabric
+version: ""1.0""
+mutual-tls: false
+
+caliper:
+  blockchain: fabric-ccp
+  command:
+    start: docker-compose -f network/fabric-v1.2/2org1peercouchdb/docker-compose-tls.yaml up -d;sleep 3s",,2019-03-01 14:02:26,https://api.github.com/repos/hyperledger/caliper/pulls/comments/255386347,https://github.com/hyperledger/caliper/pull/296#discussion_r255386347,panyu4
https://github.com/hyperledger/caliper/pull/296,https://github.com/hyperledger/caliper/pull/296,"The commands ""start"" and ""end"" here should use the directory""2org1peergoleveldb"".",60646729d5369e646c3aadbf576e29b1f0d606ab,2019-02-11 06:02:08,255386444,"@@ -0,0 +1,146 @@
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+name: Fabric
+version: ""1.0""
+mutual-tls: true
+
+caliper:
+  blockchain: fabric-ccp
+  command:
+    start: docker-compose -f network/fabric-v1.2/2org1peercouchdb/docker-compose-mutual-tls.yaml up -d;sleep 3s",,2019-03-01 14:02:26,https://api.github.com/repos/hyperledger/caliper/pulls/comments/255386444,https://github.com/hyperledger/caliper/pull/296#discussion_r255386444,panyu4
https://github.com/hyperledger/caliper/pull/296,https://github.com/hyperledger/caliper/pull/296,"The commands ""start"" and ""end"" here should use the directory""2org1peergoleveldb"".",60646729d5369e646c3aadbf576e29b1f0d606ab,2019-02-11 06:02:43,255386491,"@@ -0,0 +1,146 @@
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+name: Fabric
+version: ""1.0""
+mutual-tls: false
+
+caliper:
+  blockchain: fabric-ccp
+  command:
+    start: docker-compose -f network/fabric-v1.2/2org1peercouchdb/docker-compose-tls.yaml up -d;sleep 3s",,2019-03-01 14:02:26,https://api.github.com/repos/hyperledger/caliper/pulls/comments/255386491,https://github.com/hyperledger/caliper/pull/296#discussion_r255386491,panyu4
https://github.com/hyperledger/caliper/pull/296,https://github.com/hyperledger/caliper/pull/296,"The commands ""start"" and ""end"" here should use the directory""2org1peergoleveldb"".",60646729d5369e646c3aadbf576e29b1f0d606ab,2019-02-11 06:05:17,255386721,"@@ -0,0 +1,154 @@
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+name: Fabric
+version: ""1.0""
+mutual-tls: true
+
+caliper:
+  blockchain: fabric-ccp
+  command:
+    start: docker-compose -f network/fabric-v1.2/2org1peercouchdb/docker-compose-mutual-tls.yaml up -d;sleep 3s",,2019-03-01 14:02:26,https://api.github.com/repos/hyperledger/caliper/pulls/comments/255386721,https://github.com/hyperledger/caliper/pull/296#discussion_r255386721,panyu4
https://github.com/hyperledger/caliper/pull/296,https://github.com/hyperledger/caliper/pull/296,"Benchmark test modules should give transparent support to kinds of blockchain(different types or versions), so here it would be better to reduce the tests module's dependency with the certain type (or certain version) of blockchain system. Could you please move this Fabric-ccp dependency into the file [blockchain.js](https://github.com/hyperledger/caliper/blob/master/src/comm/blockchain.js) ? And for the parameter 'invoker', is it possible to extract a common invoker instance ? Then it could be used into kinds of blockchain system.  As for the parameter 'channel', can we  add one more parameter (eg. named as 'optionalPara') with data type Map(eg. `{fabric: {channel: 'mychannel'}}` ) to the function invokeSmartContract?  What do you think about this?",60646729d5369e646c3aadbf576e29b1f0d606ab,2019-02-25 10:00:34,259750615,"@@ -39,16 +46,38 @@ module.exports.run = function() {
         'info' : '',
         'item' : buf
     };
-    return bc.invokeSmartContract(contx, 'drm', 'v0', {verb : 'publish', item: JSON.stringify(item)}, 120)
-        .then((results)=>{
-            for (let i in results){
-                let stat = results[i];
-                if(stat.IsCommitted()) {
-                    ids.push(stat.GetResult().toString());
+
+    if (bc.bcType === 'fabric-ccp') {",20,2019-03-01 14:02:26,https://api.github.com/repos/hyperledger/caliper/pulls/comments/259750615,https://github.com/hyperledger/caliper/pull/296#discussion_r259750615,feihujiang
https://github.com/hyperledger/caliper/pull/296,https://github.com/hyperledger/caliper/pull/296,"@feihujiang I thought a lot about this, and there is also TODO in the development doc about this issue (also highlighted in the [doc of the adapter](https://aklenik.github.io/caliper/docs/Fabric_Ccp_Configuration.html#the-run-callback)).

The problem is, that the abstract API of the adapters has an inconsistent signature compared to what is needed. My suggestion in the dev docs is that we adopt the Fabric SDK convention, meaning the following: the adapter functions (mainly invoke and query) take some `context` for the test round like in the current version; an `options` describing everything related to the call, and a `timeout`. 

The `options` is a platform-specific object since, for example, each platform requires a different way to identify a target smart contract (Fabric has a `channel->chaincode->version` ""target ID"", Sawtooth and Burrow has different ways). So the user callback can't really be platform independent, there will be a need for a ""business logic -> platform syntax"" translation if the user plans to target multiple platforms. 

The `if (bc.bcType === 'fabric-ccp')` line could be omitted by making the abstract adapter API consistent across platforms. But I like the idea of extracting some common concepts (like invoker) into the adapter interface. But we need to gather the common concepts of platforms first.

I'm not sure I understand the need for `{fabric: {channel: 'mychannel'}}`, could you give an example or use case for this parameter?",60646729d5369e646c3aadbf576e29b1f0d606ab,2019-02-25 10:28:08,259760903,"@@ -39,16 +46,38 @@ module.exports.run = function() {
         'info' : '',
         'item' : buf
     };
-    return bc.invokeSmartContract(contx, 'drm', 'v0', {verb : 'publish', item: JSON.stringify(item)}, 120)
-        .then((results)=>{
-            for (let i in results){
-                let stat = results[i];
-                if(stat.IsCommitted()) {
-                    ids.push(stat.GetResult().toString());
+
+    if (bc.bcType === 'fabric-ccp') {",20,2019-03-01 14:02:26,https://api.github.com/repos/hyperledger/caliper/pulls/comments/259760903,https://github.com/hyperledger/caliper/pull/296#discussion_r259760903,aklenik
https://github.com/hyperledger/caliper/pull/296,https://github.com/hyperledger/caliper/pull/296,"No, my suggestion isn't providing the abstract API of the adapters. I mean it's better that the specific benchmark test (simple/drm etc) could be transparent to the blockchain systems.
Yes, ""business logic -> platform syntax"" is necessarily needed. To each platform requires a different way to identify a target smart contract, Fabric has a `channel->chaincode->version` ""target ID"", Sawtooth and Burrow has different ways. Could we add a mapping from a common business logic name to the target smart contract on the network Configuration File? So that the benchmark test (simple/drm etc) could use the common business logic name. If we could, {fabric: {channel: 'mychannel'}} is meaningless, avoid it.",60646729d5369e646c3aadbf576e29b1f0d606ab,2019-02-25 12:34:05,259803277,"@@ -39,16 +46,38 @@ module.exports.run = function() {
         'info' : '',
         'item' : buf
     };
-    return bc.invokeSmartContract(contx, 'drm', 'v0', {verb : 'publish', item: JSON.stringify(item)}, 120)
-        .then((results)=>{
-            for (let i in results){
-                let stat = results[i];
-                if(stat.IsCommitted()) {
-                    ids.push(stat.GetResult().toString());
+
+    if (bc.bcType === 'fabric-ccp') {",20,2019-03-01 14:02:26,https://api.github.com/repos/hyperledger/caliper/pulls/comments/259803277,https://github.com/hyperledger/caliper/pull/296#discussion_r259803277,feihujiang
https://github.com/hyperledger/caliper/pull/296,https://github.com/hyperledger/caliper/pull/296,"@feihujiang That's exactly what I was thinking after I wrote my previous comment. Just like users are identified with a unique name in this adapter, a chaincode specification inside a channel could also be labeled with a `smartContractId` attribute, that must be unique on a network level. 

So the user callback could reference it as `targetContract: simple`, and the adapter would manage the `simple => mychannel/simple/v0` mapping (similar for the other adapters). The target nodes and the invoker identity could also be referenced by name; these are probably common concepts for each (private/permissioned) platform.

However, some attributes cannot be generalized, like the target orderer to use (this is optional, but the user should be able to define it if needed), the function to invoke inside the chaincode (okay, maybe this could be common), and the syntax of transaction arguments (array of strings, named parameters, transaction dependencies, batches, etc).

So a minimal platform-specific code/arguments cannot be avoided for a multi-target benchmark. But I think it's a good tradeoff, plus this code should be really short.

I could incorporate this contract mapping into this adapter, but what about the current signature of the `invokeSmartContract` function? The separate `contractID` and `contractVersion` parameters still bother me a bit :) The new ID name should also incorporate the version because it's easy to mess up the versions in the callback (`""1.0""` vs `""v1""`)",60646729d5369e646c3aadbf576e29b1f0d606ab,2019-02-25 13:11:47,259815578,"@@ -39,16 +46,38 @@ module.exports.run = function() {
         'info' : '',
         'item' : buf
     };
-    return bc.invokeSmartContract(contx, 'drm', 'v0', {verb : 'publish', item: JSON.stringify(item)}, 120)
-        .then((results)=>{
-            for (let i in results){
-                let stat = results[i];
-                if(stat.IsCommitted()) {
-                    ids.push(stat.GetResult().toString());
+
+    if (bc.bcType === 'fabric-ccp') {",20,2019-03-01 14:02:26,https://api.github.com/repos/hyperledger/caliper/pulls/comments/259815578,https://github.com/hyperledger/caliper/pull/296#discussion_r259815578,aklenik
https://github.com/hyperledger/caliper/pull/296,https://github.com/hyperledger/caliper/pull/296,"@aklenik Your PR is a great job! 
It is a good way that the adapter would manage the `simple => mychannel/simple/v0` mapping (similar for the other adapters).
I agree with you that a minimal platform-specific code/arguments cannot be avoided for a multi-target benchmark. And I think trying our best to extract common concepts is benefit for users. 
The new ID name should also incorporate the version==>exactly.

",60646729d5369e646c3aadbf576e29b1f0d606ab,2019-02-26 07:28:46,260155235,"@@ -39,16 +46,38 @@ module.exports.run = function() {
         'info' : '',
         'item' : buf
     };
-    return bc.invokeSmartContract(contx, 'drm', 'v0', {verb : 'publish', item: JSON.stringify(item)}, 120)
-        .then((results)=>{
-            for (let i in results){
-                let stat = results[i];
-                if(stat.IsCommitted()) {
-                    ids.push(stat.GetResult().toString());
+
+    if (bc.bcType === 'fabric-ccp') {",20,2019-03-01 14:02:26,https://api.github.com/repos/hyperledger/caliper/pulls/comments/260155235,https://github.com/hyperledger/caliper/pull/296#discussion_r260155235,feihujiang
https://github.com/hyperledger/caliper/pull/296,https://github.com/hyperledger/caliper/pull/296,"@feihujiang Then I'll add these features to this adapter, as a best-practice to follow for other adapters. So, for now, this adapter will follow the current API, but yeah, we'll need to consolidate it later ðŸ‘ 
I'll ping you when it's ready.",60646729d5369e646c3aadbf576e29b1f0d606ab,2019-02-26 11:34:26,260244846,"@@ -39,16 +46,38 @@ module.exports.run = function() {
         'info' : '',
         'item' : buf
     };
-    return bc.invokeSmartContract(contx, 'drm', 'v0', {verb : 'publish', item: JSON.stringify(item)}, 120)
-        .then((results)=>{
-            for (let i in results){
-                let stat = results[i];
-                if(stat.IsCommitted()) {
-                    ids.push(stat.GetResult().toString());
+
+    if (bc.bcType === 'fabric-ccp') {",20,2019-03-01 14:02:26,https://api.github.com/repos/hyperledger/caliper/pulls/comments/260244846,https://github.com/hyperledger/caliper/pull/296#discussion_r260244846,aklenik
https://github.com/hyperledger/caliper/pull/296,https://github.com/hyperledger/caliper/pull/296,:+1:  :),60646729d5369e646c3aadbf576e29b1f0d606ab,2019-02-27 03:59:23,260585027,"@@ -39,16 +46,38 @@ module.exports.run = function() {
         'info' : '',
         'item' : buf
     };
-    return bc.invokeSmartContract(contx, 'drm', 'v0', {verb : 'publish', item: JSON.stringify(item)}, 120)
-        .then((results)=>{
-            for (let i in results){
-                let stat = results[i];
-                if(stat.IsCommitted()) {
-                    ids.push(stat.GetResult().toString());
+
+    if (bc.bcType === 'fabric-ccp') {",20,2019-03-01 14:02:26,https://api.github.com/repos/hyperledger/caliper/pulls/comments/260585027,https://github.com/hyperledger/caliper/pull/296#discussion_r260585027,feihujiang
https://github.com/hyperledger/caliper/pull/291,https://github.com/hyperledger/caliper/pull/291,"This call is allowed by the 1.1 SDK, but it's not compatible with a 1.0 Fabric backend.",e6bff49bafc6b6b88e9cc95cfffd1d377d876540,2019-02-15 12:47:23,257220751,"@@ -551,7 +551,8 @@ async function getcontext(channelConfig, clientIdx, txModeFile) {
                     'grpc.keepalive_time_ms' : 360000   // time to wait for ping response, 6 minutes
                     // 'grpc.http2.keepalive_time' : 15
                 }
-            );
+            );*/
+            let eh = channel.newChannelEventHub(peer);",15,2019-02-15 12:54:42,https://api.github.com/repos/hyperledger/caliper/pulls/comments/257220751,https://github.com/hyperledger/caliper/pull/291#discussion_r257220751,aklenik
https://github.com/hyperledger/caliper/pull/291,https://github.com/hyperledger/caliper/pull/291,"As stated by the comments above, an error/timeout from the broadcast call doesn't necessarily mean that the ordering failed. It's just an ACK from the orderer, that might get lost. That's why the events will determine the final state of the transaction.",e6bff49bafc6b6b88e9cc95cfffd1d377d876540,2019-02-15 12:49:33,257221337,"@@ -733,6 +733,8 @@ async function sendTransaction(context, signedTransaction, invokeStatus, startTi
             errFlag |= TxErrorEnum.OrdererResponseError;
             invokeStatus.SetFlag(errFlag);
             invokeStatus.SetErrMsg(TxErrorIndex.OrdererResponseError,err.toString());
+            invokeStatus.SetStatusFail();",40,2019-02-15 12:54:42,https://api.github.com/repos/hyperledger/caliper/pulls/comments/257221337,https://github.com/hyperledger/caliper/pull/291#discussion_r257221337,aklenik
https://github.com/hyperledger/caliper/pull/291,https://github.com/hyperledger/caliper/pull/291,"The exception is thrown ""to the end"", so the errors can be handled at one place at the end of the function. Otherwise, there will be a lot of repetitive code.",e6bff49bafc6b6b88e9cc95cfffd1d377d876540,2019-02-15 12:51:58,257222037,"@@ -859,13 +861,16 @@ async function invokebycontext(context, id, version, args, timeout){
                 //invokeStatus.Set('invokeLatency', (Date.now() - beforeInvokeTime));
                 one_good = true;
             } else {
-                let err = new Error('Endorsement denied: ' + proposal_response.toString());
+                //let err = new Error('Endorsement denied: ' + proposal_response.toString());
                 errFlag |= TxErrorEnum.BadProposalResponseError;
                 invokeStatus.SetFlag(errFlag);
-                invokeStatus.SetErrMsg(TxErrorIndex.BadProposalResponseError, err.toString());
+                invokeStatus.SetErrMsg(TxErrorIndex.BadProposalResponseError, 'Endorsement denied: ' + proposal_response.toString());
                 // explicit rejection, early life-cycle termination, definitely failed
                 invokeStatus.SetVerification(true);
-                throw err;
+                commLogger.error('Failed to complete transaction [' + txId.substring(0, 5) + '...]:' + ' Endorsement denied: ' + proposal_response.toString());",58,2019-02-15 12:54:42,https://api.github.com/repos/hyperledger/caliper/pulls/comments/257222037,https://github.com/hyperledger/caliper/pull/291#discussion_r257222037,aklenik
https://github.com/hyperledger/caliper/pull/291,https://github.com/hyperledger/caliper/pull/291,What's the reason for sleeping 5ms for every 100th transaction?,e6bff49bafc6b6b88e9cc95cfffd1d377d876540,2019-02-15 12:53:51,257222551,"@@ -62,9 +62,13 @@ class FixedFeedbackRateController extends RateInterface{
             return;
         }
 
-        let diff = (this.sleepTime * idx - ((Date.now() - this.total_sleep_time) - start));
+        /*let diff = (this.sleepTime * idx - ((Date.now() - this.total_sleep_time) - start));
         if( diff > 5) {
             return await util.sleep(diff);
+        }*/
+
+        if(idx % 100 === 0) {",10,2019-02-15 12:54:42,https://api.github.com/repos/hyperledger/caliper/pulls/comments/257222551,https://github.com/hyperledger/caliper/pull/291#discussion_r257222551,aklenik
https://github.com/hyperledger/caliper/pull/290,https://github.com/hyperledger/caliper/pull/290,Names now are changed into `ca.org1.example.com`. Please make sure all of the ca names are changed.,8bc7d7d3676d92c295468756cb406d32c83d99ea,2019-02-03 09:42:17,253294599,"@@ -0,0 +1,101 @@
+{
+  ""caliper"": {
+    ""blockchain"": ""fabric"",
+    ""command"" : {
+      ""start"": ""docker-compose -f network/fabric-v1.4/2org1peercouchdb/docker-compose-tls.yaml up -d;sleep 3s"",
+      ""end"" : ""docker-compose -f network/fabric-v1.4/2org1peercouchdb/docker-compose-tls.yaml down;docker rm $(docker ps -aq);docker rmi $(docker images dev* -q)""
+    }
+  },
+  ""fabric"": {
+    ""cryptodir"": ""network/fabric-v1.4/config/crypto-config"",
+    ""network"": {
+      ""orderer"": {
+        ""url"": ""grpcs://localhost:7050"",
+        ""mspid"": ""OrdererMSP"",
+        ""msp"": ""network/fabric-v1.4/config/crypto-config/ordererOrganizations/example.com/msp/"",
+        ""server-hostname"": ""orderer.example.com"",
+        ""tls_cacerts"": ""network/fabric-v1.4/config/crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/ca.crt""
+      },
+      ""org1"": {
+        ""name"": ""peerOrg1"",
+        ""mspid"": ""Org1MSP"",
+        ""msp"": ""network/fabric-v1.4/config/crypto-config/peerOrganizations/org1.example.com/msp/"",
+        ""ca"": {
+          ""url"": ""https://localhost:7054"",
+          ""name"": ""ca-org1""",,2019-02-20 05:23:02,https://api.github.com/repos/hyperledger/caliper/pulls/comments/253294599,https://github.com/hyperledger/caliper/pull/290#discussion_r253294599,panyu4
https://github.com/hyperledger/caliper/pull/287,https://github.com/hyperledger/caliper/pull/287,These results are needed for testing. ,c2ce1f9998786e395e82a59a2fbfa20d01302b3c,2019-01-22 02:37:15,249625205,"@@ -170,11 +171,6 @@ function processResult(results, label){
             resultTable[1] = getResultValue(r);
         }
 
-        let sTP = r.sTPTotal / r.length;
-        let sT = r.sTTotal / r.length;
-        logger.debug('sendTransactionProposal: ' + sTP + 'ms length: ' + r.length);
-        logger.debug('sendTransaction: ' + sT + 'ms');
-        logger.debug('invokeLantency: ' + r.invokeTotal / r.length + 'ms');",,2019-03-05 13:00:45,https://api.github.com/repos/hyperledger/caliper/pulls/comments/249625205,https://github.com/hyperledger/caliper/pull/287#discussion_r249625205,panyu4
https://github.com/hyperledger/caliper/pull/287,https://github.com/hyperledger/caliper/pull/287,"The test flow is deleted, so how can caliper complete the test? I'm confused.",c2ce1f9998786e395e82a59a2fbfa20d01302b3c,2019-01-22 02:38:41,249625399,"@@ -221,37 +217,11 @@ async function defaultTest(args, clientArgs, final) {
             trim: args.trim ? args.trim : 0,
             args: args.arguments,
             cb  : args.callback,
-            config: configPath,
+            config: configPath
         };
         // condition for time based or number based test driving
         if (args.txNumber) {
             msg.numb = testRounds[i];
-            // File information for reading or writing transaction request
-            msg.txFile = {roundLength: testRounds.length, roundCurrent: i, txMode: args.txMode};
-            if(args.txMode && args.txMode.type === 'file-write') {
-                logger.info('------ Prepare(file-write) waiting ------');
-                msg.txFile.readWrite = 'write';
-                msg.rateControl = {type: 'fixed-rate', opts: {tps: 400}};
-                try {
-                    await client.startTest(msg, clientArgs, function(){}, testLabel);
-                    msg.numb = testRounds[i];
-                    msg.txFile.readWrite = 'read';
-                    msg.rateControl = args.rateControl[i] ? args.rateControl[i] : {type:'fixed-rate', 'opts' : {'tps': 1}};
-                    if(i === (testRounds.length - 1)) {
-                        logger.info('Waiting 5 seconds...');
-                        logger.info('------ Prepare(file-write) success------');
-                        await Util.sleep(5000);
-                    }
-                } catch (err) {
-                    logger.error('------Prepare(file-write) failed------');
-                    args.txMode.type = 'file-no';
-                }
-
-            }else if(args.txMode && args.txMode.type === 'file-read'){
-                msg.txFile.readWrite = 'read';
-            }else {
-                msg.txFile.readWrite = 'no';
-            }",,2019-03-05 13:00:45,https://api.github.com/repos/hyperledger/caliper/pulls/comments/249625399,https://github.com/hyperledger/caliper/pull/287#discussion_r249625399,panyu4
https://github.com/hyperledger/caliper/pull/287,https://github.com/hyperledger/caliper/pull/287,"Running a benchmark should be independent of running linting and coverage tests. The scripts, in general, need to be organized, so let's start clean with this one.
My suggestions is that a `bench` command should be used that delegates to a common `main.js` file. Something like this:
`""bench"": ""node ./scripts/main.js""`

So running a benchmark would look like this:
`npm run bench -- -c ./bechmark/simple/config-linear-rate.yaml -n ./network/fabric-v1.1/dev/fabric-node.json`",c2ce1f9998786e395e82a59a2fbfa20d01302b3c,2019-02-14 15:46:36,256890164,"@@ -6,13 +6,13 @@
     ""url"": ""https://github.com/hyperledger/caliper""
   },
   ""scripts"": {
-    ""test"": ""npm run lint && npm run nyc && npm run e2e"",
+    ""test"": ""npm run lint && npm run nyc && npm run e2e -- "",",,2019-03-05 13:00:45,https://api.github.com/repos/hyperledger/caliper/pulls/comments/256890164,https://github.com/hyperledger/caliper/pull/287#discussion_r256890164,aklenik
https://github.com/hyperledger/caliper/pull/287,https://github.com/hyperledger/caliper/pull/287,"Since this is the entry point of the process, an error code could be returned",c2ce1f9998786e395e82a59a2fbfa20d01302b3c,2019-02-14 15:48:07,256890841,"@@ -8,65 +8,59 @@
 
 'use strict';
 
-var configFile;
-var networkFile;
 var path = require('path');
 var fs = require('fs-extra');
 var exec = require('child_process').exec;
-
-function setConfig(file) {
-    configFile = path.join('../..', file);
-}
-
-function setNetwork(file) {
-    networkFile = path.join('../..', file);
-}
+const Util = require('../src/comm/util');
 
 function main() {
-    if(process.argv.length < 3) {
-        console.log('undefined benchmark name, should be ""npm test -- benchmark-name [options]""');
-        process.exit(1);
-    }
-
-    let benchmark = process.argv[2];
-    let runDir = path.join(__dirname, '../benchmark', benchmark);
-    if(!fs.existsSync(runDir)) {
-        console.log('directory ' + runDir + ' does not exist');
-        process.exit(1);
-    }
-
-    let runExe = path.join(runDir, 'main.js');
-    if(!fs.existsSync(runExe)) {
-        console.log('file ' + runExe + ' does not exist');
-        process.exit(1);
-    }
-
     let program = require('commander');
     program
-        .option('-c, --config <file>', 'config file of the benchmark', setConfig)
-        .option('-n, --network <file>', 'config file of the blockchain system under test', setNetwork)
+        .option('-c, --config <file>', 'config file of the benchmark')
+        .option('-n, --network <file>', 'config file of the blockchain system under test')
         .parse(process.argv);
-    let cmd = 'node main.js';
-    if(typeof configFile === 'string') {
-        cmd += ' -c ';
-        cmd += configFile;
+
+    let logger = Util.getLogger('scripts/test.js');
+    let absConfigFile;
+    if(typeof program.config === 'undefined') {
+      logger.error('config file is required');
+      return;",,2019-03-05 13:00:45,https://api.github.com/repos/hyperledger/caliper/pulls/comments/256890841,https://github.com/hyperledger/caliper/pull/287#discussion_r256890841,aklenik
https://github.com/hyperledger/caliper/pull/287,https://github.com/hyperledger/caliper/pull/287,"Re-added, not sure why I removed these...",c2ce1f9998786e395e82a59a2fbfa20d01302b3c,2019-02-17 13:59:07,257505192,"@@ -170,11 +171,6 @@ function processResult(results, label){
             resultTable[1] = getResultValue(r);
         }
 
-        let sTP = r.sTPTotal / r.length;
-        let sT = r.sTTotal / r.length;
-        logger.debug('sendTransactionProposal: ' + sTP + 'ms length: ' + r.length);
-        logger.debug('sendTransaction: ' + sT + 'ms');
-        logger.debug('invokeLantency: ' + r.invokeTotal / r.length + 'ms');",,2019-03-05 13:00:45,https://api.github.com/repos/hyperledger/caliper/pulls/comments/257505192,https://github.com/hyperledger/caliper/pull/287#discussion_r257505192,gregdhill
https://github.com/hyperledger/caliper/pull/287,https://github.com/hyperledger/caliper/pull/287,See previous comment.,c2ce1f9998786e395e82a59a2fbfa20d01302b3c,2019-02-17 13:59:24,257505217,"@@ -221,37 +217,11 @@ async function defaultTest(args, clientArgs, final) {
             trim: args.trim ? args.trim : 0,
             args: args.arguments,
             cb  : args.callback,
-            config: configPath,
+            config: configPath
         };
         // condition for time based or number based test driving
         if (args.txNumber) {
             msg.numb = testRounds[i];
-            // File information for reading or writing transaction request
-            msg.txFile = {roundLength: testRounds.length, roundCurrent: i, txMode: args.txMode};
-            if(args.txMode && args.txMode.type === 'file-write') {
-                logger.info('------ Prepare(file-write) waiting ------');
-                msg.txFile.readWrite = 'write';
-                msg.rateControl = {type: 'fixed-rate', opts: {tps: 400}};
-                try {
-                    await client.startTest(msg, clientArgs, function(){}, testLabel);
-                    msg.numb = testRounds[i];
-                    msg.txFile.readWrite = 'read';
-                    msg.rateControl = args.rateControl[i] ? args.rateControl[i] : {type:'fixed-rate', 'opts' : {'tps': 1}};
-                    if(i === (testRounds.length - 1)) {
-                        logger.info('Waiting 5 seconds...');
-                        logger.info('------ Prepare(file-write) success------');
-                        await Util.sleep(5000);
-                    }
-                } catch (err) {
-                    logger.error('------Prepare(file-write) failed------');
-                    args.txMode.type = 'file-no';
-                }
-
-            }else if(args.txMode && args.txMode.type === 'file-read'){
-                msg.txFile.readWrite = 'read';
-            }else {
-                msg.txFile.readWrite = 'no';
-            }",,2019-03-05 13:00:45,https://api.github.com/repos/hyperledger/caliper/pulls/comments/257505217,https://github.com/hyperledger/caliper/pull/287#discussion_r257505217,gregdhill
https://github.com/hyperledger/caliper/pull/287,https://github.com/hyperledger/caliper/pull/287,That makes much more sense :) I've added a new bench target,c2ce1f9998786e395e82a59a2fbfa20d01302b3c,2019-02-17 13:59:56,257505233,"@@ -6,13 +6,13 @@
     ""url"": ""https://github.com/hyperledger/caliper""
   },
   ""scripts"": {
-    ""test"": ""npm run lint && npm run nyc && npm run e2e"",
+    ""test"": ""npm run lint && npm run nyc && npm run e2e -- "",",,2019-03-05 13:00:45,https://api.github.com/repos/hyperledger/caliper/pulls/comments/257505233,https://github.com/hyperledger/caliper/pull/287#discussion_r257505233,gregdhill
https://github.com/hyperledger/caliper/pull/287,https://github.com/hyperledger/caliper/pull/287,"That's the idea, so we can't run without the config set",c2ce1f9998786e395e82a59a2fbfa20d01302b3c,2019-02-17 14:00:39,257505263,"@@ -8,65 +8,59 @@
 
 'use strict';
 
-var configFile;
-var networkFile;
 var path = require('path');
 var fs = require('fs-extra');
 var exec = require('child_process').exec;
-
-function setConfig(file) {
-    configFile = path.join('../..', file);
-}
-
-function setNetwork(file) {
-    networkFile = path.join('../..', file);
-}
+const Util = require('../src/comm/util');
 
 function main() {
-    if(process.argv.length < 3) {
-        console.log('undefined benchmark name, should be ""npm test -- benchmark-name [options]""');
-        process.exit(1);
-    }
-
-    let benchmark = process.argv[2];
-    let runDir = path.join(__dirname, '../benchmark', benchmark);
-    if(!fs.existsSync(runDir)) {
-        console.log('directory ' + runDir + ' does not exist');
-        process.exit(1);
-    }
-
-    let runExe = path.join(runDir, 'main.js');
-    if(!fs.existsSync(runExe)) {
-        console.log('file ' + runExe + ' does not exist');
-        process.exit(1);
-    }
-
     let program = require('commander');
     program
-        .option('-c, --config <file>', 'config file of the benchmark', setConfig)
-        .option('-n, --network <file>', 'config file of the blockchain system under test', setNetwork)
+        .option('-c, --config <file>', 'config file of the benchmark')
+        .option('-n, --network <file>', 'config file of the blockchain system under test')
         .parse(process.argv);
-    let cmd = 'node main.js';
-    if(typeof configFile === 'string') {
-        cmd += ' -c ';
-        cmd += configFile;
+
+    let logger = Util.getLogger('scripts/test.js');
+    let absConfigFile;
+    if(typeof program.config === 'undefined') {
+      logger.error('config file is required');
+      return;",,2019-03-05 13:00:45,https://api.github.com/repos/hyperledger/caliper/pulls/comments/257505263,https://github.com/hyperledger/caliper/pull/287#discussion_r257505263,gregdhill
https://github.com/hyperledger/caliper/pull/287,https://github.com/hyperledger/caliper/pull/287,"An `.allowUnknownOption()` should be inserted before the `parse` call, so users can override runtime Caliper settings through the command line (this is made possible by `nconf`)",c2ce1f9998786e395e82a59a2fbfa20d01302b3c,2019-02-17 14:23:12,257507078,"@@ -0,0 +1,66 @@
+/**
+* Copyright 2017 HUAWEI. All Rights Reserved.
+*
+* SPDX-License-Identifier: Apache-2.0
+*
+*/
+
+
+'use strict';
+
+var path = require('path');
+var fs = require('fs-extra');
+var exec = require('child_process').exec;
+const Util = require('../src/comm/util');
+
+function main() {
+    let program = require('commander');
+    program
+        .option('-c, --config <file>', 'config file of the benchmark')
+        .option('-n, --network <file>', 'config file of the blockchain system under test')
+        .parse(process.argv);",22,2019-03-05 13:00:45,https://api.github.com/repos/hyperledger/caliper/pulls/comments/257507078,https://github.com/hyperledger/caliper/pull/287#discussion_r257507078,aklenik
https://github.com/hyperledger/caliper/pull/287,https://github.com/hyperledger/caliper/pull/287,Done :),c2ce1f9998786e395e82a59a2fbfa20d01302b3c,2019-02-20 16:15:01,258558369,"@@ -0,0 +1,66 @@
+/**
+* Copyright 2017 HUAWEI. All Rights Reserved.
+*
+* SPDX-License-Identifier: Apache-2.0
+*
+*/
+
+
+'use strict';
+
+var path = require('path');
+var fs = require('fs-extra');
+var exec = require('child_process').exec;
+const Util = require('../src/comm/util');
+
+function main() {
+    let program = require('commander');
+    program
+        .option('-c, --config <file>', 'config file of the benchmark')
+        .option('-n, --network <file>', 'config file of the blockchain system under test')
+        .parse(process.argv);",22,2019-03-05 13:00:45,https://api.github.com/repos/hyperledger/caliper/pulls/comments/258558369,https://github.com/hyperledger/caliper/pull/287#discussion_r258558369,gregdhill
https://github.com/hyperledger/caliper/pull/287,https://github.com/hyperledger/caliper/pull/287,"`e2e` should call the `test.js` script, the Travis build uses it. ",c2ce1f9998786e395e82a59a2fbfa20d01302b3c,2019-03-01 13:27:24,261601402,"@@ -7,10 +7,11 @@
   },
   ""scripts"": {
     ""test"": ""npm run lint && npm run nyc && npm run e2e"",
-    ""nyc"": ""nyc mocha --recursive -t 10000"",
-    ""e2e"": ""node ./scripts/test.js"",
     ""lint"": ""npx eslint ."",
     ""list"": ""node ./scripts/list.js"",
+    ""nyc"": ""nyc mocha --recursive -t 10000"",
+    ""e2e"": ""node ./scripts/main.js"",",9,2019-03-05 13:00:45,https://api.github.com/repos/hyperledger/caliper/pulls/comments/261601402,https://github.com/hyperledger/caliper/pull/287#discussion_r261601402,aklenik
https://github.com/hyperledger/caliper/pull/287,https://github.com/hyperledger/caliper/pull/287,@aklenik I've actually removed `test.js` in favour of `main.js` which comprises similar functionality. ,c2ce1f9998786e395e82a59a2fbfa20d01302b3c,2019-03-04 10:05:36,261991807,"@@ -7,10 +7,11 @@
   },
   ""scripts"": {
     ""test"": ""npm run lint && npm run nyc && npm run e2e"",
-    ""nyc"": ""nyc mocha --recursive -t 10000"",
-    ""e2e"": ""node ./scripts/test.js"",
     ""lint"": ""npx eslint ."",
     ""list"": ""node ./scripts/list.js"",
+    ""nyc"": ""nyc mocha --recursive -t 10000"",
+    ""e2e"": ""node ./scripts/main.js"",",9,2019-03-05 13:00:45,https://api.github.com/repos/hyperledger/caliper/pulls/comments/261991807,https://github.com/hyperledger/caliper/pull/287#discussion_r261991807,gregdhill
https://github.com/hyperledger/caliper/pull/287,https://github.com/hyperledger/caliper/pull/287,"@gregdhill Similar, but not the same :) During the Travis CI, the `.travis/script.sh` script will be called with the `BENCHMARK` env. variable set to different values. This value is passed to `test.js` as the only argument. Because of this, the current call to `main.js` will fail: 
```
> caliper@0.1.0 e2e /home/klenik/projects/prs/start-script
> node ./scripts/main.js ""simple""

error: [scripts/main.js]: config file is required
```

You're right, that `main.js` should be used, it's cleaner and doesn't assume defaults that need to be maintained. But in this case you should also modify `.travis/script.sh` at lines 27, 35 and 39.

Line 27: 
```
npm run test -- -- --config=benchmark/composer/config.yaml --network=network/fabric-v1.2/dev/composer-tls.json
```

Line 34-35:
```
npm run fabric-v1.1-deps
npm run test -- -- --config=benchmark/drm/config.yaml --network=network/fabric-v1.1/dev/fabric-go-tls.json
```

Line 39:
```
npm run test -- -- --config=benchmark/simple/config-linear-rate.yaml --network=network/fabric-v1.1/dev/fabric-node-tls.json
```

__(Note the double `-- --`, since the parameters pass through two run calls.)__

NB: the CI process needs to be improved, that's why I suggested not to bother with `test.js`, but your way works too, and already starts the CI improvements :)",c2ce1f9998786e395e82a59a2fbfa20d01302b3c,2019-03-04 14:52:27,262090463,"@@ -7,10 +7,11 @@
   },
   ""scripts"": {
     ""test"": ""npm run lint && npm run nyc && npm run e2e"",
-    ""nyc"": ""nyc mocha --recursive -t 10000"",
-    ""e2e"": ""node ./scripts/test.js"",
     ""lint"": ""npx eslint ."",
     ""list"": ""node ./scripts/list.js"",
+    ""nyc"": ""nyc mocha --recursive -t 10000"",
+    ""e2e"": ""node ./scripts/main.js"",",9,2019-03-05 13:00:45,https://api.github.com/repos/hyperledger/caliper/pulls/comments/262090463,https://github.com/hyperledger/caliper/pull/287#discussion_r262090463,aklenik
https://github.com/hyperledger/caliper/pull/287,https://github.com/hyperledger/caliper/pull/287,"Ahh ofc, I've made your suggested changes! :)",c2ce1f9998786e395e82a59a2fbfa20d01302b3c,2019-03-05 13:01:22,262486232,"@@ -7,10 +7,11 @@
   },
   ""scripts"": {
     ""test"": ""npm run lint && npm run nyc && npm run e2e"",
-    ""nyc"": ""nyc mocha --recursive -t 10000"",
-    ""e2e"": ""node ./scripts/test.js"",
     ""lint"": ""npx eslint ."",
     ""list"": ""node ./scripts/list.js"",
+    ""nyc"": ""nyc mocha --recursive -t 10000"",
+    ""e2e"": ""node ./scripts/main.js"",",9,2019-03-05 13:01:22,https://api.github.com/repos/hyperledger/caliper/pulls/comments/262486232,https://github.com/hyperledger/caliper/pull/287#discussion_r262486232,gregdhill
https://github.com/hyperledger/caliper/pull/260,https://github.com/hyperledger/caliper/pull/260,"This is fabric v1.0, so packages fabric-ca-client@1.0.0 and fabric-client@1.0.0 should be installed",2cafa92da272ceeadb3cb51dc0e18f38facfab3a,2018-12-17 02:23:48,242011587,"@@ -14,7 +14,9 @@
     ""startclient"": ""node ./src/comm/client/zoo-client.js"",
     ""burrow-deps"": ""npm install --no-save @monax/burrow@0.20.8"",
     ""composer-deps"": ""npm install --no-save composer-admin@0.19.18 composer-client@0.19.18 composer-common@0.19.18 fabric-ca-client@1.2.0 fabric-client@1.2.0"",
-    ""fabric-deps"": ""npm install --no-save grpc@1.10.1 fabric-ca-client@1.1.0 fabric-client@1.1.0"",
+    ""fabric-v1.0-deps"": ""npm install --no-save grpc@1.10.1 fabric-ca-client@1.1.0 fabric-client@1.1.0"",",5,2018-12-17 07:26:35,https://api.github.com/repos/hyperledger/caliper/pulls/comments/242011587,https://github.com/hyperledger/caliper/pull/260#discussion_r242011587,panyu4
https://github.com/hyperledger/caliper/pull/260,https://github.com/hyperledger/caliper/pull/260,"Yes, I wanted to do that originally, but the dependencies of the 1.0 SDK didn't sit well with NodeJs 8.x and crashed on start. But the 1.1 SDK works well with 1.0 binaries. Could you get it working with the 1.0 SDK?",2cafa92da272ceeadb3cb51dc0e18f38facfab3a,2018-12-17 07:31:26,242045588,"@@ -14,7 +14,9 @@
     ""startclient"": ""node ./src/comm/client/zoo-client.js"",
     ""burrow-deps"": ""npm install --no-save @monax/burrow@0.20.8"",
     ""composer-deps"": ""npm install --no-save composer-admin@0.19.18 composer-client@0.19.18 composer-common@0.19.18 fabric-ca-client@1.2.0 fabric-client@1.2.0"",
-    ""fabric-deps"": ""npm install --no-save grpc@1.10.1 fabric-ca-client@1.1.0 fabric-client@1.1.0"",
+    ""fabric-v1.0-deps"": ""npm install --no-save grpc@1.10.1 fabric-ca-client@1.1.0 fabric-client@1.1.0"",",5,2018-12-17 07:31:27,https://api.github.com/repos/hyperledger/caliper/pulls/comments/242045588,https://github.com/hyperledger/caliper/pull/260#discussion_r242045588,aklenik
https://github.com/hyperledger/caliper/pull/260,https://github.com/hyperledger/caliper/pull/260,I also failed. I thought it was grpc's problem. You are right. Now let it be 1.1.0. I'll approve it.,2cafa92da272ceeadb3cb51dc0e18f38facfab3a,2018-12-17 07:39:00,242046848,"@@ -14,7 +14,9 @@
     ""startclient"": ""node ./src/comm/client/zoo-client.js"",
     ""burrow-deps"": ""npm install --no-save @monax/burrow@0.20.8"",
     ""composer-deps"": ""npm install --no-save composer-admin@0.19.18 composer-client@0.19.18 composer-common@0.19.18 fabric-ca-client@1.2.0 fabric-client@1.2.0"",
-    ""fabric-deps"": ""npm install --no-save grpc@1.10.1 fabric-ca-client@1.1.0 fabric-client@1.1.0"",
+    ""fabric-v1.0-deps"": ""npm install --no-save grpc@1.10.1 fabric-ca-client@1.1.0 fabric-client@1.1.0"",",5,2018-12-17 07:39:00,https://api.github.com/repos/hyperledger/caliper/pulls/comments/242046848,https://github.com/hyperledger/caliper/pull/260#discussion_r242046848,panyu4
https://github.com/hyperledger/caliper/pull/258,https://github.com/hyperledger/caliper/pull/258,"Only the `path` property is used in the code. These properties should be Burrow-specific. So whatever information you need to deploy the contract should be present, but the other properties should be removed to avoid confusion.",20c47e48c6ca8e9099f28c1df73bbf699f7c62fb,2018-12-16 20:28:33,241994619,"@@ -14,6 +14,7 @@
       }
     }
   },
+  ""contract"": {""id"": ""simple"", ""path"": ""src/contract/burrow/simple/simple.bin"", ""language"":""solidity"", ""version"": ""v0"", ""channel"": ""mychannel""},",,2018-12-20 17:22:09,https://api.github.com/repos/hyperledger/caliper/pulls/comments/241994619,https://github.com/hyperledger/caliper/pull/258#discussion_r241994619,aklenik
https://github.com/hyperledger/caliper/pull/258,https://github.com/hyperledger/caliper/pull/258,Platform-specific dependencies should be moved to the appropriate `npm run` script. ,20c47e48c6ca8e9099f28c1df73bbf699f7c62fb,2018-12-16 20:29:29,241994659,"@@ -33,6 +33,7 @@
     ""commander"": ""^2.11.0"",
     ""dockerode"": ""^2.5.0"",
     ""fs-extra"": ""^4.0.2"",
+    ""grpc"": ""^1.16.1"",",,2018-12-20 17:22:09,https://api.github.com/repos/hyperledger/caliper/pulls/comments/241994659,https://github.com/hyperledger/caliper/pull/258#discussion_r241994659,aklenik
https://github.com/hyperledger/caliper/pull/258,https://github.com/hyperledger/caliper/pull/258,"My suggestion to avoid Promise chains:
```js
let contractAddress = await contract._constructor('');
logger.infor(`Contract: ${address}`);
```
Continued in the next comment.",20c47e48c6ca8e9099f28c1df73bbf699f7c62fb,2018-12-16 20:33:07,241994786,"@@ -38,12 +39,40 @@ class Burrow extends BlockchainInterface{
     }
 
     /**
-     * Deploy the chaincode specified in the network configuration file to all peers.
-     * @return {Burrow} resolve
+     * Deploy the smart contract specified in the network configuration file.
+     * @return {object} Promise execution for namereg.
      */
-    installSmartContract() {
-        // TODO: complete
-        return Promise.resolve();
+    async installSmartContract() {
+        let config  = require(this.configPath);
+        let grpc = config.burrow.network.validator.grpc;
+        if(grpc === null) {
+            logger.error('Error: Validator url not set.');
+        }
+        let account = fs.readFileSync(util.resolvePath(config.burrow.network.validator.address)).toString();
+        let options = {objectReturn: true};
+        let burrow = monax.createInstance(grpc, account, options);
+        let data = JSON.parse(fs.readFileSync(util.resolvePath(config.contract.path)).toString());
+        let abi = data.Abi;
+        let bytecode = data.Evm.Bytecode.Object;
+
+        const contract = burrow.contracts.new(abi, bytecode);
+        let contractAddress = await Promise.all([contract._constructor('')]).then(([address]) => {",,2018-12-20 17:22:09,https://api.github.com/repos/hyperledger/caliper/pulls/comments/241994786,https://github.com/hyperledger/caliper/pull/258#discussion_r241994786,aklenik
https://github.com/hyperledger/caliper/pull/258,https://github.com/hyperledger/caliper/pull/258,"```js
Data: [contractAddress],
```",20c47e48c6ca8e9099f28c1df73bbf699f7c62fb,2018-12-16 20:33:46,241994814,"@@ -38,12 +39,40 @@ class Burrow extends BlockchainInterface{
     }
 
     /**
-     * Deploy the chaincode specified in the network configuration file to all peers.
-     * @return {Burrow} resolve
+     * Deploy the smart contract specified in the network configuration file.
+     * @return {object} Promise execution for namereg.
      */
-    installSmartContract() {
-        // TODO: complete
-        return Promise.resolve();
+    async installSmartContract() {
+        let config  = require(this.configPath);
+        let grpc = config.burrow.network.validator.grpc;
+        if(grpc === null) {
+            logger.error('Error: Validator url not set.');
+        }
+        let account = fs.readFileSync(util.resolvePath(config.burrow.network.validator.address)).toString();
+        let options = {objectReturn: true};
+        let burrow = monax.createInstance(grpc, account, options);
+        let data = JSON.parse(fs.readFileSync(util.resolvePath(config.contract.path)).toString());
+        let abi = data.Abi;
+        let bytecode = data.Evm.Bytecode.Object;
+
+        const contract = burrow.contracts.new(abi, bytecode);
+        let contractAddress = await Promise.all([contract._constructor('')]).then(([address]) => {
+            logger.info(`Contract: ${address}`);
+            return address;
+        });
+
+        // this stores the contract address in a namereg for easy retreival
+        let setPayload = {
+            Input: {
+                Address: Buffer.from(account,'hex'),
+                Amount: 50000
+            },
+            Name: 'DOUG',
+            Data: contractAddress,",36,2018-12-20 17:22:09,https://api.github.com/repos/hyperledger/caliper/pulls/comments/241994814,https://github.com/hyperledger/caliper/pull/258#discussion_r241994814,aklenik
https://github.com/hyperledger/caliper/pull/258,https://github.com/hyperledger/caliper/pull/258,Is this member field used somewhere?,20c47e48c6ca8e9099f28c1df73bbf699f7c62fb,2018-12-16 20:34:26,241994841,"@@ -27,6 +27,7 @@ class Burrow extends BlockchainInterface{
     constructor(config_path) {
         super(config_path);
         this.statusInterval = null;
+        this.contractAddress = '';",,2018-12-20 17:22:09,https://api.github.com/repos/hyperledger/caliper/pulls/comments/241994841,https://github.com/hyperledger/caliper/pull/258#discussion_r241994841,aklenik
https://github.com/hyperledger/caliper/pull/258,https://github.com/hyperledger/caliper/pull/258,"To replace Promise chains:
```js
let address = (await burrow.query.GetName({Name: 'DOUG'})).Data;
```",20c47e48c6ca8e9099f28c1df73bbf699f7c62fb,2018-12-16 20:35:49,241994917,"@@ -69,7 +99,12 @@ class Burrow extends BlockchainInterface{
 
             let options = {objectReturn: true};
             let burrow = monax.createInstance(grpc, account, options);
-            context = {stream: burrow, account: account};
+
+            // get the contract address from the namereg
+            let address = await burrow.query.GetName({Name: 'DOUG'})",,2018-12-20 17:22:09,https://api.github.com/repos/hyperledger/caliper/pulls/comments/241994917,https://github.com/hyperledger/caliper/pull/258#discussion_r241994917,aklenik
https://github.com/hyperledger/caliper/pull/258,https://github.com/hyperledger/caliper/pull/258,"Nope, left that by mistake :P",20c47e48c6ca8e9099f28c1df73bbf699f7c62fb,2018-12-17 10:28:19,242094159,"@@ -27,6 +27,7 @@ class Burrow extends BlockchainInterface{
     constructor(config_path) {
         super(config_path);
         this.statusInterval = null;
+        this.contractAddress = '';",,2018-12-20 17:22:09,https://api.github.com/repos/hyperledger/caliper/pulls/comments/242094159,https://github.com/hyperledger/caliper/pull/258#discussion_r242094159,gregdhill
https://github.com/hyperledger/caliper/pull/258,https://github.com/hyperledger/caliper/pull/258,"Much more efficient, thanks!",20c47e48c6ca8e9099f28c1df73bbf699f7c62fb,2018-12-17 10:28:42,242094288,"@@ -69,7 +99,12 @@ class Burrow extends BlockchainInterface{
 
             let options = {objectReturn: true};
             let burrow = monax.createInstance(grpc, account, options);
-            context = {stream: burrow, account: account};
+
+            // get the contract address from the namereg
+            let address = await burrow.query.GetName({Name: 'DOUG'})",,2018-12-20 17:22:09,https://api.github.com/repos/hyperledger/caliper/pulls/comments/242094288,https://github.com/hyperledger/caliper/pull/258#discussion_r242094288,gregdhill
https://github.com/hyperledger/caliper/pull/246,https://github.com/hyperledger/caliper/pull/246,"This is a network configuration file, so it can be move into the corresponding folder 'network/burrow/simplenetwork'. And one section named ""caliper"" with two subsections 'blockchain' and 'command' could be added into it.  You can modify it according to the sample file '/network/fabric/2org2peer/fabric-simple.json'.",4478f2a2adea3d97b4ed46fd900c0d480416a830,2018-12-03 06:38:59,238156409,"@@ -0,0 +1,15 @@
+{
+  ""burrow"": {",,2018-12-07 15:06:51,https://api.github.com/repos/hyperledger/caliper/pulls/comments/238156409,https://github.com/hyperledger/caliper/pull/246#discussion_r238156409,panyu4
https://github.com/hyperledger/caliper/pull/246,https://github.com/hyperledger/caliper/pull/246,These sections 'blockchain' and 'command' can be moved into the network configuration files.  Then the rest of it seems to be same with other simple's configuration and maybe the file /benchmark/simple/config.yaml could be reused.,4478f2a2adea3d97b4ed46fd900c0d480416a830,2018-12-03 06:51:13,238158169,"@@ -0,0 +1,32 @@
+{
+  ""blockchain"": {",,2018-12-07 15:06:51,https://api.github.com/repos/hyperledger/caliper/pulls/comments/238158169,https://github.com/hyperledger/caliper/pull/246#discussion_r238158169,panyu4
https://github.com/hyperledger/caliper/pull/246,https://github.com/hyperledger/caliper/pull/246,This comma should be deleted.,4478f2a2adea3d97b4ed46fd900c0d480416a830,2018-12-04 07:46:03,238554561,"@@ -0,0 +1,22 @@
+{
+  ""caliper"" : {
+    ""blockchain"": ""burrow"",
+    ""command"" : {
+      ""start"": ""docker-compose -f network/burrow/simplenetwork/docker-compose.yml up -d"",
+      ""end"" : ""docker-compose -f network/burrow/simplenetwork/docker-compose.yml down""
+    },",,2018-12-07 15:06:51,https://api.github.com/repos/hyperledger/caliper/pulls/comments/238554561,https://github.com/hyperledger/caliper/pull/246#discussion_r238554561,panyu4
https://github.com/hyperledger/caliper/pull/246,https://github.com/hyperledger/caliper/pull/246,"Since there isn't any Burrow-specific setting in this file (that was the goal of moving the platform-specific parts to the network config files), it can be deleted. 
(The `config-iroha.yaml` and `config-sawtooth.yaml` files are also redundant, they'll be deleted later.)",4478f2a2adea3d97b4ed46fd900c0d480416a830,2018-12-06 09:56:45,239389798,"@@ -0,0 +1,28 @@
+---",,2018-12-07 15:06:51,https://api.github.com/repos/hyperledger/caliper/pulls/comments/239389798,https://github.com/hyperledger/caliper/pull/246#discussion_r239389798,aklenik
https://github.com/hyperledger/caliper/pull/246,https://github.com/hyperledger/caliper/pull/246,"It would be better to provide the docs for the functions instead of disabling the jsdoc rule :)
",4478f2a2adea3d97b4ed46fd900c0d480416a830,2018-12-06 10:06:27,239393186,"@@ -0,0 +1,131 @@
+/**
+ * Copyright 2017 HUAWEI. All Rights Reserved.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * @file, definition of the Burrow class, which implements the Caliper's NBI for Hyperledger Burrow.
+ */
+
+'use strict';
+
+const fs = require('fs');
+const monax = require('@monax/burrow');
+const BlockchainInterface = require('../comm/blockchain-interface.js');
+const util = require('../comm/util.js');
+const logger = util.getLogger('burrow.js');
+const TxStatus = require('../comm/transaction');
+
+/* eslint-disable require-jsdoc */",,2018-12-07 15:06:51,https://api.github.com/repos/hyperledger/caliper/pulls/comments/239393186,https://github.com/hyperledger/caliper/pull/246#discussion_r239393186,aklenik
https://github.com/hyperledger/caliper/pull/246,https://github.com/hyperledger/caliper/pull/246,"Since the function is marked as async, you could use await instead of Promise chains. (However, I'm a little confused by the `CallTxSync` name, shouldn't it be sync, so no need for the Promise chain?)",4478f2a2adea3d97b4ed46fd900c0d480416a830,2018-12-06 10:10:18,239394452,"@@ -0,0 +1,131 @@
+/**
+ * Copyright 2017 HUAWEI. All Rights Reserved.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * @file, definition of the Burrow class, which implements the Caliper's NBI for Hyperledger Burrow.
+ */
+
+'use strict';
+
+const fs = require('fs');
+const monax = require('@monax/burrow');
+const BlockchainInterface = require('../comm/blockchain-interface.js');
+const util = require('../comm/util.js');
+const logger = util.getLogger('burrow.js');
+const TxStatus = require('../comm/transaction');
+
+/* eslint-disable require-jsdoc */
+/**
+ * Implements {BlockchainInterface} for a Burrow backend.
+ */
+class Burrow extends BlockchainInterface{
+    constructor(config_path) {
+        super(config_path);
+        this.statusInterval = null;
+    }
+
+    init() {
+        return util.sleep(2000);
+    }
+
+    installSmartContract() {
+        return Promise.resolve();
+    }
+
+    getContext(name, args) {
+        let config  = require(this.configPath);
+        let context = config.burrow.context;
+        if(typeof context === 'undefined') {
+
+            let grpc = config.burrow.network.validator.grpc;
+            if(grpc === null) {
+                logger.error('Error: Validator url not set.');
+            }
+            let account = fs.readFileSync(util.resolvePath(config.burrow.network.validator.address)).toString();
+
+            logger.info(`Account: ${account}`);
+            logger.info(`GRPC: ${grpc}`);
+
+            let options = {objectReturn: true};
+            let burrow = monax.createInstance(grpc, account, options);
+            context = {stream: burrow, account: account};
+        }
+        return Promise.resolve(context);
+    }
+
+    releaseContext(context) {
+        // nothing to do
+        return Promise.resolve();
+    }
+
+    /**
+   * Invoke a smart contract.
+   * @param {Object} context context object
+   * @param {String} contractID identity of the contract
+   * @param {String} contractVer version of the contract
+   * @param {Array} args array of JSON formatted arguments for multiple transactions
+   * @param {Number} timeout request timeout, in seconds
+   * @return {Promise<object>} the promise for the result of the execution.
+   */
+    async invokeSmartContract(context, contractID, contractVer, args, timeout) {
+        let promises = [];
+        args.forEach((item, index)=>{
+            promises.push(this.burrowTransaction(context, contractID, contractVer, item, timeout));
+        });
+        return await Promise.all(promises);
+    }
+
+    /**
+   * Submit a transaction to the burrow daemon with the specified options.
+   * @param {Object} context context object
+   * @param {String} contractID identity of the contract
+   * @param {String} contractVer version of the contract
+   * @param {Array} args array of JSON formatted arguments for multiple transactions
+   * @param {Number} timeout request timeout, in seconds
+   * @return {Promise<TxStatus>} result and stats of the transaction invocation.
+   */
+    async burrowTransaction(context, contractID, contractVer, args, timeout) {
+        try {
+            let status = new TxStatus(args.account);
+            status.Set('timeout', timeout*1000);
+            if(context.engine) {
+                context.engine.submitCallback(1);
+            }
+
+            let tx = {
+                Input: {
+                    Address: Buffer.from(context.account,'hex'),
+                    Amount: args.money
+                },
+                GasLimit: 5000,
+                Fee: 5000
+            };
+
+            let exe = context.stream.transact.CallTxSync(tx).then((execution)=>{",,2018-12-07 15:06:51,https://api.github.com/repos/hyperledger/caliper/pulls/comments/239394452,https://github.com/hyperledger/caliper/pull/246#discussion_r239394452,aklenik
https://github.com/hyperledger/caliper/pull/246,https://github.com/hyperledger/caliper/pull/246,"The Tx submission logic should never throw exceptions (or reject). Any error should be signaled by the `status.SetStatusFail()` call and that status should be returned normally. Otherwise, any Tx error would stop the entire test round, and we don't want that.",4478f2a2adea3d97b4ed46fd900c0d480416a830,2018-12-06 10:13:24,239395455,"@@ -0,0 +1,131 @@
+/**
+ * Copyright 2017 HUAWEI. All Rights Reserved.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * @file, definition of the Burrow class, which implements the Caliper's NBI for Hyperledger Burrow.
+ */
+
+'use strict';
+
+const fs = require('fs');
+const monax = require('@monax/burrow');
+const BlockchainInterface = require('../comm/blockchain-interface.js');
+const util = require('../comm/util.js');
+const logger = util.getLogger('burrow.js');
+const TxStatus = require('../comm/transaction');
+
+/* eslint-disable require-jsdoc */
+/**
+ * Implements {BlockchainInterface} for a Burrow backend.
+ */
+class Burrow extends BlockchainInterface{
+    constructor(config_path) {
+        super(config_path);
+        this.statusInterval = null;
+    }
+
+    init() {
+        return util.sleep(2000);
+    }
+
+    installSmartContract() {
+        return Promise.resolve();
+    }
+
+    getContext(name, args) {
+        let config  = require(this.configPath);
+        let context = config.burrow.context;
+        if(typeof context === 'undefined') {
+
+            let grpc = config.burrow.network.validator.grpc;
+            if(grpc === null) {
+                logger.error('Error: Validator url not set.');
+            }
+            let account = fs.readFileSync(util.resolvePath(config.burrow.network.validator.address)).toString();
+
+            logger.info(`Account: ${account}`);
+            logger.info(`GRPC: ${grpc}`);
+
+            let options = {objectReturn: true};
+            let burrow = monax.createInstance(grpc, account, options);
+            context = {stream: burrow, account: account};
+        }
+        return Promise.resolve(context);
+    }
+
+    releaseContext(context) {
+        // nothing to do
+        return Promise.resolve();
+    }
+
+    /**
+   * Invoke a smart contract.
+   * @param {Object} context context object
+   * @param {String} contractID identity of the contract
+   * @param {String} contractVer version of the contract
+   * @param {Array} args array of JSON formatted arguments for multiple transactions
+   * @param {Number} timeout request timeout, in seconds
+   * @return {Promise<object>} the promise for the result of the execution.
+   */
+    async invokeSmartContract(context, contractID, contractVer, args, timeout) {
+        let promises = [];
+        args.forEach((item, index)=>{
+            promises.push(this.burrowTransaction(context, contractID, contractVer, item, timeout));
+        });
+        return await Promise.all(promises);
+    }
+
+    /**
+   * Submit a transaction to the burrow daemon with the specified options.
+   * @param {Object} context context object
+   * @param {String} contractID identity of the contract
+   * @param {String} contractVer version of the contract
+   * @param {Array} args array of JSON formatted arguments for multiple transactions
+   * @param {Number} timeout request timeout, in seconds
+   * @return {Promise<TxStatus>} result and stats of the transaction invocation.
+   */
+    async burrowTransaction(context, contractID, contractVer, args, timeout) {
+        try {
+            let status = new TxStatus(args.account);
+            status.Set('timeout', timeout*1000);
+            if(context.engine) {
+                context.engine.submitCallback(1);
+            }
+
+            let tx = {
+                Input: {
+                    Address: Buffer.from(context.account,'hex'),
+                    Amount: args.money
+                },
+                GasLimit: 5000,
+                Fee: 5000
+            };
+
+            let exe = context.stream.transact.CallTxSync(tx).then((execution)=>{
+                status.SetID(execution.TxHash.toString());
+                status.SetStatusSuccess();
+                return status;
+            });
+            return exe;
+        }
+        catch(err) {
+            logger.error(err);
+            return Promise.reject();",,2018-12-07 15:06:51,https://api.github.com/repos/hyperledger/caliper/pulls/comments/239395455,https://github.com/hyperledger/caliper/pull/246#discussion_r239395455,aklenik
https://github.com/hyperledger/caliper/pull/246,https://github.com/hyperledger/caliper/pull/246,"From the [docs](https://github.com/monax/bosmarmot/tree/develop/burrow.js): ""A note on RPC naming, any method which ends in Sync will wait until the transaction generated is included in a block."" ... "" If no callback is provided, a promise will be returned instead.""",4478f2a2adea3d97b4ed46fd900c0d480416a830,2018-12-07 13:49:21,239813086,"@@ -0,0 +1,131 @@
+/**
+ * Copyright 2017 HUAWEI. All Rights Reserved.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * @file, definition of the Burrow class, which implements the Caliper's NBI for Hyperledger Burrow.
+ */
+
+'use strict';
+
+const fs = require('fs');
+const monax = require('@monax/burrow');
+const BlockchainInterface = require('../comm/blockchain-interface.js');
+const util = require('../comm/util.js');
+const logger = util.getLogger('burrow.js');
+const TxStatus = require('../comm/transaction');
+
+/* eslint-disable require-jsdoc */
+/**
+ * Implements {BlockchainInterface} for a Burrow backend.
+ */
+class Burrow extends BlockchainInterface{
+    constructor(config_path) {
+        super(config_path);
+        this.statusInterval = null;
+    }
+
+    init() {
+        return util.sleep(2000);
+    }
+
+    installSmartContract() {
+        return Promise.resolve();
+    }
+
+    getContext(name, args) {
+        let config  = require(this.configPath);
+        let context = config.burrow.context;
+        if(typeof context === 'undefined') {
+
+            let grpc = config.burrow.network.validator.grpc;
+            if(grpc === null) {
+                logger.error('Error: Validator url not set.');
+            }
+            let account = fs.readFileSync(util.resolvePath(config.burrow.network.validator.address)).toString();
+
+            logger.info(`Account: ${account}`);
+            logger.info(`GRPC: ${grpc}`);
+
+            let options = {objectReturn: true};
+            let burrow = monax.createInstance(grpc, account, options);
+            context = {stream: burrow, account: account};
+        }
+        return Promise.resolve(context);
+    }
+
+    releaseContext(context) {
+        // nothing to do
+        return Promise.resolve();
+    }
+
+    /**
+   * Invoke a smart contract.
+   * @param {Object} context context object
+   * @param {String} contractID identity of the contract
+   * @param {String} contractVer version of the contract
+   * @param {Array} args array of JSON formatted arguments for multiple transactions
+   * @param {Number} timeout request timeout, in seconds
+   * @return {Promise<object>} the promise for the result of the execution.
+   */
+    async invokeSmartContract(context, contractID, contractVer, args, timeout) {
+        let promises = [];
+        args.forEach((item, index)=>{
+            promises.push(this.burrowTransaction(context, contractID, contractVer, item, timeout));
+        });
+        return await Promise.all(promises);
+    }
+
+    /**
+   * Submit a transaction to the burrow daemon with the specified options.
+   * @param {Object} context context object
+   * @param {String} contractID identity of the contract
+   * @param {String} contractVer version of the contract
+   * @param {Array} args array of JSON formatted arguments for multiple transactions
+   * @param {Number} timeout request timeout, in seconds
+   * @return {Promise<TxStatus>} result and stats of the transaction invocation.
+   */
+    async burrowTransaction(context, contractID, contractVer, args, timeout) {
+        try {
+            let status = new TxStatus(args.account);
+            status.Set('timeout', timeout*1000);
+            if(context.engine) {
+                context.engine.submitCallback(1);
+            }
+
+            let tx = {
+                Input: {
+                    Address: Buffer.from(context.account,'hex'),
+                    Amount: args.money
+                },
+                GasLimit: 5000,
+                Fee: 5000
+            };
+
+            let exe = context.stream.transact.CallTxSync(tx).then((execution)=>{",,2018-12-07 15:06:51,https://api.github.com/repos/hyperledger/caliper/pulls/comments/239813086,https://github.com/hyperledger/caliper/pull/246#discussion_r239813086,gregdhill
https://github.com/hyperledger/caliper/pull/246,https://github.com/hyperledger/caliper/pull/246,"You should add a `.catch(err => {...})` to the chain in case an error occurs, so you can set the status to failed and ""hide"" the error from the engine. Or the following would be even better:

```js
try {
  let execution = await context.stream.transact.CallTxSync(tx);
  status.SetID(execution.TxHash.toString());
  status.SetStatusSuccess();
} catch (err) {
  // log error
  status.SetStatusFail();
}

return status;
```",4478f2a2adea3d97b4ed46fd900c0d480416a830,2018-12-07 14:49:43,239831947,"@@ -0,0 +1,157 @@
+/**
+ * Copyright 2017 HUAWEI. All Rights Reserved.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * @file, definition of the Burrow class, which implements the Caliper's NBI for Hyperledger Burrow.
+ */
+
+'use strict';
+
+const fs = require('fs');
+const monax = require('@monax/burrow');
+const BlockchainInterface = require('../comm/blockchain-interface.js');
+const util = require('../comm/util.js');
+const logger = util.getLogger('burrow.js');
+const TxStatus = require('../comm/transaction');
+
+/**
+ * Implements {BlockchainInterface} for a Burrow backend.
+ */
+class Burrow extends BlockchainInterface{
+
+    /**
+   * Create a new instance of the {Burrow} class.
+   * @param {string} config_path The path of the Fabric network configuration file.
+   */
+    constructor(config_path) {
+        super(config_path);
+        this.statusInterval = null;
+    }
+
+    /**
+     * Initialize the {Burrow} object.
+     * @return {time} sleep
+     */
+    init() {
+        return util.sleep(2000);
+    }
+
+    /**
+     * Deploy the chaincode specified in the network configuration file to all peers.
+     * @return {Burrow} resolve
+     */
+    installSmartContract() {
+        // TODO: complete
+        return Promise.resolve();
+    }
+
+    /**
+     * Return the Burrow context associated with the given callback module name.
+     * @param {string} name The name of the callback module as defined in the configuration files.
+     * @param {object} args Unused.
+     * @return {object} The assembled Fabric context.
+     * @async
+     */
+    getContext(name, args) {
+        let config  = require(this.configPath);
+        let context = config.burrow.context;
+        if(typeof context === 'undefined') {
+
+            let grpc = config.burrow.network.validator.grpc;
+            if(grpc === null) {
+                logger.error('Error: Validator url not set.');
+            }
+            let account = fs.readFileSync(util.resolvePath(config.burrow.network.validator.address)).toString();
+
+            logger.info(`Account: ${account}`);
+            logger.info(`GRPC: ${grpc}`);
+
+            let options = {objectReturn: true};
+            let burrow = monax.createInstance(grpc, account, options);
+            context = {stream: burrow, account: account};
+        }
+        return Promise.resolve(context);
+    }
+
+    /**
+     * Release the given Burrow context.
+     * @param {object} context The Burrow context to release.
+     * @async
+     */
+    async releaseContext(context) {
+        // nothing to do
+    }
+
+    /**
+   * Invoke a smart contract.
+   * @param {Object} context context object
+   * @param {String} contractID identity of the contract
+   * @param {String} contractVer version of the contract
+   * @param {Array} args array of JSON formatted arguments for multiple transactions
+   * @param {Number} timeout request timeout, in seconds
+   * @return {Promise<object>} the promise for the result of the execution.
+   */
+    async invokeSmartContract(context, contractID, contractVer, args, timeout) {
+        let promises = [];
+        args.forEach((item, index)=>{
+            promises.push(this.burrowTransaction(context, contractID, contractVer, item, timeout));
+        });
+        return await Promise.all(promises);
+    }
+
+    /**
+   * Submit a transaction to the burrow daemon with the specified options.
+   * @param {Object} context context object
+   * @param {String} contractID identity of the contract
+   * @param {String} contractVer version of the contract
+   * @param {Array} args array of JSON formatted arguments for multiple transactions
+   * @param {Number} timeout request timeout, in seconds
+   * @return {Promise<TxStatus>} result and stats of the transaction invocation.
+   */
+    async burrowTransaction(context, contractID, contractVer, args, timeout) {
+        let status = new TxStatus(args.account);
+        status.Set('timeout', timeout*1000);
+        if(context.engine) {
+            context.engine.submitCallback(1);
+        }
+
+        let tx = {
+            Input: {
+                Address: Buffer.from(context.account,'hex'),
+                Amount: args.money
+            },
+            GasLimit: 5000,
+            Fee: 5000
+        };
+
+        return context.stream.transact.CallTxSync(tx).then((execution)=>{
+            status.SetID(execution.TxHash.toString());
+            status.SetStatusSuccess();
+            return status;
+        });",,2018-12-07 15:06:51,https://api.github.com/repos/hyperledger/caliper/pulls/comments/239831947,https://github.com/hyperledger/caliper/pull/246#discussion_r239831947,aklenik
https://github.com/hyperledger/caliper/pull/246,https://github.com/hyperledger/caliper/pull/246,"`status.Set()` just ""logs"" a key-value you pass. If the Burrow API doesn't support timeout (or supports it in another way), you can ignore this parameter. Or you could wrap your `CallTxSync()` call in a Promise and set a timeout inside that. ",4478f2a2adea3d97b4ed46fd900c0d480416a830,2018-12-07 14:52:23,239832898,"@@ -0,0 +1,157 @@
+/**
+ * Copyright 2017 HUAWEI. All Rights Reserved.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * @file, definition of the Burrow class, which implements the Caliper's NBI for Hyperledger Burrow.
+ */
+
+'use strict';
+
+const fs = require('fs');
+const monax = require('@monax/burrow');
+const BlockchainInterface = require('../comm/blockchain-interface.js');
+const util = require('../comm/util.js');
+const logger = util.getLogger('burrow.js');
+const TxStatus = require('../comm/transaction');
+
+/**
+ * Implements {BlockchainInterface} for a Burrow backend.
+ */
+class Burrow extends BlockchainInterface{
+
+    /**
+   * Create a new instance of the {Burrow} class.
+   * @param {string} config_path The path of the Fabric network configuration file.
+   */
+    constructor(config_path) {
+        super(config_path);
+        this.statusInterval = null;
+    }
+
+    /**
+     * Initialize the {Burrow} object.
+     * @return {time} sleep
+     */
+    init() {
+        return util.sleep(2000);
+    }
+
+    /**
+     * Deploy the chaincode specified in the network configuration file to all peers.
+     * @return {Burrow} resolve
+     */
+    installSmartContract() {
+        // TODO: complete
+        return Promise.resolve();
+    }
+
+    /**
+     * Return the Burrow context associated with the given callback module name.
+     * @param {string} name The name of the callback module as defined in the configuration files.
+     * @param {object} args Unused.
+     * @return {object} The assembled Fabric context.
+     * @async
+     */
+    getContext(name, args) {
+        let config  = require(this.configPath);
+        let context = config.burrow.context;
+        if(typeof context === 'undefined') {
+
+            let grpc = config.burrow.network.validator.grpc;
+            if(grpc === null) {
+                logger.error('Error: Validator url not set.');
+            }
+            let account = fs.readFileSync(util.resolvePath(config.burrow.network.validator.address)).toString();
+
+            logger.info(`Account: ${account}`);
+            logger.info(`GRPC: ${grpc}`);
+
+            let options = {objectReturn: true};
+            let burrow = monax.createInstance(grpc, account, options);
+            context = {stream: burrow, account: account};
+        }
+        return Promise.resolve(context);
+    }
+
+    /**
+     * Release the given Burrow context.
+     * @param {object} context The Burrow context to release.
+     * @async
+     */
+    async releaseContext(context) {
+        // nothing to do
+    }
+
+    /**
+   * Invoke a smart contract.
+   * @param {Object} context context object
+   * @param {String} contractID identity of the contract
+   * @param {String} contractVer version of the contract
+   * @param {Array} args array of JSON formatted arguments for multiple transactions
+   * @param {Number} timeout request timeout, in seconds
+   * @return {Promise<object>} the promise for the result of the execution.
+   */
+    async invokeSmartContract(context, contractID, contractVer, args, timeout) {
+        let promises = [];
+        args.forEach((item, index)=>{
+            promises.push(this.burrowTransaction(context, contractID, contractVer, item, timeout));
+        });
+        return await Promise.all(promises);
+    }
+
+    /**
+   * Submit a transaction to the burrow daemon with the specified options.
+   * @param {Object} context context object
+   * @param {String} contractID identity of the contract
+   * @param {String} contractVer version of the contract
+   * @param {Array} args array of JSON formatted arguments for multiple transactions
+   * @param {Number} timeout request timeout, in seconds
+   * @return {Promise<TxStatus>} result and stats of the transaction invocation.
+   */
+    async burrowTransaction(context, contractID, contractVer, args, timeout) {
+        let status = new TxStatus(args.account);
+        status.Set('timeout', timeout*1000);",,2018-12-07 15:06:51,https://api.github.com/repos/hyperledger/caliper/pulls/comments/239832898,https://github.com/hyperledger/caliper/pull/246#discussion_r239832898,aklenik
https://github.com/hyperledger/caliper/pull/246,https://github.com/hyperledger/caliper/pull/246,Fabric --> Burrow :),4478f2a2adea3d97b4ed46fd900c0d480416a830,2018-12-07 14:53:39,239833355,"@@ -0,0 +1,157 @@
+/**
+ * Copyright 2017 HUAWEI. All Rights Reserved.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * @file, definition of the Burrow class, which implements the Caliper's NBI for Hyperledger Burrow.
+ */
+
+'use strict';
+
+const fs = require('fs');
+const monax = require('@monax/burrow');
+const BlockchainInterface = require('../comm/blockchain-interface.js');
+const util = require('../comm/util.js');
+const logger = util.getLogger('burrow.js');
+const TxStatus = require('../comm/transaction');
+
+/**
+ * Implements {BlockchainInterface} for a Burrow backend.
+ */
+class Burrow extends BlockchainInterface{
+
+    /**
+   * Create a new instance of the {Burrow} class.
+   * @param {string} config_path The path of the Fabric network configuration file.
+   */
+    constructor(config_path) {
+        super(config_path);
+        this.statusInterval = null;
+    }
+
+    /**
+     * Initialize the {Burrow} object.
+     * @return {time} sleep
+     */
+    init() {
+        return util.sleep(2000);
+    }
+
+    /**
+     * Deploy the chaincode specified in the network configuration file to all peers.
+     * @return {Burrow} resolve
+     */
+    installSmartContract() {
+        // TODO: complete
+        return Promise.resolve();
+    }
+
+    /**
+     * Return the Burrow context associated with the given callback module name.
+     * @param {string} name The name of the callback module as defined in the configuration files.
+     * @param {object} args Unused.
+     * @return {object} The assembled Fabric context.",,2018-12-07 15:06:51,https://api.github.com/repos/hyperledger/caliper/pulls/comments/239833355,https://github.com/hyperledger/caliper/pull/246#discussion_r239833355,aklenik
https://github.com/hyperledger/caliper/pull/239,https://github.com/hyperledger/caliper/pull/239,"`js-yaml` should be added to the dependencies, since it's a Caliper-level dep.

The platform-specific dependencies should not be saved to `package.json`:
* `composer-*`
* `fabric-*`
* `grpc`
* `protocol-buffers`
* `sawtooth-sdk`",8dd3e43947a5cfdca3cb6b8ee9d8a7b1e81b5f09,2018-11-28 11:43:20,237048420,"@@ -31,8 +30,14 @@
   ""dependencies"": {
     ""cbor"": ""^3.0.3"",
     ""commander"": ""^2.11.0"",
+    ""composer-admin"": ""^0.19.0"",",,2018-11-29 12:30:56,https://api.github.com/repos/hyperledger/caliper/pulls/comments/237048420,https://github.com/hyperledger/caliper/pull/239#discussion_r237048420,aklenik
https://github.com/hyperledger/caliper/pull/239,https://github.com/hyperledger/caliper/pull/239,"ok, i will do it. ",8dd3e43947a5cfdca3cb6b8ee9d8a7b1e81b5f09,2018-11-29 06:32:17,237366814,"@@ -31,8 +30,14 @@
   ""dependencies"": {
     ""cbor"": ""^3.0.3"",
     ""commander"": ""^2.11.0"",
+    ""composer-admin"": ""^0.19.0"",",,2018-11-29 12:30:56,https://api.github.com/repos/hyperledger/caliper/pulls/comments/237366814,https://github.com/hyperledger/caliper/pull/239#discussion_r237366814,houqinghui
https://github.com/hyperledger/caliper/pull/237,https://github.com/hyperledger/caliper/pull/237,This logs the CPU and memory stats for every progress update (maybe a leftover debug log?),e00ad89a4c0374ad8ebb9e825790ff4f1c5215d2,2018-11-28 11:19:27,237041380,"@@ -105,6 +105,7 @@ function getUsage(pids, type) {
         });
 
         Promise.all(promises).then((stats) => {
+            console.log(stats);",,2018-11-28 14:50:44,https://api.github.com/repos/hyperledger/caliper/pulls/comments/237041380,https://github.com/hyperledger/caliper/pull/237#discussion_r237041380,aklenik
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,"kafka-node is not a necessary package for caliper users, I think it should be removed.  ",f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2018-11-28 02:14:11,236919311,"@@ -34,6 +33,7 @@
     ""dockerode"": ""^2.5.0"",
     ""fs-extra"": ""^4.0.2"",
     ""jsrsasign"": ""^8.0.4"",
+    ""kafka-node"": ""^2.3.0"",",,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/236919311,https://github.com/hyperledger/caliper/pull/236#discussion_r236919311,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,"When occurring an error, it should execute the  end command. So this line and next line should check the end property",f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2018-11-29 02:42:31,237336629,"@@ -96,8 +98,38 @@ class Client{
     /**
     * Initialise client object
     * @return {Promise} promise object
+    * @param {JSON} demo object which trakcs real time metrics
+    * @param {String} config path of the configuration file
+    * @param {String} absCaliperDir caliper directory
+    * @param {JSON} listener_child child process
+    * @param {String} networkFile network file path
+    * @param {JSON} t test object
     */
-    async init() {
+    async init(demo, config, absCaliperDir, listener_child, networkFile) {
+        absConfigFile = require(util.resolvePath(networkFile));
+        if (this.config.hasOwnProperty('WITH_MQ') && this.config.WITH_MQ) {
+            clientUtil._consumeEvents(function(err){
+                logger.error(err);
+                listener_child.send({type:'closeKafkaProducer', config: absConfigFile});
+                clientUtil.stop();
+                clientUtil.closeKafkaConsumer();
+                demo.stopWatch();
+                if (absConfigFile.hasOwnProperty('caliper') && absConfigFile.caliper.hasOwnProperty('command') && absConfigFile.caliper.command.hasOwnProperty('start')) {",36,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/237336629,https://github.com/hyperledger/caliper/pull/236#discussion_r237336629,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,"As the early comment like [https://github.com/hyperledger/caliper/pull/124#issuecomment-408162450], this property WITH_MQ can be moved into the config/default.yaml file under the ""core"" section. Then you can get the property by the config framework like this: 
`const cfUtil = require('src/comm/config-util.js'); const cfUtil.getConfigSetting('core:with-mq',false);`",f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2018-11-30 06:14:57,237756252,"@@ -0,0 +1,38 @@
+{
+  ""test"": {
+    ""name"": ""simple"",
+    ""description"" : ""This is an example benchmark for caliper, to test the backend DLT's performance with simple account opening & querying transactions"",
+    ""clients"": {
+      ""type"": ""local"",
+	  ""WITH_MQ"": true,",,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/237756252,https://github.com/hyperledger/caliper/pull/236#discussion_r237756252,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,"Since this property is in default.yaml, it can be got through the config framework. ",f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2018-11-30 06:19:34,237756844,"@@ -298,6 +302,7 @@ module.exports.run = async function(configFile, networkFile) {
 
     let configObject = require(absConfigFile);
     let networkObject = require(absNetworkFile);
+    configurationType = configObject.test.clients.WITH_MQ;",,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/237756844,https://github.com/hyperledger/caliper/pull/236#discussion_r237756844,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,"These parameters here added in client.init function are used for program exit.  Now the bench-flow.js file is able to handle the exit ,  so it is necessary for client.init function to throw an error when the clients encounter errors and then  these parameters could be deleted.",f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2018-11-30 06:26:44,237757766,"@@ -308,9 +313,17 @@ module.exports.run = async function(configFile, networkFile) {
             await execAsync(networkObject.caliper.command.start);
         }
 
+        if (configurationType) {
+            let blockListenerPath = path.join(__dirname, absCaliperPath, 'listener/block-listener-handler.js');
+            listener_child = childProcess.fork(blockListenerPath);
+            listener_child.on('error', function () {
+                logger.error('client encountered unexpected error');
+            });
+            listener_child.send({ type:'test', config: absNetworkFile });
+        }
         await blockchain.init();
         await blockchain.installSmartContract();
-        let numberOfClients = await client.init();
+        let numberOfClients = await client.init(demo, configFile, absCaliperDir, listener_child, networkFile);",44,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/237757766,https://github.com/hyperledger/caliper/pull/236#discussion_r237757766,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,"Since  this parameter ""withMQ"" is able to got from the config framework, it could be deleted.",f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2018-11-30 06:41:26,237759923,"@@ -501,9 +501,10 @@ module.exports.releasecontext = releasecontext;
  * @param {string} version The version of the chaincode.
  * @param {string[]} args The arguments to pass to the chaincode.
  * @param {number} timeout The timeout for the transaction invocation.
+ * @param {number} withMQ Flag to determine if tool running in MQ mode.
  * @return {Promise<TxStatus>} The result and stats of the transaction invocation.
  */
-async function invokebycontext(context, id, version, args, timeout){
+async function invokebycontext(context, id, version, args, timeout, withMQ){",,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/237759923,https://github.com/hyperledger/caliper/pull/236#discussion_r237759923,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,The code from line 612 to line 616 has already executed. These code are redundant,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2018-11-30 06:52:34,237761726,"@@ -603,44 +607,52 @@ async function invokebycontext(context, id, version, args, timeout){
         }
 
         const eventPromises = [];
-        eventHubs.forEach((eh) => {
-            eventPromises.push(new Promise((resolve, reject) => {
-                let handle = setTimeout(() => reject(new Error('Timeout')), newTimeout);
-
-                eh.registerTxEvent(txId,
-                    (tx, code) => {
-                        clearTimeout(handle);
-                        eh.unregisterTxEvent(txId);
-
-                        // either explicit invalid event or valid event, verified in both cases by at least one peer
-                        invokeStatus.SetVerification(true);
-                        if (code !== 'VALID') {
-                            let err = new Error('Invalid transaction: ' + code);
-                            errFlag |= TxErrorEnum.BadEventNotificationError;
+        if (! withMQ) {
+
+            let newTimeout = timeout * 1000 - (Date.now() - startTime);",39,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/237761726,https://github.com/hyperledger/caliper/pull/236#discussion_r237761726,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,The parameter withMQ can be got through the config framework. It can be deleted here.,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2018-11-30 06:55:33,237762160,"@@ -77,8 +77,9 @@ class BlockchainInterface {
      * @param {String} contractVer version of the contract
      * @param {Array} args array of JSON formatted arguments for multiple transactions
      * @param {Number} timeout request timeout, in second
+     * @param {Boolean} withMQ flag to determine if running in MQ mode
      */
-    async invokeSmartContract(context, contractID, contractVer, args, timeout) {
+    async invokeSmartContract(context, contractID, contractVer, args, timeout, withMQ) {",,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/237762160,https://github.com/hyperledger/caliper/pull/236#discussion_r237762160,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,The parameter withMQ can be got through the config framework. It can be deleted here.,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2018-11-30 06:55:56,237762206,"@@ -131,7 +133,7 @@ class Blockchain {
             time = timeout;
         }
 
-        return await this.bcObj.invokeSmartContract(context, contractID, contractVer, arg, time);
+        return await this.bcObj.invokeSmartContract(context, contractID, contractVer, arg, time, this.withMQ);",,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/237762206,https://github.com/hyperledger/caliper/pull/236#discussion_r237762206,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,The parameter withMQ can be got through the config framework. It can be deleted here.,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2018-11-30 06:56:56,237762351,"@@ -14,9 +14,11 @@ class Blockchain {
     /**
      * Constructor
      * @param {String} configPath path of the blockchain configuration file
+     * @param {String} withMQ, Flag to check if caliper running in MQ mode
      */
-    constructor(configPath) {
+    constructor(configPath, withMQ) {",,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/237762351,https://github.com/hyperledger/caliper/pull/236#discussion_r237762351,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,The parameter withMQ can be got through the config framework. It can be deleted here.,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2018-11-30 06:57:37,237762476,"@@ -111,6 +281,13 @@ async function startTest(number, message, clientArgs, updates, results) {
         }
     }
 
+    if (withMQ) {",222,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/237762476,https://github.com/hyperledger/caliper/pull/236#discussion_r237762476,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,"To handle the exit, we have to pass the params to the init function since the error cannot be return back to the bench-flow.js. Consume events function is asynchronous and to return from asynchronous call a callback function is used.",f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2018-12-23 15:50:33,243768170,"@@ -308,9 +313,17 @@ module.exports.run = async function(configFile, networkFile) {
             await execAsync(networkObject.caliper.command.start);
         }
 
+        if (configurationType) {
+            let blockListenerPath = path.join(__dirname, absCaliperPath, 'listener/block-listener-handler.js');
+            listener_child = childProcess.fork(blockListenerPath);
+            listener_child.on('error', function () {
+                logger.error('client encountered unexpected error');
+            });
+            listener_child.send({ type:'test', config: absNetworkFile });
+        }
         await blockchain.init();
         await blockchain.installSmartContract();
-        let numberOfClients = await client.init();
+        let numberOfClients = await client.init(demo, configFile, absCaliperDir, listener_child, networkFile);",44,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/243768170,https://github.com/hyperledger/caliper/pull/236#discussion_r243768170,nitesh7sid
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,These packages like fabric and kafka should not be added here. They are optional.  ,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2019-01-03 01:44:55,244900036,"@@ -34,9 +34,13 @@
     ""cbor"": ""^3.0.3"",
     ""commander"": ""^2.11.0"",
     ""dockerode"": ""^2.5.0"",
+    ""fabric-ca-client"": ""^1.1.0"",",,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/244900036,https://github.com/hyperledger/caliper/pull/236#discussion_r244900036,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,This parameter is not used in the function,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2019-01-03 07:21:26,244923584,"@@ -78,6 +78,7 @@ class BlockchainInterface {
      * @param {String} contractVer version of the contract
      * @param {Array} args array of JSON formatted arguments for multiple transactions
      * @param {Number} timeout request timeout, in second
+     * @param {Boolean} withMQ flag to determine if running in MQ mode",,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/244923584,https://github.com/hyperledger/caliper/pull/236#discussion_r244923584,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,This parameter is not used in the constructor function,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2019-01-03 07:22:24,244923686,"@@ -14,10 +14,10 @@ class Blockchain {
     /**
      * Constructor
      * @param {String} configPath path of the blockchain configuration file
+     * @param {String} withMQ, Flag to check if caliper running in MQ mode",,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/244923686,https://github.com/hyperledger/caliper/pull/236#discussion_r244923686,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,This parameter is not used here. It can be deleted,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2019-01-03 07:24:27,244923926,"@@ -88,17 +175,101 @@ function launchClient(updates, results) {
     });
 }
 
+/**
+ *
+ * @param {Array} updates array to process txUpdates
+ */
+function verifyUnconfirmedTransactions(updates) {
+    for (let i = 0; i < updates.length; i++) {
+        let submitted_transactions = updates[i].committed;
+        for (let j =0; j < submitted_transactions.length; j++) {
+            let transactionStatus = submitted_transactions[j].status;
+            let TransactionStatus = new TxStatus(transactionStatus.id, transactionStatus.status, transactionStatus.time_create, transactionStatus.time_final,
+                transactionStatus.result, transactionStatus.verified, transactionStatus.flags, transactionStatus.error_messages);
+            if (cachedEvents.get(TransactionStatus.GetID()) === undefined) {
+                if (TransactionStatus.GetFlag() === 0) {
+                    cachedEvents.set(TransactionStatus.GetID(), TransactionStatus);
+                } else {
+                    confirmedTransactions.push(TransactionStatus);
+                    totalTransactionsCommitted++;
+                }
+            }
+            else  {
+                TransactionStatus.Set('time_final', cachedEvents.get(TransactionStatus.GetID()));
+                TransactionStatus.SetVerification(true);
+                TransactionStatus.Set('status', 'success');
+                cachedEvents.set(TransactionStatus.GetID(), TransactionStatus);
+                confirmedTransactions.push(TransactionStatus);
+                totalTransactionsCommitted++;
+            }
+        }
+    }
+    let newResults = [];
+    let len  = confirmedTransactions.length;
+    if(len > confirmTail) {
+        newResults = confirmedTransactions.slice(confirmTail, len);
+        confirmTail = len;
+    }
+    let newStats = blockchain.getDefaultTxStats(newResults, false);
+    let dataToUpdate = {submitted: 0, committed: newStats};
+    pushUpdate(global_pid, dataToUpdate);
+}
+
+/**
+ * Update
+ *
+ */
+function update() {
+    let data = [];
+    let len  = unConfirmedTransactions.length;
+    if(len > updateTail) {
+        data = unConfirmedTransactions.slice(updateTail, len);
+        updateTail = len;
+    }
+    verifyUnconfirmedTransactions(data);
+}
+
+/**
+ * updateResults
+ * @param {*} withMQ flag to determine if running MQ mode
+ * @return {Promise} promise object
+ */
+function updateResults(withMQ) {
+    if (withMQ && unConfirmedTransactions.length !== 0) {
+        return new Promise(function(resolve, reject) {
+            (function wait(){
+                if (totalTransactionsCommitted === totalTransactionsForMQ && testfinished === true) {
+                    let finalStats = blockchain.getDefaultTxStats(confirmedTransactions, false);
+                    pushResult(global_pid, finalStats);
+                    clearInterval(txUpdateInter);
+                    return resolve();
+                }
+                setTimeout(wait, 5000);
+            })();
+        });
+    }
+    else {
+        return new Promise(function(resolve, reject){
+            resolve();
+        });
+    }
+}
+
 /**
  * Start a test
  * @param {Number} number test clients' count
  * @param {JSON} message start message
  * @param {Array} clientArgs each element contains specific arguments for a client
  * @param {Array} updates array to save txUpdate results
  * @param {Array} results array to save the test results
+ * @param {*} withMQ flag to determine if running MQ mode",,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/244923926,https://github.com/hyperledger/caliper/pull/236#discussion_r244923926,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,"In blockchain's constructor function, there is only one parameter.",f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2019-01-03 07:28:32,244924401,"@@ -187,7 +206,7 @@ async function runDuration(msg, cb, context) {
 async function doTest(msg) {
     logger.debug('doTest() with:', msg);
     let cb = require(Util.resolvePath(msg.cb));
-    blockchain = new bc(Util.resolvePath(msg.config));
+    blockchain = new bc(Util.resolvePath(msg.config), msg.withMQ);",,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/244924401,https://github.com/hyperledger/caliper/pull/236#discussion_r244924401,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,It is not used in the function.,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2019-01-03 07:30:32,244924666,"@@ -108,6 +108,7 @@ class Fabric extends BlockchainInterface{
      * @param {string} contractVer The version of the chaincode.
      * @param {Array} args Array of JSON formatted arguments for transaction(s). Each element contains arguments (including the function name) passing to the chaincode. JSON attribute named transaction_type is used by default to specify the function name. If the attribute does not exist, the first attribute will be used as the function name.
      * @param {number} timeout The timeout to set for the execution in seconds.
+     * @param {number} withMQ Flag to determine if tool running in MQ mode.",,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/244924666,https://github.com/hyperledger/caliper/pull/236#discussion_r244924666,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,"Add a section name for logger, like `const logger = Util.getLogger('block-listener-adapter.js')`.",f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2019-01-03 07:32:10,244924831,"@@ -0,0 +1,70 @@
+/**
+* Copyright Persistent Systems 2018. All Rights Reserved.
+*
+* SPDX-License-Identifier: Apache-2.0
+*@file Implementation for block listener adapter.
+*/
+
+'use strict';
+const kafka = require('kafka-node');
+const Util = require('../comm/util');
+const logger = Util.getLogger();",,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/244924831,https://github.com/hyperledger/caliper/pull/236#discussion_r244924831,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,The line 15 should be `const logger = Util.getLogger('listener-fabric.js')`,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2019-01-03 07:33:43,244924989,"@@ -0,0 +1,110 @@
+/**
+* Copyright Persistent Systems 2018. All Rights Reserved.
+*
+* SPDX-License-Identifier: Apache-2.0
+@file Implementation for Fabric Event listener to connect to the peer Event Hub and recieve blocks.
+*/
+
+'use strict';
+
+const Client = require('fabric-client');
+const fs = require('fs');
+const path = require('path');
+let testUtil = require('../fabric/util.js');
+const Util = require('../comm/util');
+const logger = Util.getLogger();",,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/244924989,https://github.com/hyperledger/caliper/pull/236#discussion_r244924989,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,'grpcs' should be 'grpc'?,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2019-01-03 07:57:58,244927950,"@@ -0,0 +1,10 @@
+{
+    ""broker_urls"": ""10.80.66.151:9092,10.80.66.151:7092,10.80.66.151:8092"",
+     ""zk_url"": ""10.80.66.151:2181"",
+     ""topic"": ""client-b"",
+     ""peerOrg"":""org1"",
+     ""peerEventUrl"":""grpcs://localhost:7053"",",6,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/244927950,https://github.com/hyperledger/caliper/pull/236#discussion_r244927950,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,I ran the experiment against tls enabled network. Hence grpcs.,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2019-01-03 08:32:54,244933129,"@@ -0,0 +1,10 @@
+{
+    ""broker_urls"": ""10.80.66.151:9092,10.80.66.151:7092,10.80.66.151:8092"",
+     ""zk_url"": ""10.80.66.151:2181"",
+     ""topic"": ""client-b"",
+     ""peerOrg"":""org1"",
+     ""peerEventUrl"":""grpcs://localhost:7053"",",6,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/244933129,https://github.com/hyperledger/caliper/pull/236#discussion_r244933129,nitesh7sid
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,got it. ,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2019-01-03 08:37:06,244933818,"@@ -0,0 +1,10 @@
+{
+    ""broker_urls"": ""10.80.66.151:9092,10.80.66.151:7092,10.80.66.151:8092"",
+     ""zk_url"": ""10.80.66.151:2181"",
+     ""topic"": ""client-b"",
+     ""peerOrg"":""org1"",
+     ""peerEventUrl"":""grpcs://localhost:7053"",",6,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/244933818,https://github.com/hyperledger/caliper/pull/236#discussion_r244933818,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,The path is always changing according to different network configuration files. ,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2019-01-04 03:36:59,245195344,"@@ -12,6 +12,79 @@ const path = require('path');
 const childProcess = require('child_process');
 
 let processes  = {}; // {pid:{obj, promise}}
+let confirmedTransactions = [];
+let cachedEvents = new Map();
+let unConfirmedTransactions = [];
+let txUpdateInter = null;
+let globalConsumer;
+const TxStatus = require('../transaction.js');
+let updateTail;
+const bc   = require('../blockchain.js');
+const blockchain = new bc(path.join(__dirname, '../../../', 'network/fabric-v1.1/dev/fabric-node-tls'));",,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/245195344,https://github.com/hyperledger/caliper/pull/236#discussion_r245195344,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,Does this global_pid affect the latency computation?,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2019-01-04 06:56:19,245222695,"@@ -76,6 +159,10 @@ function launchClient(updates, results) {
         else if(msg.type === 'txUpdated') {
             pushUpdate(pid, msg.data);
         }
+        else if(msg.type === 'txUpdatedWithMQ') {
+            global_pid = pid;",107,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/245222695,https://github.com/hyperledger/caliper/pull/236#discussion_r245222695,panyu4
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,Nope. its not the issue of global_pid,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2019-01-08 22:04:49,246168177,"@@ -76,6 +159,10 @@ function launchClient(updates, results) {
         else if(msg.type === 'txUpdated') {
             pushUpdate(pid, msg.data);
         }
+        else if(msg.type === 'txUpdatedWithMQ') {
+            global_pid = pid;",107,2019-01-08 22:30:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/246168177,https://github.com/hyperledger/caliper/pull/236#discussion_r246168177,nitesh7sid
https://github.com/hyperledger/caliper/pull/236,https://github.com/hyperledger/caliper/pull/236,fixed,f591a1cbdb39af2c7dc9b3f9a0c23e37b43ab131,2019-01-08 22:32:24,246175677,"@@ -12,6 +12,79 @@ const path = require('path');
 const childProcess = require('child_process');
 
 let processes  = {}; // {pid:{obj, promise}}
+let confirmedTransactions = [];
+let cachedEvents = new Map();
+let unConfirmedTransactions = [];
+let txUpdateInter = null;
+let globalConsumer;
+const TxStatus = require('../transaction.js');
+let updateTail;
+const bc   = require('../blockchain.js');
+const blockchain = new bc(path.join(__dirname, '../../../', 'network/fabric-v1.1/dev/fabric-node-tls'));",,2019-01-08 22:32:24,https://api.github.com/repos/hyperledger/caliper/pulls/comments/246175677,https://github.com/hyperledger/caliper/pull/236#discussion_r246175677,nitesh7sid
https://github.com/hyperledger/caliper/pull/208,https://github.com/hyperledger/caliper/pull/208,"I think this should be specified outside of the round-configs, since they're independent. The Fabric SDK treats it like a [normal setting](https://github.com/hyperledger/fabric-sdk-node/blob/release-1.3/fabric-client/lib/utils.js#L111), configurable in different ways (env, command line, default config). PR #202 will facilitate this really soon.",637748b3b0a0c470067ce1fbac8efa6d3d5c1298,2018-11-05 16:11:27,230810254,"@@ -2,11 +2,17 @@
   ""blockchain"": {
     ""type"": ""fabric"",
     ""config"": ""benchmark/simple/fabric.json""
-  },
+  },  
   ""command"" : {
     ""start"": ""docker-compose -f network/fabric/simplenetwork/docker-compose.yaml up -d"",
     ""end"" : ""docker-compose -f network/fabric/simplenetwork/docker-compose.yaml down;docker rm $(docker ps -aq);docker rmi $(docker images dev* -q)""
   },
+  ""logging"": {",,2018-11-12 09:25:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/230810254,https://github.com/hyperledger/caliper/pull/208#discussion_r230810254,aklenik
https://github.com/hyperledger/caliper/pull/208,https://github.com/hyperledger/caliper/pull/208,"We should use the current file name as logger name to make identifying the source of the logs easier, i.e., `Util.getLogger('bench-flow.js');`",637748b3b0a0c470067ce1fbac8efa6d3d5c1298,2018-11-05 16:14:38,230811584,"@@ -22,14 +22,15 @@ const Monitor = require('./monitor.js');
 const Report  = require('./report.js');
 const Client  = require('./client/client.js');
 const Util = require('./util.js');
-const log = Util.log;
+const logger = Util.getLogger('testLog');",,2018-11-12 09:25:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/230811584,https://github.com/hyperledger/caliper/pull/208#discussion_r230811584,aklenik
https://github.com/hyperledger/caliper/pull/208,https://github.com/hyperledger/caliper/pull/208,"If the exception is re-thrown, then the default logger won't be returned. ",637748b3b0a0c470067ce1fbac8efa6d3d5c1298,2018-11-05 16:58:32,230829879,"@@ -14,10 +14,146 @@
 
 'use strict';
 const path = require('path');
+const fs = require('fs');
+const moment  = require('moment');
+const winston = require('winston');
 
 // comm --> src --> root
 const rootDir = path.join('..', '..');
+const LOGGING_LEVELS =  ['debug','info','warn','error'];
+const maxSize = 5242880; //5M
 
+/**
+ * Save the logging configurations
+ * @param {object} logger  cutomed winston logger
+ */
+function saveLogger(logger) {
+    if (global.caliper) {
+        global.caliper.logger = logger;
+    } else {
+        global.caliper = {
+            logger: logger
+        };
+    }
+}
+
+/**
+ * When starting to run tests, the old log files with the default names and
+ * the current log cofigurations' name should be deleted.
+ * @param {String} fileName  in default creating mode, this name is
+ *                corresponding to log level without '.log'; otherwise, this
+ *                is a full name with '.log'
+ */
+function deleteLoggerFiles(fileName) {
+    let curLogName;
+    let baseName;
+    if(fileName.indexOf('.log')>=0 && fileName.indexOf('.log')===fileName.length -4){
+        curLogName = fileName;
+        baseName = path.basename(fileName,'.log');
+    }
+    else{
+        curLogName = fileName +'.log';
+        baseName = fileName;
+    }
+    let logNumber = 0;
+    //remove the last file;
+    if(fs.existsSync(curLogName)){
+        fs.unlinkSync(curLogName);
+    }
+    logNumber++;
+    curLogName = baseName + logNumber.toString() +'.log';
+    while(fs.existsSync(curLogName)){
+        fs.unlinkSync(curLogName);
+        logNumber++;
+        curLogName = baseName + logNumber.toString() +'.log';
+    }
+}
+
+/**
+ * define a log format
+ * @param {object} options winston's options for log definition
+ * @returns {string} a formatted string
+*/
+function logFormat(options){
+    return  options.timestamp() + ' - ' +
+    options.level.toUpperCase() +
+    ' ' +(options.message ? options.message : '') +
+    (options.meta && Object.keys(options.meta).length ? '\n\t' + JSON.stringify(options.meta) : ' ') +
+    '\r\n';
+}
+
+/**
+ * If there is no  logging configurations, create a new logger,
+ * it will generater 3 files named 'info.log', 'error.log','warn.log'.
+ * The debug information is not saved to a file, it will just show to console.
+ * @return {object}   the new winston logger
+ */
+function newDefaultLogger() {
+    let transports =[new (winston.transports.Console)({
+        colorize: true})];
+    ['debug', 'info', 'warn', 'error'].forEach((level)=>{
+        try {
+            //remove the last file;
+            deleteLoggerFiles(level);
+            if(level==='debug'){
+                transports.push(
+                    new (winston.transports.Console)({
+                        timestamp: function (){return moment().format();},
+                        name: level + 'console',
+                        level: level,
+                        colorize: true,
+                        json: false
+                        //formatter: logFormat
+                    })
+                );
+            }
+            else{
+                transports.push(
+                    new (winston.transports.File)({
+                        timestamp: function (){return moment().format();},
+                        name: level+'-file',
+                        level: level,
+                        filename: level+'.log',
+                        colorize: true,
+                        json: false,
+                        maxsize: maxSize,
+                        handleExceptions: true,
+                        formatter: logFormat
+                    })
+                );
+            }
+        }
+        catch (ex) {
+            throw new Error('failed to set transports for files, the logger will use the default setting ');",,2018-11-12 09:25:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/230829879,https://github.com/hyperledger/caliper/pull/208#discussion_r230829879,aklenik
https://github.com/hyperledger/caliper/pull/208,https://github.com/hyperledger/caliper/pull/208,"I think the default should be something like the following:
* info (which is essentially progress report) and above (warning, error) should be printed to the console
* debug should go to a debug file",637748b3b0a0c470067ce1fbac8efa6d3d5c1298,2018-11-05 17:02:19,230831275,"@@ -14,10 +14,146 @@
 
 'use strict';
 const path = require('path');
+const fs = require('fs');
+const moment  = require('moment');
+const winston = require('winston');
 
 // comm --> src --> root
 const rootDir = path.join('..', '..');
+const LOGGING_LEVELS =  ['debug','info','warn','error'];
+const maxSize = 5242880; //5M
 
+/**
+ * Save the logging configurations
+ * @param {object} logger  cutomed winston logger
+ */
+function saveLogger(logger) {
+    if (global.caliper) {
+        global.caliper.logger = logger;
+    } else {
+        global.caliper = {
+            logger: logger
+        };
+    }
+}
+
+/**
+ * When starting to run tests, the old log files with the default names and
+ * the current log cofigurations' name should be deleted.
+ * @param {String} fileName  in default creating mode, this name is
+ *                corresponding to log level without '.log'; otherwise, this
+ *                is a full name with '.log'
+ */
+function deleteLoggerFiles(fileName) {
+    let curLogName;
+    let baseName;
+    if(fileName.indexOf('.log')>=0 && fileName.indexOf('.log')===fileName.length -4){
+        curLogName = fileName;
+        baseName = path.basename(fileName,'.log');
+    }
+    else{
+        curLogName = fileName +'.log';
+        baseName = fileName;
+    }
+    let logNumber = 0;
+    //remove the last file;
+    if(fs.existsSync(curLogName)){
+        fs.unlinkSync(curLogName);
+    }
+    logNumber++;
+    curLogName = baseName + logNumber.toString() +'.log';
+    while(fs.existsSync(curLogName)){
+        fs.unlinkSync(curLogName);
+        logNumber++;
+        curLogName = baseName + logNumber.toString() +'.log';
+    }
+}
+
+/**
+ * define a log format
+ * @param {object} options winston's options for log definition
+ * @returns {string} a formatted string
+*/
+function logFormat(options){
+    return  options.timestamp() + ' - ' +
+    options.level.toUpperCase() +
+    ' ' +(options.message ? options.message : '') +
+    (options.meta && Object.keys(options.meta).length ? '\n\t' + JSON.stringify(options.meta) : ' ') +
+    '\r\n';
+}
+
+/**
+ * If there is no  logging configurations, create a new logger,
+ * it will generater 3 files named 'info.log', 'error.log','warn.log'.
+ * The debug information is not saved to a file, it will just show to console.
+ * @return {object}   the new winston logger
+ */
+function newDefaultLogger() {
+    let transports =[new (winston.transports.Console)({
+        colorize: true})];
+    ['debug', 'info', 'warn', 'error'].forEach((level)=>{
+        try {
+            //remove the last file;
+            deleteLoggerFiles(level);
+            if(level==='debug'){",,2018-11-12 09:25:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/230831275,https://github.com/hyperledger/caliper/pull/208#discussion_r230831275,aklenik
https://github.com/hyperledger/caliper/pull/208,https://github.com/hyperledger/caliper/pull/208,I've moved these setting to default.yaml,637748b3b0a0c470067ce1fbac8efa6d3d5c1298,2018-11-09 06:41:46,232154209,"@@ -2,11 +2,17 @@
   ""blockchain"": {
     ""type"": ""fabric"",
     ""config"": ""benchmark/simple/fabric.json""
-  },
+  },  
   ""command"" : {
     ""start"": ""docker-compose -f network/fabric/simplenetwork/docker-compose.yaml up -d"",
     ""end"" : ""docker-compose -f network/fabric/simplenetwork/docker-compose.yaml down;docker rm $(docker ps -aq);docker rmi $(docker images dev* -q)""
   },
+  ""logging"": {",,2018-11-12 09:25:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/232154209,https://github.com/hyperledger/caliper/pull/208#discussion_r232154209,panyu4
https://github.com/hyperledger/caliper/pull/208,https://github.com/hyperledger/caliper/pull/208,All of the logger names are modified to the corresponding file name.,637748b3b0a0c470067ce1fbac8efa6d3d5c1298,2018-11-09 06:43:25,232154417,"@@ -22,14 +22,15 @@ const Monitor = require('./monitor.js');
 const Report  = require('./report.js');
 const Client  = require('./client/client.js');
 const Util = require('./util.js');
-const log = Util.log;
+const logger = Util.getLogger('testLog');",,2018-11-12 09:25:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/232154417,https://github.com/hyperledger/caliper/pull/208#discussion_r232154417,panyu4
https://github.com/hyperledger/caliper/pull/208,https://github.com/hyperledger/caliper/pull/208,It is fixed.,637748b3b0a0c470067ce1fbac8efa6d3d5c1298,2018-11-09 06:44:36,232154551,"@@ -14,10 +14,146 @@
 
 'use strict';
 const path = require('path');
+const fs = require('fs');
+const moment  = require('moment');
+const winston = require('winston');
 
 // comm --> src --> root
 const rootDir = path.join('..', '..');
+const LOGGING_LEVELS =  ['debug','info','warn','error'];
+const maxSize = 5242880; //5M
 
+/**
+ * Save the logging configurations
+ * @param {object} logger  cutomed winston logger
+ */
+function saveLogger(logger) {
+    if (global.caliper) {
+        global.caliper.logger = logger;
+    } else {
+        global.caliper = {
+            logger: logger
+        };
+    }
+}
+
+/**
+ * When starting to run tests, the old log files with the default names and
+ * the current log cofigurations' name should be deleted.
+ * @param {String} fileName  in default creating mode, this name is
+ *                corresponding to log level without '.log'; otherwise, this
+ *                is a full name with '.log'
+ */
+function deleteLoggerFiles(fileName) {
+    let curLogName;
+    let baseName;
+    if(fileName.indexOf('.log')>=0 && fileName.indexOf('.log')===fileName.length -4){
+        curLogName = fileName;
+        baseName = path.basename(fileName,'.log');
+    }
+    else{
+        curLogName = fileName +'.log';
+        baseName = fileName;
+    }
+    let logNumber = 0;
+    //remove the last file;
+    if(fs.existsSync(curLogName)){
+        fs.unlinkSync(curLogName);
+    }
+    logNumber++;
+    curLogName = baseName + logNumber.toString() +'.log';
+    while(fs.existsSync(curLogName)){
+        fs.unlinkSync(curLogName);
+        logNumber++;
+        curLogName = baseName + logNumber.toString() +'.log';
+    }
+}
+
+/**
+ * define a log format
+ * @param {object} options winston's options for log definition
+ * @returns {string} a formatted string
+*/
+function logFormat(options){
+    return  options.timestamp() + ' - ' +
+    options.level.toUpperCase() +
+    ' ' +(options.message ? options.message : '') +
+    (options.meta && Object.keys(options.meta).length ? '\n\t' + JSON.stringify(options.meta) : ' ') +
+    '\r\n';
+}
+
+/**
+ * If there is no  logging configurations, create a new logger,
+ * it will generater 3 files named 'info.log', 'error.log','warn.log'.
+ * The debug information is not saved to a file, it will just show to console.
+ * @return {object}   the new winston logger
+ */
+function newDefaultLogger() {
+    let transports =[new (winston.transports.Console)({
+        colorize: true})];
+    ['debug', 'info', 'warn', 'error'].forEach((level)=>{
+        try {
+            //remove the last file;
+            deleteLoggerFiles(level);
+            if(level==='debug'){
+                transports.push(
+                    new (winston.transports.Console)({
+                        timestamp: function (){return moment().format();},
+                        name: level + 'console',
+                        level: level,
+                        colorize: true,
+                        json: false
+                        //formatter: logFormat
+                    })
+                );
+            }
+            else{
+                transports.push(
+                    new (winston.transports.File)({
+                        timestamp: function (){return moment().format();},
+                        name: level+'-file',
+                        level: level,
+                        filename: level+'.log',
+                        colorize: true,
+                        json: false,
+                        maxsize: maxSize,
+                        handleExceptions: true,
+                        formatter: logFormat
+                    })
+                );
+            }
+        }
+        catch (ex) {
+            throw new Error('failed to set transports for files, the logger will use the default setting ');",,2018-11-12 09:25:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/232154551,https://github.com/hyperledger/caliper/pull/208#discussion_r232154551,panyu4
https://github.com/hyperledger/caliper/pull/202,https://github.com/hyperledger/caliper/pull/202,`src/comm/util.js:resolvePath` provides consistent path resolution.,1a2b5b9eb95f2843ed50ed03a0565ef085f650ba,2018-10-30 13:20:48,229301302,"@@ -11,14 +11,23 @@
 const bc   = require('../blockchain.js');
 const RateControl = require('../rate-control/rateControl.js');
 const Util = require('../util.js');
+const cfUtil = require('../config-util.js');
+const path = require('path');
+const config = cfUtil.getConfig();
+const default_config = path.resolve(__dirname, '../../../config/default.json');",,2018-11-06 06:58:42,https://api.github.com/repos/hyperledger/caliper/pulls/comments/229301302,https://github.com/hyperledger/caliper/pull/202#discussion_r229301302,aklenik
https://github.com/hyperledger/caliper/pull/202,https://github.com/hyperledger/caliper/pull/202,Maybe the default config could be added in the constructor with the lowest priority?,1a2b5b9eb95f2843ed50ed03a0565ef085f650ba,2018-10-30 13:21:31,229301548,"@@ -11,14 +11,23 @@
 const bc   = require('../blockchain.js');
 const RateControl = require('../rate-control/rateControl.js');
 const Util = require('../util.js');
+const cfUtil = require('../config-util.js');
+const path = require('path');
+const config = cfUtil.getConfig();
+const default_config = path.resolve(__dirname, '../../../config/default.json');
+//make sure this default has precedences
+config.reorderFileStores(default_config);",,2018-11-06 06:58:42,https://api.github.com/repos/hyperledger/caliper/pulls/comments/229301548,https://github.com/hyperledger/caliper/pull/202#discussion_r229301548,aklenik
https://github.com/hyperledger/caliper/pull/202,https://github.com/hyperledger/caliper/pull/202,Fixed,1a2b5b9eb95f2843ed50ed03a0565ef085f650ba,2018-11-02 11:41:57,230346353,"@@ -11,14 +11,23 @@
 const bc   = require('../blockchain.js');
 const RateControl = require('../rate-control/rateControl.js');
 const Util = require('../util.js');
+const cfUtil = require('../config-util.js');
+const path = require('path');
+const config = cfUtil.getConfig();
+const default_config = path.resolve(__dirname, '../../../config/default.json');",,2018-11-06 06:58:42,https://api.github.com/repos/hyperledger/caliper/pulls/comments/230346353,https://github.com/hyperledger/caliper/pull/202#discussion_r230346353,feihujiang
https://github.com/hyperledger/caliper/pull/202,https://github.com/hyperledger/caliper/pull/202,Fixed,1a2b5b9eb95f2843ed50ed03a0565ef085f650ba,2018-11-02 11:42:04,230346375,"@@ -11,14 +11,23 @@
 const bc   = require('../blockchain.js');
 const RateControl = require('../rate-control/rateControl.js');
 const Util = require('../util.js');
+const cfUtil = require('../config-util.js');
+const path = require('path');
+const config = cfUtil.getConfig();
+const default_config = path.resolve(__dirname, '../../../config/default.json');
+//make sure this default has precedences
+config.reorderFileStores(default_config);",,2018-11-06 06:58:42,https://api.github.com/repos/hyperledger/caliper/pulls/comments/230346375,https://github.com/hyperledger/caliper/pull/202#discussion_r230346375,feihujiang
https://github.com/hyperledger/caliper/pull/202,https://github.com/hyperledger/caliper/pull/202,This should be moved after the `nconf.env()` line to make it the lowest priority.,1a2b5b9eb95f2843ed50ed03a0565ef085f650ba,2018-11-05 15:23:48,230790356,"@@ -0,0 +1,140 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+'use strict';
+
+const commUtils = require('./util');
+
+const nconf = require('nconf');
+nconf.formats.yaml = require('nconf-yaml');
+
+//
+// The class representing the hierarchy of configuration settings.
+//
+const Config = class {
+    /**
+     * Constructor
+     */
+    constructor() {
+        nconf.use('memory');
+        nconf.use('mapenv', {type:'memory'});
+        this.mapSettings(nconf.stores.mapenv, process.env);
+        this._fileStores = [];
+        // reference to configuration settings
+        this._config = nconf;
+        const defaultConfig = commUtils.resolvePath('config/default.yaml');
+        this.file(defaultConfig);",39,2018-11-06 06:58:42,https://api.github.com/repos/hyperledger/caliper/pulls/comments/230790356,https://github.com/hyperledger/caliper/pull/202#discussion_r230790356,aklenik
https://github.com/hyperledger/caliper/pull/202,https://github.com/hyperledger/caliper/pull/202,I think this file is no longer necessary.,1a2b5b9eb95f2843ed50ed03a0565ef085f650ba,2018-11-05 15:24:49,230790784,"@@ -0,0 +1,4 @@
+{",,2018-11-06 06:58:42,https://api.github.com/repos/hyperledger/caliper/pulls/comments/230790784,https://github.com/hyperledger/caliper/pull/202#discussion_r230790784,aklenik
https://github.com/hyperledger/caliper/pull/202,https://github.com/hyperledger/caliper/pull/202,Fixed,1a2b5b9eb95f2843ed50ed03a0565ef085f650ba,2018-11-06 07:04:18,231014904,"@@ -0,0 +1,140 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+'use strict';
+
+const commUtils = require('./util');
+
+const nconf = require('nconf');
+nconf.formats.yaml = require('nconf-yaml');
+
+//
+// The class representing the hierarchy of configuration settings.
+//
+const Config = class {
+    /**
+     * Constructor
+     */
+    constructor() {
+        nconf.use('memory');
+        nconf.use('mapenv', {type:'memory'});
+        this.mapSettings(nconf.stores.mapenv, process.env);
+        this._fileStores = [];
+        // reference to configuration settings
+        this._config = nconf;
+        const defaultConfig = commUtils.resolvePath('config/default.yaml');
+        this.file(defaultConfig);",39,2018-11-06 07:04:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/231014904,https://github.com/hyperledger/caliper/pull/202#discussion_r231014904,feihujiang
https://github.com/hyperledger/caliper/pull/202,https://github.com/hyperledger/caliper/pull/202,Removed.,1a2b5b9eb95f2843ed50ed03a0565ef085f650ba,2018-11-06 07:04:35,231014944,"@@ -0,0 +1,4 @@
+{",,2018-11-06 07:04:35,https://api.github.com/repos/hyperledger/caliper/pulls/comments/231014944,https://github.com/hyperledger/caliper/pull/202#discussion_r231014944,feihujiang
https://github.com/hyperledger/caliper/pull/191,https://github.com/hyperledger/caliper/pull/191,I could not tell if there was a reason for all of these excludes or not. I left most. The rate-control files above actually already have some coverage.,d143670a9e6b1c39509bc74fed3f262567615486,2018-10-15 15:11:41,225203975,"@@ -56,15 +60,11 @@
       ""coverage/**"",
       ""src/comm/*.js"",
       ""src/comm/client/**"",
-      ""src/comm/rate-control/pidRate.js"",
-      ""src/comm/rate-control/rateControl.js"",
-      ""src/comm/rate-control/rateInterface.js"",
       ""src/composer/**"",
       ""src/contract/**"",
       ""src/fabric/**"",
       ""src/gui/**"",
       ""src/iroha/**"",
-      ""src/sawtooth/**"",",23,2018-10-16 01:37:39,https://api.github.com/repos/hyperledger/caliper/pulls/comments/225203975,https://github.com/hyperledger/caliper/pull/191#discussion_r225203975,mtrubs
https://github.com/hyperledger/caliper/pull/191,https://github.com/hyperledger/caliper/pull/191,I needed to add this so that the template html file gets included on an `npm install`,d143670a9e6b1c39509bc74fed3f262567615486,2018-10-15 15:12:43,225204470,"@@ -19,6 +19,10 @@
   },
   ""engine-strict"": true,
   ""engineStrict"": true,
+  ""files"": [
+    ""*"",
+    ""src/comm/template/report.html""
+  ],",7,2018-10-16 01:37:39,https://api.github.com/repos/hyperledger/caliper/pulls/comments/225204470,https://github.com/hyperledger/caliper/pull/191#discussion_r225204470,mtrubs
https://github.com/hyperledger/caliper/pull/167,https://github.com/hyperledger/caliper/pull/167,Why remove these above lines?,bdeaaed3f9cb6262e735596fff0877450e421eb7,2018-10-08 06:51:23,223260441,"@@ -9,15 +9,16 @@
 
 module.exports.info  = 'opening accounts';
 
-let accounts = [];
+let account_array = [];
+let txnPerBatch;
 let initMoney;
 let bc, contx;
 module.exports.init = function(blockchain, context, args) {
-    if(!args.hasOwnProperty('money')) {
-        return Promise.reject(new Error('simple.open - ""money"" is missed in the arguments'));",11,2018-10-08 06:51:23,https://api.github.com/repos/hyperledger/caliper/pulls/comments/223260441,https://github.com/hyperledger/caliper/pull/167#discussion_r223260441,feihujiang
https://github.com/hyperledger/caliper/pull/159,https://github.com/hyperledger/caliper/pull/159,"Why the next block is not pending, the batch commit status is success? Why the next block must include the batch?",3808e8782ff3ec02b8586fcbad02c9ea0e944b6d,2018-10-08 11:01:31,223323468,"@@ -14,6 +14,152 @@ const log = require('../comm/util.js').log;
 let configPath;
 const request = require('request-promise');
 const TxStatus = require('../comm/transaction');
+const _ = require('lodash');
+const { Stream } = require('sawtooth-sdk/messaging/stream');
+const {
+    Message,
+    EventList,
+    EventSubscription,
+    ClientEventsSubscribeRequest,
+    ClientEventsSubscribeResponse,
+    ClientEventsUnsubscribeRequest,
+    ClientEventsUnsubscribeResponse
+} = require('sawtooth-sdk/protobuf');
+
+let lastKnownBlockId=null;
+let stream;
+let blockCommitSatus = new Map();
+let currentBlockNum=0;
+
+/**
+* Get the last recent block id for the block chain
+* @return {Promise<String>} last recent block id
+*/
+async function getCurrentBlockId() {
+    const request = require('request-promise');
+    let config = require(configPath);
+    let restApiUrl = config.sawtooth.network.restapi.url;
+    const blocks = restApiUrl + '/blocks?limit=1';
+    let options = {
+        uri: blocks
+    };
+    return request(options)
+        .then(function(body) {
+            let data = (JSON.parse(body)).data;
+            if (data.length > 0) {
+                currentBlockNum = parseInt(data[0].header.block_num);
+                lastKnownBlockId = data[0].header_signature.toString();
+                return currentBlockNum;
+            }
+        });
+}
+
+/**
+ * Get block data from event message
+ * @param {Object} events message
+ * @return {Promise<object>} The promise for the result of event message
+ */
+async function getBlock(events) {
+    const block = _.chain(events)
+        .find(e => e.eventType === 'sawtooth/block-commit')
+        .get('attributes')
+        .map(a => [a.key, a.value])
+        .fromPairs()
+        .value();
+    return {
+        blockNum: parseInt(block.block_num),
+        blockId: block.block_id.toString(),
+        stateRootHash: block.state_root_hash
+    };
+}
+
+/**
+ * Handle event message to updated lastKnownBlockId for next event subscription
+ * @param {Object} msg event message
+ * @return {void}
+ */
+async function handleEvent(msg) {
+    if (msg.messageType === Message.MessageType.CLIENT_EVENTS) {
+        const events = EventList.decode(msg.content).events;
+        getBlock(events).then(result => {
+            lastKnownBlockId = result.blockId.toString();
+            let blockNum=result.blockNum;
+            //On receiving event with block, update the status of the block to sucess
+            blockCommitSatus.set(blockNum, 'success');
+        });
+    } else {
+        log('Warn: Received message of unknown type:', msg.messageType);
+    }
+}
+
+/**
+ * Subscribe to block-commit delta events
+ * @param {Object} stream object to send event subscribe message
+ * @return {void}
+ */
+async function subscribe(stream) {
+    //Subscribe to block-commit delta event
+    const blockSub = EventSubscription.create({
+        eventType: 'sawtooth/block-commit'
+    });
+
+    if(lastKnownBlockId === null) {
+        await getCurrentBlockId().then(() => {
+        });
+    }
+    stream.send(
+        Message.MessageType.CLIENT_EVENTS_SUBSCRIBE_REQUEST,
+        ClientEventsSubscribeRequest.encode({
+            subscriptions: [blockSub],
+            lastKnownBlockIds: [lastKnownBlockId]
+        }).finish()
+    )
+        .then(response => ClientEventsSubscribeResponse.decode(response))
+        .then(decoded => {
+            const status = _.findKey(ClientEventsSubscribeResponse.Status,
+                val => val === decoded.status);
+            if (status !== 'OK') {
+                throw new Error(`Validator responded with status ""${status}""`);
+            }
+        });
+}
+
+/**
+ * Unsubscribe to block-commit delta events
+ * @param {Object} stream1 object to send event unsubscribe message
+ * @return {void}
+ */
+function unsubscribe(stream1) {
+    stream1.send(
+        Message.MessageType.CLIENT_EVENTS_UNSUBSCRIBE_REQUEST,
+        ClientEventsUnsubscribeRequest.encode({
+        }).finish()
+    )
+        .then(response => ClientEventsUnsubscribeResponse.decode(response))
+        .then(decoded => {
+            const status = _.findKey(ClientEventsUnsubscribeResponse.Status,
+                val => val === decoded.status);
+            if (status !== 'OK') {
+                throw new Error(`Validator responded with status ""${status}""`);
+            }
+        });
+}
+/**
+ * Get batch commit event message on block commit
+ * @param {Number} block_num of next block
+ * @param {Number} batchStats Batch status object to update commit status
+ * @return {Promise<object>} returns batch commit status
+ */
+function getBatchEventResponse(block_num, batchStats) {
+    return new Promise(resolve => {
+        while(blockCommitSatus.get(block_num) !== 'pending') {
+        }
+        //remove the block number from map because we are done with this block
+        blockCommitSatus.delete(block_num);
+        batchStats.SetStatusSuccess();",146,2018-10-08 11:01:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/223323468,https://github.com/hyperledger/caliper/pull/159#discussion_r223323468,feihujiang
https://github.com/hyperledger/caliper/pull/159,https://github.com/hyperledger/caliper/pull/159,sucess is a typo.,3808e8782ff3ec02b8586fcbad02c9ea0e944b6d,2018-10-08 11:02:08,223323613,"@@ -14,6 +14,152 @@ const log = require('../comm/util.js').log;
 let configPath;
 const request = require('request-promise');
 const TxStatus = require('../comm/transaction');
+const _ = require('lodash');
+const { Stream } = require('sawtooth-sdk/messaging/stream');
+const {
+    Message,
+    EventList,
+    EventSubscription,
+    ClientEventsSubscribeRequest,
+    ClientEventsSubscribeResponse,
+    ClientEventsUnsubscribeRequest,
+    ClientEventsUnsubscribeResponse
+} = require('sawtooth-sdk/protobuf');
+
+let lastKnownBlockId=null;
+let stream;
+let blockCommitSatus = new Map();
+let currentBlockNum=0;
+
+/**
+* Get the last recent block id for the block chain
+* @return {Promise<String>} last recent block id
+*/
+async function getCurrentBlockId() {
+    const request = require('request-promise');
+    let config = require(configPath);
+    let restApiUrl = config.sawtooth.network.restapi.url;
+    const blocks = restApiUrl + '/blocks?limit=1';
+    let options = {
+        uri: blocks
+    };
+    return request(options)
+        .then(function(body) {
+            let data = (JSON.parse(body)).data;
+            if (data.length > 0) {
+                currentBlockNum = parseInt(data[0].header.block_num);
+                lastKnownBlockId = data[0].header_signature.toString();
+                return currentBlockNum;
+            }
+        });
+}
+
+/**
+ * Get block data from event message
+ * @param {Object} events message
+ * @return {Promise<object>} The promise for the result of event message
+ */
+async function getBlock(events) {
+    const block = _.chain(events)
+        .find(e => e.eventType === 'sawtooth/block-commit')
+        .get('attributes')
+        .map(a => [a.key, a.value])
+        .fromPairs()
+        .value();
+    return {
+        blockNum: parseInt(block.block_num),
+        blockId: block.block_id.toString(),
+        stateRootHash: block.state_root_hash
+    };
+}
+
+/**
+ * Handle event message to updated lastKnownBlockId for next event subscription
+ * @param {Object} msg event message
+ * @return {void}
+ */
+async function handleEvent(msg) {
+    if (msg.messageType === Message.MessageType.CLIENT_EVENTS) {
+        const events = EventList.decode(msg.content).events;
+        getBlock(events).then(result => {
+            lastKnownBlockId = result.blockId.toString();
+            let blockNum=result.blockNum;
+            //On receiving event with block, update the status of the block to sucess",74,2018-10-08 11:02:09,https://api.github.com/repos/hyperledger/caliper/pulls/comments/223323613,https://github.com/hyperledger/caliper/pull/159#discussion_r223323613,feihujiang
https://github.com/hyperledger/caliper/pull/159,https://github.com/hyperledger/caliper/pull/159,Once batch is submitted then the adding status of batch as pending to hash map and when we get the event then remove the entry from hash map and update the status to success and send it to caliper.,3808e8782ff3ec02b8586fcbad02c9ea0e944b6d,2018-10-08 14:09:00,223377011,"@@ -14,6 +14,152 @@ const log = require('../comm/util.js').log;
 let configPath;
 const request = require('request-promise');
 const TxStatus = require('../comm/transaction');
+const _ = require('lodash');
+const { Stream } = require('sawtooth-sdk/messaging/stream');
+const {
+    Message,
+    EventList,
+    EventSubscription,
+    ClientEventsSubscribeRequest,
+    ClientEventsSubscribeResponse,
+    ClientEventsUnsubscribeRequest,
+    ClientEventsUnsubscribeResponse
+} = require('sawtooth-sdk/protobuf');
+
+let lastKnownBlockId=null;
+let stream;
+let blockCommitSatus = new Map();
+let currentBlockNum=0;
+
+/**
+* Get the last recent block id for the block chain
+* @return {Promise<String>} last recent block id
+*/
+async function getCurrentBlockId() {
+    const request = require('request-promise');
+    let config = require(configPath);
+    let restApiUrl = config.sawtooth.network.restapi.url;
+    const blocks = restApiUrl + '/blocks?limit=1';
+    let options = {
+        uri: blocks
+    };
+    return request(options)
+        .then(function(body) {
+            let data = (JSON.parse(body)).data;
+            if (data.length > 0) {
+                currentBlockNum = parseInt(data[0].header.block_num);
+                lastKnownBlockId = data[0].header_signature.toString();
+                return currentBlockNum;
+            }
+        });
+}
+
+/**
+ * Get block data from event message
+ * @param {Object} events message
+ * @return {Promise<object>} The promise for the result of event message
+ */
+async function getBlock(events) {
+    const block = _.chain(events)
+        .find(e => e.eventType === 'sawtooth/block-commit')
+        .get('attributes')
+        .map(a => [a.key, a.value])
+        .fromPairs()
+        .value();
+    return {
+        blockNum: parseInt(block.block_num),
+        blockId: block.block_id.toString(),
+        stateRootHash: block.state_root_hash
+    };
+}
+
+/**
+ * Handle event message to updated lastKnownBlockId for next event subscription
+ * @param {Object} msg event message
+ * @return {void}
+ */
+async function handleEvent(msg) {
+    if (msg.messageType === Message.MessageType.CLIENT_EVENTS) {
+        const events = EventList.decode(msg.content).events;
+        getBlock(events).then(result => {
+            lastKnownBlockId = result.blockId.toString();
+            let blockNum=result.blockNum;
+            //On receiving event with block, update the status of the block to sucess
+            blockCommitSatus.set(blockNum, 'success');
+        });
+    } else {
+        log('Warn: Received message of unknown type:', msg.messageType);
+    }
+}
+
+/**
+ * Subscribe to block-commit delta events
+ * @param {Object} stream object to send event subscribe message
+ * @return {void}
+ */
+async function subscribe(stream) {
+    //Subscribe to block-commit delta event
+    const blockSub = EventSubscription.create({
+        eventType: 'sawtooth/block-commit'
+    });
+
+    if(lastKnownBlockId === null) {
+        await getCurrentBlockId().then(() => {
+        });
+    }
+    stream.send(
+        Message.MessageType.CLIENT_EVENTS_SUBSCRIBE_REQUEST,
+        ClientEventsSubscribeRequest.encode({
+            subscriptions: [blockSub],
+            lastKnownBlockIds: [lastKnownBlockId]
+        }).finish()
+    )
+        .then(response => ClientEventsSubscribeResponse.decode(response))
+        .then(decoded => {
+            const status = _.findKey(ClientEventsSubscribeResponse.Status,
+                val => val === decoded.status);
+            if (status !== 'OK') {
+                throw new Error(`Validator responded with status ""${status}""`);
+            }
+        });
+}
+
+/**
+ * Unsubscribe to block-commit delta events
+ * @param {Object} stream1 object to send event unsubscribe message
+ * @return {void}
+ */
+function unsubscribe(stream1) {
+    stream1.send(
+        Message.MessageType.CLIENT_EVENTS_UNSUBSCRIBE_REQUEST,
+        ClientEventsUnsubscribeRequest.encode({
+        }).finish()
+    )
+        .then(response => ClientEventsUnsubscribeResponse.decode(response))
+        .then(decoded => {
+            const status = _.findKey(ClientEventsUnsubscribeResponse.Status,
+                val => val === decoded.status);
+            if (status !== 'OK') {
+                throw new Error(`Validator responded with status ""${status}""`);
+            }
+        });
+}
+/**
+ * Get batch commit event message on block commit
+ * @param {Number} block_num of next block
+ * @param {Number} batchStats Batch status object to update commit status
+ * @return {Promise<object>} returns batch commit status
+ */
+function getBatchEventResponse(block_num, batchStats) {
+    return new Promise(resolve => {
+        while(blockCommitSatus.get(block_num) !== 'pending') {
+        }
+        //remove the block number from map because we are done with this block
+        blockCommitSatus.delete(block_num);
+        batchStats.SetStatusSuccess();",146,2018-10-08 14:09:00,https://api.github.com/repos/hyperledger/caliper/pulls/comments/223377011,https://github.com/hyperledger/caliper/pull/159#discussion_r223377011,Ram-srini
https://github.com/hyperledger/caliper/pull/159,https://github.com/hyperledger/caliper/pull/159,"After getting event from transactions commit event, updating the status to success.",3808e8782ff3ec02b8586fcbad02c9ea0e944b6d,2018-10-08 14:10:23,223377510,"@@ -14,6 +14,152 @@ const log = require('../comm/util.js').log;
 let configPath;
 const request = require('request-promise');
 const TxStatus = require('../comm/transaction');
+const _ = require('lodash');
+const { Stream } = require('sawtooth-sdk/messaging/stream');
+const {
+    Message,
+    EventList,
+    EventSubscription,
+    ClientEventsSubscribeRequest,
+    ClientEventsSubscribeResponse,
+    ClientEventsUnsubscribeRequest,
+    ClientEventsUnsubscribeResponse
+} = require('sawtooth-sdk/protobuf');
+
+let lastKnownBlockId=null;
+let stream;
+let blockCommitSatus = new Map();
+let currentBlockNum=0;
+
+/**
+* Get the last recent block id for the block chain
+* @return {Promise<String>} last recent block id
+*/
+async function getCurrentBlockId() {
+    const request = require('request-promise');
+    let config = require(configPath);
+    let restApiUrl = config.sawtooth.network.restapi.url;
+    const blocks = restApiUrl + '/blocks?limit=1';
+    let options = {
+        uri: blocks
+    };
+    return request(options)
+        .then(function(body) {
+            let data = (JSON.parse(body)).data;
+            if (data.length > 0) {
+                currentBlockNum = parseInt(data[0].header.block_num);
+                lastKnownBlockId = data[0].header_signature.toString();
+                return currentBlockNum;
+            }
+        });
+}
+
+/**
+ * Get block data from event message
+ * @param {Object} events message
+ * @return {Promise<object>} The promise for the result of event message
+ */
+async function getBlock(events) {
+    const block = _.chain(events)
+        .find(e => e.eventType === 'sawtooth/block-commit')
+        .get('attributes')
+        .map(a => [a.key, a.value])
+        .fromPairs()
+        .value();
+    return {
+        blockNum: parseInt(block.block_num),
+        blockId: block.block_id.toString(),
+        stateRootHash: block.state_root_hash
+    };
+}
+
+/**
+ * Handle event message to updated lastKnownBlockId for next event subscription
+ * @param {Object} msg event message
+ * @return {void}
+ */
+async function handleEvent(msg) {
+    if (msg.messageType === Message.MessageType.CLIENT_EVENTS) {
+        const events = EventList.decode(msg.content).events;
+        getBlock(events).then(result => {
+            lastKnownBlockId = result.blockId.toString();
+            let blockNum=result.blockNum;
+            //On receiving event with block, update the status of the block to sucess",74,2018-10-08 14:10:23,https://api.github.com/repos/hyperledger/caliper/pulls/comments/223377510,https://github.com/hyperledger/caliper/pull/159#discussion_r223377510,Ram-srini
https://github.com/hyperledger/caliper/pull/159,https://github.com/hyperledger/caliper/pull/159,"Yes ,I know the total process. But Which event? I can't find the batch commit event, but the block commit event. So my question is why we get the  block commit event, we could update the status of the batch to success.",3808e8782ff3ec02b8586fcbad02c9ea0e944b6d,2018-10-09 01:53:52,223541591,"@@ -14,6 +14,152 @@ const log = require('../comm/util.js').log;
 let configPath;
 const request = require('request-promise');
 const TxStatus = require('../comm/transaction');
+const _ = require('lodash');
+const { Stream } = require('sawtooth-sdk/messaging/stream');
+const {
+    Message,
+    EventList,
+    EventSubscription,
+    ClientEventsSubscribeRequest,
+    ClientEventsSubscribeResponse,
+    ClientEventsUnsubscribeRequest,
+    ClientEventsUnsubscribeResponse
+} = require('sawtooth-sdk/protobuf');
+
+let lastKnownBlockId=null;
+let stream;
+let blockCommitSatus = new Map();
+let currentBlockNum=0;
+
+/**
+* Get the last recent block id for the block chain
+* @return {Promise<String>} last recent block id
+*/
+async function getCurrentBlockId() {
+    const request = require('request-promise');
+    let config = require(configPath);
+    let restApiUrl = config.sawtooth.network.restapi.url;
+    const blocks = restApiUrl + '/blocks?limit=1';
+    let options = {
+        uri: blocks
+    };
+    return request(options)
+        .then(function(body) {
+            let data = (JSON.parse(body)).data;
+            if (data.length > 0) {
+                currentBlockNum = parseInt(data[0].header.block_num);
+                lastKnownBlockId = data[0].header_signature.toString();
+                return currentBlockNum;
+            }
+        });
+}
+
+/**
+ * Get block data from event message
+ * @param {Object} events message
+ * @return {Promise<object>} The promise for the result of event message
+ */
+async function getBlock(events) {
+    const block = _.chain(events)
+        .find(e => e.eventType === 'sawtooth/block-commit')
+        .get('attributes')
+        .map(a => [a.key, a.value])
+        .fromPairs()
+        .value();
+    return {
+        blockNum: parseInt(block.block_num),
+        blockId: block.block_id.toString(),
+        stateRootHash: block.state_root_hash
+    };
+}
+
+/**
+ * Handle event message to updated lastKnownBlockId for next event subscription
+ * @param {Object} msg event message
+ * @return {void}
+ */
+async function handleEvent(msg) {
+    if (msg.messageType === Message.MessageType.CLIENT_EVENTS) {
+        const events = EventList.decode(msg.content).events;
+        getBlock(events).then(result => {
+            lastKnownBlockId = result.blockId.toString();
+            let blockNum=result.blockNum;
+            //On receiving event with block, update the status of the block to sucess
+            blockCommitSatus.set(blockNum, 'success');
+        });
+    } else {
+        log('Warn: Received message of unknown type:', msg.messageType);
+    }
+}
+
+/**
+ * Subscribe to block-commit delta events
+ * @param {Object} stream object to send event subscribe message
+ * @return {void}
+ */
+async function subscribe(stream) {
+    //Subscribe to block-commit delta event
+    const blockSub = EventSubscription.create({
+        eventType: 'sawtooth/block-commit'
+    });
+
+    if(lastKnownBlockId === null) {
+        await getCurrentBlockId().then(() => {
+        });
+    }
+    stream.send(
+        Message.MessageType.CLIENT_EVENTS_SUBSCRIBE_REQUEST,
+        ClientEventsSubscribeRequest.encode({
+            subscriptions: [blockSub],
+            lastKnownBlockIds: [lastKnownBlockId]
+        }).finish()
+    )
+        .then(response => ClientEventsSubscribeResponse.decode(response))
+        .then(decoded => {
+            const status = _.findKey(ClientEventsSubscribeResponse.Status,
+                val => val === decoded.status);
+            if (status !== 'OK') {
+                throw new Error(`Validator responded with status ""${status}""`);
+            }
+        });
+}
+
+/**
+ * Unsubscribe to block-commit delta events
+ * @param {Object} stream1 object to send event unsubscribe message
+ * @return {void}
+ */
+function unsubscribe(stream1) {
+    stream1.send(
+        Message.MessageType.CLIENT_EVENTS_UNSUBSCRIBE_REQUEST,
+        ClientEventsUnsubscribeRequest.encode({
+        }).finish()
+    )
+        .then(response => ClientEventsUnsubscribeResponse.decode(response))
+        .then(decoded => {
+            const status = _.findKey(ClientEventsUnsubscribeResponse.Status,
+                val => val === decoded.status);
+            if (status !== 'OK') {
+                throw new Error(`Validator responded with status ""${status}""`);
+            }
+        });
+}
+/**
+ * Get batch commit event message on block commit
+ * @param {Number} block_num of next block
+ * @param {Number} batchStats Batch status object to update commit status
+ * @return {Promise<object>} returns batch commit status
+ */
+function getBatchEventResponse(block_num, batchStats) {
+    return new Promise(resolve => {
+        while(blockCommitSatus.get(block_num) !== 'pending') {
+        }
+        //remove the block number from map because we are done with this block
+        blockCommitSatus.delete(block_num);
+        batchStats.SetStatusSuccess();",146,2018-10-09 01:53:53,https://api.github.com/repos/hyperledger/caliper/pulls/comments/223541591,https://github.com/hyperledger/caliper/pull/159#discussion_r223541591,feihujiang
https://github.com/hyperledger/caliper/pull/159,https://github.com/hyperledger/caliper/pull/159,The last word 'sucess' of the annotation is a typo.,3808e8782ff3ec02b8586fcbad02c9ea0e944b6d,2018-10-09 01:55:51,223541796,"@@ -14,6 +14,152 @@ const log = require('../comm/util.js').log;
 let configPath;
 const request = require('request-promise');
 const TxStatus = require('../comm/transaction');
+const _ = require('lodash');
+const { Stream } = require('sawtooth-sdk/messaging/stream');
+const {
+    Message,
+    EventList,
+    EventSubscription,
+    ClientEventsSubscribeRequest,
+    ClientEventsSubscribeResponse,
+    ClientEventsUnsubscribeRequest,
+    ClientEventsUnsubscribeResponse
+} = require('sawtooth-sdk/protobuf');
+
+let lastKnownBlockId=null;
+let stream;
+let blockCommitSatus = new Map();
+let currentBlockNum=0;
+
+/**
+* Get the last recent block id for the block chain
+* @return {Promise<String>} last recent block id
+*/
+async function getCurrentBlockId() {
+    const request = require('request-promise');
+    let config = require(configPath);
+    let restApiUrl = config.sawtooth.network.restapi.url;
+    const blocks = restApiUrl + '/blocks?limit=1';
+    let options = {
+        uri: blocks
+    };
+    return request(options)
+        .then(function(body) {
+            let data = (JSON.parse(body)).data;
+            if (data.length > 0) {
+                currentBlockNum = parseInt(data[0].header.block_num);
+                lastKnownBlockId = data[0].header_signature.toString();
+                return currentBlockNum;
+            }
+        });
+}
+
+/**
+ * Get block data from event message
+ * @param {Object} events message
+ * @return {Promise<object>} The promise for the result of event message
+ */
+async function getBlock(events) {
+    const block = _.chain(events)
+        .find(e => e.eventType === 'sawtooth/block-commit')
+        .get('attributes')
+        .map(a => [a.key, a.value])
+        .fromPairs()
+        .value();
+    return {
+        blockNum: parseInt(block.block_num),
+        blockId: block.block_id.toString(),
+        stateRootHash: block.state_root_hash
+    };
+}
+
+/**
+ * Handle event message to updated lastKnownBlockId for next event subscription
+ * @param {Object} msg event message
+ * @return {void}
+ */
+async function handleEvent(msg) {
+    if (msg.messageType === Message.MessageType.CLIENT_EVENTS) {
+        const events = EventList.decode(msg.content).events;
+        getBlock(events).then(result => {
+            lastKnownBlockId = result.blockId.toString();
+            let blockNum=result.blockNum;
+            //On receiving event with block, update the status of the block to sucess",74,2018-10-09 01:55:51,https://api.github.com/repos/hyperledger/caliper/pulls/comments/223541796,https://github.com/hyperledger/caliper/pull/159#discussion_r223541796,feihujiang
https://github.com/hyperledger/caliper/pull/159,https://github.com/hyperledger/caliper/pull/159,"We are subscribed to block-commit event. In sawtooth it will be block level, not batch level. Multiple batches are added to block and it is committed. After getting block commit event we are setting batch status to success and sending it to caliper. ",3808e8782ff3ec02b8586fcbad02c9ea0e944b6d,2018-10-09 03:10:40,223549746,"@@ -14,6 +14,152 @@ const log = require('../comm/util.js').log;
 let configPath;
 const request = require('request-promise');
 const TxStatus = require('../comm/transaction');
+const _ = require('lodash');
+const { Stream } = require('sawtooth-sdk/messaging/stream');
+const {
+    Message,
+    EventList,
+    EventSubscription,
+    ClientEventsSubscribeRequest,
+    ClientEventsSubscribeResponse,
+    ClientEventsUnsubscribeRequest,
+    ClientEventsUnsubscribeResponse
+} = require('sawtooth-sdk/protobuf');
+
+let lastKnownBlockId=null;
+let stream;
+let blockCommitSatus = new Map();
+let currentBlockNum=0;
+
+/**
+* Get the last recent block id for the block chain
+* @return {Promise<String>} last recent block id
+*/
+async function getCurrentBlockId() {
+    const request = require('request-promise');
+    let config = require(configPath);
+    let restApiUrl = config.sawtooth.network.restapi.url;
+    const blocks = restApiUrl + '/blocks?limit=1';
+    let options = {
+        uri: blocks
+    };
+    return request(options)
+        .then(function(body) {
+            let data = (JSON.parse(body)).data;
+            if (data.length > 0) {
+                currentBlockNum = parseInt(data[0].header.block_num);
+                lastKnownBlockId = data[0].header_signature.toString();
+                return currentBlockNum;
+            }
+        });
+}
+
+/**
+ * Get block data from event message
+ * @param {Object} events message
+ * @return {Promise<object>} The promise for the result of event message
+ */
+async function getBlock(events) {
+    const block = _.chain(events)
+        .find(e => e.eventType === 'sawtooth/block-commit')
+        .get('attributes')
+        .map(a => [a.key, a.value])
+        .fromPairs()
+        .value();
+    return {
+        blockNum: parseInt(block.block_num),
+        blockId: block.block_id.toString(),
+        stateRootHash: block.state_root_hash
+    };
+}
+
+/**
+ * Handle event message to updated lastKnownBlockId for next event subscription
+ * @param {Object} msg event message
+ * @return {void}
+ */
+async function handleEvent(msg) {
+    if (msg.messageType === Message.MessageType.CLIENT_EVENTS) {
+        const events = EventList.decode(msg.content).events;
+        getBlock(events).then(result => {
+            lastKnownBlockId = result.blockId.toString();
+            let blockNum=result.blockNum;
+            //On receiving event with block, update the status of the block to sucess
+            blockCommitSatus.set(blockNum, 'success');
+        });
+    } else {
+        log('Warn: Received message of unknown type:', msg.messageType);
+    }
+}
+
+/**
+ * Subscribe to block-commit delta events
+ * @param {Object} stream object to send event subscribe message
+ * @return {void}
+ */
+async function subscribe(stream) {
+    //Subscribe to block-commit delta event
+    const blockSub = EventSubscription.create({
+        eventType: 'sawtooth/block-commit'
+    });
+
+    if(lastKnownBlockId === null) {
+        await getCurrentBlockId().then(() => {
+        });
+    }
+    stream.send(
+        Message.MessageType.CLIENT_EVENTS_SUBSCRIBE_REQUEST,
+        ClientEventsSubscribeRequest.encode({
+            subscriptions: [blockSub],
+            lastKnownBlockIds: [lastKnownBlockId]
+        }).finish()
+    )
+        .then(response => ClientEventsSubscribeResponse.decode(response))
+        .then(decoded => {
+            const status = _.findKey(ClientEventsSubscribeResponse.Status,
+                val => val === decoded.status);
+            if (status !== 'OK') {
+                throw new Error(`Validator responded with status ""${status}""`);
+            }
+        });
+}
+
+/**
+ * Unsubscribe to block-commit delta events
+ * @param {Object} stream1 object to send event unsubscribe message
+ * @return {void}
+ */
+function unsubscribe(stream1) {
+    stream1.send(
+        Message.MessageType.CLIENT_EVENTS_UNSUBSCRIBE_REQUEST,
+        ClientEventsUnsubscribeRequest.encode({
+        }).finish()
+    )
+        .then(response => ClientEventsUnsubscribeResponse.decode(response))
+        .then(decoded => {
+            const status = _.findKey(ClientEventsUnsubscribeResponse.Status,
+                val => val === decoded.status);
+            if (status !== 'OK') {
+                throw new Error(`Validator responded with status ""${status}""`);
+            }
+        });
+}
+/**
+ * Get batch commit event message on block commit
+ * @param {Number} block_num of next block
+ * @param {Number} batchStats Batch status object to update commit status
+ * @return {Promise<object>} returns batch commit status
+ */
+function getBatchEventResponse(block_num, batchStats) {
+    return new Promise(resolve => {
+        while(blockCommitSatus.get(block_num) !== 'pending') {
+        }
+        //remove the block number from map because we are done with this block
+        blockCommitSatus.delete(block_num);
+        batchStats.SetStatusSuccess();",146,2018-10-09 03:10:40,https://api.github.com/repos/hyperledger/caliper/pulls/comments/223549746,https://github.com/hyperledger/caliper/pull/159#discussion_r223549746,Ram-srini
https://github.com/hyperledger/caliper/pull/159,https://github.com/hyperledger/caliper/pull/159,It is success ,3808e8782ff3ec02b8586fcbad02c9ea0e944b6d,2018-10-09 03:11:30,223549822,"@@ -14,6 +14,152 @@ const log = require('../comm/util.js').log;
 let configPath;
 const request = require('request-promise');
 const TxStatus = require('../comm/transaction');
+const _ = require('lodash');
+const { Stream } = require('sawtooth-sdk/messaging/stream');
+const {
+    Message,
+    EventList,
+    EventSubscription,
+    ClientEventsSubscribeRequest,
+    ClientEventsSubscribeResponse,
+    ClientEventsUnsubscribeRequest,
+    ClientEventsUnsubscribeResponse
+} = require('sawtooth-sdk/protobuf');
+
+let lastKnownBlockId=null;
+let stream;
+let blockCommitSatus = new Map();
+let currentBlockNum=0;
+
+/**
+* Get the last recent block id for the block chain
+* @return {Promise<String>} last recent block id
+*/
+async function getCurrentBlockId() {
+    const request = require('request-promise');
+    let config = require(configPath);
+    let restApiUrl = config.sawtooth.network.restapi.url;
+    const blocks = restApiUrl + '/blocks?limit=1';
+    let options = {
+        uri: blocks
+    };
+    return request(options)
+        .then(function(body) {
+            let data = (JSON.parse(body)).data;
+            if (data.length > 0) {
+                currentBlockNum = parseInt(data[0].header.block_num);
+                lastKnownBlockId = data[0].header_signature.toString();
+                return currentBlockNum;
+            }
+        });
+}
+
+/**
+ * Get block data from event message
+ * @param {Object} events message
+ * @return {Promise<object>} The promise for the result of event message
+ */
+async function getBlock(events) {
+    const block = _.chain(events)
+        .find(e => e.eventType === 'sawtooth/block-commit')
+        .get('attributes')
+        .map(a => [a.key, a.value])
+        .fromPairs()
+        .value();
+    return {
+        blockNum: parseInt(block.block_num),
+        blockId: block.block_id.toString(),
+        stateRootHash: block.state_root_hash
+    };
+}
+
+/**
+ * Handle event message to updated lastKnownBlockId for next event subscription
+ * @param {Object} msg event message
+ * @return {void}
+ */
+async function handleEvent(msg) {
+    if (msg.messageType === Message.MessageType.CLIENT_EVENTS) {
+        const events = EventList.decode(msg.content).events;
+        getBlock(events).then(result => {
+            lastKnownBlockId = result.blockId.toString();
+            let blockNum=result.blockNum;
+            //On receiving event with block, update the status of the block to sucess",74,2018-10-09 03:11:30,https://api.github.com/repos/hyperledger/caliper/pulls/comments/223549822,https://github.com/hyperledger/caliper/pull/159#discussion_r223549822,Ram-srini
https://github.com/hyperledger/caliper/pull/159,https://github.com/hyperledger/caliper/pull/159,"Got your point, i am updating batch status to pending when submitted but if multiple batches goes to in single block then we are not updating the status of all batches, that is  question right?",3808e8782ff3ec02b8586fcbad02c9ea0e944b6d,2018-10-09 03:16:33,223550339,"@@ -14,6 +14,152 @@ const log = require('../comm/util.js').log;
 let configPath;
 const request = require('request-promise');
 const TxStatus = require('../comm/transaction');
+const _ = require('lodash');
+const { Stream } = require('sawtooth-sdk/messaging/stream');
+const {
+    Message,
+    EventList,
+    EventSubscription,
+    ClientEventsSubscribeRequest,
+    ClientEventsSubscribeResponse,
+    ClientEventsUnsubscribeRequest,
+    ClientEventsUnsubscribeResponse
+} = require('sawtooth-sdk/protobuf');
+
+let lastKnownBlockId=null;
+let stream;
+let blockCommitSatus = new Map();
+let currentBlockNum=0;
+
+/**
+* Get the last recent block id for the block chain
+* @return {Promise<String>} last recent block id
+*/
+async function getCurrentBlockId() {
+    const request = require('request-promise');
+    let config = require(configPath);
+    let restApiUrl = config.sawtooth.network.restapi.url;
+    const blocks = restApiUrl + '/blocks?limit=1';
+    let options = {
+        uri: blocks
+    };
+    return request(options)
+        .then(function(body) {
+            let data = (JSON.parse(body)).data;
+            if (data.length > 0) {
+                currentBlockNum = parseInt(data[0].header.block_num);
+                lastKnownBlockId = data[0].header_signature.toString();
+                return currentBlockNum;
+            }
+        });
+}
+
+/**
+ * Get block data from event message
+ * @param {Object} events message
+ * @return {Promise<object>} The promise for the result of event message
+ */
+async function getBlock(events) {
+    const block = _.chain(events)
+        .find(e => e.eventType === 'sawtooth/block-commit')
+        .get('attributes')
+        .map(a => [a.key, a.value])
+        .fromPairs()
+        .value();
+    return {
+        blockNum: parseInt(block.block_num),
+        blockId: block.block_id.toString(),
+        stateRootHash: block.state_root_hash
+    };
+}
+
+/**
+ * Handle event message to updated lastKnownBlockId for next event subscription
+ * @param {Object} msg event message
+ * @return {void}
+ */
+async function handleEvent(msg) {
+    if (msg.messageType === Message.MessageType.CLIENT_EVENTS) {
+        const events = EventList.decode(msg.content).events;
+        getBlock(events).then(result => {
+            lastKnownBlockId = result.blockId.toString();
+            let blockNum=result.blockNum;
+            //On receiving event with block, update the status of the block to sucess
+            blockCommitSatus.set(blockNum, 'success');
+        });
+    } else {
+        log('Warn: Received message of unknown type:', msg.messageType);
+    }
+}
+
+/**
+ * Subscribe to block-commit delta events
+ * @param {Object} stream object to send event subscribe message
+ * @return {void}
+ */
+async function subscribe(stream) {
+    //Subscribe to block-commit delta event
+    const blockSub = EventSubscription.create({
+        eventType: 'sawtooth/block-commit'
+    });
+
+    if(lastKnownBlockId === null) {
+        await getCurrentBlockId().then(() => {
+        });
+    }
+    stream.send(
+        Message.MessageType.CLIENT_EVENTS_SUBSCRIBE_REQUEST,
+        ClientEventsSubscribeRequest.encode({
+            subscriptions: [blockSub],
+            lastKnownBlockIds: [lastKnownBlockId]
+        }).finish()
+    )
+        .then(response => ClientEventsSubscribeResponse.decode(response))
+        .then(decoded => {
+            const status = _.findKey(ClientEventsSubscribeResponse.Status,
+                val => val === decoded.status);
+            if (status !== 'OK') {
+                throw new Error(`Validator responded with status ""${status}""`);
+            }
+        });
+}
+
+/**
+ * Unsubscribe to block-commit delta events
+ * @param {Object} stream1 object to send event unsubscribe message
+ * @return {void}
+ */
+function unsubscribe(stream1) {
+    stream1.send(
+        Message.MessageType.CLIENT_EVENTS_UNSUBSCRIBE_REQUEST,
+        ClientEventsUnsubscribeRequest.encode({
+        }).finish()
+    )
+        .then(response => ClientEventsUnsubscribeResponse.decode(response))
+        .then(decoded => {
+            const status = _.findKey(ClientEventsUnsubscribeResponse.Status,
+                val => val === decoded.status);
+            if (status !== 'OK') {
+                throw new Error(`Validator responded with status ""${status}""`);
+            }
+        });
+}
+/**
+ * Get batch commit event message on block commit
+ * @param {Number} block_num of next block
+ * @param {Number} batchStats Batch status object to update commit status
+ * @return {Promise<object>} returns batch commit status
+ */
+function getBatchEventResponse(block_num, batchStats) {
+    return new Promise(resolve => {
+        while(blockCommitSatus.get(block_num) !== 'pending') {
+        }
+        //remove the block number from map because we are done with this block
+        blockCommitSatus.delete(block_num);
+        batchStats.SetStatusSuccess();",146,2018-10-09 03:16:34,https://api.github.com/repos/hyperledger/caliper/pulls/comments/223550339,https://github.com/hyperledger/caliper/pull/159#discussion_r223550339,Ram-srini
https://github.com/hyperledger/caliper/pull/159,https://github.com/hyperledger/caliper/pull/159,"No, I mean if multiple batches(a, b, c, d, e, f) submitted once, the next block is 2, and they couldn't be total added to the next block(2), these batches (a, b, c) ) maybe added to the next block(2), and other batches(d, e, f) maybe added to the next next block(3). When we get block(2) commit event, we are setting all of batches(a, b, c, d, e, f) status to success, but the truth is that only (a, b, c) batches status is success, and only we get block(3) commit event, batches(d, e, f) status is success. Am I right?",3808e8782ff3ec02b8586fcbad02c9ea0e944b6d,2018-10-09 11:25:41,223660425,"@@ -14,6 +14,152 @@ const log = require('../comm/util.js').log;
 let configPath;
 const request = require('request-promise');
 const TxStatus = require('../comm/transaction');
+const _ = require('lodash');
+const { Stream } = require('sawtooth-sdk/messaging/stream');
+const {
+    Message,
+    EventList,
+    EventSubscription,
+    ClientEventsSubscribeRequest,
+    ClientEventsSubscribeResponse,
+    ClientEventsUnsubscribeRequest,
+    ClientEventsUnsubscribeResponse
+} = require('sawtooth-sdk/protobuf');
+
+let lastKnownBlockId=null;
+let stream;
+let blockCommitSatus = new Map();
+let currentBlockNum=0;
+
+/**
+* Get the last recent block id for the block chain
+* @return {Promise<String>} last recent block id
+*/
+async function getCurrentBlockId() {
+    const request = require('request-promise');
+    let config = require(configPath);
+    let restApiUrl = config.sawtooth.network.restapi.url;
+    const blocks = restApiUrl + '/blocks?limit=1';
+    let options = {
+        uri: blocks
+    };
+    return request(options)
+        .then(function(body) {
+            let data = (JSON.parse(body)).data;
+            if (data.length > 0) {
+                currentBlockNum = parseInt(data[0].header.block_num);
+                lastKnownBlockId = data[0].header_signature.toString();
+                return currentBlockNum;
+            }
+        });
+}
+
+/**
+ * Get block data from event message
+ * @param {Object} events message
+ * @return {Promise<object>} The promise for the result of event message
+ */
+async function getBlock(events) {
+    const block = _.chain(events)
+        .find(e => e.eventType === 'sawtooth/block-commit')
+        .get('attributes')
+        .map(a => [a.key, a.value])
+        .fromPairs()
+        .value();
+    return {
+        blockNum: parseInt(block.block_num),
+        blockId: block.block_id.toString(),
+        stateRootHash: block.state_root_hash
+    };
+}
+
+/**
+ * Handle event message to updated lastKnownBlockId for next event subscription
+ * @param {Object} msg event message
+ * @return {void}
+ */
+async function handleEvent(msg) {
+    if (msg.messageType === Message.MessageType.CLIENT_EVENTS) {
+        const events = EventList.decode(msg.content).events;
+        getBlock(events).then(result => {
+            lastKnownBlockId = result.blockId.toString();
+            let blockNum=result.blockNum;
+            //On receiving event with block, update the status of the block to sucess
+            blockCommitSatus.set(blockNum, 'success');
+        });
+    } else {
+        log('Warn: Received message of unknown type:', msg.messageType);
+    }
+}
+
+/**
+ * Subscribe to block-commit delta events
+ * @param {Object} stream object to send event subscribe message
+ * @return {void}
+ */
+async function subscribe(stream) {
+    //Subscribe to block-commit delta event
+    const blockSub = EventSubscription.create({
+        eventType: 'sawtooth/block-commit'
+    });
+
+    if(lastKnownBlockId === null) {
+        await getCurrentBlockId().then(() => {
+        });
+    }
+    stream.send(
+        Message.MessageType.CLIENT_EVENTS_SUBSCRIBE_REQUEST,
+        ClientEventsSubscribeRequest.encode({
+            subscriptions: [blockSub],
+            lastKnownBlockIds: [lastKnownBlockId]
+        }).finish()
+    )
+        .then(response => ClientEventsSubscribeResponse.decode(response))
+        .then(decoded => {
+            const status = _.findKey(ClientEventsSubscribeResponse.Status,
+                val => val === decoded.status);
+            if (status !== 'OK') {
+                throw new Error(`Validator responded with status ""${status}""`);
+            }
+        });
+}
+
+/**
+ * Unsubscribe to block-commit delta events
+ * @param {Object} stream1 object to send event unsubscribe message
+ * @return {void}
+ */
+function unsubscribe(stream1) {
+    stream1.send(
+        Message.MessageType.CLIENT_EVENTS_UNSUBSCRIBE_REQUEST,
+        ClientEventsUnsubscribeRequest.encode({
+        }).finish()
+    )
+        .then(response => ClientEventsUnsubscribeResponse.decode(response))
+        .then(decoded => {
+            const status = _.findKey(ClientEventsUnsubscribeResponse.Status,
+                val => val === decoded.status);
+            if (status !== 'OK') {
+                throw new Error(`Validator responded with status ""${status}""`);
+            }
+        });
+}
+/**
+ * Get batch commit event message on block commit
+ * @param {Number} block_num of next block
+ * @param {Number} batchStats Batch status object to update commit status
+ * @return {Promise<object>} returns batch commit status
+ */
+function getBatchEventResponse(block_num, batchStats) {
+    return new Promise(resolve => {
+        while(blockCommitSatus.get(block_num) !== 'pending') {
+        }
+        //remove the block number from map because we are done with this block
+        blockCommitSatus.delete(block_num);
+        batchStats.SetStatusSuccess();",146,2018-10-09 11:25:41,https://api.github.com/repos/hyperledger/caliper/pulls/comments/223660425,https://github.com/hyperledger/caliper/pull/159#discussion_r223660425,feihujiang
https://github.com/hyperledger/caliper/pull/159,https://github.com/hyperledger/caliper/pull/159,Yes that's correct. It should be fine because block consists of batches and each batch contain multiple transactions and block is ultimate entity getting added to block chain.,3808e8782ff3ec02b8586fcbad02c9ea0e944b6d,2018-10-09 12:14:06,223673922,"@@ -14,6 +14,152 @@ const log = require('../comm/util.js').log;
 let configPath;
 const request = require('request-promise');
 const TxStatus = require('../comm/transaction');
+const _ = require('lodash');
+const { Stream } = require('sawtooth-sdk/messaging/stream');
+const {
+    Message,
+    EventList,
+    EventSubscription,
+    ClientEventsSubscribeRequest,
+    ClientEventsSubscribeResponse,
+    ClientEventsUnsubscribeRequest,
+    ClientEventsUnsubscribeResponse
+} = require('sawtooth-sdk/protobuf');
+
+let lastKnownBlockId=null;
+let stream;
+let blockCommitSatus = new Map();
+let currentBlockNum=0;
+
+/**
+* Get the last recent block id for the block chain
+* @return {Promise<String>} last recent block id
+*/
+async function getCurrentBlockId() {
+    const request = require('request-promise');
+    let config = require(configPath);
+    let restApiUrl = config.sawtooth.network.restapi.url;
+    const blocks = restApiUrl + '/blocks?limit=1';
+    let options = {
+        uri: blocks
+    };
+    return request(options)
+        .then(function(body) {
+            let data = (JSON.parse(body)).data;
+            if (data.length > 0) {
+                currentBlockNum = parseInt(data[0].header.block_num);
+                lastKnownBlockId = data[0].header_signature.toString();
+                return currentBlockNum;
+            }
+        });
+}
+
+/**
+ * Get block data from event message
+ * @param {Object} events message
+ * @return {Promise<object>} The promise for the result of event message
+ */
+async function getBlock(events) {
+    const block = _.chain(events)
+        .find(e => e.eventType === 'sawtooth/block-commit')
+        .get('attributes')
+        .map(a => [a.key, a.value])
+        .fromPairs()
+        .value();
+    return {
+        blockNum: parseInt(block.block_num),
+        blockId: block.block_id.toString(),
+        stateRootHash: block.state_root_hash
+    };
+}
+
+/**
+ * Handle event message to updated lastKnownBlockId for next event subscription
+ * @param {Object} msg event message
+ * @return {void}
+ */
+async function handleEvent(msg) {
+    if (msg.messageType === Message.MessageType.CLIENT_EVENTS) {
+        const events = EventList.decode(msg.content).events;
+        getBlock(events).then(result => {
+            lastKnownBlockId = result.blockId.toString();
+            let blockNum=result.blockNum;
+            //On receiving event with block, update the status of the block to sucess
+            blockCommitSatus.set(blockNum, 'success');
+        });
+    } else {
+        log('Warn: Received message of unknown type:', msg.messageType);
+    }
+}
+
+/**
+ * Subscribe to block-commit delta events
+ * @param {Object} stream object to send event subscribe message
+ * @return {void}
+ */
+async function subscribe(stream) {
+    //Subscribe to block-commit delta event
+    const blockSub = EventSubscription.create({
+        eventType: 'sawtooth/block-commit'
+    });
+
+    if(lastKnownBlockId === null) {
+        await getCurrentBlockId().then(() => {
+        });
+    }
+    stream.send(
+        Message.MessageType.CLIENT_EVENTS_SUBSCRIBE_REQUEST,
+        ClientEventsSubscribeRequest.encode({
+            subscriptions: [blockSub],
+            lastKnownBlockIds: [lastKnownBlockId]
+        }).finish()
+    )
+        .then(response => ClientEventsSubscribeResponse.decode(response))
+        .then(decoded => {
+            const status = _.findKey(ClientEventsSubscribeResponse.Status,
+                val => val === decoded.status);
+            if (status !== 'OK') {
+                throw new Error(`Validator responded with status ""${status}""`);
+            }
+        });
+}
+
+/**
+ * Unsubscribe to block-commit delta events
+ * @param {Object} stream1 object to send event unsubscribe message
+ * @return {void}
+ */
+function unsubscribe(stream1) {
+    stream1.send(
+        Message.MessageType.CLIENT_EVENTS_UNSUBSCRIBE_REQUEST,
+        ClientEventsUnsubscribeRequest.encode({
+        }).finish()
+    )
+        .then(response => ClientEventsUnsubscribeResponse.decode(response))
+        .then(decoded => {
+            const status = _.findKey(ClientEventsUnsubscribeResponse.Status,
+                val => val === decoded.status);
+            if (status !== 'OK') {
+                throw new Error(`Validator responded with status ""${status}""`);
+            }
+        });
+}
+/**
+ * Get batch commit event message on block commit
+ * @param {Number} block_num of next block
+ * @param {Number} batchStats Batch status object to update commit status
+ * @return {Promise<object>} returns batch commit status
+ */
+function getBatchEventResponse(block_num, batchStats) {
+    return new Promise(resolve => {
+        while(blockCommitSatus.get(block_num) !== 'pending') {
+        }
+        //remove the block number from map because we are done with this block
+        blockCommitSatus.delete(block_num);
+        batchStats.SetStatusSuccess();",146,2018-10-09 12:14:06,https://api.github.com/repos/hyperledger/caliper/pulls/comments/223673922,https://github.com/hyperledger/caliper/pull/159#discussion_r223673922,Ram-srini
https://github.com/hyperledger/caliper/pull/159,https://github.com/hyperledger/caliper/pull/159,"As the codes, when we get block(2) commit event, we are setting all of batches(a, b, c, d, e, f) status to success, but I think this is not correct.  The truth is that only (a, b, c) batches status is success. But the codes are setting all of the batches' status to success.",3808e8782ff3ec02b8586fcbad02c9ea0e944b6d,2018-10-09 12:31:31,223679273,"@@ -14,6 +14,152 @@ const log = require('../comm/util.js').log;
 let configPath;
 const request = require('request-promise');
 const TxStatus = require('../comm/transaction');
+const _ = require('lodash');
+const { Stream } = require('sawtooth-sdk/messaging/stream');
+const {
+    Message,
+    EventList,
+    EventSubscription,
+    ClientEventsSubscribeRequest,
+    ClientEventsSubscribeResponse,
+    ClientEventsUnsubscribeRequest,
+    ClientEventsUnsubscribeResponse
+} = require('sawtooth-sdk/protobuf');
+
+let lastKnownBlockId=null;
+let stream;
+let blockCommitSatus = new Map();
+let currentBlockNum=0;
+
+/**
+* Get the last recent block id for the block chain
+* @return {Promise<String>} last recent block id
+*/
+async function getCurrentBlockId() {
+    const request = require('request-promise');
+    let config = require(configPath);
+    let restApiUrl = config.sawtooth.network.restapi.url;
+    const blocks = restApiUrl + '/blocks?limit=1';
+    let options = {
+        uri: blocks
+    };
+    return request(options)
+        .then(function(body) {
+            let data = (JSON.parse(body)).data;
+            if (data.length > 0) {
+                currentBlockNum = parseInt(data[0].header.block_num);
+                lastKnownBlockId = data[0].header_signature.toString();
+                return currentBlockNum;
+            }
+        });
+}
+
+/**
+ * Get block data from event message
+ * @param {Object} events message
+ * @return {Promise<object>} The promise for the result of event message
+ */
+async function getBlock(events) {
+    const block = _.chain(events)
+        .find(e => e.eventType === 'sawtooth/block-commit')
+        .get('attributes')
+        .map(a => [a.key, a.value])
+        .fromPairs()
+        .value();
+    return {
+        blockNum: parseInt(block.block_num),
+        blockId: block.block_id.toString(),
+        stateRootHash: block.state_root_hash
+    };
+}
+
+/**
+ * Handle event message to updated lastKnownBlockId for next event subscription
+ * @param {Object} msg event message
+ * @return {void}
+ */
+async function handleEvent(msg) {
+    if (msg.messageType === Message.MessageType.CLIENT_EVENTS) {
+        const events = EventList.decode(msg.content).events;
+        getBlock(events).then(result => {
+            lastKnownBlockId = result.blockId.toString();
+            let blockNum=result.blockNum;
+            //On receiving event with block, update the status of the block to sucess
+            blockCommitSatus.set(blockNum, 'success');
+        });
+    } else {
+        log('Warn: Received message of unknown type:', msg.messageType);
+    }
+}
+
+/**
+ * Subscribe to block-commit delta events
+ * @param {Object} stream object to send event subscribe message
+ * @return {void}
+ */
+async function subscribe(stream) {
+    //Subscribe to block-commit delta event
+    const blockSub = EventSubscription.create({
+        eventType: 'sawtooth/block-commit'
+    });
+
+    if(lastKnownBlockId === null) {
+        await getCurrentBlockId().then(() => {
+        });
+    }
+    stream.send(
+        Message.MessageType.CLIENT_EVENTS_SUBSCRIBE_REQUEST,
+        ClientEventsSubscribeRequest.encode({
+            subscriptions: [blockSub],
+            lastKnownBlockIds: [lastKnownBlockId]
+        }).finish()
+    )
+        .then(response => ClientEventsSubscribeResponse.decode(response))
+        .then(decoded => {
+            const status = _.findKey(ClientEventsSubscribeResponse.Status,
+                val => val === decoded.status);
+            if (status !== 'OK') {
+                throw new Error(`Validator responded with status ""${status}""`);
+            }
+        });
+}
+
+/**
+ * Unsubscribe to block-commit delta events
+ * @param {Object} stream1 object to send event unsubscribe message
+ * @return {void}
+ */
+function unsubscribe(stream1) {
+    stream1.send(
+        Message.MessageType.CLIENT_EVENTS_UNSUBSCRIBE_REQUEST,
+        ClientEventsUnsubscribeRequest.encode({
+        }).finish()
+    )
+        .then(response => ClientEventsUnsubscribeResponse.decode(response))
+        .then(decoded => {
+            const status = _.findKey(ClientEventsUnsubscribeResponse.Status,
+                val => val === decoded.status);
+            if (status !== 'OK') {
+                throw new Error(`Validator responded with status ""${status}""`);
+            }
+        });
+}
+/**
+ * Get batch commit event message on block commit
+ * @param {Number} block_num of next block
+ * @param {Number} batchStats Batch status object to update commit status
+ * @return {Promise<object>} returns batch commit status
+ */
+function getBatchEventResponse(block_num, batchStats) {
+    return new Promise(resolve => {
+        while(blockCommitSatus.get(block_num) !== 'pending') {
+        }
+        //remove the block number from map because we are done with this block
+        blockCommitSatus.delete(block_num);
+        batchStats.SetStatusSuccess();",146,2018-10-09 12:31:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/223679273,https://github.com/hyperledger/caliper/pull/159#discussion_r223679273,feihujiang
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,We should specify a supporting list to tell user which blockchains support this flag now.,20a7141bd4341bae6b03f595254264386590d9c2,2018-07-25 06:40:05,204995689,"@@ -66,8 +66,26 @@ Run `npm install` in caliper folder to install dependencies locally
 
    Please see the plugin [documentation](./docs/Composer.md) for more details on using the Composer performance plugin, and developing your own tests.
 
+### Install Apache Kafka MQ (optional feature)
+You can also configure the tool to run with Apache Kafka. Set `WITH_MQ` flag to true in the config file for each benchmark and run through the following installation for Kafka.",5,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/204995689,https://github.com/hyperledger/caliper/pull/124#discussion_r204995689,haojun
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,It's optional,20a7141bd4341bae6b03f595254264386590d9c2,2018-07-25 06:40:25,204995742,"@@ -66,8 +66,26 @@ Run `npm install` in caliper folder to install dependencies locally
 
    Please see the plugin [documentation](./docs/Composer.md) for more details on using the Composer performance plugin, and developing your own tests.
 
+### Install Apache Kafka MQ (optional feature)
+You can also configure the tool to run with Apache Kafka. Set `WITH_MQ` flag to true in the config file for each benchmark and run through the following installation for Kafka.
+  
+#### Pre-requisites for Kafka MQ
+
+  * Following tools are required to be installed.
+      *   Docker version 17.03.0-ce or greater is required (tested with with 18.02.0-ce)
+      *   Docker-compose version 1.8 or greater is required (tested with with 1.19.0)
+
+  * Clone the file docker-compose-kafka.yaml present in `/kafka-setup` directory on the machine where you want to set up the Kafka cluster.
+  * Open the file docker-compose-kafka.yaml and change the `KAFKA_ADVERTISED_HOST_NAME` environment variable to the machine IP address where Kafka will be running. 
+  * Run `docker-compose -f docker-compose-kafka.yaml up -d`.
+
 ## Run benchmark
 
+ ### Note
+  1) Before running the fabric related benchmarks, make sure Apache kafka MQ is set up correctly.",24,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/204995742,https://github.com/hyperledger/caliper/pull/124#discussion_r204995742,haojun
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,And we should add description of the flag in architecture doc,20a7141bd4341bae6b03f595254264386590d9c2,2018-07-25 06:42:54,204996156,"@@ -66,8 +66,26 @@ Run `npm install` in caliper folder to install dependencies locally
 
    Please see the plugin [documentation](./docs/Composer.md) for more details on using the Composer performance plugin, and developing your own tests.
 
+### Install Apache Kafka MQ (optional feature)
+You can also configure the tool to run with Apache Kafka. Set `WITH_MQ` flag to true in the config file for each benchmark and run through the following installation for Kafka.",5,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/204996156,https://github.com/hyperledger/caliper/pull/124#discussion_r204996156,haojun
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,"1. It would be better to define a new file such as config_with_mq.json to demo the new flag, instead of changing the old one.
2. What happens if the flag is not setting? The default behavior should be as with_mq=false, right? ",20a7141bd4341bae6b03f595254264386590d9c2,2018-07-25 06:45:03,204996497,"@@ -8,23 +8,22 @@
     ""end"" : ""docker-compose -f network/fabric/simplenetwork/docker-compose.yaml down;docker rm $(docker ps -aq)""
   },
   ""test"": {
-    ""name"": ""simple"",
-    ""description"" : ""This is an example benchmark for caliper, to test the backend DLT's performance with simple account opening & querying transactions"",
+    ""WITH_MQ"": true,",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/204996497,https://github.com/hyperledger/caliper/pull/124#discussion_r204996497,haojun
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,"Those packages are fabric related, so please don't specify them in the common package.json. Some people may not want to test fabric",20a7141bd4341bae6b03f595254264386590d9c2,2018-07-25 06:50:51,204997732,"@@ -23,12 +23,17 @@
     ""cbor"": ""^3.0.3"",
     ""commander"": ""^2.11.0"",
     ""dockerode"": ""^2.5.0"",
+    ""fabric-ca-client"": ""^1.1.0"",",4,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/204997732,https://github.com/hyperledger/caliper/pull/124#discussion_r204997732,haojun
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,It seems this file does not need to be updated,20a7141bd4341bae6b03f595254264386590d9c2,2018-07-25 06:56:21,204999443,"@@ -97,12 +97,15 @@ function launchClient(updates, results) {
  * @return {Promise} promise object
  */
 function startTest(number, message, clientArgs, updates, results) {
+    ",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/204999443,https://github.com/hyperledger/caliper/pull/124#discussion_r204999443,haojun
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,It seem this file doesn't need to be updated,20a7141bd4341bae6b03f595254264386590d9c2,2018-07-25 06:56:48,204999587,"@@ -144,6 +144,7 @@ class Client{
         switch(this.type) {",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/204999587,https://github.com/hyperledger/caliper/pull/124#discussion_r204999587,haojun
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,"1. I think it's not proper to use any test case specific informations in a general benchmark module to do some patches. The tester can use any label name and the semantic is unknowable to a general benchmark module.
2. Is it necessary to define a new demo file? Can we just use the old update mechanism?",20a7141bd4341bae6b03f595254264386590d9c2,2018-07-27 01:39:14,205647496,"@@ -0,0 +1,305 @@
+/**
+* Copyright 2017 HUAWEI. All Rights Reserved.
+*
+* SPDX-License-Identifier: Apache-2.0
+*
+* @file Implementation of the temporary demo
+*/
+
+
+'use strict'
+
+/* global variables */
+const kafka = require('kafka-node');
+const listener_config = require(""../../../listener/listener-config.json"")
+var cb;
+var testLabel;
+var totalTxnsPerRound = 0;
+var cachedEvents;
+var confirmedTransactions;
+var totalSubmitted = 0;
+var totalSucc = 0;
+var totalFail = 0;
+var path = require('path');
+const bc   = require('../../comm/blockchain.js');
+const blockchain = new bc(path.join(__dirname, '../../../', 'benchmark/simple/fabric'));
+var demoFile = path.join(__dirname, '../output/demoOptional.json');
+var demoInterval = 1;   // interval length(s)
+var demoXLen = 60;     // default x axis length
+var demoData;
+var demoInterObj = null;
+var demoSessionID = 0;
+const TxStatus = require('../../comm/transaction.js');
+
+function demoInit() {
+    var fs = require('fs');
+    demoData =  {
+        throughput: {
+            x: [],
+            submitted: [0],
+            succeeded: [0],
+            failed: [0]
+        },
+        latency: {
+            x: [],
+            max: [0],
+            min: [0],
+            avg: [0]
+        },
+        summary: {
+            txSub: 0,
+            txSucc: 0,
+            txFail: 0,
+            round: 0,
+        },
+        report: ''
+    }
+    for(let i = 0 ; i < demoXLen ; i++) {
+        demoData.throughput.x.push(i * demoInterval);
+        demoData.latency.x.push(i * demoInterval);
+    }
+    fs.writeFileSync(demoFile,  JSON.stringify(demoData));
+}
+module.exports.init = demoInit;
+
+// TODO: need to limit the maximum length for X-Axis
+function demoRefreshX() {
+
+    var len = demoData.throughput.submitted.length;
+    while(demoData.throughput.x.length < len) {
+        if(demoData.throughput.x.length === 0) {
+            demoData.throughput.x[0] = 0;
+        }
+        else {
+            let last = demoData.throughput.x[demoData.throughput.x.length - 1];
+            demoData.throughput.x.push(last + demoInterval);
+        }
+    }
+    len = demoData.latency.max.length;
+    while(demoData.latency.x.length < len) {
+        if(demoData.latency.x.length === 0) {
+            demoData.latency.x[0] = 0;
+        }
+        else {
+            let last = demoData.latency.x[demoData.latency.x.length - 1];
+            demoData.latency.x.push(last + demoInterval);
+        }
+    }
+}
+
+function demoAddThroughput(sub, suc, fail) {
+    demoData.throughput.submitted.push(sub/demoInterval);
+    demoData.throughput.succeeded.push(suc/demoInterval);
+    demoData.throughput.failed.push(fail/demoInterval);
+    demoData.summary.txSub  = sub;
+    demoData.summary.txSucc = suc;
+    demoData.summary.txFail = fail;
+}
+
+function demoAddLatency(max, min, avg) {
+    demoData.latency.max.push(max);
+    demoData.latency.min.push(min);
+    demoData.latency.avg.push(avg);
+}
+
+function demoRefreshData(updates, label) {
+
+    for (let i = 0; i < updates.length; i++) {
+        var sub = updates[i].submitted
+        totalSubmitted += sub
+        var submitted_transactions = updates[i].committed
+    
+        for (let j =0; j < submitted_transactions.length; j++) {
+            var transactionStatus = submitted_transactions[j].status
+            var TransactionStatus = new TxStatus(transactionStatus.id, transactionStatus.status, transactionStatus.time_create, transactionStatus.time_final, 
+                transactionStatus.result, transactionStatus.verified, transactionStatus.flags, transactionStatus.error_messages);
+                
+            if (cachedEvents.get(TransactionStatus.GetID()) == undefined) {
+                cachedEvents.set(TransactionStatus.GetID(), TransactionStatus)
+                if (label == 'query') {",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/205647496,https://github.com/hyperledger/caliper/pull/124#discussion_r205647496,haojun
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,"if the flag is not set, the tool will default to non MQ mode.",20a7141bd4341bae6b03f595254264386590d9c2,2018-07-27 04:58:51,205668289,"@@ -8,23 +8,22 @@
     ""end"" : ""docker-compose -f network/fabric/simplenetwork/docker-compose.yaml down;docker rm $(docker ps -aq)""
   },
   ""test"": {
-    ""name"": ""simple"",
-    ""description"" : ""This is an example benchmark for caliper, to test the backend DLT's performance with simple account opening & querying transactions"",
+    ""WITH_MQ"": true,",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/205668289,https://github.com/hyperledger/caliper/pull/124#discussion_r205668289,nitesh7sid
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,agree. I will make sure they are removed from the package.json file,20a7141bd4341bae6b03f595254264386590d9c2,2018-07-27 05:07:00,205669035,"@@ -23,12 +23,17 @@
     ""cbor"": ""^3.0.3"",
     ""commander"": ""^2.11.0"",
     ""dockerode"": ""^2.5.0"",
+    ""fabric-ca-client"": ""^1.1.0"",",4,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/205669035,https://github.com/hyperledger/caliper/pull/124#discussion_r205669035,nitesh7sid
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,"Since Kafka mode is not necessary for all kinds of the tests,  these requirements may need to be moved into the related function. ",20a7141bd4341bae6b03f595254264386590d9c2,2018-11-19 09:48:12,234551508,"@@ -9,7 +10,80 @@
 'use strict';
 const logger = require('../util.js').getLogger('client-util.js');
 let processes  = {}; // {pid:{obj, promise}}
+let txUpdateTime = 1000;
+const kafka = require('kafka-node');
+const listener_config = require('../../listener/listener-config.json');",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/234551508,https://github.com/hyperledger/caliper/pull/124#discussion_r234551508,panyu4
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,"please rebase and use commLogger.warn('WARNING: timeout is too small, default value is used instead')  to record the log information. For info, commLogger.info('') can be used and commLogger.error('') is used for errors.",20a7141bd4341bae6b03f595254264386590d9c2,2018-11-20 08:06:46,234900866,"@@ -643,52 +644,53 @@ async function invokebycontext(context, id, version, args, timeout){
             proposalResponses: proposalResponses,
             proposal: proposal,
         };
-
-        let newTimeout = timeout * 1000 - (Date.now() - startTime);
-        if(newTimeout < 10000) {
-            commLogger.warn('WARNING: timeout is too small, default value is used instead');
-            newTimeout = 10000;
-        }
-
         const eventPromises = [];
-        eventHubs.forEach((eh) => {
-            eventPromises.push(new Promise((resolve, reject) => {
-                let handle = setTimeout(() => reject(new Error('Timeout')), newTimeout);
-
-                eh.registerTxEvent(txId,
-                    (tx, code) => {
-                        clearTimeout(handle);
-                        eh.unregisterTxEvent(txId);
+        if (! withMQ) {
 
-                        // either explicit invalid event or valid event, verified in both cases by at least one peer
-                        invokeStatus.SetVerification(true);
-                        if (code !== 'VALID') {
-                            let err = new Error('Invalid transaction: ' + code);
-                            errFlag |= TxErrorEnum.BadEventNotificationError;
+            let newTimeout = timeout * 1000 - (Date.now() - startTime);
+            if(newTimeout < 10000) {
+                commUtils.log('WARNING: timeout is too small, default value is used instead');",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/234900866,https://github.com/hyperledger/caliper/pull/124#discussion_r234900866,panyu4
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,commUtils.log should be replaced by commLogger.error,20a7141bd4341bae6b03f595254264386590d9c2,2018-11-20 08:07:52,234901131,"@@ -709,17 +711,19 @@ async function invokebycontext(context, id, version, args, timeout){
             invokeStatus.SetVerification(true);
             throw err;
         }
-
-        await Promise.all(eventPromises);
-        // if the Tx is not verified at this point, then every eventhub connection failed (with resolve)
-        // so mark it failed but leave it not verified
-        if (!invokeStatus.IsVerified()) {
-            invokeStatus.SetStatusFail();
-            commLogger.error('Failed to complete transaction [' + txId.substring(0, 5) + '...]: every eventhub connection closed');
-        } else {
-            invokeStatus.SetStatusSuccess();
+        if (!withMQ) {
+            await Promise.all(eventPromises);
+            // if the Tx is not verified at this point, then every eventhub connection failed (with resolve)
+            // so mark it failed but leave it not verified
+            if (!invokeStatus.IsVerified()) {
+                invokeStatus.SetStatusFail();
+                commUtils.log('Failed to complete transaction [' + txId.substring(0, 5) + '...]: every eventhub connection closed');",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/234901131,https://github.com/hyperledger/caliper/pull/124#discussion_r234901131,panyu4
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,please use Util.getLogger() to log the information,20a7141bd4341bae6b03f595254264386590d9c2,2018-11-20 08:09:01,234901349,"@@ -0,0 +1,70 @@
+/**
+* Copyright Persistent Systems 2018. All Rights Reserved.
+*
+* SPDX-License-Identifier: Apache-2.0
+*@file Implementation for block listener adapter.
+*/
+
+'use strict';
+const kafka = require('kafka-node');
+const Util = require('../comm/util');
+const log = Util.log;",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/234901349,https://github.com/hyperledger/caliper/pull/124#discussion_r234901349,panyu4
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,log should be changed into util.getlogger,20a7141bd4341bae6b03f595254264386590d9c2,2018-11-20 08:09:56,234901552,"@@ -0,0 +1,70 @@
+/**
+* Copyright Persistent Systems 2018. All Rights Reserved.
+*
+* SPDX-License-Identifier: Apache-2.0
+*@file Implementation for block listener adapter.
+*/
+
+'use strict';
+const kafka = require('kafka-node');
+const Util = require('../comm/util');
+const log = Util.log;
+let HighLevelProducer = kafka.HighLevelProducer;
+
+let KafkaAdapter = class {
+    /**
+     * Constructor
+     * @param {String} configPath path of the listener configuration file
+     *
+     */
+    constructor(configPath) {
+        this.listener_config = require('./listener-config.json');
+        let zk_url = this.listener_config.zk_url;
+        this.client_kafka = new kafka.Client(zk_url, this.listener_config.topic, { sessionTimeout: 300000, spinDelay: 100, retries: 2 });
+        this.producer = new HighLevelProducer(this.client_kafka, { requireAcks: -1 });
+        let args = require(configPath).blockchain;
+        this.bcObj = null;
+        this.bcType = args.type;
+
+        switch (this.bcType) {
+        case 'fabric': {
+            const FabricListener = require('./listener-fabric.js');
+            this.bcObj = new FabricListener(this.listener_config, this.client_kafka, this.producer, configPath);
+            break;
+        }
+        default:
+            throw new Error('Unknown blockchain type, ' + this.bcType);
+        }
+    }
+
+    /**
+     * Create Kafka topic
+     */
+    createTopic() {
+        let self = this;
+        this.producer.on('ready', function () {
+            self.producer.createTopics([self.listener_config.topic], false, function (err, data) {
+                if (err) {
+                    log('Error creating Topic', err);",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/234901552,https://github.com/hyperledger/caliper/pull/124#discussion_r234901552,panyu4
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,replace Util.log with Util.getLogger() ,20a7141bd4341bae6b03f595254264386590d9c2,2018-11-20 08:11:09,234901808,"@@ -0,0 +1,112 @@
+/**
+* Copyright Persistent Systems 2018. All Rights Reserved.
+*
+* SPDX-License-Identifier: Apache-2.0
+@file Implementation for Fabric Event listener to connect to the peer Event Hub and recieve blocks.
+*/
+
+'use strict';
+
+const Client = require('fabric-client');
+const fs = require('fs');
+const path = require('path');
+let testUtil = require('../fabric/util.js');
+const Util = require('../comm/util');
+const log = Util.log;",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/234901808,https://github.com/hyperledger/caliper/pull/124#discussion_r234901808,panyu4
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,log should be replaced with Util.getLogger(),20a7141bd4341bae6b03f595254264386590d9c2,2018-11-20 08:12:14,234902061,"@@ -0,0 +1,112 @@
+/**
+* Copyright Persistent Systems 2018. All Rights Reserved.
+*
+* SPDX-License-Identifier: Apache-2.0
+@file Implementation for Fabric Event listener to connect to the peer Event Hub and recieve blocks.
+*/
+
+'use strict';
+
+const Client = require('fabric-client');
+const fs = require('fs');
+const path = require('path');
+let testUtil = require('../fabric/util.js');
+const Util = require('../comm/util');
+const log = Util.log;
+const rootPath = '../../';
+
+
+/**
+ * Fabric Listener class, define operations to recieve block events from Fabric Peer and publish into kafka
+ */
+class FabricListener {
+    /**
+     * Constructor
+     * @param {String} listener_config path of the listener configuration file
+     * @param {Client} client_kafka, Kafka client
+     * @param {Producer} producer, Kafka HighLevelProducer
+     * @param {String} configPath path of the blockchain configuration file
+     */
+    constructor(listener_config, client_kafka, producer, configPath) {
+
+        this.testUtil = testUtil;
+        let args = require(configPath).blockchain;
+        this.testUtil.init(path.join(__dirname, rootPath, args.config));
+        this.peerEventObject = {};
+        this.peerEventObject.eventUrl = listener_config.peerEventUrl;
+        let tlsCert = fs.readFileSync(path.join(__dirname, rootPath, listener_config.peerEventTlscaPath));
+        this.peerEventObject.eventTlsca = tlsCert;
+        this.peerEventObject.eventServerHostName =listener_config.peerEventHostnameOverride;
+        this.peerEventObject.org = listener_config.peerOrg;
+        this.client = new Client();
+        this.client_kafka = client_kafka;
+        this.producer = producer;
+        this.listener_config = listener_config;
+
+    }
+
+    /**
+     * Fetch Blocks from Fabric peer and publish into kafka
+     *
+     */
+    getBlocks() {
+        let self = this;
+        self.client_kafka.on('error', function (error) {
+            log('Kafka client ERROR', error);",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/234902061,https://github.com/hyperledger/caliper/pull/124#discussion_r234902061,panyu4
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,"log should be replaced with Util.getLogger();  when logging errors with logger=Util.getLogger(), please use logger.error().",20a7141bd4341bae6b03f595254264386590d9c2,2018-11-20 08:12:41,234902165,"@@ -0,0 +1,112 @@
+/**
+* Copyright Persistent Systems 2018. All Rights Reserved.
+*
+* SPDX-License-Identifier: Apache-2.0
+@file Implementation for Fabric Event listener to connect to the peer Event Hub and recieve blocks.
+*/
+
+'use strict';
+
+const Client = require('fabric-client');
+const fs = require('fs');
+const path = require('path');
+let testUtil = require('../fabric/util.js');
+const Util = require('../comm/util');
+const log = Util.log;
+const rootPath = '../../';
+
+
+/**
+ * Fabric Listener class, define operations to recieve block events from Fabric Peer and publish into kafka
+ */
+class FabricListener {
+    /**
+     * Constructor
+     * @param {String} listener_config path of the listener configuration file
+     * @param {Client} client_kafka, Kafka client
+     * @param {Producer} producer, Kafka HighLevelProducer
+     * @param {String} configPath path of the blockchain configuration file
+     */
+    constructor(listener_config, client_kafka, producer, configPath) {
+
+        this.testUtil = testUtil;
+        let args = require(configPath).blockchain;
+        this.testUtil.init(path.join(__dirname, rootPath, args.config));
+        this.peerEventObject = {};
+        this.peerEventObject.eventUrl = listener_config.peerEventUrl;
+        let tlsCert = fs.readFileSync(path.join(__dirname, rootPath, listener_config.peerEventTlscaPath));
+        this.peerEventObject.eventTlsca = tlsCert;
+        this.peerEventObject.eventServerHostName =listener_config.peerEventHostnameOverride;
+        this.peerEventObject.org = listener_config.peerOrg;
+        this.client = new Client();
+        this.client_kafka = client_kafka;
+        this.producer = producer;
+        this.listener_config = listener_config;
+
+    }
+
+    /**
+     * Fetch Blocks from Fabric peer and publish into kafka
+     *
+     */
+    getBlocks() {
+        let self = this;
+        self.client_kafka.on('error', function (error) {
+            log('Kafka client ERROR', error);
+        });
+
+        self.producer.on('ready', function () {
+            Client.newDefaultKeyValueStore({ path: '../hfc/hfc-test-kvs_peerOrg1' }).then((store) => {
+
+                self.client.setStateStore(store);
+                return self.testUtil.getSubmitter(self.client, true, self.peerEventObject.org);
+
+            }).then((admin) => {
+
+                self.client._userContext = admin;
+                let eh = self.client.newEventHub();
+                eh.setPeerAddr(
+                    self.peerEventObject.eventUrl,
+                    {
+                        pem: Buffer.from(self.peerEventObject.eventTlsca).toString(),
+                        'ssl-target-name-override': self.peerEventObject.eventServerHostName,
+                        'request-timeout': 12000000,
+                        'grpc.max_receive_message_length': -1
+                    }
+                );
+                eh.connect();
+
+                eh.registerBlockEvent((block) => {
+                    let event_data = {};
+                    event_data.validTime = Date.now();
+                    event_data.block = block;
+                    let payload = [{
+                        topic: self.listener_config.topic,
+                        messages: JSON.stringify(event_data),
+                        partition: 0,
+                        attributes: 1
+                    }];
+
+                    self.producer.send(payload, function (error, result) {
+                        if (error) {
+                            log('Error while publishing block in kafka', error);",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/234902165,https://github.com/hyperledger/caliper/pull/124#discussion_r234902165,panyu4
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,"log should be replaced with Util.getLogger();  when logging errors with logger=Util.getLogger(), please use logger.error().",20a7141bd4341bae6b03f595254264386590d9c2,2018-11-20 08:14:20,234902606,"@@ -0,0 +1,112 @@
+/**
+* Copyright Persistent Systems 2018. All Rights Reserved.
+*
+* SPDX-License-Identifier: Apache-2.0
+@file Implementation for Fabric Event listener to connect to the peer Event Hub and recieve blocks.
+*/
+
+'use strict';
+
+const Client = require('fabric-client');
+const fs = require('fs');
+const path = require('path');
+let testUtil = require('../fabric/util.js');
+const Util = require('../comm/util');
+const log = Util.log;
+const rootPath = '../../';
+
+
+/**
+ * Fabric Listener class, define operations to recieve block events from Fabric Peer and publish into kafka
+ */
+class FabricListener {
+    /**
+     * Constructor
+     * @param {String} listener_config path of the listener configuration file
+     * @param {Client} client_kafka, Kafka client
+     * @param {Producer} producer, Kafka HighLevelProducer
+     * @param {String} configPath path of the blockchain configuration file
+     */
+    constructor(listener_config, client_kafka, producer, configPath) {
+
+        this.testUtil = testUtil;
+        let args = require(configPath).blockchain;
+        this.testUtil.init(path.join(__dirname, rootPath, args.config));
+        this.peerEventObject = {};
+        this.peerEventObject.eventUrl = listener_config.peerEventUrl;
+        let tlsCert = fs.readFileSync(path.join(__dirname, rootPath, listener_config.peerEventTlscaPath));
+        this.peerEventObject.eventTlsca = tlsCert;
+        this.peerEventObject.eventServerHostName =listener_config.peerEventHostnameOverride;
+        this.peerEventObject.org = listener_config.peerOrg;
+        this.client = new Client();
+        this.client_kafka = client_kafka;
+        this.producer = producer;
+        this.listener_config = listener_config;
+
+    }
+
+    /**
+     * Fetch Blocks from Fabric peer and publish into kafka
+     *
+     */
+    getBlocks() {
+        let self = this;
+        self.client_kafka.on('error', function (error) {
+            log('Kafka client ERROR', error);
+        });
+
+        self.producer.on('ready', function () {
+            Client.newDefaultKeyValueStore({ path: '../hfc/hfc-test-kvs_peerOrg1' }).then((store) => {
+
+                self.client.setStateStore(store);
+                return self.testUtil.getSubmitter(self.client, true, self.peerEventObject.org);
+
+            }).then((admin) => {
+
+                self.client._userContext = admin;
+                let eh = self.client.newEventHub();
+                eh.setPeerAddr(
+                    self.peerEventObject.eventUrl,
+                    {
+                        pem: Buffer.from(self.peerEventObject.eventTlsca).toString(),
+                        'ssl-target-name-override': self.peerEventObject.eventServerHostName,
+                        'request-timeout': 12000000,
+                        'grpc.max_receive_message_length': -1
+                    }
+                );
+                eh.connect();
+
+                eh.registerBlockEvent((block) => {
+                    let event_data = {};
+                    event_data.validTime = Date.now();
+                    event_data.block = block;
+                    let payload = [{
+                        topic: self.listener_config.topic,
+                        messages: JSON.stringify(event_data),
+                        partition: 0,
+                        attributes: 1
+                    }];
+
+                    self.producer.send(payload, function (error, result) {
+                        if (error) {
+                            log('Error while publishing block in kafka', error);
+                        }
+                    });
+
+                },
+                (err) => {
+                    log('Error in chaincode Event listener :', err);",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/234902606,https://github.com/hyperledger/caliper/pull/124#discussion_r234902606,panyu4
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,"log should be replaced with Util.getLogger();  when logging errors with logger=Util.getLogger(), please use logger.error().",20a7141bd4341bae6b03f595254264386590d9c2,2018-11-20 08:14:34,234902659,"@@ -0,0 +1,112 @@
+/**
+* Copyright Persistent Systems 2018. All Rights Reserved.
+*
+* SPDX-License-Identifier: Apache-2.0
+@file Implementation for Fabric Event listener to connect to the peer Event Hub and recieve blocks.
+*/
+
+'use strict';
+
+const Client = require('fabric-client');
+const fs = require('fs');
+const path = require('path');
+let testUtil = require('../fabric/util.js');
+const Util = require('../comm/util');
+const log = Util.log;
+const rootPath = '../../';
+
+
+/**
+ * Fabric Listener class, define operations to recieve block events from Fabric Peer and publish into kafka
+ */
+class FabricListener {
+    /**
+     * Constructor
+     * @param {String} listener_config path of the listener configuration file
+     * @param {Client} client_kafka, Kafka client
+     * @param {Producer} producer, Kafka HighLevelProducer
+     * @param {String} configPath path of the blockchain configuration file
+     */
+    constructor(listener_config, client_kafka, producer, configPath) {
+
+        this.testUtil = testUtil;
+        let args = require(configPath).blockchain;
+        this.testUtil.init(path.join(__dirname, rootPath, args.config));
+        this.peerEventObject = {};
+        this.peerEventObject.eventUrl = listener_config.peerEventUrl;
+        let tlsCert = fs.readFileSync(path.join(__dirname, rootPath, listener_config.peerEventTlscaPath));
+        this.peerEventObject.eventTlsca = tlsCert;
+        this.peerEventObject.eventServerHostName =listener_config.peerEventHostnameOverride;
+        this.peerEventObject.org = listener_config.peerOrg;
+        this.client = new Client();
+        this.client_kafka = client_kafka;
+        this.producer = producer;
+        this.listener_config = listener_config;
+
+    }
+
+    /**
+     * Fetch Blocks from Fabric peer and publish into kafka
+     *
+     */
+    getBlocks() {
+        let self = this;
+        self.client_kafka.on('error', function (error) {
+            log('Kafka client ERROR', error);
+        });
+
+        self.producer.on('ready', function () {
+            Client.newDefaultKeyValueStore({ path: '../hfc/hfc-test-kvs_peerOrg1' }).then((store) => {
+
+                self.client.setStateStore(store);
+                return self.testUtil.getSubmitter(self.client, true, self.peerEventObject.org);
+
+            }).then((admin) => {
+
+                self.client._userContext = admin;
+                let eh = self.client.newEventHub();
+                eh.setPeerAddr(
+                    self.peerEventObject.eventUrl,
+                    {
+                        pem: Buffer.from(self.peerEventObject.eventTlsca).toString(),
+                        'ssl-target-name-override': self.peerEventObject.eventServerHostName,
+                        'request-timeout': 12000000,
+                        'grpc.max_receive_message_length': -1
+                    }
+                );
+                eh.connect();
+
+                eh.registerBlockEvent((block) => {
+                    let event_data = {};
+                    event_data.validTime = Date.now();
+                    event_data.block = block;
+                    let payload = [{
+                        topic: self.listener_config.topic,
+                        messages: JSON.stringify(event_data),
+                        partition: 0,
+                        attributes: 1
+                    }];
+
+                    self.producer.send(payload, function (error, result) {
+                        if (error) {
+                            log('Error while publishing block in kafka', error);
+                        }
+                    });
+
+                },
+                (err) => {
+                    log('Error in chaincode Event listener :', err);
+                }
+                );
+            });
+
+        });
+        self.producer.on('error', function (error) {
+            log('Producer is not ready', error);",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/234902659,https://github.com/hyperledger/caliper/pull/124#discussion_r234902659,panyu4
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,localConfig's value is same as config in line 290. configurationType  can be got after the config is set. ,20a7141bd4341bae6b03f595254264386590d9c2,2018-11-20 08:36:06,234908265,"@@ -278,6 +280,8 @@ function defaultTest(args, clientArgs, final) {
  * @param {String} networkFile path of the blockchain configuration file
  */
 module.exports.run = function(configFile, networkFile) {
+    let localConfig = require(configFile);
+    configurationType = localConfig.test.clients.WITH_MQ;",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/234908265,https://github.com/hyperledger/caliper/pull/124#discussion_r234908265,panyu4
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,"since absConfigFile can be recorded using config framework, it is not necessary to add config as a parameter. 
You can use config framework like this:  const cfUtil = require('./config-util.js');  const cfUtil.getConfigSetting('fabric:WITH_MQ',false);   
If there is any problem when using this config framework, please let me know or you can contact with @feihujiang ",20a7141bd4341bae6b03f595254264386590d9c2,2018-11-20 08:46:47,234911426,"@@ -90,14 +92,43 @@ class Client{
         let conf = require(config);
         this.config = conf.test.clients;
         this.results = [];                        // output of recent test round
-        this.updates = {id:0, data:[]};           // contains txUpdated messages
+        this.updates = {id:0, data:[]}; // contains txUpdated messages
     }
 
     /**
     * Initialise client object
+    * @param {JSON} demo object which trakcs real time metrics
+    * @param {String} config path of the configuration file
+    * @param {String} absCaliperDir caliper directory
+    * @param {JSON} listener_child child process
+    * @param {JSON} t test object
     * @return {Promise} promise object
     */
-    init() {
+    init(demo, config, absCaliperDir, listener_child) {
+        absConfigFile = require(Util.resolvePath(config));",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/234911426,https://github.com/hyperledger/caliper/pull/124#discussion_r234911426,panyu4
https://github.com/hyperledger/caliper/pull/124,https://github.com/hyperledger/caliper/pull/124,The last parameter is not necessary to be added since it can be got through the config framework.,20a7141bd4341bae6b03f595254264386590d9c2,2018-11-20 08:49:35,234912303,"@@ -221,8 +258,9 @@ class Client{
      * @return {Promise} promise object
      */
     _startLocalTest(message, clientArgs) {
+
         message.totalClients = this.number;
-        return clientUtil.startTest(this.number, message, clientArgs, this.updates.data, this.results);
+        return clientUtil.startTest(this.number, message, clientArgs, this.updates.data, this.results, this.config.WITH_MQ);",,2018-11-25 20:51:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/234912303,https://github.com/hyperledger/caliper/pull/124#discussion_r234912303,panyu4
https://github.com/hyperledger/caliper/pull/71,https://github.com/hyperledger/caliper/pull/71,"Why this changes required? create account operation may be part of batch, but it should be first in the order.",7ab3ba31767c89eee8fee006910cfbef874b6ef9,2018-05-21 10:43:18,189554620,"@@ -68,7 +68,7 @@ function generateWorkload() {
     if(workload.length === txnPerBatch) {
         return workload;
     }
-    else {",13,2018-05-21 10:45:02,https://api.github.com/repos/hyperledger/caliper/pulls/comments/189554620,https://github.com/hyperledger/caliper/pull/71#discussion_r189554620,Ram-srini
https://github.com/hyperledger/caliper/pull/71,https://github.com/hyperledger/caliper/pull/71,"Since Fabric does not support batch, txns in the same batch are submitted nearly simultaneously . There is a high chance of error if an transaction such as send_payment is wrapped in a batch with a create_account transaction and those two txns operates on the same account. The change is to avoid this.",7ab3ba31767c89eee8fee006910cfbef874b6ef9,2018-05-21 11:15:38,189560867,"@@ -68,7 +68,7 @@ function generateWorkload() {
     if(workload.length === txnPerBatch) {
         return workload;
     }
-    else {",13,2018-05-21 11:15:38,https://api.github.com/repos/hyperledger/caliper/pulls/comments/189560867,https://github.com/hyperledger/caliper/pull/71#discussion_r189560867,haojun
https://github.com/hyperledger/caliper/pull/71,https://github.com/hyperledger/caliper/pull/71,"Is it happening always? or with higher tps rate? Intention of small bank benchmark use case is simulate the real bank use case. if order of transactions is fixed then, it should create account first and later it perform operations on those account. For amalgamate we can do perform separate testing. Other than this we shouldn't change the behavior small bank work load generation.",7ab3ba31767c89eee8fee006910cfbef874b6ef9,2018-05-22 04:48:21,189776793,"@@ -68,7 +68,7 @@ function generateWorkload() {
     if(workload.length === txnPerBatch) {
         return workload;
     }
-    else {",13,2018-05-22 04:48:21,https://api.github.com/repos/hyperledger/caliper/pulls/comments/189776793,https://github.com/hyperledger/caliper/pull/71#discussion_r189776793,Ram-srini
https://github.com/hyperledger/caliper/pull/71,https://github.com/hyperledger/caliper/pull/71,"It happens always. In real world, if you are using fabric, you should first create account, **waiting for the result** and then send other operations. You should not send the later operation if the creation has not been finished. ",7ab3ba31767c89eee8fee006910cfbef874b6ef9,2018-05-22 06:00:32,189784346,"@@ -68,7 +68,7 @@ function generateWorkload() {
     if(workload.length === txnPerBatch) {
         return workload;
     }
-    else {",13,2018-05-22 06:00:32,https://api.github.com/repos/hyperledger/caliper/pulls/comments/189784346,https://github.com/hyperledger/caliper/pull/71#discussion_r189784346,haojun
https://github.com/hyperledger/caliper/pull/71,https://github.com/hyperledger/caliper/pull/71,"Then it is limitation in Fabric, even if we are sending the transactions in the right order where account creation operatons at first and others followed by that. In this case should we update our benchmark test to fit to the limitation of hyperledger framework?",7ab3ba31767c89eee8fee006910cfbef874b6ef9,2018-05-22 06:08:38,189785437,"@@ -68,7 +68,7 @@ function generateWorkload() {
     if(workload.length === txnPerBatch) {
         return workload;
     }
-    else {",13,2018-05-22 09:56:10,https://api.github.com/repos/hyperledger/caliper/pulls/comments/189785437,https://github.com/hyperledger/caliper/pull/71#discussion_r189785437,Ram-srini
https://github.com/hyperledger/caliper/pull/71,https://github.com/hyperledger/caliper/pull/71,"Sorry, what's your point?",7ab3ba31767c89eee8fee006910cfbef874b6ef9,2018-05-22 07:22:39,189798780,"@@ -68,7 +68,7 @@ function generateWorkload() {
     if(workload.length === txnPerBatch) {
         return workload;
     }
-    else {",13,2018-05-22 07:22:39,https://api.github.com/repos/hyperledger/caliper/pulls/comments/189798780,https://github.com/hyperledger/caliper/pull/71#discussion_r189798780,haojun
https://github.com/hyperledger/caliper/pull/71,https://github.com/hyperledger/caliper/pull/71,payiing typo,7ab3ba31767c89eee8fee006910cfbef874b6ef9,2018-05-22 07:31:18,189800809,"@@ -0,0 +1,9 @@
+The smallbank benchmark contains a series of transactions to simulate bank operations, including one transaction which creates accounts and others which perform banking transactions such as querying balances, depositing in accounts, payiing money, etc. The benchmark intends to provide cross-platform workload for blockchain performance testing in the bank scene.",1,2018-05-22 07:31:18,https://api.github.com/repos/hyperledger/caliper/pulls/comments/189800809,https://github.com/hyperledger/caliper/pull/71#discussion_r189800809,feihujiang
https://github.com/hyperledger/caliper/pull/71,https://github.com/hyperledger/caliper/pull/71,"if len(args) != 2 {	// should be [dest_customer_id,source_customer_id]",7ab3ba31767c89eee8fee006910cfbef874b6ef9,2018-05-22 08:06:16,189809214,"@@ -0,0 +1,263 @@
+/**
+* Copyright 2017 HUAWEI. All Rights Reserved.
+*
+* SPDX-License-Identifier: Apache-2.0
+*
+*/
+
+package main
+
+import (
+	""fmt""
+	""strconv""
+	""crypto/sha512""
+	""encoding/hex""
+	""encoding/json""
+	""strings""
+	""github.com/hyperledger/fabric/core/chaincode/shim""
+	pb ""github.com/hyperledger/fabric/protos/peer""
+)
+
+const ERROR_UNKNOWN_FUNC = ""Unknown function""
+const ERROR_WRONG_ARGS = ""Wrong arguments of function""
+const ERROR_SYSTEM = ""System exception""
+const ERR_NOT_FOUND = ""Could not find specified account""
+const ERROR_PUT_STATE = ""Failed to put state""
+
+var namespace = hexdigest(""smallbank"")[:6]
+
+type SmallbankChaincode struct {
+
+}
+
+func (t *SmallbankChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {
+	// nothing to do
+	return shim.Success(nil)
+}
+
+func (t *SmallbankChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {
+	function, args := stub.GetFunctionAndParameters()
+	switch function {
+	case ""create_account"":
+		return t.CreateAccount(stub, args)
+	case ""transact_savings"":
+		return t.TransactSavings(stub, args)
+	case ""deposit_checking"":
+		return t.DepositChecking(stub, args)
+	case ""send_payment"":
+		return t.SendPayment(stub, args)
+	case ""write_check"":
+		return t.WriteCheck(stub, args)
+	case ""amalgamate"":
+		return t.Amalgamate(stub, args)
+	case ""query"":
+		return t.Query(stub, args)
+	default:
+		return errormsg(ERROR_UNKNOWN_FUNC + "": "" +function)
+	}
+}
+
+type Account struct {
+	CustomId   string
+	CustomName string
+	SavingsBalance int
+	CheckingBalance int
+}
+func (t *SmallbankChaincode) CreateAccount(stub shim.ChaincodeStubInterface, args []string) pb.Response {
+	if len(args) != 4 {	//should be [customer_id, customer_name, initial_checking_balance, initial_savings_balance]
+		return errormsg(ERROR_WRONG_ARGS + "" create_account"")
+	}
+
+	key := accountKey(args[0])
+	data,err := stub.GetState(key)
+	if data != nil {
+		return errormsg(""Can not create duplicated account"")
+	}
+
+	checking, errcheck := strconv.Atoi(args[2])
+	if errcheck != nil {
+		return errormsg(ERROR_WRONG_ARGS + "" create_account, checking balance should be integer"")
+	}
+	saving, errsaving := strconv.Atoi(args[3])
+	if errsaving != nil {
+		return errormsg(ERROR_WRONG_ARGS + "" create_account, saving balance should be integer"")
+	}
+
+	account := &Account {
+		CustomId: args[0],
+		CustomName: args[1],
+		SavingsBalance: saving,
+		CheckingBalance: checking }
+	err = saveAccount(stub, account)
+	if err != nil {
+		return systemerror(err.Error())
+	}
+
+	return shim.Success(nil)
+}
+
+func (t *SmallbankChaincode) DepositChecking(stub shim.ChaincodeStubInterface, args []string) pb.Response {
+	if len(args) != 2 {	// should be [amount,customer_id]
+		return errormsg(ERROR_WRONG_ARGS + "" deposit_checking"")
+	}
+	account, err := loadAccount(stub, args[1])
+	if err != nil {
+		return errormsg(ERR_NOT_FOUND);
+	}
+	amount, _ := strconv.Atoi(args[0])
+	account.CheckingBalance += amount
+	err = saveAccount(stub, account)
+	if err != nil {
+		return systemerror(err.Error())
+	}
+
+	return shim.Success(nil)
+}
+
+func (t *SmallbankChaincode) WriteCheck(stub shim.ChaincodeStubInterface, args []string) pb.Response {
+	if len(args) != 2 {	// should be [amount,customer_id]
+		return errormsg(ERROR_WRONG_ARGS + "" write_check"")
+	}
+	account, err := loadAccount(stub, args[1])
+	if err != nil {
+		return errormsg(ERR_NOT_FOUND);
+	}
+	amount, _ := strconv.Atoi(args[0])
+	account.CheckingBalance -= amount
+	err = saveAccount(stub, account)
+	if err != nil {
+		return systemerror(err.Error())
+	}
+
+	return shim.Success(nil)
+}
+
+func (t *SmallbankChaincode) TransactSavings(stub shim.ChaincodeStubInterface, args []string) pb.Response {
+	if len(args) != 2 {	// should be [amount,customer_id]
+		return errormsg(ERROR_WRONG_ARGS + "" transaction_savings"")
+	}
+	account, err := loadAccount(stub, args[1])
+	if err != nil {
+		return errormsg(ERR_NOT_FOUND);
+	}
+	amount, _ := strconv.Atoi(args[0])
+	// since the contract is only used for perfomance testing, we ignore this check 
+	//if amount < 0 && account.SavingsBalance < (-amount) {
+	//	return errormsg(""Insufficient funds in source savings account"")
+	//}
+	account.SavingsBalance += amount
+	err = saveAccount(stub, account)
+	if err != nil {
+		return systemerror(err.Error())
+	}
+
+	return shim.Success(nil)
+}
+
+func (t *SmallbankChaincode) SendPayment(stub shim.ChaincodeStubInterface, args []string) pb.Response {
+	if len(args) != 3 {	// should be [amount,dest_customer_id,source_customer_id]
+		return errormsg(ERROR_WRONG_ARGS + "" send_payment"")
+	}
+	destAccount, err1 := loadAccount(stub, args[1])
+	sourceAccount, err2 := loadAccount(stub, args[2])
+	if err1 != nil || err2 != nil {
+		return errormsg(ERR_NOT_FOUND)
+	}
+
+	amount, _ := strconv.Atoi(args[0])
+	// since the contract is only used for perfomance testing, we ignore this check
+	//if sourceAccount.CheckingBalance < amount {
+	//	return errormsg(""Insufficient funds in source checking account"")
+	//}
+	sourceAccount.CheckingBalance -= amount
+	destAccount.CheckingBalance += amount
+	err1 = saveAccount(stub, sourceAccount)
+	err2 = saveAccount(stub, destAccount)
+	if err1 != nil || err2 != nil {
+		return errormsg(ERROR_PUT_STATE)
+	}
+	
+	return shim.Success(nil)
+}
+
+func (t *SmallbankChaincode) Amalgamate(stub shim.ChaincodeStubInterface, args []string) pb.Response {
+	if len(args) != 3 {	// should be [amount,dest_customer_id,source_customer_id]",184,2018-05-22 08:11:23,https://api.github.com/repos/hyperledger/caliper/pulls/comments/189809214,https://github.com/hyperledger/caliper/pull/71#discussion_r189809214,feihujiang
https://github.com/hyperledger/caliper/pull/71,https://github.com/hyperledger/caliper/pull/71,destAccount.CheckingBalance += sourceAccount.SavingsBalance,7ab3ba31767c89eee8fee006910cfbef874b6ef9,2018-05-22 08:07:48,189809603,"@@ -0,0 +1,263 @@
+/**
+* Copyright 2017 HUAWEI. All Rights Reserved.
+*
+* SPDX-License-Identifier: Apache-2.0
+*
+*/
+
+package main
+
+import (
+	""fmt""
+	""strconv""
+	""crypto/sha512""
+	""encoding/hex""
+	""encoding/json""
+	""strings""
+	""github.com/hyperledger/fabric/core/chaincode/shim""
+	pb ""github.com/hyperledger/fabric/protos/peer""
+)
+
+const ERROR_UNKNOWN_FUNC = ""Unknown function""
+const ERROR_WRONG_ARGS = ""Wrong arguments of function""
+const ERROR_SYSTEM = ""System exception""
+const ERR_NOT_FOUND = ""Could not find specified account""
+const ERROR_PUT_STATE = ""Failed to put state""
+
+var namespace = hexdigest(""smallbank"")[:6]
+
+type SmallbankChaincode struct {
+
+}
+
+func (t *SmallbankChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {
+	// nothing to do
+	return shim.Success(nil)
+}
+
+func (t *SmallbankChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {
+	function, args := stub.GetFunctionAndParameters()
+	switch function {
+	case ""create_account"":
+		return t.CreateAccount(stub, args)
+	case ""transact_savings"":
+		return t.TransactSavings(stub, args)
+	case ""deposit_checking"":
+		return t.DepositChecking(stub, args)
+	case ""send_payment"":
+		return t.SendPayment(stub, args)
+	case ""write_check"":
+		return t.WriteCheck(stub, args)
+	case ""amalgamate"":
+		return t.Amalgamate(stub, args)
+	case ""query"":
+		return t.Query(stub, args)
+	default:
+		return errormsg(ERROR_UNKNOWN_FUNC + "": "" +function)
+	}
+}
+
+type Account struct {
+	CustomId   string
+	CustomName string
+	SavingsBalance int
+	CheckingBalance int
+}
+func (t *SmallbankChaincode) CreateAccount(stub shim.ChaincodeStubInterface, args []string) pb.Response {
+	if len(args) != 4 {	//should be [customer_id, customer_name, initial_checking_balance, initial_savings_balance]
+		return errormsg(ERROR_WRONG_ARGS + "" create_account"")
+	}
+
+	key := accountKey(args[0])
+	data,err := stub.GetState(key)
+	if data != nil {
+		return errormsg(""Can not create duplicated account"")
+	}
+
+	checking, errcheck := strconv.Atoi(args[2])
+	if errcheck != nil {
+		return errormsg(ERROR_WRONG_ARGS + "" create_account, checking balance should be integer"")
+	}
+	saving, errsaving := strconv.Atoi(args[3])
+	if errsaving != nil {
+		return errormsg(ERROR_WRONG_ARGS + "" create_account, saving balance should be integer"")
+	}
+
+	account := &Account {
+		CustomId: args[0],
+		CustomName: args[1],
+		SavingsBalance: saving,
+		CheckingBalance: checking }
+	err = saveAccount(stub, account)
+	if err != nil {
+		return systemerror(err.Error())
+	}
+
+	return shim.Success(nil)
+}
+
+func (t *SmallbankChaincode) DepositChecking(stub shim.ChaincodeStubInterface, args []string) pb.Response {
+	if len(args) != 2 {	// should be [amount,customer_id]
+		return errormsg(ERROR_WRONG_ARGS + "" deposit_checking"")
+	}
+	account, err := loadAccount(stub, args[1])
+	if err != nil {
+		return errormsg(ERR_NOT_FOUND);
+	}
+	amount, _ := strconv.Atoi(args[0])
+	account.CheckingBalance += amount
+	err = saveAccount(stub, account)
+	if err != nil {
+		return systemerror(err.Error())
+	}
+
+	return shim.Success(nil)
+}
+
+func (t *SmallbankChaincode) WriteCheck(stub shim.ChaincodeStubInterface, args []string) pb.Response {
+	if len(args) != 2 {	// should be [amount,customer_id]
+		return errormsg(ERROR_WRONG_ARGS + "" write_check"")
+	}
+	account, err := loadAccount(stub, args[1])
+	if err != nil {
+		return errormsg(ERR_NOT_FOUND);
+	}
+	amount, _ := strconv.Atoi(args[0])
+	account.CheckingBalance -= amount
+	err = saveAccount(stub, account)
+	if err != nil {
+		return systemerror(err.Error())
+	}
+
+	return shim.Success(nil)
+}
+
+func (t *SmallbankChaincode) TransactSavings(stub shim.ChaincodeStubInterface, args []string) pb.Response {
+	if len(args) != 2 {	// should be [amount,customer_id]
+		return errormsg(ERROR_WRONG_ARGS + "" transaction_savings"")
+	}
+	account, err := loadAccount(stub, args[1])
+	if err != nil {
+		return errormsg(ERR_NOT_FOUND);
+	}
+	amount, _ := strconv.Atoi(args[0])
+	// since the contract is only used for perfomance testing, we ignore this check 
+	//if amount < 0 && account.SavingsBalance < (-amount) {
+	//	return errormsg(""Insufficient funds in source savings account"")
+	//}
+	account.SavingsBalance += amount
+	err = saveAccount(stub, account)
+	if err != nil {
+		return systemerror(err.Error())
+	}
+
+	return shim.Success(nil)
+}
+
+func (t *SmallbankChaincode) SendPayment(stub shim.ChaincodeStubInterface, args []string) pb.Response {
+	if len(args) != 3 {	// should be [amount,dest_customer_id,source_customer_id]
+		return errormsg(ERROR_WRONG_ARGS + "" send_payment"")
+	}
+	destAccount, err1 := loadAccount(stub, args[1])
+	sourceAccount, err2 := loadAccount(stub, args[2])
+	if err1 != nil || err2 != nil {
+		return errormsg(ERR_NOT_FOUND)
+	}
+
+	amount, _ := strconv.Atoi(args[0])
+	// since the contract is only used for perfomance testing, we ignore this check
+	//if sourceAccount.CheckingBalance < amount {
+	//	return errormsg(""Insufficient funds in source checking account"")
+	//}
+	sourceAccount.CheckingBalance -= amount
+	destAccount.CheckingBalance += amount
+	err1 = saveAccount(stub, sourceAccount)
+	err2 = saveAccount(stub, destAccount)
+	if err1 != nil || err2 != nil {
+		return errormsg(ERROR_PUT_STATE)
+	}
+	
+	return shim.Success(nil)
+}
+
+func (t *SmallbankChaincode) Amalgamate(stub shim.ChaincodeStubInterface, args []string) pb.Response {
+	if len(args) != 3 {	// should be [amount,dest_customer_id,source_customer_id]
+		return errormsg(ERROR_WRONG_ARGS + "" amalgamate"")
+	}
+	destAccount, err1 := loadAccount(stub, args[1])
+	sourceAccount, err2 := loadAccount(stub, args[2])
+	if err1 != nil || err2 != nil {
+		return errormsg(ERR_NOT_FOUND)
+	}
+
+	// amount, _ := strconv.Atoi(args[0])
+	destAccount.SavingsBalance += sourceAccount.SavingsBalance",194,2018-05-22 08:11:23,https://api.github.com/repos/hyperledger/caliper/pulls/comments/189809603,https://github.com/hyperledger/caliper/pull/71#discussion_r189809603,feihujiang
https://github.com/hyperledger/caliper/pull/71,https://github.com/hyperledger/caliper/pull/71,"I've summarized the current discussion below, and will post it to contributor channel of rocketchat to see if other guys have  any suggestion. ",7ab3ba31767c89eee8fee006910cfbef874b6ef9,2018-05-22 08:08:26,189809740,"@@ -68,7 +68,7 @@ function generateWorkload() {
     if(workload.length === txnPerBatch) {
         return workload;
     }
-    else {",13,2018-05-22 08:08:26,https://api.github.com/repos/hyperledger/caliper/pulls/comments/189809740,https://github.com/hyperledger/caliper/pull/71#discussion_r189809740,haojun
https://github.com/hyperledger/caliper/pull/71,https://github.com/hyperledger/caliper/pull/71,Do we need this file?,7ab3ba31767c89eee8fee006910cfbef874b6ef9,2018-05-22 08:11:23,189810532,"@@ -0,0 +1 @@
+nohup: failed to run command 'java': No such file or directory",1,2018-05-22 08:11:23,https://api.github.com/repos/hyperledger/caliper/pulls/comments/189810532,https://github.com/hyperledger/caliper/pull/71#discussion_r189810532,feihujiang
https://github.com/hyperledger/caliper/pull/71,https://github.com/hyperledger/caliper/pull/71,Do we need this file?,7ab3ba31767c89eee8fee006910cfbef874b6ef9,2018-05-22 08:11:32,189810575,"@@ -0,0 +1 @@
+43698",1,2018-05-22 08:11:33,https://api.github.com/repos/hyperledger/caliper/pulls/comments/189810575,https://github.com/hyperledger/caliper/pull/71#discussion_r189810575,feihujiang
https://github.com/hyperledger/caliper/pull/71,https://github.com/hyperledger/caliper/pull/71,"If we set txnPerBatch = 1 for fabric, will it fix 'Invalid transaction: MVCC_READ_CONFLICT' error in fabric?",7ab3ba31767c89eee8fee006910cfbef874b6ef9,2018-05-22 08:38:40,189818609,"@@ -0,0 +1,38 @@
+{
+   ""blockchain"": {
+        ""type"": ""fabric"",
+        ""config"": ""benchmark/smallbank/fabric.json""
+  },
+  ""command"" : {
+    ""start"": ""docker-compose -f network/fabric/simplenetwork/docker-compose.yaml up -d"",
+    ""end"" : ""docker-compose -f network/fabric/simplenetwork/docker-compose.yaml down;docker rm $(docker ps -aq)""
+  },
+  ""test"": {
+    ""name"": ""smallbank"",
+    ""description"" : ""This is smallbank benchmark for caliper"",
+    ""clients"": {
+      ""type"": ""local"",
+      ""number"": 5
+    },
+    ""rounds"": [{
+        ""label"" : ""smallOperations"",
+        ""txNumber"" : [2000],
+        ""rateControl"" : [{""type"": ""fixed-rate"", ""opts"": {""tps"" : 200}}],
+        ""arguments"": {""accounts"":300, ""txnPerBatch"":10},",21,2018-05-22 08:38:41,https://api.github.com/repos/hyperledger/caliper/pulls/comments/189818609,https://github.com/hyperledger/caliper/pull/71#discussion_r189818609,Ram-srini
https://github.com/hyperledger/caliper/pull/71,https://github.com/hyperledger/caliper/pull/71,"Unfortunately no...... But at least there will be some time interval between two adjacent submittings, so it may be better at low submitting rate.",7ab3ba31767c89eee8fee006910cfbef874b6ef9,2018-05-22 08:58:15,189824806,"@@ -0,0 +1,38 @@
+{
+   ""blockchain"": {
+        ""type"": ""fabric"",
+        ""config"": ""benchmark/smallbank/fabric.json""
+  },
+  ""command"" : {
+    ""start"": ""docker-compose -f network/fabric/simplenetwork/docker-compose.yaml up -d"",
+    ""end"" : ""docker-compose -f network/fabric/simplenetwork/docker-compose.yaml down;docker rm $(docker ps -aq)""
+  },
+  ""test"": {
+    ""name"": ""smallbank"",
+    ""description"" : ""This is smallbank benchmark for caliper"",
+    ""clients"": {
+      ""type"": ""local"",
+      ""number"": 5
+    },
+    ""rounds"": [{
+        ""label"" : ""smallOperations"",
+        ""txNumber"" : [2000],
+        ""rateControl"" : [{""type"": ""fixed-rate"", ""opts"": {""tps"" : 200}}],
+        ""arguments"": {""accounts"":300, ""txnPerBatch"":10},",21,2018-05-22 08:58:15,https://api.github.com/repos/hyperledger/caliper/pulls/comments/189824806,https://github.com/hyperledger/caliper/pull/71#discussion_r189824806,haojun
https://github.com/hyperledger/caliper/pull/71,https://github.com/hyperledger/caliper/pull/71,You can include amalgamate in the small bank work load generation. Amalgamate will move entire amount from one user saving to other user's checking account. And also The TransactSavingsTransaction adds an amount to the customer's savings account. Amount may be a negative number. So it won't affect the operation of transact saving after amalgamate. I think you have to change chain code for transact_saving_account operation to avoid errors.,7ab3ba31767c89eee8fee006910cfbef874b6ef9,2018-05-23 04:20:46,190119080,"@@ -14,7 +14,7 @@ let no_accounts=0;
 let account_array=[];
 let accounts, txnPerBatch;
 const initial_balance = 1000000;
-const operation_type = ['transact_savings','deposit_checking','send_payment','write_check','amalgamate'];
+const operation_type = ['transact_savings','deposit_checking','send_payment','write_check']; //,'amalgamate'];",5,2018-05-23 04:20:46,https://api.github.com/repos/hyperledger/caliper/pulls/comments/190119080,https://github.com/hyperledger/caliper/pull/71#discussion_r190119080,Ram-srini
https://github.com/hyperledger/caliper/pull/71,https://github.com/hyperledger/caliper/pull/71,"OK, got it",7ab3ba31767c89eee8fee006910cfbef874b6ef9,2018-05-24 03:10:55,190455179,"@@ -14,7 +14,7 @@ let no_accounts=0;
 let account_array=[];
 let accounts, txnPerBatch;
 const initial_balance = 1000000;
-const operation_type = ['transact_savings','deposit_checking','send_payment','write_check','amalgamate'];
+const operation_type = ['transact_savings','deposit_checking','send_payment','write_check']; //,'amalgamate'];",5,2018-05-24 03:10:56,https://api.github.com/repos/hyperledger/caliper/pulls/comments/190455179,https://github.com/hyperledger/caliper/pull/71#discussion_r190455179,haojun
https://github.com/hyperledger/caliper/pull/66,https://github.com/hyperledger/caliper/pull/66,Has a lint error,3378c87bd547354a20b4ff2154092e1ec2b8963b,2018-05-16 08:55:19,188550050,"@@ -80,7 +97,6 @@ class SimpleBatchBuilder extends BatchBuilder {
         const familyNameSpace = _hash(this.familyName).substring(0, 6);
         let address = familyNameSpace + _hash(name).slice(-64);
         return address;
-    }
- 
+    } ",,2018-05-17 01:00:20,https://api.github.com/repos/hyperledger/caliper/pulls/comments/188550050,https://github.com/hyperledger/caliper/pull/66#discussion_r188550050,feihujiang
https://github.com/hyperledger/caliper/pull/58,https://github.com/hyperledger/caliper/pull/58,"Would recommend removing the hat for now and use:

`""grpc"": ""1.10.1"",`",3bf3dc6d066c050d499fbadb4cffe81b047f601e,2018-05-04 11:46:08,186058477,"@@ -24,6 +24,7 @@
     ""commander"": ""^2.11.0"",
     ""dockerode"": ""^2.5.0"",
     ""fs-extra"": ""^4.0.2"",
+    ""grpc"": ""^1.10.1"",",,2018-05-07 06:20:40,https://api.github.com/repos/hyperledger/caliper/pulls/comments/186058477,https://github.com/hyperledger/caliper/pull/58#discussion_r186058477,nklincoln
https://github.com/hyperledger/caliper/pull/47,https://github.com/hyperledger/caliper/pull/47,Why need this shell container?,5446832ba7a0c068a83ae90b3c4c90178099c065,2018-05-04 02:46:18,185982104,"@@ -0,0 +1,79 @@
+# Copyright 2017 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+# ------------------------------------------------------------------------------
+
+version: ""2.1""
+
+services:
+
+  settings-tp:
+    image: hyperledger/sawtooth-settings-tp:latest
+    container_name: sawtooth-settings-tp-default
+    depends_on:
+      - validator
+    entrypoint: settings-tp -vv -C tcp://validator:4004
+
+  smallbank-tp-go:
+    image: hyperledger/sawtooth-smallbank-tp-go:latest
+    container_name: sawtooth-smallbank-tp-go-default
+    depends_on:
+      - validator
+    entrypoint: smallbank-tp-go -vv -C tcp://validator:4004
+
+  validator:
+    image: hyperledger/sawtooth-validator:latest
+    container_name: sawtooth-validator-default
+    expose:
+      - 4004
+    ports:
+      - ""4004:4004""
+    # start the validator with an empty genesis batch
+    entrypoint: ""bash -c \""\
+        sawadm keygen && \
+        sawtooth keygen my_key && \
+        sawset genesis -k /root/.sawtooth/keys/my_key.priv && \
+        sawadm genesis config-genesis.batch && \
+        sawtooth-validator -vv \
+          --endpoint tcp://validator:8800 \
+          --bind component:tcp://eth0:4004 \
+          --bind network:tcp://eth0:8800 \
+        \""""
+
+  rest-api:
+    image: hyperledger/sawtooth-rest-api:latest
+    container_name: sawtooth-rest-api-default
+    expose:
+      - 8008
+    ports:
+      - ""8008:8008""
+    depends_on:
+      - validator
+    entrypoint: sawtooth-rest-api -vvv -C tcp://validator:4004 --bind rest-api:8008
+
+  shell:",,2018-05-08 04:15:37,https://api.github.com/repos/hyperledger/caliper/pulls/comments/185982104,https://github.com/hyperledger/caliper/pull/47#discussion_r185982104,feihujiang
https://github.com/hyperledger/caliper/pull/47,https://github.com/hyperledger/caliper/pull/47,Shell container is to run sawtooth cli commands to verify state and blocks data.,5446832ba7a0c068a83ae90b3c4c90178099c065,2018-05-04 02:52:55,185982654,"@@ -0,0 +1,79 @@
+# Copyright 2017 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+# ------------------------------------------------------------------------------
+
+version: ""2.1""
+
+services:
+
+  settings-tp:
+    image: hyperledger/sawtooth-settings-tp:latest
+    container_name: sawtooth-settings-tp-default
+    depends_on:
+      - validator
+    entrypoint: settings-tp -vv -C tcp://validator:4004
+
+  smallbank-tp-go:
+    image: hyperledger/sawtooth-smallbank-tp-go:latest
+    container_name: sawtooth-smallbank-tp-go-default
+    depends_on:
+      - validator
+    entrypoint: smallbank-tp-go -vv -C tcp://validator:4004
+
+  validator:
+    image: hyperledger/sawtooth-validator:latest
+    container_name: sawtooth-validator-default
+    expose:
+      - 4004
+    ports:
+      - ""4004:4004""
+    # start the validator with an empty genesis batch
+    entrypoint: ""bash -c \""\
+        sawadm keygen && \
+        sawtooth keygen my_key && \
+        sawset genesis -k /root/.sawtooth/keys/my_key.priv && \
+        sawadm genesis config-genesis.batch && \
+        sawtooth-validator -vv \
+          --endpoint tcp://validator:8800 \
+          --bind component:tcp://eth0:4004 \
+          --bind network:tcp://eth0:8800 \
+        \""""
+
+  rest-api:
+    image: hyperledger/sawtooth-rest-api:latest
+    container_name: sawtooth-rest-api-default
+    expose:
+      - 8008
+    ports:
+      - ""8008:8008""
+    depends_on:
+      - validator
+    entrypoint: sawtooth-rest-api -vvv -C tcp://validator:4004 --bind rest-api:8008
+
+  shell:",,2018-05-08 04:15:37,https://api.github.com/repos/hyperledger/caliper/pulls/comments/185982654,https://github.com/hyperledger/caliper/pull/47#discussion_r185982654,Ram-srini
https://github.com/hyperledger/caliper/pull/47,https://github.com/hyperledger/caliper/pull/47,Anybody could send a WriteCheckTransaction to remove an amount from the account? not must the owner of the account?,5446832ba7a0c068a83ae90b3c4c90178099c065,2018-05-04 03:06:57,185983696,"@@ -0,0 +1,129 @@
+/**
+* Copyright 2017 Intel Corporation
+*
+* Licensed under the Apache License, Version 2.0 (the ""License"");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+syntax = ""proto3"";
+option java_multiple_files = true;
+
+option go_package = ""smallbank_pb2"";
+
+message Account {
+    // Customer ID
+    uint32 customer_id = 1;
+
+    // Customer Name
+    string customer_name = 2;
+
+    // Savings Balance (in cents to avoid float)
+    uint32 savings_balance = 3;
+
+    // Checking Balance (in cents to avoid float)
+    uint32 checking_balance = 4;
+}
+
+message SmallbankTransactionPayload {
+    message CreateAccountTransactionData {
+        // The CreateAccountTransaction creates an account
+
+        // Customer ID
+        uint32 customer_id = 1;
+
+        // Customer Name
+        string customer_name = 2;
+
+        // Initial Savings Balance (in cents to avoid float)
+        uint32 initial_savings_balance = 3;
+
+        // Initial Checking Balance (in cents to avoid float)
+        uint32 initial_checking_balance = 4;
+    }
+
+    message DepositCheckingTransactionData {
+        // The DepositCheckingTransction adds an amount to the customer's
+        // checking account.
+
+        // Customer ID
+        uint32 customer_id = 1;
+
+        // Amount
+        uint32 amount = 2;
+    }
+
+    message WriteCheckTransactionData {",64,2018-05-08 04:15:37,https://api.github.com/repos/hyperledger/caliper/pulls/comments/185983696,https://github.com/hyperledger/caliper/pull/47#discussion_r185983696,feihujiang
https://github.com/hyperledger/caliper/pull/47,https://github.com/hyperledger/caliper/pull/47,This annotation is wrong.,5446832ba7a0c068a83ae90b3c4c90178099c065,2018-05-04 03:19:03,185984550,"@@ -0,0 +1,363 @@
+/**
+ * Copyright 2017 HUAWEI All Rights Reserved.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * @file, batch builder definition for small bank use case.
+ **/
+
+
+'use strict';
+
+const log = require('../../../src/comm/util.js').log;
+let BatchBuilder = require('./BatchBuilder.js');
+
+/**
+ * get the list of customer ids from the list of small bank transactions
+ * @param {object} args list of small bank transactions
+ * @returns {object} list of customer ids
+ */
+function getCustomerIds(args) {
+    let cust_ids = [];
+    //Based on the payload type get the customer ids
+    switch(args.transaction_type) {
+    case 'create_account':
+    case 'deposit_checking':
+    case 'write_check':
+    case 'transact_savings':
+        cust_ids.push(args.customer_id);
+        break;
+    case 'send_payment':
+    case 'amalgamate':
+        cust_ids.push(args.source_customer_id);
+        cust_ids.push(args.dest_customer_id);
+        break;
+    default:
+        log('Error: Unknown payload type' + args.payload_type);
+        break;
+    }
+    return cust_ids;
+}
+
+/**
+ * Create the payload for create account operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createAccountPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.CREATE_ACCOUNT,
+        create_account: {
+            customer_id: args.customer_id,
+            customer_name: args.customer_name,
+            initial_savings_balance: args.initial_savings_balance,
+            initial_checking_balance: args.initial_checking_balance
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for deposit checking operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createDepositCheckingPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.DEPOSIT_CHECKING,
+        deposit_checking: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for write check operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createWriteCheckPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.WRITE_CHECK,
+        write_check: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for transact saving operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createTransactSavingsPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.TRANSACT_SAVINGS,
+        transact_savings: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for send payment operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createSendPaymentPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let sendPayment = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.SEND_PAYMENT,
+        send_payment: {
+            source_customer_id: args.source_customer_id,
+            dest_customer_id: args.dest_customer_id,
+            amount: args.amount
+        }
+    });
+    return sendPayment;
+}
+
+/**
+ * Create the protobuf payload for Amalgamate operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createAmalgamatePayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let amalgamatePayment = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.AMALGAMATE,
+        amalgamate: {
+            source_customer_id: args.source_customer_id,
+            dest_customer_id: args.dest_customer_id,
+        }
+    });
+    return amalgamatePayment;
+}
+
+/**
+ * Builds payload data which is as per the protobuf format
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function buildPayload(args) {
+    let payloadBytes;
+    //Based on the payload type construct the protobuf message
+    switch(args.transaction_type) {
+    case 'create_account':
+        payloadBytes = createAccountPayload(args);
+        break;
+    case 'deposit_checking':
+        payloadBytes = createDepositCheckingPayload(args);
+        break;
+    case 'write_check':
+        payloadBytes = createWriteCheckPayload(args);
+        break;
+    case 'transact_savings':
+        payloadBytes = createTransactSavingsPayload(args);
+        break;
+    case 'send_payment':
+        payloadBytes = createSendPaymentPayload(args);
+        break;
+    case 'amalgamate':
+        payloadBytes = createAmalgamatePayload(args);
+        break;
+    }
+    return payloadBytes;
+}
+
+/**
+ * Converts string to byte array
+ * @param {string} str string
+ * @returns {object} byte array
+ */
+function as_bytes(str) {
+    let byteArray = [];
+    for(let i = 0; i<str.length; ++i) {
+        let y = str.charCodeAt(i);
+        byteArray = byteArray.concat([y]);
+    }
+    return byteArray;
+}
+
+/**
+ * Converts byte array to hex string
+ * @param {object} buffer byte array
+ * @returns {string} hex string
+ */
+function bytes_to_hex_str(buffer) {
+    let hexStringArray = [];
+    for(let i = 0; i<buffer.length; ++i) {
+        hexStringArray = hexStringArray.concat([buffer[i].toString(16)]);
+    }
+    let hexAddress = hexStringArray.join('').toString();
+    return hexAddress;
+}
+
+/**
+ * Class responsible for building batch for small bank
+ * operations
+ */
+class SmallBankBatchBuilder extends BatchBuilder {
+
+    /**
+     * @param {string} fName transaction family name
+     * @param {string} fVersion transaction family version
+     */
+    constructor(fName, fVersion) {
+        super();
+        this.familyName = fName;
+        this.familyVersion = fVersion;
+    }
+    /**
+     * Calculate the address using account number. It uses 64 bytes from family name
+     * and 6 character from account number.",,2018-05-08 04:15:37,https://api.github.com/repos/hyperledger/caliper/pulls/comments/185984550,https://github.com/hyperledger/caliper/pull/47#discussion_r185984550,feihujiang
https://github.com/hyperledger/caliper/pull/47,https://github.com/hyperledger/caliper/pull/47,"It is up to application to validate authentication and authorization, since we are testing sawtooth functionality we are doing minimal validation in transaction processor to check whether sufficient balance , whether account exists or not etc.",5446832ba7a0c068a83ae90b3c4c90178099c065,2018-05-04 03:34:16,185985530,"@@ -0,0 +1,129 @@
+/**
+* Copyright 2017 Intel Corporation
+*
+* Licensed under the Apache License, Version 2.0 (the ""License"");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+syntax = ""proto3"";
+option java_multiple_files = true;
+
+option go_package = ""smallbank_pb2"";
+
+message Account {
+    // Customer ID
+    uint32 customer_id = 1;
+
+    // Customer Name
+    string customer_name = 2;
+
+    // Savings Balance (in cents to avoid float)
+    uint32 savings_balance = 3;
+
+    // Checking Balance (in cents to avoid float)
+    uint32 checking_balance = 4;
+}
+
+message SmallbankTransactionPayload {
+    message CreateAccountTransactionData {
+        // The CreateAccountTransaction creates an account
+
+        // Customer ID
+        uint32 customer_id = 1;
+
+        // Customer Name
+        string customer_name = 2;
+
+        // Initial Savings Balance (in cents to avoid float)
+        uint32 initial_savings_balance = 3;
+
+        // Initial Checking Balance (in cents to avoid float)
+        uint32 initial_checking_balance = 4;
+    }
+
+    message DepositCheckingTransactionData {
+        // The DepositCheckingTransction adds an amount to the customer's
+        // checking account.
+
+        // Customer ID
+        uint32 customer_id = 1;
+
+        // Amount
+        uint32 amount = 2;
+    }
+
+    message WriteCheckTransactionData {",64,2018-05-08 04:15:37,https://api.github.com/repos/hyperledger/caliper/pulls/comments/185985530,https://github.com/hyperledger/caliper/pull/47#discussion_r185985530,Ram-srini
https://github.com/hyperledger/caliper/pull/47,https://github.com/hyperledger/caliper/pull/47,I think we don't need to new a signer each time when building a batch.,5446832ba7a0c068a83ae90b3c4c90178099c065,2018-05-04 03:35:34,185985642,"@@ -0,0 +1,363 @@
+/**
+ * Copyright 2017 HUAWEI All Rights Reserved.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * @file, batch builder definition for small bank use case.
+ **/
+
+
+'use strict';
+
+const log = require('../../../src/comm/util.js').log;
+let BatchBuilder = require('./BatchBuilder.js');
+
+/**
+ * get the list of customer ids from the list of small bank transactions
+ * @param {object} args list of small bank transactions
+ * @returns {object} list of customer ids
+ */
+function getCustomerIds(args) {
+    let cust_ids = [];
+    //Based on the payload type get the customer ids
+    switch(args.transaction_type) {
+    case 'create_account':
+    case 'deposit_checking':
+    case 'write_check':
+    case 'transact_savings':
+        cust_ids.push(args.customer_id);
+        break;
+    case 'send_payment':
+    case 'amalgamate':
+        cust_ids.push(args.source_customer_id);
+        cust_ids.push(args.dest_customer_id);
+        break;
+    default:
+        log('Error: Unknown payload type' + args.payload_type);
+        break;
+    }
+    return cust_ids;
+}
+
+/**
+ * Create the payload for create account operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createAccountPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.CREATE_ACCOUNT,
+        create_account: {
+            customer_id: args.customer_id,
+            customer_name: args.customer_name,
+            initial_savings_balance: args.initial_savings_balance,
+            initial_checking_balance: args.initial_checking_balance
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for deposit checking operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createDepositCheckingPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.DEPOSIT_CHECKING,
+        deposit_checking: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for write check operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createWriteCheckPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.WRITE_CHECK,
+        write_check: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for transact saving operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createTransactSavingsPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.TRANSACT_SAVINGS,
+        transact_savings: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for send payment operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createSendPaymentPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let sendPayment = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.SEND_PAYMENT,
+        send_payment: {
+            source_customer_id: args.source_customer_id,
+            dest_customer_id: args.dest_customer_id,
+            amount: args.amount
+        }
+    });
+    return sendPayment;
+}
+
+/**
+ * Create the protobuf payload for Amalgamate operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createAmalgamatePayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let amalgamatePayment = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.AMALGAMATE,
+        amalgamate: {
+            source_customer_id: args.source_customer_id,
+            dest_customer_id: args.dest_customer_id,
+        }
+    });
+    return amalgamatePayment;
+}
+
+/**
+ * Builds payload data which is as per the protobuf format
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function buildPayload(args) {
+    let payloadBytes;
+    //Based on the payload type construct the protobuf message
+    switch(args.transaction_type) {
+    case 'create_account':
+        payloadBytes = createAccountPayload(args);
+        break;
+    case 'deposit_checking':
+        payloadBytes = createDepositCheckingPayload(args);
+        break;
+    case 'write_check':
+        payloadBytes = createWriteCheckPayload(args);
+        break;
+    case 'transact_savings':
+        payloadBytes = createTransactSavingsPayload(args);
+        break;
+    case 'send_payment':
+        payloadBytes = createSendPaymentPayload(args);
+        break;
+    case 'amalgamate':
+        payloadBytes = createAmalgamatePayload(args);
+        break;
+    }
+    return payloadBytes;
+}
+
+/**
+ * Converts string to byte array
+ * @param {string} str string
+ * @returns {object} byte array
+ */
+function as_bytes(str) {
+    let byteArray = [];
+    for(let i = 0; i<str.length; ++i) {
+        let y = str.charCodeAt(i);
+        byteArray = byteArray.concat([y]);
+    }
+    return byteArray;
+}
+
+/**
+ * Converts byte array to hex string
+ * @param {object} buffer byte array
+ * @returns {string} hex string
+ */
+function bytes_to_hex_str(buffer) {
+    let hexStringArray = [];
+    for(let i = 0; i<buffer.length; ++i) {
+        hexStringArray = hexStringArray.concat([buffer[i].toString(16)]);
+    }
+    let hexAddress = hexStringArray.join('').toString();
+    return hexAddress;
+}
+
+/**
+ * Class responsible for building batch for small bank
+ * operations
+ */
+class SmallBankBatchBuilder extends BatchBuilder {
+
+    /**
+     * @param {string} fName transaction family name
+     * @param {string} fVersion transaction family version
+     */
+    constructor(fName, fVersion) {
+        super();
+        this.familyName = fName;
+        this.familyVersion = fVersion;
+    }
+    /**
+     * Calculate the address using account number. It uses 64 bytes from family name
+     * and 6 character from account number.
+     * @param {number} accNumber customer id
+     * @returns {string} state address
+     */
+    calculateAddress(accNumber) {
+        //Generate byte array from customer id
+        let byteArray = as_bytes(accNumber.toString());
+        const crypto = require('crypto');
+        const _hash = (x) =>
+            crypto.createHash('sha512').update(x).digest('hex');
+
+        //convert the hash bytes to hex sring
+        let hexAddress = bytes_to_hex_str(_hash(Buffer.from(byteArray)));
+
+        const familyNameSpace = _hash(this.familyName).substring(0, 6);
+        let address = familyNameSpace + hexAddress.substring(0,64);
+        return address;
+    }
+
+    /**
+     * It is same as calculateAddress but calculates multiple address at a time.
+     * and 6 character from account number.
+     * @param {number} args array of account numbers
+     * @returns {string} list valid state addresses
+     */
+    calculateAddresses(args) {
+        let addresses = [];
+        for (let key in args) {
+            let address = this.calculateAddress(key);
+            addresses.push(address);
+        }
+        return addresses;
+    }
+
+    /**
+     * Create the sawtooth transaction from small bank payload
+     * @param {object} args small bank payload
+     * @param {object} signer used for signing transaction
+     * @returns {object} transaction object
+     */
+    buildTransaction(args, signer) {
+        const {createHash} = require('crypto');
+        const {protobuf} = require('sawtooth-sdk');
+
+        //get customer ids from the argument and calculate the addresses from
+        //customer ids
+        let ids = getCustomerIds(args);
+        let in_address = this.calculateAddress(ids[0]);
+        let input_address=[in_address];
+        let output_address=[in_address];
+        if(ids.length === 2) {
+            let out_address = this.calculateAddress(ids[1]);
+            input_address.push(out_address);
+            output_address.push(out_address);
+        }
+        //Generate protobuf payload from input args
+        const payloadBytes = buildPayload(args);
+
+        //Construct transaction header
+        const transactionHeaderBytes = protobuf.TransactionHeader.encode({
+            familyName: this.familyName,
+            familyVersion: this.familyVersion,
+            inputs: input_address,
+            outputs: output_address,
+            signerPublicKey: signer.getPublicKey().asHex(),
+            batcherPublicKey: signer.getPublicKey().asHex(),
+            dependencies: [],
+            payloadSha512: createHash('sha512').update(payloadBytes).digest('hex')
+        }).finish();
+
+        //construct transaction
+        const txnSignature = signer.sign(transactionHeaderBytes);
+        const transaction = protobuf.Transaction.create({
+            header: transactionHeaderBytes,
+            headerSignature: txnSignature,
+            payload: payloadBytes
+        });
+        return transaction;
+    }
+
+    /**
+     * Builds sawtooth batch from list of small bank transactions
+     * @param {object} args list smallbank transactions
+     * @returns {object} batch list bytes
+     */
+    buildBatch(args) {
+        const {createContext, CryptoFactory} = require('sawtooth-sdk/signing');
+        const context = createContext('secp256k1');
+        const {protobuf} = require('sawtooth-sdk');
+
+        const privateKey = context.newRandomPrivateKey();
+        const signer = new CryptoFactory(context).newSigner(privateKey);",332,2018-05-08 04:15:37,https://api.github.com/repos/hyperledger/caliper/pulls/comments/185985642,https://github.com/hyperledger/caliper/pull/47#discussion_r185985642,feihujiang
https://github.com/hyperledger/caliper/pull/47,https://github.com/hyperledger/caliper/pull/47,"I am using one random signing key per batch, it means all transactions are signed with one signing key. In really world scenario each account holder has to sign there transactions to authorize.",5446832ba7a0c068a83ae90b3c4c90178099c065,2018-05-04 03:43:55,185986206,"@@ -0,0 +1,363 @@
+/**
+ * Copyright 2017 HUAWEI All Rights Reserved.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * @file, batch builder definition for small bank use case.
+ **/
+
+
+'use strict';
+
+const log = require('../../../src/comm/util.js').log;
+let BatchBuilder = require('./BatchBuilder.js');
+
+/**
+ * get the list of customer ids from the list of small bank transactions
+ * @param {object} args list of small bank transactions
+ * @returns {object} list of customer ids
+ */
+function getCustomerIds(args) {
+    let cust_ids = [];
+    //Based on the payload type get the customer ids
+    switch(args.transaction_type) {
+    case 'create_account':
+    case 'deposit_checking':
+    case 'write_check':
+    case 'transact_savings':
+        cust_ids.push(args.customer_id);
+        break;
+    case 'send_payment':
+    case 'amalgamate':
+        cust_ids.push(args.source_customer_id);
+        cust_ids.push(args.dest_customer_id);
+        break;
+    default:
+        log('Error: Unknown payload type' + args.payload_type);
+        break;
+    }
+    return cust_ids;
+}
+
+/**
+ * Create the payload for create account operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createAccountPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.CREATE_ACCOUNT,
+        create_account: {
+            customer_id: args.customer_id,
+            customer_name: args.customer_name,
+            initial_savings_balance: args.initial_savings_balance,
+            initial_checking_balance: args.initial_checking_balance
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for deposit checking operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createDepositCheckingPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.DEPOSIT_CHECKING,
+        deposit_checking: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for write check operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createWriteCheckPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.WRITE_CHECK,
+        write_check: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for transact saving operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createTransactSavingsPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.TRANSACT_SAVINGS,
+        transact_savings: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for send payment operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createSendPaymentPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let sendPayment = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.SEND_PAYMENT,
+        send_payment: {
+            source_customer_id: args.source_customer_id,
+            dest_customer_id: args.dest_customer_id,
+            amount: args.amount
+        }
+    });
+    return sendPayment;
+}
+
+/**
+ * Create the protobuf payload for Amalgamate operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createAmalgamatePayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let amalgamatePayment = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.AMALGAMATE,
+        amalgamate: {
+            source_customer_id: args.source_customer_id,
+            dest_customer_id: args.dest_customer_id,
+        }
+    });
+    return amalgamatePayment;
+}
+
+/**
+ * Builds payload data which is as per the protobuf format
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function buildPayload(args) {
+    let payloadBytes;
+    //Based on the payload type construct the protobuf message
+    switch(args.transaction_type) {
+    case 'create_account':
+        payloadBytes = createAccountPayload(args);
+        break;
+    case 'deposit_checking':
+        payloadBytes = createDepositCheckingPayload(args);
+        break;
+    case 'write_check':
+        payloadBytes = createWriteCheckPayload(args);
+        break;
+    case 'transact_savings':
+        payloadBytes = createTransactSavingsPayload(args);
+        break;
+    case 'send_payment':
+        payloadBytes = createSendPaymentPayload(args);
+        break;
+    case 'amalgamate':
+        payloadBytes = createAmalgamatePayload(args);
+        break;
+    }
+    return payloadBytes;
+}
+
+/**
+ * Converts string to byte array
+ * @param {string} str string
+ * @returns {object} byte array
+ */
+function as_bytes(str) {
+    let byteArray = [];
+    for(let i = 0; i<str.length; ++i) {
+        let y = str.charCodeAt(i);
+        byteArray = byteArray.concat([y]);
+    }
+    return byteArray;
+}
+
+/**
+ * Converts byte array to hex string
+ * @param {object} buffer byte array
+ * @returns {string} hex string
+ */
+function bytes_to_hex_str(buffer) {
+    let hexStringArray = [];
+    for(let i = 0; i<buffer.length; ++i) {
+        hexStringArray = hexStringArray.concat([buffer[i].toString(16)]);
+    }
+    let hexAddress = hexStringArray.join('').toString();
+    return hexAddress;
+}
+
+/**
+ * Class responsible for building batch for small bank
+ * operations
+ */
+class SmallBankBatchBuilder extends BatchBuilder {
+
+    /**
+     * @param {string} fName transaction family name
+     * @param {string} fVersion transaction family version
+     */
+    constructor(fName, fVersion) {
+        super();
+        this.familyName = fName;
+        this.familyVersion = fVersion;
+    }
+    /**
+     * Calculate the address using account number. It uses 64 bytes from family name
+     * and 6 character from account number.
+     * @param {number} accNumber customer id
+     * @returns {string} state address
+     */
+    calculateAddress(accNumber) {
+        //Generate byte array from customer id
+        let byteArray = as_bytes(accNumber.toString());
+        const crypto = require('crypto');
+        const _hash = (x) =>
+            crypto.createHash('sha512').update(x).digest('hex');
+
+        //convert the hash bytes to hex sring
+        let hexAddress = bytes_to_hex_str(_hash(Buffer.from(byteArray)));
+
+        const familyNameSpace = _hash(this.familyName).substring(0, 6);
+        let address = familyNameSpace + hexAddress.substring(0,64);
+        return address;
+    }
+
+    /**
+     * It is same as calculateAddress but calculates multiple address at a time.
+     * and 6 character from account number.
+     * @param {number} args array of account numbers
+     * @returns {string} list valid state addresses
+     */
+    calculateAddresses(args) {
+        let addresses = [];
+        for (let key in args) {
+            let address = this.calculateAddress(key);
+            addresses.push(address);
+        }
+        return addresses;
+    }
+
+    /**
+     * Create the sawtooth transaction from small bank payload
+     * @param {object} args small bank payload
+     * @param {object} signer used for signing transaction
+     * @returns {object} transaction object
+     */
+    buildTransaction(args, signer) {
+        const {createHash} = require('crypto');
+        const {protobuf} = require('sawtooth-sdk');
+
+        //get customer ids from the argument and calculate the addresses from
+        //customer ids
+        let ids = getCustomerIds(args);
+        let in_address = this.calculateAddress(ids[0]);
+        let input_address=[in_address];
+        let output_address=[in_address];
+        if(ids.length === 2) {
+            let out_address = this.calculateAddress(ids[1]);
+            input_address.push(out_address);
+            output_address.push(out_address);
+        }
+        //Generate protobuf payload from input args
+        const payloadBytes = buildPayload(args);
+
+        //Construct transaction header
+        const transactionHeaderBytes = protobuf.TransactionHeader.encode({
+            familyName: this.familyName,
+            familyVersion: this.familyVersion,
+            inputs: input_address,
+            outputs: output_address,
+            signerPublicKey: signer.getPublicKey().asHex(),
+            batcherPublicKey: signer.getPublicKey().asHex(),
+            dependencies: [],
+            payloadSha512: createHash('sha512').update(payloadBytes).digest('hex')
+        }).finish();
+
+        //construct transaction
+        const txnSignature = signer.sign(transactionHeaderBytes);
+        const transaction = protobuf.Transaction.create({
+            header: transactionHeaderBytes,
+            headerSignature: txnSignature,
+            payload: payloadBytes
+        });
+        return transaction;
+    }
+
+    /**
+     * Builds sawtooth batch from list of small bank transactions
+     * @param {object} args list smallbank transactions
+     * @returns {object} batch list bytes
+     */
+    buildBatch(args) {
+        const {createContext, CryptoFactory} = require('sawtooth-sdk/signing');
+        const context = createContext('secp256k1');
+        const {protobuf} = require('sawtooth-sdk');
+
+        const privateKey = context.newRandomPrivateKey();
+        const signer = new CryptoFactory(context).newSigner(privateKey);",332,2018-05-08 04:15:37,https://api.github.com/repos/hyperledger/caliper/pulls/comments/185986206,https://github.com/hyperledger/caliper/pull/47#discussion_r185986206,Ram-srini
https://github.com/hyperledger/caliper/pull/47,https://github.com/hyperledger/caliper/pull/47,What is wrong here?,5446832ba7a0c068a83ae90b3c4c90178099c065,2018-05-04 03:44:35,185986249,"@@ -0,0 +1,363 @@
+/**
+ * Copyright 2017 HUAWEI All Rights Reserved.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * @file, batch builder definition for small bank use case.
+ **/
+
+
+'use strict';
+
+const log = require('../../../src/comm/util.js').log;
+let BatchBuilder = require('./BatchBuilder.js');
+
+/**
+ * get the list of customer ids from the list of small bank transactions
+ * @param {object} args list of small bank transactions
+ * @returns {object} list of customer ids
+ */
+function getCustomerIds(args) {
+    let cust_ids = [];
+    //Based on the payload type get the customer ids
+    switch(args.transaction_type) {
+    case 'create_account':
+    case 'deposit_checking':
+    case 'write_check':
+    case 'transact_savings':
+        cust_ids.push(args.customer_id);
+        break;
+    case 'send_payment':
+    case 'amalgamate':
+        cust_ids.push(args.source_customer_id);
+        cust_ids.push(args.dest_customer_id);
+        break;
+    default:
+        log('Error: Unknown payload type' + args.payload_type);
+        break;
+    }
+    return cust_ids;
+}
+
+/**
+ * Create the payload for create account operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createAccountPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.CREATE_ACCOUNT,
+        create_account: {
+            customer_id: args.customer_id,
+            customer_name: args.customer_name,
+            initial_savings_balance: args.initial_savings_balance,
+            initial_checking_balance: args.initial_checking_balance
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for deposit checking operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createDepositCheckingPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.DEPOSIT_CHECKING,
+        deposit_checking: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for write check operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createWriteCheckPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.WRITE_CHECK,
+        write_check: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for transact saving operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createTransactSavingsPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.TRANSACT_SAVINGS,
+        transact_savings: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for send payment operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createSendPaymentPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let sendPayment = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.SEND_PAYMENT,
+        send_payment: {
+            source_customer_id: args.source_customer_id,
+            dest_customer_id: args.dest_customer_id,
+            amount: args.amount
+        }
+    });
+    return sendPayment;
+}
+
+/**
+ * Create the protobuf payload for Amalgamate operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createAmalgamatePayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let amalgamatePayment = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.AMALGAMATE,
+        amalgamate: {
+            source_customer_id: args.source_customer_id,
+            dest_customer_id: args.dest_customer_id,
+        }
+    });
+    return amalgamatePayment;
+}
+
+/**
+ * Builds payload data which is as per the protobuf format
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function buildPayload(args) {
+    let payloadBytes;
+    //Based on the payload type construct the protobuf message
+    switch(args.transaction_type) {
+    case 'create_account':
+        payloadBytes = createAccountPayload(args);
+        break;
+    case 'deposit_checking':
+        payloadBytes = createDepositCheckingPayload(args);
+        break;
+    case 'write_check':
+        payloadBytes = createWriteCheckPayload(args);
+        break;
+    case 'transact_savings':
+        payloadBytes = createTransactSavingsPayload(args);
+        break;
+    case 'send_payment':
+        payloadBytes = createSendPaymentPayload(args);
+        break;
+    case 'amalgamate':
+        payloadBytes = createAmalgamatePayload(args);
+        break;
+    }
+    return payloadBytes;
+}
+
+/**
+ * Converts string to byte array
+ * @param {string} str string
+ * @returns {object} byte array
+ */
+function as_bytes(str) {
+    let byteArray = [];
+    for(let i = 0; i<str.length; ++i) {
+        let y = str.charCodeAt(i);
+        byteArray = byteArray.concat([y]);
+    }
+    return byteArray;
+}
+
+/**
+ * Converts byte array to hex string
+ * @param {object} buffer byte array
+ * @returns {string} hex string
+ */
+function bytes_to_hex_str(buffer) {
+    let hexStringArray = [];
+    for(let i = 0; i<buffer.length; ++i) {
+        hexStringArray = hexStringArray.concat([buffer[i].toString(16)]);
+    }
+    let hexAddress = hexStringArray.join('').toString();
+    return hexAddress;
+}
+
+/**
+ * Class responsible for building batch for small bank
+ * operations
+ */
+class SmallBankBatchBuilder extends BatchBuilder {
+
+    /**
+     * @param {string} fName transaction family name
+     * @param {string} fVersion transaction family version
+     */
+    constructor(fName, fVersion) {
+        super();
+        this.familyName = fName;
+        this.familyVersion = fVersion;
+    }
+    /**
+     * Calculate the address using account number. It uses 64 bytes from family name
+     * and 6 character from account number.",,2018-05-08 04:15:37,https://api.github.com/repos/hyperledger/caliper/pulls/comments/185986249,https://github.com/hyperledger/caliper/pull/47#discussion_r185986249,Ram-srini
https://github.com/hyperledger/caliper/pull/47,https://github.com/hyperledger/caliper/pull/47,"""It uses 64 bytes from family name and 6 character from account num"" is wrong.",5446832ba7a0c068a83ae90b3c4c90178099c065,2018-05-04 06:12:26,185996744,"@@ -0,0 +1,363 @@
+/**
+ * Copyright 2017 HUAWEI All Rights Reserved.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * @file, batch builder definition for small bank use case.
+ **/
+
+
+'use strict';
+
+const log = require('../../../src/comm/util.js').log;
+let BatchBuilder = require('./BatchBuilder.js');
+
+/**
+ * get the list of customer ids from the list of small bank transactions
+ * @param {object} args list of small bank transactions
+ * @returns {object} list of customer ids
+ */
+function getCustomerIds(args) {
+    let cust_ids = [];
+    //Based on the payload type get the customer ids
+    switch(args.transaction_type) {
+    case 'create_account':
+    case 'deposit_checking':
+    case 'write_check':
+    case 'transact_savings':
+        cust_ids.push(args.customer_id);
+        break;
+    case 'send_payment':
+    case 'amalgamate':
+        cust_ids.push(args.source_customer_id);
+        cust_ids.push(args.dest_customer_id);
+        break;
+    default:
+        log('Error: Unknown payload type' + args.payload_type);
+        break;
+    }
+    return cust_ids;
+}
+
+/**
+ * Create the payload for create account operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createAccountPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.CREATE_ACCOUNT,
+        create_account: {
+            customer_id: args.customer_id,
+            customer_name: args.customer_name,
+            initial_savings_balance: args.initial_savings_balance,
+            initial_checking_balance: args.initial_checking_balance
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for deposit checking operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createDepositCheckingPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.DEPOSIT_CHECKING,
+        deposit_checking: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for write check operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createWriteCheckPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.WRITE_CHECK,
+        write_check: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for transact saving operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createTransactSavingsPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.TRANSACT_SAVINGS,
+        transact_savings: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for send payment operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createSendPaymentPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let sendPayment = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.SEND_PAYMENT,
+        send_payment: {
+            source_customer_id: args.source_customer_id,
+            dest_customer_id: args.dest_customer_id,
+            amount: args.amount
+        }
+    });
+    return sendPayment;
+}
+
+/**
+ * Create the protobuf payload for Amalgamate operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createAmalgamatePayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let amalgamatePayment = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.AMALGAMATE,
+        amalgamate: {
+            source_customer_id: args.source_customer_id,
+            dest_customer_id: args.dest_customer_id,
+        }
+    });
+    return amalgamatePayment;
+}
+
+/**
+ * Builds payload data which is as per the protobuf format
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function buildPayload(args) {
+    let payloadBytes;
+    //Based on the payload type construct the protobuf message
+    switch(args.transaction_type) {
+    case 'create_account':
+        payloadBytes = createAccountPayload(args);
+        break;
+    case 'deposit_checking':
+        payloadBytes = createDepositCheckingPayload(args);
+        break;
+    case 'write_check':
+        payloadBytes = createWriteCheckPayload(args);
+        break;
+    case 'transact_savings':
+        payloadBytes = createTransactSavingsPayload(args);
+        break;
+    case 'send_payment':
+        payloadBytes = createSendPaymentPayload(args);
+        break;
+    case 'amalgamate':
+        payloadBytes = createAmalgamatePayload(args);
+        break;
+    }
+    return payloadBytes;
+}
+
+/**
+ * Converts string to byte array
+ * @param {string} str string
+ * @returns {object} byte array
+ */
+function as_bytes(str) {
+    let byteArray = [];
+    for(let i = 0; i<str.length; ++i) {
+        let y = str.charCodeAt(i);
+        byteArray = byteArray.concat([y]);
+    }
+    return byteArray;
+}
+
+/**
+ * Converts byte array to hex string
+ * @param {object} buffer byte array
+ * @returns {string} hex string
+ */
+function bytes_to_hex_str(buffer) {
+    let hexStringArray = [];
+    for(let i = 0; i<buffer.length; ++i) {
+        hexStringArray = hexStringArray.concat([buffer[i].toString(16)]);
+    }
+    let hexAddress = hexStringArray.join('').toString();
+    return hexAddress;
+}
+
+/**
+ * Class responsible for building batch for small bank
+ * operations
+ */
+class SmallBankBatchBuilder extends BatchBuilder {
+
+    /**
+     * @param {string} fName transaction family name
+     * @param {string} fVersion transaction family version
+     */
+    constructor(fName, fVersion) {
+        super();
+        this.familyName = fName;
+        this.familyVersion = fVersion;
+    }
+    /**
+     * Calculate the address using account number. It uses 64 bytes from family name
+     * and 6 character from account number.",,2018-05-08 04:15:37,https://api.github.com/repos/hyperledger/caliper/pulls/comments/185996744,https://github.com/hyperledger/caliper/pull/47#discussion_r185996744,feihujiang
https://github.com/hyperledger/caliper/pull/47,https://github.com/hyperledger/caliper/pull/47,I got it.,5446832ba7a0c068a83ae90b3c4c90178099c065,2018-05-04 06:13:02,185996801,"@@ -0,0 +1,129 @@
+/**
+* Copyright 2017 Intel Corporation
+*
+* Licensed under the Apache License, Version 2.0 (the ""License"");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an ""AS IS"" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+syntax = ""proto3"";
+option java_multiple_files = true;
+
+option go_package = ""smallbank_pb2"";
+
+message Account {
+    // Customer ID
+    uint32 customer_id = 1;
+
+    // Customer Name
+    string customer_name = 2;
+
+    // Savings Balance (in cents to avoid float)
+    uint32 savings_balance = 3;
+
+    // Checking Balance (in cents to avoid float)
+    uint32 checking_balance = 4;
+}
+
+message SmallbankTransactionPayload {
+    message CreateAccountTransactionData {
+        // The CreateAccountTransaction creates an account
+
+        // Customer ID
+        uint32 customer_id = 1;
+
+        // Customer Name
+        string customer_name = 2;
+
+        // Initial Savings Balance (in cents to avoid float)
+        uint32 initial_savings_balance = 3;
+
+        // Initial Checking Balance (in cents to avoid float)
+        uint32 initial_checking_balance = 4;
+    }
+
+    message DepositCheckingTransactionData {
+        // The DepositCheckingTransction adds an amount to the customer's
+        // checking account.
+
+        // Customer ID
+        uint32 customer_id = 1;
+
+        // Amount
+        uint32 amount = 2;
+    }
+
+    message WriteCheckTransactionData {",64,2018-05-08 04:15:37,https://api.github.com/repos/hyperledger/caliper/pulls/comments/185996801,https://github.com/hyperledger/caliper/pull/47#discussion_r185996801,feihujiang
https://github.com/hyperledger/caliper/pull/47,https://github.com/hyperledger/caliper/pull/47,"So the container is used by users to interact with validators, but it isn't the mandatory container for the benchmark use case?",5446832ba7a0c068a83ae90b3c4c90178099c065,2018-05-04 06:24:49,185997936,"@@ -0,0 +1,79 @@
+# Copyright 2017 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+# ------------------------------------------------------------------------------
+
+version: ""2.1""
+
+services:
+
+  settings-tp:
+    image: hyperledger/sawtooth-settings-tp:latest
+    container_name: sawtooth-settings-tp-default
+    depends_on:
+      - validator
+    entrypoint: settings-tp -vv -C tcp://validator:4004
+
+  smallbank-tp-go:
+    image: hyperledger/sawtooth-smallbank-tp-go:latest
+    container_name: sawtooth-smallbank-tp-go-default
+    depends_on:
+      - validator
+    entrypoint: smallbank-tp-go -vv -C tcp://validator:4004
+
+  validator:
+    image: hyperledger/sawtooth-validator:latest
+    container_name: sawtooth-validator-default
+    expose:
+      - 4004
+    ports:
+      - ""4004:4004""
+    # start the validator with an empty genesis batch
+    entrypoint: ""bash -c \""\
+        sawadm keygen && \
+        sawtooth keygen my_key && \
+        sawset genesis -k /root/.sawtooth/keys/my_key.priv && \
+        sawadm genesis config-genesis.batch && \
+        sawtooth-validator -vv \
+          --endpoint tcp://validator:8800 \
+          --bind component:tcp://eth0:4004 \
+          --bind network:tcp://eth0:8800 \
+        \""""
+
+  rest-api:
+    image: hyperledger/sawtooth-rest-api:latest
+    container_name: sawtooth-rest-api-default
+    expose:
+      - 8008
+    ports:
+      - ""8008:8008""
+    depends_on:
+      - validator
+    entrypoint: sawtooth-rest-api -vvv -C tcp://validator:4004 --bind rest-api:8008
+
+  shell:",,2018-05-08 04:15:37,https://api.github.com/repos/hyperledger/caliper/pulls/comments/185997936,https://github.com/hyperledger/caliper/pull/47#discussion_r185997936,feihujiang
https://github.com/hyperledger/caliper/pull/47,https://github.com/hyperledger/caliper/pull/47,Ok.,5446832ba7a0c068a83ae90b3c4c90178099c065,2018-05-04 06:33:39,185998936,"@@ -0,0 +1,363 @@
+/**
+ * Copyright 2017 HUAWEI All Rights Reserved.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * @file, batch builder definition for small bank use case.
+ **/
+
+
+'use strict';
+
+const log = require('../../../src/comm/util.js').log;
+let BatchBuilder = require('./BatchBuilder.js');
+
+/**
+ * get the list of customer ids from the list of small bank transactions
+ * @param {object} args list of small bank transactions
+ * @returns {object} list of customer ids
+ */
+function getCustomerIds(args) {
+    let cust_ids = [];
+    //Based on the payload type get the customer ids
+    switch(args.transaction_type) {
+    case 'create_account':
+    case 'deposit_checking':
+    case 'write_check':
+    case 'transact_savings':
+        cust_ids.push(args.customer_id);
+        break;
+    case 'send_payment':
+    case 'amalgamate':
+        cust_ids.push(args.source_customer_id);
+        cust_ids.push(args.dest_customer_id);
+        break;
+    default:
+        log('Error: Unknown payload type' + args.payload_type);
+        break;
+    }
+    return cust_ids;
+}
+
+/**
+ * Create the payload for create account operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createAccountPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.CREATE_ACCOUNT,
+        create_account: {
+            customer_id: args.customer_id,
+            customer_name: args.customer_name,
+            initial_savings_balance: args.initial_savings_balance,
+            initial_checking_balance: args.initial_checking_balance
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for deposit checking operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createDepositCheckingPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.DEPOSIT_CHECKING,
+        deposit_checking: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for write check operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createWriteCheckPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.WRITE_CHECK,
+        write_check: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for transact saving operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createTransactSavingsPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let account = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.TRANSACT_SAVINGS,
+        transact_savings: {
+            customer_id: args.customer_id,
+            amount: args.amount
+        }
+    });
+    return account;
+}
+
+/**
+ * Create the protobuf payload for send payment operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createSendPaymentPayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let sendPayment = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.SEND_PAYMENT,
+        send_payment: {
+            source_customer_id: args.source_customer_id,
+            dest_customer_id: args.dest_customer_id,
+            amount: args.amount
+        }
+    });
+    return sendPayment;
+}
+
+/**
+ * Create the protobuf payload for Amalgamate operation
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function createAmalgamatePayload(args) {
+    let protobuf = require('protocol-buffers');
+    let fs = require('fs');
+    let root = protobuf(fs.readFileSync('./protos/smallbank.proto'));
+
+    let amalgamatePayment = root.SmallbankTransactionPayload.encode({
+        payload_type: root.SmallbankTransactionPayload.PayloadType.AMALGAMATE,
+        amalgamate: {
+            source_customer_id: args.source_customer_id,
+            dest_customer_id: args.dest_customer_id,
+        }
+    });
+    return amalgamatePayment;
+}
+
+/**
+ * Builds payload data which is as per the protobuf format
+ * @param {object} args small bank transaction
+ * @returns {object} payload data
+ */
+function buildPayload(args) {
+    let payloadBytes;
+    //Based on the payload type construct the protobuf message
+    switch(args.transaction_type) {
+    case 'create_account':
+        payloadBytes = createAccountPayload(args);
+        break;
+    case 'deposit_checking':
+        payloadBytes = createDepositCheckingPayload(args);
+        break;
+    case 'write_check':
+        payloadBytes = createWriteCheckPayload(args);
+        break;
+    case 'transact_savings':
+        payloadBytes = createTransactSavingsPayload(args);
+        break;
+    case 'send_payment':
+        payloadBytes = createSendPaymentPayload(args);
+        break;
+    case 'amalgamate':
+        payloadBytes = createAmalgamatePayload(args);
+        break;
+    }
+    return payloadBytes;
+}
+
+/**
+ * Converts string to byte array
+ * @param {string} str string
+ * @returns {object} byte array
+ */
+function as_bytes(str) {
+    let byteArray = [];
+    for(let i = 0; i<str.length; ++i) {
+        let y = str.charCodeAt(i);
+        byteArray = byteArray.concat([y]);
+    }
+    return byteArray;
+}
+
+/**
+ * Converts byte array to hex string
+ * @param {object} buffer byte array
+ * @returns {string} hex string
+ */
+function bytes_to_hex_str(buffer) {
+    let hexStringArray = [];
+    for(let i = 0; i<buffer.length; ++i) {
+        hexStringArray = hexStringArray.concat([buffer[i].toString(16)]);
+    }
+    let hexAddress = hexStringArray.join('').toString();
+    return hexAddress;
+}
+
+/**
+ * Class responsible for building batch for small bank
+ * operations
+ */
+class SmallBankBatchBuilder extends BatchBuilder {
+
+    /**
+     * @param {string} fName transaction family name
+     * @param {string} fVersion transaction family version
+     */
+    constructor(fName, fVersion) {
+        super();
+        this.familyName = fName;
+        this.familyVersion = fVersion;
+    }
+    /**
+     * Calculate the address using account number. It uses 64 bytes from family name
+     * and 6 character from account number.
+     * @param {number} accNumber customer id
+     * @returns {string} state address
+     */
+    calculateAddress(accNumber) {
+        //Generate byte array from customer id
+        let byteArray = as_bytes(accNumber.toString());
+        const crypto = require('crypto');
+        const _hash = (x) =>
+            crypto.createHash('sha512').update(x).digest('hex');
+
+        //convert the hash bytes to hex sring
+        let hexAddress = bytes_to_hex_str(_hash(Buffer.from(byteArray)));
+
+        const familyNameSpace = _hash(this.familyName).substring(0, 6);
+        let address = familyNameSpace + hexAddress.substring(0,64);
+        return address;
+    }
+
+    /**
+     * It is same as calculateAddress but calculates multiple address at a time.
+     * and 6 character from account number.
+     * @param {number} args array of account numbers
+     * @returns {string} list valid state addresses
+     */
+    calculateAddresses(args) {
+        let addresses = [];
+        for (let key in args) {
+            let address = this.calculateAddress(key);
+            addresses.push(address);
+        }
+        return addresses;
+    }
+
+    /**
+     * Create the sawtooth transaction from small bank payload
+     * @param {object} args small bank payload
+     * @param {object} signer used for signing transaction
+     * @returns {object} transaction object
+     */
+    buildTransaction(args, signer) {
+        const {createHash} = require('crypto');
+        const {protobuf} = require('sawtooth-sdk');
+
+        //get customer ids from the argument and calculate the addresses from
+        //customer ids
+        let ids = getCustomerIds(args);
+        let in_address = this.calculateAddress(ids[0]);
+        let input_address=[in_address];
+        let output_address=[in_address];
+        if(ids.length === 2) {
+            let out_address = this.calculateAddress(ids[1]);
+            input_address.push(out_address);
+            output_address.push(out_address);
+        }
+        //Generate protobuf payload from input args
+        const payloadBytes = buildPayload(args);
+
+        //Construct transaction header
+        const transactionHeaderBytes = protobuf.TransactionHeader.encode({
+            familyName: this.familyName,
+            familyVersion: this.familyVersion,
+            inputs: input_address,
+            outputs: output_address,
+            signerPublicKey: signer.getPublicKey().asHex(),
+            batcherPublicKey: signer.getPublicKey().asHex(),
+            dependencies: [],
+            payloadSha512: createHash('sha512').update(payloadBytes).digest('hex')
+        }).finish();
+
+        //construct transaction
+        const txnSignature = signer.sign(transactionHeaderBytes);
+        const transaction = protobuf.Transaction.create({
+            header: transactionHeaderBytes,
+            headerSignature: txnSignature,
+            payload: payloadBytes
+        });
+        return transaction;
+    }
+
+    /**
+     * Builds sawtooth batch from list of small bank transactions
+     * @param {object} args list smallbank transactions
+     * @returns {object} batch list bytes
+     */
+    buildBatch(args) {
+        const {createContext, CryptoFactory} = require('sawtooth-sdk/signing');
+        const context = createContext('secp256k1');
+        const {protobuf} = require('sawtooth-sdk');
+
+        const privateKey = context.newRandomPrivateKey();
+        const signer = new CryptoFactory(context).newSigner(privateKey);",332,2018-05-08 04:15:37,https://api.github.com/repos/hyperledger/caliper/pulls/comments/185998936,https://github.com/hyperledger/caliper/pull/47#discussion_r185998936,feihujiang
https://github.com/hyperledger/caliper/pull/47,https://github.com/hyperledger/caliper/pull/47,"Right. Not required, I will remove it. I added to validate transactions/state after running the test.",5446832ba7a0c068a83ae90b3c4c90178099c065,2018-05-04 06:59:54,186002049,"@@ -0,0 +1,79 @@
+# Copyright 2017 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+# ------------------------------------------------------------------------------
+
+version: ""2.1""
+
+services:
+
+  settings-tp:
+    image: hyperledger/sawtooth-settings-tp:latest
+    container_name: sawtooth-settings-tp-default
+    depends_on:
+      - validator
+    entrypoint: settings-tp -vv -C tcp://validator:4004
+
+  smallbank-tp-go:
+    image: hyperledger/sawtooth-smallbank-tp-go:latest
+    container_name: sawtooth-smallbank-tp-go-default
+    depends_on:
+      - validator
+    entrypoint: smallbank-tp-go -vv -C tcp://validator:4004
+
+  validator:
+    image: hyperledger/sawtooth-validator:latest
+    container_name: sawtooth-validator-default
+    expose:
+      - 4004
+    ports:
+      - ""4004:4004""
+    # start the validator with an empty genesis batch
+    entrypoint: ""bash -c \""\
+        sawadm keygen && \
+        sawtooth keygen my_key && \
+        sawset genesis -k /root/.sawtooth/keys/my_key.priv && \
+        sawadm genesis config-genesis.batch && \
+        sawtooth-validator -vv \
+          --endpoint tcp://validator:8800 \
+          --bind component:tcp://eth0:4004 \
+          --bind network:tcp://eth0:8800 \
+        \""""
+
+  rest-api:
+    image: hyperledger/sawtooth-rest-api:latest
+    container_name: sawtooth-rest-api-default
+    expose:
+      - 8008
+    ports:
+      - ""8008:8008""
+    depends_on:
+      - validator
+    entrypoint: sawtooth-rest-api -vvv -C tcp://validator:4004 --bind rest-api:8008
+
+  shell:",,2018-05-08 04:15:37,https://api.github.com/repos/hyperledger/caliper/pulls/comments/186002049,https://github.com/hyperledger/caliper/pull/47#discussion_r186002049,Ram-srini
https://github.com/hyperledger/caliper/pull/35,https://github.com/hyperledger/caliper/pull/35,"We (Iroha team) plan to change Iroha's docker [naming](https://soramitsu.atlassian.net/browse/IR-1259) in the nearest future, so now this PR uses image `hyperledger/iroha:x86_64-develop-latest` without any sha256.

When we rename it I'll do commit in this branch with the new name of container on dockerhub.",b3e9869d9dfec808a0ead8be5a98e9520db6e9b2,2018-04-23 12:36:35,183378052,"@@ -1,8 +1,8 @@
 version: '3'
 
 services:
-  iroha_node0:
-    image: hyperledger/iroha-docker@sha256:b82a24eee7cc4215bf70d9f79acab8b817e4cf36cc9f87c1c63202dca552cf0f
+  iroha-node0:
+    image: hyperledger/iroha:x86_64-develop-latest",,2018-06-04 08:48:27,https://api.github.com/repos/hyperledger/caliper/pulls/comments/183378052,https://github.com/hyperledger/caliper/pull/35#discussion_r183378052,stinger112
https://github.com/hyperledger/caliper/pull/35,https://github.com/hyperledger/caliper/pull/35,This file should not be commited.,b3e9869d9dfec808a0ead8be5a98e9520db6e9b2,2018-06-01 08:27:11,192328860,"@@ -0,0 +1,4627 @@
+{",,2018-06-04 08:48:27,https://api.github.com/repos/hyperledger/caliper/pulls/comments/192328860,https://github.com/hyperledger/caliper/pull/35#discussion_r192328860,haojun
https://github.com/hyperledger/caliper/pull/35,https://github.com/hyperledger/caliper/pull/35,"1. what's the purpose of add npx?
2. Is grpc > 1.12 MUST be used for iroha. If not, please keep the version as 1.10.1 (we found the new version of grpc is somehow incompatible with fabric-sdk )
3. This package is for common use, so please don't add iroha's dependencies here.",b3e9869d9dfec808a0ead8be5a98e9520db6e9b2,2018-06-01 08:33:59,192330326,"@@ -24,7 +24,8 @@
     ""commander"": ""^2.11.0"",
     ""dockerode"": ""^2.5.0"",
     ""fs-extra"": ""^4.0.2"",
-    ""grpc"": ""1.10.1"",
+    ""grpc"": ""^1.12.2"",
+    ""iroha-lib"": ""^0.1.1"",",15,2018-06-04 08:48:27,https://api.github.com/repos/hyperledger/caliper/pulls/comments/192330326,https://github.com/hyperledger/caliper/pull/35#discussion_r192330326,haojun
https://github.com/hyperledger/caliper/pull/35,https://github.com/hyperledger/caliper/pull/35,"Now you can use log function from src/comm/util.js to resolve the eslint error instead of disable it.
We may extend this function later.",b3e9869d9dfec808a0ead8be5a98e9520db6e9b2,2018-06-01 08:48:18,192333754,"@@ -3,90 +3,207 @@
 *
 * SPDX-License-Identifier: Apache-2.0
 *
-* @file, definition of the Fabric class, which implements the caliper's NBI for hyperledger fabric
+* @file, definition of the Iroha class, which implements the Caliper's NBI for Hyperledger Iroha.
 */
 
+/* eslint-disable no-console */",,2018-06-04 08:48:27,https://api.github.com/repos/hyperledger/caliper/pulls/comments/192333754,https://github.com/hyperledger/caliper/pull/35#discussion_r192333754,haojun
https://github.com/hyperledger/caliper/pull/35,https://github.com/hyperledger/caliper/pull/35,"1. According to the philosophy of NPM all apps should be self-contained. If I have no globally installed ESLint or version of my installed ESLint another than specified in the package for some reason (e.g. in a case of CI), `npm test` and `npm run-script lint` may have strange behavior or even don't work at all.
So I add **npx** as script wrapper to return such functionality.
If you want to I can replace it with directly calling `./node_modules/.bin/eslint .` or even return it to the previous state.
2. grpc must not be used by Iroha, I returned it to the 1.10.1
3. **IMPORTANT!** We definitely need to add some mechanism to fix versions of used connector packages for different ledgers in order to ensure the stability of the current version of Caliper.
Exactly like we did use docker images and hashes/tags.
I think just description in Readme not enough to solve this issue, therefore I decided to fix version in the common package.json until the future improvements.
I know this not the best solution, but it is something.
If you have any ideas how to gracefully solve this problem, it would be nice!

By the way, is **grpc** in package.json not a ledger-related dependency too?
",b3e9869d9dfec808a0ead8be5a98e9520db6e9b2,2018-06-01 11:42:44,192370594,"@@ -24,7 +24,8 @@
     ""commander"": ""^2.11.0"",
     ""dockerode"": ""^2.5.0"",
     ""fs-extra"": ""^4.0.2"",
-    ""grpc"": ""1.10.1"",
+    ""grpc"": ""^1.12.2"",
+    ""iroha-lib"": ""^0.1.1"",",15,2018-06-04 08:48:27,https://api.github.com/repos/hyperledger/caliper/pulls/comments/192370594,https://github.com/hyperledger/caliper/pull/35#discussion_r192370594,stinger112
https://github.com/hyperledger/caliper/pull/34,https://github.com/hyperledger/caliper/pull/34,typo: buildiBatch / buildBatch,5ca6ba35ea0fc1b87ecf713bff0f7317ef60a96a,2018-04-23 19:56:17,183518281,"@@ -0,0 +1,17 @@
+'use strict'
+
+class BatchBuilder {
+    constructor() {
+    }
+
+    buildBatch(args) {
+        throw new Error('buildiBatch is not implemented for this application!!');",,2018-04-26 04:11:57,https://api.github.com/repos/hyperledger/caliper/pulls/comments/183518281,https://github.com/hyperledger/caliper/pull/34#discussion_r183518281,dcmiddle
https://github.com/hyperledger/caliper/pull/34,https://github.com/hyperledger/caliper/pull/34,Where is the ./SmallBankBatchBuilder.js?,5ca6ba35ea0fc1b87ecf713bff0f7317ef60a96a,2018-04-24 13:07:43,183721985,"@@ -0,0 +1,25 @@
+'use strict'
+
+var SimpleBatchBuilder = require('./SimpleBatchBuilder.js')
+var SmallBankBatchBuilder = require('./SmallBankBatchBuilder.js')
+",,2018-04-26 04:11:57,https://api.github.com/repos/hyperledger/caliper/pulls/comments/183721985,https://github.com/hyperledger/caliper/pull/34#discussion_r183721985,feihujiang
https://github.com/hyperledger/caliper/pull/34,https://github.com/hyperledger/caliper/pull/34,I will raise the PR for that later.,5ca6ba35ea0fc1b87ecf713bff0f7317ef60a96a,2018-04-24 14:21:11,183749037,"@@ -0,0 +1,25 @@
+'use strict'
+
+var SimpleBatchBuilder = require('./SimpleBatchBuilder.js')
+var SmallBankBatchBuilder = require('./SmallBankBatchBuilder.js')
+",,2018-04-26 04:11:57,https://api.github.com/repos/hyperledger/caliper/pulls/comments/183749037,https://github.com/hyperledger/caliper/pull/34#discussion_r183749037,Ram-srini
https://github.com/hyperledger/caliper/pull/34,https://github.com/hyperledger/caliper/pull/34,Should have license text.,5ca6ba35ea0fc1b87ecf713bff0f7317ef60a96a,2018-04-26 02:29:36,184256004,"@@ -0,0 +1,17 @@
+'use strict'",10,2018-04-26 04:11:57,https://api.github.com/repos/hyperledger/caliper/pulls/comments/184256004,https://github.com/hyperledger/caliper/pull/34#discussion_r184256004,feihujiang
https://github.com/hyperledger/caliper/pull/34,https://github.com/hyperledger/caliper/pull/34,Should have license text,5ca6ba35ea0fc1b87ecf713bff0f7317ef60a96a,2018-04-26 02:30:07,184256064,"@@ -0,0 +1,21 @@
+'use strict'",9,2018-04-26 04:11:57,https://api.github.com/repos/hyperledger/caliper/pulls/comments/184256064,https://github.com/hyperledger/caliper/pull/34#discussion_r184256064,feihujiang
https://github.com/hyperledger/caliper/pull/34,https://github.com/hyperledger/caliper/pull/34,Should have license text.,5ca6ba35ea0fc1b87ecf713bff0f7317ef60a96a,2018-04-26 02:30:40,184256112,"@@ -0,0 +1,77 @@
+'use strict'",10,2018-04-26 04:11:57,https://api.github.com/repos/hyperledger/caliper/pulls/comments/184256112,https://github.com/hyperledger/caliper/pull/34#discussion_r184256112,feihujiang
https://github.com/hyperledger/caliper/pull/34,https://github.com/hyperledger/caliper/pull/34,Done.,5ca6ba35ea0fc1b87ecf713bff0f7317ef60a96a,2018-04-26 04:17:06,184266856,"@@ -0,0 +1,17 @@
+'use strict'",10,2018-04-26 04:17:06,https://api.github.com/repos/hyperledger/caliper/pulls/comments/184266856,https://github.com/hyperledger/caliper/pull/34#discussion_r184266856,Ram-srini
https://github.com/hyperledger/caliper/pull/34,https://github.com/hyperledger/caliper/pull/34,Done,5ca6ba35ea0fc1b87ecf713bff0f7317ef60a96a,2018-04-26 04:17:15,184266873,"@@ -0,0 +1,21 @@
+'use strict'",9,2018-04-26 04:17:16,https://api.github.com/repos/hyperledger/caliper/pulls/comments/184266873,https://github.com/hyperledger/caliper/pull/34#discussion_r184266873,Ram-srini
https://github.com/hyperledger/caliper/pull/34,https://github.com/hyperledger/caliper/pull/34,Done,5ca6ba35ea0fc1b87ecf713bff0f7317ef60a96a,2018-04-26 04:17:22,184266885,"@@ -0,0 +1,77 @@
+'use strict'",10,2018-04-26 04:17:22,https://api.github.com/repos/hyperledger/caliper/pulls/comments/184266885,https://github.com/hyperledger/caliper/pull/34#discussion_r184266885,Ram-srini
https://github.com/hyperledger/caliper/pull/14,https://github.com/hyperledger/caliper/pull/14,Is `fabrci/src`?,cc1ceb31b1f03b4a2a79534400cfe7c5876c7371,2018-04-03 07:05:29,178730626,"@@ -0,0 +1,48 @@
+## Contributing to Hyperledger Caliper
+
+Welcome to Hyperledger Caliper project, we are excited about the prospect of you contributing. 
+
+### How to contribute
+
+We are using GitHub issues for bug reports and feature requests.
+
+If you find any bug in the source code or have any trivial changes (such as typos fix, minor feature), you can raise an issue or delivery a fix via a pull request directly.
+
+If you have any enhancement suggestions or want to help extend caliper with more DLTs or have any other major changes, please start by opening an issue first.
+That way, relevant parties (e.g. maintainers or main contributors of the relevant subsystem) can have a chance to look at it before you do any work.
+
+All PRs must get at least one review, you can ask `hyperledger/caliper-committers` for review.
+Normally we will review your contribution in one week.
+If you haven't heard from anyone in one week, feel free to @ or mail a maintainer to review it.
+
+All PRs must be signed before be merged, be sure to use `git commit -s` to commit your changes.
+   
+There is also a [RocketChat Channel](https://chat.hyperledger.org/channel/caliper) for communication, anybody is welcome to join. 
+
+### Caliper Structure
+
+For beginners of Caliper, if you want to :
+
+* Create a new test case
+
+  You should create a new folder in`caliper/benchmark` directory and include all test scripts needed in this folder.
+  A `main.js` is needed as the bootstrap for the test case. You can simply copy it from `caliper/benchmark/simple/` directory or write a new one by yourself.
+  In the latter case, the command should as least accepts two arguments(-c and -n) which are used to specify the test configuration file and network configuration file.
+ 
+  You may also provide some sample configuration files with the test scripts to illustrate how to run an end-to-end test.
+    
+  New smart contracts may be needed to run the the new test case, `caliper/src/contract` folder is recommended to use to maintain those smart contracts.
+    
+* Add supporting for a new DLT
+  
+  You must implement a new class inherited from `BlockchainInterface` as the adaptor for the DLT. All source codes should be maintained in `fabrci/src`.",,2018-04-03 07:56:36,https://api.github.com/repos/hyperledger/caliper/pulls/comments/178730626,https://github.com/hyperledger/caliper/pull/14#discussion_r178730626,feihujiang
https://github.com/hyperledger/caliper/pull/14,https://github.com/hyperledger/caliper/pull/14,fixed,cc1ceb31b1f03b4a2a79534400cfe7c5876c7371,2018-04-03 07:58:15,178740793,"@@ -0,0 +1,48 @@
+## Contributing to Hyperledger Caliper
+
+Welcome to Hyperledger Caliper project, we are excited about the prospect of you contributing. 
+
+### How to contribute
+
+We are using GitHub issues for bug reports and feature requests.
+
+If you find any bug in the source code or have any trivial changes (such as typos fix, minor feature), you can raise an issue or delivery a fix via a pull request directly.
+
+If you have any enhancement suggestions or want to help extend caliper with more DLTs or have any other major changes, please start by opening an issue first.
+That way, relevant parties (e.g. maintainers or main contributors of the relevant subsystem) can have a chance to look at it before you do any work.
+
+All PRs must get at least one review, you can ask `hyperledger/caliper-committers` for review.
+Normally we will review your contribution in one week.
+If you haven't heard from anyone in one week, feel free to @ or mail a maintainer to review it.
+
+All PRs must be signed before be merged, be sure to use `git commit -s` to commit your changes.
+   
+There is also a [RocketChat Channel](https://chat.hyperledger.org/channel/caliper) for communication, anybody is welcome to join. 
+
+### Caliper Structure
+
+For beginners of Caliper, if you want to :
+
+* Create a new test case
+
+  You should create a new folder in`caliper/benchmark` directory and include all test scripts needed in this folder.
+  A `main.js` is needed as the bootstrap for the test case. You can simply copy it from `caliper/benchmark/simple/` directory or write a new one by yourself.
+  In the latter case, the command should as least accepts two arguments(-c and -n) which are used to specify the test configuration file and network configuration file.
+ 
+  You may also provide some sample configuration files with the test scripts to illustrate how to run an end-to-end test.
+    
+  New smart contracts may be needed to run the the new test case, `caliper/src/contract` folder is recommended to use to maintain those smart contracts.
+    
+* Add supporting for a new DLT
+  
+  You must implement a new class inherited from `BlockchainInterface` as the adaptor for the DLT. All source codes should be maintained in `fabrci/src`.",,2018-04-03 07:58:15,https://api.github.com/repos/hyperledger/caliper/pulls/comments/178740793,https://github.com/hyperledger/caliper/pull/14#discussion_r178740793,haojun
